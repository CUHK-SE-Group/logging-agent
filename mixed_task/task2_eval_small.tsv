without_logging_code_index	line_index	label
"public class A { <line0> void prepareDashboardData() { <line1> try { <line2> InsightsWorkflowType type = new InsightsWorkflowType(); <line3> type.setWorkflowType(WorkflowTaskEnum.WorkflowType.GRAFANADASHBOARDPDFREPORT.getValue()); <line4> workflowConfigDAL.saveWorkflowType(type); <line5> } catch (Exception e) { <line6> } <line7> try { <line8> String workflowTaskTest = <line9> ""    {\r\n"" <line10> + ""    \""description\"":\""GRAFANA_PDF_Execute\"",\r\n"" <line11> + ""    \""mqChannel\"":\""WORKFLOW.TASK.GRAFANAPDF.EXCECUTION\"",\r\n"" <line12> + ""    \""componentName\"":\""com.cognizant.devops.platformreports.assessment.core.GrafanaPDFExecutionSubscriber\"",\r\n"" <line13> + ""    \""dependency\"":\""0\"",\r\n"" <line14> + ""    \""workflowType\"":\""GRAFANADASHBOARDPDFREPORT\""\r\n"" <line15> + ""    }""; <line16> JsonObject workflowTaskJson = convertStringIntoJson(workflowTaskTest); <line17> int response = workflowService.saveWorkflowTask(workflowTaskJson); <line18> InsightsWorkflowTask tasks = <line19> workflowConfigDAL.getTaskbyTaskDescription( <line20> workflowTaskJson.get(""description"").getAsString()); <line21> taskID = tasks.getTaskId(); <line22> } catch (Exception e) { <line23> } <line24> try { <line25> String workflowTaskTest = <line26> ""{\r\n"" <line27> + ""   \""description\"":\""GRAFANA_PDF_EMAIL_Execute\"",\r\n"" <line28> + ""   \""mqChannel\"":\""WORKFLOW.TASK.GRAFANAPDFEMAIL.EXCECUTION\"",\r\n"" <line29> + ""   \""componentName\"":\""com.cognizant.devops.platformreports.assessment.core.GrafanaPDFEmailExecutionSubscriber\"",\r\n"" <line30> + ""   \""dependency\"":\""1\"",\r\n"" <line31> + ""   \""workflowType\"":\""GRAFANADASHBOARDPDFREPORT\""\r\n"" <line32> + ""}""; <line33> JsonObject workflowTaskJson = convertStringIntoJson(workflowTaskTest); <line34> int response = workflowService.saveWorkflowTask(workflowTaskJson); <line35> InsightsWorkflowTask tasks = <line36> workflowConfigDAL.getTaskbyTaskDescription( <line37> workflowTaskJson.get(""description"").getAsString()); <line38> relationTaskID = tasks.getTaskId(); <line39> } catch (Exception e) { <line40> } <line41> } <line42> } <line43> "	 <line6>	Yes
public class A { <line0> public static void addResource(Binder binder, Class<?> resourceClazz) { <line1> Multibinder.newSetBinder(binder, new TypeLiteral<Class<?>>() {}, JSR311Resource.class) <line2> .addBinding() <line3> .toInstance(resourceClazz); <line4> } <line5> } <line6> 	 <line2>	No
"public class A { <line0> @POST(path = ""/backend/admin/users/remove"", permission = ""admin:edit:user"") <line1> String removeUser(@BindRequest UserConfigRequest request) throws Exception { <line2> try { <line3> configRepository.deleteUserConfig(request.username().get()); <line4> } catch (CannotDeleteLastUserException e) { <line5> return ""{\""errorCannotDeleteLastUser\"":true}""; <line6> } <line7> return ""{}""; <line8> } <line9> } <line10> "	 <line7>	No
"public class A { <line0> @DeleteMapping(""/delete.json"") <line1> @AuthAction(PrivilegeType.WRITE_RULE) <line2> public Result<Long> apiDeleteFlowRule(Long id) { <line3> if (id == null) { <line4> return Result.ofFail(-1, ""id can't be null""); <line5> } <line6> FlowRuleEntity oldEntity = repository.findById(id); <line7> if (oldEntity == null) { <line8> return Result.ofSuccess(null); <line9> } <line10> try { <line11> repository.delete(id); <line12> } catch (Exception e) { <line13> return Result.ofFail(-1, e.getMessage()); <line14> } <line15> try { <line16> publishRules(oldEntity.getApp(), oldEntity.getIp(), oldEntity.getPort()) <line17> .get(5000, TimeUnit.MILLISECONDS); <line18> return Result.ofSuccess(id); <line19> } catch (Throwable t) { <line20> Throwable e = t instanceof ExecutionException ? t.getCause() : t; <line21> return Result.ofFail(-1, e.getMessage()); <line22> } <line23> } <line24> } <line25> "	 <line13>	No
public class A { <line0> @Override <line1> public void storeXMLResource(final Txn transaction, final DocumentImpl doc) { <line2> try (final VariableByteOutputStream os = new VariableByteOutputStream(256); <line3> final ManagedLock<ReentrantLock> collectionsDbLock = <line4> lockManager.acquireBtreeWriteLock(collectionsDb.getLockName())) { <line5> doc.write(os); <line6> final Value key = <line7> new CollectionStore.DocumentKey( <line8> doc.getCollection().getId(), doc.getResourceType(), doc.getDocId()); <line9> collectionsDb.put(transaction, key, os.data(), true); <line10> } catch (final LockException e) { <line11> } catch (final IOException e) { <line12> } <line13> } <line14> } <line15> 	 <line8>	No
"public class A { <line0> protected void checkNonSerializable(Object x, boolean strict) { <line1> ManagementContext mgmt = LocalManagementContextForTests.newInstance(); <line2> try { <line3> ObjectMapper mapper = BrooklynJacksonJsonProvider.newPrivateObjectMapper(mgmt); <line4> if (strict) BidiSerialization.setStrictSerialization(true); <line5> String tS = mapper.writeValueAsString(x); <line6> Assert.fail(""Should not have serialized "" + x + ""; instead gave: "" + tS); <line7> } catch (Exception e) { <line8> Exceptions.propagateIfFatal(e); <line9> } finally { <line10> if (strict) BidiSerialization.clearStrictSerialization(); <line11> Entities.destroyAll(mgmt); <line12> } <line13> } <line14> } <line15> "	 <line9>	Yes
"public class A { <line0> @Override <line1> public boolean onPortNumber(int portNumber) { <line2> try { <line3> Server server = null; <line4> XmlConfiguration lastXmlConfiguration = null; <line5> Object[] objs = new Object[jettyConfig.length]; <line6> Map<String, String> esProperties = jettySettings(bindHost, portNumber); <line7> for (int i = 0; i < jettyConfig.length; i++) { <line8> String configFile = jettyConfig[i]; <line9> URL config = environment.resolveConfig(configFile); <line10> XmlConfiguration xmlConfiguration = new XmlConfiguration(config); <line11> if (lastXmlConfiguration != null) { <line12> xmlConfiguration.getIdMap().putAll(lastXmlConfiguration.getIdMap()); <line13> } else { <line14> xmlConfiguration.getIdMap().put(""ESServerTransport"", JettyHttpServerTransport.this); <line15> xmlConfiguration.getIdMap().put(""ESClient"", client); <line16> } <line17> xmlConfiguration.getProperties().putAll(esProperties); <line18> objs[i] = xmlConfiguration.configure(); <line19> lastXmlConfiguration = xmlConfiguration; <line20> } <line21> Object serverObject = lastXmlConfiguration.getIdMap().get(jettyConfigServerId); <line22> if (serverObject != null) { <line23> if (serverObject instanceof Server) { <line24> server = (Server) serverObject; <line25> } <line26> } else { <line27> for (Object obj : objs) { <line28> if (obj instanceof Server) { <line29> server = (Server) obj; <line30> break; <line31> } <line32> } <line33> } <line34> if (server == null) { <line35> lastException.set( <line36> new ElasticsearchException(""Cannot find server with id "" + jettyConfigServerId)); <line37> return true; <line38> } <line39> server.setAttribute(TRANSPORT_ATTRIBUTE, JettyHttpServerTransport.this); <line40> for (Object obj : objs) { <line41> if (obj instanceof LifeCycle) { <line42> LifeCycle lifeCycle = (LifeCycle) obj; <line43> if (!lifeCycle.isRunning()) { <line44> lifeCycle.start(); <line45> } <line46> } <line47> } <line48> jettyServer = server; <line49> lastException.set(null); <line50> } catch (BindException e) { <line51> lastException.set(e); <line52> return false; <line53> } catch (Exception e) { <line54> lastException.set(e); <line55> return true; <line56> } <line57> return true; <line58> } <line59> } <line60> "	 <line6>	No
"public class A { <line0> protected List<Range<Long>> parseRangeHeader(String value) { <line1> Iterator<Range<Long>> i; <line2> String byteRangesSpecifier[], bytesUnit, byteRangeSet[]; <line3> List<Range<Long>> res; <line4> long lastEnd = -1; <line5> if (value == null) { <line6> return null; <line7> } <line8> res = new ArrayList<Range<Long>>(); <line9> byteRangesSpecifier = value.split(""=""); <line10> if (byteRangesSpecifier.length != 2) { <line11> return null; <line12> } <line13> bytesUnit = byteRangesSpecifier[0]; <line14> byteRangeSet = byteRangesSpecifier[1].split("",""); <line15> if (!bytesUnit.equals(""bytes"")) { <line16> return null; <line17> } <line18> for (String byteRangeSpec : byteRangeSet) { <line19> String[] bytePos; <line20> Long firstBytePos = null, lastBytePos = null; <line21> bytePos = byteRangeSpec.split(""-"", -1); <line22> try { <line23> if (bytePos[0].trim().length() > 0) { <line24> firstBytePos = Long.valueOf(bytePos[0].trim()); <line25> } <line26> if (bytePos[1].trim().length() > 0) { <line27> lastBytePos = Long.valueOf(bytePos[1].trim()); <line28> } <line29> } catch (NumberFormatException e) { <line30> } <line31> if ((firstBytePos == null) && (lastBytePos == null)) { <line32> return null; <line33> } else if (firstBytePos == null) { <line34> firstBytePos = length - lastBytePos; <line35> lastBytePos = length - 1; <line36> } else if (lastBytePos == null) { <line37> lastBytePos = length - 1; <line38> } <line39> if (firstBytePos > lastBytePos) { <line40> return null; <line41> } <line42> if (firstBytePos < 0) { <line43> return null; <line44> } <line45> if (lastBytePos >= length) { <line46> return null; <line47> } <line48> res.add(new Range<Long>(firstBytePos, lastBytePos)); <line49> } <line50> Collections.sort(res); <line51> i = res.listIterator(); <line52> while (i.hasNext()) { <line53> Range<Long> range; <line54> range = i.next(); <line55> if (lastEnd >= range.getStart()) { <line56> range.setStart(lastEnd + 1); <line57> if ((range.getStart() >= length) || (range.getStart() > range.getEnd())) { <line58> i.remove(); <line59> } else { <line60> lastEnd = range.getEnd(); <line61> } <line62> } else { <line63> lastEnd = range.getEnd(); <line64> } <line65> } <line66> if (res.isEmpty()) { <line67> return null; <line68> } else { <line69> return res; <line70> } <line71> } <line72> } <line73> "	 <line30>	Yes
"public class A { <line0> public void execute(final Activity activity) { <line1> ScopeType type = activity.getRecipientStreamScope().getScopeType(); <line2> String recipientUniqueKey = activity.getRecipientStreamScope().getUniqueKey(); <line3> long activityId = activity.getId(); <line4> if (type == ScopeType.PERSON) { <line5> PersonModelView person = getPersonModelViewByAccountIdMapper.execute(recipientUniqueKey); <line6> updateActivitiesByFollowingCacheLists(person.getEntityId(), activityId); <line7> } else if (type == ScopeType.RESOURCE && activity.getActorType() == EntityType.PERSON) { <line8> if (activity.getShowInStream()) { <line9> PersonModelView person = getPersonModelViewByAccountIdMapper.execute(activity.getActorId()); <line10> updateActivitiesByFollowingCacheLists(person.getEntityId(), activityId); <line11> } <line12> } else if (type == ScopeType.GROUP) { <line13> int donothing = 1; <line14> } else { <line15> throw new RuntimeException(""Unexpected Activity destination stream type: "" + type); <line16> } <line17> if (activity.getSharedLink() != null) { <line18> getCache() <line19> .addToTopOfList( <line20> CacheKeys.ENTITY_STREAM_BY_SCOPE_ID <line21> + activity.getSharedLink().getStreamScope().getId(), <line22> activityId); <line23> } <line24> if (activity.getShowInStream()) { <line25> getCache().addToTopOfList(CacheKeys.EVERYONE_ACTIVITY_IDS, activityId); <line26> } <line27> } <line28> } <line29> "	 <line25>	Yes
public class A { <line0> public void send(String message, int retryCount) { <line1> int count = 0; <line2> while (session == null && count < retryCount) { <line3> try { <line4> Thread.sleep(1000); <line5> } catch (InterruptedException e) { <line6> e.printStackTrace(); <line7> } <line8> count++; <line9> } <line10> if (session != null) { <line11> try { <line12> session.getBasicRemote().sendText(message); <line13> } catch (IOException e) { <line14> } <line15> } else { <line16> } <line17> } <line18> } <line19> 	 <line4>	Yes
public class A { <line0> @Override <line1> public synchronized void error(SchedulerDriver schedulerDriver, String s) { <line2> } <line3> } <line4> 	 <line0>	No
"public class A { <line0> @Test <line1> public void test_12() { <line2> throw new RuntimeException(""Unimplemented test""); <line3> } <line4> } <line5> "	 <line2>	Yes
public class A { <line0> @Override <line1> public CompletableFuture<Void> leave(final Node localNode) { <line2> return CompletableFuture.completedFuture(null); <line3> } <line4> } <line5> 	 <line3>	No
"public class A { <line0> @Override <line1> public void removeBpmWidgetInfo(String pageCode) { <line2> PreparedStatement stat = null; <line3> Connection conn = null; <line4> try { <line5> conn = this.getConnection(); <line6> conn.setAutoCommit(false); <line7> this.removeBpmWidgetInfoByPageCode(pageCode, conn); <line8> conn.commit(); <line9> } catch (Throwable t) { <line10> this.executeRollback(conn); <line11> throw new RuntimeException(""Error deleting bpmWidgetInfo"", t); <line12> } finally { <line13> this.closeDaoResources(null, stat, conn); <line14> } <line15> } <line16> } <line17> "	 <line8>	No
public class A { <line0> public DDMFormInstance getFormInstance() { <line1> if (_ddmFormInstance != null) { <line2> return _ddmFormInstance; <line3> } <line4> try { <line5> _ddmFormInstance = _ddmFormInstanceService.fetchFormInstance(getFormInstanceId()); <line6> } catch (PortalException portalException) { <line7> if (_log.isDebugEnabled()) { <line8> } <line9> return null; <line10> } <line11> return _ddmFormInstance; <line12> } <line13> } <line14> 	 <line8>	Yes
"public class A { <line0> protected void resetCacheMap(Collection<?> resources) { <line1> Collection<String> toDelete = Collections.emptySet(); <line2> synchronized (cacheMap) { <line3> if (cacheMap.size() <= 0) { <line4> return; <line5> } <line6> if (GenericUtils.isEmpty(resources)) { <line7> cacheMap.clear(); <line8> return; <line9> } <line10> for (Object r : resources) { <line11> String resourceKey = <line12> ValidateUtils.checkNotNullAndNotEmpty( <line13> Objects.toString(r, null), ""No resource key value""); <line14> if (cacheMap.containsKey(resourceKey)) { <line15> continue; <line16> } <line17> if (toDelete.isEmpty()) { <line18> toDelete = new TreeSet<>(String.CASE_INSENSITIVE_ORDER); <line19> } <line20> if (!toDelete.add(resourceKey)) { <line21> continue; <line22> } <line23> } <line24> if (GenericUtils.size(toDelete) > 0) { <line25> toDelete.forEach(cacheMap::remove); <line26> } <line27> } <line28> if (log.isDebugEnabled()) { <line29> } <line30> } <line31> } <line32> "	 <line29>	Yes
"public class A { <line0> @Override <line1> public boolean updateState( <line2> com.cloud.storage.Volume.State currentState, <line3> Event event, <line4> com.cloud.storage.Volume.State nextState, <line5> Volume vo, <line6> Object data) { <line7> Long oldUpdated = vo.getUpdatedCount(); <line8> Date oldUpdatedTime = vo.getUpdated(); <line9> SearchCriteria<VolumeVO> sc = AllFieldsSearch.create(); <line10> sc.setParameters(""id"", vo.getId()); <line11> sc.setParameters(""state"", currentState); <line12> sc.setParameters(""updatedCount"", vo.getUpdatedCount()); <line13> vo.incrUpdatedCount(); <line14> UpdateBuilder builder = getUpdateBuilder(vo); <line15> builder.set(vo, ""state"", nextState); <line16> builder.set(vo, ""updated"", new Date()); <line17> int rows = update((VolumeVO) vo, sc); <line18> if (rows == 0 && s_logger.isDebugEnabled()) { <line19> VolumeVO dbVol = findByIdIncludingRemoved(vo.getId()); <line20> if (dbVol != null) { <line21> StringBuilder str = new StringBuilder(""Unable to update "").append(vo.toString()); <line22> str.append("": DB Data={id="") <line23> .append(dbVol.getId()) <line24> .append(""; state="") <line25> .append(dbVol.getState()) <line26> .append(""; updatecount="") <line27> .append(dbVol.getUpdatedCount()) <line28> .append("";updatedTime="") <line29> .append(dbVol.getUpdated()); <line30> str.append("": New Data={id="") <line31> .append(vo.getId()) <line32> .append(""; state="") <line33> .append(nextState) <line34> .append(""; event="") <line35> .append(event) <line36> .append(""; updatecount="") <line37> .append(vo.getUpdatedCount()) <line38> .append(""; updatedTime="") <line39> .append(vo.getUpdated()); <line40> str.append("": stale Data={id="") <line41> .append(vo.getId()) <line42> .append(""; state="") <line43> .append(currentState) <line44> .append(""; event="") <line45> .append(event) <line46> .append(""; updatecount="") <line47> .append(oldUpdated) <line48> .append(""; updatedTime="") <line49> .append(oldUpdatedTime); <line50> } else { <line51> } <line52> } <line53> return rows > 0; <line54> } <line55> } <line56> "	 <line51>	Yes
public class A { <line0> public void setAllowMultipleDns(final boolean b) { <line1> allowMultipleDns = b; <line2> } <line3> } <line4> 	 <line0>	No
"public class A { <line0> public void updateChannelConfiguration( <line1> User userContext, <line2> UpdateChannelConfiguration updateChannelConfiguration, <line3> Orderer orderer, <line4> byte[]... signers) <line5> throws TransactionException, InvalidArgumentException { <line6> checkChannelState(); <line7> checkOrderer(orderer); <line8> User.userContextCheck(userContext); <line9> try { <line10> final long startLastConfigIndex = <line11> getLastConfigIndex(newTransactionContext(userContext), orderer); <line12> sendUpdateChannel( <line13> userContext, <line14> updateChannelConfiguration.getUpdateChannelConfigurationAsBytes(), <line15> signers, <line16> orderer); <line17> long currentLastConfigIndex = -1; <line18> final long nanoTimeStart = System.nanoTime(); <line19> do { <line20> currentLastConfigIndex = getLastConfigIndex(newTransactionContext(userContext), orderer); <line21> if (currentLastConfigIndex == startLastConfigIndex) { <line22> final long duration = <line23> TimeUnit.MILLISECONDS.convert( <line24> System.nanoTime() - nanoTimeStart, TimeUnit.NANOSECONDS); <line25> if (duration > CHANNEL_CONFIG_WAIT_TIME) { <line26> currentLastConfigIndex = startLastConfigIndex - 1L; <line27> } else { <line28> try { <line29> Thread.sleep(ORDERER_RETRY_WAIT_TIME); <line30> } catch (InterruptedException e) { <line31> TransactionException te = new TransactionException(""update channel thread Sleep"", e); <line32> } <line33> } <line34> } <line35> } while (currentLastConfigIndex == startLastConfigIndex); <line36> } catch (TransactionException e) { <line37> throw e; <line38> } catch (Exception e) { <line39> String msg = format(""Channel %s error: %s"", name, e.getMessage()); <line40> throw new TransactionException(msg, e); <line41> } <line42> } <line43> } <line44> "	 <line3>	No
public class A { <line0> private void retrieveAndSetAttachmentContent(final MutableAttachment attachment) <line1> throws Exception { <line2> final StringBuilder sb = new StringBuilder(); <line3> sb.append(attachment.getBaseUrl()) <line4> .append(attachment.getUrlContext()) <line5> .append(attachment.getDownloadUrl()); <line6> final String url = sanitizeUrl(sb.toString()); <line7> final HttpGet httpGet = createGetRequest(url); <line8> try (CloseableHttpResponse response = executeRequest(httpGet); ) { <line9> attachment.setLength(response.getEntity().getContentLength()); <line10> final byte[] byteContent = IOUtils.toByteArray(response.getEntity().getContent()); <line11> EntityUtils.consumeQuietly(response.getEntity()); <line12> attachment.setContentStream(new ByteArrayInputStream(byteContent)); <line13> } catch (final Exception e) { <line14> throw e; <line15> } <line16> } <line17> } <line18> 	 <line7>	Yes
"public class A { <line0> private void parseMultipleOccupancyGroupStatus(JsonObject messageBody) { <line1> List<OccupancyGroupStatus> statusList = <line2> parseBodyMultiple(messageBody, ""OccupancyGroupStatuses"", OccupancyGroupStatus.class); <line3> for (OccupancyGroupStatus status : statusList) { <line4> int groupNumber = status.getOccupancyGroup(); <line5> if (groupNumber > 0) { <line6> callback.handleGroupUpdate(groupNumber, status.occupancyStatus); <line7> } <line8> } <line9> } <line10> } <line11> "	 <line1>	Yes
"public class A { <line0> public static List<NamedAggregationOperator> loadOperators( <line1> final NodeSettingsRO settings, final DataTableSpec spec) throws InvalidSettingsException { <line2> final String[] resultColNames = settings.getStringArray(CNFG_RESULT_COL_NAMES); <line3> final String[] aggrMethods = settings.getStringArray(CNFG_AGGR_METHODS); <line4> final boolean[] inclMissingVals = settings.getBooleanArray(CNFG_INCL_MISSING_VALS); <line5> final List<NamedAggregationOperator> colAggrList = new LinkedList<>(); <line6> if (aggrMethods.length != resultColNames.length) { <line7> throw new InvalidSettingsException( <line8> ""Name array and "" + ""aggregation method array should be of equal size""); <line9> } <line10> for (int i = 0, length = aggrMethods.length; i < length; i++) { <line11> final String resultColName = resultColNames[i]; <line12> final AggregationMethod method = AggregationMethods.getMethod4Id(aggrMethods[i]); <line13> final boolean inclMissingVal = inclMissingVals[i]; <line14> NamedAggregationOperator operator = <line15> new NamedAggregationOperator(resultColName, method, inclMissingVal); <line16> if (operator.hasOptionalSettings()) { <line17> try { <line18> NodeSettingsRO operatorSettings = settings.getNodeSettings(createSettingsKey(operator)); <line19> if (spec != null) { <line20> operator.loadSettingsFrom(operatorSettings, spec); <line21> } else { <line22> operator.loadValidatedSettings(operatorSettings); <line23> } <line24> } catch (Exception e) { <line25> } <line26> } <line27> colAggrList.add(operator); <line28> } <line29> return colAggrList; <line30> } <line31> } <line32> "	 <line15>	No
public class A { <line0> @Override <line1> public void sendAccountRequest(RfAccountingRequest accountRequest) <line2> throws InternalException, IllegalStateException, RouteException, OverloadException { <line3> try { <line4> sendAndStateLock.lock(); <line5> handleEvent(new Event(accountRequest)); <line6> try { <line7> session.send(accountRequest.getMessage(), this); <line8> sessionData.setDestinationRealm( <line9> accountRequest <line10> .getMessage() <line11> .getAvps() <line12> .getAvp(Avp.DESTINATION_REALM) <line13> .getDiameterIdentity()); <line14> Avp destHostAvp = accountRequest.getMessage().getAvps().getAvp(Avp.DESTINATION_HOST); <line15> if (destHostAvp != null) { <line16> sessionData.setDestinationHost(destHostAvp.getDiameterIdentity()); <line17> } <line18> } catch (Throwable t) { <line19> handleEvent(new Event(Event.Type.FAILED_SEND_RECORD, accountRequest)); <line20> } <line21> } catch (Exception exc) { <line22> throw new InternalException(exc); <line23> } finally { <line24> sendAndStateLock.unlock(); <line25> } <line26> } <line27> } <line28> 	 <line19>	Yes
"public class A { <line0> @Override <line1> public MatchType getMatchType(RangerAccessResource resource, Map<String, Object> evalContext) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> MatchType ret = MatchType.NONE; <line5> RangerPerfTracer perf = null; <line6> if (RangerPerfTracer.isPerfTraceEnabled(PERF_POLICY_RESOURCE_MATCHER_MATCH_LOG)) { <line7> perf = <line8> RangerPerfTracer.getPerfTracer( <line9> PERF_POLICY_RESOURCE_MATCHER_MATCH_LOG, <line10> ""RangerDefaultPolicyResourceMatcher.getMatchType()""); <line11> } <line12> if (resource != null && policyResources != null) { <line13> int resourceKeysSize = resource.getKeys() == null ? 0 : resource.getKeys().size(); <line14> if (policyResources.size() == 0 && resourceKeysSize == 0) { <line15> ret = MatchType.SELF; <line16> } else { <line17> List<RangerResourceDef> hierarchy = getMatchingHierarchy(resource); <line18> if (CollectionUtils.isNotEmpty(hierarchy)) { <line19> int lastNonAnyMatcherIndex = -1; <line20> int matchersSize = 0; <line21> for (RangerResourceDef resourceDef : hierarchy) { <line22> RangerResourceMatcher matcher = getResourceMatcher(resourceDef.getName()); <line23> if (matcher != null) { <line24> if (!matcher.isMatchAny()) { <line25> lastNonAnyMatcherIndex = matchersSize; <line26> } <line27> matchersSize++; <line28> } else { <line29> break; <line30> } <line31> } <line32> if (resourceKeysSize == 0) { <line33> ret = MatchType.SELF; <line34> } <line35> for (RangerResourceDef resourceDef : hierarchy) { <line36> RangerResourceMatcher matcher = getResourceMatcher(resourceDef.getName()); <line37> Object resourceValue = resource.getValue(resourceDef.getName()); <line38> if (matcher != null) { <line39> if (resourceValue != null || matcher.isMatchAny()) { <line40> if (matcher.isMatch(resourceValue, evalContext)) { <line41> ret = MatchType.SELF; <line42> } else { <line43> ret = MatchType.NONE; <line44> break; <line45> } <line46> } <line47> } else { <line48> if (resourceValue != null) { <line49> ret = MatchType.ANCESTOR; <line50> } <line51> break; <line52> } <line53> } <line54> if (ret == MatchType.SELF && resourceKeysSize < policyResources.size()) { <line55> if (resourceKeysSize > lastNonAnyMatcherIndex) { <line56> ret = MatchType.SELF_AND_ALL_DESCENDANTS; <line57> } else { <line58> ret = MatchType.DESCENDANT; <line59> } <line60> } <line61> } <line62> } <line63> } <line64> RangerPerfTracer.log(perf); <line65> if (LOG.isDebugEnabled()) { <line66> } <line67> return ret; <line68> } <line69> } <line70> "	 <line66>	Yes
public class A { <line0> public static void pushAuthentication() { <line1> Authentication originalFullAuthentication = AuthenticationUtil.getFullAuthentication(); <line2> Authentication originalRunAsAuthentication = AuthenticationUtil.getRunAsAuthentication(); <line3> threadLocalFullAuthenticationStack.get().push(originalFullAuthentication); <line4> threadLocalRunAsAuthenticationStack.get().push(originalRunAsAuthentication); <line5> threadLocalTenantDomainStack.get().push(TenantContextHolder.getTenantDomain()); <line6> if (logger.isTraceEnabled()) { <line7> } <line8> } <line9> } <line10> 	 <line9>	No
"public class A { <line0> public synchronized void refresh() { <line1> initializing = false; <line2> List<SlotInfo> slotList = null; <line3> try { <line4> Socket s = getSocket(); <line5> s.getOutputStream().write((""slot-info\r\n"").getBytes()); <line6> socketReader.readLine(); <line7> JsonReader jr = new JsonReader(socketReader); <line8> jr.setLenient(true); <line9> Type slotListType = new TypeToken<List<SlotInfo>>() {}.getType(); <line10> slotList = gson.fromJson(jr, slotListType); <line11> } catch (IOException e) { <line12> disconnected(); <line13> return; <line14> } <line15> boolean running = false, finishing = true; <line16> for (SlotInfo si : slotList) { <line17> finishing &= ""FINISHING"".equals(si.status); <line18> running |= ""FINISHING"".equals(si.status) || ""RUNNING"".equals(si.status); <line19> SlotUpdateListener listener = slotUpdateListeners.get(si.id); <line20> if (listener != null) { <line21> listener.refreshed(si); <line22> } else { <line23> String host = (String) getThing().getConfiguration().get(""host""); <line24> FoldingDiscoveryProxy.getInstance() <line25> .newSlot(getThing().getUID(), host, si.id, si.description); <line26> } <line27> } <line28> updateState(getThing().getChannel(""run"").getUID(), running ? OnOffType.ON : OnOffType.OFF); <line29> updateState(getThing().getChannel(""finish"").getUID(), finishing ? OnOffType.ON : OnOffType.OFF); <line30> } <line31> } <line32> "	 <line23>	Yes
public class A { <line0> private void writeConfigFile(String tmpFileName, String dstFileName, StringBuilder sb) <line1> throws KuraException { <line2> File srcFile = new File(tmpFileName); <line3> File dstFile = new File(dstFileName); <line4> try (FileOutputStream fos = new FileOutputStream(srcFile); <line5> PrintWriter pw = new PrintWriter(fos)) { <line6> pw.write(sb.toString()); <line7> pw.flush(); <line8> fos.getFD().sync(); <line9> } catch (Exception e) { <line10> throw KuraException.internalError(e.getMessage()); <line11> } <line12> copyConfigFile(srcFile, dstFile); <line13> } <line14> } <line15> 	 <line10>	Yes
"public class A { <line0> @RequestMapping(value = ""/saveUserLocation"", method = RequestMethod.POST) <line1> public @ResponseBody boolean saveUserLocation( <line2> @RequestBody UserLocationVo userLocationVo, HttpServletRequest httpServletRequest) { <line3> boolean confirmation = false; <line4> String userId = GtasSecurityUtils.fetchLoggedInUserId(); <line5> if (userLocationVo.getAirport() == null || userLocationVo.getAirport().trim().isEmpty()) { <line6> return confirmation; <line7> } <line8> try { <line9> httpServletRequest <line10> .getSession() <line11> .setAttribute(Constants.USER_PRIMARY_LOCATION, userLocationVo.getAirport()); <line12> boolean result = <line13> userLocationService.updateUserPrimaryLocation(userId, userLocationVo.getAirport(), true); <line14> if (result) { <line15> confirmation = true; <line16> } else { <line17> confirmation = false; <line18> } <line19> } catch (Exception e) { <line20> } <line21> return confirmation; <line22> } <line23> } <line24> "	 <line17>	No
"public class A { <line0> @Override <line1> public void run() { <line2> while (true) { <line3> if (_destroy) { <line4> break; <line5> } <line6> ShellStatus shellStatus = _queue.poll(); <line7> if (shellStatus == null) { <line8> try { <line9> Thread.sleep(getThreadExecuteInterval()); <line10> } catch (InterruptedException interruptedException) { <line11> break; <line12> } <line13> continue; <line14> } <line15> System.out.println(""Queue size "" + _queue.size()); <line16> try { <line17> if (_log.isInfoEnabled()) { <line18> } <line19> execute(shellStatus); <line20> } catch (Exception exception) { <line21> } <line22> } <line23> _destroyed = true; <line24> } <line25> } <line26> "	 <line21>	Yes
"public class A { <line0> public String formatRevisionDisplay(final Revision revision) { <line1> final String defaultFormattedRevision = <line2> revision.getAuthor() + "" @ "" + revision.getDate() + "" ("" + revision.getRevision() + "")""; <line3> final ServletContext servletContext = pageContext.getServletContext(); <line4> final WebApplicationContext context = <line5> WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); <line6> try { <line7> final Map<String, DefinitionRevisionDisplayFormatter> formatterBeans = <line8> BeanFactoryUtils.beansOfTypeIncludingAncestors( <line9> context, DefinitionRevisionDisplayFormatter.class); <line10> if (formatterBeans.isEmpty()) { <line11> return StringEscapeUtils.escapeHtml4(defaultFormattedRevision); <line12> } else if (formatterBeans.size() == 1) { <line13> final DefinitionRevisionDisplayFormatter formatter = <line14> formatterBeans.values().iterator().next(); <line15> return formatter.formatRevision(revision); <line16> } else { <line17> throw new IllegalArgumentException( <line18> ""Multiple beans of type "" <line19> + DefinitionRevisionDisplayFormatter.class.getSimpleName() <line20> + "" found, expected 0 or 1.""); <line21> } <line22> } catch (final Exception e) { <line23> return defaultFormattedRevision; <line24> } <line25> } <line26> } <line27> "	 <line25>	No
"public class A { <line0> protected void addPublicContentSearchRecord(String id, IApsEntity entity, Connection conn) <line1> throws ApsSystemException { <line2> PreparedStatement stat = null; <line3> try { <line4> stat = conn.prepareStatement(ADD_CONTENT_SEARCH_RECORD); <line5> this.addEntitySearchRecord(id, entity, stat); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(""Error on adding public content search records"", t); <line8> } finally { <line9> closeDaoResources(null, stat); <line10> } <line11> } <line12> } <line13> "	 <line1>	No
"public class A { <line0> @Test <line1> public void testMinQuery() { <line2> BrokerRequest brokerRequest = getMinQuery(); <line3> QuerySource querySource = new QuerySource(); <line4> querySource.setTableName(""midas""); <line5> brokerRequest.setQuerySource(querySource); <line6> InstanceRequest instanceRequest = new InstanceRequest(0, brokerRequest); <line7> instanceRequest.setSearchSegments(new ArrayList<String>()); <line8> for (IndexSegment segment : _indexSegmentList) { <line9> instanceRequest.getSearchSegments().add(segment.getSegmentName()); <line10> } <line11> try { <line12> DataTable instanceResponse = _queryExecutor.processQuery(instanceRequest); <line13> Assert.assertEquals(instanceResponse.getDouble(0, 0), 0.0); <line14> } catch (Exception e) { <line15> e.printStackTrace(); <line16> Assert.assertEquals(true, false); <line17> } <line18> } <line19> } <line20> "	 <line13>	Yes
"public class A { <line0> public void setDescription(final String desc) { <line1> if (desc != null && !desc.isEmpty()) { <line2> if (MemoryUtils.isLowMemoryEnvironment()) { <line3> try (var connection = PooledDatabaseConnection.INSTANCE.getDataSource().getConnection(); <line4> var ignored = new SqlAutoSetAutoCommit(connection, false); <line5> var tm = new SqlAutoRollback(connection); <line6> var mergeStatement = <line7> connection.prepareStatement( <line8> ""MERGE INTO mediathekview.description KEY(ID) VALUES (?,?)"")) { <line9> mergeStatement.setInt(1, databaseFilmNumber); <line10> mergeStatement.setString(2, desc); <line11> mergeStatement.executeUpdate(); <line12> tm.commit(); <line13> } catch (SQLException ex) { <line14> } <line15> } else description = desc; <line16> } <line17> } <line18> } <line19> "	 <line14>	Yes
public class A { <line0> @Override <line1> public void onExpansionEvent(ExpansionEvent arg0) { <line2> } <line3> } <line4> 	 <line3>	No
"public class A { <line0> public static void fail(Exception e) { <line1> Assert.fail(""Failing because of exception.""); <line2> } <line3> } <line4> "	 <line0>	No
public class A { <line0> @Override <line1> public void createOrUpdateReadOnlyHivePolicy( <line2> String categoryName, <line3> String feedName, <line4> List<String> hadoopAuthorizationGroups, <line5> String datebaseName, <line6> List<String> tableNames) { <line7> if (this.sentryConnection.getKerberosTicketConfiguration().isKerberosEnabled()) { <line8> try { <line9> UserGroupInformation ugi = authenticatePolicyCreatorWithKerberos(); <line10> if (ugi == null) { <line11> } else { <line12> ugi.doAs( <line13> new PrivilegedExceptionAction<Void>() { <line14> @Override <line15> public Void run() throws Exception { <line16> String sentryPolicyName = getHivePolicyName(categoryName, feedName); <line17> if (!(sentryClientObject.checkIfRoleExists(sentryPolicyName))) { <line18> createReadOnlyHivePolicy( <line19> categoryName, <line20> feedName, <line21> hadoopAuthorizationGroups, <line22> datebaseName, <line23> tableNames); <line24> } else { <line25> try { <line26> updateReadOnlyHivePolicy( <line27> categoryName, <line28> feedName, <line29> hadoopAuthorizationGroups, <line30> datebaseName, <line31> tableNames); <line32> } catch (Exception e) { <line33> throw new RuntimeException(e); <line34> } <line35> } <line36> return null; <line37> } <line38> }); <line39> } <line40> } catch (Exception e) { <line41> throw new RuntimeException(e); <line42> } <line43> } else { <line44> String sentryPolicyName = getHivePolicyName(categoryName, feedName); <line45> if (!(sentryClientObject.checkIfRoleExists(sentryPolicyName))) { <line46> createReadOnlyHivePolicy( <line47> categoryName, feedName, hadoopAuthorizationGroups, datebaseName, tableNames); <line48> } else { <line49> try { <line50> updateReadOnlyHivePolicy( <line51> categoryName, feedName, hadoopAuthorizationGroups, datebaseName, tableNames); <line52> } catch (Exception e) { <line53> throw new RuntimeException(e); <line54> } <line55> } <line56> } <line57> } <line58> } <line59> 	 <line51>	No
public class A { <line0> @Override <line1> public void cancel(ServiceContext ctx) { <line2> clusterMgr.stopClusterIfExists(clusterId); <line3> } <line4> } <line5> 	 <line2>	No
"public class A { <line0> public void connect(VertxWebsocketConsumer consumer) { <line1> VertxWebsocketEndpoint endpoint = consumer.getEndpoint(); <line2> VertxWebsocketConfiguration configuration = endpoint.getConfiguration(); <line3> Router router = hostConfiguration.getRouter(); <line4> Route route = router.route(configuration.getPath()); <line5> if (!ObjectHelper.isEmpty(configuration.getAllowedOriginPattern())) { <line6> CorsHandler corsHandler = CorsHandler.create(configuration.getAllowedOriginPattern()); <line7> route.handler(corsHandler); <line8> } <line9> route.handler( <line10> routingContext -> { <line11> HttpServerRequest request = routingContext.request(); <line12> String connectionHeader = request.headers().get(HttpHeaders.CONNECTION); <line13> if (connectionHeader == null || !connectionHeader.toLowerCase().contains(""upgrade"")) { <line14> routingContext.response().setStatusCode(400); <line15> routingContext.response().end(""Can \""Upgrade\"" only to \""WebSocket\"".""); <line16> } else { <line17> final boolean parseEnded = request.isEnded(); <line18> if (!parseEnded) { <line19> request.pause(); <line20> } <line21> request.toWebSocket( <line22> toWebSocket -> { <line23> if (toWebSocket.succeeded()) { <line24> if (!parseEnded) { <line25> request.resume(); <line26> } <line27> ServerWebSocket webSocket = toWebSocket.result(); <line28> SocketAddress socketAddress = webSocket.localAddress(); <line29> SocketAddress remote = webSocket.remoteAddress(); <line30> String connectionKey = UUID.randomUUID().toString(); <line31> connectedPeers.put(connectionKey, webSocket); <line32> if (LOG.isDebugEnabled()) { <line33> if (socketAddress != null) { <line34> } <line35> } <line36> webSocket.textMessageHandler( <line37> message -> consumer.onMessage(connectionKey, message, remote)); <line38> webSocket.binaryMessageHandler( <line39> message -> consumer.onMessage(connectionKey, message.getBytes(), remote)); <line40> webSocket.exceptionHandler( <line41> exception -> consumer.onException(connectionKey, exception, remote)); <line42> webSocket.closeHandler( <line43> closeEvent -> { <line44> if (LOG.isDebugEnabled()) { <line45> if (socketAddress != null) { <line46> } <line47> } <line48> connectedPeers.remove(connectionKey); <line49> }); <line50> } else { <line51> routingContext.fail(toWebSocket.cause()); <line52> } <line53> }); <line54> } <line55> }); <line56> routeRegistry.put(configuration.getPath(), route); <line57> } <line58> } <line59> "	 <line40>	No
"public class A { <line0> public NettyClient borrowObject() throws BorrowObjectException { <line1> try { <line2> return objectPool.borrowObject(); <line3> } catch (Exception e) { <line4> throw new BorrowObjectException(""borrow "" + factory, e); <line5> } <line6> } <line7> } <line8> "	 <line4>	Yes
"public class A { <line0> protected void update(String body, String contentType) throws Exception { <line1> Gson gson = <line2> new GsonBuilder() <line3> .registerTypeAdapter(EnvironmentId.class, new EnvironmentIdSerializer()) <line4> .registerTypeAdapter(EnvironmentId.class, new EnvironmentIdDeserializer()) <line5> .create(); <line6> String json = httpPatch(ENV_PATH + ""/"" + ENV_NAME, body, contentType); <line7> JsonResponse jsonResponse = gson.fromJson(json, JsonResponse.class); <line8> Assert.assertEquals(Response.Status.OK.getStatusCode(), jsonResponse.getCode()); <line9> Environment env = gson.fromJson(gson.toJson(jsonResponse.getResult()), Environment.class); <line10> verifyUpdateEnvironmentApiResult(env); <line11> } <line12> } <line13> "	 <line6>	Yes
"public class A { <line0> @Override <line1> void onPreviousNodeFail() { <line2> joinErrorWatcher.checkJoinError(); <line3> if (rtState.errForClose != null || rtState.joined) return; <line4> synchronized (stateMux) { <line5> if (connState != STARTED) return; <line6> } <line7> localNodeFail(""Local node was forced to stop."", true); <line8> } <line9> } <line10> "	 <line1>	No
"public class A { <line0> @Test <line1> public void testFileToCxfMessageDataFormat() throws Exception { <line2> MockEndpoint mock = getMockEndpoint(""mock:result""); <line3> mock.expectedMessageCount(1); <line4> template.sendBodyAndHeader( <line5> ""file:target/filetocxf"", createBody(), Exchange.FILE_NAME, ""payload.xml""); <line6> assertMockEndpointsSatisfied(); <line7> String out = mock.getReceivedExchanges().get(0).getIn().getBody(String.class); <line8> assertNotNull(out); <line9> assertTrue(out.contains(""echo Camel""), ""Should invoke the echo operation""); <line10> } <line11> } <line12> "	 <line2>	No
public class A { <line0> protected static void writeError(String msg) { <line1> if (LOG.isErrorEnabled()) { <line2> } <line3> } <line4> } <line5> 	 <line1>	No
public class A { <line0> private void endOfTestHook(ITestResult result, RunResult outcome) { <line1> NDC.pop(); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> private void processDispose(final String cacheName, final long requesterId) throws IOException { <line1> final CacheListeners<K, V> cacheDesc = cacheListenersMap.get(cacheName); <line2> if (cacheDesc != null) { <line3> synchronized (cacheDesc) { <line4> final ICacheEventQueue<K, V>[] qlist = getEventQList(cacheDesc, requesterId); <line5> for (final ICacheEventQueue<K, V> element : qlist) { <line6> element.addDisposeEvent(); <line7> } <line8> cacheManager.freeCache(cacheName); <line9> } <line10> } <line11> } <line12> } <line13> 	 <line3>	No
public class A { <line0> @Override <line1> public DocumentDTO addDocument(DocumentDTO doc) { <line2> try { <line3> Document d = doc.toEntity(); <line4> em.persist(d); <line5> em.flush(); <line6> em.refresh(d); <line7> return new DocumentDTO(d); <line8> } catch (Exception e) { <line9> return null; <line10> } <line11> } <line12> } <line13> 	 <line1>	No
"public class A { <line0> @Override <line1> protected synchronized Namespace createOrGetNamespace(final String name, Boolean create) { <line2> Project project = client.projects().withName(name).get(); <line3> ExitCondition projectReady = <line4> new ExitCondition() { <line5> @Override <line6> public Boolean call() { <line7> Project actualProject = client.projects().withName(name).get(); <line8> return actualProject != null <line9> && actualProject.getStatus().getPhase().equals(PHASE_ACTIVE); <line10> } <line11>  <line12> @Override <line13> public String getFailureMessage() { <line14> Project actualProject = client.projects().withName(name).get(); <line15> return ""Project for "" <line16> + name <line17> + "" "" <line18> + (actualProject == null ? ""absent"" : "" status "" + actualProject.getStatus()); <line19> } <line20> }; <line21> if (project != null) { <line22> } else if (create) { <line23> project = <line24> client <line25> .projects() <line26> .create(new ProjectBuilder().withNewMetadata().withName(name).endMetadata().build()); <line27> } else { <line28> throw new IllegalStateException( <line29> ""Project "" + name + "" does not exist and namespace.create is not set""); <line30> } <line31> waitForExitCondition(projectReady); <line32> return client.namespaces().withName(name).get(); <line33> } <line34> } <line35> "	 <line27>	Yes
"public class A { <line0> @Override <line1> public String JSON2(boolean isArray, boolean isEmbed) { <line2> Map<String, String> valueMap = new HashMap<>(); <line3> valueMap.put( <line4> ""id"", <line5> null == resourceRecipe || null == resourceRecipe.getId() <line6> ? StringUtils.EMPTY <line7> : String.valueOf(resourceRecipe.getId())); <line8> valueMap.put( <line9> ""action"", <line10> null == resourceRecipe || null == resourceRecipe.getAction() <line11> ? StringUtils.EMPTY <line12> : resourceRecipe.getAction()); <line13> valueMap.put( <line14> ""orchestrationUri"", <line15> null == resourceRecipe || null == resourceRecipe.getOrchestrationUri() <line16> ? StringUtils.EMPTY <line17> : resourceRecipe.getOrchestrationUri()); <line18> valueMap.put( <line19> ""recipeTimeout"", <line20> null == resourceRecipe || null == resourceRecipe.getRecipeTimeout() <line21> ? StringUtils.EMPTY <line22> : String.valueOf(resourceRecipe.getRecipeTimeout())); <line23> valueMap.put( <line24> ""paramXSD"", <line25> null == resourceRecipe || null == resourceRecipe.getParamXsd() <line26> ? StringUtils.EMPTY <line27> : resourceRecipe.getParamXsd()); <line28> valueMap.put( <line29> ""description"", <line30> null == resourceRecipe || null == resourceRecipe.getDescription() <line31> ? StringUtils.EMPTY <line32> : resourceRecipe.getDescription()); <line33> ObjectMapper mapper = new ObjectMapper(); <line34> mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, false); <line35> String jsonStr = """"; <line36> try { <line37> jsonStr = mapper.writeValueAsString(valueMap); <line38> } catch (JsonProcessingException e) { <line39> } <line40> return jsonStr; <line41> } <line42> } <line43> "	 <line39>	Yes
public class A { <line0> @Override <line1> public void newReport(final Report report) { <line2> final DateTime timeOfEntry = this.getTimeOfEntry(report); <line3> final String reportDescription = this.getReportDescription(report, timeOfEntry); <line4> if (Boolean.TRUE.equals(report.getBufOvfl())) { <line5> } <line6> if (this.firstNewSqNum != null <line7> && report.getSqNum() != null <line8> && report.getSqNum() < this.firstNewSqNum) { <line9> } <line10> this.logReportDetails(report); <line11> if (CollectionUtils.isEmpty(report.getValues())) { <line12> return; <line13> } <line14> final Map<LightMeasurementDevice, FcModelNode> reportMemberPerDevice = <line15> this.processReportedDataForLightMeasurementDevices(report.getValues()); <line16> for (final LightMeasurementDevice lmd : reportMemberPerDevice.keySet()) { <line17> final String deviceIdentification = lmd.getDeviceIdentification(); <line18> final Short index = lmd.getDigitalInput(); <line19> final FcModelNode member = reportMemberPerDevice.get(lmd); <line20> final EventNotificationDto eventNotification = <line21> this.getEventNotificationForReportedData( <line22> member, timeOfEntry, reportDescription, deviceIdentification, index.intValue()); <line23> try { <line24> this.deviceManagementService.addEventNotifications( <line25> deviceIdentification, Arrays.asList(eventNotification)); <line26> } catch (final ProtocolAdapterException pae) { <line27> } <line28> } <line29> } <line30> } <line31> 	 <line9>	Yes
"public class A { <line0> public List findByExample(StgMbGefaehrskat instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.StgMbGefaehrskat"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line12>	No
public class A { <line0> @JsxFunction <line1> public boolean confirm(final String message) { <line2> final ConfirmHandler handler = getWebWindow().getWebClient().getConfirmHandler(); <line3> if (handler == null) { <line4> if (LOG.isWarnEnabled()) { <line5> } <line6> return true; <line7> } <line8> return handler.handleConfirm(document_.getPage(), message); <line9> } <line10> } <line11> 	 <line8>	No
"public class A { <line0> boolean isValidDataMaskTypes( <line1> Long serviceDefId, <line2> List<RangerDataMaskTypeDef> dataMaskTypes, <line3> List<ValidationFailureDetails> failures, <line4> final Action action) { <line5> if (LOG.isDebugEnabled()) { <line6> } <line7> boolean valid = true; <line8> if (CollectionUtils.isEmpty(dataMaskTypes)) { <line9> } else { <line10> Map<Long, String> existingDataMaskTypeIDNameMap = new HashMap<>(); <line11> if (action == Action.UPDATE) { <line12> List<RangerDataMaskTypeDef> existingDataMaskTypes = <line13> this.getServiceDef(serviceDefId).getDataMaskDef().getMaskTypes(); <line14> for (RangerDataMaskTypeDef existingDataMaskType : existingDataMaskTypes) { <line15> existingDataMaskTypeIDNameMap.put( <line16> existingDataMaskType.getItemId(), existingDataMaskType.getName()); <line17> } <line18> } <line19> if (LOG.isDebugEnabled()) { <line20> } <line21> Set<Long> ids = new HashSet<Long>(); <line22> Set<String> names = new HashSet<String>(); <line23> for (RangerDataMaskTypeDef dataMaskType : dataMaskTypes) { <line24> String name = dataMaskType.getName(); <line25> Long itemId = dataMaskType.getItemId(); <line26> valid = <line27> isUnique(itemId, ids, ""data mask type def itemId"", ""data mask type defs"", failures) <line28> && valid; <line29> valid = <line30> isUnique(name, names, ""data mask type def name"", ""data mask type defs"", failures) <line31> && valid; <line32> if (action == Action.UPDATE) { <line33> if (existingDataMaskTypeIDNameMap.get(itemId) != null <line34> && !existingDataMaskTypeIDNameMap.get(itemId).equals(name)) { <line35> ValidationErrorCode error; <line36> error = ValidationErrorCode.SERVICE_DEF_VALIDATION_ERR_SERVICE_DEF_NAME_CONFICT; <line37> failures.add( <line38> (new ValidationFailureDetailsBuilder()) <line39> .field(""data mask type def name"") <line40> .isSemanticallyIncorrect() <line41> .errorCode(error.getErrorCode()) <line42> .becauseOf( <line43> String.format( <line44> ""changing %s[%s] in %s is not supported"", <line45> ""data mask type def name"", name, ""data mask type defs"")) <line46> .build()); <line47> valid = false; <line48> } <line49> } <line50> } <line51> } <line52> if (LOG.isDebugEnabled()) { <line53> } <line54> return valid; <line55> } <line56> } <line57> "	 <line19>	No
public class A { <line0> public static boolean deleteFileIfExistsQuietly(Path file) { <line1> try { <line2> return Files.deleteIfExists(file); <line3> } catch (IOException e) { <line4> } <line5> return false; <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> public void run() { <line1> try { <line2> String[] fields = ""c0,c1,c2,c3,c4,c5"".split("",""); <line3> Object[] expected = new Object[] {1, 1, 1, 1, 1, 1}; <line4> while (!shutdown) { <line5> env.sendEventBean(new SupportBean_S0(0)); <line6> EventBean event = listener.assertOneGetNewAndReset(); <line7> if (event.get(""c0"") == null) { <line8> notFoundCount++; <line9> } else { <line10> foundCount++; <line11> EPAssertionUtil.assertProps(event, fields, expected); <line12> } <line13> numQueries++; <line14> } <line15> } catch (RuntimeException ex) { <line16> exception = ex; <line17> } <line18> } <line19> } <line20> "	 <line16>	Yes
"public class A { <line0> @Override <line1> public DistrictInfo extractData(ResultSet rs) throws SQLException { <line2> DistrictInfo districtInfo = new DistrictInfo(); <line3> while (rs.next()) { <line4> DistrictType type = DistrictType.resolveType(rs.getString(""type"")); <line5> if (type != null) { <line6> districtInfo.setDistName(type, rs.getString(""name"")); <line7> districtInfo.setDistCode(type, getDistrictCode(rs)); <line8> districtInfo.setDistMap(type, getDistrictMapFromJson(rs.getString(""map""))); <line9> districtInfo.setDistProximity(type, rs.getDouble(""proximity"")); <line10> } else { <line11> } <line12> } <line13> return districtInfo; <line14> } <line15> } <line16> "	 <line8>	No
"public class A { <line0> @Test <line1> public void testRecoveryOnTransactionalAndPartitionedCache() throws Exception { <line2> IgniteEx ignite = (IgniteEx) startGrids(3); <line3> ignite.cluster().active(true); <line4> final String cacheName = ""transactional""; <line5> CacheConfiguration<Object, Object> cacheConfiguration = <line6> new CacheConfiguration<>(cacheName) <line7> .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL) <line8> .setAffinity(new RendezvousAffinityFunction(false, 32)) <line9> .setCacheMode(CacheMode.PARTITIONED) <line10> .setRebalanceMode(CacheRebalanceMode.SYNC) <line11> .setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_SYNC) <line12> .setBackups(2); <line13> ignite.createCache(cacheConfiguration); <line14> IgniteCache<Object, Object> cache = ignite.cache(cacheName); <line15> Map<Object, Object> map = new HashMap<>(); <line16> final int transactions = 100; <line17> final int operationsPerTransaction = 40; <line18> Random random = new Random(); <line19> for (int t = 1; t <= transactions; t++) { <line20> Transaction tx = <line21> ignite <line22> .transactions() <line23> .txStart(TransactionConcurrency.OPTIMISTIC, TransactionIsolation.READ_COMMITTED); <line24> Map<Object, Object> changesInTransaction = new HashMap<>(); <line25> for (int op = 0; op < operationsPerTransaction; op++) { <line26> int key = random.nextInt(1000) + 1; <line27> Object value = random.nextBoolean() ? randomString(random) + key : new BigObject(key); <line28> changesInTransaction.put(key, value); <line29> cache.put(key, value); <line30> } <line31> if (random.nextBoolean()) { <line32> tx.commit(); <line33> map.putAll(changesInTransaction); <line34> } else { <line35> tx.rollback(); <line36> } <line37> } <line38> stopAllGrids(); <line39> ignite = (IgniteEx) startGrids(3); <line40> ignite.cluster().active(true); <line41> cache = ignite.cache(cacheName); <line42> for (Object key : map.keySet()) { <line43> Object expectedValue = map.get(key); <line44> Object actualValue = cache.get(key); <line45> Assert.assertEquals(""Unexpected value for key "" + key, expectedValue, actualValue); <line46> } <line47> } <line48> } <line49> "	 <line37>	Yes
"public class A { <line0> @Override <line1> @FederationEnabled <line2> public List<CollectionAndDataObjectListingEntry> listDataObjectsUnderPathWithPermissions( <line3> final String absolutePathToParent, <line4> final int partialStartIndex, <line5> final boolean usingOracleSyntax) <line6> throws FileNotFoundException, JargonException { <line7> if (absolutePathToParent == null) { <line8> throw new JargonException(""absolutePathToParent is null""); <line9> } <line10> final ObjStat objStat = <line11> retrieveObjectStatForPathWithHeuristicPathGuessing(absolutePathToParent); <line12> if (objStat == null) { <line13> throw new FileNotFoundException(""unable to find objStat for collection""); <line14> } <line15> return listDataObjectsUnderPathWithPermissionsCheckingIfSpecQueryUsed( <line16> absolutePathToParent, partialStartIndex, objStat, usingOracleSyntax); <line17> } <line18> } <line19> "	 <line11>	No
public class A { <line0> @Override <line1> public void activateObject(PooledObject<LdapConnection> pooledObject) throws LdapException { <line2> LdapConnection connection = pooledObject.getObject(); <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> super.activateObject(pooledObject); <line6> ((MonitoringLdapConnection) connection).resetMonitors(); <line7> } <line8> } <line9> 	 <line1>	No
"public class A { <line0> @SuppressWarnings(""squid:S3776"") <line1> public RestorableTsFileIOWriter recover( <line2> boolean needRedoWal, Supplier<ByteBuffer[]> supplier, Consumer<ByteBuffer[]> consumer) <line3> throws StorageGroupProcessorException { <line4> File file = FSFactoryProducer.getFSFactory().getFile(filePath); <line5> if (!file.exists()) { <line6> return null; <line7> } <line8> RestorableTsFileIOWriter restorableTsFileIOWriter; <line9> try { <line10> restorableTsFileIOWriter = new RestorableTsFileIOWriter(file); <line11> } catch (NotCompatibleTsFileException e) { <line12> boolean result = file.delete(); <line13> throw new StorageGroupProcessorException(e); <line14> } catch (IOException e) { <line15> throw new StorageGroupProcessorException(e); <line16> } <line17> if (!restorableTsFileIOWriter.hasCrashed()) { <line18> try { <line19> recoverResource(); <line20> return restorableTsFileIOWriter; <line21> } catch (IOException e) { <line22> throw new StorageGroupProcessorException( <line23> ""recover the resource file failed: "" + filePath + RESOURCE_SUFFIX + e); <line24> } <line25> } <line26> recoverResourceFromWriter(restorableTsFileIOWriter); <line27> if (needRedoWal) { <line28> redoLogs(restorableTsFileIOWriter, supplier); <line29> try { <line30> MultiFileLogNodeManager.getInstance() <line31> .deleteNode( <line32> logNodePrefix + SystemFileFactory.INSTANCE.getFile(filePath).getName(), consumer); <line33> } catch (IOException e) { <line34> throw new StorageGroupProcessorException(e); <line35> } <line36> } <line37> return restorableTsFileIOWriter; <line38> } <line39> } <line40> "	 <line29>	No
public class A { <line0> @Override <line1> public ResponseEntity<PagedRestResponse<ResourceDTO>> listTrashedResources( <line2> String resourceTypeCode, RestListRequest requestList) { <line3> UserDetails userDetails = HttpSessionHelper.extractCurrentUser(httpSession); <line4> PagedMetadata<ResourceDTO> result = <line5> resourcesVersioningService.getTrashedResources(resourceTypeCode, requestList, userDetails); <line6> return new ResponseEntity<>(new PagedRestResponse<>(result), HttpStatus.OK); <line7> } <line8> } <line9> 	 <line0>	No
public class A { <line0> @Override <line1> public void run() { <line2> putMsg.resetRecipients(); <line3> putMsg.setRecipient(msg.getSender()); <line4> putMsg.setSendDelta(false); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> dm.putOutgoing(putMsg); <line8> try { <line9> PartitionedRegion.getPRFromId(putMsg.regionId).getCachePerfStats().incDeltaFullValuesSent(); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	 <line4>	No
"public class A { <line0> protected boolean doSafePollSubDirectory( <line1> String absolutePath, String dirName, List<GenericFile<T>> fileList, int depth) { <line2> try { <line3> return doPollDirectory(absolutePath, dirName, fileList, depth); <line4> } catch (Exception e) { <line5> if (ignoreCannotRetrieveFile(absolutePath, null, e)) { <line6> return true; <line7> } else { <line8> if (e instanceof GenericFileOperationFailedException) { <line9> throw (GenericFileOperationFailedException) e; <line10> } else { <line11> throw new GenericFileOperationFailedException( <line12> ""Cannot poll sub-directory: "" + absolutePath + "" from: "" + endpoint, e); <line13> } <line14> } <line15> } <line16> } <line17> } <line18> "	 <line6>	Yes
public class A { <line0> @Deprecated <line1> public static void updateFragmentEntryLinks( <line2> long groupId, <line3> long classNameId, <line4> long classPK, <line5> long[] fragmentEntryIds, <line6> String editableValues, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws RemoteException { <line9> try { <line10> FragmentEntryLinkServiceUtil.updateFragmentEntryLinks( <line11> groupId, classNameId, classPK, fragmentEntryIds, editableValues, serviceContext); <line12> } catch (Exception exception) { <line13> throw new RemoteException(exception.getMessage()); <line14> } <line15> } <line16> } <line17> 	 <line13>	Yes
public class A { <line0> @Override <line1> protected void startBackgroundDiscovery() { <line2> if (mZWayDeviceScanningJob == null || mZWayDeviceScanningJob.isCancelled()) { <line3> mZWayDeviceScanningJob = <line4> scheduler.scheduleWithFixedDelay( <line5> mZWayDeviceScanningRunnable, INITIAL_DELAY, SCAN_INTERVAL, TimeUnit.SECONDS); <line6> } else { <line7> } <line8> } <line9> } <line10> 	 <line6>	No
public class A { <line0> protected void setInitialBuffer(ByteBuffer initialBuffer) { <line1> if (LOG.isDebugEnabled()) <line2> try (AutoLock l = lock.lock()) { <line3> networkBuffer = newNetworkBuffer(initialBuffer.remaining()); <line4> } <line5> ByteBuffer buffer = networkBuffer.getBuffer(); <line6> BufferUtil.clearToFill(buffer); <line7> BufferUtil.put(initialBuffer, buffer); <line8> BufferUtil.flipToFlush(buffer, 0); <line9> } <line10> } <line11> 	 <line1>	No
"public class A { <line0> @CheckForNull <line1> public Sensor setReverseStoppingSensorName(String reverseSensor) { <line2> if ((reverseSensor == null) || (reverseSensor.length() <= 0)) { <line3> mReverseStoppingNamedSensor = null; <line4> mReverseStoppingSensorName = """"; <line5> return null; <line6> } <line7> tempSensorName = reverseSensor; <line8> Sensor s = validateSensor(); <line9> if (s == null) { <line10> return null; <line11> } <line12> mReverseStoppingNamedSensor = nbhm.getNamedBeanHandle(tempSensorName, s); <line13> mReverseStoppingSensorName = tempSensorName; <line14> return s; <line15> } <line16> } <line17> "	 <line10>	Yes
public class A { <line0> @Override <line1> public void resetOrderBy() throws DatabaseException { <line2> this.setOrderByField(this.defaultOrderByField); <line3> this.setOrderByOperator(Operator.SORTASC); <line4> } <line5> } <line6> 	 <line2>	No
"public class A { <line0> @Cacheable( <line1> value = ""getTypeDescription"", <line2> key = <line3> ""{#root.target.dateIndexTableName,#root.target.auths,#dateType,#begin,#end,#datatypeFilter}"", <line4> cacheManager = ""dateIndexHelperCacheManager"") <line5> public DateTypeDescription getTypeDescription( <line6> String dateType, Date begin, Date end, Set<String> datatypeFilter) <line7> throws TableNotFoundException { <line8> if (log.isTraceEnabled()) { <line9> this.showMeDaCache(""before getTypeDescription""); <line10> } <line11> long startTime = System.currentTimeMillis(); <line12> DateTypeDescription desc = new DateTypeDescription(); <line13> BatchScanner bs = <line14> ScannerHelper.createBatchScanner(client, dateIndexTableName, auths, numQueryThreads); <line15> try { <line16> bs.setRanges( <line17> Arrays.asList(new Range(DateIndexUtil.format(begin), DateIndexUtil.format(end) + '~'))); <line18> bs.fetchColumnFamily(new Text(dateType)); <line19> Iterator<Entry<Key, Value>> iterator = bs.iterator(); <line20> while (iterator.hasNext()) { <line21> Entry<Key, Value> entry = iterator.next(); <line22> Key k = entry.getKey(); <line23> String[] parts = StringUtils.split(k.getColumnQualifier().toString(), '\0'); <line24> if (datatypeFilter == null <line25> || datatypeFilter.isEmpty() <line26> || datatypeFilter.contains(parts[1])) { <line27> desc.fields.add(parts[2]); <line28> String date = parts[0]; <line29> if (desc.dateRange[0] == null) { <line30> desc.dateRange[0] = date; <line31> desc.dateRange[1] = date; <line32> } else { <line33> if (date.compareTo(desc.dateRange[0]) < 0) { <line34> desc.dateRange[0] = date; <line35> } <line36> if (date.compareTo(desc.dateRange[1]) > 0) { <line37> desc.dateRange[1] = date; <line38> } <line39> } <line40> } <line41> } <line42> } finally { <line43> bs.close(); <line44> } <line45> if (desc.dateRange[0] == null) { <line46> desc.dateRange[0] = DateIndexUtil.format(begin); <line47> desc.dateRange[1] = DateIndexUtil.format(end); <line48> } <line49> if (log.isDebugEnabled()) { <line50> long endTime = System.currentTimeMillis(); <line51> } <line52> return desc; <line53> } <line54> } <line55> "	 <line37>	No
"public class A { <line0> private <K, V> <line1> CompletableFuture<StatefulRedisClusterPubSubConnection<K, V>> connectClusterPubSubAsync( <line2> RedisCodec<K, V> codec) { <line3> if (partitions == null) { <line4> return Futures.failed( <line5> new IllegalStateException( <line6> ""Partitions not initialized. Initialize via RedisClusterClient.getPartitions()."")); <line7> } <line8> topologyRefreshScheduler.activateTopologyRefreshIfNeeded(); <line9> PubSubClusterEndpoint<K, V> endpoint = <line10> new PubSubClusterEndpoint<>(getClusterClientOptions(), getResources()); <line11> RedisChannelWriter writer = endpoint; <line12> if (CommandExpiryWriter.isSupported(getClusterClientOptions())) { <line13> writer = new CommandExpiryWriter(writer, getClusterClientOptions(), getResources()); <line14> } <line15> if (CommandListenerWriter.isSupported(getCommandListeners())) { <line16> writer = new CommandListenerWriter(writer, getCommandListeners()); <line17> } <line18> ClusterDistributionChannelWriter clusterWriter = <line19> new ClusterDistributionChannelWriter( <line20> getClusterClientOptions(), writer, topologyRefreshScheduler); <line21> ClusterPubSubConnectionProvider<K, V> pooledClusterConnectionProvider = <line22> new ClusterPubSubConnectionProvider<>( <line23> this, clusterWriter, codec, endpoint.getUpstreamListener(), topologyRefreshScheduler); <line24> StatefulRedisClusterPubSubConnectionImpl<K, V> connection = <line25> new StatefulRedisClusterPubSubConnectionImpl<>( <line26> endpoint, pooledClusterConnectionProvider, clusterWriter, codec, getDefaultTimeout()); <line27> clusterWriter.setClusterConnectionProvider(pooledClusterConnectionProvider); <line28> connection.setPartitions(partitions); <line29> Supplier<CommandHandler> commandHandlerSupplier = <line30> () -> <line31> new PubSubCommandHandler<>(getClusterClientOptions(), getResources(), codec, endpoint); <line32> Mono<SocketAddress> socketAddressSupplier = <line33> getSocketAddressSupplier(connection::getPartitions, TopologyComparators::sortByClientCount); <line34> Mono<StatefulRedisClusterPubSubConnectionImpl<K, V>> connectionMono = <line35> Mono.defer( <line36> () -> connect(socketAddressSupplier, endpoint, connection, commandHandlerSupplier)); <line37> for (int i = 1; i < getConnectionAttempts(); i++) { <line38> connectionMono = <line39> connectionMono.onErrorResume( <line40> t -> connect(socketAddressSupplier, endpoint, connection, commandHandlerSupplier)); <line41> } <line42> return connectionMono <line43> .doOnNext( <line44> c -> <line45> connection.registerCloseables( <line46> closeableResources, clusterWriter, pooledClusterConnectionProvider)) <line47> .map(it -> (StatefulRedisClusterPubSubConnection<K, V>) it) <line48> .toFuture(); <line49> } <line50> } <line51> "	 <line9>	Yes
"public class A { <line0> private static String readPayload(HttpServletRequest request) throws IOException { <line1> try (BufferedReader reader = request.getReader()) { <line2> String payload = """"; <line3> String line; <line4> while ((line = reader.readLine()) != null) { <line5> payload += line; <line6> } <line7> return payload; <line8> } <line9> } <line10> } <line11> "	 <line7>	Yes
"public class A { <line0> public DBStore build() throws IOException { <line1> if (StringUtil.isBlank(dbname) || (dbPath == null)) { <line2> throw new IOException( <line3> ""Required parameter is missing. Please make sure "" + ""Path and DB name is provided.""); <line4> } <line5> Set<TableConfig> tableConfigs = makeTableConfigs(); <line6> if (rocksDBOption == null) { <line7> rocksDBOption = getDefaultDBOptions(tableConfigs); <line8> } <line9> WriteOptions writeOptions = new WriteOptions(); <line10> writeOptions.setSync(rocksDBConfiguration.getSyncOption()); <line11> File dbFile = getDBFile(); <line12> if (!dbFile.getParentFile().exists()) { <line13> throw new IOException(""The DB destination directory should exist.""); <line14> } <line15> return new RDBStore(dbFile, rocksDBOption, writeOptions, tableConfigs, registry, openReadOnly); <line16> } <line17> } <line18> "	 <line2>	Yes
"public class A { <line0> public static void executeChangelog() throws DatabaseUpdateException { <line1> final LiquibaseProvider liquibaseProvider = new DatabaseUpdaterLiquibaseProvider(); <line2> final List<String> changeLogs; <line3> try { <line4> final String version = <line5> changeLogDetective.getInitialLiquibaseSnapshotVersion(CONTEXT, liquibaseProvider); <line6> changeLogs = <line7> changeLogDetective.getUnrunLiquibaseUpdateFileNames(version, CONTEXT, liquibaseProvider); <line8> } catch (Exception e) { <line9> throw new DatabaseUpdateException(""Error while trying to find database changes to run"", e); <line10> } <line11> if (changeLogs.isEmpty()) { <line12> return; <line13> } <line14> for (String changeLog : changeLogs) { <line15> executeChangelog(changeLog, (ChangeSetExecutorCallback) null); <line16> } <line17> } <line18> } <line19> "	 <line17>	No
public class A { <line0> public static List<String[]> getCoresDataArray() { <line1> return coresDataArray; <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> private void refreshOneUser(String command, String description) { <line1> if (command != null) { <line2> Map<String, User> idToUser = new HashMap<>(); <line3> Map<String, User> usernameToUser = new HashMap<>(); <line4> Map<String, User> gidToUser = new HashMap<>(); <line5> List<String> userLines; <line6> try { <line7> userLines = shellRunner.runShell(command, description); <line8> rebuildUsers(userLines, idToUser, usernameToUser, gidToUser); <line9> } catch (final IOException ioexc) { <line10> } <line11> if (idToUser.size() > 0) { <line12> synchronized (usersById) { <line13> usersById.putAll(idToUser); <line14> } <line15> } <line16> if (usernameToUser.size() > 0) { <line17> synchronized (usersByName) { <line18> usersByName.putAll(usernameToUser); <line19> } <line20> } <line21> } else { <line22> } <line23> } <line24> } <line25> 	 <line5>	No
public class A { <line0> protected void auditMessage( <line1> RespondingGatewaySendAlertMessageType message, AssertionType assertion, String direction) { <line2> AcknowledgementType ack = getAuditLogger().auditEntityAdminDist(message, assertion, direction); <line3> if (ack != null) { <line4> } <line5> } <line6> } <line7> 	 <line4>	Yes
public class A { <line0> @Override <line1> protected void channelRead0(ChannelHandlerContext ctx, ShareLoginMessage message) { <line2> String[] messageParts = message.body.split(StringUtils.BODY_SEPARATOR_STRING); <line3> if (messageParts.length < 2) { <line4> ctx.writeAndFlush(illegalCommand(message.id), ctx.voidPromise()); <line5> } else { <line6> var version = <line7> messageParts.length > 3 <line8> ? new Version(messageParts[2], messageParts[3]) <line9> : Version.UNKNOWN_VERSION; <line10> appLogin(ctx, message.id, messageParts[0], messageParts[1], version); <line11> } <line12> } <line13> } <line14> 	 <line4>	Yes
"public class A { <line0> public List<ActivityFrequencyScheduleBean> getActiveTaskFrequencyDetailsForWeekly( <line1> ActiveTaskDto activeTask, List<ActivityFrequencyScheduleBean> runDetailsBean) <line2> throws DAOException { <line3> LOGGER.entry(""begin getActiveTaskFrequencyDetailsForWeekly()""); <line4> try { <line5> if (StringUtils.isNotEmpty(activeTask.getActiveTaskLifetimeStart()) <line6> && StringUtils.isNotEmpty(activeTask.getActiveTaskLifetimeEnd()) <line7> && StringUtils.isNotEmpty(activeTask.getDayOfTheWeek())) { <line8> Integer repeatCount = <line9> ((activeTask.getRepeatActiveTask() == null) || (activeTask.getRepeatActiveTask() == 0)) <line10> ? 1 <line11> : activeTask.getRepeatActiveTask(); <line12> String activeTaskDay = activeTask.getDayOfTheWeek(); <line13> String activeTaskStartDate = activeTask.getActiveTaskLifetimeStart(); <line14> while (repeatCount > 0) { <line15> ActivityFrequencyScheduleBean weeklyBean = new ActivityFrequencyScheduleBean(); <line16> String activeTaskEndDate; <line17> String day = """"; <line18> String weekEndDate; <line19> boolean flag = false; <line20> boolean skipLoop = false; <line21> if (activeTaskDay.equalsIgnoreCase(StudyMetaDataUtil.getDayByDate(activeTaskStartDate))) { <line22> day = activeTaskDay; <line23> } <line24> if (!activeTaskDay.equalsIgnoreCase(day)) { <line25> while (!activeTaskDay.equalsIgnoreCase(day)) { <line26> activeTaskStartDate = StudyMetaDataUtil.addDaysToDate(activeTaskStartDate, 1); <line27> day = StudyMetaDataUtil.getDayByDate(activeTaskStartDate); <line28> } <line29> } <line30> weekEndDate = StudyMetaDataUtil.addWeeksToDate(activeTaskStartDate, 1); <line31> if ((StudyMetaDataConstants.SDF_DATE <line32> .parse(StudyMetaDataUtil.getCurrentDate()) <line33> .equals(StudyMetaDataConstants.SDF_DATE.parse(weekEndDate))) <line34> || (StudyMetaDataConstants.SDF_DATE <line35> .parse(StudyMetaDataUtil.getCurrentDate()) <line36> .before(StudyMetaDataConstants.SDF_DATE.parse(weekEndDate)))) { <line37> flag = true; <line38> } <line39> if (flag) { <line40> activeTaskEndDate = weekEndDate; <line41> if ((StudyMetaDataConstants.SDF_DATE <line42> .parse(weekEndDate) <line43> .equals( <line44> StudyMetaDataConstants.SDF_DATE.parse( <line45> activeTask.getActiveTaskLifetimeEnd()))) <line46> || (StudyMetaDataConstants.SDF_DATE <line47> .parse(weekEndDate) <line48> .after( <line49> StudyMetaDataConstants.SDF_DATE.parse( <line50> activeTask.getActiveTaskLifetimeEnd())))) { <line51> activeTaskEndDate = activeTask.getActiveTaskLifetimeEnd(); <line52> skipLoop = true; <line53> } <line54> weeklyBean.setStartTime(activeTaskStartDate); <line55> weeklyBean.setEndTime(activeTaskEndDate); <line56> runDetailsBean.add(weeklyBean); <line57> if (skipLoop) { <line58> break; <line59> } <line60> } <line61> activeTaskStartDate = weekEndDate; <line62> activeTaskDay = day; <line63> repeatCount--; <line64> } <line65> } <line66> } catch (Exception e) { <line67> } <line68> LOGGER.exit(""getActiveTaskFrequencyDetailsForWeekly() :: Ends""); <line69> return runDetailsBean; <line70> } <line71> } <line72> "	 <line67>	Yes
public class A { <line0> private boolean nullLockGrantorId(LockGrantorId oldLockGrantorId) { <line1> Assert.assertHoldsLock(this.destroyLock, false); <line2> Assert.assertHoldsLock(this.lockGrantorIdLock, false); <line3> if (oldLockGrantorId == null) { <line4> return false; <line5> } <line6> DLockGrantor grantorToDestroy = null; <line7> try { <line8> synchronized (this.lockGrantorIdLock) { <line9> if (equalsLockGrantorId(oldLockGrantorId) <line10> || (oldLockGrantorId.isLocal(getSerialNumber()) && isMakingLockGrantor())) { <line11> if (oldLockGrantorId.isLocal(getSerialNumber()) <line12> && isLockGrantorVersion(this.grantor, oldLockGrantorId.getLockGrantorVersion())) { <line13> grantorToDestroy = this.grantor; <line14> this.grantor = null; <line15> } <line16> this.lockGrantorId = null; <line17> return true; <line18> } else { <line19> return false; <line20> } <line21> } <line22> } finally { <line23> if (grantorToDestroy != null) { <line24> if (logger.isTraceEnabled(LogMarker.DLS_VERBOSE)) { <line25> } <line26> grantorToDestroy.destroy(); <line27> } <line28> } <line29> } <line30> } <line31> 	 <line3>	No
"public class A { <line0> @Override <line1> public boolean check(Object credentials) { <line2> try { <line3> if (credentials instanceof char[]) credentials = new String((char[]) credentials); <line4> if (credentials instanceof Password || credentials instanceof String) { <line5> byte[] digest; <line6> try (AutoLock l = __md5Lock.lock()) { <line7> if (__md == null) __md = MessageDigest.getInstance(""MD5""); <line8> __md.reset(); <line9> __md.update(credentials.toString().getBytes(StandardCharsets.ISO_8859_1)); <line10> digest = __md.digest(); <line11> } <line12> return byteEquals(_digest, digest); <line13> } else if (credentials instanceof MD5) { <line14> return equals(credentials); <line15> } else if (credentials instanceof Credential) { <line16> return ((Credential) credentials).check(this); <line17> } else { <line18> return false; <line19> } <line20> } catch (Exception e) { <line21> return false; <line22> } <line23> } <line24> } <line25> "	 <line6>	No
"public class A { <line0> public static String getConfigFilePath() { <line1> String configResource = GsEnv.property(""com.gigaspaces.metrics.config.resource"").get(); <line2> if (StringUtils.hasLength(configResource)) { <line3> URL systemResource = ClassLoader.getSystemResource(configResource); <line4> if (systemResource != null) { <line5> return systemResource.getFile(); <line6> } <line7> if (logger.isDebugEnabled()) { <line8> } <line9> } <line10> String result = GsEnv.property(""com.gigaspaces.metrics.config"").get(); <line11> if (!StringUtils.hasLength(result)) { <line12> result = SystemLocations.singleton().config(""metrics"").resolve(""metrics.xml"").toString(); <line13> } <line14> return result; <line15> } <line16> } <line17> "	 <line10>	No
"public class A { <line0> private void commonInit() { <line1> for (GlobalInterceptor interceptor : interceptorsRegistry.getInterceptors()) { <line2> interceptor.intercept(this); <line3> } <line4> footerItems = new ListModel<>(new ArrayList<>()); <line5> footerItemRegistry.getFooterItems().stream() <line6> .map(c -> c.create(""item"")) <line7> .forEach(c -> footerItems.getObject().add(c)); <line8> footer = new WebMarkupContainer(""footer""); <line9> footer.setOutputMarkupId(true); <line10> add(footer); <line11> footer.add( <line12> new ListView<Component>(""footerItems"", footerItems) { <line13> private static final long serialVersionUID = 5912513189482015963L; <line14>  <line15> { <line16> setReuseItems(true); <line17> } <line18>  <line19> @Override <line20> protected void populateItem(ListItem<Component> aItem) { <line21> aItem.setOutputMarkupPlaceholderTag(true); <line22> aItem.add(aItem.getModelObject()); <line23> } <line24> }); <line25> Properties settings = SettingsUtil.getSettings(); <line26> String locale = settings.getProperty(SettingsUtil.CFG_LOCALE, ""en""); <line27> switch (locale) { <line28> case ""auto"": <line29> break; <line30> default: <line31> getSession().setLocale(Locale.forLanguageTag(locale)); <line32> break; <line33> } <line34> try { <line35> Class<? extends Component> menubarClass = getApplication().getMetaData(MENUBAR_CLASS); <line36> if (menubarClass == null) { <line37> menubarClass = MenuBar.class; <line38> } <line39> add(ConstructorUtils.invokeConstructor(menubarClass, ""menubar"")); <line40> } catch (NoSuchMethodException <line41> | IllegalAccessException <line42> | InvocationTargetException <line43> | InstantiationException e1) { <line44> throw new RuntimeException(e1); <line45> } <line46> feedbackPanel = new BootstrapFeedbackPanel(""feedbackPanel""); <line47> feedbackPanel.setOutputMarkupId(true); <line48> feedbackPanel.setFilter( <line49> (IFeedbackMessageFilter) <line50> aMessage -> { <line51> Authentication auth = SecurityContextHolder.getContext().getAuthentication(); <line52> String username = auth != null ? auth.getName() : ""SYSTEM""; <line53> if (aMessage.isFatal()) { <line54> LOG.error(""{}: {}"", username, aMessage.getMessage()); <line55> } else if (aMessage.isError()) { <line56> } else if (aMessage.isWarning()) { <line57> } else if (aMessage.isInfo()) { <line58> } else if (aMessage.isDebug()) { <line59> } <line60> return true; <line61> }); <line62> add(feedbackPanel); <line63> } <line64> } <line65> "	 <line57>	Yes
"public class A { <line0> public SSOAuthenticationProperties loadJwtProperties() { <line1> String providerUrl = configuration.getString(JWT_AUTH_PROVIDER_URL); <line2> if (providerUrl != null && configuration.getBoolean(""atlas.sso.knox.enabled"", false)) { <line3> SSOAuthenticationProperties jwtProperties = new SSOAuthenticationProperties(); <line4> String publicKeyPathStr = configuration.getString(JWT_PUBLIC_KEY); <line5> if (publicKeyPathStr == null) { <line6> return null; <line7> } <line8> jwtProperties.setAuthenticationProviderUrl(providerUrl); <line9> jwtProperties.setCookieName( <line10> configuration.getString(JWT_COOKIE_NAME, JWT_COOKIE_NAME_DEFAULT)); <line11> jwtProperties.setOriginalUrlQueryParam( <line12> configuration.getString( <line13> JWT_ORIGINAL_URL_QUERY_PARAM, JWT_ORIGINAL_URL_QUERY_PARAM_DEFAULT)); <line14> String[] userAgent = configuration.getStringArray(BROWSER_USERAGENT); <line15> if (userAgent != null && userAgent.length > 0) { <line16> jwtProperties.setUserAgentList(userAgent); <line17> } else { <line18> jwtProperties.setUserAgentList(DEFAULT_BROWSER_USERAGENT.split("","")); <line19> } <line20> try { <line21> RSAPublicKey publicKey = parseRSAPublicKey(publicKeyPathStr); <line22> jwtProperties.setPublicKey(publicKey); <line23> } catch (IOException e) { <line24> } catch (CertificateException e) { <line25> } catch (ServletException e) { <line26> } <line27> return jwtProperties; <line28> } else { <line29> return null; <line30> } <line31> } <line32> } <line33> "	 <line4>	No
"public class A { <line0> public boolean isWineryRepositoryAvailable() { <line1> try (CloseableHttpClient httpClient = HttpClients.createDefault()) { <line2> final URI serviceTemplatesUri = new URI(this.wineryPath + ""servicetemplates""); <line3> final HttpGet get = new HttpGet(); <line4> get.setHeader(HttpHeaders.ACCEPT, ContentType.APPLICATION_JSON.getMimeType()); <line5> get.setURI(serviceTemplatesUri); <line6> final CloseableHttpResponse resp = httpClient.execute(get); <line7> resp.close(); <line8> return resp.getStatusLine().getStatusCode() < 400; <line9> } catch (URISyntaxException | IOException e) { <line10> return false; <line11> } <line12> } <line13> } <line14> "	 <line10>	Yes
"public class A { <line0> @Override <line1> public void registerWikiComponent(WikiComponent component) throws WikiComponentException { <line2> DocumentReference currentUserReference = <line3> this.wikiComponentManagerContext.getCurrentUserReference(); <line4> EntityReference currentEntityReference = <line5> this.wikiComponentManagerContext.getCurrentEntityReference(); <line6> try { <line7> Type roleType = component.getRoleType(); <line8> Class<?> roleTypeClass = ReflectionUtils.getTypeClass(roleType); <line9> ComponentDescriptor componentDescriptor = <line10> createComponentDescriptor(roleType, component.getRoleHint()); <line11> this.wikiComponentManagerContext.setCurrentUserReference(component.getAuthorReference()); <line12> this.wikiComponentManagerContext.setCurrentEntityReference(component.getEntityReference()); <line13> if (this.isInitializable(component.getClass().getInterfaces())) { <line14> try { <line15> ((Initializable) component).initialize(); <line16> } catch (InitializationException e) { <line17> } <line18> } <line19> getComponentManager(component.getScope()) <line20> .registerComponent(componentDescriptor, roleTypeClass.cast(component)); <line21> cacheWikiComponent(component); <line22> } catch (ComponentLookupException e) { <line23> throw new WikiComponentException( <line24> String.format( <line25> ""Failed to find a component manager for scope [%s] wiki "" <line26> + ""component registration failed"", <line27> component.getScope()), <line28> e); <line29> } catch (ComponentRepositoryException e) { <line30> throw new WikiComponentException( <line31> ""Failed to register wiki component against component repository"", e); <line32> } finally { <line33> this.wikiComponentManagerContext.setCurrentUserReference(currentUserReference); <line34> this.wikiComponentManagerContext.setCurrentEntityReference(currentEntityReference); <line35> } <line36> } <line37> } <line38> "	 <line14>	No
"public class A { <line0> @Managed(description = ""Sets time in nanoseconds"") <line1> public void setKeepAliveTime(final long time) { <line2> getThreadPool().setKeepAliveTime(time, TimeUnit.NANOSECONDS); <line3> if (log.isInfoEnabled()) { <line4> } <line5> } <line6> } <line7> "	 <line5>	No
"public class A { <line0> public static void deleteWebsite(HttpPrincipal httpPrincipal, long websiteId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey(WebsiteServiceUtil.class, ""deleteWebsite"", _deleteWebsiteParameterTypes1); <line5> MethodHandler methodHandler = new MethodHandler(methodKey, websiteId); <line6> try { <line7> TunnelUtil.invoke(httpPrincipal, methodHandler); <line8> } catch (Exception exception) { <line9> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line10> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line11> } <line12> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line13> } <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	 <line2>	No
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> File destConfDir = new File(exportDir, ""conf""); <line4> FileUtils.forceMkdir(destConfDir); <line5> File srcConfDir = new File(ToolUtil.getConfFolder()); <line6> Preconditions.checkState( <line7> srcConfDir.exists(), ""Cannot find config dir: "" + srcConfDir.getAbsolutePath()); <line8> File[] confFiles = srcConfDir.listFiles(); <line9> if (confFiles != null) { <line10> for (File confFile : confFiles) { <line11> FileUtils.copyFileToDirectory(confFile, destConfDir); <line12> } <line13> } <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> "	 <line15>	Yes
public class A { <line0> private void _populateAssignableUsers( <line1> KaleoTaskAssignment kaleoTaskAssignment, <line2> KaleoTaskInstanceToken kaleoTaskInstanceToken, <line3> Set<User> assignableUsers, <line4> long assignedUserId) <line5> throws PortalException { <line6> String assigneeClassName = kaleoTaskAssignment.getAssigneeClassName(); <line7> long assigneeClassPK = kaleoTaskAssignment.getAssigneeClassPK(); <line8> if (assigneeClassName.equals(User.class.getName())) { <line9> if (assignedUserId == assigneeClassPK) { <line10> return; <line11> } <line12> User user = _userLocalService.fetchUser(assigneeClassPK); <line13> if ((user != null) && user.isActive()) { <line14> assignableUsers.add(user); <line15> } <line16> return; <line17> } <line18> Role role = _roleLocalService.getRole(assigneeClassPK); <line19> if ((role.getType() == RoleConstants.TYPE_DEPOT) <line20> || (role.getType() == RoleConstants.TYPE_ORGANIZATION) <line21> || (role.getType() == RoleConstants.TYPE_SITE)) { <line22> if (Objects.equals(role.getName(), DepotRolesConstants.ASSET_LIBRARY_MEMBER) <line23> || Objects.equals(role.getName(), RoleConstants.SITE_MEMBER)) { <line24> assignableUsers.addAll( <line25> Stream.of( <line26> _userLocalService.getGroupUsers( <line27> kaleoTaskInstanceToken.getGroupId(), <line28> WorkflowConstants.STATUS_APPROVED, <line29> null)) <line30> .flatMap(List::parallelStream) <line31> .filter(user -> user.getUserId() != assignedUserId) <line32> .collect(Collectors.toList())); <line33> return; <line34> } <line35> assignableUsers.addAll( <line36> Stream.of( <line37> _userGroupRoleLocalService.getUserGroupRolesByGroupAndRole( <line38> kaleoTaskInstanceToken.getGroupId(), assigneeClassPK)) <line39> .flatMap(List::parallelStream) <line40> .map( <line41> userGroupRole -> { <line42> try { <line43> return userGroupRole.getUser(); <line44> } catch (PortalException portalException) { <line45> if (_log.isWarnEnabled()) { <line46> } <line47> } <line48> return null; <line49> }) <line50> .filter( <line51> user -> (user != null) && user.isActive() && (user.getUserId() != assignedUserId)) <line52> .collect(Collectors.toList())); <line53> assignableUsers.addAll( <line54> Stream.of( <line55> _userGroupGroupRoleLocalService.getUserGroupGroupRolesByGroupAndRole( <line56> kaleoTaskInstanceToken.getGroupId(), assigneeClassPK)) <line57> .flatMap(List::parallelStream) <line58> .map( <line59> userGroupGroupRole -> <line60> _userLocalService.getUserGroupUsers(userGroupGroupRole.getUserGroupId())) <line61> .flatMap(List::parallelStream) <line62> .filter(user -> user.isActive() && (user.getUserId() != assignedUserId)) <line63> .collect(Collectors.toList())); <line64> } else { <line65> assignableUsers.addAll( <line66> Stream.of( <line67> _userLocalService.getInheritedRoleUsers( <line68> assigneeClassPK, QueryUtil.ALL_POS, QueryUtil.ALL_POS, null)) <line69> .flatMap(List::parallelStream) <line70> .filter(user -> user.isActive() && (user.getUserId() != assignedUserId)) <line71> .collect(Collectors.toList())); <line72> } <line73> } <line74> } <line75> 	 <line16>	No
"public class A { <line0> public String register() { <line1> personController.registerUser(userName, password, name, surname, age, admin); <line2> JSFUtility.addInfoMessage(""User with name : "" + userName + "" is registered successfully."", """"); <line3> return ""login""; <line4> } <line5> } <line6> "	 <line1>	Yes
public class A { <line0> public void unregisterClient(int id) { <line1> ConnectedClient client = clients.remove(id); <line2> if (client == null) { <line3> return; <line4> } <line5> Processor processor = client.getProcessor(); <line6> if (processor != null) { <line7> processor.disconnect(client); <line8> } <line9> try { <line10> managementListeners.forEach(l -> l.clientUnregistered(client)); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> 	 <line10>	No
public class A { <line0> private Date getValidDate(Object raw) { <line1> if (raw instanceof String) { <line2> try { <line3> try { <line4> return formatter1.parse((String) raw); <line5> } catch (ParseException e) { <line6> } <line7> return formatter2.parse((String) raw); <line8> } catch (ParseException e) { <line9> getLogger() <line10> return null; <line11> } <line12> } else { <line13> return (Date) raw; <line14> } <line15> } <line16> } <line17> 	 <line10>	Yes
"public class A { <line0> public String appRes(String mesgKey) { <line1> String value = """"; <line2> try { <line3> ResourceBundle res = rcontext_.getApplicationResourceBundle(); <line4> value = res.getString(mesgKey); <line5> } catch (MissingResourceException ex) { <line6> if (PropertyManager.isDevelopping()) <line7> if (mesgKey != null) value = mesgKey.substring(mesgKey.lastIndexOf('.') + 1); <line8> } <line9> return value; <line10> } <line11> } <line12> "	 <line0>	No
public class A { <line0> private Mono<ResourceResponse<StoredProcedure>> createStoredProcedureInternal( <line1> String collectionLink, <line2> StoredProcedure storedProcedure, <line3> RequestOptions options, <line4> DocumentClientRetryPolicy retryPolicyInstance) { <line5> try { <line6> RxDocumentServiceRequest request = <line7> getStoredProcedureRequest(collectionLink, storedProcedure, options, OperationType.Create); <line8> if (retryPolicyInstance != null) { <line9> retryPolicyInstance.onBeforeSendRequest(request); <line10> } <line11> return this.create(request, retryPolicyInstance) <line12> .map(response -> toResourceResponse(response, StoredProcedure.class)); <line13> } catch (Exception e) { <line14> } <line15> } <line16> } <line17> 	 <line6>	Yes
"public class A { <line0> @ConditionalOnMissingBean(name = BEAN_NAME_EMBEDDED_ELASTIC_SEARCH) <line1> @Bean(name = BEAN_NAME_EMBEDDED_ELASTIC_SEARCH, destroyMethod = ""stop"") <line2> public ElasticsearchContainer elasticSearch( <line3> ConfigurableEnvironment environment, ElasticSearchProperties properties) { <line4> ElasticsearchContainer elasticSearch = ElasticSearchContainerFactory.create(properties); <line5> elasticSearch = <line6> (ElasticsearchContainer) configureCommonsAndStart(elasticSearch, properties, log); <line7> registerElasticSearchEnvironment(elasticSearch, environment, properties); <line8> return elasticSearch; <line9> } <line10> } <line11> "	 <line4>	Yes
"public class A { <line0> private void initTable() { <line1> try { <line2> if (config.getBENCHMARK_WORK_MODE().equals(Constants.MODE_SERVER_MODE) <line3> || config.getBENCHMARK_WORK_MODE().equals(Constants.MODE_CLIENT_SYSTEM_INFO)) { <line4> if (!hasTable(""SERVER_MODE_"" + localName + ""_"" + day)) { <line5> statement.executeUpdate( <line6> ""create table SERVER_MODE_"" <line7> + localName <line8> + ""_"" <line9> + day <line10> + ""(id BIGINT, cpu_usage DOUBLE,mem_usage DOUBLE,diskIo_usage"" <line11> + "" DOUBLE,net_recv_rate DOUBLE,net_send_rate DOUBLE, pro_mem_size DOUBLE,"" <line12> + "" dataFileSize DOUBLE,systemFizeSize DOUBLE,sequenceFileSize"" <line13> + "" DOUBLE,unsequenceFileSize DOUBLE, walFileSize DOUBLE,tps DOUBLE,MB_read"" <line14> + "" DOUBLE,MB_wrtn DOUBLE,primary key(id))""); <line15> } <line16> return; <line17> } <line18> if (!hasTable(""CONFIG"")) { <line19> statement.executeUpdate( <line20> ""create table CONFIG (id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, projectID"" <line21> + "" VARCHAR(150), configuration_item VARCHAR(150), configuration_value"" <line22> + "" VARCHAR(150))AUTO_INCREMENT = 1;""); <line23> } <line24> if (!hasTable(""FINAL_RESULT"")) { <line25> statement.executeUpdate( <line26> ""create table FINAL_RESULT (id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,"" <line27> + "" projectID VARCHAR(150), operation VARCHAR(50), result_key VARCHAR(150),"" <line28> + "" result_value VARCHAR(150))AUTO_INCREMENT = 1;""); <line29> } <line30> if (config.getBENCHMARK_WORK_MODE().equals(Constants.MODE_TEST_WITH_DEFAULT_PATH) <line31> && !hasTable(projectID)) { <line32> statement.executeUpdate( <line33> ""create table "" <line34> + projectID <line35> + ""(id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, recordTime varchar(50),"" <line36> + "" clientName varchar(50), operation varchar(50), okPoint INTEGER, failPoint"" <line37> + "" INTEGER, latency DOUBLE, rate DOUBLE, remark varchar(1000))AUTO_INCREMENT ="" <line38> + "" 1;""); <line39> } <line40> } catch (SQLException e) { <line41> } <line42> } <line43> } <line44> "	 <line16>	No
public class A { <line0> @Override <line1> public void handleStreamClosePacket(ServerStreamChannel streamChannel, StreamClosePacket packet) { <line2> } <line3> } <line4> 	 <line3>	No
"public class A { <line0> private static boolean isOsx0() { <line1> String osname = <line2> SystemPropertyUtil.get(""os.name"", """").toLowerCase(Locale.US).replaceAll(""[^a-z0-9]+"", """"); <line3> boolean osx = osname.startsWith(""macosx"") || osname.startsWith(""osx""); <line4> if (osx) { <line5> } <line6> return osx; <line7> } <line8> } <line9> "	 <line8>	No
"public class A { <line0> @Override <line1> public synchronized void unregister(String resourcePath) throws HyracksDataException { <line2> validateDatasetLifecycleManagerState(); <line3> int did = getDIDfromResourcePath(resourcePath); <line4> long resourceID = getResourceIDfromResourcePath(resourcePath); <line5> DatasetResource dsr = datasets.get(did); <line6> IndexInfo iInfo = dsr == null ? null : dsr.getIndexInfo(resourceID); <line7> if (dsr == null || iInfo == null) { <line8> throw HyracksDataException.create(ErrorCode.INDEX_DOES_NOT_EXIST); <line9> } <line10> PrimaryIndexOperationTracker opTracker = dsr.getOpTracker(iInfo.getPartition()); <line11> if (iInfo.getReferenceCount() != 0 <line12> || (opTracker != null && opTracker.getNumActiveOperations() != 0)) { <line13> if (LOGGER.isErrorEnabled()) { <line14> final String logMsg = <line15> String.format( <line16> ""Failed to drop in-use index %s. Ref count (%d), Operation tracker active ops (%d)"", <line17> resourcePath, iInfo.getReferenceCount(), opTracker.getNumActiveOperations()); <line18> } <line19> throw HyracksDataException.create( <line20> ErrorCode.CANNOT_DROP_IN_USE_INDEX, StoragePathUtil.getIndexNameFromPath(resourcePath)); <line21> } <line22> DatasetInfo dsInfo = dsr.getDatasetInfo(); <line23> dsInfo.waitForIO(); <line24> closeIndex(iInfo); <line25> dsInfo.removeIndex(resourceID); <line26> synchronized (dsInfo) { <line27> if (dsInfo.getReferenceCount() == 0 <line28> && dsInfo.isOpen() <line29> && dsInfo.getIndexes().isEmpty() <line30> && !dsInfo.isExternal()) { <line31> removeDatasetFromCache(dsInfo.getDatasetID()); <line32> } <line33> } <line34> } <line35> } <line36> "	 <line7>	No
public class A { <line0> protected void onError(Status status, Metadata trailers) { <line1> Code code = status.getCode(); <line2> if (code == Status.Code.CANCELLED) { <line3> setException(status.asRuntimeException()); <line4> finalizeStats(status); <line5> return; <line6> } <line7> String channelId = ChannelPool.extractIdentifier(trailers); <line8> if (!retryOptions.enableRetries() <line9> || !retryOptions.isRetryable(code) <line10> || !(isRequestRetryable() || code == Code.UNAUTHENTICATED || code == Code.UNAVAILABLE)) { <line11> rpc.getRpcMetrics().markFailure(); <line12> finalizeStats(status); <line13> setException(status.asRuntimeException()); <line14> return; <line15> } <line16> Long nextBackOff = getNextBackoff(); <line17> failedCount += 1; <line18> if (nextBackOff == null) { <line19> setException(getExhaustedRetriesException(status)); <line20> } else { <line21> performRetry(nextBackOff); <line22> } <line23> } <line24> } <line25> 	 <line19>	Yes
"public class A { <line0> private ByteString readStateMachineData( <line1> ContainerCommandRequestProto requestProto, long term, long index) throws IOException { <line2> metrics.incNumReadStateMachineMissCount(); <line3> WriteChunkRequestProto writeChunkRequestProto = requestProto.getWriteChunk(); <line4> ContainerProtos.ChunkInfo chunkInfo = writeChunkRequestProto.getChunkData(); <line5> ReadChunkRequestProto.Builder readChunkRequestProto = <line6> ReadChunkRequestProto.newBuilder() <line7> .setBlockID(writeChunkRequestProto.getBlockID()) <line8> .setChunkData(chunkInfo) <line9> .setReadChunkVersion(ContainerProtos.ReadChunkVersion.V1); <line10> ContainerCommandRequestProto dataContainerCommandProto = <line11> ContainerCommandRequestProto.newBuilder(requestProto) <line12> .setCmdType(Type.ReadChunk) <line13> .setReadChunk(readChunkRequestProto) <line14> .build(); <line15> DispatcherContext context = <line16> new DispatcherContext.Builder() <line17> .setTerm(term) <line18> .setLogIndex(index) <line19> .setReadFromTmpFile(true) <line20> .build(); <line21> ContainerCommandResponseProto response = dispatchCommand(dataContainerCommandProto, context); <line22> if (response.getResult() != ContainerProtos.Result.SUCCESS) { <line23> StorageContainerException sce = <line24> new StorageContainerException(response.getMessage(), response.getResult()); <line25> stateMachineHealthy.set(false); <line26> throw sce; <line27> } <line28> ReadChunkResponseProto responseProto = response.getReadChunk(); <line29> ByteString data; <line30> if (responseProto.hasData()) { <line31> data = responseProto.getData(); <line32> } else { <line33> data = BufferUtils.concatByteStrings(responseProto.getDataBuffers().getBuffersList()); <line34> } <line35> Preconditions.checkNotNull(data, ""read chunk data is null for chunk: %s"", chunkInfo); <line36> Preconditions.checkState( <line37> data.size() == chunkInfo.getLen(), <line38> ""read chunk len=%s does not match chunk expected len=%s for chunk:%s"", <line39> data.size(), <line40> chunkInfo.getLen(), <line41> chunkInfo); <line42> return data; <line43> } <line44> } <line45> "	 <line25>	Yes
public class A { <line0> public void greetMeOneWay(String me) { <line1> } <line2> } <line3> 	 <line2>	No
"public class A { <line0> @Override <line1> public List<? extends Command> getPreProcessingCommands(Context context, boolean withDao) { <line2> InitialContext initialContext = (InitialContext) context.get(INITIAL_CONTEXT); <line3> List<Command> commands = new ArrayList<>(); <line4> try { <line5> commands.add(CommandFactory.create(initialContext, HubInitExportCommand.class.getName())); <line6> } catch (Exception e) { <line7> throw new RuntimeException(""unable to call factories""); <line8> } <line9> return commands; <line10> } <line11> } <line12> "	 <line7>	Yes
public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> Stopwatch stopwatch = Stopwatch.createStarted(); <line3> try { <line4> method.invoke(WinRmMachineLocationLiveTest.this); <line5> return null; <line6> } catch (Exception e) { <line7> throw e; <line8> } <line9> } <line10> } <line11> 	 <line9>	No
public class A { <line0> public final boolean showOverlay(Region overlay, boolean blocking) { <line1> if (!overlays.containsKey(overlay)) { <line2> overlays.put(overlay, new WorkbenchOverlay(overlay, new GlassPane())); <line3> } <line4> if (blockingOverlaysShown.contains(overlay) || nonBlockingOverlaysShown.contains(overlay)) { <line5> return false; <line6> } <line7> if (blocking) { <line8> return blockingOverlaysShown.add(overlay); <line9> } else { <line10> return nonBlockingOverlaysShown.add(overlay); <line11> } <line12> } <line13> } <line14> 	 <line7>	No
public class A { <line0> @Override <line1> public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) { <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> @Override <line1> public void _setNextWriteValue(Optional<Boolean> valueOpt) throws OpenemsException { <line2> if (this.isDebug()) { <line3> } <line4> this.nextWriteValue = valueOpt; <line5> this.onSetNextWriteCallbacks.forEach(callback -> callback.accept(valueOpt)); <line6> } <line7> } <line8> 	 <line3>	Yes
public class A { <line0> @Override <line1> public Object createConnectionFactory() throws ResourceException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> return createConnectionFactory(new ActiveMQRAConnectionManager()); <line5> } <line6> } <line7> 	 <line3>	Yes
"public class A { <line0> @Override <line1> protected void onConfigError( <line2> StackGresClusterContext context, HasMetadata configResource, Exception ex) { <line3> String message = <line4> MessageFormatter.arrayFormat( <line5> ""StackGres Cluster {}.{} reconciliation failed"", <line6> new String[] { <line7> configResource.getMetadata().getNamespace(), <line8> configResource.getMetadata().getName(), <line9> }) <line10> .getMessage(); <line11> try (KubernetesClient client = clientSupplier.get()) { <line12> eventController.sendEvent( <line13> ClusterControllerEventReason.CLUSTER_CONTROLLER_ERROR, <line14> message + "": "" + ex.getMessage(), <line15> configResource, <line16> client); <line17> } <line18> } <line19> } <line20> "	 <line11>	Yes
public class A { <line0> @Override <line1> public void codecAdded(SignalMLCodecManagerEvent ev) { <line2> try { <line3> PluginCodecEvent event = createCodecEvent(ev); <line4> for (PluginCodecListener listener : codecListeners) { <line5> try { <line6> listener.codecAdded(event); <line7> } catch (Exception ex) { <line8> } <line9> } <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	 <line8>	Yes
public class A { <line0> private void executeCommit() throws SQLException { <line1> if (useCommit) { <line2> if (commitCount < commitEvery) { <line3> commitCount++; <line4> } else { <line5> commitCount = 0; <line6> conn.commit(); <line7> } <line8> } <line9> } <line10> } <line11> 	 <line2>	No
"public class A { <line0> public static ValidationReport validateDescriptiveBinary( <line1> ContentPayload descriptiveMetadataPayload, <line2> String descriptiveMetadataType, <line3> String descriptiveMetadataVersion, <line4> boolean failIfNoSchema) { <line5> ValidationReport ret = new ValidationReport(); <line6> Optional<Schema> xmlSchema = <line7> RodaCoreFactory.getRodaSchema(descriptiveMetadataType, descriptiveMetadataVersion); <line8> try { <line9> if (xmlSchema.isPresent()) { <line10> RodaErrorHandler errorHandler = new RodaErrorHandler(); <line11> try (InputStreamReader inputStreamReader = <line12> new InputStreamReader( <line13> new BOMInputStream(descriptiveMetadataPayload.createInputStream()))) { <line14> XMLReader xmlReader = XMLReaderFactory.createXMLReader(); <line15> xmlReader.setEntityResolver(new RodaEntityResolver()); <line16> InputSource inputSource = new InputSource(inputStreamReader); <line17> Source source = new SAXSource(xmlReader, inputSource); <line18> Validator validator = xmlSchema.get().newValidator(); <line19> validator.setErrorHandler(errorHandler); <line20> validator.validate(source); <line21> ret.setValid(errorHandler.getErrors().isEmpty()); <line22> for (SAXParseException saxParseException : errorHandler.getErrors()) { <line23> ret.addIssue(convertSAXParseException(saxParseException)); <line24> } <line25> } catch (SAXException e) { <line26> ret.setValid(false); <line27> for (SAXParseException saxParseException : errorHandler.getErrors()) { <line28> ret.addIssue(convertSAXParseException(saxParseException)); <line29> } <line30> } <line31> } else { <line32> if (failIfNoSchema) { <line33> ret.setValid(false); <line34> ret.setMessage(""No schema to validate "" + descriptiveMetadataType); <line35> } else { <line36> ret = isXMLValid(descriptiveMetadataPayload); <line37> } <line38> } <line39> } catch (IOException e) { <line40> ret.setValid(false); <line41> ret.setMessage(e.getMessage()); <line42> } <line43> return ret; <line44> } <line45> } <line46> "	 <line23>	No
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""org.nd4j.linalg.BaseNd4jTestWithBackends#configs"") <line2> public void compareAfterWrite(Nd4jBackend backend) throws Exception { <line3> int[] ranksToCheck = new int[] {0, 1, 2, 3, 4}; <line4> for (int i = 0; i < ranksToCheck.length; i++) { <line5> compareArrays(ranksToCheck[i], ordering(), testDir); <line6> } <line7> } <line8> } <line9> "	 <line7>	No
"public class A { <line0> @Override <line1> public void execute() throws Exception { <line2> String subCommandString = getParsedSubCommand(studiesCommandOptions.jCommander); <line3> RestResponse queryResponse = null; <line4> switch (subCommandString) { <line5> case ""create"": <line6> queryResponse = create(); <line7> break; <line8> case ""info"": <line9> queryResponse = info(); <line10> break; <line11> case ""update"": <line12> queryResponse = update(); <line13> break; <line14> case ""stats"": <line15> queryResponse = stats(); <line16> break; <line17> case ""search"": <line18> queryResponse = search(); <line19> break; <line20> case ""acl"": <line21> queryResponse = getAcl(); <line22> break; <line23> case ""acl-update"": <line24> queryResponse = updateAcl(); <line25> break; <line26> case ""groups"": <line27> queryResponse = groups(); <line28> break; <line29> case ""groups-create"": <line30> queryResponse = groupsCreate(); <line31> break; <line32> case ""groups-delete"": <line33> queryResponse = groupsDelete(); <line34> break; <line35> case ""groups-update"": <line36> queryResponse = groupsUpdate(); <line37> break; <line38> case ""variable-sets"": <line39> queryResponse = variableSets(); <line40> break; <line41> case ""variable-sets-update"": <line42> queryResponse = variableSetUpdate(); <line43> break; <line44> case ""variable-sets-variables-update"": <line45> queryResponse = variableSetVariableUpdate(); <line46> break; <line47> default: <line48> break; <line49> } <line50> createOutput(queryResponse); <line51> } <line52> } <line53> "	 <line43>	No
public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> deleteProject_result result = new deleteProject_result(); <line4> if (e instanceof org.apache.airavata.model.error.InvalidRequestException) { <line5> result.ire = (org.apache.airavata.model.error.InvalidRequestException) e; <line6> result.setIreIsSet(true); <line7> msg = result; <line8> } else if (e instanceof org.apache.airavata.model.error.AiravataClientException) { <line9> result.ace = (org.apache.airavata.model.error.AiravataClientException) e; <line10> result.setAceIsSet(true); <line11> msg = result; <line12> } else if (e instanceof org.apache.airavata.model.error.AiravataSystemException) { <line13> result.ase = (org.apache.airavata.model.error.AiravataSystemException) e; <line14> result.setAseIsSet(true); <line15> msg = result; <line16> } else if (e instanceof org.apache.airavata.model.error.ProjectNotFoundException) { <line17> result.pnfe = (org.apache.airavata.model.error.ProjectNotFoundException) e; <line18> result.setPnfeIsSet(true); <line19> msg = result; <line20> } else if (e instanceof org.apache.airavata.model.error.AuthorizationException) { <line21> result.ae = (org.apache.airavata.model.error.AuthorizationException) e; <line22> result.setAeIsSet(true); <line23> msg = result; <line24> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line25> fb.close(); <line26> return; <line27> } else if (e instanceof org.apache.thrift.TApplicationException) { <line28> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line29> msg = (org.apache.thrift.TApplicationException) e; <line30> } else { <line31> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line32> msg = <line33> new org.apache.thrift.TApplicationException( <line34> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line35> } <line36> try { <line37> fcall.sendResponse(fb, msg, msgType, seqid); <line38> } catch (java.lang.Exception ex) { <line39> fb.close(); <line40> } <line41> } <line42> } <line43> 	 <line10>	No
"public class A { <line0> @SkipValidation <line1> @Action(value = ""/budget/budgetProposal-update"") <line2> public String update() { <line3> for (final BudgetProposalBean bpBean : bpBeanList) { <line4> if (bpBean == null || bpBean.getId() == null) continue; <line5> budgetDetail = budgetDetailService.find(""from BudgetDetail where id=?"", bpBean.getId()); <line6> break; <line7> } <line8> final List<Assignment> assignment = <line9> assignmentService.findAllAssignmentsByHODDeptAndDates( <line10> budgetDetail.getExecutingDepartment().getId(), budgetDetail.getBudget().getAsOnDate()); <line11> if (!assignment.isEmpty()) approverPositionId = assignment.get(0).getPosition().getId(); <line12> populateWorkflowBean(); <line13> if (actionName.contains(""Forward"")) { <line14> if (!assignment.isEmpty()) <line15> addActionMessage( <line16> getText( <line17> ""budgetdetail.forward"", new String[] {assignment.get(0).getEmployee().getName()})); <line18> else <line19> throw new ValidationException( <line20> org.apache.commons.lang.StringUtils.EMPTY, <line21> ""Approver doesn't exists for the selected department""); <line22> } else if (actionName.contains(""Verify"")) addActionMessage(getText(""budgetdetail.verify"")); <line23> else if (actionName.contains(""Cancel"")) addActionMessage(getText(""budgetdetail.cancel"")); <line24> else { <line25> final Assignment initiator = budgetDetailService.getWorkflowInitiator(budgetDetail); <line26> addActionMessage( <line27> getText(""budgetdetail.reject"", new String[] {initiator.getEmployee().getName()})); <line28> } <line29> budgetDetailActionHelper.update(bpBeanList, workflowBean); <line30> return ""message""; <line31> } <line32> } <line33> "	 <line30>	Yes
"public class A { <line0> protected Answer execute(MigrateVmToPoolCommand cmd) { <line1> if (s_logger.isInfoEnabled()) { <line2> if (s_logger.isDebugEnabled()) { <line3> } <line4> } <line5> final String vmName = cmd.getVmName(); <line6> VmwareHypervisorHost hyperHost = getHyperHost(getServiceContext()); <line7> try { <line8> VirtualMachineMO vmMo = getVirtualMachineMO(vmName, hyperHost); <line9> if (vmMo == null) { <line10> ManagedObjectReference dcMor = hyperHost.getHyperHostDatacenter(); <line11> DatacenterMO dcMo = new DatacenterMO(hyperHost.getContext(), dcMor); <line12> vmMo = dcMo.findVm(vmName); <line13> if (vmMo == null) { <line14> String msg = ""VM "" + vmName + "" does not exist in VMware datacenter""; <line15> throw new CloudRuntimeException(msg); <line16> } <line17> } <line18> return migrateAndAnswer(vmMo, null, hyperHost, cmd); <line19> } catch (Throwable e) { <line20> if (e instanceof Exception) { <line21> return new Answer(cmd, (Exception) e); <line22> } <line23> if (s_logger.isDebugEnabled()) { <line24> } <line25> return new Answer(cmd, false, ""unknown problem: "" + e.getLocalizedMessage()); <line26> } <line27> } <line28> } <line29> "	 <line10>	Yes
public class A { <line0> private void waitForShutdown(ExecutorService service) { <line1> if (!service.isTerminated()) { <line2> try { <line3> service.awaitTermination(10, TimeUnit.MINUTES); <line4> } catch (InterruptedException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line3>	Yes
public class A { <line0> public WeblogTheme getTheme() { <line1> try { <line2> ThemeManager themeMgr = WebloggerFactory.getWeblogger().getThemeManager(); <line3> return themeMgr.getTheme(this); <line4> } catch (WebloggerException ex) { <line5> } <line6> return null; <line7> } <line8> } <line9> 	 <line1>	No
public class A { <line0> private void iterateOnSection( <line1> ProjectReportModelSection section, <line2> List<RichTextElement> elements, <line3> ProjectReportVersion version) { <line4> int areaCount = section.getNumberOfTextarea(); <line5> List<KeyQuestion> keyQuestions = section.getKeyQuestions(); <line6> if (keyQuestions == null) { <line7> keyQuestions = Collections.emptyList(); <line8> } <line9> for (int index = 0; index < keyQuestions.size(); index++) { <line10> final RichTextElement element = new RichTextElement(); <line11> element.setIndex(index); <line12> element.setSectionId(section.getId()); <line13> element.setVersion(version); <line14> elements.add(element); <line15> } <line16> int index = 0; <line17> List<ProjectReportModelSection> subSections = section.getSubSections(); <line18> if (subSections == null) { <line19> subSections = Collections.emptyList(); <line20> } <line21> for (final ProjectReportModelSection subSection : subSections) { <line22> while (index < subSection.getIndex() && areaCount > 0) { <line23> final RichTextElement element = new RichTextElement(); <line24> element.setIndex(index + keyQuestions.size()); <line25> element.setSectionId(section.getId()); <line26> element.setVersion(version); <line27> elements.add(element); <line28> index++; <line29> areaCount--; <line30> } <line31> iterateOnSection(subSection, elements, version); <line32> } <line33> while (areaCount > 0) { <line34> final RichTextElement element = new RichTextElement(); <line35> element.setIndex(index + keyQuestions.size()); <line36> element.setSectionId(section.getId()); <line37> element.setVersion(version); <line38> elements.add(element); <line39> index++; <line40> areaCount--; <line41> } <line42> } <line43> } <line44> 	 <line22>	Yes
"public class A { <line0> private void addSingleResourceToHive( <line1> HiveDriver driver, ResourceEntry res, LensSessionHandle sessionHandle) throws LensException { <line2> String sessionIdentifier = sessionHandle.getPublicId().toString(); <line3> String uri = res.getUri(); <line4> uri = removePrefixBeforeURI(uri); <line5> String command = ""add "" + res.getType().toLowerCase() + "" "" + uri; <line6> driver.execute(createResourceQuery(command, sessionHandle, driver)); <line7> } <line8> } <line9> "	 <line7>	Yes
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Thread.sleep(2500); <line4> } catch (InterruptedException ie) { <line5> fail(""interrupted""); <line6> } <line7> region.destroyRegion(); <line8> } <line9> } <line10> "	 <line5>	Yes
public class A { <line0> public boolean completedIsDisplayed() { <line1> return readyElement(completedLabel).isDisplayed(); <line2> } <line3> } <line4> 	 <line2>	No
public class A { <line0> @Override <line1> public boolean undeployPlan(final TPlan plan, final String targetNamespace, final CsarId csarId) { <line2> final String language = plan.getPlanLanguage(); <line3> if (plan.getPlanModel() != null) { <line4> final IPlanEnginePlanModelPluginService plugin = this.getModelPlugin(language); <line5> if (plugin == null) { <line6> return false; <line7> } <line8> return plugin.undeployPlan(plan.getPlanModel(), csarId); <line9> } <line10> final QName planId = QName.valueOf(plan.getId()); <line11> final IPlanEnginePlanRefPluginService plugin = this.getRefPlugin(language); <line12> if (plugin == null) { <line13> return false; <line14> } <line15> return plugin.undeployPlanReference(planId, plan.getPlanModelReference(), csarId); <line16> } <line17> } <line18> 	 <line12>	No
"public class A { <line0> @Override <line1> public JavaRDD<HoodieRecord<T>> handleUpdate(JavaRDD<HoodieRecord<T>> taggedRecordsRDD) { <line2> List<HoodieFileGroupId> fileGroupIdsWithRecordUpdate = getGroupIdsWithUpdate(taggedRecordsRDD); <line3> fileGroupIdsWithRecordUpdate.forEach( <line4> fileGroupIdWithRecordUpdate -> { <line5> if (fileGroupsInPendingClustering.contains(fileGroupIdWithRecordUpdate)) { <line6> String msg = <line7> String.format( <line8> ""Not allowed to update the clustering file group %s. For pending clustering"" <line9> + "" operations, we are not going to support update for now."", <line10> fileGroupIdWithRecordUpdate.toString()); <line11> throw new HoodieClusteringUpdateException(msg); <line12> } <line13> }); <line14> return taggedRecordsRDD; <line15> } <line16> } <line17> "	 <line8>	No
"public class A { <line0> @Override <line1> public String convert(InputStream xml) throws ValidationException { <line2> Object parsedObject = parseXml(xml); <line3> if (parsedObject instanceof Envelope) { <line4> parsedObject = JTS.toGeometry((Envelope) parsedObject); <line5> } <line6> if (parsedObject instanceof Geometry) { <line7> try { <line8> Geometry geometry = convertCRS((Geometry) parsedObject); <line9> return new WKTWriter().write(geometry); <line10> } catch (TransformException e) { <line11> throw new ValidationExceptionImpl( <line12> e, <line13> Collections.singletonList(""Cannot transform geometry to lon/lat""), <line14> new ArrayList<>()); <line15> } <line16> } <line17> throw new ValidationExceptionImpl( <line18> """", Collections.singletonList(""Couldn't not convert GML to WKT""), new ArrayList<>()); <line19> } <line20> } <line21> "	 <line9>	No
public class A { <line0> @Override <line1> public List<AbstractDomain> getAllAuthorizedDomain(AbstractDomain domain) { <line2> List<AbstractDomain> result = new ArrayList<AbstractDomain>(); <line3> List<DomainAccessRule> rules = domain.getPolicy().getDomainAccessPolicy().getRules(); <line4> for (AbstractDomain d : getAllAuthorizedDomain(domain, rules)) { <line5> if (!result.contains(d)) { <line6> result.add(d); <line7> } <line8> } <line9> for (AbstractDomain d : getAllAuthorizedDomainReverse(domain, rules)) { <line10> if (!result.contains(d)) { <line11> result.add(d); <line12> } <line13> } <line14> for (AbstractDomain abstractDomain : result) { <line15> } <line16> return result; <line17> } <line18> } <line19> 	 <line9>	No
"public class A { <line0> public static int getFragmentCollectionsCount( <line1> HttpPrincipal httpPrincipal, long groupId, String name) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> FragmentCollectionServiceUtil.class, <line6> ""getFragmentCollectionsCount"", <line7> _getFragmentCollectionsCountParameterTypes17); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, name); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> throw systemException; <line18> } <line19> } <line20> } <line21> "	 <line13>	No
public class A { <line0> private void parsePskIdentityHintLength(PskEcDheServerKeyExchangeMessage msg) { <line1> msg.setIdentityHintLength(parseIntField(HandshakeByteLength.PSK_IDENTITY_LENGTH)); <line2> } <line3> } <line4> 	 <line1>	No
"public class A { <line0> UserToken findByUserId(final long userId) { <line1> EntityManager em = daoManager.getEntityManagerFromFactory(); <line2> UserToken tk = null; <line3> try { <line4> List<UserTokenEntity> result; <line5> TypedQuery<UserTokenEntity> qr = <line6> em.createQuery( <line7> ""select h from UserTokenEntity h where h.userId=:userId order by h.validDate desc"", <line8> UserTokenEntity.class); <line9> qr.setParameter(""userId"", userId); <line10> result = qr.getResultList(); <line11> if (result != null && !result.isEmpty()) { <line12> tk = result.get(0); <line13> } <line14> } catch (Exception e) { <line15> } finally { <line16> daoManager.closeEntityManager(em); <line17> } <line18> return tk; <line19> } <line20> } <line21> "	 <line15>	Yes
public class A { <line0> protected boolean isCustomField(String className, long tableId) { <line1> long classNameId = classNameLocalService.getClassNameId(className); <line2> try { <line3> ExpandoTable expandoTable = expandoTableLocalService.getTable(tableId); <line4> if (Objects.equals(ExpandoTableConstants.DEFAULT_TABLE_NAME, expandoTable.getName()) <line5> && (expandoTable.getClassNameId() == classNameId)) { <line6> return true; <line7> } <line8> } catch (Exception exception) { <line9> if (_log.isWarnEnabled()) { <line10> } <line11> } <line12> return false; <line13> } <line14> } <line15> 	 <line5>	No
public class A { <line0> protected void logError(Integration integration, String format, Object... args) { <line1> if (log.isErrorEnabled()) { <line2> } <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> protected byte[] unsealNotifOld(byte[] message) { <line1> CryptoResult<UnsealedData> result = getOldDataUnsealer().unseal(message); <line2> if (result != null && result.hasData()) { <line3> if (result.hasErrors()) { <line4> for (NotificationError error : result.getErrors()) { <line5> } <line6> for (NotificationWarning warning : result.getWarnings()) { <line7> } <line8> if (result.getFatal() != null) { <line9> } <line10> } <line11> InputStream unsealedDataStream = result.getData().getContent(); <line12> byte[] unsealedData = IOUtils.getBytes(unsealedDataStream); <line13> return unsealedData; <line14> } <line15> return null; <line16> } <line17> } <line18> 	 <line15>	No
public class A { <line0> @Override <line1> public Response toResponse(CloudConfigurationNotFoundException e) { <line2> RequestError error = new RequestError(); <line3> ServiceException value = new ServiceException(); <line4> value.setMessageId(ErrorNumbers.SVC_GENERAL_SERVICE_ERROR); <line5> value.setText(e.getMessage()); <line6> error.setServiceException(value); <line7> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(error).build(); <line8> } <line9> } <line10> 	 <line4>	No
"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/by-code/{code}"") <line3> public Response getCrisisByCode(@PathParam(""code"") String crisisCode) { <line4> CollectionDTO crisis = null; <line5> try { <line6> crisis = crisisLocalEJB.getCrisisByCode(crisisCode); <line7> return Response.ok(crisis).build(); <line8> } catch (RuntimeException e) { <line9> return Response.ok( <line10> new ResponseWrapper( <line11> TaggerAPIConfigurator.getInstance() <line12> .getProperty(TaggerAPIConfigurationProperty.STATUS_CODE_FAILED), <line13> e.getCause().getCause().getMessage())) <line14> .build(); <line15> } <line16> } <line17> } <line18> "	 <line9>	Yes
"public class A { <line0> @Test(groups = ""Integration"") <line1> @SuppressWarnings(""resource"") <line2> public void testWhichKnife() throws IOException, InterruptedException { <line3> Process p = Runtime.getRuntime().exec(new String[] {""bash"", ""-l"", ""-c"", ""which knife""}); <line4> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line5> new StreamGobbler(p.getInputStream(), out, log).start(); <line6> new StreamGobbler(p.getErrorStream(), out, log).start(); <line7> Time.sleep(Duration.millis(1000)); <line8> Assert.assertEquals(p.exitValue(), 0); <line9> } <line10> } <line11> "	 <line6>	No
"public class A { <line0> public void saveInternals(final File nodeInternDir) { <line1> if (!m_settings.isHilitingEnabled()) { <line2> return; <line3> } <line4> final NodeSettings internalSettings = new NodeSettings(""hilite_mapping""); <line5> for (InputTable inPort : m_translators.keySet()) { <line6> for (ResultType outPort : m_translators.get(inPort).keySet()) { <line7> String configurationName = hiliteConfigurationName(inPort, outPort); <line8> NodeSettingsWO mappingSettings = internalSettings.addNodeSettings(configurationName); <line9> DefaultHiLiteMapper mapper = <line10> (DefaultHiLiteMapper) m_translators.get(inPort).get(outPort).getMapper(); <line11> if (mapper != null) { <line12> mapper.save(mappingSettings); <line13> } <line14> } <line15> } <line16> File f = new File(nodeInternDir, INTERNALS_FILE_NAME); <line17> try (FileOutputStream out = new FileOutputStream(f)) { <line18> internalSettings.saveToXML(out); <line19> } catch (IOException e) { <line20> } <line21> } <line22> } <line23> "	 <line20>	Yes
public class A { <line0> public Boolean getModified(String property) { <line1> return isModified.get(property); <line2> } <line3> } <line4> 	 <line3>	No
"public class A { <line0> @POST <line1> @Path(""{csid}/accountroles"") <line2> public Response createAccountRole( <line3> @Context UriInfo uriInfo, <line4> @QueryParam(""_method"") String method, <line5> @PathParam(""csid"") String accCsid, <line6> AccountRole input) { <line7> if (method != null) { <line8> if (""delete"".equalsIgnoreCase(method)) { <line9> return deleteAccountRole(accCsid, input); <line10> } <line11> } <line12> ensureCSID(accCsid, ServiceMessages.POST_FAILED + ""accountroles account ""); <line13> try { <line14> AccountsCommon account = (AccountsCommon) get(accCsid, AccountsCommon.class); <line15> if (AccountClient.IMMUTABLE.equals(account.getRolesProtection())) { <line16> Response response = <line17> Response.status(Response.Status.FORBIDDEN) <line18> .entity(""Roles for Account: "" + accCsid + "" are immutable."") <line19> .type(""text/plain"") <line20> .build(); <line21> return response; <line22> } <line23> ServiceContext<AccountsCommon, AccountsCommon> ctx = <line24> createServiceContext((AccountsCommon) null, AccountsCommon.class, uriInfo); <line25> ctx.openConnection(); <line26> try { <line27> AccountRoleSubResource subResource = <line28> new AccountRoleSubResource(AccountRoleSubResource.ACCOUNT_ACCOUNTROLE_SERVICE); <line29> String accrolecsid = subResource.createAccountRole(ctx, input, SubjectType.ROLE); <line30> UriBuilder path = UriBuilder.fromResource(AccountResource.class); <line31> path.path(accCsid + ""/accountroles/"" + accrolecsid); <line32> Response response = Response.created(path.build()).build(); <line33> return response; <line34> } finally { <line35> ctx.closeConnection(); <line36> } <line37> } catch (Exception e) { <line38> throw bigReThrow(e, ServiceMessages.POST_FAILED, accCsid); <line39> } <line40> } <line41> } <line42> "	 <line27>	No
public class A { <line0> @Override <line1> public void onSuccess(@Nullable Void result) { <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> @Test <line1> public void testKafka() throws Exception { <line2> try (ClusterController clusterController = flink.startCluster(2)) { <line3> String testJsonTopic = ""test-json-"" + kafkaVersion + ""-"" + UUID.randomUUID().toString(); <line4> String testAvroTopic = ""test-avro-"" + kafkaVersion + ""-"" + UUID.randomUUID().toString(); <line5> kafka.createTopic(1, 1, testJsonTopic); <line6> String[] messages = <line7> new String[] { <line8> ""{\""rowtime\"": \""2018-03-12 08:00:00\"", \""user\"": \""Alice\"", \""event\"": { \""type\"":"" <line9> + "" \""WARNING\"", \""message\"": \""This is a warning.\""}}"", <line10> ""{\""rowtime\"": \""2018-03-12 08:10:00\"", \""user\"": \""Alice\"", \""event\"": { \""type\"":"" <line11> + "" \""WARNING\"", \""message\"": \""This is a warning.\""}}"", <line12> ""{\""rowtime\"": \""2018-03-12 09:00:00\"", \""user\"": \""Bob\"", \""event\"": { \""type\"":"" <line13> + "" \""WARNING\"", \""message\"": \""This is another warning.\""}}"", <line14> ""{\""rowtime\"": \""2018-03-12 09:10:00\"", \""user\"": \""Alice\"", \""event\"": { \""type\"":"" <line15> + "" \""INFO\"", \""message\"": \""This is a info.\""}}"", <line16> ""{\""rowtime\"": \""2018-03-12 09:20:00\"", \""user\"": \""Steve\"", \""event\"": { \""type\"":"" <line17> + "" \""INFO\"", \""message\"": \""This is another info.\""}}"", <line18> ""{\""rowtime\"": \""2018-03-12 09:30:00\"", \""user\"": \""Steve\"", \""event\"": { \""type\"":"" <line19> + "" \""INFO\"", \""message\"": \""This is another info.\""}}"", <line20> ""{\""rowtime\"": \""2018-03-12 09:30:00\"", \""user\"": null, \""event\"": { \""type\"":"" <line21> + "" \""WARNING\"", \""message\"": \""This is a bad message because the user is"" <line22> + "" missing.\""}}"", <line23> ""{\""rowtime\"": \""2018-03-12 10:40:00\"", \""user\"": \""Bob\"", \""event\"": { \""type\"":"" <line24> + "" \""ERROR\"", \""message\"": \""This is an error.\""}}"" <line25> }; <line26> kafka.sendMessages(testJsonTopic, messages); <line27> kafka.createTopic(1, 1, testAvroTopic); <line28> Map<String, String> varsMap = new HashMap<>(); <line29> varsMap.put(""$KAFKA_IDENTIFIER"", this.kafkaIdentifier); <line30> varsMap.put(""$TOPIC_JSON_NAME"", testJsonTopic); <line31> varsMap.put(""$TOPIC_AVRO_NAME"", testAvroTopic); <line32> varsMap.put(""$RESULT"", this.result.toAbsolutePath().toString()); <line33> varsMap.put( <line34> ""$KAFKA_BOOTSTRAP_SERVERS"", <line35> StringUtils.join(kafka.getBootstrapServerAddresses().toArray(), "","")); <line36> List<String> sqlLines = initializeSqlLines(varsMap); <line37> executeSqlStatements(clusterController, sqlLines); <line38> checkCsvResultFile(); <line39> } <line40> } <line41> } <line42> "	 <line24>	No
"public class A { <line0> @Test <line1> public void getAll() throws Exception { <line2> List<Module> modules = ESSuiteTest.moduleDao.getAll(); <line3> for (Module m : modules) { <line4> } <line5> assertEquals(""Wrong number of modules in elasticsearch"", 2, modules.size()); <line6> } <line7> } <line8> "	 <line4>	Yes
"public class A { <line0> @StateMachineAction <line1> public String releaseIPaddress( <line2> String instanceId, ProvisioningSettings settings, InstanceStatus result) { <line3> String eventId = EVENT_FAILED; <line4> VMPropertyHandler ph = new VMPropertyHandler(settings); <line5> try { <line6> ph.releaseManuallyDefinedIPAddresses(); <line7> eventId = EVENT_SUCCESS; <line8> } catch (Exception e) { <line9> String message = Messages.get(ph.getLocale(), ""error_release_ip"", new Object[] {instanceId}); <line10> ph.setSetting(VMPropertyHandler.SM_ERROR_MESSAGE, message); <line11> } <line12> return eventId; <line13> } <line14> } <line15> "	 <line9>	Yes
public class A { <line0> protected void removeChild(String child) { <line1> this.children.remove(child); <line2> zk.unwatchData(getPath(child)); <line3> } <line4> } <line5> 	 <line1>	Yes
public class A { <line0> @Override <line1> public HttpClientWithContext createClientPool(Context context) { <line2> HttpClient httpClient = context.owner().createHttpClient(httpClientOptions); <line3> httpClient.connectionHandler( <line4> connection -> { <line5> connection.closeHandler( <line6> v -> <line7> connection.exceptionHandler( <line8> e -> <line9> }); <line10> return new HttpClientWithContext(httpClient, context); <line11> } <line12> } <line13> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public Message receive(TestContext context, long timeout) { <line2> String topic = <line3> context.replaceDynamicContentInString( <line4> Optional.ofNullable(endpointConfiguration.getTopic()) <line5> .orElseThrow( <line6> () -> <line7> new CitrusRuntimeException( <line8> ""Missing Kafka topic to receive messages from - add topic to endpoint"" <line9> + "" configuration""))); <line10> if (log.isDebugEnabled()) { <line11> } <line12> if (CollectionUtils.isEmpty(consumer.subscription())) { <line13> consumer.subscribe(Arrays.asList(StringUtils.commaDelimitedListToStringArray(topic))); <line14> } <line15> ConsumerRecords<Object, Object> records = consumer.poll(Duration.ofMillis(timeout)); <line16> if (records.isEmpty()) { <line17> throw new MessageTimeoutException(timeout, topic); <line18> } <line19> if (log.isDebugEnabled()) { <line20> records.forEach( <line21> record -> <line22> } <line23> Message received = <line24> endpointConfiguration <line25> .getMessageConverter() <line26> .convertInbound(records.iterator().next(), endpointConfiguration, context); <line27> context.onInboundMessage(received); <line28> consumer.commitSync(Duration.ofMillis(endpointConfiguration.getTimeout())); <line29> return received; <line30> } <line31> } <line32> "	 <line11>	Yes
"public class A { <line0> @Test <line1> public void test07InvalidPatchEntities() { <line2> Object thingId = THING_IDS.get(0); <line3> String urlParameters = <line4> ""{\""Locations\"": [\n"" <line5> + ""    {\n"" <line6> + ""      \""name\"": \""West Roof\"",\n"" <line7> + ""      \""description\"": \""West Roof\"",\n"" <line8> + ""      \""location\"": { \""type\"": \""Point\"", \""coordinates\"": [-117.05, 51.05] },\n"" <line9> + ""      \""encodingType\"": \""application/vnd.geo+json\""\n"" <line10> + ""    }\n"" <line11> + ""  ]}""; <line12> invalidPatchEntity(EntityType.THING, urlParameters, thingId); <line13> urlParameters = <line14> ""{\""Datastreams\"": [\n"" <line15> + ""    {\n"" <line16> + ""      \""unitOfMeasurement\"": {\n"" <line17> + ""        \""name\"": \""Lumen\"",\n"" <line18> + ""        \""symbol\"": \""lm\"",\n"" <line19> + ""        \""definition\"":"" <line20> + "" \""http://www.qudt.org/qudt/owl/1.0.0/unit/Instances.html#Lumen\""\n"" <line21> + ""      }}]}""; <line22> invalidPatchEntity(EntityType.THING, urlParameters, thingId); <line23> Object sensorId = SENSOR_IDS.get(0); <line24> urlParameters = <line25> ""{\""Datastreams\"": [\n"" <line26> + ""    {\n"" <line27> + ""      \""unitOfMeasurement\"": {\n"" <line28> + ""        \""name\"": \""Lumen\"",\n"" <line29> + ""        \""symbol\"": \""lm\"",\n"" <line30> + ""        \""definition\"":"" <line31> + "" \""http://www.qudt.org/qudt/owl/1.0.0/unit/Instances.html#Lumen\""}\n"" <line32> + ""        ,\""Thing\"":{\""@iot.id\"":"" <line33> + quoteIdForJson(thingId) <line34> + ""}"" <line35> + ""      }]}""; <line36> invalidPatchEntity(EntityType.SENSOR, urlParameters, sensorId); <line37> Object obsPropId = OBSPROP_IDS.get(0); <line38> urlParameters = <line39> ""{\""Datastreams\"": [\n"" <line40> + ""    {\n"" <line41> + ""      \""unitOfMeasurement\"": {\n"" <line42> + ""        \""name\"": \""Lumen\"",\n"" <line43> + ""        \""symbol\"": \""lm\"",\n"" <line44> + ""        \""definition\"":"" <line45> + "" \""http://www.qudt.org/qudt/owl/1.0.0/unit/Instances.html#Lumen\""}\n"" <line46> + ""        ,\""Thing\"":{\""@iot.id\"":"" <line47> + quoteIdForJson(thingId) <line48> + ""}"" <line49> + ""      }]}""; <line50> invalidPatchEntity(EntityType.OBSERVED_PROPERTY, urlParameters, obsPropId); <line51> Object datastreamId = DATASTREAM_IDS.get(0); <line52> urlParameters = <line53> ""{\""ObservedProperty\"": {\n"" <line54> + ""  \t\""name\"": \""Count\"",\n"" <line55> + ""\t\""definition\"": \""http://qudt.org/vocab/unit#Dimensionless\"",\n"" <line56> + ""\t\""name\"": \""Count is a dimensionless property.\"",\n"" <line57> + ""\t\""description\"": \""Count is a dimensionless property.\""\n"" <line58> + ""  } }""; <line59> invalidPatchEntity(EntityType.DATASTREAM, urlParameters, datastreamId); <line60> urlParameters = <line61> ""{\""Sensor\"": {\n"" <line62> + ""  \t\""name\"": \""Acme Traffic 2000\"",  \n"" <line63> + ""  \t\""description\"": \""Acme Traffic 2000\"",  \n"" <line64> + ""  \t\""encodingType\"": \""application/pdf\"",\n"" <line65> + ""  \t\""metadata\"": \""Traffic counting device\""\n"" <line66> + ""  }}""; <line67> invalidPatchEntity(EntityType.DATASTREAM, urlParameters, datastreamId); <line68> urlParameters = <line69> ""{"" + ""\""Thing\"": {"" + ""  \""name\"": \""test\"","" + ""  \""description\"": \""test\"""" + "" }"" + ""}""; <line70> invalidPatchEntity(EntityType.DATASTREAM, urlParameters, datastreamId); <line71> urlParameters = <line72> ""{\""Observations\"": [\n"" <line73> + ""    {\n"" <line74> + ""      \""phenomenonTime\"": \""2015-03-01T00:00:00Z\"",\n"" <line75> + ""      \""result\"": 92122,\n"" <line76> + ""      \""resultQuality\"": \""High\""\n"" <line77> + ""    }\n"" <line78> + ""  ]}""; <line79> invalidPatchEntity(EntityType.DATASTREAM, urlParameters, datastreamId); <line80> } <line81> } <line82> "	 <line50>	No
"public class A { <line0> void handleSessionState() { <line1> String sessionStateStr = String.valueOf(sessionState.value()); <line2> if (""CONNECTED"".equals(sessionStateStr)) { <line3> if (!sessionConnectedFile.exists()) { <line4> try { <line5> touch(sessionConnectedFile); <line6> } catch (IOException e) { <line7> } <line8> } <line9> } else { <line10> if (sessionConnectedFile.exists() && !sessionConnectedFile.delete()) { <line11> } <line12> if (i++ % 60 == 0) { <line13> } <line14> } <line15> } <line16> } <line17> "	 <line7>	Yes
public class A { <line0> @Override <line1> public LiferayConnection connect() throws ConnectionException { <line2> return LiferayConnection.withOAuth2Authentication( <line3> httpService, <line4> oAuth2AuthenticationConfig.getOpenApiSpecPath(), <line5> oAuth2AuthenticationConfig.getConsumerKey(), <line6> oAuth2AuthenticationConfig.getConsumerSecret(), <line7> liferayProxyConfig.getProxyConfig()); <line8> } <line9> } <line10> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void transactionMarker() { <line2> } <line3> } <line4> 	 <line3>	No
"public class A { <line0> @Override <line1> public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) { <line2> if (Code.NONODE.intValue() == rc) { <line3> callback.operationFinished(ctx, null); <line4> return; <line5> } <line6> if (Code.OK.intValue() != rc) { <line7> KeeperException e = <line8> ZkUtils.logErrorAndCreateZKException( <line9> ""Could not read ownership for topic: "" + topic.toStringUtf8(), path, rc); <line10> callback.operationFailed(ctx, new PubSubException.ServiceDownException(e)); <line11> return; <line12> } <line13> HubInfo owner = null; <line14> try { <line15> owner = HubInfo.parse(new String(data)); <line16> } catch (HubInfo.InvalidHubInfoException ihie) { <line17> } <line18> int version = stat.getVersion(); <line19> callback.operationFinished(ctx, new Versioned<HubInfo>(owner, new ZkVersion(version))); <line20> return; <line21> } <line22> } <line23> "	 <line16>	No
"public class A { <line0> private void handshakeCompleted(PendingHandshakeConnection conn) { <line1> try { <line2> if (conn.handshakeSuccess) { <line3> final SelectionKey key = conn.socketChannel.getSocketChannel().register(selector, 0); <line4> final TCPConnection tcpConn = <line5> new TCPConnection(TCPEndpoint.this, conn.socketChannel, key, selector, conn.type); <line6> key.attach(tcpConn); <line7> switch (conn.type) { <line8> case INCOMING: <line9> connectionAccepted(tcpConn); <line10> break; <line11> case OUTGOING: <line12> connectionEstablished(tcpConn); <line13> break; <line14> default: <line15> throw new IllegalStateException(""Unknown connection type: "" + conn.type); <line16> } <line17> } else { <line18> handleHandshakeFailure(conn); <line19> } <line20> } catch (Exception e) { <line21> handleHandshakeFailure(conn); <line22> } <line23> } <line24> } <line25> "	 <line22>	No
public class A { <line0> private boolean handle(ServerConfiguration conf) throws Exception { <line1> ServerConfiguration bkConf = new ServerConfiguration(conf); <line2> InterleavedLedgerStorage interleavedStorage = new InterleavedLedgerStorage(); <line3> BookieImpl.mountLedgerStorageOffline(bkConf, interleavedStorage); <line4> DbLedgerStorage dbStorage = new DbLedgerStorage(); <line5> BookieImpl.mountLedgerStorageOffline(bkConf, dbStorage); <line6> int convertedLedgers = 0; <line7> for (long ledgerId : interleavedStorage.getActiveLedgersInRange(0, Long.MAX_VALUE)) { <line8> if (LOG.isDebugEnabled()) { <line9> } <line10> LedgerCache.LedgerIndexMetadata fi = interleavedStorage.readLedgerIndexMetadata(ledgerId); <line11> LedgerCache.PageEntriesIterable pages = interleavedStorage.getIndexEntries(ledgerId); <line12> long numberOfEntries = dbStorage.addLedgerToIndex(ledgerId, fi.fenced, fi.masterKey, pages); <line13> if (LOG.isDebugEnabled()) { <line14> } <line15> interleavedStorage.deleteLedger(ledgerId); <line16> if (++convertedLedgers % 1000 == 0) { <line17> } <line18> } <line19> dbStorage.shutdown(); <line20> interleavedStorage.shutdown(); <line21> return true; <line22> } <line23> } <line24> 	 <line9>	Yes
public class A { <line0> @Override <line1> public void onEvent(EndOfStreamEvent event) { <line2> eosLatch.countDown(); <line3> } <line4> } <line5> 	 <line1>	No
"public class A { <line0> private void mergeNextUUIDLookups(final EventQueryResponseBase mergedResponse) { <line1> final String queryId = mergedResponse.getQueryId(); <line2> final List<EventBase> mergedEvents = new LinkedList<>(mergedResponse.getEvents()); <line3> try { <line4> EventQueryResponseBase eventResponse = null; <line5> do { <line6> final BaseQueryResponse nextResponse = this.queryExecutor.next(queryId); <line7> eventResponse = this.validatePagedResponse(nextResponse); <line8> final List<EventBase> nextEvents = <line9> this.removeIrrelevantEventInformation(eventResponse.getEvents()); <line10> mergedEvents.addAll(nextEvents); <line11> } while (null != eventResponse); <line12> } catch (final NoResultsException e) { <line13> } finally { <line14> try { <line15> this.queryExecutor.close(queryId); <line16> } catch (final Exception e) { <line17> final String message = <line18> ""Unable to close UUID lookup query "" + queryId + "" while performing a content lookup""; <line19> } <line20> } <line21> mergedResponse.setEvents(mergedEvents); <line22> } <line23> } <line24> "	 <line19>	Yes
"public class A { <line0> @Override <line1> public String toModelName(String name) { <line2> if (importMapping.containsKey(name)) { <line3> return importMapping.get(name); <line4> } <line5> if (!StringUtils.isEmpty(modelNamePrefix)) { <line6> name = modelNamePrefix + ""_"" + name; <line7> } <line8> if (!StringUtils.isEmpty(modelNameSuffix)) { <line9> name = name + ""_"" + modelNameSuffix; <line10> } <line11> name = sanitizeName(name); <line12> if (isReservedWord(name)) { <line13> name = ""model_"" + name; <line14> } <line15> if (name.matches(""^\\d.*"")) { <line16> name = ""model_"" + name; <line17> } <line18> return camelize(name); <line19> } <line20> } <line21> "	 <line13>	Yes
"public class A { <line0> @Override <line1> public FlowFile write(final FlowFile source, final OutputStreamCallback writer) { <line2> validateRecordState(source); <line3> final StandardRepositoryRecord record = records.get(source); <line4> long writtenToFlowFile = 0L; <line5> ContentClaim newClaim = null; <line6> try { <line7> newClaim = claimCache.getContentClaim(); <line8> ensureNotAppending(newClaim); <line9> try (final OutputStream stream = claimCache.write(newClaim); <line10> final OutputStream disableOnClose = new DisableOnCloseOutputStream(stream); <line11> final ByteCountingOutputStream countingOut = <line12> new ByteCountingOutputStream(disableOnClose)) { <line13> try { <line14> recursionSet.add(source); <line15> writer.process(new FlowFileAccessOutputStream(countingOut, source)); <line16> } finally { <line17> writtenToFlowFile = countingOut.getBytesWritten(); <line18> bytesWritten += countingOut.getBytesWritten(); <line19> } <line20> } finally { <line21> recursionSet.remove(source); <line22> } <line23> } catch (final ContentNotFoundException nfe) { <line24> resetWriteClaims(); <line25> destroyContent(newClaim); <line26> handleContentNotFound(nfe, record); <line27> } catch (final FlowFileAccessException ffae) { <line28> resetWriteClaims(); <line29> destroyContent(newClaim); <line30> throw ffae; <line31> } catch (final IOException ioe) { <line32> resetWriteClaims(); <line33> destroyContent(newClaim); <line34> throw new ProcessException( <line35> ""IOException thrown from "" + connectableDescription + "": "" + ioe.toString(), ioe); <line36> } catch (final Throwable t) { <line37> resetWriteClaims(); <line38> destroyContent(newClaim); <line39> throw t; <line40> } <line41> removeTemporaryClaim(record); <line42> final FlowFileRecord newFile = <line43> new StandardFlowFileRecord.Builder() <line44> .fromFlowFile(record.getCurrent()) <line45> .contentClaim(newClaim) <line46> .contentClaimOffset(Math.max(0, newClaim.getLength() - writtenToFlowFile)) <line47> .size(writtenToFlowFile) <line48> .build(); <line49> record.setWorking(newFile); <line50> return newFile; <line51> } <line52> } <line53> "	 <line27>	No
"public class A { <line0> @ApiOperation( <line1> value = ""Returns all KIE containers for a specified KIE Server template"", <line2> response = ContainerSpecList.class) <line3> @ApiResponses( <line4> value = { <line5> @ApiResponse( <line6> code = 200, <line7> message = ""KIE containers"", <line8> examples = <line9> @Example({ <line10> @ExampleProperty(mediaType = JSON, value = CONTAINER_SPEC_LIST_JSON), <line11> @ExampleProperty(mediaType = XML, value = CONTAINER_SPEC_LIST_XML) <line12> })), <line13> @ApiResponse(code = 404, message = ""KIE Server template not found""), <line14> @ApiResponse(code = 400, message = ""Controller exception""), <line15> @ApiResponse(code = 500, message = ""Unexpected error"") <line16> }) <line17> @GET <line18> @Path(""servers/{serverTemplateId}/containers"") <line19> @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line20> @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line21> public Response listContainerSpec( <line22> @Context HttpHeaders headers, <line23> @ApiParam( <line24> name = ""serverTemplateId"", <line25> value = ""ID of the KIE Server template for which you are retrieving KIE containers"", <line26> required = true, <line27> example = ""test-kie-server"") <line28> @PathParam(""serverTemplateId"") <line29> String serverTemplateId) { <line30> String contentType = getContentType(headers); <line31> try { <line32> String response = <line33> marshal(contentType, specManagementService.listContainerSpec(serverTemplateId)); <line34> return createCorrectVariant(response, headers, Response.Status.OK); <line35> } catch (KieServerControllerIllegalArgumentException e) { <line36> return createCorrectVariant(e.getMessage(), headers, Response.Status.NOT_FOUND); <line37> } catch (KieServerControllerException e) { <line38> return createCorrectVariant( <line39> REQUEST_FAILED_TOBE_PROCESSED + e.getMessage(), headers, Response.Status.BAD_REQUEST); <line40> } catch (Exception e) { <line41> return createCorrectVariant( <line42> ""Unknown error "" + e.getMessage(), headers, Response.Status.INTERNAL_SERVER_ERROR); <line43> } <line44> } <line45> } <line46> "	 <line31>	No
public class A { <line0> @Override <line1> public void removeSystemProperty(TInfo info, TCredentials c, String property) <line2> throws ThriftSecurityException { <line3> if (!manager.security.canPerformSystemActions(c)) <line4> throw new ThriftSecurityException(c.getPrincipal(), SecurityErrorCode.PERMISSION_DENIED); <line5> try { <line6> SystemPropUtil.removeSystemProperty(manager.getContext(), property); <line7> updatePlugins(property); <line8> } catch (Exception e) { <line9> throw new RuntimeException(e.getMessage()); <line10> } <line11> } <line12> } <line13> 	 <line8>	No
"public class A { <line0> @Override <line1> public void delete(PostgresPersistenceManager<J> pm, J entityId) throws NoSuchEntityException { <line2> AbstractTableMultiDatastreams<J> tMd = tableCollection.getTableMultiDatastreams(); <line3> AbstractTableMultiDatastreamsObsProperties<J> tMdOp = <line4> tableCollection.getTableMultiDatastreamsObsProperties(); <line5> long count = <line6> pm.getDslContext() <line7> .delete(tMd) <line8> .where( <line9> tMd.getId() <line10> .in( <line11> DSL.select(tMdOp.getMultiDatastreamId()) <line12> .from(tMdOp) <line13> .where(tMdOp.getObsPropertyId().eq(entityId)))) <line14> .execute(); <line15> count = pm.getDslContext().delete(table).where(table.getId().eq(entityId)).execute(); <line16> if (count == 0) { <line17> throw new NoSuchEntityException(""ObservedProperty "" + entityId + "" not found.""); <line18> } <line19> } <line20> } <line21> "	 <line3>	No
public class A { <line0> boolean onMasterNodeLeft() { <line1> if (job instanceof ComputeJobMasterLeaveAware) { <line2> if (masterLeaveGuard.compareAndSet(false, true)) { <line3> try { <line4> ((ComputeJobMasterLeaveAware) job).onMasterNodeLeft(ses.session()); <line5> if (log.isDebugEnabled()) <line6> } catch (Exception e) { <line7> } <line8> } <line9> return true; <line10> } <line11> return false; <line12> } <line13> } <line14> 	 <line2>	No
"public class A { <line0> private String readAndLogErrorMessage(final int errorLength, final int info) <line1> throws JargonException { <line2> String additionalMessage = """"; <line3> if (errorLength != 0) { <line4> byte[] errorMessage = new byte[errorLength]; <line5> try { <line6> irodsConnection.read(errorMessage, 0, errorLength); <line7> } catch (ClosedChannelException e) { <line8> throw new JargonException(e); <line9> } catch (InterruptedIOException e) { <line10> throw new JargonException(e); <line11> } catch (IOException e) { <line12> disconnectWithForce(); <line13> throw new JargonException(e); <line14> } <line15> Tag errorTag; <line16> try { <line17> errorTag = Tag.readNextTag(errorMessage, getEncoding()); <line18> if (errorTag != null) { <line19> additionalMessage = <line20> errorTag.getTag(RErrMsg.PI_TAG).getTag(IRodsPI.MESSAGE_TAG).getStringValue(); <line21> } <line22> } catch (UnsupportedEncodingException e) { <line23> throw new JargonException(""Unsupported encoding for: "" + getEncoding()); <line24> } <line25> } <line26> return additionalMessage; <line27> } <line28> } <line29> "	 <line19>	Yes
"public class A { <line0> public static MetaModelException wrapException( <line1> SQLException e, String actionDescription, JdbcActionType actionType) <line2> throws MetaModelException { <line3> String message = e.getMessage(); <line4> if (message == null || message.isEmpty()) { <line5> message = ""Could not "" + actionDescription; <line6> } else { <line7> message = ""Could not "" + actionDescription + "": "" + message; <line8> } <line9> final SQLException nextException = e.getNextException(); <line10> if (nextException != null) { <line11> } <line12> switch (actionType) { <line13> case QUERY: <line14> case UPDATE: <line15> return new UncheckedSQLException(e); <line16> case COMMIT_ROLLBACK: <line17> case METADATA: <line18> default: <line19> return new MetaModelException(message, e); <line20> } <line21> } <line22> } <line23> "	 <line22>	No
public class A { <line0> public void insertAction(ActionInfo actionInfo) throws MetaStoreException { <line1> try { <line2> if (getActionById(actionInfo.getActionId()) != null) { <line3> actionDao.update(actionInfo); <line4> } else { <line5> actionDao.insert(actionInfo); <line6> } <line7> } catch (Exception e) { <line8> throw new MetaStoreException(e); <line9> } <line10> } <line11> } <line12> 	 <line1>	Yes
"public class A { <line0> @Override <line1> public void selectionChanged(SelectionChangedEvent event) { <line2> if (event.getSource() == viewer) { <line3> IStructuredSelection selection = (IStructuredSelection) viewer.getSelection(); <line4> if (selection != null && !selection.isEmpty()) { <line5> viewedElement = selection.getFirstElement(); <line6> } else { <line7> browserLoadingListener.setText(""""); <line8> return; <line9> } <line10> } <line11> if (viewedElement == null) { <line12> browserLoadingListener.setText(""""); <line13> return; <line14> } <line15> renderAndSetHtmlDescription(viewedElement); <line16> } <line17> } <line18> "	 <line12>	Yes
"public class A { <line0> private void init() { <line1> providers = Maps.newConcurrentMap(); <line2> String[] providerNames = config.getRealizationProviders(); <line3> for (String clsName : providerNames) { <line4> try { <line5> Class<? extends IRealizationProvider> cls = <line6> ClassUtil.forName(clsName, IRealizationProvider.class); <line7> IRealizationProvider p = <line8> (IRealizationProvider) <line9> cls.getMethod(""getInstance"", KylinConfig.class).invoke(null, config); <line10> providers.put(p.getRealizationType(), p); <line11> } catch (Exception | NoClassDefFoundError e) { <line12> if (e instanceof ClassNotFoundException || e instanceof NoClassDefFoundError) <line13> } <line14> } <line15> if (providers.isEmpty()) <line16> throw new IllegalArgumentException( <line17> ""Failed to find realization provider by url: "" + config.getMetadataUrl()); <line18> } <line19> } <line20> "	 <line12>	No
"public class A { <line0> private void runCheck() throws IOException, ClassNotFoundException, InterruptedException { <line1> Configuration conf = getConf(); <line2> String jobName = getTablename() + ""_check"" + EnvironmentEdgeManager.currentTime(); <line3> Path p = util.getDataTestDirOnTestFS(jobName); <line4> Job job = new Job(conf); <line5> job.setJarByClass(getClass()); <line6> job.setJobName(jobName); <line7> job.setPartitionerClass(NaturalKeyPartitioner.class); <line8> job.setGroupingComparatorClass(NaturalKeyGroupingComparator.class); <line9> job.setSortComparatorClass(CompositeKeyComparator.class); <line10> Scan scan = new Scan(); <line11> scan.addFamily(CHAIN_FAM); <line12> scan.addFamily(SORT_FAM); <line13> scan.readVersions(1); <line14> scan.setCacheBlocks(false); <line15> scan.setBatch(1000); <line16> int replicaCount = conf.getInt(NUM_REPLICA_COUNT_KEY, NUM_REPLICA_COUNT_DEFAULT); <line17> if (replicaCount != NUM_REPLICA_COUNT_DEFAULT) { <line18> scan.setConsistency(Consistency.TIMELINE); <line19> } <line20> TableMapReduceUtil.initTableMapperJob( <line21> getTablename().getName(), <line22> scan, <line23> LinkedListCheckingMapper.class, <line24> LinkKey.class, <line25> LinkChain.class, <line26> job); <line27> job.setReducerClass(LinkedListCheckingReducer.class); <line28> job.setOutputKeyClass(NullWritable.class); <line29> job.setOutputValueClass(NullWritable.class); <line30> FileOutputFormat.setOutputPath(job, p); <line31> assertEquals(true, job.waitForCompletion(true)); <line32> util.getTestFileSystem().delete(p, true); <line33> } <line34> } <line35> "	 <line1>	Yes
"public class A { <line0> @BeforeEach <line1> public void configureServiceClients(final TestInfo testInfo) { <line2> createClients(); <line3> prepareClients(); <line4> setServiceClients(adapter); <line5> final CommandConsumer commandConsumer = mock(CommandConsumer.class); <line6> when(commandConsumer.close(any())).thenReturn(Future.succeededFuture()); <line7> when(commandConsumerFactory.createCommandConsumer( <line8> anyString(), anyString(), VertxMockSupport.anyHandler(), any(), any())) <line9> .thenReturn(Future.succeededFuture(commandConsumer)); <line10> doAnswer( <line11> invocation -> { <line12> final Handler<AsyncResult<User>> resultHandler = invocation.getArgument(2); <line13> resultHandler.handle( <line14> Future.failedFuture( <line15> new ClientErrorException( <line16> HttpURLConnection.HTTP_UNAUTHORIZED, ""bad credentials""))); <line17> return null; <line18> }) <line19> .when(usernamePasswordAuthProvider) <line20> .authenticate(any(UsernamePasswordCredentials.class), any(), VertxMockSupport.anyHandler()); <line21> doAnswer( <line22> invocation -> { <line23> final JsonObject authInfo = invocation.getArgument(0); <line24> final String username = <line25> JsonHelper.getValue( <line26> authInfo, CredentialsConstants.FIELD_USERNAME, String.class, null); <line27> final String password = <line28> JsonHelper.getValue( <line29> authInfo, CredentialsConstants.FIELD_PASSWORD, String.class, null); <line30> if (username == null || password == null) { <line31> return null; <line32> } else { <line33> return UsernamePasswordCredentials.create(username, password); <line34> } <line35> }) <line36> .when(usernamePasswordAuthProvider) <line37> .getCredentials(any(JsonObject.class)); <line38> } <line39> } <line40> "	 <line39>	No
public class A { <line0> public void setJUnitResultDir(String dir) { <line1> jUnitResult.setDir(dir); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void setPermission(INodeAuthorizationInfo node, FsPermission permission) { <line2> if (isSentryManaged(node)) { <line3> } <line4> defaultAuthzProvider.setPermission(node, permission); <line5> } <line6> } <line7> 	 <line2>	No
"public class A { <line0> @Override <line1> public void setup(OperatorContext context) { <line2> super.setup(context); <line3> fastMergeActive = <line4> outputFS.getConf().getBoolean(""dfs.support.append"", true) <line5> && appFS.getUri().equals(outputFS.getUri()); <line6> defaultBlockSize = outputFS.getDefaultBlockSize(new Path(filePath)); <line7> fastMergerDecisionMaker = <line8> new FastMergerDecisionMaker(blocksDirectoryPath, appFS, defaultBlockSize); <line9> } <line10> } <line11> "	 <line6>	Yes
"public class A { <line0> public String uploadContentInDatabase(MultipartFile file) throws InsightsCustomException { <line1> String returnMessage = """"; <line2> String originalFilename = file.getOriginalFilename(); <line3> JsonParser jsonParser = new JsonParser(); <line4> String fileExt = FilenameUtils.getExtension(originalFilename); <line5> try { <line6> if (fileExt.equalsIgnoreCase(""json"")) { <line7> String contentJson = readFileAndCreateJson(file); <line8> JsonArray contentJsonArray = jsonParser.parse(contentJson).getAsJsonArray(); <line9> returnMessage = saveBulkContentDefinition(contentJsonArray); <line10> } else { <line11> throw new InsightsCustomException(""Invalid file format.""); <line12> } <line13> } catch (Exception ex) { <line14> throw new InsightsCustomException(ex.getMessage()); <line15> } <line16> return returnMessage; <line17> } <line18> } <line19> "	 <line2>	No
public class A { <line0> @Override <line1> public void onScanEnded() { <line2> if (createdMethodCount > 0) { <line3> } <line4> } <line5> } <line6> 	 <line5>	No
"public class A { <line0> @ExceptionHandler(value = {UpdateException.class}) <line1> protected ResponseEntity<ExceptionInfo> handleUpdateException(UpdateException ex) { <line2> String error = ""An error occurred while updating or getting update infos: "" + ex.getMessage(); <line3> return new ResponseEntity<>( <line4> new ExceptionInfo( <line5> 500, error, ex.getClass().getName(), error, SessionStorage.requestUrl.get()), <line6> HttpStatus.valueOf(500)); <line7> } <line8> } <line9> "	 <line5>	No
public class A { <line0> public void close() { <line1> if (vaultContainer != null && vaultContainer.isRunning()) { <line2> vaultContainer.stop(); <line3> } <line4> if (postgresContainer != null && postgresContainer.isRunning()) { <line5> postgresContainer.stop(); <line6> } <line7> } <line8> } <line9> 	 <line1>	Yes
public class A { <line0> private synchronized void addEndPoint(ServiceEndPoint endPoint) { <line1> _recentlyRemovedEndPoints.remove(endPoint); <line2> markEndPointAsBad(endPoint); <line3> } <line4> } <line5> 	 <line3>	Yes
public class A { <line0> @Override <line1> public boolean handleResponse(MessageContext messageContext, Object endpoint) <line2> throws IOException, SAXException { <line3> if (validateResponse) { <line4> Source responseSource = getValidationResponseSource(messageContext.getResponse()); <line5> if (responseSource != null) { <line6> SAXParseException[] errors = validator.validate(responseSource, errorHandler); <line7> if (!ObjectUtils.isEmpty(errors)) { <line8> return handleResponseValidationErrors(messageContext, errors); <line9> } else if (logger.isDebugEnabled()) { <line10> } <line11> } <line12> } <line13> return true; <line14> } <line15> } <line16> 	 <line10>	Yes
public class A { <line0> protected final void putPercentType( <line1> Map<Channel, State> targetMap, <line2> @Nullable Channel channel, <line3> @Nullable Double value, <line4> int factor) { <line5> if (channel != null) { <line6> State result = UnDefType.UNDEF; <line7> if (value != null) { <line8> result = new QuantityType<>(value * factor, Units.PERCENT); <line9> } else { <line10> } <line11> targetMap.put(channel, result); <line12> } <line13> } <line14> } <line15> 	 <line10>	Yes
"public class A { <line0> @Override <line1> protected void doUpgrade() throws Exception { <line2> List<Long> queuedOrganizationIds = new ArrayList<>(); <line3> try (Statement s = <line4> connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); <line5> ResultSet resultSet = <line6> s.executeQuery( <line7> ""select organizationId from Organization_ where type_ = "" + ""'account'"")) { <line8> while (resultSet.next()) { <line9> long organizationId = resultSet.getLong(""organizationId""); <line10> queuedOrganizationIds.add(organizationId); <line11> } <line12> } <line13> while (!queuedOrganizationIds.isEmpty()) { <line14> List<Long> organizationIds = new ArrayList<>(queuedOrganizationIds); <line15> queuedOrganizationIds.clear(); <line16> for (long organizationId : organizationIds) { <line17> Organization organization = _organizationLocalService.getOrganization(organizationId); <line18> long parentCommerceAccountId = <line19> _getParentCommerceAccountId(organization.getParentOrganizationId()); <line20> if (parentCommerceAccountId < 0) { <line21> queuedOrganizationIds.add(organizationId); <line22> continue; <line23> } <line24> _addCommerceAccount(organization, parentCommerceAccountId); <line25> } <line26> if (queuedOrganizationIds.size() >= organizationIds.size()) { <line27> String organizationIdsString = <line28> ListUtil.toString(organizationIds, StringPool.BLANK, StringPool.COMMA_AND_SPACE); <line29> return; <line30> } <line31> } <line32> } <line33> } <line34> "	 <line30>	No
"public class A { <line0> @Test <line1> public void testEchoMethodInvocation() throws Exception { <line2> Work echoResult = <line3> thriftClient.echo(new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY)); <line4> MockEndpoint mockEndpoint = getMockEndpoint(""mock:thrift-secure-service""); <line5> mockEndpoint.expectedMessageCount(1); <line6> mockEndpoint.expectedHeaderValuesReceivedInAnyOrder( <line7> ThriftConstants.THRIFT_METHOD_NAME_HEADER, ""echo""); <line8> mockEndpoint.assertIsSatisfied(); <line9> assertNotNull(echoResult); <line10> assertTrue(echoResult instanceof Work); <line11> assertEquals(THRIFT_TEST_NUM1, echoResult.num1); <line12> assertEquals(Operation.MULTIPLY, echoResult.op); <line13> } <line14> } <line15> "	 <line2>	Yes
public class A { <line0> @Override <line1> public JiraWriter createWriter(RuntimeContainer container) { <line2> Action action = sink.getAction(); <line3> switch (action) { <line4> case DELETE: <line5> { <line6> return new JiraDeleteWriter(this); <line7> } <line8> case INSERT: <line9> { <line10> return new JiraInsertWriter(this); <line11> } <line12> case UPDATE: <line13> { <line14> return new JiraUpdateWriter(this); <line15> } <line16> default: <line17> { <line18> return null; <line19> } <line20> } <line21> } <line22> } <line23> 	 <line18>	Yes
"public class A { <line0> @Deprecated <line1> public static ManagementContext startManagement(Application app, BrooklynProperties props) { <line2> if (isManaged(app)) { <line3> throw new IllegalStateException( <line4> ""Application "" + app + "" is already managed, so can't set brooklyn properties""); <line5> } <line6> ManagementContext mgmt = new LocalManagementContext(props); <line7> mgmt.getEntityManager().manage(app); <line8> return mgmt; <line9> } <line10> } <line11> "	 <line2>	Yes
"public class A { <line0> @Test <line1> public void test_06_MixedVep() { <line2> compareVep(""testHg3775Chr7"", path(""mixed_chr7.vcf"")); <line3> } <line4> } <line5> "	 <line2>	Yes
public class A { <line0> public void initialize() { <line1> ZooKeeperFactory zooKeeperFactory = new ZooKeeperFactory(); <line2> zooKeeperFactory.setConnectString(endpoint); <line3> zooKeeperFactory.setSessionTimeout(sessionTimeout); <line4> IZookeeper zooKeeper = null; <line5> try { <line6> zooKeeper = zooKeeperFactory.create(); <line7> zoo = new Zoo(zooKeeperFactory.create()); <line8> if (zoo.root().hasChild(rootNode)) { <line9> zoo.root().child(rootNode).removeWithChildren(); <line10> } <line11> zoo.root().createChild(znode().withPath(rootNode)); <line12> } finally { <line13> if (zooKeeper != null) { <line14> try { <line15> zooKeeper.close(); <line16> } catch (InterruptedException e) { <line17> } <line18> } <line19> } <line20> } <line21> } <line22> 	 <line8>	No
"public class A { <line0> public URL[] getPlatformJars() throws MalformedURLException, ConfigurationException { <line1> List<URL> defaultPlatformJARsList = getDefaultCommonClassLoaderClasspath(); <line2> URL[] defaultPlatformJARs = <line3> defaultPlatformJARsList.toArray(new URL[defaultPlatformJARsList.size()]); <line4> URL[] platformJARs = <line5> (URL[]) config.getEntry(COMPONENT, ""platformJARs"", URL[].class, defaultPlatformJARs); <line6> URL[] addPlatformJARs = addedPlatformJars.toArray(new URL[addedPlatformJars.size()]); <line7> if (addPlatformJARs.length > 0) { <line8> if (logger.isDebugEnabled()) { <line9> StringBuilder buffer = new StringBuilder(); <line10> for (int i = 0; i < addPlatformJARs.length; i++) { <line11> if (i > 0) buffer.append(""\n""); <line12> buffer.append(""    "" + addPlatformJARs[i].toExternalForm()); <line13> } <line14> } <line15> ArrayList<URL> list = new ArrayList<>(); <line16> for (int i = 0; i < platformJARs.length; i++) list.add(platformJARs[i]); <line17> for (int i = 0; i < addPlatformJARs.length; i++) list.add(addPlatformJARs[i]); <line18> platformJARs = list.toArray(new URL[list.size()]); <line19> } <line20> if (logger.isDebugEnabled()) { <line21> StringBuilder buffer = new StringBuilder(); <line22> for (int i = 0; i < platformJARs.length; i++) { <line23> if (i > 0) buffer.append(""\n""); <line24> buffer.append(""    "" + platformJARs[i].toExternalForm()); <line25> } <line26> } <line27> return (platformJARs); <line28> } <line29> } <line30> "	 <line14>	Yes
public class A { <line0> @Override <line1> public String explain(String query, String language) throws RepositoryException { <line2> final org.modeshape.jcr.api.query.Query jcrQuery = <line3> (org.modeshape.jcr.api.query.Query) <line4> getLocalSession() <line5> .getSession() <line6> .getWorkspace() <line7> .getQueryManager() <line8> .createQuery(query, language); <line9> return jcrQuery.explain().getPlan(); <line10> } <line11> } <line12> 	 <line10>	No
public class A { <line0> @Override <line1> public void doRender( <line2> RenderContext rc, <line3> Collection<? extends T> input, <line4> Collection<? super T> rejected, <line5> PickManager pickManager, <line6> MapContext<?> mapContext, <line7> ModelDataRetriever<T> dataRetriever) { <line8> int listId = -1; <line9> boolean compileList = false; <line10> if (rc.getRenderMode() == AbstractGeometry.RenderMode.DRAW) { <line11> Set<Geometry> pickedGeometries = pickManager.getPickedGeometries(); <line12> if (!myLastPicked.equals(pickedGeometries)) { <line13> myDrawDirty = true; <line14> myLastPicked = new WeakHashSet<>(pickedGeometries); <line15> } <line16> if (myDrawDirty) { <line17> compileList = true; <line18> if (myDrawDisplayListId == 0) { <line19> myDrawDisplayListId = rc.getGL().getGL2().glGenLists(1); <line20> } <line21> myDrawDirty = false; <line22> } <line23> listId = myDrawDisplayListId; <line24> } else if (rc.getRenderMode() == AbstractGeometry.RenderMode.PICK) { <line25> if (myPickDirty) { <line26> compileList = true; <line27> if (myPickDisplayListId == 0) { <line28> myPickDisplayListId = rc.getGL().getGL2().glGenLists(1); <line29> } <line30> myPickDirty = false; <line31> } <line32> listId = myPickDisplayListId; <line33> } else { <line34> throw new UnexpectedEnumException(rc.getRenderMode()); <line35> } <line36> myRenderer.initializeShaders(rc, input); <line37> if (compileList) { <line38> rc.getGL().getGL2().glNewList(listId, GL2.GL_COMPILE); <line39> try { <line40> doRender(rc, input, pickManager, mapContext, rejected, dataRetriever); <line41> } finally { <line42> rc.getGL().getGL2().glEndList(); <line43> } <line44> } <line45> if (listId != -1) { <line46> if (rc.getGL().glGetError() != GL.GL_NO_ERROR) { <line47> } <line48> rc.getGL().getGL2().glCallList(listId); <line49> } <line50> myRenderer.cleanupShaders(rc, input); <line51> } <line52> } <line53> 	 <line47>	Yes
"public class A { <line0> @Override <line1> @Transactional <line2> @Deprecated <line3> public void sendApiRecordCreationEmail(String toEmail, String orcid) { <line4> ProfileEntity record = profileEntityCacheManager.retrieve(orcid); <line5> String creatorName = <line6> record.getSource() == null ? null : sourceEntityUtils.getSourceName(record.getSource()); <line7> Locale userLocale = getUserLocaleFromProfileEntity(record); <line8> String email = emailManager.findPrimaryEmail(orcid).getEmail(); <line9> String emailName = deriveEmailFriendlyName(orcid); <line10> String verificationUrl = createClaimVerificationUrl(email, orcidUrlManager.getBaseUrl()); <line11> String subject = null; <line12> String body = null; <line13> String htmlBody = null; <line14> String sender = null; <line15> subject = getSubject(""email.subject.api_record_creation"", userLocale); <line16> Map<String, Object> templateParams = new HashMap<String, Object>(); <line17> templateParams.put(""emailName"", emailName); <line18> templateParams.put(""orcid"", orcid); <line19> templateParams.put(""subject"", subject); <line20> templateParams.put(""creatorName"", creatorName); <line21> templateParams.put(""baseUri"", orcidUrlManager.getBaseUrl()); <line22> templateParams.put(""baseUriHttp"", orcidUrlManager.getBaseUriHttp()); <line23> templateParams.put(""verificationUrl"", verificationUrl); <line24> addMessageParams(templateParams, userLocale); <line25> body = templateManager.processTemplate(""api_record_creation_email.ftl"", templateParams); <line26> htmlBody = <line27> templateManager.processTemplate(""api_record_creation_email_html.ftl"", templateParams); <line28> if (apiRecordCreationEmailEnabled) { <line29> mailGunManager.sendEmail(CLAIM_NOTIFY_ORCID_ORG, email, subject, body, htmlBody); <line30> } else { <line31> } <line32> } <line33> } <line34> "	 <line31>	Yes
public class A { <line0> public static void uploadData( <line1> String ftpHost, <line2> int port, <line3> String user, <line4> String password, <line5> String data, <line6> String destinationFileName) { <line7> byte[] decode = Base64.getDecoder().decode(data); <line8> try (InputStream is = new ByteArrayInputStream(decode)) { <line9> upload(ftpHost, port, user, password, is, destinationFileName); <line10> } catch (IOException e) { <line11> } <line12> } <line13> } <line14> 	 <line8>	Yes
"public class A { <line0> @Override <line1> public <T> SourceDriver<T> createSource(ProcessScript<T> script) throws IOException { <line2> if (script == null) { <line3> throw new IllegalArgumentException(""script must not be null""); <line4> } <line5> JdbcScript<T> jdbcScript = <line6> JdbcResourceUtil.convert(profile, script, arguments, DriverScript.Kind.SOURCE); <line7> T object = ProcessUtil.newDataModel(profile.getResourceName(), script); <line8> Connection connection = profile.openConnection(); <line9> boolean succeed = false; <line10> try { <line11> JdbcSourceDriver<T> driver = new JdbcSourceDriver<>(profile, jdbcScript, connection, object); <line12> succeed = true; <line13> return driver; <line14> } finally { <line15> if (succeed == false) { <line16> try { <line17> connection.close(); <line18> } catch (SQLException e) { <line19> for (SQLException ex = e; ex != null; ex = ex.getNextException()) { <line20> } <line21> } <line22> } <line23> } <line24> } <line25> } <line26> "	 <line7>	No
"public class A { <line0> private void findPrefixInChildren(String prefix, ZooKeeper zookeeper, String dir) <line1> throws KeeperException, InterruptedException { <line2> List<String> names = zookeeper.getChildren(dir, false); <line3> for (String name : names) { <line4> if (name.startsWith(prefix)) { <line5> id = name; <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> break; <line9> } <line10> } <line11> if (id == null) { <line12> id = zookeeper.create(dir + ""/"" + prefix, data, getAcl(), EPHEMERAL_SEQUENTIAL); <line13> if (LOG.isDebugEnabled()) { <line14> } <line15> } <line16> } <line17> } <line18> "	 <line7>	Yes
public class A { <line0> public static String[] getTempAttachmentNames(long groupId, String tempFolderName) <line1> throws RemoteException { <line2> try { <line3> String[] returnValue = KBArticleServiceUtil.getTempAttachmentNames(groupId, tempFolderName); <line4> return returnValue; <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
public class A { <line0> public static <I extends WritableComparable, V extends Writable, E extends Writable> <line1> Piece<I, V, E, NoMessage, Object> removeVertices( <line2> final String pieceName, final SupplierFromVertex<I, V, E, Boolean> shouldRemoveVertex) { <line3> return new Piece<I, V, E, NoMessage, Object>() { <line4> private ReducerHandle<LongWritable, LongWritable> countRemovedAgg; <line5>  <line6> @Override <line7> public void registerReducers(CreateReducersApi reduceApi, Object executionStage) { <line8> countRemovedAgg = reduceApi.createLocalReducer(SumReduce.LONG); <line9> } <line10>  <line11> @Override <line12> public VertexSender<I, V, E> getVertexSender( <line13> final BlockWorkerSendApi<I, V, E, NoMessage> workerApi, Object executionStage) { <line14> return new InnerVertexSender() { <line15> @Override <line16> public void vertexSend(Vertex<I, V, E> vertex) { <line17> if (shouldRemoveVertex.get(vertex)) { <line18> workerApi.removeVertexRequest(vertex.getId()); <line19> reduceLong(countRemovedAgg, 1); <line20> } <line21> } <line22> }; <line23> } <line24>  <line25> @Override <line26> public void masterCompute(BlockMasterApi master, Object executionStage) { <line27> } <line28>  <line29> @Override <line30> public String toString() { <line31> return pieceName; <line32> } <line33> }; <line34> } <line35> } <line36> 	 <line11>	No
public class A { <line0> @Deprecated <line1> public static com.liferay.portal.kernel.model.CountrySoap getCountryByA2(String a2) <line2> throws RemoteException { <line3> try { <line4> com.liferay.portal.kernel.model.Country returnValue = CountryServiceUtil.getCountryByA2(a2); <line5> return com.liferay.portal.kernel.model.CountrySoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line2>	No
"public class A { <line0> @Override <line1> protected void setUp() throws Exception { <line2> deliveryMode = DeliveryMode.NON_PERSISTENT; <line3> topic = false; <line4> super.setUp(); <line5> consumerDestination2 = consumeSession.createTopic(""FOO.BAR.HUMBUG2""); <line6> if (durable) { <line7> consumer2 = consumeSession.createDurableSubscriber((Topic) consumerDestination2, getName()); <line8> } else { <line9> consumer2 = consumeSession.createConsumer(consumerDestination2); <line10> } <line11> } <line12> } <line13> "	 <line6>	Yes
"public class A { <line0> public void showMessage(String text, short[] textColor, short[] backColor) { <line1> short[][][] message = new short[(text.length() + 2) * 8][8][3]; <line2> System.arraycopy(alphabet.getLetter("" ""), 0, message, 0, 8); <line3> for (int i = 0; i < text.length(); i++) { <line4> if (!alphabet.isAvailable(String.valueOf(text.charAt(i)))) { <line5> clearFrameBuffer(); <line6> return; <line7> } <line8> System.arraycopy( <line9> alphabet.getLetter(String.valueOf(text.charAt(i))), 0, message, (i + 1) * 8, 8); <line10> } <line11> System.arraycopy(alphabet.getLetter("" ""), 0, message, message.length - 8, 8); <line12> short[][][] currentFrame = new short[8][8][3]; <line13> for (int i = 0; i < message.length - 8; i++) { <line14> for (int x = 0; x < 8; x++) { <line15> for (int y = 0; y < 8; y++) { <line16> currentFrame[x][y][0] = message[x + i][y][0] == 0 ? backColor[0] : textColor[0]; <line17> currentFrame[x][y][1] = message[x + i][y][1] == 0 ? backColor[1] : textColor[1]; <line18> currentFrame[x][y][2] = message[x + i][y][2] == 0 ? backColor[2] : textColor[2]; <line19> } <line20> } <line21> frameBuffer.setPixels(currentFrame); <line22> try { <line23> Thread.sleep(100); <line24> } catch (InterruptedException e) { <line25> } <line26> } <line27> } <line28> } <line29> "	 <line5>	Yes
"public class A { <line0> public void run() { <line1> setRunning(true); <line2> if (messageListener == null) { <line3> throw new IllegalStateException(""messageListener cannot be 'null""); <line4> } <line5> if (exceptionListener == null) { <line6> throw new IllegalStateException(""exceptionListener cannot be 'null""); <line7> } <line8> try { <line9> execute(); <line10> } catch (Throwable t) { <line11> } <line12> } <line13> } <line14> "	 <line11>	Yes
public class A { <line0> public void consume() { <line1> while (true) { <line2> Message msg; <line3> try { <line4> msg = queue.take(); <line5> if (Message.POISON_PILL.equals(msg)) { <line6> break; <line7> } <line8> } catch (InterruptedException e) { <line9> return; <line10> } <line11> String sender = msg.getHeader(Headers.SENDER); <line12> String body = msg.getBody(); <line13> } <line14> } <line15> } <line16> 	 <line6>	Yes
"public class A { <line0> @Test <line1> public void testImportPDFAttachment() throws Exception { <line2> try { <line3> byte[] content = copyToBytesFromClasspath(TEST_ATTACHMENT_PDF); <line4> GridFS gridFS = new GridFS(mongoDB); <line5> GridFSInputFile in = gridFS.createFile(content); <line6> in.setFilename(""lorem.pdf""); <line7> in.setContentType(""application/pdf""); <line8> in.save(); <line9> in.validate(); <line10> String id = in.getId().toString(); <line11> GridFSDBFile out = gridFS.findOne(in.getFilename()); <line12> logger.debug(""GridFS from findOne: {}"", out); <line13> out = gridFS.findOne(new ObjectId(id)); <line14> Assert.assertEquals(out.getId(), in.getId()); <line15> Thread.sleep(wait); <line16> refreshIndex(); <line17> CountResponse countResponse = getNode().client().count(countRequest(getIndex())).actionGet(); <line18> assertThat(countResponse.getCount(), equalTo(1l)); <line19> GetResponse getResponse = getNode().client().get(getRequest(getIndex()).id(id)).get(); <line20> logger.debug(""Get request for id {}: {}"", id, getResponse.isExists()); <line21> assertThat(getResponse.isExists(), equalTo(true)); <line22> SearchResponse response = <line23> getNode() <line24> .client() <line25> .prepareSearch(getIndex()) <line26> .setQuery(QueryBuilders.queryString(""Lorem ipsum dolor"")) <line27> .execute() <line28> .actionGet(); <line29> long totalHits = response.getHits().getTotalHits(); <line30> assertThat(totalHits, equalTo(1l)); <line31> gridFS.remove(new ObjectId(id)); <line32> Thread.sleep(wait); <line33> refreshIndex(); <line34> getResponse = getNode().client().get(getRequest(getIndex()).id(id)).get(); <line35> assertThat(getResponse.isExists(), equalTo(false)); <line36> } catch (Throwable t) { <line37> Assert.fail(""testImportPDFAttachment failed"", t); <line38> } finally { <line39> } <line40> } <line41> } <line42> "	 <line38>	No
"public class A { <line0> @Override <line1> protected void doHealthCheck(Builder builder) throws Exception { <line2> try { <line3> ClusterHealthRequest request = new ClusterHealthRequest(); <line4> ClusterHealthResponse response = client.cluster().health(request, RequestOptions.DEFAULT); <line5> if (response.getStatus().equals(ClusterHealthStatus.GREEN) <line6> || response.getStatus().equals(ClusterHealthStatus.YELLOW)) { <line7> builder.up(); <line8> } else { <line9> builder.down(); <line10> } <line11> builder.withDetail( <line12> ""Number of Update Queue Items"", elasticsearchUpdateQueueItemRepository.count()); <line13> } catch (Exception e) { <line14> builder.down(e); <line15> } <line16> } <line17> } <line18> "	 <line15>	No
"public class A { <line0> public void sendEndStatus(int exit, String rebalanceSource, String rebalanceTarget) { <line1> TaskExitState exitState = new TaskExitState(); <line2> File jobExit = new File(jobDir, ""job.exit""); <line3> if (jobExit.exists() && jobExit.canRead()) { <line4> try { <line5> CodecJSON.INSTANCE.decode(exitState, LessFiles.read(jobExit)); <line6> } catch (Exception ex) { <line7> ex.printStackTrace(); <line8> } <line9> } <line10> exitState.setWasStopped(wasStopped()); <line11> StatusTaskEnd end = new StatusTaskEnd(minion.uuid, id, node, exit, fileCount, fileBytes); <line12> end.setRebalanceSource(rebalanceSource); <line13> end.setRebalanceTarget(rebalanceTarget); <line14> end.setWasQueued(wasQueued); <line15> end.setExitState(exitState); <line16> setRebalanceSource(null); <line17> setRebalanceTarget(null); <line18> Minion.tasksCompletedPerHour.mark(); <line19> minion.sendStatusMessage(end); <line20> try { <line21> minion.kickNextJob(); <line22> } catch (Exception e) { <line23> } <line24> } <line25> } <line26> "	 <line23>	Yes
"public class A { <line0> @Override <line1> protected void setup(Context context) throws IOException, InterruptedException { <line2> super.setup(context); <line3> Configuration conf = context.getConfiguration(); <line4> if (inputCategories == null) { <line5> Set<String> newCategories = new HashSet<String>(); <line6> DefaultStringifier<Set<String>> setStringifier = <line7> new DefaultStringifier<Set<String>>(conf, GenericsUtil.getClass(newCategories)); <line8> String categoriesStr = <line9> conf.get(""wikipedia.categories"", setStringifier.toString(newCategories)); <line10> inputCategories = setStringifier.fromString(categoriesStr); <line11> } <line12> exactMatchOnly = conf.getBoolean(""exact.match.only"", false); <line13> all = conf.getBoolean(""all.files"", true); <line14> } <line15> } <line16> "	 <line14>	Yes
public class A { <line0> public void removeFilterByKey(Object key) { <line1> IUserFilterState filter = m_filterMap.remove(key); <line2> fireFilterRemoved(filter); <line3> } <line4> } <line5> 	 <line0>	No
"public class A { <line0> @Override <line1> public Statement apply(Statement base, Description description) { <line2> Class<?> clazz = description.getTestClass(); <line3> String mname = description.getMethodName(); <line4> Collection<Annotation> annotations = description.getAnnotations(); <line5> final int rounds = getRoundsForFullMethodName(clazz.getCanonicalName() + ""."" + mname); <line6> List<Annotation> modifiedAnnotations = new ArrayList<Annotation>(annotations.size()); <line7> boolean hit = false; <line8> for (Annotation a : annotations) { <line9> if (a.annotationType().equals(BenchmarkOptions.class)) { <line10> final BenchmarkOptions old = (BenchmarkOptions) a; <line11> BenchmarkOptions replacement = getWrappedBenchmarkOptions(old, rounds); <line12> modifiedAnnotations.add(replacement); <line13> hit = true; <line14> } else { <line15> modifiedAnnotations.add(a); <line16> } <line17> } <line18> if (!hit) { <line19> BenchmarkOptions opts = getDefaultBenchmarkOptions(rounds); <line20> modifiedAnnotations.add(opts); <line21> } <line22> Description roundsAdjustedDesc = <line23> Description.createTestDescription( <line24> clazz, mname, modifiedAnnotations.toArray(new Annotation[modifiedAnnotations.size()])); <line25> return rule.apply(base, roundsAdjustedDesc); <line26> } <line27> } <line28> "	 <line3>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> synchronized (THREADS) { <line4> THREADS.add(this); <line5> } <line6> while (okToRun.get()) { <line7> sendRandomLine(); <line8> synchronized (okToRun) { <line9> okToRun.wait(TimeUnit.SECONDS.toMillis(5L)); <line10> } <line11> } <line12> } catch (Exception e) { <line13> } finally { <line14> try { <line15> session.close(true); <line16> } finally { <line17> session.removeSessionListener(this); <line18> synchronized (THREADS) { <line19> THREADS.remove(this); <line20> } <line21> } <line22> } <line23> } <line24> } <line25> 	 <line20>	No
public class A { <line0> @Override <line1> public AnnouncementsEntry findByPrimaryKey(Serializable primaryKey) throws NoSuchEntryException { <line2> AnnouncementsEntry announcementsEntry = fetchByPrimaryKey(primaryKey); <line3> if (announcementsEntry == null) { <line4> if (_log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchEntryException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return announcementsEntry; <line9> } <line10> } <line11> 	 <line5>	Yes
"public class A { <line0> public EtherRainStatusResponse commandStatus() throws EtherRainException, IOException { <line1> commandLogin(); <line2> List<String> responseList = sendGet(""result.cgi?xs""); <line3> if (responseList.isEmpty()) { <line4> throw new EtherRainException(""Empty Response""); <line5> } <line6> EtherRainStatusResponse response = new EtherRainStatusResponse(); <line7> for (String line : responseList) { <line8> Matcher m = responseStatusPattern.matcher(line); <line9> if (m.matches()) { <line10> String command = m.replaceAll(""$1""); <line11> String status = m.replaceAll(""$2""); <line12> switch (command) { <line13> case ""un"": <line14> response.setUniqueName(status); <line15> break; <line16> case ""ma"": <line17> response.setMacAddress(status); <line18> break; <line19> case ""ac"": <line20> response.setServiceAccount(status); <line21> break; <line22> case ""os"": <line23> response.setOperatingStatus(EtherRainOperatingStatus.valueOf(status.toUpperCase())); <line24> break; <line25> case ""cs"": <line26> response.setLastCommandStatus(EtherRainCommandStatus.valueOf(status.toUpperCase())); <line27> break; <line28> case ""rz"": <line29> response.setLastCommandResult(EtherRainCommandResult.valueOf(status.toUpperCase())); <line30> break; <line31> case ""ri"": <line32> response.setLastActiveValue(Integer.parseInt(status)); <line33> break; <line34> case ""rn"": <line35> response.setRainSensor(Integer.parseInt(status) == 1); <line36> break; <line37> default: <line38> } <line39> } <line40> } <line41> return response; <line42> } <line43> } <line44> "	 <line22>	No
public class A { <line0> @Override <line1> public void onMessage(final Message message) { <line2> try { <line3> final ObjectMessage objectMessage = (ObjectMessage) message; <line4> final MessageProcessor processor = <line5> this.dlmsRequestMessageProcessorMap.getMessageProcessor(objectMessage); <line6> processor.processMessage(objectMessage); <line7> } catch (final JMSException ex) { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
"public class A { <line0> @Override <line1> public void methodToFireBroadcastWithMultipleArrayParameters(String[] partitions) { <line2> logger.warn(""*********************************************************************""); <line3> } <line4> } <line5> "	 <line3>	Yes
public class A { <line0> public static void unsubscribeKBArticle(long resourcePrimKey) throws RemoteException { <line1> try { <line2> KBArticleServiceUtil.unsubscribeKBArticle(resourcePrimKey); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> public VersionLanguagesTab filterEnabledLanguages(String localeQuery) { <line1> readyElement(activeLocalesFilter).clear(); <line2> enterText(readyElement(activeLocalesFilter), localeQuery); <line3> return new VersionLanguagesTab(getDriver()); <line4> } <line5> } <line6> 	 <line2>	No
"public class A { <line0> public void verify(String signatureBaseString, String signature) <line1> throws InvalidSignatureException { <line2> try { <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> byte[] signatureBytes = Base64.decodeBase64(signature.getBytes(""UTF-8"")); <line6> Mac mac = Mac.getInstance(MAC_NAME); <line7> mac.init(key); <line8> byte[] text = signatureBaseString.getBytes(""UTF-8""); <line9> byte[] calculatedBytes = mac.doFinal(text); <line10> if (!safeArrayEquals(calculatedBytes, signatureBytes)) { <line11> throw new InvalidSignatureException(""Invalid signature for signature method "" + getName()); <line12> } <line13> } catch (NoSuchAlgorithmException e) { <line14> throw new IllegalStateException(e); <line15> } catch (InvalidKeyException e) { <line16> throw new IllegalStateException(e); <line17> } catch (UnsupportedEncodingException e) { <line18> throw new RuntimeException(e); <line19> } <line20> } <line21> } <line22> "	 <line21>	No
"public class A { <line0> @Test <line1> public void testTransformMetacardNoProducerInputTransformerRegistered() throws Exception { <line2> MimeTypeToTransformerMapper matchingService = mock(MimeTypeToTransformerMapper.class); <line3> catalogComponent.setMimeTypeToTransformerMapper(matchingService); <line4> List list = new ArrayList<InputTransformer>(); <line5> when(matchingService.findMatches(eq(InputTransformer.class), isA(MimeType.class))) <line6> .thenReturn(list); <line7> InputStream input = IOUtils.toInputStream(xmlInput); <line8> InputTransformer transformer = getTransformer(""text/xml"", ""identity""); <line9> assertNotNull(""InputTransformer for text/xml;id=identity not found"", transformer); <line10> try { <line11> transformer.transform(input); <line12> fail(""Should have thrown a CatalogTransformerException""); <line13> } catch (CatalogTransformerException e) { <line14> assertEquals( <line15> ""Did not find an InputTransformer for MIME Type [text/xml] and id [xml]"", e.getMessage()); <line16> } <line17> } <line18> } <line19> "	 <line2>	Yes
public class A { <line0> public static List<Job.Status> getBundleStatuses(List<BundleJob> bundles) { <line1> List<Job.Status> statuses = new ArrayList<>(); <line2> for (BundleJob bundle : bundles) { <line3> statuses.add(bundle.getStatus()); <line4> } <line5> return statuses; <line6> } <line7> } <line8> 	 <line4>	No
public class A { <line0> protected void handleExit() { <line1> android.os.Process.killProcess(android.os.Process.myPid()); <line2> System.exit(1); <line3> } <line4> } <line5> 	 <line1>	Yes
public class A { <line0> private void stopSystem() { <line1> EnumWriteChannel contactorControlChannel = this.channel(ChannelId.BMS_CONTACTOR_CONTROL); <line2> Optional<Integer> contactorControlOpt = contactorControlChannel.value().asOptional(); <line3> if (contactorControlOpt.isPresent() <line4> && contactorControlOpt.get() == ContactorControl.CUT_OFF.getValue()) { <line5> return; <line6> } <line7> try { <line8> contactorControlChannel.setNextWriteValue(SYSTEM_OFF); <line9> this.isStopping = true; <line10> } catch (OpenemsNamedException e) { <line11> } <line12> } <line13> } <line14> 	 <line2>	No
public class A { <line0> public void setTorsoSpeed(Double topStom, Double midStom, Double lowStom) { <line1> if (torso != null) { <line2> torso.setSpeed(topStom, midStom, lowStom); <line3> } else { <line4> } <line5> } <line6> } <line7> 	 <line6>	No
public class A { <line0> public void setMaxWait(long maxWaitMillis) { <line1> if (maxWaitMillis == this.maxWait) { <line2> return; <line3> } <line4> if (maxWaitMillis > 0 && useUnfairLock == null && !this.inited) { <line5> final ReentrantLock lock = this.lock; <line6> lock.lock(); <line7> try { <line8> if ((!this.inited) && (!lock.isFair())) { <line9> this.lock = new ReentrantLock(true); <line10> this.notEmpty = this.lock.newCondition(); <line11> this.empty = this.lock.newCondition(); <line12> } <line13> } finally { <line14> lock.unlock(); <line15> } <line16> } <line17> if (inited) { <line18> } <line19> this.maxWait = maxWaitMillis; <line20> } <line21> } <line22> 	 <line10>	No
public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> Log_result result = new Log_result(); <line4> if (e instanceof org.apache.thrift.transport.TTransportException) { <line5> fb.close(); <line6> return; <line7> } else if (e instanceof org.apache.thrift.TApplicationException) { <line8> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line9> msg = (org.apache.thrift.TApplicationException) e; <line10> } else { <line11> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line12> msg = <line13> new org.apache.thrift.TApplicationException( <line14> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line15> } <line16> try { <line17> fcall.sendResponse(fb, msg, msgType, seqid); <line18> } catch (java.lang.Exception ex) { <line19> fb.close(); <line20> } <line21> } <line22> } <line23> 	 <line15>	No
public class A { <line0> public void start(Client c) { <line1> Long roomId = c.getRoomId(); <line2> if (!c.hasRight(Room.Right.PRESENTER) || isStarted(roomId)) { <line3> return; <line4> } <line5> IMap<Long, Map<Long, Boolean>> polls = map(); <line6> polls.lock(roomId); <line7> polls.putIfAbsent(roomId, new ConcurrentHashMap<>()); <line8> polls.unlock(roomId); <line9> WebSocketHelper.sendRoom(new TextRoomMessage(roomId, c, Type.QUICK_POLL_UPDATED, c.getUid())); <line10> } <line11> } <line12> 	 <line2>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> protected List<String> assertReceivedObjectMessageWithListBody(Message message) <line2> throws JMSException { <line3> assertNotNull(""Should have received a message!"", message); <line4> assertEquals(""foo header"", ""abc"", message.getStringProperty(""foo"")); <line5> assertTrue(""Should be an object message but was: "" + message, message instanceof ObjectMessage); <line6> ObjectMessage objectMessage = (ObjectMessage) message; <line7> List<String> body = (List<String>) objectMessage.getObject(); <line8> assertEquals(""Size of list should be 1"", 1, body.size()); <line9> assertEquals(""element 0 of list"", ""First"", body.get(0)); <line10> return body; <line11> } <line12> } <line13> "	 <line9>	No
"public class A { <line0> @Path(""/group/{groupPath}/meta"") <line1> @GET <line2> public String getGroupMeta(@PathParam(""groupPath"") String group) <line3> throws EngineException, JsonProcessingException { <line4> if (!group.startsWith(""/"")) group = ""/"" + group; <line5> GroupContents contents = groupsMan.getContents(group, GroupContents.METADATA); <line6> return mapper.writeValueAsString(contents.getGroup()); <line7> } <line8> } <line9> "	 <line1>	No
public class A { <line0> @BeforeClass <line1> public void logMyRunning() { <line2> } <line3> } <line4> 	 <line3>	No
public class A { <line0> @Override <line1> public void onEvent(Object event) throws Exception { <line2> try { <line3> if (event instanceof MavenExecutionRequest) { <line4> multiModuleProjectDirectory = <line5> ((MavenExecutionRequest) event).getMultiModuleProjectDirectory().toPath(); <line6> } else if (event instanceof MavenExecutionResult) { <line7> cache.cache.removeIf(this::shouldEvict); <line8> } <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> 	 <line10>	Yes
"public class A { <line0> public List<String> updateStatement(ScriptExecutionRequest scriptExecutionRequest) { <line1> List<String> queries = new ArrayList<>(); <line2> queries.add( <line3> ""UPDATE "" <line4> + getMetadataRepository().getTableNameByLabel(""ScriptExecutionRequests"") <line5> + "" SET "" <line6> + ""ID="" <line7> + SQLTools.getStringForSQL(scriptExecutionRequest.getExecutionRequestKey().getId()) <line8> + "", "" <line9> + ""EXIT="" <line10> + SQLTools.getStringForSQL(scriptExecutionRequest.isExit()) <line11> + "","" <line12> + ""ENVIRONMENT="" <line13> + SQLTools.getStringForSQL(scriptExecutionRequest.getEnvironment()) <line14> + "","" <line15> + ""ST_NM="" <line16> + SQLTools.getStringForSQL( <line17> scriptExecutionRequest.getScriptExecutionRequestStatus().value()) <line18> + "" WHERE "" <line19> + ""SCRPT_REQUEST_ID = "" <line20> + SQLTools.getStringForSQL(scriptExecutionRequest.getMetadataKey().getId()) <line21> + "";""); <line22> if (scriptExecutionRequest instanceof ScriptFileExecutionRequest) { <line23> queries.add( <line24> ""UPDATE "" <line25> + getMetadataRepository().getTableNameByLabel(""ScriptFileExecutionRequests"") <line26> + "" SET "" <line27> + ""ID="" <line28> + SQLTools.getStringForSQL(scriptExecutionRequest.getExecutionRequestKey().getId()) <line29> + "", "" <line30> + ""SCRPT_FILENAME="" <line31> + SQLTools.getStringForSQL( <line32> ((ScriptFileExecutionRequest) scriptExecutionRequest).getFileName()) <line33> + "" WHERE "" <line34> + ""SCRPT_REQUEST_ID = "" <line35> + SQLTools.getStringForSQL(scriptExecutionRequest.getMetadataKey().getId()) <line36> + "";""); <line37> return queries; <line38> } else if (scriptExecutionRequest instanceof ScriptNameExecutionRequest) { <line39> queries.add( <line40> ""UPDATE "" <line41> + getMetadataRepository().getTableNameByLabel(""ScriptNameExecutionRequests"") <line42> + "" SET "" <line43> + ""ID="" <line44> + SQLTools.getStringForSQL(scriptExecutionRequest.getExecutionRequestKey().getId()) <line45> + "", "" <line46> + ""SCRPT_NAME="" <line47> + SQLTools.getStringForSQL( <line48> ((ScriptNameExecutionRequest) scriptExecutionRequest).getScriptName()) <line49> + "","" <line50> + ""SCRPT_VRS="" <line51> + SQLTools.getStringForSQL( <line52> ((ScriptNameExecutionRequest) scriptExecutionRequest) <line53> .getScriptVersion() <line54> .orElse(null)) <line55> + "" WHERE "" <line56> + ""SCRPT_REQUEST_ID = "" <line57> + SQLTools.getStringForSQL(scriptExecutionRequest.getMetadataKey().getId()) <line58> + "";""); <line59> return queries; <line60> } else { <line61> } <line62> return queries; <line63> } <line64> } <line65> "	 <line61>	Yes
public class A { <line0> public boolean getExecutionResult() { <line1> waitForElement(By.className(AppHtmlElements.APP_CONFIG_DIV_CLASS_STATUS_MSG), 5); <line2> if (!verifyFoundElement(By.className(AppHtmlElements.APP_CONFIG_LICLASS_STATUS_MSG_ERROR)) <line3> && verifyFoundElement(By.className(AppHtmlElements.APP_CONFIG_LICLASS_STATUS_MSG_OK))) { <line4> return true; <line5> } else { <line6> return false; <line7> } <line8> } <line9> } <line10> 	 <line4>	Yes
public class A { <line0> private void internalInitialize(Properties props) { <line1> if (this.initialized) { <line2> return; <line3> } <line4> this.initialized = true; <line5> if (logger.isDebugEnabled()) { <line6> } <line7> auditor.init(props); <line8> String schedule = null; <line9> if (props != null) { <line10> schedule = props.getProperty(SCHEDULE); <line11> } <line12> scheduler.init(schedule); <line13> } <line14> } <line15> 	 <line6>	Yes
public class A { <line0> @Test <line1> public void testGetProcessImageViaUIClientTest() throws Exception { <line2> String result = uiServicesClient.getProcessImage(CONTAINER_ID, HIRING_PROCESS_ID); <line3> assertThat(result).isNotNull().isNotEmpty(); <line4> } <line5> } <line6> 	 <line3>	Yes
"public class A { <line0> private void handleQueuedStatusUpdates() { <line1> try { <line2> Iterator<TaskStatus> diskQueueIterator = queuedUpdates.diskQueueIterator(); <line3> while (diskQueueIterator.hasNext()) { <line4> while (!statusUpdateHandler.hasRoomForMoreUpdates()) { <line5> LOG.debug(""Status update queue is full, waiting before processing additional updates""); <line6> Thread.sleep(2000); <line7> } <line8> TaskStatus status = diskQueueIterator.next(); <line9> handleStatusUpdateAsync(status); <line10> diskQueueIterator.remove(); <line11> } <line12> TaskStatus nextInMemory = queuedUpdates.nextInMemory(); <line13> while (nextInMemory != null) { <line14> while (!statusUpdateHandler.hasRoomForMoreUpdates()) { <line15> Thread.sleep(2000); <line16> } <line17> handleStatusUpdateAsync(nextInMemory); <line18> nextInMemory = queuedUpdates.nextInMemory(); <line19> } <line20> } catch (Throwable t) { <line21> throw new RuntimeException(t); <line22> } <line23> } <line24> } <line25> "	 <line24>	No
public class A { <line0> public void unsubscribe() { <line1> if (subscription != null) { <line2> try { <line3> subscription.unsubscribe(new Unsubscribe()); <line4> } catch (UnableToDestroySubscriptionFault | ResourceUnknownFault e) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line3>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> consumeFromTopic(formatPluginName, avroFormatPlugin, ingestRunData, queue); <line4> } catch (final Exception e) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> @Disabled <line1> @Test <line2> public void testFind() throws Exception { <line3> final com.braintreegateway.Subscription result = requestBody(""direct://FIND"", null); <line4> assertNotNull(result, ""find result""); <line5> } <line6> } <line7> "	 <line0>	No
public class A { <line0> @Override <line1> public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext) <line2> throws IOException { <line3> CALL_COUNT++; <line4> } <line5> } <line6> 	 <line4>	Yes
public class A { <line0> private static void createVertexIndixes() { <line1> JanusGraphManagement graphMgt = graph.openManagement(); <line2> JanusGraphIndex index = null; <line3> for (GraphPropertiesDictionary prop : GraphPropertiesDictionary.values()) { <line4> PropertyKey propKey = null; <line5> if (!graphMgt.containsPropertyKey(prop.getProperty())) { <line6> Class<?> clazz = prop.getClazz(); <line7> if (!clazz.isAssignableFrom(ArrayList.class) && !clazz.isAssignableFrom(HashMap.class)) { <line8> propKey = graphMgt.makePropertyKey(prop.getProperty()).dataType(prop.getClazz()).make(); <line9> } <line10> } else { <line11> propKey = graphMgt.getPropertyKey(prop.getProperty()); <line12> } <line13> if (prop.isIndexed()) { <line14> if (!graphMgt.containsGraphIndex(prop.getProperty())) { <line15> if (prop.isUnique()) { <line16> index = <line17> graphMgt <line18> .buildIndex(prop.getProperty(), Vertex.class) <line19> .addKey(propKey) <line20> .unique() <line21> .buildCompositeIndex(); <line22> graphMgt.setConsistency(propKey, ConsistencyModifier.LOCK); <line23> graphMgt.setConsistency(index, ConsistencyModifier.LOCK); <line24> } else { <line25> graphMgt <line26> .buildIndex(prop.getProperty(), Vertex.class) <line27> .addKey(propKey) <line28> .buildCompositeIndex(); <line29> } <line30> } <line31> } <line32> } <line33> graphMgt.commit(); <line34> } <line35> } <line36> 	 <line6>	No
public class A { <line0> @Override <line1> public void run() { <line2> while (this.running) { <line3> try { <line4> processService(); <line5> } catch (Exception exception) { <line6> hasError = true; <line7> } <line8> } <line9> } <line10> } <line11> 	 <line2>	No
public class A { <line0> public Configuration configure(String resource) throws EPException { <line1> if (log.isDebugEnabled()) { <line2> } <line3> InputStream stream = getConfigurationInputStream(resource); <line4> ConfigurationParser.doConfigure(this, stream, resource); <line5> return this; <line6> } <line7> } <line8> 	 <line5>	No
"public class A { <line0> @Override <line1> public Representation represent(final Variant variant) throws ResourceException { <line2> try { <line3> if (targetString == null || targetString.length() == 0) { <line4> return new StringRepresentation(""""); <line5> } <line6> String acctId = SecurityContextHolder.getContext().getAuthentication().getName(); <line7> List<DisplayEntityModelView> results = <line8> entitiesDAO.execute( <line9> new GetEntitiesByPrefixRequest(acctId.trim().toLowerCase(), targetString)); <line10> JSONObject json = new JSONObject(); <line11> JSONArray jsonEntities = new JSONArray(); <line12> for (DisplayEntityModelView femv : results) { <line13> if (!femv.isAccountLocked()) { <line14> jsonEntities.add(convertDisplayEntityModelViewToJSON(femv)); <line15> } <line16> } <line17> json.put(ENTITIES_KEY, jsonEntities); <line18> Representation rep = new StringRepresentation(json.toString(), MediaType.APPLICATION_JSON); <line19> rep.setExpirationDate(new Date(0L)); <line20> return rep; <line21> } catch (Exception ex) { <line22> throw new ResourceException( <line23> Status.CLIENT_ERROR_BAD_REQUEST, ""Error occurred retrieving entity."", ex); <line24> } <line25> } <line26> } <line27> "	 <line26>	No
public class A { <line0> @Override <line1> public boolean evaluate(QueryEvaluationContext ctx) { <line2> KeyValueCursor<Path, JsonNode> cursor = ctx.getNodes(relativePath); <line3> boolean ret = false; <line4> while (cursor.hasNext()) { <line5> cursor.next(); <line6> JsonNode valueNode = cursor.getCurrentValue(); <line7> Object docValue; <line8> if (valueNode != null) { <line9> docValue = fieldMd.getType().fromJson(valueNode); <line10> } else { <line11> docValue = null; <line12> } <line13> if (docValue != null) { <line14> ret = regex.matcher(docValue.toString()).matches(); <line15> } <line16> if (ret) { <line17> break; <line18> } <line19> } <line20> ctx.setResult(ret); <line21> return ret; <line22> } <line23> } <line24> 	 <line9>	No
public class A { <line0> protected void mkdirs(final File file) { <line1> assert file != null; <line2> File dir = file.getParentFile(); <line3> if (!dir.exists()) { <line4> if (!dir.mkdirs()) { <line5> } else { <line6> } <line7> } else if (dir.isFile()) { <line8> } <line9> } <line10> } <line11> 	 <line2>	No
public class A { <line0> public void run() { <line1> byte[] buf = new byte[1024]; <line2> try { <line3> InputStream in = src.getInputStream(); <line4> OutputStream out = destination.getOutputStream(); <line5> while (true) { <line6> int len = in.read(buf); <line7> if (len == -1) { <line8> break; <line9> } <line10> pause.get().await(); <line11> out.write(buf, 0, len); <line12> } <line13> } catch (Exception e) { <line14> try { <line15> close(); <line16> } catch (Exception ignore) { <line17> } <line18> } <line19> } <line20> } <line21> 	 <line18>	No
public class A { <line0> private CounterMetric _createAndRegisterCounterMXBean(Metric m, Counter c) { <line1> CounterMetric b = new CounterMetric(m, c); <line2> _registerMBean(b); <line3> return b; <line4> } <line5> } <line6> 	 <line2>	No
"public class A { <line0> @RequestMapping( <line1> value = ""/{project}/{tableNames}/cardinality"", <line2> method = {RequestMethod.PUT}, <line3> produces = {""application/json""}) <line4> @ResponseBody <line5> public CardinalityRequest generateCardinality( <line6> @PathVariable String tableNames, <line7> @RequestBody CardinalityRequest request, <line8> @PathVariable String project) <line9> throws Exception { <line10> String submitter = SecurityContextHolder.getContext().getAuthentication().getName(); <line11> String[] tables = StringUtil.splitByComma(tableNames); <line12> try { <line13> for (String table : tables) { <line14> tableService.calculateCardinality( <line15> table.trim().toUpperCase(Locale.ROOT), submitter, project); <line16> } <line17> } catch (IOException e) { <line18> throw new InternalErrorException(e.getLocalizedMessage(), e); <line19> } <line20> return request; <line21> } <line22> } <line23> "	 <line18>	Yes
public class A { <line0> @VisibleForTesting <line1> public static void registerGauges(final UfsManager ufsManager, final InodeTree inodeTree) { <line2> MetricsSystem.registerGaugeIfAbsent( <line3> MetricKey.MASTER_FILES_PINNED.getName(), inodeTree::getPinnedSize); <line4> MetricsSystem.registerGaugeIfAbsent( <line5> MetricKey.MASTER_FILES_TO_PERSIST.getName(), () -> inodeTree.getToBePersistedIds().size()); <line6> MetricsSystem.registerGaugeIfAbsent( <line7> MetricKey.MASTER_TOTAL_PATHS.getName(), inodeTree::getInodeCount); <line8> MetricsSystem.registerGaugeIfAbsent( <line9> MetricKey.MASTER_FILE_SIZE.getName(), <line10> () -> <line11> StreamSupport.stream( <line12> inodeTree <line13> .getFileSizeHistogram() <line14> .logarithmicBucketValues(1024, 1024) <line15> .spliterator(), <line16> false) <line17> .map( <line18> x -> <line19> new Pair<>( <line20> new Pair<>( <line21> x.getDoubleValueIteratedFrom(), x.getDoubleValueIteratedTo()), <line22> x.getCountAddedInThisIterationStep())) <line23> .collect(Collectors.toMap(Pair::getFirst, Pair::getSecond))); <line24> final String ufsDataFolder = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS); <line25> MetricsSystem.registerGaugeIfAbsent( <line26> MetricKey.CLUSTER_ROOT_UFS_CAPACITY_TOTAL.getName(), <line27> () -> { <line28> try (CloseableResource<UnderFileSystem> ufsResource = <line29> ufsManager.getRoot().acquireUfsResource()) { <line30> UnderFileSystem ufs = ufsResource.get(); <line31> return ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_TOTAL); <line32> } catch (IOException e) { <line33> LOG.error(e.getMessage(), e); <line34> return Stream.empty(); <line35> } <line36> }); <line37> MetricsSystem.registerGaugeIfAbsent( <line38> MetricKey.CLUSTER_ROOT_UFS_CAPACITY_USED.getName(), <line39> () -> { <line40> try (CloseableResource<UnderFileSystem> ufsResource = <line41> ufsManager.getRoot().acquireUfsResource()) { <line42> UnderFileSystem ufs = ufsResource.get(); <line43> return ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_USED); <line44> } catch (IOException e) { <line45> LOG.error(e.getMessage(), e); <line46> return Stream.empty(); <line47> } <line48> }); <line49> MetricsSystem.registerGaugeIfAbsent( <line50> MetricKey.CLUSTER_ROOT_UFS_CAPACITY_FREE.getName(), <line51> () -> { <line52> long ret = 0L; <line53> try (CloseableResource<UnderFileSystem> ufsResource = <line54> ufsManager.getRoot().acquireUfsResource()) { <line55> UnderFileSystem ufs = ufsResource.get(); <line56> ret = ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_FREE); <line57> } catch (IOException e) { <line58> } <line59> return ret; <line60> }); <line61> } <line62> } <line63> 	 <line39>	No
"public class A { <line0> private static void initSpark() { <line1> staticFiles.location(""/static""); <line2> } <line3> } <line4> "	 <line0>	No
public class A { <line0> @Override <line1> protected AuthorizationDecision combineDecisions( <line2> AuthorizationDecision[] decisions, boolean errorsInTarget) { <line3> if (decisions.length == 0) return AuthorizationDecision.PERMIT; <line4> var entitlement = PERMIT; <line5> var collector = new ObligationAdviceCollector(); <line6> Optional<JsonNode> resource = Optional.empty(); <line7> for (var decision : decisions) { <line8> if (decision.getDecision() == DENY) { <line9> entitlement = DENY; <line10> } <line11> collector.add(decision); <line12> if (decision.getResource().isPresent()) { <line13> if (resource.isPresent()) { <line14> entitlement = DENY; <line15> } else { <line16> resource = decision.getResource(); <line17> } <line18> } <line19> } <line20> var finalDecision = <line21> new AuthorizationDecision( <line22> entitlement, <line23> resource, <line24> collector.getObligations(entitlement), <line25> collector.getAdvices(entitlement)); <line26> return finalDecision; <line27> } <line28> } <line29> 	 <line14>	No
"public class A { <line0> @RequestMapping( <line1> value = ""/getCrisesByUserId.action"", <line2> method = {RequestMethod.GET}) <line3> @ResponseBody <line4> public Map<String, Object> getCrisesByUserId() { <line5> try { <line6> String userName = getAuthenticatedUserName(); <line7> Integer taggerUserId = taggerService.isUserExistsByUsername(userName); <line8> if (taggerUserId != null) { <line9> return getUIWrapper(taggerService.getCrisesByUserId(taggerUserId), true); <line10> } else { <line11> return getUIWrapper(false, ""Error while getting all crisis for user in Tagger""); <line12> } <line13> } catch (Exception e) { <line14> return getUIWrapper(false, e.getMessage()); <line15> } <line16> } <line17> } <line18> "	 <line3>	No
"public class A { <line0> public void remove(String typeName) { <line1> logEnter(""ClientTypeDescRepository.remove"", ""typeName"", typeName); <line2> synchronized (_lock) { <line3> _typeMap.remove(typeName); <line4> if (_logger.isDebugEnabled()) <line5> } <line6> logExit(""ClientTypeDescRepository.remove"", ""typeName"", typeName); <line7> } <line8> } <line9> "	 <line8>	No
"public class A { <line0> public ItemsVO deleteItemsEntry(ItemsVO vo) { <line1> long timerStart = System.currentTimeMillis(); <line2> conf.getDBDAO().doDeleteItemsEntry(vo); <line3> logTime(""deleteItemsEntry"", timerStart, System.currentTimeMillis()); <line4> return vo; <line5> } <line6> } <line7> "	 <line6>	No
public class A { <line0> @Override <line1> public void submit(Entity entity, Properties props) throws DAGEngineException { <line2> try { <line3> OozieOrchestrationWorkflowBuilder builder = <line4> OozieOrchestrationWorkflowBuilder.get( <line5> entity, cluster, Tag.DEFAULT, OozieOrchestrationWorkflowBuilder.Scheduler.NATIVE); <line6> prepareEntityBuildPath(entity); <line7> Path buildPath = EntityUtil.getNewStagingPath(cluster, entity); <line8> org.apache.falcon.entity.v0.process.Process process = (Process) entity; <line9> builder.setNominalTime( <line10> new DateTime(process.getClusters().getClusters().get(0).getValidity().getStart())); <line11> Properties properties = builder.build(cluster, buildPath, props); <line12> boolean skipDryRun = false; <line13> if (props != null <line14> && !props.isEmpty() <line15> && props.containsKey(FalconWorkflowEngine.FALCON_SKIP_DRYRUN)) { <line16> Boolean skipDryRunprop = <line17> Boolean.parseBoolean(props.getProperty(FalconWorkflowEngine.FALCON_SKIP_DRYRUN)); <line18> if (skipDryRunprop != null) { <line19> skipDryRun = skipDryRunprop; <line20> } <line21> } <line22> if (!skipDryRun) { <line23> dryRunInternal(properties, buildPath, entity); <line24> } <line25> } catch (OozieClientException e) { <line26> throw new DAGEngineException(e); <line27> } catch (FalconException e1) { <line28> throw new DAGEngineException(e1); <line29> } <line30> } <line31> } <line32> 	 <line19>	No
"public class A { <line0> @Override <line1> public void prepareAnalyzer(Engine engine) throws InitializationException { <line2> super.prepareAnalyzer(engine); <line3> try { <line4> this.open(engine.getDatabase()); <line5> } catch (IOException ex) { <line6> throw new InitializationException(""An exception occurred initializing the Lucene Index"", ex); <line7> } catch (DatabaseException ex) { <line8> throw new InitializationException(""An exception occurred accessing the database"", ex); <line9> } <line10> final String[] tmp = engine.getSettings().getArray(Settings.KEYS.ECOSYSTEM_SKIP_CPEANALYZER); <line11> if (tmp == null) { <line12> skipEcosystems = new ArrayList<>(); <line13> } else { <line14> skipEcosystems = Arrays.asList(tmp); <line15> } <line16> ecosystemTools = new Ecosystem(engine.getSettings()); <line17> suppression = new CpeSuppressionAnalyzer(); <line18> suppression.initialize(engine.getSettings()); <line19> suppression.prepareAnalyzer(engine); <line20> } <line21> } <line22> "	 <line14>	Yes
public class A { <line0> private void removeRack() { <line1> Rack rack = this.rackClient.getByName(RACK_NAME).get(0); <line2> String response = this.rackClient.remove(rack.getResourceId()); <line3> } <line4> } <line5> 	 <line3>	Yes
public class A { <line0> public Identity getOrCreateIdentity( <line1> String providerId, String remoteId, boolean forceLoadOrReloadProfile) { <line2> Identity returnIdentity = null; <line3> IdentityProvider<?> identityProvider = this.getIdentityProvider(providerId); <line4> Identity identityFoundByRemoteProvider = identityProvider.getIdentityByRemoteId(remoteId); <line5> Identity result = this.getIdentityStorage().findIdentity(providerId, remoteId); <line6> if (result == null) { <line7> if (identityFoundByRemoteProvider != null) { <line8> saveIdentity(identityFoundByRemoteProvider); <line9> this.getIdentityStorage().saveProfile(identityFoundByRemoteProvider.getProfile()); <line10> result = identityFoundByRemoteProvider; <line11> if (OrganizationIdentityProvider.NAME.equals(providerId)) { <line12> profileLifeCycle.createProfile(result.getProfile()); <line13> } <line14> } else { <line15> return result; <line16> } <line17> } else { <line18> if (identityFoundByRemoteProvider == null && !result.isDeleted()) { <line19> } <line20> Profile profile = this.getIdentityStorage().loadProfile(result.getProfile()); <line21> profile.setIdentity(result); <line22> result.setProfile(profile); <line23> } <line24> returnIdentity = result; <line25> return returnIdentity; <line26> } <line27> } <line28> 	 <line9>	No
public class A { <line0> boolean containsUuidIdentifiersOnly() { <line1> if (hasQueryPredicates()) { <line2> return false; <line3> } <line4> if ((identifiers == null) || identifiers.isEmpty()) { <line5> return false; <line6> } <line7> for (Identifier identifier : identifiers) { <line8> if (identifier == null) { <line9> return false; <line10> } <line11> if (!identifier.isUUID()) { <line12> return false; <line13> } <line14> } <line15> return true; <line16> } <line17> } <line18> 	 <line17>	No
public class A { <line0> public static boolean tryDelete(File file) { <line1> if (isSpecialFile(file)) { <line2> return false; <line3> } <line4> boolean deleted = FileUtils.deleteQuietly(file); <line5> return deleted; <line6> } <line7> } <line8> 	 <line0>	No
public class A { <line0> @Override <line1> public void terminate( <line2> BatchRunContext batchRunContext, <line3> List<String> all, <line4> long errors, <line5> long unhandled_errors, <line6> long total, <line7> long processed) { <line8> long success = total - errors - unhandled_errors; <line9> if (errors > 0) { <line10> } <line11> if (unhandled_errors > 0) { <line12> } <line13> } <line14> } <line15> 	 <line3>	No
"public class A { <line0> @Override <line1> public List<Broker> getAllBrokers() { <line2> Command request = <line3> new Command( <line4> new JoyQueueHeader(Direction.REQUEST, NsrCommandType.GET_ALL_BROKERS), <line5> new GetAllBrokers()); <line6> Command response = send(request); <line7> if (!response.isSuccess()) { <line8> throw new RuntimeException( <line9> String.format(""getAllBrokers error request {},response {}"", request, response)); <line10> } <line11> return ((GetAllBrokersAck) response.getPayload()).getBrokers(); <line12> } <line13> } <line14> "	 <line8>	Yes
"public class A { <line0> private void process(final SynchronizedExchange synchronizedExchange) { <line1> try { <line2> Exchange exchange = synchronizedExchange.getExchange(); <line3> final boolean ignore = <line4> exchange.hasProperties() <line5> && exchange.getProperties().containsKey(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE); <line6> if (ignore) { <line7> return; <line8> } <line9> final Exchange result = prepareExchange(exchange); <line10> result <line11> .adapt(ExtendedExchange.class) <line12> .addOnCompletion( <line13> new Synchronization() { <line14> @Override <line15> public void onComplete(Exchange exchange) { <line16> synchronizedExchange.consumed(result); <line17> } <line18>  <line19> @Override <line20> public void onFailure(Exchange exchange) { <line21> synchronizedExchange.consumed(result); <line22> } <line23> }); <line24> processor.process(result, NOOP_ASYNC_CALLBACK); <line25> } catch (Exception e) { <line26> Exchange exchange = synchronizedExchange.getExchange(); <line27> if (exchange != null) { <line28> getExceptionHandler().handleException(""Error processing exchange"", exchange, e); <line29> } else { <line30> getExceptionHandler().handleException(e); <line31> } <line32> } <line33> } <line34> } <line35> "	 <line7>	Yes
public class A { <line0> private void runRestore() { <line1> try { <line2> backupManager.restoreWorkspaceBackup(WORKSPACE_ID, CONTAINER_ID, NODE_HOST); <line3> } catch (ServerException | EnvironmentException e) { <line4> } <line5> } <line6> } <line7> 	 <line4>	Yes
public class A { <line0> public static com.liferay.commerce.pricing.model.CommercePriceModifierRelSoap <line1> fetchCommercePriceModifierRel(long commercePriceModifierId, String className, long classPK) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.pricing.model.CommercePriceModifierRel returnValue = <line5> CommercePriceModifierRelServiceUtil.fetchCommercePriceModifierRel( <line6> commercePriceModifierId, className, classPK); <line7> return com.liferay.commerce.pricing.model.CommercePriceModifierRelSoap.toSoapModel( <line8> returnValue); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	 <line10>	Yes
"public class A { <line0> @Override <line1> public void onNodeDeletion() { <line2> super.onNodeDeletion(); <line3> final String thisName = getName(); <line4> for (SchemaView view : getProperty(SchemaProperty.schemaViews)) { <line5> final String sortOrder = view.getProperty(SchemaView.sortOrder); <line6> if (sortOrder != null) { <line7> try { <line8> view.setProperty( <line9> SchemaView.sortOrder, <line10> StringUtils.join( <line11> Arrays.stream(sortOrder.split("","")) <line12> .filter(propertyName -> !thisName.equals(propertyName)) <line13> .toArray(), <line14> "","")); <line15> } catch (FrameworkException ex) { <line16> } <line17> } <line18> } <line19> final AbstractSchemaNode parent = getProperty(SchemaProperty.schemaNode); <line20> if (parent != null) { <line21> final ConfigurationProvider conf = StructrApp.getConfiguration(); <line22> final Class type = conf.getNodeEntityClass(parent.getName()); <line23> if (type != null) { <line24> conf.unregisterProperty(type, conf.getPropertyKeyForJSONName(type, getPropertyName())); <line25> } <line26> } <line27> } <line28> } <line29> "	 <line16>	Yes
public class A { <line0> @Override <line1> public DetailedGarbageCollectorMetric get() { <line2> DetailedGarbageCollectorMetric detailedGarbageCollectorMetric = null; <line3> Map<String, GarbageCollectorMXBean> garbageCollectorMap = createGarbageCollectorMap(); <line4> for (GarbageCollectorType garbageCollectorType : GarbageCollectorType.values()) { <line5> if (garbageCollectorMap.containsKey(garbageCollectorType.newGenName())) { <line6> GarbageCollectorMXBean garbageCollectorMXBean = <line7> garbageCollectorMap.get(garbageCollectorType.newGenName()); <line8> detailedGarbageCollectorMetric = <line9> new DefaultDetailedGarbageCollectorMetric(garbageCollectorType, garbageCollectorMXBean); <line10> break; <line11> } <line12> } <line13> if (detailedGarbageCollectorMetric == null) { <line14> detailedGarbageCollectorMetric = new UnknownDetailedGarbageCollectorMetric(); <line15> } <line16> return detailedGarbageCollectorMetric; <line17> } <line18> } <line19> 	 <line0>	No
public class A { <line0> private void stop() throws Exception { <line1> jettyServer.stop(); <line2> } <line3> } <line4> 	 <line1>	No
public class A { <line0> @GetMapping(COLLECTION_CODE_PATH) <line1> @ResponseBody <line2> public List<String> suggestCollectionCodes( <line3> @RequestParam(QUERY_PARAM) String prefix, @RequestParam(PARAM_LIMIT) int limit) { <line4> return searchService.suggestCollectionCodes(prefix, limit); <line5> } <line6> } <line7> 	 <line0>	No
public class A { <line0> private StatementWrapper getInternalBoundStatementWrapper() { <line1> if (LOGGER.isTraceEnabled()) { <line2> } <line3> final PreparedStatement ps = getInternalPreparedStatement(); <line4> BoundValuesWrapper wrapper = <line5> updateStatic == true <line6> ? meta.extractPartitionKeysAndStaticColumnsFromEntity(instance, options) <line7> : meta.extractAllValuesFromEntity(instance, options); <line8> StatementWrapper statementWrapper = wrapper.bindForUpdate(ps); <line9> statementWrapper.applyOptions(options); <line10> return statementWrapper; <line11> } <line12> } <line13> 	 <line0>	No
public class A { <line0> @Override <line1> public void schedule(JobExecutionContext jobExecutionContext) throws Exception { <line2> List<BBSForumInfo> forumInfoList = null; <line3> try { <line4> forumInfoList = forumInfoServiceAdv.listAll(); <line5> if (ListTools.isNotEmpty(forumInfoList)) { <line6> forumSubjectStatisticService.statisticSubjectTotalAndReplayTotalForForum(forumInfoList); <line7> } <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> 	 <line1>	No
"public class A { <line0> private String upgradeAutoFillRuleToTableNames(String autoFillValueStr) throws IOException { <line1> List<AutoFillItem> autoFillItems = JsonUtil.toList(autoFillValueStr, AutoFillItem.class); <line2> List<AutoFillItem> exAutoFillItems = new ArrayList<>(); <line3> String reg = ""\""ciTypeId\"":\\d+[},]""; <line4> Pattern r = Pattern.compile(reg); <line5> for (AutoFillItem autoFillItem : autoFillItems) { <line6> AutoFillItem exAutoFillItem = new AutoFillItem(); <line7> exAutoFillItem.setType(autoFillItem.getType()); <line8> if (!autoFillItem.getType().equals(""rule"")) { <line9> exAutoFillItem.setValue(autoFillItem.getValue()); <line10> } else { <line11> Matcher m = r.matcher(autoFillItem.getValue()); <line12> if (m.find()) { <line13> List<AutoFillIntegrationQueryDto> intDtos = <line14> JsonUtil.toList(autoFillItem.getValue(), AutoFillIntegrationQueryDto.class); <line15> List<AutoFillIntegrationQueryExDto> exIntDtos = new ArrayList<>(); <line16> for (AutoFillIntegrationQueryDto intDto : intDtos) { <line17> AutoFillIntegrationQueryExDto exIntDto = convert(intDto); <line18> exIntDtos.add(exIntDto); <line19> } <line20> String itemJsonValue = JsonUtil.toJson(exIntDtos); <line21> exAutoFillItem.setValue(itemJsonValue); <line22> } else { <line23> exAutoFillItem.setValue(autoFillItem.getValue()); <line24> } <line25> } <line26> exAutoFillItems.add(exAutoFillItem); <line27> } <line28> return JsonUtil.toJson(exAutoFillItems); <line29> } <line30> } <line31> "	 <line6>	Yes
public class A { <line0> @Override <line1> public void errorInFilter( <line2> final AnalysisJob job, <line3> final FilterJob filterJob, <line4> final InputRow row, <line5> final Throwable throwable) { <line6> handleError(job, throwable); <line7> } <line8> } <line9> 	 <line6>	Yes
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> public static SimpleFeatureType configureType(final SimpleFeatureType type) { <line2> final String configFileName = System.getProperty(SIMPLE_FEATURE_CONFIG_FILE_PROP); <line3> if (configFileName != null) { <line4> final File configFile = new File(configFileName); <line5> if (configFile.exists() && configFile.canRead()) { <line6> try (FileInputStream input = new FileInputStream(configFile); <line7> Reader reader = new InputStreamReader(input, ""UTF-8"")) { <line8> final ObjectMapper mapper = <line9> new ObjectMapper().disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); <line10> final SimpleFeatureUserDataConfigurationSet instance = <line11> mapper.readValue(reader, SimpleFeatureUserDataConfigurationSet.class); <line12> instance.updateType(type); <line13> } catch (final IOException e) { <line14> } <line15> } <line16> } <line17> return type; <line18> } <line19> } <line20> "	 <line14>	Yes
public class A { <line0> private void transferFile( <line1> final String source, final String target, final Map<String, Object> headers) { <line2> final Map<String, String> inputParamsMap = new HashMap<>(); <line3> inputParamsMap.put( <line4> Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_PARAMETER_TARGETABSOLUTPATH, <line5> target); <line6> inputParamsMap.put( <line7> Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_PARAMETER_SOURCEURLORLOCALPATH, <line8> source); <line9> headers.put( <line10> MBHeader.OPERATIONNAME_STRING.toString(), <line11> Interfaces.OPENTOSCA_DECLARATIVE_INTERFACE_OPERATINGSYSTEM_TRANSFERFILE); <line12> for (final String key : headers.keySet()) { <line13> if (headers.get(key) != null && headers.get(key) instanceof String) { <line14> } <line15> } <line16> invokeManagementBusEngine(inputParamsMap, headers); <line17> } <line18> } <line19> 	 <line12>	Yes
"public class A { <line0> private static void tryCustomMeasureTypes( <line1> Collection<TblColRef> unmatchedDimensions, <line2> Collection<FunctionDesc> unmatchedAggregations, <line3> SQLDigest digest, <line4> CubeInstance cube, <line5> CapabilityResult result) { <line6> CubeDesc cubeDesc = cube.getDescriptor(); <line7> List<String> influencingMeasures = Lists.newArrayList(); <line8> for (MeasureDesc measure : cubeDesc.getMeasures()) { <line9> MeasureType<?> measureType = measure.getFunction().getMeasureType(); <line10> if (measureType instanceof BasicMeasureType) continue; <line11> CapabilityInfluence inf = <line12> measureType.influenceCapabilityCheck( <line13> unmatchedDimensions, unmatchedAggregations, digest, measure); <line14> if (inf != null) { <line15> result.influences.add(inf); <line16> influencingMeasures.add(measure.getName() + ""@"" + measureType.getClass()); <line17> } <line18> } <line19> if (influencingMeasures.size() != 0) <line20> } <line21> } <line22> "	 <line20>	Yes
public class A { <line0> public String delete() { <line1> try { <line2> String check = this.checkDelete(); <line3> if (null != check) { <line4> return check; <line5> } <line6> long modelId = this.getModelId().longValue(); <line7> DataObjectModel model = this.getDataObjectModelManager().getDataObjectModel(modelId); <line8> this.getDataObjectModelManager().removeDataObjectModel(model); <line9> } catch (Throwable t) { <line10> return FAILURE; <line11> } <line12> return SUCCESS; <line13> } <line14> } <line15> 	 <line10>	Yes
public class A { <line0> protected List<PerFeatureRunner> runnersFromFeatures( <line1> final URL repoUrl, final Features features, final Class<?> testClass) <line2> throws InitializationError { <line3> final List<PerFeatureRunner> runners = new ArrayList<>(); <line4> final List<Feature> featureList = features.getFeature(); <line5> for (final Feature f : featureList) { <line6> if (featureList.size() == 1 || !f.getName().equals(features.getName())) { <line7> runners.add(new PerFeatureRunner(repoUrl, f.getName(), f.getVersion(), testClass)); <line8> } else { <line9> } <line10> } <line11> return runners; <line12> } <line13> } <line14> 	 <line9>	Yes
public class A { <line0> @NonNull <line1> public static Map<Uint32, Group> wrapGroupsToMap(@Nullable final Collection<Group> groups) { <line2> final Map<Uint32, Group> groupMap; <line3> if (groups == null) { <line4> groupMap = Collections.emptyMap(); <line5> } else { <line6> groupMap = new HashMap<>(); <line7> for (Group group : groups) { <line8> groupMap.put(group.getGroupId().getValue(), group); <line9> } <line10> } <line11> return groupMap; <line12> } <line13> } <line14> 	 <line6>	Yes
"public class A { <line0> @Override <line1> public boolean releaseAndTryRemove(String pathInZooKeeper) throws Exception { <line2> checkNotNull(pathInZooKeeper, ""Path in ZooKeeper""); <line3> final String path = normalizePath(pathInZooKeeper); <line4> RetrievableStateHandle<T> stateHandle = null; <line5> try { <line6> stateHandle = get(path, false); <line7> } catch (Exception e) { <line8> } <line9> release(pathInZooKeeper); <line10> try { <line11> client.delete().forPath(path); <line12> } catch (KeeperException.NotEmptyException ignored) { <line13> return false; <line14> } <line15> if (stateHandle != null) { <line16> stateHandle.discardState(); <line17> } <line18> return true; <line19> } <line20> } <line21> "	 <line16>	No
public class A { <line0> private void copyHDFSJobInfo(String jobId) throws Exception { <line1> String srcDirQualified = srcCluster.getJobWorkingDirQualified(jobId); <line2> String dstDirQualified = dstCluster.getJobWorkingDirQualified(jobId); <line3> if (ifExecute) { <line4> dstCluster.copyInitOnJobCluster(new Path(dstDirQualified)); <line5> copyHDFSPath(srcDirQualified, srcCluster.jobConf, dstDirQualified, dstCluster.jobConf); <line6> } else { <line7> } <line8> } <line9> } <line10> 	 <line7>	Yes
"public class A { <line0> @Override <line1> public void init( <line2> String serviceName, String appId, String configPropertyPrefix, Configuration config) { <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> super.init(serviceName, appId, configPropertyPrefix, config); <line6> _serviceName = serviceName; <line7> _pluginId = getPluginId(serviceName, appId); <line8> String tmpUrl = config.get(configPropertyPrefix + "".policy.rest.url""); <line9> _sslConfigFileName = config.get(configPropertyPrefix + "".policy.rest.ssl.config.file""); <line10> _restClientConnTimeOutMs = <line11> config.getInt( <line12> configPropertyPrefix + "".policy.rest.client.connection.timeoutMs"", 120 * 1000); <line13> _restClientReadTimeOutMs = <line14> config.getInt(configPropertyPrefix + "".policy.rest.client.read.timeoutMs"", 30 * 1000); <line15> _clusterName = config.get(configPropertyPrefix + "".access.cluster.name"", """"); <line16> if (StringUtil.isEmpty(_clusterName)) { <line17> _clusterName = config.get(configPropertyPrefix + "".ambari.cluster.name"", """"); <line18> } <line19> _supportsPolicyDeltas = <line20> config.getBoolean( <line21> configPropertyPrefix + RangerCommonConstants.PLUGIN_CONFIG_SUFFIX_POLICY_DELTA, <line22> RangerCommonConstants.PLUGIN_CONFIG_SUFFIX_POLICY_DELTA_DEFAULT); <line23> _supportsTagDeltas = <line24> config.getBoolean( <line25> configPropertyPrefix + RangerCommonConstants.PLUGIN_CONFIG_SUFFIX_TAG_DELTA, <line26> RangerCommonConstants.PLUGIN_CONFIG_SUFFIX_TAG_DELTA_DEFAULT); <line27> configURLs = StringUtil.getURLs(tmpUrl); <line28> this.lastKnownActiveUrlIndex = new Random().nextInt(configURLs.size()); <line29> String url = configURLs.get(this.lastKnownActiveUrlIndex); <line30> _isSSL = isSsl(url); <line31> _client = getClient(); <line32> _client.property(ClientProperties.CONNECT_TIMEOUT, _restClientConnTimeOutMs); <line33> _client.property(ClientProperties.READ_TIMEOUT, _restClientReadTimeOutMs); <line34> if (LOG.isDebugEnabled()) { <line35> } <line36> } <line37> } <line38> "	 <line16>	No
"public class A { <line0> void importRooms(File base) throws Exception { <line1> Class<Room> eClazz = Room.class; <line2> JAXBContext jc = JAXBContext.newInstance(eClazz); <line3> Unmarshaller unmarshaller = jc.createUnmarshaller(); <line4> unmarshaller.setAdapter(new UserAdapter(userDao, userMap)); <line5> readList( <line6> unmarshaller, <line7> base, <line8> ""rooms.xml"", <line9> ROOM_LIST_NODE, <line10> ROOM_NODE, <line11> eClazz, <line12> r -> { <line13> Long roomId = r.getId(); <line14> if (r.getOwnerId() != null) { <line15> Long newOwnerId = userMap.get(r.getOwnerId()); <line16> if (newOwnerId == null) { <line17> return; <line18> } <line19> r.setOwnerId(newOwnerId); <line20> } <line21> r.setId(null); <line22> if (r.getModerators() != null) { <line23> for (Iterator<RoomModerator> i = r.getModerators().iterator(); i.hasNext(); ) { <line24> RoomModerator rm = i.next(); <line25> if (rm.getUser().getId() == null) { <line26> i.remove(); <line27> } <line28> } <line29> } <line30> r = roomDao.update(r, null); <line31> roomMap.put(roomId, r.getId()); <line32> }); <line33> } <line34> } <line35> "	 <line32>	No
public class A { <line0> public String addCommentToCase( <line1> String containerId, <line2> String caseId, <line3> String author, <line4> List<String> restrictions, <line5> String comment, <line6> String marshallingType) { <line7> verifyContainerId(containerId, caseId); <line8> author = getUser(author); <line9> String actualComment = <line10> marshallerHelper.unmarshal( <line11> containerId, <line12> comment, <line13> marshallingType, <line14> String.class, <line15> new ByCaseIdContainerLocator(caseId)); <line16> String commentId = <line17> caseService.addCaseComment( <line18> caseId, author, actualComment, restrictions.toArray(new String[restrictions.size()])); <line19> return marshallerHelper.marshal(containerId, marshallingType, commentId); <line20> } <line21> } <line22> 	 <line19>	No
public class A { <line0> @Override <line1> public void onSuccess(Void obj, HttpHeaders responseHeaders) { <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> private void persistBundleVersionContent( <line1> final BundleType bundleType, <line2> final BundleEntity bundle, <line3> final BundleVersionEntity bundleVersion, <line4> final File extensionWorkingFile, <line5> final boolean overwriteBundleVersion) <line6> throws IOException { <line7> final BundleVersionCoordinate versionCoordinate = <line8> new StandardBundleVersionCoordinate.Builder() <line9> .bucketId(bundle.getBucketId()) <line10> .groupId(bundle.getGroupId()) <line11> .artifactId(bundle.getArtifactId()) <line12> .version(bundleVersion.getVersion()) <line13> .type(getProviderBundleType(bundleType)) <line14> .build(); <line15> final BundlePersistenceContext context = <line16> new StandardBundlePersistenceContext.Builder() <line17> .coordinate(versionCoordinate) <line18> .bundleSize(bundleVersion.getContentSize()) <line19> .author(bundleVersion.getCreatedBy()) <line20> .timestamp(bundleVersion.getCreated().getTime()) <line21> .build(); <line22> try (final InputStream in = new FileInputStream(extensionWorkingFile); <line23> final InputStream bufIn = new BufferedInputStream(in)) { <line24> if (overwriteBundleVersion) { <line25> bundlePersistenceProvider.updateBundleVersion(context, bufIn); <line26> } else { <line27> bundlePersistenceProvider.createBundleVersion(context, bufIn); <line28> } <line29> } <line30> } <line31> } <line32> 	 <line28>	Yes
public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> User user = twitter.reportSpam(screenName); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.reportedSpam(user); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> @After <line1> public void teardownBrowserTest() { <line2> if (testScenario != null) { <line3> for (Browser browser : testScenario.getBrowserMap().values()) { <line4> String browserId = browser.getId(); <line5> try { <line6> WebDriver webDriver = browser.getWebDriver(); <line7> if (webDriver != null) { <line8> String screenshotFileName = getDefaultOutputFile(""-"" + browserId + "".png""); <line9> getOrCreatePage(browserId).takeScreeshot(screenshotFileName); <line10> browserLogs.put(browserId, webDriver.manage().logs().get(LogType.BROWSER)); <line11> } else { <line12> } <line13> } catch (Exception e) { <line14> } <line15> try { <line16> browser.close(); <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> } <line22> } <line23> "	 <line18>	Yes
public class A { <line0> public static void main(String[] args) { <line1> } <line2> } <line3> 	 <line0>	No
public class A { <line0> private void readBlacklistedSites(JsonReader reader) throws IOException { <line1> reader.beginArray(); <line2> while (reader.hasNext()) { <line3> BlacklistedSite blSite = new BlacklistedSite(); <line4> reader.beginObject(); <line5> while (reader.hasNext()) { <line6> switch (reader.peek()) { <line7> case END_OBJECT: <line8> continue; <line9> case NAME: <line10> String name = reader.nextName(); <line11> if (name.equals(ID)) { <line12> reader.skipValue(); <line13> } else if (name.equals(URI)) { <line14> blSite.setUri(reader.nextString()); <line15> } else { <line16> reader.skipValue(); <line17> } <line18> break; <line19> default: <line20> reader.skipValue(); <line21> continue; <line22> } <line23> } <line24> reader.endObject(); <line25> blSiteRepository.save(blSite); <line26> } <line27> reader.endArray(); <line28> } <line29> } <line30> 	 <line20>	Yes
"public class A { <line0> private void connect() { <line1> disconnect(); <line2> SqueezeBoxServerConfig config = getConfigAs(SqueezeBoxServerConfig.class); <line3> this.host = config.ipAddress; <line4> this.cliport = config.cliport; <line5> this.webport = config.webport; <line6> this.userId = config.userId; <line7> this.password = config.password; <line8> if (host.isEmpty()) { <line9> updateStatus( <line10> ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, ""host is not set""); <line11> return; <line12> } <line13> jsonRpcUrl = String.format(""http://%s:%d/jsonrpc.js"", host, webport); <line14> try { <line15> clientSocket = new Socket(host, cliport); <line16> } catch (IOException e) { <line17> updateStatus( <line18> ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage()); <line19> scheduleReconnect(); <line20> return; <line21> } <line22> try { <line23> listener = new SqueezeServerListener(); <line24> listener.start(); <line25> } catch (IllegalThreadStateException e) { <line26> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage()); <line27> } <line28> updateStatus(ThingStatus.ONLINE); <line29> } <line30> } <line31> "	 <line17>	Yes
public class A { <line0> @Override <line1> protected void decode(ChannelHandlerContext chc, DatagramPacket msg, List<Object> list) <line2> throws Exception { <line3> ByteBuf bb = msg.content(); <line4> if (bb.readableBytes() < LENGTH_OF_HEADER) { <line5> return; <line6> } <line7> int length = bb.getUnsignedShort(bb.readerIndex() + LENGTH_INDEX_IN_HEADER); <line8> if (bb.readableBytes() < length) { <line9> return; <line10> } <line11> ByteBuf messageBuffer = bb.slice(bb.readerIndex(), length); <line12> list.add(messageBuffer); <line13> messageBuffer.retain(); <line14> bb.skipBytes(length); <line15> } <line16> } <line17> 	 <line6>	No
"public class A { <line0> protected void loadResource(String resourceUri, XsltBuilder xslt) <line1> throws TransformerException, IOException { <line2> Source source = xslt.getUriResolver().resolve(resourceUri, null); <line3> if (source == null) { <line4> throw new IOException(""Cannot load schema resource "" + resourceUri); <line5> } else { <line6> xslt.setTransformerSource(source); <line7> } <line8> cacheCleared = false; <line9> } <line10> } <line11> "	 <line5>	No
"public class A { <line0> private ClobWriter getClobWriter(PreparedStatement statement, int clobColumn) <line1> throws SQLException, JdbcException { <line2> ResultSet rs = statement.executeQuery(); <line3> XmlBuilder result = new XmlBuilder(""result""); <line4> JdbcUtil.warningsToXml(statement.getWarnings(), result); <line5> rs.next(); <line6> Object clobUpdateHandle = getDbmsSupport().getClobHandle(rs, clobColumn); <line7> Writer dbmsWriter = getDbmsSupport().getClobWriter(rs, clobColumn, clobUpdateHandle); <line8> return new ClobWriter(getDbmsSupport(), clobUpdateHandle, clobColumn, dbmsWriter, rs, result); <line9> } <line10> } <line11> "	 <line2>	Yes
public class A { <line0> public static <T> T fromJson(String jsonStr, Class<T> type) { <line1> T ret = null; <line2> if (jsonStr != null) { <line3> try { <line4> ret = mapper.readValue(jsonStr, type); <line5> if (ret instanceof Struct) { <line6> ((Struct) ret).normalize(); <line7> } <line8> } catch (IOException e) { <line9> ret = null; <line10> } <line11> } <line12> return ret; <line13> } <line14> } <line15> 	 <line9>	Yes
public class A { <line0> private ByteBuffer allocate(int length) { <line1> if (length > SUSPICIOUS_THRESHOLD) <line2> return DIRECT_BUFFERS ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length); <line3> } <line4> } <line5> 	 <line4>	No
public class A { <line0> @Test <line1> public void minimumWireComponentExists() throws KuraException { <line2> WireGraphConfiguration wgc; <line3> try { <line4> wgc = wireGraphService.get(); <line5> } catch (KuraException e) { <line6> throw e; <line7> } <line8> assertTrue( <line9> wgc.getWireComponentConfigurations().stream() <line10> .anyMatch(wcc -> UNDER_TEST_PID.equals(wcc.getConfiguration().getPid()))); <line11> } <line12> } <line13> 	 <line0>	No
public class A { <line0> @Override <line1> public void run() { <line2> EventCoordinator.Listener eventListener = nextEvent.getListener(); <line3> while (stillManager()) { <line4> long wait = DEFAULT_WAIT_FOR_WATCHER; <line5> try { <line6> switch (getManagerGoalState()) { <line7> case NORMAL: <line8> setManagerState(ManagerState.NORMAL); <line9> break; <line10> case SAFE_MODE: <line11> if (getManagerState() == ManagerState.NORMAL) { <line12> setManagerState(ManagerState.SAFE_MODE); <line13> } <line14> if (getManagerState() == ManagerState.HAVE_LOCK) { <line15> setManagerState(ManagerState.SAFE_MODE); <line16> } <line17> break; <line18> case CLEAN_STOP: <line19> switch (getManagerState()) { <line20> case NORMAL: <line21> setManagerState(ManagerState.SAFE_MODE); <line22> break; <line23> case SAFE_MODE: <line24> { <line25> int count = nonMetaDataTabletsAssignedOrHosted(); <line26> if (count == 0 && goodStats()) { <line27> setManagerState(ManagerState.UNLOAD_METADATA_TABLETS); <line28> } <line29> } <line30> break; <line31> case UNLOAD_METADATA_TABLETS: <line32> { <line33> int count = assignedOrHosted(MetadataTable.ID); <line34> if (count == 0 && goodStats()) { <line35> setManagerState(ManagerState.UNLOAD_ROOT_TABLET); <line36> } <line37> } <line38> break; <line39> case UNLOAD_ROOT_TABLET: <line40> int count = assignedOrHosted(MetadataTable.ID); <line41> if (count > 0 && goodStats()) { <line42> setManagerState(ManagerState.UNLOAD_ROOT_TABLET); <line43> } <line44> int root_count = assignedOrHosted(RootTable.ID); <line45> if (root_count > 0 && goodStats()) { <line46> } <line47> if (count + root_count == 0 && goodStats()) { <line48> Set<TServerInstance> currentServers = tserverSet.getCurrentServers(); <line49> for (TServerInstance server : currentServers) { <line50> try { <line51> serversToShutdown.add(server); <line52> tserverSet.getConnection(server).fastHalt(managerLock); <line53> } catch (TException e) { <line54> } finally { <line55> tserverSet.remove(server); <line56> } <line57> } <line58> if (currentServers.isEmpty()) { <line59> setManagerState(ManagerState.STOP); <line60> } <line61> } <line62> break; <line63> default: <line64> break; <line65> } <line66> } <line67> } catch (Exception t) { <line68> } <line69> try { <line70> wait = updateStatus(); <line71> eventListener.waitForEvents(wait); <line72> } catch (Exception t) { <line73> sleepUninterruptibly(WAIT_BETWEEN_ERRORS, TimeUnit.MILLISECONDS); <line74> } <line75> } <line76> } <line77> } <line78> 	 <line75>	No
"public class A { <line0> @Override <line1> public String execute(final Context context, final Map<String, String> params) <line2> throws PluginException { <line3> final String include = params.get(PARAM_INCLUDE); <line4> final String exclude = params.get(PARAM_EXCLUDE); <line5> final Element masterDiv = getElement(""div"", ""index""); <line6> final Element indexDiv = getElement(""div"", ""header""); <line7> masterDiv.addContent(indexDiv); <line8> try { <line9> final List<String> pages = listPages(context, include, exclude); <line10> context.getEngine().getManager(PageManager.class).getPageSorter().sort(pages); <line11> char initialChar = ' '; <line12> Element currentDiv = new Element(""div"", xmlns_XHTML); <line13> for (final String name : pages) { <line14> if (StringUtils.isNotBlank(name) && name.charAt(0) != initialChar) { <line15> if (initialChar != ' ') { <line16> indexDiv.addContent("" - ""); <line17> } <line18> initialChar = name.charAt(0); <line19> masterDiv.addContent(makeHeader(String.valueOf(initialChar))); <line20> currentDiv = getElement(""div"", ""body""); <line21> masterDiv.addContent(currentDiv); <line22> indexDiv.addContent(getLink(""#"" + initialChar, String.valueOf(initialChar))); <line23> } else { <line24> currentDiv.addContent("", ""); <line25> } <line26> currentDiv.addContent( <line27> getLink(context.getURL(ContextEnum.PAGE_VIEW.getRequestContext(), name), name)); <line28> } <line29> } catch (final ProviderException e) { <line30> throw new PluginException(e.getMessage()); <line31> } <line32> final XMLOutputter out = new XMLOutputter(Format.getRawFormat()); <line33> return out.outputString(masterDiv); <line34> } <line35> } <line36> "	 <line30>	Yes
"public class A { <line0> public Database parseDatabase(String connection) { <line1> Database database = m_connections.get(connection); <line2> if (database == null <line3> && StringUtils.isNotEmpty(connection) <line4> && !m_errorConnections.contains(connection)) { <line5> try { <line6> if (connection.contains(""jdbc:mysql://"")) { <line7> String con = connection.split(""jdbc:mysql://"")[1]; <line8> con = con.split(""\\?"")[0]; <line9> int index = con.indexOf("":""); <line10> String ip = """"; <line11> if (index < 0) { <line12> ip = con.split(""/"")[0]; <line13> } else { <line14> ip = con.substring(0, index); <line15> } <line16> String name = con.substring(con.indexOf(""/"") + 1); <line17> database = new Database(name, ip); <line18> m_connections.put(connection, database); <line19> } else if (connection.contains(""jdbc:oracle"")) { <line20> String[] tabs = connection.split("":""); <line21> String ip = ""Default""; <line22> for (String str : tabs) { <line23> if (str.startsWith(""@"")) { <line24> ip = str.substring(1).trim(); <line25> } <line26> } <line27> String name = tabs[tabs.length - 1]; <line28> database = new Database(name, ip); <line29> m_connections.put(connection, database); <line30> } else { <line31> m_errorConnections.add(connection); <line32> } <line33> } catch (Exception e) { <line34> m_errorConnections.add(connection); <line35> Cat.logError(connection, e); <line36> } <line37> } <line38> return database; <line39> } <line40> } <line41> "	 <line21>	No
public class A { <line0> private void statisticJob(final int runningCount) { <line1> Optional<JobRunningStatistics> latestOne = repository.findLatestJobRunningStatistics(); <line2> latestOne.ifPresent(this::fillBlankIfNeeded); <line3> JobRunningStatistics jobRunningStatistics = <line4> new JobRunningStatistics( <line5> runningCount, StatisticTimeUtils.getCurrentStatisticTime(EXECUTE_INTERVAL)); <line6> repository.add(jobRunningStatistics); <line7> } <line8> } <line9> 	 <line2>	No
public class A { <line0> public void expandSystemProperties() { <line1> for (String key : systemPropertySource.keySet()) { <line2> String value = properties.getString(key); <line3> if (value != null) { <line4> String expanded = properties.expand(value); <line5> if (!value.equals(expanded)) System.setProperty(key, expanded); <line6> } <line7> } <line8> } <line9> } <line10> 	 <line9>	No
"public class A { <line0> @Nullable <line1> private ComputeJobResultPolicy result( <line2> final ComputeJobResult jobRes, final List<ComputeJobResult> results) { <line3> assert !Thread.holdsLock(mux); <line4> return U.wrapThreadLoader( <line5> dep.classLoader(), <line6> new CO<ComputeJobResultPolicy>() { <line7> @Nullable <line8> @Override <line9> public ComputeJobResultPolicy apply() { <line10> try { <line11> ComputeJobResultPolicy plc = null; <line12> try { <line13> plc = task.result(jobRes, results); <line14> if (plc == FAILOVER && noFailover) { <line15> IgniteException e = jobRes.getException(); <line16> if (e != null) throw e; <line17> plc = WAIT; <line18> } <line19> } finally { <line20> recordJobEvent( <line21> EVT_JOB_RESULTED, <line22> jobRes.getJobContext().getJobId(), <line23> jobRes.getNode(), <line24> plc, <line25> ""Job got resulted with: "" + plc); <line26> } <line27> if (log.isDebugEnabled()) <line28> return plc; <line29> } catch (IgniteException e) { <line30> if (X.hasCause(e, GridInternalException.class)) { <line31> if (log.isDebugEnabled()) <line32> } else if (X.hasCause(e, ComputeJobFailoverException.class)) { <line33> IgniteCheckedException e0 = <line34> new IgniteCheckedException( <line35> "" Job was not failed over because ComputeJobResultPolicy.FAILOVER was not"" <line36> + "" returned from ComputeTask.result(...) method for job result with"" <line37> + "" ComputeJobFailoverException."", <line38> e); <line39> finishTask(null, e0); <line40> return null; <line41> } else if (X.hasCause(e, GridServiceNotFoundException.class) <line42> || X.hasCause(e, ClusterTopologyCheckedException.class)) { <line43> } else <line44> finishTask(null, e); <line45> return null; <line46> } catch (Throwable e) { <line47> String errMsg = <line48> ""Failed to obtain remote job result policy for result from"" <line49> + ""ComputeTask.result(..) method due to undeclared user exception "" <line50> + ""(will fail the whole task): "" <line51> + jobRes; <line52> Throwable tmp = new ComputeUserUndeclaredException(errMsg, e); <line53> finishTask(null, tmp); <line54> if (e instanceof Error) throw e; <line55> return null; <line56> } <line57> } <line58> }); <line59> } <line60> } <line61> "	 <line48>	No
public class A { <line0> @Override <line1> public void onSuccess(ResultSet result) { <line2> concurrentQueries.release(); <line3> if (executedQueries.incrementAndGet() % 1000 == 0) <line4> } <line5> } <line6> 	 <line5>	No
public class A { <line0> public static List<String> getListOfMemberNames(Object group) { <line1> Map<String, Object> groupInfo = null; <line2> List<String> memberList = null; <line3> try { <line4> groupInfo = (Map<String, Object>) group; <line5> if (groupInfo.containsKey(TOSCAkeywords.GROUP_ELEMENT_MEMBERS_TAG)) { <line6> memberList = (List<String>) groupInfo.get(TOSCAkeywords.GROUP_ELEMENT_MEMBERS_TAG); <line7> } <line8> } catch (ClassCastException E) { <line9> return null; <line10> } <line11> if (!memberList.isEmpty()) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> return memberList; <line15> } <line16> return null; <line17> } <line18> } <line19> 	 <line5>	No
public class A { <line0> public void run() { <line1> if (listener instanceof Closeable) { <line2> try { <line3> ((Closeable) listener).close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void logSummary() { <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> private @Nullable List<SonosMusicService> getAvailableMusicServices() { <line1> if (musicServices == null) { <line2> Map<String, String> result = <line3> service.invokeAction(this, ""MusicServices"", ""ListAvailableServices"", null); <line4> String serviceList = result.get(""AvailableServiceDescriptorList""); <line5> if (serviceList != null) { <line6> List<SonosMusicService> services = SonosXMLParser.getMusicServicesFromXML(serviceList); <line7> musicServices = services; <line8> String[] servicesTypes = new String[0]; <line9> String serviceTypeList = result.get(""AvailableServiceTypeList""); <line10> if (serviceTypeList != null) { <line11> servicesTypes = serviceTypeList.split("",""); <line12> } <line13> int idx = 0; <line14> for (SonosMusicService service : services) { <line15> if (!""TuneIn"".equals(service.getName())) { <line16> if (idx < servicesTypes.length) { <line17> try { <line18> Integer serviceType = Integer.parseInt(servicesTypes[idx]); <line19> service.setType(serviceType); <line20> } catch (NumberFormatException e) { <line21> } <line22> idx++; <line23> } <line24> } else { <line25> service.setType(TUNEIN_DEFAULT_SERVICE_TYPE); <line26> } <line27> } <line28> } <line29> } <line30> return musicServices; <line31> } <line32> } <line33> "	 <line27>	Yes
public class A { <line0> @Override <line1> public boolean contains(IMolecularFormula formula) { <line2> return super.contains(formula); <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> private void updateLastLogonUserTime(User user) { <line1> if (!appConfiguration.getUpdateUserLastLogonTime()) { <line2> return; <line3> } <line4> CustomEntry customEntry = new CustomEntry(); <line5> customEntry.setDn(user.getDn()); <line6> List<String> personCustomObjectClassList = userService.getPersonCustomObjectClassList(); <line7> if ((personCustomObjectClassList != null) && !personCustomObjectClassList.isEmpty()) { <line8> Set<Object> customPersonCustomObjectClassList = new HashSet<Object>(); <line9> customPersonCustomObjectClassList.add(AttributeConstants.objectClassPerson); <line10> customPersonCustomObjectClassList.addAll(personCustomObjectClassList); <line11> if (user.getCustomObjectClasses() != null) { <line12> customPersonCustomObjectClassList.addAll(Arrays.asList(user.getCustomObjectClasses())); <line13> } <line14> customEntry.setCustomObjectClasses( <line15> customPersonCustomObjectClassList.toArray( <line16> new String[customPersonCustomObjectClassList.size()])); <line17> } else { <line18> customEntry.setCustomObjectClasses(UserService.USER_OBJECT_CLASSES); <line19> } <line20> Date now = new GregorianCalendar(TimeZone.getTimeZone(""UTC"")).getTime(); <line21> String nowDateString = ldapEntryManager.encodeTime(customEntry.getDn(), now); <line22> CustomAttribute customAttribute = new CustomAttribute(""jansLastLogonTime"", nowDateString); <line23> customEntry.getCustomAttributes().add(customAttribute); <line24> try { <line25> ldapEntryManager.merge(customEntry); <line26> } catch (EntryPersistenceException epe) { <line27> epe.printStackTrace(); <line28> } <line29> } <line30> } <line31> "	 <line27>	Yes
public class A { <line0> @Override <line1> public void destroyedResourceInstance(ResourceInstance resourceInstance) { <line2> if (logger.isTraceEnabled(LogMarker.STATISTICS_VERBOSE)) { <line3> } <line4> if (archiver != null) { <line5> try { <line6> archiver.destroyedResourceInstance(resourceInstance); <line7> } catch (GemFireException ex) { <line8> handleArchiverException(ex); <line9> } <line10> } <line11> } <line12> } <line13> 	 <line3>	Yes
"public class A { <line0> @Test <line1> public void testTxPutGetRestart() throws Exception { <line2> int clientGrid = gridCount() - 1; <line3> assertTrue(ignite(clientGrid).configuration().isClientMode()); <line4> final IgniteTransactions txs = ignite(clientGrid).transactions(); <line5> final IgniteCache<Integer, Integer> cache = jcache(clientGrid); <line6> updateCache(cache, txs); <line7> final AtomicBoolean stop = new AtomicBoolean(); <line8> IgniteInternalFuture<?> updateFut = <line9> GridTestUtils.runAsync( <line10> new Callable<Void>() { <line11> @Override <line12> public Void call() throws Exception { <line13> Thread.currentThread().setName(""update-thread""); <line14> assertTrue(latch.await(30_000, TimeUnit.MILLISECONDS)); <line15> int iter = 0; <line16> while (!stop.get()) { <line17> synchronized (mux) { <line18> updateCache(cache, txs); <line19> } <line20> } <line21> return null; <line22> } <line23> }); <line24> IgniteInternalFuture<?> restartFut = <line25> GridTestUtils.runAsync( <line26> new Callable<Void>() { <line27> @Override <line28> public Void call() throws Exception { <line29> Thread.currentThread().setName(""restart-thread""); <line30> ThreadLocalRandom rnd = ThreadLocalRandom.current(); <line31> while (!stop.get()) { <line32> assertTrue(latch.await(30_000, TimeUnit.MILLISECONDS)); <line33> int node = rnd.nextInt(0, gridCount() - 1); <line34> stopGrid(node); <line35> U.sleep(100); <line36> startGrid(node); <line37> latch = new CountDownLatch(1); <line38> U.sleep(100); <line39> } <line40> return null; <line41> } <line42> }); <line43> long endTime = System.currentTimeMillis() + 2 * 60_000; <line44> try { <line45> int iter = 0; <line46> while (System.currentTimeMillis() < endTime && !updateFut.isDone() && !restartFut.isDone()) { <line47> try { <line48> synchronized (mux) { <line49> readCache(cache, txs); <line50> } <line51> } finally { <line52> latch.countDown(); <line53> } <line54> } <line55> } finally { <line56> latch.countDown(); <line57> stop.set(true); <line58> } <line59> updateFut.get(); <line60> restartFut.get(); <line61> readCache(cache, txs); <line62> } <line63> } <line64> "	 <line36>	Yes
public class A { <line0> @Override <line1> public boolean prepareToProcessRecord(ContinuousFileReaderOperator<?, ?> op) { <line2> return false; <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> @GetMapping( <line1> value = ""/testPDFDownload"", <line2> consumes = ""application/json"", <line3> produces = ""application/json"") <line4> public ResponseEntity<?> testPDFDownload(@RequestHeader String fileName) { <line5> logger.entry(""UserConsentManagementController testPDFDownload() - starts ""); <line6> ErrorBean errorBean = null; <line7> String bucketName = ""consent-test-pdf""; <line8> String fileData = """"; <line9> try { <line10> Storage storageService = StorageOptions.getDefaultInstance().getService(); <line11> try { <line12> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line13> Blob blob = storageService.get(BlobId.of(bucketName, fileName)); <line14> blob.downloadTo(baos); <line15> fileData = new String(baos.toByteArray()); <line16> } catch (Exception e) { <line17> throw new RuntimeException(e); <line18> } <line19> } catch (Exception e) { <line20> } <line21> logger.exit(""UserConsentManagementController testPDFDownload() - ends ""); <line22> return new ResponseEntity<>(fileData, HttpStatus.OK); <line23> } <line24> } <line25> "	 <line21>	No
"public class A { <line0> @Override <line1> public void init(ServletConfig config) throws ServletException { <line2> super.init(config); <line3> try { <line4> fedoraServerPort = m_server.getParameter(""fedoraServerPort""); <line5> fedoraServerRedirectPort = m_server.getParameter(""fedoraRedirectPort""); <line6> fedoraServerHost = m_server.getParameter(""fedoraServerHost""); <line7> m_manager = (DOManager) m_server.getModule(""org.fcrepo.server.storage.DOManager""); <line8> String expireLimit = m_server.getParameter(""datastreamMediationLimit""); <line9> if (expireLimit == null || expireLimit.equalsIgnoreCase("""")) { <line10> datastreamMediationLimit = 5000; <line11> } else { <line12> datastreamMediationLimit = Integer.parseInt(expireLimit); <line13> } <line14> } catch (Throwable th) { <line15> } <line16> } <line17> } <line18> "	 <line13>	Yes
public class A { <line0> private void enrich( <line1> RoutePart routePart, EnricherContext context, List<RoutePartEnricher> routePartEnrichers) <line2> throws CriticalEnricherException { <line3> for (RoutePartEnricher routePartEnricher : routePartEnrichers) { <line4> routePartEnricher.enrich(routePart, context); <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> @Override <line1> public HAContextID convertProxyHAID(HAContextID haContextID) throws CSErrorException { <line2> if (null == haContextID) { <line3> throw new CSErrorException(ErrorCode.INVALID_HAID, ""HaContextID cannot be null.""); <line4> } <line5> if (StringUtils.isBlank(haContextID.getContextId())) { <line6> HAContextID tmpHAID = contextHAIDGenerator.generateHAContextID(null); <line7> haContextID.setContextId(tmpHAID.getContextId()); <line8> haContextID.setInstance(tmpHAID.getInstance()); <line9> haContextID.setBackupInstance(tmpHAID.getBackupInstance()); <line10> return haContextID; <line11> } else if (StringUtils.isNotBlank(haContextID.getInstance()) <line12> && StringUtils.isNotBlank(haContextID.getBackupInstance())) { <line13> if (StringUtils.isNumeric(haContextID.getContextId())) { <line14> String haIdKey = contextHAChecker.convertHAIDToHAKey(haContextID); <line15> haContextID.setContextId(haIdKey); <line16> } else if (contextHAChecker.isHAIDValid(haContextID.getContextId())) { <line17> String contextID = <line18> contextHAChecker.parseHAIDFromKey(haContextID.getContextId()).getContextId(); <line19> haContextID.setContextId(contextID); <line20> } else { <line21> throw new CSErrorException( <line22> ErrorCode.INVALID_HAID, <line23> ""Invalid contextID in haContextID : "" + gson.toJson(haContextID)); <line24> } <line25> return haContextID; <line26> } else { <line27> if (StringUtils.isNumeric(haContextID.getContextId())) { <line28> HAContextID tmpHAID = contextHAIDGenerator.generateHAContextID(haContextID); <line29> haContextID.setInstance(tmpHAID.getInstance()); <line30> haContextID.setBackupInstance(tmpHAID.getBackupInstance()); <line31> } else if (contextHAChecker.isHAIDValid(haContextID.getContextId())) { <line32> HAContextID tmpHAID = contextHAChecker.parseHAIDFromKey(haContextID.getContextId()); <line33> haContextID.setContextId(tmpHAID.getContextId()); <line34> haContextID.setInstance(tmpHAID.getInstance()); <line35> haContextID.setBackupInstance(tmpHAID.getBackupInstance()); <line36> } else { <line37> throw new CSErrorException( <line38> ErrorCode.INVALID_HAID, <line39> ""Invalid contextID in haContextID : "" + gson.toJson(haContextID)); <line40> } <line41> if (contextHAChecker.isHAContextIDValid(haContextID)) { <line42> } <line43> return haContextID; <line44> } <line45> } <line46> } <line47> "	 <line42>	Yes
"public class A { <line0> private String getResultMessage(QueryContext queryContext) { <line1> try { <line2> LensResultSet result = queryService.getResultset(queryContext.getQueryHandle()); <line3> if (result instanceof InMemoryResultSet) { <line4> long availableUntilTime = <line5> ((InMemoryResultSet) result).getCreationTime() + inMemoryResultsetTTLSecs; <line6> return RESULT_AVAILABLE_UNTIL_MSG + MESSAGE_DATE_FORMATTER.print(availableUntilTime); <line7> } else { <line8> return result.toQueryResult().toPrettyString(); <line9> } <line10> } catch (LensException e) { <line11> return ""Error retrieving result.""; <line12> } <line13> } <line14> } <line15> "	 <line11>	Yes
public class A { <line0> @Override <line1> public Set<Principal> getPrincipals(final HttpServletRequest request) { <line2> if (headerName == null || separator == null) { <line3> return emptySet(); <line4> } <line5> if (request == null) { <line6> return emptySet(); <line7> } <line8> final String value = request.getHeader(headerName); <line9> if (value == null) { <line10> return emptySet(); <line11> } <line12> final String[] names = value.split(separator); <line13> final Set<Principal> principals = new HashSet<>(); <line14> for (final String name : names) { <line15> principals.add(createPrincipal(name)); <line16> } <line17> return principals; <line18> } <line19> } <line20> 	 <line9>	No
public class A { <line0> protected Boolean getAutoCommit(Connection conn) { <line1> Boolean autoCommit = null; <line2> try { <line3> autoCommit = conn != null ? conn.getAutoCommit() : null; <line4> } catch (SQLException continued) { <line5> } <line6> return autoCommit; <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> @Test <line1> public void testLogin() throws Exception { <line2> LoginContext context = <line3> new LoginContext( <line4> ""LDAPLogin"", <line5> new CallbackHandler() { <line6> @Override <line7> public void handle(Callback[] callbacks) <line8> throws IOException, UnsupportedCallbackException { <line9> for (int i = 0; i < callbacks.length; i++) { <line10> if (callbacks[i] instanceof NameCallback) { <line11> ((NameCallback) callbacks[i]).setName(""first""); <line12> } else if (callbacks[i] instanceof PasswordCallback) { <line13> ((PasswordCallback) callbacks[i]).setPassword(""secret"".toCharArray()); <line14> } else { <line15> throw new UnsupportedCallbackException(callbacks[i]); <line16> } <line17> } <line18> } <line19> }); <line20> context.login(); <line21> context.logout(); <line22> assertTrue( <line23> ""sessions still active after logout"", <line24> waitFor(() -> ldapServer.getLdapSessionManager().getSessions().length == 0)); <line25> } <line26> } <line27> "	 <line2>	Yes
"public class A { <line0> @RequestMapping(path = ""/v1/network-utilization"", method = RequestMethod.GET) <line1> public ResponseEntity<Object> getNetworkUtilization(@RequestParam(""ag"") String assetGroup) { <line2> if (Strings.isNullOrEmpty(assetGroup)) { <line3> return ResponseUtils.buildFailureResponse(new Exception(StatsConstants.ERR_MSG_AG_MANDATORY)); <line4> } <line5> ResponseVO response; <line6> try { <line7> response = new ResponseVO(statsService.getNetworkUtilization(assetGroup)); <line8> } catch (Exception e) { <line9> return ResponseUtils.buildFailureResponse(e); <line10> } <line11> return ResponseUtils.buildSucessResponse(response); <line12> } <line13> } <line14> "	 <line1>	No
public class A { <line0> @Override <line1> public DeleteResponse delete(DeleteRequest request) { <line2> try { <line3> Thread.sleep(deleteDelayMillis); <line4> } catch (InterruptedException e) { <line5> } <line6> return provider.delete(request); <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> private void mixedWriteTo(OutputStream out) throws IOException { <line1> if (out != null) { <line2> Gson gson = new Gson(); <line3> LinkedHashMap<String, List<String[]>> headerMap = new LinkedHashMap<String, List<String[]>>(); <line4> headerMap.put(""schema"", buffer.first); <line5> out.write((gson.toJson(headerMap) + ""\n"").getBytes()); <line6> for (Object[] tuple : buffer.second) { <line7> out.write((gson.toJson(tuple) + ""\n"").getBytes()); <line8> } <line9> } <line10> } <line11> } <line12> "	 <line1>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> updateStateFromCurrentKeys(); <line3> initialized = true; <line4> while (keepRunning) { <line5> long now = System.currentTimeMillis(); <line6> _run(now); <line7> try { <line8> Thread.sleep(5000); <line9> } catch (InterruptedException ie) { <line10> } <line11> } <line12> } <line13> } <line14> 	 <line4>	No
"public class A { <line0> private static void createControlFile(FileSystem fs, int fileSize, int nrFiles) <line1> throws IOException { <line2> fs.delete(CONTROL_DIR, true); <line3> for (int i = 0; i < nrFiles; i++) { <line4> String name = getFileName(i); <line5> Path controlFile = new Path(CONTROL_DIR, ""in_file_"" + name); <line6> SequenceFile.Writer writer = null; <line7> try { <line8> writer = <line9> SequenceFile.createWriter( <line10> fs, fsConfig, controlFile, Text.class, LongWritable.class, CompressionType.NONE); <line11> writer.append(new Text(name), new LongWritable(fileSize)); <line12> } catch (Exception e) { <line13> throw new IOException(e.getLocalizedMessage()); <line14> } finally { <line15> if (writer != null) writer.close(); <line16> writer = null; <line17> } <line18> } <line19> } <line20> } <line21> "	 <line19>	Yes
public class A { <line0> private RestResponse<Family> create() throws ClientException { <line1> FamilyCommandOptions.CreateCommandOptions commandOptions = <line2> familyCommandOptions.createCommandOptions; <line3> FamilyCreateParams data = <line4> new FamilyCreateParams() <line5> .setId(commandOptions.id) <line6> .setName(commandOptions.name) <line7> .setDescription(commandOptions.description); <line8> if (commandOptions.members != null) { <line9> data.setMembers( <line10> commandOptions.members.stream() <line11> .map(memberId -> new IndividualCreateParams().setId(memberId)) <line12> .collect(Collectors.toList())); <line13> } <line14> ObjectMap params = new ObjectMap(); <line15> params.put(FamilyDBAdaptor.QueryParams.STUDY.key(), commandOptions.study); <line16> return openCGAClient.getFamilyClient().create(data, params); <line17> } <line18> } <line19> 	 <line1>	Yes
"public class A { <line0> public static BaseAssemblyNodeFactory build( <line1> int rootStream, Map<Integer, int[]> streamsJoinedPerStream, boolean[] isRequiredPerStream) { <line2> if (streamsJoinedPerStream.size() < 3) { <line3> throw new IllegalArgumentException(""Not a 3-way join""); <line4> } <line5> if ((rootStream < 0) || (rootStream >= streamsJoinedPerStream.size())) { <line6> throw new IllegalArgumentException(""Invalid root stream""); <line7> } <line8> if (isRequiredPerStream.length != streamsJoinedPerStream.size()) { <line9> throw new IllegalArgumentException(""Arrays not matching up""); <line10> } <line11> NStreamOuterQueryPlanBuilder.verifyJoinedPerStream(rootStream, streamsJoinedPerStream); <line12> if (log.isDebugEnabled()) { <line13> } <line14> BaseAssemblyNodeFactory topNode = <line15> createNode( <line16> true, <line17> rootStream, <line18> streamsJoinedPerStream.size(), <line19> streamsJoinedPerStream.get(rootStream), <line20> isRequiredPerStream); <line21> recursiveBuild(rootStream, topNode, streamsJoinedPerStream, isRequiredPerStream); <line22> if (log.isDebugEnabled()) { <line23> StringWriter buf = new StringWriter(); <line24> PrintWriter print = new PrintWriter(buf); <line25> IndentWriter indentWriter = new IndentWriter(print, 0, 2); <line26> topNode.printDescendends(indentWriter); <line27> } <line28> return topNode; <line29> } <line30> } <line31> "	 <line27>	Yes
public class A { <line0> @Override <line1> public int doReindex( <line2> FHIROperationContext operationContext, <line3> OperationOutcome.Builder operationOutcomeResult, <line4> Instant tstamp, <line5> String resourceLogicalId) <line6> throws Exception { <line7> int result = 0; <line8> final int TX_ATTEMPTS = 5; <line9> int attempt = 1; <line10> do { <line11> FHIRTransactionHelper txn = new FHIRTransactionHelper(getTransaction()); <line12> txn.begin(); <line13> try { <line14> FHIRPersistenceContext persistenceContext = null; <line15> result = <line16> persistence.reindex( <line17> persistenceContext, operationOutcomeResult, tstamp, resourceLogicalId); <line18> attempt = TX_ATTEMPTS; <line19> } catch (FHIRPersistenceDataAccessException x) { <line20> if (x.isTransactionRetryable() && attempt < TX_ATTEMPTS) { <line21> } else { <line22> throw x; <line23> } <line24> } finally { <line25> txn.end(); <line26> } <line27> } while (attempt++ < TX_ATTEMPTS); <line28> return result; <line29> } <line30> } <line31> 	 <line21>	Yes
"public class A { <line0> public void publishEndpoint(EndpointInfo endpoint) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> EndpointInfo exists = endpoints.put(endpoint.id, endpoint); <line4> if (exists != null) { <line5> throw new IllegalStateException( <line6> ""An endpoint with id "" + endpoint.id + "" has already been published: "" + exists); <line7> } <line8> } <line9> } <line10> "	 <line2>	Yes
"public class A { <line0> private static InputStreamReader loadConfig() <line1> throws AgentPackageNotFoundException, ConfigNotFoundException { <line2> String specifiedConfigPath = System.getProperty(SPECIFIED_CONFIG_PATH); <line3> File configFile = <line4> StringUtil.isEmpty(specifiedConfigPath) <line5> ? new File(AgentPackagePath.getPath(), DEFAULT_CONFIG_FILE_NAME) <line6> : new File(specifiedConfigPath); <line7> if (configFile.exists() && configFile.isFile()) { <line8> try { <line9> return new InputStreamReader(new FileInputStream(configFile), StandardCharsets.UTF_8); <line10> } catch (FileNotFoundException e) { <line11> throw new ConfigNotFoundException(""Failed to load agent.config"", e); <line12> } <line13> } <line14> throw new ConfigNotFoundException(""Failed to load agent.config.""); <line15> } <line16> } <line17> "	 <line9>	Yes
public class A { <line0> private Map<String, String> getProperties(ServiceConfigurationItem confItem) { <line1> String targetUrl = confItem.getHref(); <line2> try { <line3> Map<String, ?> responseMap = <line4> JsonClientUtil.getEntity(client.target(targetUrl), AMBARI_REST_API_MEDIA_TYPE, Map.class); <line5> List<Map<String, ?>> items = <line6> (List<Map<String, ?>>) <line7> responseMap.get(AmbariRestAPIConstants.AMBARI_JSON_SCHEMA_COMMON_ITEMS); <line8> if (items.size() > 0) { <line9> return (Map<String, String>) <line10> items.get(0).get(AmbariRestAPIConstants.AMBARI_JSON_SCHEMA_COMMON_PROPERTIES); <line11> } <line12> return Collections.emptyMap(); <line13> } catch (WebApplicationException e) { <line14> throw WrappedWebApplicationException.of(e); <line15> } <line16> } <line17> } <line18> 	 <line2>	Yes
public class A { <line0> @Modified <line1> protected void modified(Map<String, Object> config) { <line2> configuration.update(new Configuration(config).as(UpnpControlBindingConfiguration.class)); <line3> } <line4> } <line5> 	 <line3>	Yes
public class A { <line0> public void fatalError(String message, Throwable throwable) { <line1> setMdc(); <line2> } <line3> } <line4> 	 <line3>	No
public class A { <line0> @Override <line1> public void addRecover(TsFileResource tsFileResource, boolean sequence) { <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private static Map<String, Object> decryptECPS(String ecps, String phrase) { <line2> try { <line3> return new ObjectMapper() <line4> .readValue(AESGCMHelper.getInstance(phrase).decrypt(ecps), Map.class); <line5> } catch (Exception e) { <line6> throw new RuntimeException(e); <line7> } <line8> } <line9> } <line10> "	 <line6>	Yes
"public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public void logInterDirectMeasurementDetailsToDB( <line2> final QoSInterDirectPingMeasurementLog measurementLogSaved, <line3> final List<IcmpPingResponse> responseList, <line4> final ZonedDateTime aroundNow) { <line5> if (responseList == null || responseList.isEmpty()) { <line6> throw new InvalidParameterException(""List<IcmpPingResponse>"" + EMPTY_OR_NULL_ERROR_MESSAGE); <line7> } else if (measurementLogSaved == null) { <line8> throw new InvalidParameterException(""QoSInterPingMeasurementLog"" + NULL_ERROR_MESSAGE); <line9> } else if (aroundNow == null) { <line10> throw new InvalidParameterException(""ZonedDateTime"" + NULL_ERROR_MESSAGE); <line11> } <line12> final List<QoSInterDirectPingMeasurementLogDetails> interMeasurementLogDetailsList = <line13> new ArrayList<>(responseList.size()); <line14> int measurementSequenece = 0; <line15> for (final IcmpPingResponse icmpPingResponse : responseList) { <line16> final QoSInterDirectPingMeasurementLogDetails measurementLogDetails = <line17> new QoSInterDirectPingMeasurementLogDetails(); <line18> measurementLogDetails.setMeasurementLog(measurementLogSaved); <line19> measurementLogDetails.setMeasurementSequeneceNumber(measurementSequenece++); <line20> measurementLogDetails.setSuccessFlag(icmpPingResponse.getSuccessFlag()); <line21> measurementLogDetails.setTimeoutFlag(icmpPingResponse.getTimeoutFlag()); <line22> measurementLogDetails.setErrorMessage(icmpPingResponse.getErrorMessage()); <line23> measurementLogDetails.setThrowable( <line24> icmpPingResponse.getThrowable() == null <line25> ? null <line26> : icmpPingResponse.getThrowable().toString()); <line27> measurementLogDetails.setSize(icmpPingResponse.getSize()); <line28> measurementLogDetails.setTtl(icmpPingResponse.getTtl()); <line29> measurementLogDetails.setRtt(icmpPingResponse.getRtt()); <line30> measurementLogDetails.setDuration((int) icmpPingResponse.getDuration()); <line31> measurementLogDetails.setMeasuredAt(aroundNow); <line32> interMeasurementLogDetailsList.add(measurementLogDetails); <line33> } <line34> try { <line35> qoSInterDirectPingMeasurementLogDetailsRepository.saveAll(interMeasurementLogDetailsList); <line36> qoSInterDirectPingMeasurementLogDetailsRepository.flush(); <line37> } catch (final Exception ex) { <line38> throw new ArrowheadException(CoreCommonConstants.DATABASE_OPERATION_EXCEPTION_MSG); <line39> } <line40> } <line41> } <line42> "	 <line17>	No
"public class A { <line0> protected void exportData(ActionRequest actionRequest, Portlet portlet) throws Exception { <line1> try { <line2> ThemeDisplay themeDisplay = (ThemeDisplay) actionRequest.getAttribute(WebKeys.THEME_DISPLAY); <line3> long plid = ParamUtil.getLong(actionRequest, ""plid""); <line4> long groupId = ParamUtil.getLong(actionRequest, ""groupId""); <line5> String fileName = ParamUtil.getString(actionRequest, ""exportFileName""); <line6> Map<String, Serializable> exportPortletSettingsMap = <line7> _exportImportConfigurationSettingsMapFactory.buildExportPortletSettingsMap( <line8> themeDisplay.getUserId(), <line9> plid, <line10> groupId, <line11> portlet.getPortletId(), <line12> actionRequest.getParameterMap(), <line13> themeDisplay.getLocale(), <line14> themeDisplay.getTimeZone(), <line15> fileName); <line16> ExportImportConfiguration exportImportConfiguration = <line17> _exportImportConfigurationLocalService.addDraftExportImportConfiguration( <line18> themeDisplay.getUserId(), <line19> ExportImportConfigurationConstants.TYPE_EXPORT_PORTLET, <line20> exportPortletSettingsMap); <line21> _exportImportService.exportPortletInfoAsFileInBackground(exportImportConfiguration); <line22> } catch (Exception exception) { <line23> if (exception instanceof LARFileNameException) { <line24> throw exception; <line25> } <line26> if (_log.isDebugEnabled()) { <line27> } <line28> SessionErrors.add(actionRequest, exception.getClass(), exception); <line29> } <line30> } <line31> } <line32> "	 <line27>	Yes
"public class A { <line0> @SuppressWarnings(""rawtypes"") <line1> @Test <line2> public void testGetPendingCollaborations() throws Exception { <line3> final java.util.Collection result = requestBody(""direct://GETPENDINGCOLLABORATIONS"", null); <line4> assertNotNull(result, ""getPendingCollaborations result""); <line5> } <line6> } <line7> "	 <line4>	No
"public class A { <line0> private void processDataObject( <line1> Node resource, PrivacyPreferenceService ppoService, PimoService pimoService) { <line2> DataObject dataObject = null; <line3> try { <line4> dataObject = getPimoService().get(resource.asURI(), DataObject.class); <line5> PrivacyPreference pp = ppoService.getForDataObject(dataObject); <line6> if (pp == null) { <line7> return; <line8> } <line9> if (pp.hasAccessSpace()) { <line10> updateRelatedTo(pp, dataObject); <line11> processEvalData(NFO.FileDataObject, pp, dataObject); <line12> } <line13> } catch (ClassCastException e) { <line14> logger.error(""Could not load DataObject for: <"" + resource.toString() + ""> . "", e); <line15> return; <line16> } catch (NotFoundException e) { <line17> return; <line18> } catch (InfosphereException e) { <line19> logger.error(""Could not process trust for: <"" + resource.toString() + ""> . "", e); <line20> return; <line21> } catch (RepositoryException e) { <line22> return; <line23> } <line24> } <line25> } <line26> "	 <line5>	No
"public class A { <line0> private void updateThreadCounts(final Element rootElement, final FlowController controller) { <line1> final Integer maxThreadCount = getInteger(rootElement, ""maxThreadCount""); <line2> if (maxThreadCount == null) { <line3> controller.setMaxTimerDrivenThreadCount(getInt(rootElement, ""maxTimerDrivenThreadCount"")); <line4> controller.setMaxEventDrivenThreadCount(getInt(rootElement, ""maxEventDrivenThreadCount"")); <line5> } else { <line6> controller.setMaxTimerDrivenThreadCount(maxThreadCount * 2 / 3); <line7> controller.setMaxEventDrivenThreadCount(maxThreadCount / 3); <line8> } <line9> } <line10> } <line11> "	 <line1>	Yes
"public class A { <line0> private Ini convertPathToIni(String path, boolean required) { <line1> Ini ini = null; <line2> if (StringUtils.hasText(path)) { <line3> InputStream is = null; <line4> if (!ResourceUtils.hasResourcePrefix(path)) { <line5> is = getServletContextResourceStream(path); <line6> } else { <line7> try { <line8> is = ResourceUtils.getInputStreamForPath(path); <line9> } catch (IOException e) { <line10> if (required) { <line11> throw new ConfigurationException(e); <line12> } else { <line13> if (log.isDebugEnabled()) { <line14> } <line15> } <line16> } <line17> } <line18> if (is != null) { <line19> ini = new Ini(); <line20> ini.load(is); <line21> } else { <line22> if (required) { <line23> throw new ConfigurationException(""Unable to load resource path '"" + path + ""'""); <line24> } <line25> } <line26> } <line27> return ini; <line28> } <line29> } <line30> "	 <line14>	Yes
public class A { <line0> @Override <line1> public void transferFailed(TransferEvent event) { <line2> transferCompleted(event); <line3> } <line4> } <line5> 	 <line3>	Yes
public class A { <line0> private void handleHandshakePacket(ControlHandshakeResponsePacket message, Channel channel) { <line1> boolean isCompleted = handshaker.handshakeComplete(message); <line2> if (isCompleted) { <line3> HandshakeResponseCode code = handshaker.getHandshakeResult(); <line4> if (code == HandshakeResponseCode.SUCCESS || code == HandshakeResponseCode.ALREADY_KNOWN) { <line5> state.toRunSimplex(); <line6> } else if (code == HandshakeResponseCode.DUPLEX_COMMUNICATION <line7> || code == HandshakeResponseCode.ALREADY_DUPLEX_COMMUNICATION) { <line8> remoteClusterOption = handshaker.getClusterOption(); <line9> state.toRunDuplex(); <line10> } else if (code == HandshakeResponseCode.SIMPLEX_COMMUNICATION <line11> || code == HandshakeResponseCode.ALREADY_SIMPLEX_COMMUNICATION) { <line12> state.toRunSimplex(); <line13> } else { <line14> return; <line15> } <line16> } else if (handshaker.isFinished()) { <line17> } else { <line18> } <line19> } <line20> } <line21> 	 <line5>	No
public class A { <line0> private Key unwrapKey(PrivateKey wrappingKey, byte[] wrappedKey) throws GeneralSecurityException { <line1> Cipher unwrapper = Cipher.getInstance(RSA); <line2> unwrapper.init(Cipher.UNWRAP_MODE, wrappingKey); <line3> try { <line4> return unwrapper.unwrap(wrappedKey, DES, Cipher.SECRET_KEY); <line5> } catch (InvalidKeyException e) { <line6> throw e; <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
"public class A { <line0> @Test <line1> public void test_20() { <line2> CompareEffects comp = new CompareEffects(genomeName, randSeed, verbose); <line3> String trId = ""ENST00000382673""; <line4> comp.snpEffect(path(trId + "".snps""), trId, true); <line5> } <line6> } <line7> "	 <line1>	No
"public class A { <line0> public void testGetActionMappingName1() { <line1> String[] paths = { <line2> ""foo"", ""foo.do"", ""foo?foo=bar"", ""foo?foo=bar&bar=baz"", ""foo?foo=bar&amp;bar=baz"" <line3> }; <line4> String[][] prepends = { <line5> {"""", ""/foo""}, {""/"", ""/foo""}, {""bar/"", ""/bar/foo""}, {""/bar/"", ""/bar/foo""} <line6> }; <line7> String[] appends = { <line8> """", ""#anchor"", ""?"", ""?#"", ""?foo=bar"", ""?foo1=bar1&foo2=bar2"", ""?foo1=bar1&amp;foo2=bar2"" <line9> }; <line10> String finalResult = null; <line11> String path = null; <line12> String results = null; <line13> boolean equality = false; <line14> int ct = 0; <line15> for (int i = 0; i < appends.length; i++) { <line16> for (int j = 0; j < prepends.length; j++) { <line17> finalResult = prepends[j][1]; <line18> for (int k = 0; k < paths.length; k++) { <line19> path = prepends[j][0] + paths[k] + appends[i]; <line20> results = tagutils.getActionMappingName(path); <line21> equality = finalResult.equals(results); <line22> if (!equality) { <line23> fail( <line24> ""Path does not return correct result\n"" <line25> + ""\nexpected: "" <line26> + results <line27> + ""\nfound: "" <line28> + path); <line29> } <line30> assertTrue(""Path should translate to result"", equality); <line31> ct++; <line32> } <line33> } <line34> } <line35> } <line36> } <line37> "	 <line16>	No
public class A { <line0> private void logMessage(Exchange exchange, Document inDoc) throws Exception { <line1> DomConverter converter = new DomConverter(); <line2> String xmlStr = converter.toString(inDoc, exchange); <line3> } <line4> } <line5> 	 <line0>	No
public class A { <line0> public <T> boolean delete( <line1> Query<T> query, final ScanCallback<T, ?> scanCallback, final boolean deleteDuplicates) { <line2> if (query == null) { <line3> query = (Query) QueryBuilder.newBuilder().build(); <line4> } <line5> if (((query.getQueryConstraints() == null) <line6> || (query.getQueryConstraints() instanceof EverythingQuery))) { <line7> if ((query.getDataTypeQueryOptions().getTypeNames() == null) <line8> || (query.getDataTypeQueryOptions().getTypeNames().length == 0) <line9> || isAllAdapters(query.getDataTypeQueryOptions().getTypeNames())) { <line10> return deleteEverything(); <line11> } else { <line12> try { <line13> final BaseQueryOptions sanitizedQueryOptions = <line14> new BaseQueryOptions(query, adapterStore, internalAdapterStore); <line15> for (final Pair<Index, List<InternalDataAdapter<?>>> indexAdapterPair : <line16> sanitizedQueryOptions.getIndicesForAdapters( <line17> adapterStore, indexMappingStore, indexStore)) { <line18> if (indexAdapterPair.getLeft() != null) { <line19> for (final InternalDataAdapter adapter : indexAdapterPair.getRight()) { <line20> try { <line21> deleteEntries( <line22> adapter, <line23> indexAdapterPair.getLeft(), <line24> query.getCommonQueryOptions().getAuthorizations()); <line25> } catch (final IOException e) { <line26> return false; <line27> } <line28> } <line29> } <line30> } <line31> if (baseOptions.isSecondaryIndexing()) { <line32> for (final InternalDataAdapter adapter : <line33> sanitizedQueryOptions.getAdaptersArray(adapterStore)) { <line34> deleteEntries( <line35> adapter, <line36> DataIndexUtils.DATA_ID_INDEX, <line37> query.getCommonQueryOptions().getAuthorizations()); <line38> } <line39> } <line40> } catch (final IOException e) { <line41> return false; <line42> } <line43> } <line44> } else { <line45> try (CloseableIterator<?> dataIt = <line46> internalQuery( <line47> query, <line48> deleteDuplicates ? DeletionMode.DELETE_WITH_DUPLICATES : DeletionMode.DELETE, <line49> scanCallback)) { <line50> while (dataIt.hasNext()) { <line51> dataIt.next(); <line52> } <line53> } <line54> } <line55> return true; <line56> } <line57> } <line58> 	 <line41>	Yes
"public class A { <line0> private void startBackupThread() { <line1> Preconditions.checkNotNull( <line2> checkpointBackUpExecutor, <line3> ""Expected the checkpoint backup exector to be non-null, "" <line4> + ""but it is null. Checkpoint will not be backed up.""); <line5> checkpointBackUpExecutor.submit( <line6> new Runnable() { <line7> @Override <line8> public void run() { <line9> boolean error = false; <line10> try { <line11> backupCheckpoint(backupDir); <line12> } catch (Throwable throwable) { <line13> fileChannelCounter.incrementCheckpointBackupWriteErrorCount(); <line14> error = true; <line15> } finally { <line16> backupCompletedSema.release(); <line17> } <line18> if (!error) { <line19> } <line20> } <line21> }); <line22> } <line23> } <line24> "	 <line5>	Yes
public class A { <line0> private NodeConnectionStatus updateNodeStatus( <line1> final NodeIdentifier nodeId, <line2> final NodeConnectionStatus updatedStatus, <line3> final boolean storeState) { <line4> final String nodeUuid = nodeId.getId(); <line5> while (true) { <line6> final NodeConnectionStatus currentStatus = nodeStatuses.get(nodeUuid); <line7> if (currentStatus == null) { <line8> onNodeAdded(nodeId, storeState); <line9> return null; <line10> } <line11> if (currentStatus.getUpdateIdentifier() > updatedStatus.getUpdateIdentifier()) { <line12> return currentStatus; <line13> } <line14> final boolean updated = nodeStatuses.replace(nodeUuid, currentStatus, updatedStatus); <line15> if (updated) { <line16> onNodeStateChange(nodeId, updatedStatus.getState()); <line17> return currentStatus; <line18> } <line19> } <line20> } <line21> } <line22> 	 <line17>	Yes
public class A { <line0> private boolean isQueried(Path field) { <line1> for (QueryExpression q : queries) { <line2> if (q.isRequired(field)) { <line3> return true; <line4> } else { <line5> } <line6> } <line7> return false; <line8> } <line9> } <line10> 	 <line6>	No
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public void configure(Map<String, Object> parserConfig) { <line3> setReadCharset(parserConfig); <line4> this.grokPath = (String) parserConfig.get(""grokPath""); <line5> String multiLineString = (String) parserConfig.get(""multiLine""); <line6> if (!StringUtils.isBlank(multiLineString)) { <line7> multiLine = Boolean.parseBoolean(multiLineString); <line8> } <line9> this.patternLabel = (String) parserConfig.get(""patternLabel""); <line10> this.timestampField = (String) parserConfig.get(""timestampField""); <line11> List<String> timeFieldsParam = (List<String>) parserConfig.get(""timeFields""); <line12> if (timeFieldsParam != null) { <line13> this.timeFields = timeFieldsParam; <line14> } <line15> String dateFormatParam = (String) parserConfig.get(""dateFormat""); <line16> if (dateFormatParam != null) { <line17> this.dateFormat = new SimpleDateFormat(dateFormatParam); <line18> } <line19> String timeZoneParam = (String) parserConfig.get(""timeZone""); <line20> if (timeZoneParam != null) { <line21> dateFormat.setTimeZone(TimeZone.getTimeZone(timeZoneParam)); <line22> } else { <line23> dateFormat.setTimeZone(TimeZone.getTimeZone(""UTC"")); <line24> } <line25> } <line26> } <line27> "	 <line22>	Yes
public class A { <line0> private Txn doBeginTransaction() { <line1> final long txnId = nextTxnId.getAndIncrement(); <line2> if (journalManager.isPresent()) { <line3> try { <line4> journalManager.get().journal(new TxnStart(txnId)); <line5> } catch (final JournalException e) { <line6> } <line7> } <line8> transactions.put(txnId, new TxnCounter().increment()); <line9> final Txn txn = new Txn(this, txnId); <line10> try (final DBBroker broker = pool.getBroker()) { <line11> broker.addCurrentTransaction(txn); <line12> } catch (final EXistException ee) { <line13> throw new RuntimeException(ee); <line14> } <line15> return txn; <line16> } <line17> } <line18> 	 <line13>	Yes
public class A { <line0> @Override <line1> public void configure(MapredContext context) { <line2> super.configure(context); <line3> conf = context.getJobConf(); <line4> soi = PrimitiveObjectInspectorFactory.javaStringObjectInspector; <line5> doi = LazyPrimitiveObjectInspectorFactory.LAZY_DOUBLE_OBJECT_INSPECTOR; <line6> } <line7> } <line8> 	 <line6>	Yes
public class A { <line0> @Override <line1> public void dropDimension(LensSessionHandle sessionid, String dimName) throws LensException { <line2> try (SessionContext ignored = new SessionContext(sessionid)) { <line3> getClient(sessionid).dropDimension(dimName); <line4> } <line5> } <line6> } <line7> 	 <line1>	No
public class A { <line0> @Authorized <line1> public <T extends Definition> T getDefinitionByUuid(Class<T> definitionType, String uuid) { <line2> SerializedObject so = dao.getSerializedObjectByUuid(uuid); <line3> try { <line4> return dao.convertSerializedObject(definitionType, so); <line5> } catch (Exception e) { <line6> ExceptionUtil.rethrowAuthenticationException(e); <line7> return null; <line8> } <line9> } <line10> } <line11> 	 <line4>	No
"public class A { <line0> private void setClasses(Class<? extends Message>[] schemas) { <line1> Preconditions.checkArgument(schemas.length != 0, ""No schemas provided.""); <line2> Set<Class<? extends Message>> clazzes = Sets.newHashSet(); <line3> for (Class<? extends Message> schema : schemas) { <line4> Preconditions.checkNotNull(schema, ""Provided schema cannot be null""); <line5> Preconditions.checkArgument(!clazzes.contains(schema), ""Schema %s was passed twice."", schema); <line6> clazzes.add(schema); <line7> Annotation[] ans = schema.getAnnotations(); <line8> String schemaType = null; <line9> Class<? extends CustomMessageDeserializer> cqd = null; <line10> Class<? extends CustomMessageValidator> cqv = null; <line11> for (Annotation an : ans) { <line12> if (an instanceof MessageType) { <line13> if (schemaType != null) { <line14> throw new IllegalArgumentException( <line15> ""Cannot specify the "" <line16> + MessageType.class <line17> + "" annotation twice on the class: "" <line18> + schema); <line19> } <line20> schemaType = ((MessageType) an).type(); <line21> } else if (an instanceof MessageDeserializerInfo) { <line22> if (cqd != null) { <line23> throw new IllegalArgumentException( <line24> ""Cannot specify the "" <line25> + MessageDeserializerInfo.class <line26> + "" annotation twice on the class: "" <line27> + schema); <line28> } <line29> cqd = ((MessageDeserializerInfo) an).clazz(); <line30> } else if (an instanceof MessageValidatorInfo) { <line31> if (cqv != null) { <line32> throw new IllegalArgumentException( <line33> ""Cannot specify the "" <line34> + MessageValidatorInfo.class <line35> + "" annotation twice on the class: ""); <line36> } <line37> cqv = ((MessageValidatorInfo) an).clazz(); <line38> } <line39> } <line40> if (schemaType == null) { <line41> throw new IllegalArgumentException( <line42> ""No "" + MessageType.class + "" annotation found on class: "" + schema); <line43> } <line44> if (cqd == null) { <line45> throw new IllegalArgumentException( <line46> ""No "" + MessageDeserializerInfo.class + "" annotation found on class: "" + schema); <line47> } <line48> if (cqv == null) { <line49> throw new IllegalArgumentException( <line50> ""No "" + MessageValidatorInfo.class + "" annotation found on class: "" + schema); <line51> } <line52> Class<? extends Message> prevSchema = typeToClass.put(schemaType, schema); <line53> if (prevSchema != null) { <line54> throw new IllegalArgumentException( <line55> ""Cannot have the "" <line56> + schemaType <line57> + "" schemaType defined on multiple classes: "" <line58> + schema <line59> + "", "" <line60> + prevSchema); <line61> } <line62> try { <line63> CustomMessageDeserializer cqdI = cqd.newInstance(); <line64> CustomMessageValidator cqvI = cqv.newInstance(); <line65> typeToCustomQueryBuilder.put(schemaType, cqdI); <line66> typeToCustomQueryValidator.put(schemaType, cqvI); <line67> } catch (InstantiationException | IllegalAccessException ex) { <line68> throw new RuntimeException(ex); <line69> } <line70> } <line71> } <line72> } <line73> "	 <line43>	No
public class A { <line0> private void recordStats( <line1> String matchingKey, <line2> String bucketingKey, <line3> String split, <line4> long start, <line5> String result, <line6> String operation, <line7> String label, <line8> Long changeNumber, <line9> Map<String, Object> attributes) { <line10> try { <line11> _impressionManager.track( <line12> new Impression( <line13> matchingKey, <line14> bucketingKey, <line15> split, <line16> result, <line17> System.currentTimeMillis(), <line18> label, <line19> changeNumber, <line20> attributes)); <line21> _metrics.time(operation, System.currentTimeMillis() - start); <line22> } catch (Throwable t) { <line23> } <line24> } <line25> } <line26> 	 <line23>	Yes
"public class A { <line0> @VisibleForTesting <line1> public synchronized void initialize( <line2> URI uri, <line3> org.apache.hadoop.conf.Configuration conf, <line4> @Nullable AlluxioConfiguration alluxioConfiguration) <line5> throws IOException { <line6> validateFsUri(uri); <line7> super.initialize(uri, conf); <line8> HadoopUtils.addSwiftCredentials(conf); <line9> setConf(conf); <line10> String authority = uri.getAuthority() == null ? ""/"" : uri.getAuthority(); <line11> mAlluxioHeader = getFsScheme(uri) + ""://"" + authority; <line12> mStatistics = statistics; <line13> mUri = URI.create(mAlluxioHeader); <line14> Map<String, Object> uriConfProperties = getConfigurationFromUri(uri); <line15> Map<String, Object> hadoopConfProperties = <line16> HadoopConfigurationUtils.getConfigurationFromHadoop(conf); <line17> AlluxioProperties alluxioProps = <line18> (alluxioConfiguration != null) <line19> ? alluxioConfiguration.copyProperties() <line20> : ConfigurationUtils.defaults(); <line21> alluxioProps.merge(hadoopConfProperties, Source.RUNTIME); <line22> alluxioProps.merge(uriConfProperties, Source.RUNTIME); <line23> mAlluxioConf = new InstancedConfiguration(alluxioProps); <line24> mAlluxioConf.validate(); <line25> if (mFileSystem != null) { <line26> return; <line27> } <line28> Subject subject = getHadoopSubject(); <line29> boolean enableUriValidation = <line30> (uri.getScheme() == null) || uri.getScheme().equals(Constants.SCHEME); <line31> mFileSystem = <line32> FileSystem.Factory.create( <line33> ClientContext.create(subject, mAlluxioConf) <line34> .setUriValidationEnabled(enableUriValidation)); <line35> } <line36> } <line37> "	 <line3>	No
"public class A { <line0> @Test <line1> public void createShard() throws Exception { <line2> List<RedisCreateInfo> createInfo = <line3> createInfo( <line4> Lists.newArrayList(""192.168.0.1:6379"", ""192.168.0.1:6380""), <line5> Lists.newArrayList(""192.168.0.2:6379"", ""192.168.0.2:6380"")); <line6> metaUpdate.createShard(clusterName, shardName, createInfo); <line7> ShardTbl shardTbl = shardService.find(clusterName, shardName); <line8> List<RedisTbl> keepers = <line9> redisService.findKeepersByDcClusterShard(activeDC, clusterName, shardName); <line10> List<RedisTbl> redisTbls = <line11> redisService.findRedisesByDcClusterShard(activeDC, clusterName, shardName); <line12> Assert.assertTrue( <line13> listEquals( <line14> Lists.newArrayList(""192.168.0.1:6379"", ""192.168.0.1:6380""), <line15> redisTbls.stream() <line16> .map( <line17> (redisTbl) -> { <line18> return redisTbl.getRedisIp() + "":"" + redisTbl.getRedisPort(); <line19> }) <line20> .collect(Collectors.toList()))); <line21> Assert.assertEquals(2, keepers.size()); <line22> } <line23> } <line24> "	 <line12>	Yes
public class A { <line0> @Override <line1> public DatabaseInfo parse(String jdbcUrl) { <line2> if (jdbcUrl == null) { <line3> return UnKnownDatabaseInfo.INSTANCE; <line4> } <line5> if (!jdbcUrl.startsWith(URL_PREFIX)) { <line6> return UnKnownDatabaseInfo.INSTANCE; <line7> } <line8> DatabaseInfo result = null; <line9> try { <line10> result = parse0(jdbcUrl); <line11> } catch (Exception e) { <line12> result = <line13> UnKnownDatabaseInfo.createUnknownDataBase( <line14> OracleConstants.ORACLE, OracleConstants.ORACLE_EXECUTE_QUERY, jdbcUrl); <line15> } <line16> return result; <line17> } <line18> } <line19> 	 <line11>	No
public class A { <line0> @Action() <line1> public Turnover $$() { <line2> turnoverAggregationService.aggregate(turnover); <line3> return turnover; <line4> } <line5> } <line6> 	 <line1>	No
"public class A { <line0> public boolean doThisSubclass( <line1> ExtendedHttpServletRequest extendedHttpServletRequest, HttpServletResponse response) <line2> throws Throwable { <line3> String method = ""doThisSubclass() ""; <line4> if (logger.isDebugEnabled()) { <line5> } <line6> String test = null; <line7> test = ""init""; <line8> if (!inited || initErrors) { <line9> if (logger.isErrorEnabled()) { <line10> } <line11> if (logger.isErrorEnabled()) { <line12> } <line13> String msg = fail(method, test); <line14> if (logger.isErrorEnabled()) { <line15> logger.error(msg); <line16> } <line17> throw new Exception(msg); <line18> } <line19> if (logger.isDebugEnabled()) { <line20> logger.debug(pass(method, test)); <line21> } <line22> test = ""HttpServletRequest""; <line23> if (!(extendedHttpServletRequest instanceof HttpServletRequest)) { <line24> String msg = fail(method, test); <line25> if (logger.isErrorEnabled()) { <line26> } <line27> throw new Exception(msg); <line28> } <line29> if (logger.isDebugEnabled()) { <line30> } <line31> if (logger.isDebugEnabled()) { <line32> } <line33> return false; <line34> } <line35> } <line36> "	 <line5>	Yes
public class A { <line0> private void doStartAutoTask() { <line1> if (scheduledFuture != null) { <line2> scheduledFuture.cancel(false); <line3> scheduledFuture = null; <line4> } <line5> int interval = autoCheckIntervalProperty.get(); <line6> if (interval <= 0) { <line7> return; <line8> } <line9> scheduledFuture = taskPool.scheduleAtFixedRate(this::runTask, interval, interval, timeUnit); <line10> } <line11> } <line12> 	 <line2>	No
public class A { <line0> private void sendBatch(List<QueuedRequest> requests) { <line1> StreamingGetDataRequest batchedRequest = flushToBatch(requests); <line2> synchronized (this) { <line3> for (QueuedRequest request : requests) { <line4> Verify.verify(pending.put(request.id, request.responseStream) == null); <line5> } <line6> try { <line7> send(batchedRequest); <line8> } catch (IllegalStateException e) { <line9> } <line10> } <line11> } <line12> } <line13> 	 <line4>	No
public class A { <line0> public void dropDatabase() { <line1> mongoDatabase().drop(); <line2> } <line3> } <line4> 	 <line2>	No
"public class A { <line0> private MethodCallExpr handleRuleUnit( <line1> VariableScope variableScope, <line2> ProcessMetaData metadata, <line3> RuleSetNode ruleSetNode, <line4> String nodeName, <line5> RuleSetNode.RuleType ruleType) { <line6> String unitName = ruleType.getName(); <line7> ProcessContextMetaModel processContext = <line8> new ProcessContextMetaModel(variableScope, contextClassLoader); <line9> RuleUnitDescription description; <line10> try { <line11> Class<?> unitClass = loadUnitClass(nodeName, unitName, metadata.getPackageName()); <line12> description = <line13> new ReflectiveRuleUnitDescription(null, (Class<? extends RuleUnitData>) unitClass); <line14> } catch (ClassNotFoundException e) { <line15> GeneratedRuleUnitDescription d = generateRuleUnitDescription(unitName, processContext); <line16> RuleUnitComponentFactoryImpl impl = <line17> (RuleUnitComponentFactoryImpl) RuleUnitComponentFactory.get(); <line18> impl.registerRuleUnitDescription(d); <line19> description = d; <line20> } <line21> RuleUnitHandler handler = <line22> new RuleUnitHandler(description, processContext, ruleSetNode, assignableChecker); <line23> Expression ruleUnitFactory = handler.invoke(); <line24> return new MethodCallExpr(""ruleUnit"") <line25> .addArgument(new StringLiteralExpr(ruleType.getName())) <line26> .addArgument(ruleUnitFactory); <line27> } <line28> } <line29> "	 <line15>	Yes
public class A { <line0> public static boolean writeFile(File file, byte[] content, boolean append) { <line1> try (FileChannel fileChannel = new FileOutputStream(file, append).getChannel()) { <line2> ByteBuffer buffer = ByteBuffer.wrap(content); <line3> fileChannel.write(buffer); <line4> return true; <line5> } catch (IOException ioe) { <line6> if (ioe.getMessage() != null) { <line7> String errMsg = ioe.getMessage(); <line8> if (NO_SPACE_CN.equals(errMsg) <line9> || NO_SPACE_EN.equals(errMsg) <line10> || errMsg.contains(DISK_QUATA_CN) <line11> || errMsg.contains(DISK_QUATA_EN)) { <line12> System.exit(0); <line13> } <line14> } <line15> } <line16> return false; <line17> } <line18> } <line19> 	 <line15>	No
"public class A { <line0> private SchedulerFactory createSchedulerFactory() throws SchedulerException { <line1> SchedulerFactory answer; <line2> Properties prop = loadProperties(); <line3> if (prop != null) { <line4> prop.put(""org.quartz.scheduler.skipUpdateCheck"", ""true""); <line5> prop.put(""org.terracotta.quartz.skipUpdateCheck"", ""true""); <line6> if (isPrefixInstanceName()) { <line7> String instName = createInstanceName(prop); <line8> prop.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, instName); <line9> } <line10> if (isInterruptJobsOnShutdown()) { <line11> prop.setProperty(StdSchedulerFactory.PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN, ""true""); <line12> } <line13> if (enableJmx && !prop.containsKey(""org.quartz.scheduler.jmx.export"")) { <line14> prop.put(""org.quartz.scheduler.jmx.export"", ""true""); <line15> LOG.info( <line16> ""Setting org.quartz.scheduler.jmx.export=true to ensure QuartzScheduler(s) will be"" <line17> + "" enlisted in JMX.""); <line18> } <line19> answer = new StdSchedulerFactory(prop); <line20> } else { <line21> InputStream is = <line22> StdSchedulerFactory.class <line23> .getClassLoader() <line24> .getResourceAsStream(""org/quartz/quartz.properties""); <line25> if (is == null) { <line26> throw new SchedulerException( <line27> ""Quartz properties file not found in classpath: org/quartz/quartz.properties""); <line28> } <line29> prop = new Properties(); <line30> try { <line31> prop.load(is); <line32> } catch (IOException e) { <line33> throw new SchedulerException( <line34> ""Error loading Quartz properties file from classpath: org/quartz/quartz.properties"", e); <line35> } finally { <line36> IOHelper.close(is); <line37> } <line38> if (isPrefixInstanceName()) { <line39> String instName = createInstanceName(prop); <line40> prop.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, instName); <line41> } <line42> prop.put(""org.quartz.scheduler.skipUpdateCheck"", ""true""); <line43> prop.put(""org.terracotta.quartz.skipUpdateCheck"", ""true""); <line44> if (isInterruptJobsOnShutdown()) { <line45> prop.setProperty(StdSchedulerFactory.PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN, ""true""); <line46> } <line47> if (enableJmx && !prop.containsKey(""org.quartz.scheduler.jmx.export"")) { <line48> prop.put(""org.quartz.scheduler.jmx.export"", ""true""); <line49> } <line50> answer = new StdSchedulerFactory(prop); <line51> } <line52> if (LOG.isDebugEnabled()) { <line53> String name = prop.getProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME); <line54> } <line55> return answer; <line56> } <line57> } <line58> "	 <line32>	No
public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> getAPIVersion_result result = new getAPIVersion_result(); <line4> if (e <line5> instanceof <line6> org.apache.airavata.service.profile.groupmanager.cpi.exception <line7> .GroupManagerServiceException) { <line8> result.gse = <line9> (org.apache.airavata.service.profile.groupmanager.cpi.exception <line10> .GroupManagerServiceException) <line11> e; <line12> result.setGseIsSet(true); <line13> msg = result; <line14> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line15> fb.close(); <line16> return; <line17> } else if (e instanceof org.apache.thrift.TApplicationException) { <line18> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line19> msg = (org.apache.thrift.TApplicationException) e; <line20> } else { <line21> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line22> msg = <line23> new org.apache.thrift.TApplicationException( <line24> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line25> } <line26> try { <line27> fcall.sendResponse(fb, msg, msgType, seqid); <line28> } catch (java.lang.Exception ex) { <line29> fb.close(); <line30> } <line31> } <line32> } <line33> 	 <line5>	No
public class A { <line0> private void putApnsClientForVariantID(final String variantID, final ApnsClient apnsClient) { <line1> final ApnsClient client = apnsClientExpiringMap.putIfAbsent(variantID, apnsClient); <line2> if (client != null) { <line3> tearDownApnsHttp2Connection(apnsClient); <line4> } <line5> } <line6> } <line7> 	 <line4>	No
public class A { <line0> private BridgeApiLockStateRequestDto getBridgeApiLockStateRequestDto(HttpServletRequest request) { <line1> String requestContent = null; <line2> try { <line3> requestContent = <line4> request.getReader().lines().collect(Collectors.joining(System.lineSeparator())); <line5> BridgeApiLockStateRequestDto bridgeApiLockStateRequestDto = <line6> gson.fromJson(requestContent, BridgeApiLockStateRequestDto.class); <line7> if (bridgeApiLockStateRequestDto.getNukiId() != 0) { <line8> return bridgeApiLockStateRequestDto; <line9> } else { <line10> } <line11> } catch (IOException e) { <line12> } catch (Exception e) { <line13> } <line14> return null; <line15> } <line16> } <line17> 	 <line8>	Yes
"public class A { <line0> @Override <line1> public void store(String id, SessionData data) throws Exception { <line2> if (!isStarted()) throw new IllegalStateException(""Not started""); <line3> if (data == null) return; <line4> long lastSave = data.getLastSaved(); <line5> long savePeriodMs = (_savePeriodSec <= 0 ? 0 : TimeUnit.SECONDS.toMillis(_savePeriodSec)); <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> if (data.isDirty() <line9> || (lastSave <= 0) <line10> || (data.isMetaDataDirty() && ((System.currentTimeMillis() - lastSave) >= savePeriodMs))) { <line11> data.setLastSaved(System.currentTimeMillis()); <line12> final Result<Object> result = new Result<>(); <line13> Runnable r = <line14> () -> { <line15> try { <line16> doStore(id, data, lastSave); <line17> data.clean(); <line18> } catch (Exception e) { <line19> data.setLastSaved(lastSave); <line20> result.setException(e); <line21> } <line22> }; <line23> _context.run(r); <line24> result.throwIfException(); <line25> } <line26> } <line27> } <line28> "	 <line7>	Yes
public class A { <line0> private boolean reloadStaticConfFromFile() { <line1> final StaticConfiguration staticConfFromFile = loadStaticConfFromFile(); <line2> if (staticConfFromFile != null) { <line3> staticConf = staticConfFromFile; <line4> return true; <line5> } else { <line6> } <line7> return false; <line8> } <line9> } <line10> 	 <line2>	No
"public class A { <line0> public StudyResponse studyList(String authorization, String applicationId) <line1> throws OrchestrationException { <line2> LOGGER.entry(""begin studyList()""); <line3> StudyResponse studyResponse = new StudyResponse(); <line4> try { <line5> studyResponse = studyMetaDataDao.studyList(authorization, applicationId); <line6> } catch (Exception e) { <line7> } <line8> LOGGER.exit(""studyList() :: Ends""); <line9> return studyResponse; <line10> } <line11> } <line12> "	 <line5>	No
public class A { <line0> @Override <line1> public boolean handleConnection(PeerConnection connection) { <line2> Peer peer = connection.getRemotePeer(); <line3> Message firstMessage = null; <line4> try { <line5> firstMessage = connection.readMessage(handshakeTimeout.toMillis()); <line6> } catch (IOException e) { <line7> if (LOGGER.isDebugEnabled()) { <line8> } <line9> } <line10> if (firstMessage != null) { <line11> if (Handshake.class.equals(firstMessage.getClass())) { <line12> Handshake peerHandshake = (Handshake) firstMessage; <line13> TorrentId torrentId = peerHandshake.getTorrentId(); <line14> Optional<TorrentDescriptor> descriptorOptional = torrentRegistry.getDescriptor(torrentId); <line15> if (torrentRegistry.getTorrentIds().contains(torrentId) <line16> && (!descriptorOptional.isPresent() || descriptorOptional.get().isActive())) { <line17> Handshake handshake = handshakeFactory.createHandshake(torrentId); <line18> handshakeHandlers.forEach(handler -> handler.processOutgoingHandshake(handshake)); <line19> try { <line20> connection.postMessage(handshake); <line21> } catch (IOException e) { <line22> if (LOGGER.isDebugEnabled()) { <line23> } <line24> return false; <line25> } <line26> connection.setTorrentId(torrentId); <line27> handshakeHandlers.forEach( <line28> handler -> <line29> handler.processIncomingHandshake( <line30> new WriteOnlyPeerConnection(connection), peerHandshake)); <line31> return true; <line32> } <line33> } else { <line34> } <line35> } <line36> return false; <line37> } <line38> } <line39> 	 <line12>	No
"public class A { <line0> @Test <line1> public void useMultipleRepositories() { <line2> personRepository.save(new Person(""Frodo"", ""Baggins"")); <line3> personRepository.save(new Person(""Bilbo"", ""Baggins"")); <line4> for (var person : personRepository.findAll()) { <line5> } <line6> treasureRepository.deleteAll(); <line7> treasureRepository.save(new Treasure(""Sting"", ""Made by the Elves"")); <line8> treasureRepository.save(new Treasure(""Sauron's ring"", ""One ring to rule them all"")); <line9> for (var treasure : treasureRepository.findAll()) { <line10> } <line11> } <line12> } <line13> "	 <line10>	Yes
"public class A { <line0> public void updateRemoteAngularObject(String name, String noteId, String paragraphId, Object o) { <line1> Client client = null; <line2> try { <line3> client = getClient(); <line4> } catch (NullPointerException e) { <line5> return; <line6> } catch (Exception e) { <line7> logger.error(""Can't update angular object"", e); <line8> } <line9> boolean broken = false; <line10> try { <line11> Gson gson = new Gson(); <line12> client.angularObjectUpdate(name, noteId, paragraphId, gson.toJson(o)); <line13> } catch (TException e) { <line14> broken = true; <line15> } catch (NullPointerException e) { <line16> return; <line17> } finally { <line18> if (client != null) { <line19> releaseClient(client, broken); <line20> } <line21> } <line22> } <line23> } <line24> "	 <line16>	Yes
"public class A { <line0> private void validateAPIKeyRestrictions(JWTClaimsSet payload, MessageContext synCtx) <line1> throws APISecurityException { <line2> org.apache.axis2.context.MessageContext axis2MessageContext = <line3> ((Axis2MessageContext) synCtx).getAxis2MessageContext(); <line4> String permittedIPList = null; <line5> if (payload.getClaim(APIConstants.JwtTokenConstants.PERMITTED_IP) != null) { <line6> permittedIPList = (String) payload.getClaim(APIConstants.JwtTokenConstants.PERMITTED_IP); <line7> } <line8> if (StringUtils.isNotEmpty(permittedIPList)) { <line9> String clientIP = GatewayUtils.getIp(axis2MessageContext); <line10> if (StringUtils.isNotEmpty(clientIP)) { <line11> for (String restrictedIP : permittedIPList.split("","")) { <line12> if (APIUtil.isIpInNetwork(clientIP, restrictedIP.trim())) { <line13> return; <line14> } <line15> } <line16> if (log.isDebugEnabled()) { <line17> String apiContext = (String) synCtx.getProperty(RESTConstants.REST_API_CONTEXT); <line18> String apiVersion = (String) synCtx.getProperty(RESTConstants.SYNAPSE_REST_API_VERSION); <line19> if (StringUtils.isNotEmpty(clientIP)) { <line20> } <line21> } <line22> throw new APISecurityException( <line23> APISecurityConstants.API_AUTH_FORBIDDEN, ""Access forbidden for the invocations""); <line24> } <line25> } <line26> String permittedRefererList = null; <line27> if (payload.getClaim(APIConstants.JwtTokenConstants.PERMITTED_REFERER) != null) { <line28> permittedRefererList = <line29> (String) payload.getClaim(APIConstants.JwtTokenConstants.PERMITTED_REFERER); <line30> } <line31> if (StringUtils.isNotEmpty(permittedRefererList)) { <line32> TreeMap<String, String> transportHeaderMap = <line33> (TreeMap<String, String>) <line34> axis2MessageContext.getProperty( <line35> org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS); <line36> if (transportHeaderMap != null) { <line37> String referer = transportHeaderMap.get(""Referer""); <line38> if (StringUtils.isNotEmpty(referer)) { <line39> for (String restrictedReferer : permittedRefererList.split("","")) { <line40> String restrictedRefererRegExp = restrictedReferer.trim().replace(""*"", ""[^ ]*""); <line41> if (referer.matches(restrictedRefererRegExp)) { <line42> return; <line43> } <line44> } <line45> if (log.isDebugEnabled()) { <line46> String apiContext = (String) synCtx.getProperty(RESTConstants.REST_API_CONTEXT); <line47> String apiVersion = (String) synCtx.getProperty(RESTConstants.SYNAPSE_REST_API_VERSION); <line48> if (StringUtils.isNotEmpty(referer)) { <line49> } <line50> } <line51> throw new APISecurityException( <line52> APISecurityConstants.API_AUTH_FORBIDDEN, ""Access forbidden for the invocations""); <line53> } else { <line54> throw new APISecurityException( <line55> APISecurityConstants.API_AUTH_FORBIDDEN, ""Access forbidden for the invocations""); <line56> } <line57> } <line58> } <line59> } <line60> } <line61> "	 <line49>	Yes
public class A { <line0> @Override <line1> @DB <line2> public boolean stop() { <line3> if (s_logger.isInfoEnabled()) { <line4> } <line5> if (_mshostId != null) { <line6> final ManagementServerHostVO mshost = _mshostDao.findByMsid(_msId); <line7> mshost.setState(ManagementServerHost.State.Down); <line8> _mshostDao.update(_mshostId, mshost); <line9> } <line10> _heartbeatScheduler.shutdownNow(); <line11> _executor.shutdownNow(); <line12> try { <line13> _heartbeatScheduler.awaitTermination(EXECUTOR_SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS); <line14> _executor.awaitTermination(EXECUTOR_SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS); <line15> } catch (final InterruptedException e) { <line16> } <line17> if (s_logger.isInfoEnabled()) { <line18> } <line19> return true; <line20> } <line21> } <line22> 	 <line18>	Yes
"public class A { <line0> @BeforeClass <line1> public static void beforeClass() throws Exception { <line2> ClassUtil.addClasspath(new File(HBaseMetadataTestCase.SANDBOX_TEST_DATA).getAbsolutePath()); <line3> System.setProperty(""hdp.version"", ""2.2.0.0-2041""); <line4> } <line5> } <line6> "	 <line1>	No
public class A { <line0> public XParagraphCursor[] getEndMark() { <line1> try { <line2> XTextRange range = bookmark.getTextCursor(); <line3> if (range == null || !hasInsertMarks) { <line4> return new XParagraphCursor[] {}; <line5> } <line6> XParagraphCursor[] cursor = new XParagraphCursor[2]; <line7> XText text = range.getText(); <line8> cursor[0] = UNO.XParagraphCursor(text.createTextCursorByRange(range.getEnd())); <line9> cursor[1] = UNO.XParagraphCursor(text.createTextCursorByRange(cursor[0])); <line10> cursor[0].goLeft(getStartMarkLength(), false); <line11> return cursor; <line12> } catch (UnoHelperException e) { <line13> return new XParagraphCursor[] {}; <line14> } <line15> } <line16> } <line17> 	 <line13>	Yes
"public class A { <line0> protected long parseRfc3164Time(String ts) { <line1> DateTime now = DateTime.now(); <line2> int year = now.getYear(); <line3> ts = TWO_SPACES.matcher(ts).replaceFirst("" ""); <line4> DateTime date; <line5> try { <line6> date = rfc3164Format.parseDateTime(ts); <line7> } catch (IllegalArgumentException e) { <line8> return 0; <line9> } <line10> if (date != null) { <line11> DateTime fixed = date.withYear(year); <line12> if (fixed.isAfter(now) && fixed.minusMonths(1).isAfter(now)) { <line13> fixed = date.minusYears(1); <line14> } else if (fixed.isBefore(now) && fixed.plusMonths(1).isBefore(now)) { <line15> fixed = date.plusYears(1); <line16> } <line17> date = fixed; <line18> } <line19> if (date == null) { <line20> return 0; <line21> } <line22> return date.getMillis(); <line23> } <line24> } <line25> "	 <line7>	No
"public class A { <line0> @Override <line1> public boolean login() throws LoginException { <line2> try { <line3> Callback[] callbacks = new Callback[] {new NameCallback(""Username"")}; <line4> callbackHandler.handle(callbacks); <line5> String username = ((NameCallback) callbacks[0]).getName(); <line6> if (username != null) { <line7> OrganizationService service = <line8> (OrganizationService) <line9> getContainer().getComponentInstanceOfType(OrganizationService.class); <line10> try { <line11> begin(service); <line12> UserHandler uHandler = service.getUserHandler(); <line13> User user = uHandler.findUserByName(username, UserStatus.ANY); <line14> if (user == null) { <line15> } else if (user instanceof UserImpl && !((UserImpl) user).isEnabled()) { <line16> HttpServletRequest request = getCurrentHttpServletRequest(); <line17> if (request != null) { <line18> request.setAttribute(DISABLED_USER_NAME, username); <line19> } <line20> throw new LoginException(""Can't authenticate. user "" + username + "" is disabled""); <line21> } <line22> } finally { <line23> end(service); <line24> } <line25> } else { <line26> } <line27> return true; <line28> } catch (final Exception e) { <line29> throw new LoginException(e.getMessage()); <line30> } <line31> } <line32> } <line33> "	 <line26>	Yes
public class A { <line0> @Override <line1> public Connection getConnection() { <line2> Connection conn = null; <line3> try { <line4> if (_dataSource != null) { <line5> conn = _dataSource.getConnection(); <line6> if (conn != null) { <line7> } <line8> } <line9> } catch (Exception e) { <line10> } <line11> return conn; <line12> } <line13> } <line14> 	 <line10>	Yes
"public class A { <line0> @Override <line1> public void link(String linkPath, String targetPath, boolean symbolic) throws IOException { <line2> if (!isOpen()) { <line3> throw new IOException( <line4> ""link("" <line5> + linkPath <line6> + "" => "" <line7> + targetPath <line8> + "")[symbolic="" <line9> + symbolic <line10> + ""] client is closed""); <line11> } <line12> if (log.isDebugEnabled()) { <line13> } <line14> Buffer buffer = new ByteArrayBuffer(linkPath.length() + targetPath.length() + Long.SIZE, false); <line15> int version = getVersion(); <line16> if (version < SftpConstants.SFTP_V6) { <line17> if (!symbolic) { <line18> throw new UnsupportedOperationException(""Hard links are not supported in sftp v"" + version); <line19> } <line20> buffer = putReferencedName(SftpConstants.SSH_FXP_SYMLINK, buffer, targetPath, 0); <line21> buffer = putReferencedName(SftpConstants.SSH_FXP_SYMLINK, buffer, linkPath, 1); <line22> checkCommandStatus(SftpConstants.SSH_FXP_SYMLINK, buffer); <line23> } else { <line24> buffer = putReferencedName(SftpConstants.SSH_FXP_SYMLINK, buffer, targetPath, 0); <line25> buffer = putReferencedName(SftpConstants.SSH_FXP_SYMLINK, buffer, linkPath, 1); <line26> buffer.putBoolean(symbolic); <line27> checkCommandStatus(SftpConstants.SSH_FXP_LINK, buffer); <line28> } <line29> } <line30> } <line31> "	 <line13>	Yes
public class A { <line0> private void distribute(Shuffling shuffling) { <line1> if (shuffling.getRecipientPublicKeys().length != shuffling.getParticipantCount()) { <line2> cancelBy(shuffling, getLastParticipant(shuffling.getId())); <line3> return; <line4> } <line5> for (byte[] recipientPublicKey : shuffling.getRecipientPublicKeys()) { <line6> byte[] publicKey = <line7> accountService.getPublicKeyByteArray(AccountService.getId(recipientPublicKey)); <line8> if (publicKey != null && !Arrays.equals(publicKey, recipientPublicKey)) { <line9> cancelBy(shuffling, getLastParticipant(shuffling.getId())); <line10> return; <line11> } <line12> } <line13> LedgerEvent event = LedgerEvent.SHUFFLING_DISTRIBUTION; <line14> try (DbIterator<ShufflingParticipant> participants = getParticipants(shuffling.getId())) { <line15> for (ShufflingParticipant participant : participants) { <line16> Account participantAccount = accountService.getAccount(participant.getAccountId()); <line17> shuffling <line18> .getHoldingType() <line19> .addToBalance( <line20> participantAccount, <line21> event, <line22> shuffling.getId(), <line23> shuffling.getHoldingId(), <line24> -shuffling.getAmount()); <line25> if (shuffling.getHoldingType() != HoldingType.APL) { <line26> accountService.addToBalanceATM( <line27> participantAccount, <line28> event, <line29> shuffling.getId(), <line30> -blockchainConfig.getShufflingDepositAtm()); <line31> } <line32> } <line33> } <line34> for (byte[] recipientPublicKey : shuffling.getRecipientPublicKeys()) { <line35> long recipientId = AccountService.getId(recipientPublicKey); <line36> Account recipientAccount = accountService.createAccount(recipientId); <line37> accountPublicKeyService.apply(recipientAccount, recipientPublicKey); <line38> shuffling <line39> .getHoldingType() <line40> .addToBalanceAndUnconfirmedBalance( <line41> recipientAccount, <line42> event, <line43> shuffling.getId(), <line44> shuffling.getHoldingId(), <line45> shuffling.getAmount()); <line46> if (shuffling.getHoldingType() != HoldingType.APL) { <line47> accountService.addToBalanceAndUnconfirmedBalanceATM( <line48> recipientAccount, event, shuffling.getId(), blockchainConfig.getShufflingDepositAtm()); <line49> } <line50> } <line51> setStage(shuffling, ShufflingStage.DONE, 0, (short) 0); <line52> updateHeightAndInsert(shuffling); <line53> shufflingListeners.notify(shuffling, ShufflingEvent.SHUFFLING_DONE); <line54> if (deleteFinished) { <line55> delete(shuffling); <line56> } <line57> } <line58> } <line59> 	 <line9>	No
public class A { <line0> @Override <line1> public void resolveLinks(ContentRenderizationInfo renderizationInfo, RequestContext reqCtx) { <line2> if (null == renderizationInfo) { <line3> return; <line4> } <line5> try { <line6> String finalRenderedContent = <line7> this.getLinkResolverManager() <line8> .resolveLinks( <line9> renderizationInfo.getCachedRenderedContent(), <line10> renderizationInfo.getContentId(), <line11> reqCtx); <line12> renderizationInfo.setRenderedContent(finalRenderedContent); <line13> } catch (Throwable t) { <line14> } <line15> } <line16> } <line17> 	 <line2>	No
public class A { <line0> protected synchronized void addRecord(String id) throws IOException { <line1> writer.append(id); <line2> writer.newLine(); <line3> writer.flush(); <line4> } <line5> } <line6> 	 <line0>	No
"public class A { <line0> private static List getVSTSWebhooks(final VSTSWebhookType webhookType) throws ServerException { <line1> Properties webhooksProperties = getProperties(VSTS_WEBHOOKS_PROPERTIES_FILENAME); <line2> Set<String> keySet = webhooksProperties.stringPropertyNames(); <line3> if (webhookType == WORK_ITEM_CREATED_WEBHOOK) { <line4> List<WorkItemCreatedWebhook> wicWebhooks = new ArrayList<>(); <line5> keySet.stream() <line6> .forEach( <line7> key -> { <line8> String value = webhooksProperties.getProperty(key); <line9> if (!isNullOrEmpty(value)) { <line10> String[] valueSplit = value.split("",""); <line11> if (valueSplit.length == 7 && valueSplit[0].equals(webhookType.toString())) { <line12> WorkItemCreatedWebhook webhook = <line13> new WorkItemCreatedWebhook( <line14> valueSplit[1], <line15> valueSplit[2], <line16> valueSplit[3], <line17> valueSplit[4], <line18> Pair.of(valueSplit[5], valueSplit[6])); <line19> wicWebhooks.add(webhook); <line20> } <line21> } <line22> }); <line23> return wicWebhooks; <line24> } <line25> if (webhookType == PULL_REQUEST_UPDATED_WEBHOOK) { <line26> List<PullRequestUpdatedWebhook> pruWebhooks = new ArrayList<>(); <line27> keySet.stream() <line28> .forEach( <line29> key -> { <line30> String value = webhooksProperties.getProperty(key); <line31> if (!isNullOrEmpty(value)) { <line32> String[] valueSplit = value.split("",""); <line33> if (valueSplit.length >= 7 && valueSplit[0].equals(webhookType.toString())) { <line34> final String[] factoriesIDs = <line35> (valueSplit.length == 8 ? valueSplit[7].split("";"") : new String[0]); <line36> PullRequestUpdatedWebhook webhook = <line37> new PullRequestUpdatedWebhook( <line38> valueSplit[1], <line39> valueSplit[2], <line40> valueSplit[3], <line41> valueSplit[4], <line42> Pair.of(valueSplit[5], valueSplit[6]), <line43> factoriesIDs); <line44> pruWebhooks.add(webhook); <line45> } <line46> } <line47> }); <line48> return pruWebhooks; <line49> } <line50> return new ArrayList(); <line51> } <line52> } <line53> "	 <line45>	Yes
public class A { <line0> public void modelReload(CatalogModel newModel) { <line1> for (ICatalogModelListener listener : getListeners()) { <line2> listener.modelReload(newModel); <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> void addToken(String fiwareService, String fiwareServicePath, String token) { <line1> Token tokenObj = new Token(fiwareService, fiwareServicePath, token, liveTime); <line2> String key = tokenObj.getIndexKey(); <line3> if (tokenCache.containsKey(key)) { <line4> tokenObj = tokenCache.get(key); <line5> tokenObj.renew(); <line6> tokenObj.setToken(token); <line7> } else { <line8> tokenCache.put(key, tokenObj); <line9> } <line10> } <line11> } <line12> 	 <line2>	No
public class A { <line0> protected void deactivate(ComponentContext cc) { <line1> cleaner.shutdown(); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void update(final short serviceType) { <line2> final TransportMetadata transportMetadata = ServerContext.getTransportMetadata(); <line3> if (transportMetadata == null) { <line4> return; <line5> } <line6> final PingSession pingSession = pingSessionRegistry.get(transportMetadata.getTransportId()); <line7> if (pingSession == null) { <line8> return; <line9> } <line10> pingSession.setServiceType(serviceType); <line11> if (logger.isDebugEnabled()) { <line12> } <line13> if (!pingSession.isUpdated()) { <line14> lifecycleListener.connect(pingSession); <line15> pingSession.setUpdated(true); <line16> } <line17> } <line18> } <line19> 	 <line12>	Yes
public class A { <line0> @Override <line1> public Connection call() throws Exception { <line2> return createConnection(settings, jdbcUrl, user, pass, kerberos, d); <line3> } <line4> } <line5> 	 <line0>	No
public class A { <line0> private void actionRejectRecommendation( <line1> AnnotationActionHandler aActionHandler, <line2> AnnotatorState aState, <line3> AjaxRequestTarget aTarget, <line4> CAS aCas, <line5> VID aVID) <line6> throws AnnotationException, IOException { <line7> Predictions predictions = <line8> recommendationService.getPredictions(aState.getUser(), aState.getProject()); <line9> SourceDocument document = aState.getDocument(); <line10> VID recommendationVID = VID.parse(aVID.getExtensionPayload()); <line11> Optional<AnnotationSuggestion> oPrediction = <line12> predictions.getPredictionByVID(document, recommendationVID); <line13> if (!oPrediction.isPresent()) { <line14> aTarget.addChildren(aTarget.getPage(), IFeedback.class); <line15> return; <line16> } <line17> AnnotationSuggestion suggestion = oPrediction.get(); <line18> Recommender recommender = recommendationService.getRecommender(recommendationVID.getId()); <line19> AnnotationLayer layer = annotationService.getLayer(recommendationVID.getLayerId()); <line20> AnnotationFeature feature = recommender.getFeature(); <line21> suggestion.hide(FLAG_TRANSIENT_REJECTED); <line22> aTarget <line23> .getPage() <line24> .send( <line25> aTarget.getPage(), <line26> Broadcast.BREADTH, <line27> new AjaxRecommendationRejectedEvent(aTarget, aState, aVID)); <line28> if (suggestion instanceof SpanSuggestion) { <line29> SpanSuggestion spanSuggestion = (SpanSuggestion) suggestion; <line30> learningRecordService.logRecord( <line31> document, <line32> aState.getUser().getUsername(), <line33> spanSuggestion, <line34> layer, <line35> feature, <line36> REJECTED, <line37> MAIN_EDITOR); <line38> applicationEventPublisher.publishEvent( <line39> new RecommendationRejectedEvent( <line40> this, <line41> document, <line42> aState.getUser().getUsername(), <line43> spanSuggestion.getBegin(), <line44> spanSuggestion.getEnd(), <line45> spanSuggestion.getCoveredText(), <line46> feature, <line47> spanSuggestion.getLabel())); <line48> } else if (suggestion instanceof RelationSuggestion) { <line49> RelationSuggestion relationSuggestion = (RelationSuggestion) suggestion; <line50> } <line51> Page page = aTarget.getPage(); <line52> page.send(page, Broadcast.BREADTH, new SelectionChangedEvent(aTarget)); <line53> page.send( <line54> page, <line55> Broadcast.BREADTH, <line56> new AjaxRecommendationRejectedEvent(aTarget, aState, recommendationVID)); <line57> } <line58> } <line59> 	 <line14>	Yes
"public class A { <line0> @Transactional <line1> public Paymentheader createDirectBankPayment( <line2> Paymentheader paymentheader, <line3> CVoucherHeader voucherHeader, <line4> CVoucherHeader billVhId, <line5> CommonBean commonBean, <line6> List<VoucherDetails> billDetailslist, <line7> List<VoucherDetails> subLedgerlist, <line8> WorkflowBean workflowBean) { <line9> try { <line10> voucherHeader = <line11> createVoucherAndledger(voucherHeader, commonBean, billDetailslist, subLedgerlist); <line12> paymentheader = <line13> paymentService.createPaymentHeader( <line14> voucherHeader, <line15> Integer.valueOf(commonBean.getAccountNumberId()), <line16> commonBean.getModeOfPayment(), <line17> commonBean.getAmount()); <line18> if (commonBean.getDocumentId() != null) <line19> billVhId = <line20> (CVoucherHeader) <line21> persistenceService <line22> .getSession() <line23> .load(CVoucherHeader.class, commonBean.getDocumentId()); <line24> createMiscBillDetail(billVhId, commonBean, voucherHeader); <line25> paymentheader = sendForApproval(paymentheader, workflowBean); <line26> } catch (final ValidationException e) { <line27> final List<ValidationError> errors = new ArrayList<ValidationError>(); <line28> errors.add(new ValidationError(""exp"", e.getErrors().get(0).getMessage())); <line29> throw new ValidationException(errors); <line30> } catch (final Exception e) { <line31> final List<ValidationError> errors = new ArrayList<ValidationError>(); <line32> errors.add(new ValidationError(""exp"", e.getMessage())); <line33> throw new ValidationException(errors); <line34> } <line35> return paymentheader; <line36> } <line37> } <line38> "	 <line32>	No
"public class A { <line0> private List<Object> selectTblMapps(JSONObject jObj) throws Exception { <line1> List<Object> selectDataList = new ArrayList<Object>(); <line2> JSONObject serverInfoObj = (JSONObject) jObj.get(ProtocolID.SERVER_INFO); <line3> List<HashMap<String, String>> objTable_Info = <line4> (List<HashMap<String, String>>) jObj.get(ProtocolID.TABLE_INFO); <line5> SqlSessionFactory sqlSessionFactory = null; <line6> sqlSessionFactory = SqlSessionManager.getInstance(); <line7> String poolName = <line8> """" <line9> + serverInfoObj.get(ProtocolID.SERVER_IP) <line10> + ""_"" <line11> + serverInfoObj.get(ProtocolID.DATABASE_NAME) <line12> + ""_"" <line13> + serverInfoObj.get(ProtocolID.SERVER_PORT); <line14> Connection connDB = null; <line15> SqlSession sessDB = null; <line16> try { <line17> SocketExt.setupDriverPool(serverInfoObj, poolName); <line18> connDB = DriverManager.getConnection(""jdbc:apache:commons:dbcp:"" + poolName); <line19> sessDB = sqlSessionFactory.openSession(connDB); <line20> if (objTable_Info.size() > 0) { <line21> HashMap hp = new HashMap(); <line22> String strDatabaseName = objTable_Info.get(0).get(ProtocolID.DATABASE_NAME).toString(); <line23> String strTableName = objTable_Info.get(0).get(ProtocolID.TABLE_NAME).toString(); <line24> String strTableSchema = objTable_Info.get(0).get(ProtocolID.TABLE_SCHEMA).toString(); <line25> hp.put(ProtocolID.DATABASE_NAME, strDatabaseName); <line26> hp.put(ProtocolID.TABLE_NAME, strTableName); <line27> hp.put(ProtocolID.TABLE_SCHEMA, strTableSchema); <line28> selectDataList = sessDB.selectList(""app.selectTblMapps"", hp); <line29> hp = null; <line30> } <line31> sessDB.close(); <line32> connDB.close(); <line33> } catch (Exception e) { <line34> throw e; <line35> } finally { <line36> if (sessDB != null) sessDB.close(); <line37> if (connDB != null) connDB.close(); <line38> } <line39> return selectDataList; <line40> } <line41> } <line42> "	 <line25>	No
public class A { <line0> public static void bind(@Nonnull String xid) { <line1> if (StringUtils.isBlank(xid)) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> unbind(); <line5> } else { <line6> MDC.put(MDC_KEY_XID, xid); <line7> if (LOGGER.isDebugEnabled()) { <line8> } <line9> CONTEXT_HOLDER.put(KEY_XID, xid); <line10> } <line11> } <line12> } <line13> 	 <line3>	Yes
"public class A { <line0> @Path(""/getShouldSucceed"") <line1> @POST <line2> public void getShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.GET); <line4> Region out = <line5> template.requestBodyAndHeader(uri, null, OpenstackConstants.ID, REGION_ID, Region.class); <line6> assertNotNull(out); <line7> assertEquals(REGION_ID, out.getId()); <line8> assertEquals(REGION_DESCRIPTION, out.getDescription()); <line9> assertEquals(REGION_PARENTREGIONID, out.getParentRegionId()); <line10> } <line11> } <line12> "	 <line9>	No
"public class A { <line0> public void emitRequiredImport(String requiredImport) { <line1> requiredImports.add('""' + requiredImport + '""'); <line2> } <line3> } <line4> "	 <line1>	Yes
"public class A { <line0> private void debug( <line1> CSpaceResource res, <line2> Authentication authToken, <line3> Serializable objectIdId, <line4> String objectIdType, <line5> Permission perm) { <line6> if (log.isTraceEnabled() == true) { <line7> String resourceTarget = <line8> ""["" <line9> + res.getId() <line10> + ""]"" <line11> + "" | "" <line12> + ""["" <line13> + ""objectIdId: "" <line14> + objectIdType <line15> + ""("" <line16> + objectIdId <line17> + "")]""; <line18> System.out.println(""PERMISSION CHECK FOR: "" + resourceTarget); <line19> System.out.println( <line20> ""\tPrincipal: "" + authToken.getName() + ""\tTenant ID: "" + res.getTenantId()); <line21> System.out.println(""\tRoles: "" + authToken.getAuthorities()); <line22> System.out.println( <line23> ""\tPermission Mask: "" + perm.getMask() + "" - Permission Pattern: "" + perm.getPattern()); <line24> System.out.println(""""); <line25> } <line26> } <line27> } <line28> "	 <line7>	Yes
"public class A { <line0> public void uploadAssetGroupTagCompliance(List<String> assetGroups) throws Exception { <line1> List<Map<String, Object>> docs = new ArrayList<>(); <line2> for (String ag : assetGroups) { <line3> try { <line4> Map<String, Object> doc = AssetGroupUtil.fetchTaggingSummary(COMP_API_URL, ag, getToken()); <line5> if (!doc.isEmpty()) { <line6> doc.put(""ag"", ag); <line7> doc.put(""date"", CURR_DATE); <line8> doc.put(""@id"", Util.getUniqueID(ag + CURR_DATE)); <line9> docs.add(doc); <line10> } <line11> } catch (Exception e) { <line12> Map<String, String> errorMap = new HashMap<>(); <line13> errorMap.put(ERROR, ""Exception in uploadAssetGroupTagCompliance for Asset Group"" + ag); <line14> errorMap.put(ERROR_TYPE, WARN); <line15> errorMap.put(EXCEPTION, e.getMessage()); <line16> synchronized (errorList) { <line17> errorList.add(errorMap); <line18> } <line19> } <line20> } <line21> ESManager.uploadData(AG_STATS, ""tagcompliance"", docs, ""@id"", false); <line22> } <line23> } <line24> "	 <line22>	Yes
"public class A { <line0> public boolean transitionToFailed(Throwable throwable) { <line1> requireNonNull(throwable, ""throwable is null""); <line2> failureCause.compareAndSet(null, Failures.toFailure(throwable)); <line3> boolean failed = stageState.setIf(FAILED, currentState -> !currentState.isDone()); <line4> if (failed) { <line5> } else { <line6> } <line7> return failed; <line8> } <line9> } <line10> "	 <line9>	No
public class A { <line0> @Override <line1> public synchronized void stop() { <line2> started = false; <line3> cachePersistenceThreadPoolTaskExecutor.shutdown(); <line4> while (!toBePersisted.isEmpty()) { <line5> toBePersistedLock.writeLock().lock(); <line6> try { <line7> cachePersistenceDAO.persistBatch(new ArrayList<>(toBePersisted)); <line8> toBePersisted.clear(); <line9> } catch (PersistenceException e) { <line10> try { <line11> Thread.sleep(1000); <line12> } catch (InterruptedException e1) { <line13> } <line14> } finally { <line15> toBePersistedLock.writeLock().unlock(); <line16> } <line17> } <line18> } <line19> } <line20> 	 <line0>	No
public class A { <line0> public boolean isMinimalGB(List<GenPolynomial<C>> Gp) { <line1> if (Gp == null || Gp.size() == 0) { <line2> return true; <line3> } <line4> for (GenPolynomial<C> a : Gp) { <line5> if (a == null || a.isZERO()) { <line6> if (debug) { <line7> } <line8> return false; <line9> } <line10> } <line11> List<GenPolynomial<C>> G = new ArrayList<GenPolynomial<C>>(Gp); <line12> List<GenPolynomial<C>> F = new ArrayList<GenPolynomial<C>>(G.size()); <line13> while (G.size() > 0) { <line14> GenPolynomial<C> a = G.remove(0); <line15> if (red.isTopReducible(G, a) || red.isTopReducible(F, a)) { <line16> if (debug) { <line17> } <line18> return false; <line19> } <line20> F.add(a); <line21> } <line22> G = F; <line23> if (G.size() <= 1) { <line24> return true; <line25> } <line26> int len = G.size(); <line27> int i = 0; <line28> while (i < len) { <line29> GenPolynomial<C> a = G.remove(0); <line30> if (!red.isNormalform(G, a)) { <line31> if (debug) { <line32> } <line33> return false; <line34> } <line35> G.add(a); <line36> i++; <line37> } <line38> return true; <line39> } <line40> } <line41> 	 <line14>	No
public class A { <line0> boolean isHighlyConserved(String category) { <line1> CountByType cbt = countAaSequenceByType.get(category); <line2> long total = cbt.sum(); <line3> var avgLen = averageAaSeqLength(cbt); <line4> StringBuilder sb = new StringBuilder(); <line5> boolean highlyConservedAaSequence = false; <line6> int rank = 1; <line7> for (String aas : cbt.keysRanked(false)) { <line8> long count = cbt.get(aas); <line9> double perc = ((double) count) / total; <line10> if ((perc > HIGHLY_CONSERVED_AA_PERCENT) && (total >= HIGHLY_CONSERVED_AA_COUNT)) <line11> highlyConservedAaSequence = true; <line12> rank++; <line13> if (rank > 50 && aas.length() > 2 && perc < 0.001) break; <line14> } <line15> return highlyConservedAaSequence; <line16> } <line17> } <line18> 	 <line10>	Yes
"public class A { <line0> public int run() { <line1> String scriptContents = toScript(props, commands, env); <line2> if (LOG.isTraceEnabled()) <line3> copyTempFileToServer( <line4> ImmutableMap.of(""permissions"", ""0700""), writeTempFile(scriptContents), scriptPath); <line5> String cmd = Strings.join(buildRunScriptCommand(), separator); <line6> return asInt(sshExec(props, cmd), -1); <line7> } <line8> } <line9> "	 <line3>	Yes
"public class A { <line0> @Test <line1> public void testQueryLaningLaneIsLimited() throws Exception { <line2> ITRetryUtil.retryUntil( <line3> () -> { <line4> final int numQueries = 50; <line5> List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries); <line6> for (int i = 0; i < numQueries; i++) { <line7> futures.add( <line8> queryClient.queryAsync( <line9> queryHelper.getQueryURL(config.getBrokerUrl()), getQueryBuilder().build())); <line10> } <line11> int success = 0; <line12> int limited = 0; <line13> for (Future<StatusResponseHolder> future : futures) { <line14> StatusResponseHolder status = future.get(); <line15> if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) { <line16> limited++; <line17> Assert.assertTrue( <line18> status <line19> .getContent() <line20> .contains(QueryCapacityExceededException.makeLaneErrorMessage(""one"", 1))); <line21> } else if (status.getStatus().getCode() == HttpResponseStatus.OK.getCode()) { <line22> success++; <line23> } <line24> } <line25> try { <line26> Assert.assertTrue(success > 0); <line27> Assert.assertTrue(limited > 0); <line28> return true; <line29> } catch (AssertionError ae) { <line30> return false; <line31> } <line32> }, <line33> true, <line34> 5000, <line35> 3, <line36> ""testQueryLaningLaneIsLimited""); <line37> StatusResponseHolder followUp = <line38> queryClient <line39> .queryAsync(queryHelper.getQueryURL(config.getBrokerUrl()), getQueryBuilder().build()) <line40> .get(); <line41> Assert.assertEquals(followUp.getStatus().getCode(), HttpResponseStatus.OK.getCode()); <line42> StatusResponseHolder andAnother = <line43> queryClient <line44> .queryAsync(queryHelper.getQueryURL(config.getBrokerUrl()), getQueryBuilder().build()) <line45> .get(); <line46> Assert.assertEquals(andAnother.getStatus().getCode(), HttpResponseStatus.OK.getCode()); <line47> } <line48> } <line49> "	 <line30>	Yes
public class A { <line0> protected void invokeDDMFormFieldValueValidator( <line1> DDMFormField ddmFormField, DDMFormFieldValue ddmFormFieldValue) <line2> throws DDMFormValuesValidationException { <line3> DDMFormFieldValueValidator ddmFormFieldValueValidator = <line4> _serviceTrackerMap.getService(ddmFormField.getType()); <line5> if (ddmFormFieldValueValidator == null) { <line6> return; <line7> } <line8> try { <line9> ddmFormFieldValueValidator.validate(ddmFormField, ddmFormFieldValue.getValue()); <line10> } catch (Exception exception) { <line11> if (_log.isDebugEnabled()) { <line12> } <line13> throw new MustSetValidValue(ddmFormField.getName()); <line14> } <line15> } <line16> } <line17> 	 <line12>	Yes
public class A { <line0> @Override <line1> public void receivedSuccessMessage(Request request, Answer answer) { <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> public Integer getDupsOKBatchSize() { <line1> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line2> } <line3> return dupsOKBatchSize; <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> private void assertK8sResultEquals(Environment env, Experiment experiment) throws Exception { <line1> KfOperator operator = <line2> kfOperatorMap.get(experiment.getSpec().getMeta().getFramework().toLowerCase()); <line3> JsonObject rootObject = <line4> getJobByK8sApi( <line5> operator.getGroup(), <line6> operator.getVersion(), <line7> operator.getNamespace(), <line8> operator.getPlural(), <line9> experiment.getName()); <line10> JsonArray actualCommand = <line11> (JsonArray) <line12> rootObject <line13> .getAsJsonObject(""spec"") <line14> .getAsJsonObject(""tfReplicaSpecs"") <line15> .getAsJsonObject(""Worker"") <line16> .getAsJsonObject(""template"") <line17> .getAsJsonObject(""spec"") <line18> .getAsJsonArray(""initContainers"") <line19> .get(0) <line20> .getAsJsonObject() <line21> .get(""command""); <line22> JsonArray expected = new JsonArray(); <line23> expected.add(""/bin/bash""); <line24> expected.add(""-c""); <line25> String minVersion = <line26> ""minVersion=\"""" <line27> + conf.getString(SubmarineConfVars.ConfVars.ENVIRONMENT_CONDA_MIN_VERSION) <line28> + ""\"";""; <line29> String maxVersion = <line30> ""maxVersion=\"""" <line31> + conf.getString(SubmarineConfVars.ConfVars.ENVIRONMENT_CONDA_MAX_VERSION) <line32> + ""\"";""; <line33> String currentVersion = ""currentVersion=$(conda -V | cut -f2 -d' ');""; <line34> String versionCommand = <line35> minVersion <line36> + maxVersion <line37> + currentVersion <line38> + ""if [ \""$(printf '%s\\n' \""$minVersion\"" \""$maxVersion\"" "" <line39> + ""\""$currentVersion\"" | sort -V | head -n2 | tail -1 )\"" "" <line40> + ""!= \""$currentVersion\"" ]; then echo \""Conda version "" <line41> + ""should be between minVersion=\""4.0.1\""; "" <line42> + ""and maxVersion=\""4.10.10\"";\""; exit 1; else echo "" <line43> + ""\""Conda current version is "" <line44> + currentVersion <line45> + "". "" <line46> + ""Moving forward with env creation and activation.\""; "" <line47> + ""fi && ""; <line48> String initialCommand = ""conda create -n "" + env.getEnvironmentSpec().getKernelSpec().getName(); <line49> String channels = """"; <line50> for (String channel : env.getEnvironmentSpec().getKernelSpec().getChannels()) { <line51> channels += "" -c "" + channel; <line52> } <line53> String dependencies = """"; <line54> for (String dependency : env.getEnvironmentSpec().getKernelSpec().getCondaDependencies()) { <line55> dependencies += "" "" + dependency; <line56> } <line57> String fullCommand = <line58> versionCommand <line59> + initialCommand <line60> + channels <line61> + dependencies <line62> + "" && echo \""source activate "" <line63> + env.getEnvironmentSpec().getKernelSpec().getName() <line64> + ""\"" > ~/.bashrc"" <line65> + "" && PATH=/opt/conda/envs/env/bin:$PATH""; <line66> expected.add(fullCommand); <line67> Assert.assertEquals(expected, actualCommand); <line68> JsonObject metadataObject = rootObject.getAsJsonObject(""metadata""); <line69> String uid = metadataObject.getAsJsonPrimitive(""uid"").getAsString(); <line70> Assert.assertEquals(experiment.getUid(), uid); <line71> String creationTimestamp = metadataObject.getAsJsonPrimitive(""creationTimestamp"").getAsString(); <line72> Date expectedDate = new DateTime(experiment.getAcceptedTime()).toDate(); <line73> Date actualDate = new DateTime(creationTimestamp).toDate(); <line74> Assert.assertEquals(expectedDate, actualDate); <line75> } <line76> } <line77> "	 <line74>	Yes
"public class A { <line0> @Override <line1> public OutputStream createOutputStream(final long l) throws IOException { <line2> try (Tx tx = StructrApp.getInstance().tx()) { <line3> if (structrFile == null) { <line4> final Folder parentFolder = <line5> (Folder) <line6> FileHelper.getFileByAbsolutePath( <line7> securityContext, StringUtils.substringBeforeLast(newPath, ""/"")); <line8> try { <line9> structrFile = <line10> FileHelper.createFile( <line11> securityContext, new byte[0], null, File.class, getName(), false); <line12> structrFile.setProperty(AbstractNode.type, File.class.getSimpleName()); <line13> structrFile.setProperty(AbstractNode.owner, owner.getStructrUser()); <line14> if (parentFolder != null) { <line15> structrFile.setParent(parentFolder); <line16> } <line17> } catch (FrameworkException ex) { <line18> return null; <line19> } <line20> } <line21> tx.success(); <line22> return ((File) structrFile).getOutputStream(); <line23> } catch (FrameworkException fex) { <line24> } <line25> return null; <line26> } <line27> } <line28> "	 <line26>	No
public class A { <line0> public static BufferedImage getImage(CardView card, int width, int height) { <line1> if (Constants.THUMBNAIL_SIZE_FULL.width + 10 > width) { <line2> return getThumbnail(card); <line3> } <line4> String key = getKey(card, card.getName(), Integer.toString(width)); <line5> BufferedImage original = getImage(key); <line6> if (original == null) { <line7> return null; <line8> } <line9> double scale = <line10> Math.min((double) width / original.getWidth(), (double) height / original.getHeight()); <line11> if (scale >= 1) { <line12> return original; <line13> } <line14> return TransformedImageCache.getResizedImage( <line15> original, (int) (original.getWidth() * scale), (int) (original.getHeight() * scale)); <line16> } <line17> } <line18> 	 <line7>	Yes
"public class A { <line0> @OPTIONS <line1> public Response unsupportedOptionsMethod() { <line2> throw new WebApplicationException( <line3> Response.status(NOT_ALLOWED_STATUS).entity(""OPTIONS Method Not Allowed"").build()); <line4> } <line5> } <line6> "	 <line2>	Yes
"public class A { <line0> public static void premain(String configfile, Instrumentation instrumentation) { <line1> try { <line2> if (configfile != null && !configfile.isEmpty()) { <line3> Map<String, String> config = loadConfig(configfile); <line4> String serviceName = config.get(""service.name""); <line5> Map<String, String> dirs = <line6> config.entrySet().stream() <line7> .filter(map -> map.getKey().startsWith(""disk."")) <line8> .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue())); <line9> MBeanServer server = ManagementFactory.getPlatformMBeanServer(); <line10> for (String dir : dirs.keySet()) { <line11> String displayName = dir.replace(""disk."", """"); <line12> String volume = dirs.get(dir); <line13> String objectName = <line14> String.format( <line15> ""io.confluent.caas:type=VolumeMetrics, service=%s, dir=%s"", <line16> serviceName, displayName); <line17> ObjectName volumeMBeanName = new ObjectName(objectName); <line18> Volume volumeMBean = new Volume(volume); <line19> server.registerMBean(volumeMBean, volumeMBeanName); <line20> Set<ObjectInstance> instances = server.queryMBeans(new ObjectName(objectName), null); <line21> ObjectInstance instance = (ObjectInstance) instances.toArray()[0]; <line22> } <line23> } else { <line24> } <line25> } catch (Exception e) { <line26> } <line27> } <line28> } <line29> "	 <line7>	No
"public class A { <line0> private String createUrl() { <line1> try { <line2> String scopeIdParam = ""scopeId="" + itNetwork.getScopeId(); <line3> String titleParam = ""itNetwork="" + URLEncoder.encode(itNetwork.getTitle(), ""UTF-8""); <line4> return ""/dashboard/"" <line5> + getTemplateFile() <line6> + ""?"" <line7> + scopeIdParam <line8> + ""&"" <line9> + titleParam <line10> + getStrategyParam(); <line11> } catch (UnsupportedEncodingException e) { <line12> } <line13> return """"; <line14> } <line15> } <line16> "	 <line5>	No
"public class A { <line0> public OpenCGAResult<Panel> update( <line1> String studyStr, <line2> List<String> panelIds, <line3> PanelUpdateParams updateParams, <line4> boolean ignoreException, <line5> QueryOptions options, <line6> String token) <line7> throws CatalogException { <line8> String userId = userManager.getUserId(token); <line9> Study study = studyManager.resolveId(studyStr, userId); <line10> String operationId = UuidUtils.generateOpenCgaUuid(UuidUtils.Entity.AUDIT); <line11> ObjectMap updateMap; <line12> try { <line13> updateMap = updateParams != null ? updateParams.getUpdateMap() : null; <line14> } catch (JsonProcessingException e) { <line15> throw new CatalogException(""Could not parse PanelUpdateParams object: "" + e.getMessage(), e); <line16> } <line17> ObjectMap auditParams = <line18> new ObjectMap() <line19> .append(""study"", studyStr) <line20> .append(""panelIds"", panelIds) <line21> .append(""updateParams"", updateMap) <line22> .append(""ignoreException"", ignoreException) <line23> .append(""options"", options) <line24> .append(""token"", token); <line25> auditManager.initAuditBatch(operationId); <line26> OpenCGAResult<Panel> result = OpenCGAResult.empty(); <line27> for (String id : panelIds) { <line28> String panelId = id; <line29> String panelUuid = """"; <line30> try { <line31> OpenCGAResult<Panel> internalResult = <line32> internalGet(study.getUid(), panelId, QueryOptions.empty(), userId); <line33> if (internalResult.getNumResults() == 0) { <line34> throw new CatalogException(""Panel '"" + id + ""' not found""); <line35> } <line36> Panel panel = internalResult.first(); <line37> panelId = panel.getId(); <line38> panelUuid = panel.getUuid(); <line39> OpenCGAResult updateResult = update(study, panel, updateParams, options, userId); <line40> result.append(updateResult); <line41> auditManager.auditUpdate( <line42> userId, <line43> Enums.Resource.DISEASE_PANEL, <line44> panel.getId(), <line45> panel.getUuid(), <line46> study.getId(), <line47> study.getUuid(), <line48> auditParams, <line49> new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS)); <line50> } catch (CatalogException e) { <line51> Event event = new Event(Event.Type.ERROR, panelId, e.getMessage()); <line52> result.getEvents().add(event); <line53> auditManager.auditUpdate( <line54> operationId, <line55> userId, <line56> Enums.Resource.DISEASE_PANEL, <line57> panelId, <line58> panelUuid, <line59> study.getId(), <line60> study.getUuid(), <line61> auditParams, <line62> new AuditRecord.Status(AuditRecord.Status.Result.ERROR, e.getError())); <line63> } <line64> } <line65> auditManager.finishAuditBatch(operationId); <line66> return endResult(result, ignoreException); <line67> } <line68> } <line69> "	 <line53>	Yes
public class A { <line0> @Test <line1> public void testPlatformIncludesList() { <line2> PlatformDto p = load(PlatformRestResource.CAMP_URI_PATH, PlatformDto.class); <line3> PlatformComponentTemplateDto pct = <line4> load( <line5> p.getPlatformComponentTemplates().get(0).getHref(), PlatformComponentTemplateDto.class); <line6> Assert.assertNotNull(pct.getName()); <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> @ApiOperation(""Delete specified path."") <line1> @ApiResponse(code = 200, message = ""Operation finished."", response = PathMappedDeleteResult.class) <line2> @DELETE <line3> @Path(CONCRETE_CONTENT_PATH) <line4> @Produces({application_json}) <line5> public PathMappedDeleteResult delete( <line6> final @PathParam(""packageType"") String packageType, <line7> final @ApiParam(allowableValues = ""hosted,group,remote"", required = true) @PathParam(""type"") <line8> String type, <line9> final @ApiParam(required = true) @PathParam(""name"") String name, <line10> final @PathParam(""path"") String path, <line11> final @Context HttpServletRequest request, <line12> final @Context SecurityContext securityContext) { <line13> try { <line14> return controller.delete(packageType, type, name, path); <line15> } catch (Exception e) { <line16> responseHelper.throwError(e); <line17> } <line18> return null; <line19> } <line20> } <line21> "	 <line4>	No
"public class A { <line0> @BeforeClass <line1> public static void setUp() throws Exception { <line2> File outdir = new File(PATH_ACTUAL); <line3> outdir.mkdirs(); <line4> File externalTestsJar = <line5> Objects.requireNonNull( <line6> new File(joinPath("".."", ""asterix-external-data"", ""target"")) <line7> .listFiles((dir, name) -> name.matches(""asterix-external-data-.*-tests.jar"")))[0]; <line8> asterixInstallerPath = new File(System.getProperty(""user.dir"")); <line9> installerTargetPath = <line10> new File(new File(asterixInstallerPath.getParentFile(), ""asterix-server""), ""target""); <line11> reportPath = new File(installerTargetPath, ""failsafe-reports"").getAbsolutePath(); <line12> ncServiceSubDirName = <line13> Objects.requireNonNull( <line14> installerTargetPath.list( <line15> (dir, name) -> name.matches(""asterix-server.*binary-assembly"")))[0]; <line16> ncServiceSubPath = new File(installerTargetPath, ncServiceSubDirName).getAbsolutePath(); <line17> ncServiceHomeDirName = <line18> Objects.requireNonNull( <line19> new File(ncServiceSubPath).list(((dir, name) -> name.matches(""apache-asterixdb.*""))))[ <line20> 0]; <line21> ncServiceHomePath = new File(ncServiceSubPath, ncServiceHomeDirName).getAbsolutePath(); <line22> FileUtils.copyFile( <line23> externalTestsJar, new File(ncServiceHomePath + ""/repo"", externalTestsJar.getName())); <line24> pb = new ProcessBuilder(); <line25> env = pb.environment(); <line26> env.put(""NCSERVICE_HOME"", ncServiceHomePath); <line27> env.put(""JAVA_HOME"", System.getProperty(""java.home"")); <line28> scriptHomePath = <line29> joinPath( <line30> asterixInstallerPath.getPath(), ""src"", ""test"", ""resources"", ""transactionts"", ""scripts""); <line31> env.put(""SCRIPT_HOME"", scriptHomePath); <line32> TestExecutor.executeScript( <line33> pb, joinPath(scriptHomePath, ""setup_teardown"", ""configure_and_validate.sh"")); <line34> TestExecutor.executeScript( <line35> pb, joinPath(scriptHomePath, ""setup_teardown"", ""stop_and_delete.sh"")); <line36> HDFSCluster.getInstance().setup(HDFS_BASE); <line37> } <line38> } <line39> "	 <line22>	Yes
"public class A { <line0> @Override <line1> public void updateService(ApiService service) throws ApsSystemException { <line2> try { <line3> if (null == service) { <line4> throw new ApsSystemException(""Null api service to update""); <line5> } <line6> ApiService masterService = <line7> this.getServiceCacheWrapper().getMasterServices().get(service.getKey()); <line8> if (null == masterService) { <line9> throw new ApsSystemException(""Api service '"" + service.getKey() + ""' does not exist""); <line10> } <line11> masterService.setActive(service.isActive()); <line12> masterService.setHidden(service.isHidden()); <line13> this.getApiCatalogDAO().updateService(masterService); <line14> this.getServiceCacheWrapper().updateService(service); <line15> } catch (Throwable t) { <line16> throw new ApsSystemException(""Error updating service '"" + service.getKey() + ""'"", t); <line17> } <line18> } <line19> } <line20> "	 <line6>	No
public class A { <line0> @Override <line1> public void close(Throwable throwable) { <line2> close0(throwable); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> @Override <line1> public Boolean call() throws Exception { <line2> ExoContainerContext.setCurrentContainer(portalContainer); <line3> boolean migrationProceededWithoutErrors = true; <line4> for (Space space : spaces) { <line5> if (space == null || StringUtils.isBlank(space.getGroupId())) { <line6> continue; <line7> } <line8> RequestLifeCycle.begin(portalContainer); <line9> try { <line10> migrateSpace(space, migrationResult); <line11> } catch (Exception ex) { <line12> migrationProceededWithoutErrors = false; <line13> } finally { <line14> RequestLifeCycle.end(); <line15> } <line16> } <line17> return migrationProceededWithoutErrors; <line18> } <line19> } <line20> 	 <line12>	Yes
public class A { <line0> protected void loadAegisTypeClassAndRegister( <line1> String typeClassName, Class<?> aegisTypeClass, QName qName, TypeMapping typeMapping) { <line2> try { <line3> Class<?> typeClazz = Thread.currentThread().getContextClassLoader().loadClass(typeClassName); <line4> AegisType aegisType = instantiateAegisType(aegisTypeClass); <line5> typeMapping.register(typeClazz, qName, aegisType); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	 <line4>	No
"public class A { <line0> @Override <line1> public List<RangerPolicy> getDefaultRangerPolicies() throws Exception { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> List<RangerPolicy> ret = super.getDefaultRangerPolicies(); <line5> for (RangerPolicy defaultPolicy : ret) { <line6> if (defaultPolicy.getName().contains(""all"") && StringUtils.isNotBlank(lookUpUser)) { <line7> List<RangerPolicy.RangerPolicyItemAccess> accessListForLookupUser = <line8> new ArrayList<RangerPolicy.RangerPolicyItemAccess>(); <line9> accessListForLookupUser.add(new RangerPolicyItemAccess(ACCESS_TYPE_READ)); <line10> accessListForLookupUser.add(new RangerPolicyItemAccess(ACCESS_TYPE_CREATE)); <line11> RangerPolicyItem policyItemForLookupUser = new RangerPolicyItem(); <line12> policyItemForLookupUser.setUsers(Collections.singletonList(lookUpUser)); <line13> policyItemForLookupUser.setAccesses(accessListForLookupUser); <line14> policyItemForLookupUser.setDelegateAdmin(false); <line15> defaultPolicy.getPolicyItems().add(policyItemForLookupUser); <line16> } <line17> } <line18> if (LOG.isDebugEnabled()) { <line19> } <line20> return ret; <line21> } <line22> } <line23> "	 <line3>	Yes
"public class A { <line0> private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len) { <line1> if (!FourLetterCommands.isKnown(len)) { <line2> return false; <line3> } <line4> String cmd = FourLetterCommands.getCommandString(len); <line5> channel.config().setAutoRead(false); <line6> packetReceived(4); <line7> final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter())); <line8> if (!FourLetterCommands.isEnabled(cmd)) { <line9> NopCommand nopCmd = <line10> new NopCommand( <line11> pwriter, this, cmd + "" is not executed because it is not in the whitelist.""); <line12> nopCmd.start(); <line13> return true; <line14> } <line15> if (len == FourLetterCommands.setTraceMaskCmd) { <line16> ByteBuffer mask = ByteBuffer.allocate(8); <line17> message.readBytes(mask); <line18> mask.flip(); <line19> long traceMask = mask.getLong(); <line20> ZooTrace.setTextTraceLevel(traceMask); <line21> SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask); <line22> setMask.start(); <line23> return true; <line24> } else { <line25> CommandExecutor commandExecutor = new CommandExecutor(); <line26> return commandExecutor.execute(this, pwriter, len, zkServer, factory); <line27> } <line28> } <line29> } <line30> "	 <line18>	No
"public class A { <line0> public static boolean isAccessAllowed(AtlasRelationshipAccessRequest request) { <line1> MetricRecorder metric = RequestContext.get().startMetricRecord(""isAccessAllowed""); <line2> boolean ret = false; <line3> String userName = getCurrentUserName(); <line4> if (StringUtils.isNotEmpty(userName) && !RequestContext.get().isImportInProgress()) { <line5> try { <line6> AtlasAuthorizer authorizer = AtlasAuthorizerFactory.getAtlasAuthorizer(); <line7> request.setUser(getCurrentUserName(), getCurrentUserGroups()); <line8> request.setClientIPAddress(RequestContext.get().getClientIPAddress()); <line9> request.setForwardedAddresses(RequestContext.get().getForwardedAddresses()); <line10> request.setRemoteIPAddress(RequestContext.get().getClientIPAddress()); <line11> ret = authorizer.isAccessAllowed(request); <line12> } catch (AtlasAuthorizationException e) { <line13> } <line14> } else { <line15> ret = true; <line16> } <line17> RequestContext.get().endMetricRecord(metric); <line18> return ret; <line19> } <line20> } <line21> "	 <line13>	Yes
"public class A { <line0> @PutChild <line1> public Gig updateGig(Gig gig, byte[] ical) throws IOException, ParserException { <line2> Transaction tx = SessionManager.session().beginTransaction(); <line3> try { <line4> CalendarBuilder builder = new CalendarBuilder(); <line5> ByteArrayInputStream bin = new ByteArrayInputStream(ical); <line6> System.out.println(bin.toString()); <line7> Calendar calendar = builder.build(bin); <line8> VEvent ev = (VEvent) calendar.getComponent(""VEVENT""); <line9> gig.setStartDate(ev.getStartDate().getDate()); <line10> Date endDate = null; <line11> if (ev.getEndDate() != null) { <line12> endDate = ev.getEndDate().getDate(); <line13> } <line14> gig.setEndDate(endDate); <line15> String summary = null; <line16> if (ev.getSummary() != null) { <line17> summary = ev.getSummary().getValue(); <line18> } <line19> gig.setDisplayName(summary); <line20> gig.setModifiedDate(new Date()); <line21> SessionManager.session().save(gig); <line22> SessionManager.session().flush(); <line23> tx.commit(); <line24> System.out.println(""Updated gig: "" + gig.getStartDate() + "" - "" + gig.getEndDate()); <line25> } catch (Exception e) { <line26> tx.rollback(); <line27> } <line28> return gig; <line29> } <line30> } <line31> "	 <line2>	Yes
public class A { <line0> @Override <line1> public boolean start() throws IOException { <line2> try { <line3> drive = source.getDriveService(); <line4> utils = source.getDriveUtils(); <line5> } catch (GeneralSecurityException e) { <line6> result.toMap().put(GoogleDriveCopyDefinition.RETURN_ERROR_MESSAGE, e.getMessage()); <line7> throw new ComponentException(e); <line8> } <line9> return true; <line10> } <line11> } <line12> 	 <line4>	No
"public class A { <line0> @Test <line1> public void testGetObjectProfileXML() { <line2> try { <line3> String url = ""/fedora/objects/test:1000001?format=xml""; <line4> String response = httpUtils.get(url); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> boolean check = response.contains(""<objLabel>Chuck</objLabel>""); <line8> Assert.assertTrue(""Expected object data not found"", check); <line9> } catch (Exception re) { <line10> Assert.fail(re.getMessage()); <line11> } <line12> } <line13> } <line14> "	 <line2>	Yes
public class A { <line0> private void onRegTmMessage(ChannelHandlerContext ctx, RpcMessage rpcMessage) { <line1> RegisterTMRequest message = (RegisterTMRequest) rpcMessage.getBody(); <line2> String ipAndPort = NetUtil.toStringAddress(ctx.channel().remoteAddress()); <line3> Version.putChannelVersion(ctx.channel(), message.getVersion()); <line4> boolean isSuccess = false; <line5> String errorInfo = StringUtils.EMPTY; <line6> try { <line7> if (null == checkAuthHandler || checkAuthHandler.regTransactionManagerCheckAuth(message)) { <line8> ChannelManager.registerTMChannel(message, ctx.channel()); <line9> Version.putChannelVersion(ctx.channel(), message.getVersion()); <line10> isSuccess = true; <line11> if (LOGGER.isDebugEnabled()) { <line12> } <line13> } <line14> } catch (Exception exx) { <line15> isSuccess = false; <line16> errorInfo = exx.getMessage(); <line17> } <line18> RegisterTMResponse response = new RegisterTMResponse(isSuccess); <line19> if (StringUtils.isNotEmpty(errorInfo)) { <line20> response.setMsg(errorInfo); <line21> } <line22> remotingServer.sendAsyncResponse(rpcMessage, ctx.channel(), response); <line23> if (LOGGER.isInfoEnabled()) { <line24> } <line25> } <line26> } <line27> 	 <line12>	Yes
"public class A { <line0> @Override <line1> public String format(LogRecord record) { <line2> String msg = record.getMessage(); <line3> return msg + ""\n""; <line4> } <line5> } <line6> "	 <line2>	No
public class A { <line0> @Override <line1> public void onRayoEvent(JID from, Presence presence) { <line2> Object obj = presence.getExtension().getObject(); <line3> if (obj instanceof com.rayo.core.verb.VerbCompleteEvent) { <line4> com.rayo.core.verb.VerbCompleteEvent event = (com.rayo.core.verb.VerbCompleteEvent) obj; <line5> MohoInputCompleteEvent<T> mohoEvent = <line6> new MohoInputCompleteEvent<T>( <line7> _todo, <line8> getMohoInputCompleteReasonByRayoReason(event.getReason()), <line9> event.getErrorText(), <line10> this); <line11> if (event instanceof com.rayo.core.verb.InputCompleteEvent) { <line12> mohoEvent.setConcept(((com.rayo.core.verb.InputCompleteEvent) event).getConcept()); <line13> mohoEvent.setConfidence(((com.rayo.core.verb.InputCompleteEvent) event).getConfidence()); <line14> com.voxeo.moho.media.InputMode mode = null; <line15> if (((com.rayo.core.verb.InputCompleteEvent) event).getMode() == InputMode.DTMF) { <line16> mode = com.voxeo.moho.media.InputMode.DTMF; <line17> } else if (((com.rayo.core.verb.InputCompleteEvent) event).getMode() == InputMode.VOICE) { <line18> mode = com.voxeo.moho.media.InputMode.SPEECH; <line19> } else { <line20> mode = com.voxeo.moho.media.InputMode.ANY; <line21> } <line22> mohoEvent.setInputMode(mode); <line23> mohoEvent.setInterpretation( <line24> ((com.rayo.core.verb.InputCompleteEvent) event).getInterpretation()); <line25> mohoEvent.setNlsml(((com.rayo.core.verb.InputCompleteEvent) event).getNlsml()); <line26> mohoEvent.setTag(((com.rayo.core.verb.InputCompleteEvent) event).getTag()); <line27> mohoEvent.setUtterance(((com.rayo.core.verb.InputCompleteEvent) event).getUtterance()); <line28> } <line29> this.done(mohoEvent); <line30> _call.dispatch(mohoEvent); <line31> } else { <line32> } <line33> } <line34> } <line35> 	 <line2>	Yes
public class A { <line0> @Override <line1> protected void execute(final IMonitoringRecord record) { <line2> this.count++; <line3> this.ctrl.newMonitoringRecord(record); <line4> if ((this.count % 100000) == 0) { <line5> } <line6> } <line7> } <line8> 	 <line0>	No
"public class A { <line0> @Override <line1> public void activateOptions() throws FlumeException { <line2> Properties props = new Properties(); <line3> props.setProperty(RpcClientConfigurationConstants.CONFIG_HOSTS, ""h1""); <line4> props.setProperty( <line5> RpcClientConfigurationConstants.CONFIG_HOSTS_PREFIX + ""h1"", hostname + "":"" + port); <line6> props.setProperty( <line7> RpcClientConfigurationConstants.CONFIG_CONNECT_TIMEOUT, String.valueOf(timeout)); <line8> props.setProperty( <line9> RpcClientConfigurationConstants.CONFIG_REQUEST_TIMEOUT, String.valueOf(timeout)); <line10> try { <line11> rpcClient = RpcClientFactory.getInstance(props); <line12> if (layout != null) { <line13> layout.activateOptions(); <line14> } <line15> } catch (FlumeException e) { <line16> String errormsg = ""RPC client creation failed! "" + e.getMessage(); <line17> throw e; <line18> } <line19> } <line20> } <line21> "	 <line17>	Yes
public class A { <line0> private void logNamespaces(Exchange exchange) { <line1> InputStream is = null; <line2> NodeList answer = null; <line3> XPathExpression xpathExpression = null; <line4> try { <line5> xpathExpression = poolLogNamespaces.poll(); <line6> if (xpathExpression == null) { <line7> xpathExpression = createTraceNamespaceExpression(); <line8> } <line9> Object document; <line10> if (isInputStreamNeeded(exchange)) { <line11> is = exchange.getIn().getBody(InputStream.class); <line12> document = getDocument(exchange, is); <line13> } else { <line14> Object body = exchange.getIn().getBody(); <line15> document = getDocument(exchange, body); <line16> } <line17> if (document instanceof InputSource) { <line18> InputSource inputSource = (InputSource) document; <line19> answer = (NodeList) xpathExpression.evaluate(inputSource, XPathConstants.NODESET); <line20> } else if (document instanceof DOMSource) { <line21> DOMSource source = (DOMSource) document; <line22> answer = (NodeList) xpathExpression.evaluate(source.getNode(), XPathConstants.NODESET); <line23> } else if (document instanceof SAXSource) { <line24> SAXSource source = (SAXSource) document; <line25> Object result = xpathExpression.evaluate(source.getInputSource(), XPathConstants.NODESET); <line26> if (result instanceof NodeList) { <line27> answer = (NodeList) result; <line28> } else { <line29> answer = null; <line30> } <line31> } else { <line32> answer = (NodeList) xpathExpression.evaluate(document, XPathConstants.NODESET); <line33> } <line34> } catch (Exception e) { <line35> } finally { <line36> IOHelper.close(is); <line37> poolLogNamespaces.add(xpathExpression); <line38> } <line39> if (answer != null) { <line40> logDiscoveredNamespaces(answer); <line41> } <line42> } <line43> } <line44> 	 <line35>	Yes
"public class A { <line0> public FileSource add(Resource resource, File file, String fileName) <line1> throws ImportException, InvalidFilenameException { <line2> if (acceptableFileName(fileName)) { <line3> FileSource src; <line4> String suffix = FilenameUtils.getExtension(fileName); <line5> if (suffix != null && (suffix.equalsIgnoreCase(""xls"") || suffix.equalsIgnoreCase(""xlsx""))) { <line6> src = addExcelFile(); <line7> } else { <line8> src = addTextFile(file); <line9> } <line10> src.setName(fileName); <line11> src.setResource(resource); <line12> try { <line13> File ddFile = dataDir.sourceFile(resource, src); <line14> try { <line15> FileUtils.copyFile(file, ddFile); <line16> } catch (IOException e1) { <line17> throw new ImportException(e1); <line18> } <line19> src.setFile(ddFile); <line20> src.setLastModified(new Date()); <line21> resource.addSource(src, true); <line22> } catch (AlreadyExistingException e) { <line23> throw new ImportException(e); <line24> } <line25> analyze(src); <line26> return src; <line27> } else { <line28> throw new InvalidFilenameException(""Filename contains illegal characters""); <line29> } <line30> } <line31> } <line32> "	 <line2>	Yes
"public class A { <line0> public boolean assignVariableValueFromInput( <line1> final String variableName, final String inputVariableLocalName, final BPELPlan buildPlan) { <line2> final Element propertyAssignElement = buildPlan.getBpelMainSequencePropertyAssignElement(); <line3> final Element copyElement = <line4> buildPlan.getBpelDocument().createElementNS(BPELPlan.bpelNamespace, ""copy""); <line5> final Element fromElement = <line6> buildPlan.getBpelDocument().createElementNS(BPELPlan.bpelNamespace, ""from""); <line7> fromElement.setAttribute(""part"", ""payload""); <line8> fromElement.setAttribute(""variable"", ""input""); <line9> final Element queryElement = <line10> buildPlan.getBpelDocument().createElementNS(BPELPlan.bpelNamespace, ""query""); <line11> queryElement.setAttribute(""queryLanguage"", ""urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0""); <line12> queryElement.appendChild( <line13> buildPlan <line14> .getBpelDocument() <line15> .createCDATASection(""//*[local-name()='"" + inputVariableLocalName + ""']/text()"")); <line16> fromElement.appendChild(queryElement); <line17> final Element toElement = <line18> buildPlan.getBpelDocument().createElementNS(BPELPlan.bpelNamespace, ""to""); <line19> toElement.setAttribute(""variable"", variableName); <line20> copyElement.appendChild(fromElement); <line21> copyElement.appendChild(toElement); <line22> propertyAssignElement.appendChild(copyElement); <line23> return true; <line24> } <line25> } <line26> "	 <line6>	No
public class A { <line0> @Override <line1> public void run() { <line2> AstroThingHandler astroHandler = AstroHandlerFactory.getHandler(getThingUID()); <line3> if (astroHandler != null) { <line4> astroHandler.publishDailyInfo(); <line5> } else { <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
"public class A { <line0> @Override <line1> public OperationPolicy createOperationPolicy( <line2> Component operation, CoreEvent event, OperationParametersProcessor operationParameters) { <line3> if (!isOperationPoliciesAvailable.get()) { <line4> return NO_POLICY_OPERATION; <line5> } <line6> PolicyPointcutParameters operationPointcutParameters = <line7> policyPointcutParametersManager.createOperationPointcutParameters( <line8> operation, event, operationParameters.getOperationParameters()); <line9> final ComponentIdentifier operationIdentifier = <line10> operation.getLocation().getComponentIdentifier().getIdentifier(); <line11> final Pair<ComponentIdentifier, PolicyPointcutParameters> policyKey = <line12> new Pair<>(operationIdentifier, operationPointcutParameters); <line13> final OperationPolicy policy = operationPolicyOuterCache.getIfPresent(policyKey); <line14> if (policy != null) { <line15> return policy; <line16> } <line17> cacheInvalidateLock.readLock().lock(); <line18> try { <line19> if (LOGGER.isDebugEnabled()) { <line20> } <line21> OperationPolicy operationPolicy = <line22> operationPolicyOuterCache.get( <line23> policyKey, <line24> outerKey -> <line25> operationPolicyInnerCache.get( <line26> policyProvider.findOperationParameterizedPolicies(outerKey.getSecond()), <line27> innerKey -> <line28> innerKey.isEmpty() <line29> ? NO_POLICY_OPERATION <line30> : compositePolicyFactory.createOperationPolicy( <line31> operation, <line32> innerKey, <line33> lookupOperationParametersTransformer(outerKey.getFirst()), <line34> operationPolicyProcessorFactory, <line35> muleContext.getConfiguration().getShutdownTimeout(), <line36> muleContext <line37> .getSchedulerService() <line38> .ioScheduler( <line39> muleContext <line40> .getSchedulerBaseConfig() <line41> .withMaxConcurrentTasks(1) <line42> .withName( <line43> operation.getLocation().getLocation() <line44> + "".policy.flux.""))))); <line45> if (operationPolicy instanceof DeferredDisposable) { <line46> activePolicies.add( <line47> new DeferredDisposableWeakReference( <line48> (DeferredDisposable) operationPolicy, stalePoliciesQueue)); <line49> } <line50> return operationPolicy; <line51> } finally { <line52> cacheInvalidateLock.readLock().unlock(); <line53> } <line54> } <line55> } <line56> "	 <line20>	Yes
"public class A { <line0> @Override <line1> public JsonArray fetchVisualizationResults(long executionId, int kpiId, int assessmentId) { <line2> String vQuery = """"; <line3> vQuery = QueryEnum.valueOf(QueryEnum.NEO4J_VCONTENTQUERY.name()).toString(); <line4> vQuery = <line5> vQuery <line6> .replace("":kpiId"", String.valueOf(kpiId)) <line7> .replace("":executionId"", String.valueOf(executionId)) <line8> .replace("":assessmentId"", String.valueOf(assessmentId)); <line9> return fetchVisualizationResults(vQuery); <line10> } <line11> } <line12> "	 <line9>	Yes
"public class A { <line0> @Override <line1> public boolean handleSync(DocumentWrapper<Object> wrapDoc) throws Exception { <line2> boolean result = false; <line3> ServiceContext<PoxPayloadIn, PoxPayloadOut> ctx = getServiceContext(); <line4> Specifier specifier = (Specifier) wrapDoc.getWrappedObject(); <line5> DocumentModel docModel = <line6> NuxeoUtils.getDocFromSpecifier( <line7> ctx, getRepositorySession(), authorityCommonSchemaName, specifier); <line8> if (docModel != null) { <line9> String authorityCsid = docModel.getName(); <line10> Long localRev = (Long) NuxeoUtils.getProperyValue(docModel, AuthorityJAXBSchema.REV); <line11> String shortId = <line12> (String) NuxeoUtils.getProperyValue(docModel, AuthorityJAXBSchema.SHORT_IDENTIFIER); <line13> String remoteClientConfigName = <line14> (String) <line15> NuxeoUtils.getProperyValue(docModel, AuthorityJAXBSchema.REMOTECLIENT_CONFIG_NAME); <line16> Specifier sasSpecifier = new Specifier(SpecifierForm.URN_NAME, shortId); <line17> PoxPayloadIn sasPayloadIn = <line18> AuthorityServiceUtils.requestPayloadInFromRemoteServer( <line19> ctx, remoteClientConfigName, sasSpecifier, getEntityResponseType()); <line20> Long sasRev = getRevision(sasPayloadIn); <line21> if (sasRev > localRev || true) { <line22> syncAllItems(ctx, authorityCsid, sasSpecifier); <line23> AuthorityResource authorityResource = (AuthorityResource) ctx.getResource(); <line24> ctx.setProperty( <line25> AuthorityServiceUtils.SHOULD_UPDATE_REV_PROPERTY, <line26> AuthorityServiceUtils.DONT_UPDATE_REV); <line27> PoxPayloadOut payloadOut = <line28> authorityResource.update( <line29> ctx, ctx.getResourceMap(), ctx.getUriInfo(), docModel.getName(), sasPayloadIn); <line30> if (payloadOut != null) { <line31> ctx.setOutput(payloadOut); <line32> result = true; <line33> } <line34> String workflowState = docModel.getCurrentLifeCycleState(); <line35> if (workflowState.contains(WorkflowClient.WORKFLOWSTATE_REPLICATED) == false) { <line36> authorityResource.updateWorkflowWithTransition( <line37> ctx, ctx.getUriInfo(), authorityCsid, WorkflowClient.WORKFLOWTRANSITION_REPLICATE); <line38> } <line39> } <line40> } else { <line41> String errMsg = <line42> String.format( <line43> ""Authority of type '%s' with identifier '%s' does not exist."", <line44> getServiceContext().getServiceName(), specifier.getURNValue()); <line45> throw new DocumentException(errMsg); <line46> } <line47> return result; <line48> } <line49> } <line50> "	 <line45>	Yes
"public class A { <line0> private void sendData(String listName, Reference<Integer> numSent) { <line1> Long lastMetricTime; <line2> lastMetricTime = this.sendBatch(listName, numSent); <line3> if (lastMetricTime != null) { <line4> String backlogNum = """"; <line5> final long start = System.currentTimeMillis(); <line6> while ((lastMetricTime = this.sendBatch(listName, numSent)) != null) { <line7> long now = System.currentTimeMillis(); <line8> long tDiff = now - lastMetricTime.longValue(); <line9> String backlog = Long.toString(tDiff / (60 * 1000)); <line10> if (((tDiff / (60 * 1000)) > 1) && (backlog.equals(backlogNum) == false)) { <line11> backlogNum = backlog; <line12> } <line13> if (this.shouldDie == true) { <line14> return; <line15> } <line16> } <line17> final long total = System.currentTimeMillis() - start; <line18> if (total > SEND_INTERVAL) { <line19> } else if (log.isDebugEnabled()) { <line20> } <line21> } <line22> } <line23> } <line24> "	 <line19>	Yes
"public class A { <line0> @Override <line1> public void onStart(AppContext appContext) throws Throwable { <line2> this.nacosNamingService = appContext.getInstance(NamingService.class); <line3> if (this.nacosNamingService == null) { <line4> Properties properties = new Properties(); <line5> properties.put(""serverAddr"", this.nacosServerAddr); <line6> properties.put(""namespace"", this.nacosNamespace); <line7> this.nacosNamingService = NacosFactory.createNamingService(properties); <line8> } else { <line9> } <line10> List<Instance> allInstances = <line11> this.nacosNamingService.getAllInstances( <line12> this.serviceName, <line13> this.nacosGroupName, <line14> Collections.singletonList(this.serviceClusterName)); <line15> for (Instance instance : allInstances) { <line16> if (instance.getIp().equals(this.serviceIP) && instance.getPort() == this.servicePort) { <line17> this.registerStatus = false; <line18> return; <line19> } <line20> } <line21> this.nacosNamingService.registerInstance( <line22> this.serviceName, <line23> this.nacosGroupName, <line24> this.serviceIP, <line25> this.servicePort, <line26> this.serviceClusterName); <line27> this.registerStatus = true; <line28> } <line29> } <line30> "	 <line9>	Yes
public class A { <line0> @Override <line1> public void rollback() { <line2> try { <line3> tm.rollback(); <line4> } catch (Exception e) { <line5> throw new RuntimeException(e); <line6> } <line7> } <line8> } <line9> 	 <line6>	No
"public class A { <line0> @GraphTransaction <line1> public AtlasGlossaryCategory createCategory(AtlasGlossaryCategory glossaryCategory) <line2> throws AtlasBaseException { <line3> if (DEBUG_ENABLED) { <line4> } <line5> if (Objects.isNull(glossaryCategory)) { <line6> throw new AtlasBaseException( <line7> AtlasErrorCode.BAD_REQUEST, ""GlossaryCategory definition missing""); <line8> } <line9> if (Objects.isNull(glossaryCategory.getAnchor())) { <line10> throw new AtlasBaseException(AtlasErrorCode.MISSING_MANDATORY_ANCHOR); <line11> } <line12> if (StringUtils.isEmpty(glossaryCategory.getName())) { <line13> throw new AtlasBaseException(AtlasErrorCode.GLOSSARY_CATEGORY_QUALIFIED_NAME_CANT_BE_DERIVED); <line14> } <line15> if (isNameInvalid(glossaryCategory.getName())) { <line16> throw new AtlasBaseException(AtlasErrorCode.INVALID_DISPLAY_NAME); <line17> } else { <line18> String anchorGlossaryGuid = glossaryCategory.getAnchor().getGlossaryGuid(); <line19> AtlasGlossary glossary = dataAccess.load(getGlossarySkeleton(anchorGlossaryGuid)); <line20> glossaryCategory.setQualifiedName( <line21> glossaryCategory.getName() + ""@"" + glossary.getQualifiedName()); <line22> if (LOG.isDebugEnabled()) { <line23> } <line24> } <line25> if (categoryExists(glossaryCategory)) { <line26> throw new AtlasBaseException( <line27> AtlasErrorCode.GLOSSARY_CATEGORY_ALREADY_EXISTS, glossaryCategory.getQualifiedName()); <line28> } <line29> AtlasGlossaryCategory storeObject = dataAccess.save(glossaryCategory); <line30> Map<String, AtlasGlossaryCategory> impactedCategories = <line31> glossaryCategoryUtils.processCategoryRelations( <line32> storeObject, glossaryCategory, GlossaryUtils.RelationshipOperation.CREATE); <line33> if (StringUtils.equals(glossaryCategory.getQualifiedName(), storeObject.getQualifiedName())) { <line34> storeObject = dataAccess.load(glossaryCategory); <line35> } else { <line36> glossaryCategory.setQualifiedName(storeObject.getQualifiedName()); <line37> if (categoryExists(glossaryCategory)) { <line38> throw new AtlasBaseException( <line39> AtlasErrorCode.GLOSSARY_CATEGORY_ALREADY_EXISTS, glossaryCategory.getQualifiedName()); <line40> } <line41> storeObject = dataAccess.save(glossaryCategory); <line42> } <line43> dataAccess.save(impactedCategories.values()); <line44> setInfoForRelations(storeObject); <line45> if (DEBUG_ENABLED) { <line46> } <line47> return storeObject; <line48> } <line49> } <line50> "	 <line46>	Yes
"public class A { <line0> private void userLoggerInfo(HttpServletRequest request) { <line1> if (!checkUserIsLogin(request)) { <line2> return; <line3> } <line4> String requesturl = getRequestSource(request); <line5> String actiontype = getReqValueByGetUrl(request, ""urltype""); <line6> String actionurl = getReqValueByGetUrl(request, ""url""); <line7> String actiondesc = getReqValueByGetUrl(request, ""desc""); <line8> if (!""menuclick"".equals(actiontype) <line9> && !""jumpmain"".equals(actiontype) <line10> && !""jumpapp"".equals(actiontype)) { <line11> return; <line12> } <line13> String ip = request.getRemoteAddr(); <line14> String xip = request.getHeader(""X-Forwarded-For""); <line15> String time = sdf.format(new Date()); <line16> String userid = getUserIdBySession(request); <line17> String userip = getClientIP(ip, xip); <line18> Map<String, String> userInfo = new HashMap<String, String>(); <line19> userInfo.put(""key"", ""ulog""); <line20> userInfo.put(""time"", time); <line21> userInfo.put(""uid"", userid); <line22> userInfo.put(""uip"", userip); <line23> userInfo.put(""rs"", requesturl); <line24> userInfo.put(""type"", actiontype); <line25> userInfo.put(""url"", actionurl); <line26> userInfo.put(""desc"", actiondesc); <line27> userInfo.put( <line28> ""authemails"", <line29> String.valueOf( <line30> request <line31> .getSession(false) <line32> .getAttribute(""apphub.gui.session.login.user.authorize.emailList""))); <line33> userInfo.put( <line34> ""authsystems"", <line35> String.valueOf( <line36> request <line37> .getSession(false) <line38> .getAttribute(""apphub.gui.session.login.user.authorize.systems""))); <line39> } <line40> } <line41> "	 <line14>	No
public class A { <line0> @Override <line1> public void onProcessingTime(long timestamp) throws Exception { <line2> try { <line3> output.emitLatencyMarker( <line4> new LatencyMarker( <line5> processingTimeService.getCurrentProcessingTime(), operatorId, subtaskIndex)); <line6> } catch (Throwable t) { <line7> } <line8> } <line9> } <line10> 	 <line7>	Yes
"public class A { <line0> @Test <line1> public void multilevelPartsWithSameValuesOnDifferentOperationsGeneratesSameHashForKeys() <line2> throws Exception { <line3> mockMultiLevelMetadataKeyId(operation); <line4> mockMultiLevelMetadataKeyId(anotherOperation); <line5> mockTypeResolversInformationModelProperty( <line6> operation, <line7> CATEGORY_NAME, <line8> ""outputResolver"", <line9> ""attributesResolver"", <line10> emptyMap(), <line11> ""keysResolver""); <line12> mockTypeResolversInformationModelProperty( <line13> anotherOperation, <line14> CATEGORY_NAME, <line15> ""outputResolver"", <line16> ""attributesResolver"", <line17> emptyMap(), <line18> ""keysResolver""); <line19> ArtifactDeclaration declaration = getBaseApp(); <line20> ComponentElementDeclaration operationDeclaration = <line21> ((ConstructElementDeclaration) declaration.getGlobalElements().get(1)) <line22> .getComponents() <line23> .get(0); <line24> ComponentElementDeclaration anotherOperationDeclaration = <line25> ((ConstructElementDeclaration) declaration.getGlobalElements().get(1)) <line26> .getComponents() <line27> .get(1); <line28> ParameterGroupElementDeclaration keyGroup = <line29> new ParameterGroupElementDeclaration(METADATA_KEY_GROUP); <line30> operationDeclaration.addParameterGroup(keyGroup); <line31> anotherOperationDeclaration.addParameterGroup(keyGroup); <line32> keyGroup.addParameter(newParam(METADATA_KEY_PART_1, ""localhost"")); <line33> ParameterElementDeclaration partTwo = newParam(METADATA_KEY_PART_2, ""8080""); <line34> keyGroup.addParameter(partTwo); <line35> keyGroup.addParameter(newParam(METADATA_KEY_PART_3, ""/api"")); <line36> MetadataCacheId operationHash = getIdForMetadataKeys(declaration, OPERATION_LOCATION); <line37> MetadataCacheId anotherOperationHash = <line38> getIdForMetadataKeys(declaration, ANOTHER_OPERATION_LOCATION); <line39> assertThat(operationHash, is(anotherOperationHash)); <line40> } <line41> } <line42> "	 <line39>	Yes
"public class A { <line0> @Override <line1> public DLFileShortcut findByUUID_G(String uuid, long groupId) throws NoSuchFileShortcutException { <line2> DLFileShortcut dlFileShortcut = fetchByUUID_G(uuid, groupId); <line3> if (dlFileShortcut == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""uuid=""); <line7> sb.append(uuid); <line8> sb.append("", groupId=""); <line9> sb.append(groupId); <line10> sb.append(""}""); <line11> if (_log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchFileShortcutException(sb.toString()); <line14> } <line15> return dlFileShortcut; <line16> } <line17> } <line18> "	 <line12>	Yes
public class A { <line0> public void exportEEGLabTags(StyledTagSet tagSet, File f) throws SignalMLException { <line1> String contents = convertToString(tagSet); <line2> try { <line3> FileWriter fstream = new FileWriter(f); <line4> fstream.write(contents); <line5> fstream.close(); <line6> } catch (IOException ex) { <line7> throw new ResolvableException(ex); <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> waitForFateOperation_result result = new waitForFateOperation_result(); <line4> if (e instanceof org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException) { <line5> result.sec = (org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException) e; <line6> result.setSecIsSet(true); <line7> msg = result; <line8> } else if (e <line9> instanceof org.apache.accumulo.core.clientImpl.thrift.ThriftTableOperationException) { <line10> result.tope = (org.apache.accumulo.core.clientImpl.thrift.ThriftTableOperationException) e; <line11> result.setTopeIsSet(true); <line12> msg = result; <line13> } else if (e <line14> instanceof org.apache.accumulo.core.clientImpl.thrift.ThriftNotActiveServiceException) { <line15> result.tnase = (org.apache.accumulo.core.clientImpl.thrift.ThriftNotActiveServiceException) e; <line16> result.setTnaseIsSet(true); <line17> msg = result; <line18> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line19> fb.close(); <line20> return; <line21> } else if (e instanceof org.apache.thrift.TApplicationException) { <line22> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line23> msg = (org.apache.thrift.TApplicationException) e; <line24> } else { <line25> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line26> msg = <line27> new org.apache.thrift.TApplicationException( <line28> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line29> } <line30> try { <line31> fcall.sendResponse(fb, msg, msgType, seqid); <line32> } catch (java.lang.Exception ex) { <line33> fb.close(); <line34> } <line35> } <line36> } <line37> 	 <line8>	No
public class A { <line0> public static List<Place> getPlaceListFromRespond(String xml) <line1> throws ParserConfigurationException, SAXException, IOException { <line2> List<Place> pList = new ArrayList<Place>(); <line3> DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); <line4> DocumentBuilder documentBuilder; <line5> InputSource is = new InputSource(new StringReader(xml)); <line6> documentBuilder = builderFactory.newDocumentBuilder(); <line7> Document doc = documentBuilder.parse(is); <line8> NodeList placeNodes = doc.getElementsByTagName(XML_PLACE); <line9> for (int i = 0; i < placeNodes.getLength(); i++) { <line10> try { <line11> pList.add(getPlace(doc, (Element) placeNodes.item(i))); <line12> } catch (Exception e) { <line13> } <line14> } <line15> return pList; <line16> } <line17> } <line18> 	 <line6>	No
public class A { <line0> private void appendAuthnStatementAuthnInstant( <line1> RequestType policyRequest, AssertionType assertion) { <line2> SubjectType parent = getSubject(policyRequest); <line3> String attributeId = XacmlAttributeId.AuthnStatementAuthnInstant; <line4> String dataType = Constants.DataTypeString; <line5> String attributeValue = extractAuthnStatementAuthnInstant(assertion); <line6> AttributeHelper attrHelper = new AttributeHelper(); <line7> attrHelper.appendAttributeToParent( <line8> parent, attributeId, dataType, attributeValue, appendAttributesIfNull); <line9> } <line10> } <line11> 	 <line2>	Yes
"public class A { <line0> @Test <line1> public void testCtor() { <line2> try { <line3> MultiRFileOutputFormatter uut = new MultiRFileOutputFormatter(); <line4> Assert.assertNotNull( <line5> ""MultiRFileOutputFormatter constructor failed to create an instance."", uut); <line6> } finally { <line7> } <line8> } <line9> } <line10> "	 <line2>	Yes
public class A { <line0> public org.talend.mdm.webservice.WSBoolean isPagingAccurate( <line1> org.talend.mdm.webservice.WSInt arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSBoolean _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	 <line2>	Yes
"public class A { <line0> @RequestMapping( <line1> value = ""/rebalance/sentinels/{dcName}/{numOfClusters}"", <line2> method = RequestMethod.POST) <line3> public RetMessage reBalanceSentinels( <line4> @PathVariable String dcName, @PathVariable int numOfClusters) { <line5> try { <line6> List<String> modifiedClusters = <line7> clusterService.reBalanceSentinels(dcName, numOfClusters, true); <line8> return RetMessage.createSuccessMessage(""clusters: "" + jsonTool.encode(modifiedClusters)); <line9> } catch (Exception e) { <line10> return RetMessage.createFailMessage(e.getMessage()); <line11> } <line12> } <line13> } <line14> "	 <line13>	No
"public class A { <line0> public void setInitProject(String currentProjectName) { <line1> try { <line2> this.currentProjectName = currentProjectName; <line3> newProjectName = null; <line4> projectFolder = """"; <line5> comment = null; <line6> copyOldRevisions = Boolean.FALSE; <line7> revisionsCount = null; <line8> separateProject = false; <line9> errorMessage = null; <line10> if (isSupportsBranches()) { <line11> RulesProject project = getCurrentProject(); <line12> currentBranchName = project.getBranch(); <line13> String userName = getUserWorkspace().getUser().getUserName(); <line14> String date = new SimpleDateFormat(""yyyyMMdd"").format(new Date()); <line15> newBranchName = designRepoComments.newBranch(getBusinessName(), userName, date); <line16> } <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> "	 <line4>	No
"public class A { <line0> private void disconnectOnServersLeft(int srvs, int clients) throws Exception { <line1> startGridsMultiThreaded(srvs); <line2> helper.clientMode(true); <line3> startGridsMultiThreaded(srvs, clients); <line4> for (int i = 0; i < GridTestUtils.SF.applyLB(5, 2); i++) { <line5> info(""Iteration: "" + i); <line6> final CountDownLatch disconnectLatch = new CountDownLatch(clients); <line7> final CountDownLatch reconnectLatch = new CountDownLatch(clients); <line8> IgnitePredicate<Event> p = <line9> new IgnitePredicate<Event>() { <line10> @Override <line11> public boolean apply(Event evt) { <line12> if (evt.type() == EVT_CLIENT_NODE_DISCONNECTED) { <line13> disconnectLatch.countDown(); <line14> } else if (evt.type() == EVT_CLIENT_NODE_RECONNECTED) { <line15> reconnectLatch.countDown(); <line16> return false; <line17> } <line18> return true; <line19> } <line20> }; <line21> for (int c = 0; c < clients; c++) { <line22> Ignite client = ignite(srvs + c); <line23> assertTrue(client.configuration().isClientMode()); <line24> client.events().localListen(p, EVT_CLIENT_NODE_DISCONNECTED, EVT_CLIENT_NODE_RECONNECTED); <line25> } <line26> GridTestUtils.runMultiThreaded( <line27> new IgniteInClosure<Integer>() { <line28> @Override <line29> public void apply(Integer threadIdx) { <line30> stopGrid(getTestIgniteInstanceName(threadIdx), true, false); <line31> } <line32> }, <line33> srvs, <line34> ""stop-server""); <line35> ZookeeperDiscoverySpiTestHelper.waitReconnectEvent(log, disconnectLatch); <line36> evts.clear(); <line37> helper.clientMode(false); <line38> startGridsMultiThreaded(0, srvs); <line39> ZookeeperDiscoverySpiTestHelper.waitReconnectEvent(log, reconnectLatch); <line40> waitForTopology(srvs + clients); <line41> } <line42> } <line43> } <line44> "	 <line5>	No
public class A { <line0> private TimerTask scheduleTimer(float period) { <line1> TimerTask task = <line2> new TimerTask() { <line3> @Override <line4> public void run() { <line5> try { <line6> for (Entry<String, Cache<Id, Object>> entry : caches().entrySet()) { <line7> this.tick(entry.getKey(), entry.getValue()); <line8> } <line9> } catch (Throwable e) { <line10> } <line11> } <line12>  <line13> private void tick(String name, Cache<Id, Object> cache) { <line14> long start = System.currentTimeMillis(); <line15> long items = cache.tick(); <line16> long cost = System.currentTimeMillis() - start; <line17> if (cost > LOG_TICK_COST_TIME) { <line18> } <line19> } <line20> }; <line21> this.timer.schedule(task, 0, (long) (period * 1000.0)); <line22> return task; <line23> } <line24> } <line25> 	 <line2>	No
public class A { <line0> private List<PropertiesLocation> parseLocations(List<PropertiesLocation> locations) { <line1> List<PropertiesLocation> answer = new ArrayList<>(); <line2> for (PropertiesLocation location : locations) { <line3> try { <line4> String path = FilePathResolver.resolvePath(location.getPath()); <line5> if (ObjectHelper.isNotEmpty(path)) { <line6> answer.add(new PropertiesLocation(location.getResolver(), path, location.isOptional())); <line7> } <line8> } catch (IllegalArgumentException e) { <line9> if (!ignoreMissingLocation && !location.isOptional()) { <line10> throw e; <line11> } else { <line12> } <line13> } <line14> } <line15> return answer; <line16> } <line17> } <line18> 	 <line1>	No
"public class A { <line0> @Test <line1> public void testProcessing_event_to_task_group() { <line2> int processingID = 4923; <line3> int[] parentIDs = {30, 32}; <line4> int[] childIDs = {34, 36}; <line5> String algorithm = ""MetadataWS testProcessing_event_to_task_group ""; <line6> String description = ""testProcessing_event_to_task_group""; <line7> int expResult = ReturnValue.SUCCESS; <line8> ReturnValue result = <line9> instance.processing_event_to_task_group( <line10> processingID, parentIDs, childIDs, algorithm, description); <line11> Assert.assertEquals(expResult, result.getExitStatus()); <line12> testCount( <line13> ""select count(*) from processing_relationship "" <line14> + ""where (parent_id=4923 AND child_id IN (34,36)) "" <line15> + ""OR (child_id=4923 AND parent_id IN (30,32));"", <line16> 4); <line17> } <line18> } <line19> "	 <line12>	No
"public class A { <line0> @Test <line1> public void testCounterLimitExceeded() throws Exception { <line2> int expectedMax = (COUNTER_LIMIT - 2) / 2; <line3> File f = setUpFlagDir(); <line4> LongRange range = createTestFiles(2, expectedMax + 20, true); <line5> int total = 2 * 2 * (expectedMax + 20); <line6> fmc.setSetFlagFileTimestamp(true); <line7> fmc.setUseFolderTimestamp(true); <line8> fmc.getDefaultCfg().setMaxFlags(expectedMax + 15); <line9> FlagMaker instance = new TestWrappedFlagMaker(fmc); <line10> instance.processFlags(); <line11> int a = f.listFiles().length; <line12> int expectedFlagCount = 0; <line13> for (File file : f.listFiles()) { <line14> if (file.getName().endsWith(""+"" + expectedMax + "".flag"")) { <line15> expectedFlagCount++; <line16> } <line17> } <line18> assertEquals( <line19> ""Unexpected number of flag files with size "" + expectedMax, <line20> (total / expectedMax), <line21> expectedFlagCount); <line22> } <line23> } <line24> "	 <line21>	No
"public class A { <line0> @GET <line1> @Path( <line2> ""{"" <line3> + USERNAME <line4> + ""}/{"" <line5> + MODULE_GROUPID <line6> + ""}/{"" <line7> + MODULE_ARTIFACTID <line8> + ""}/{"" <line9> + MODULE_VERSION <line10> + ""}/{"" <line11> + COMMIT_ID <line12> + ""}"") <line13> public Response getProperties( <line14> @PathParam(USERNAME) String user, <line15> @PathParam(MODULE_GROUPID) String groupId, <line16> @PathParam(MODULE_ARTIFACTID) String artifactId, <line17> @PathParam(MODULE_VERSION) String version, <line18> @PathParam(COMMIT_ID) String commitId, <line19> @Nullable @QueryParam(TestMode.TEST_MODE_PROPERTY) String testMode) <line20> throws IOException { <line21> if (inTestMode(testMode)) { <line22> return Response.ok(new ArrayList<ICoordinatedCluster>()).build(); <line23> } <line24> CoordinatedStack stack = <line25> coordinator.findCoordinatedStack(commitId, artifactId, groupId, version, user); <line26> if (stack == null) { <line27> return Response.ok().entity(new ArrayList<ICoordinatedCluster>()).build(); <line28> } else if (stack.getSetupState() != SetupStackState.SetUp) { <line29> return Response.ok().entity(new ArrayList<ICoordinatedCluster>()).build(); <line30> } <line31> return Response.ok(stack.getClusters()).build(); <line32> } <line33> } <line34> "	 <line33>	No
public class A { <line0> @Override <line1> public void shutDownGracefully(GracefulShutdownCallback callback) { <line2> if (this.gracefulShutdown == null) { <line3> callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE); <line4> return; <line5> } <line6> this.gracefulShutdownCallback.set(callback); <line7> this.gracefulShutdown.shutdown(); <line8> this.gracefulShutdown.addShutdownListener((success) -> notifyGracefulCallback(success)); <line9> } <line10> } <line11> 	 <line6>	Yes
public class A { <line0> public void open() throws IOException { <line1> this.amqpFileUploadNotificationReceive.open(); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @BeforeClass <line1> public static void setupClient() { <line2> S3Client = getS3Client(); <line3> if (S3Client.doesBucketExistV2(TEST_BUCKET_NAME)) { <line4> clearBucket(TEST_BUCKET_NAME); <line5> } else { <line6> S3Client.createBucket(TEST_BUCKET_NAME); <line7> } <line8> } <line9> } <line10> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public List<RangerPolicy> getDefaultRangerPolicies() throws Exception { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> List<RangerPolicy> ret = super.getDefaultRangerPolicies(); <line5> String pathResourceName = RangerHdfsAuthorizer.KEY_RESOURCE_PATH; <line6> for (RangerPolicy defaultPolicy : ret) { <line7> if (defaultPolicy.getName().contains(""all"")) { <line8> if (StringUtils.isNotBlank(lookUpUser)) { <line9> RangerPolicyItem policyItemForLookupUser = new RangerPolicyItem(); <line10> policyItemForLookupUser.setUsers(Collections.singletonList(lookUpUser)); <line11> policyItemForLookupUser.setAccesses( <line12> Collections.singletonList(new RangerPolicyItemAccess(ACCESS_TYPE_READ))); <line13> policyItemForLookupUser.setDelegateAdmin(false); <line14> defaultPolicy.getPolicyItems().add(policyItemForLookupUser); <line15> } <line16> RangerPolicy.RangerPolicyResource pathPolicyResource = <line17> defaultPolicy.getResources().get(pathResourceName); <line18> if (pathPolicyResource != null) { <line19> List<RangerServiceDef.RangerResourceDef> resourceDefs = serviceDef.getResources(); <line20> RangerServiceDef.RangerResourceDef pathResourceDef = null; <line21> for (RangerServiceDef.RangerResourceDef resourceDef : resourceDefs) { <line22> if (resourceDef.getName().equals(pathResourceName)) { <line23> pathResourceDef = resourceDef; <line24> break; <line25> } <line26> } <line27> if (pathResourceDef != null) { <line28> String pathSeparator = <line29> pathResourceDef <line30> .getMatcherOptions() <line31> .get(RangerPathResourceMatcher.OPTION_PATH_SEPARATOR); <line32> if (StringUtils.isBlank(pathSeparator)) { <line33> pathSeparator = <line34> Character.toString(RangerPathResourceMatcher.DEFAULT_PATH_SEPARATOR_CHAR); <line35> } <line36> String value = pathSeparator + RangerAbstractResourceMatcher.WILDCARD_ASTERISK; <line37> pathPolicyResource.setValue(value); <line38> } else { <line39> } <line40> } else { <line41> } <line42> } <line43> } <line44> try { <line45> RangerServiceDefHelper serviceDefHelper = new RangerServiceDefHelper(serviceDef); <line46> for (List<RangerServiceDef.RangerResourceDef> aHierarchy : <line47> serviceDefHelper.filterHierarchies_containsOnlyMandatoryResources( <line48> RangerPolicy.POLICY_TYPE_ACCESS)) { <line49> RangerPolicy policy = getPolicyForKMSAudit(aHierarchy); <line50> if (policy != null) { <line51> ret.add(policy); <line52> } <line53> } <line54> } catch (Exception e) { <line55> } <line56> if (LOG.isDebugEnabled()) { <line57> } <line58> return ret; <line59> } <line60> } <line61> "	 <line3>	Yes
public class A { <line0> @Override <line1> public void write(Message message) throws Exception { <line2> if (LOG.isTraceEnabled()) { <line3> } <line4> write(Collections.singletonList(message)); <line5> } <line6> } <line7> 	 <line4>	No
"public class A { <line0> private String createMemberInSalesForce(String accessToken, Member member) { <line1> WebResource resource = createObjectsResource(""/Account/""); <line2> JSONObject memberJson = salesForceAdapter.createSaleForceRecordFromMember(member); <line3> ClientResponse response = doPostRequest(resource, memberJson, accessToken); <line4> checkAuthorization(response); <line5> JSONObject result = checkResponse(response, 201, ""Error creating member in SalesForce""); <line6> return result.optString(""id""); <line7> } <line8> } <line9> "	 <line3>	No
"public class A { <line0> private boolean _isBundleInstalled(Bundle bundle, URL url, String location) throws IOException { <line1> try (InputStream inputStream = url.openStream(); <line2> JarInputStream jarInputStream = new JarInputStream(inputStream)) { <line3> Manifest manifest = jarInputStream.getManifest(); <line4> Attributes attributes = manifest.getMainAttributes(); <line5> String symbolicName = attributes.getValue(Constants.BUNDLE_SYMBOLICNAME); <line6> Version version = new Version(attributes.getValue(Constants.BUNDLE_VERSION)); <line7> for (Bundle installedBundle : _bundleContext.getBundles()) { <line8> if (symbolicName.equals(installedBundle.getSymbolicName()) <line9> && version.equals(installedBundle.getVersion()) <line10> && !location.equals(installedBundle.getLocation())) { <line11> if (_log.isInfoEnabled()) { <line12> StringBundler sb = new StringBundler(7); <line13> sb.append(""Skipping installation of ""); <line14> sb.append(symbolicName); <line15> sb.append("" with version ""); <line16> sb.append(version.toString()); <line17> sb.append("" in ""); <line18> sb.append(bundle.getSymbolicName()); <line19> sb.append("" because an identical bundle exists""); <line20> } <line21> return true; <line22> } <line23> } <line24> } <line25> return false; <line26> } <line27> } <line28> "	 <line20>	Yes
public class A { <line0> @Override <line1> public void inform(Event event) { <line2> if (event instanceof InsertBreak) { <line3> InsertBreak insertActivity = (InsertBreak) event; <line4> if (!insertActivity.getNewVehicle().isReturnToDepot()) { <line5> if (insertActivity.getIndex() >= insertActivity.getVehicleRoute().getActivities().size()) { <line6> insertActivity <line7> .getVehicleRoute() <line8> .getEnd() <line9> .setLocation(insertActivity.getActivity().getLocation()); <line10> } <line11> } <line12> VehicleRoute vehicleRoute = ((InsertBreak) event).getVehicleRoute(); <line13> if (!vehicleRoute.isEmpty()) { <line14> if (vehicleRoute.getVehicle() != ((InsertBreak) event).getNewVehicle()) { <line15> if (vehicleRoute.getVehicle().getBreak() != null) { <line16> boolean removed = <line17> vehicleRoute.getTourActivities().removeJob(vehicleRoute.getVehicle().getBreak()); <line18> } <line19> } <line20> } <line21> insertActivity <line22> .getVehicleRoute() <line23> .getTourActivities() <line24> .addActivity(insertActivity.getIndex(), ((InsertBreak) event).getActivity()); <line25> } <line26> } <line27> } <line28> 	 <line3>	No
"public class A { <line0> @Override <line1> public void init() { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> super.init(); <line5> Map<String, String> evalOptions = conditionDef.getEvaluatorOptions(); <line6> if (MapUtils.isNotEmpty(evalOptions)) { <line7> attributeName = evalOptions.get(""attributeName""); <line8> } <line9> if (LOG.isDebugEnabled()) { <line10> } <line11> } <line12> } <line13> "	 <line3>	Yes
public class A { <line0> public static Short readShort(DataInput in) throws IOException { <line1> InternalDataSerializer.checkIn(in); <line2> Short value = in.readShort(); <line3> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line4> } <line5> return value; <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> public void loadAll(List<Contract> contracts, List<MappedContract> mpContracts) { <line1> if (mpContracts != null) { <line2> for (MappedContract mpContract : mpContracts) { <line3> mappedContracts.putIfAbsent( <line4> mpContract.getGbpContractId(), mpContract.getFaasSecurityRulesId()); <line5> } <line6> } <line7> if (contracts != null) { <line8> for (Contract contract : contracts) { <line9> ulnDatastoreUtil.submitSecurityGroupsToDs(initSecurityGroupBuilder(contract).build()); <line10> } <line11> } <line12> } <line13> } <line14> 	 <line7>	No
"public class A { <line0> private void tryOperation(Request build, int retryCount, int numberOfRecords) throws IOException { <line1> Response execute = null; <line2> try { <line3> execute = asyncHttpClient.newCall(build).execute(); <line4> if (execute.code() != 200) { <line5> if (retryCount > 0) { <line6> tryOperation(build, retryCount - 1, numberOfRecords); <line7> return; <line8> } <line9> cloudWatchClient.putMetricDataAsync( <line10> new PutMetricDataRequest() <line11> .withNamespace(""rakam-webhook"") <line12> .withMetricData( <line13> new MetricDatum() <line14> .withMetricName(""request-error"") <line15> .withValue(Double.valueOf(numberOfRecords)))); <line16> } else { <line17> cloudWatchClient.putMetricDataAsync( <line18> new PutMetricDataRequest() <line19> .withNamespace(""rakam-webhook"") <line20> .withMetricData( <line21> new MetricDatum() <line22> .withMetricName(""request-success"") <line23> .withValue(Double.valueOf(numberOfRecords)))); <line24> cloudWatchClient.putMetricDataAsync( <line25> new PutMetricDataRequest() <line26> .withNamespace(""rakam-webhook"") <line27> .withMetricData( <line28> new MetricDatum() <line29> .withMetricName(""request-latency"") <line30> .withValue( <line31> Double.valueOf( <line32> execute.receivedResponseAtMillis() <line33> - execute.sentRequestAtMillis())))); <line34> } <line35> } catch (Throwable e) { <line36> if (retryCount > 0) { <line37> tryOperation(build, retryCount - 1, numberOfRecords); <line38> } else { <line39> cloudWatchClient.putMetricDataAsync( <line40> new PutMetricDataRequest() <line41> .withNamespace(""rakam-webhook"") <line42> .withMetricData( <line43> new MetricDatum() <line44> .withMetricName(""request-error"") <line45> .withValue(Double.valueOf(numberOfRecords)))); <line46> } <line47> } finally { <line48> if (execute != null) { <line49> execute.close(); <line50> } <line51> slice.reset(); <line52> } <line53> } <line54> } <line55> "	 <line47>	No
"public class A { <line0> public boolean generateMKFromKeySecureMK(String password, byte[] key) throws Throwable { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> init(); <line4> String encryptedMasterKey = encryptMasterKey(password, key); <line5> String savedKey = saveEncryptedMK(paddingString + "","" + encryptedMasterKey, daoManager); <line6> if (savedKey != null && !savedKey.trim().equals("""")) { <line7> return true; <line8> } <line9> if (logger.isDebugEnabled()) { <line10> } <line11> return false; <line12> } <line13> } <line14> "	 <line2>	Yes
"public class A { <line0> public boolean addContainer(Container<?> container) throws StorageContainerException { <line1> Preconditions.checkNotNull(container, ""container cannot be null""); <line2> long containerId = container.getContainerData().getContainerID(); <line3> if (containerMap.putIfAbsent(containerId, container) == null) { <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> container.getContainerData().commitSpace(); <line7> return true; <line8> } else { <line9> throw new StorageContainerException( <line10> ""Container already exists with "" + ""container Id "" + containerId, <line11> ContainerProtos.Result.CONTAINER_EXISTS); <line12> } <line13> } <line14> } <line15> "	 <line10>	No
public class A { <line0> public String getOAuthLogoutUrl(final HttpServletRequest servletRequest) { <line1> final HttpServletRequest request = (HttpServletRequest) servletRequest; <line2> final HttpSession session = request.getSession(false); <line3> if (session == null) { <line4> return null; <line5> } <line6> OAuthData oAuthData = (OAuthData) session.getAttribute(Configuration.SESSION_OAUTH_DATA); <line7> if (oAuthData == null) { <line8> return null; <line9> } <line10> ClientRequest clientRequest = <line11> new ClientRequest( <line12> Configuration.instance().getPropertyValue(Configuration.OAUTH_PROPERTY_LOGOUT_URL)); <line13> clientRequest.queryParameter(Configuration.OAUTH_ID_TOKEN_HINT, oAuthData.getIdToken()); <line14> clientRequest.queryParameter( <line15> Configuration.OAUTH_POST_LOGOUT_REDIRECT_URI, constructRedirectUrl(request)); <line16> session.removeAttribute(Configuration.SESSION_OAUTH_DATA); <line17> try { <line18> return clientRequest.getUri(); <line19> } catch (Exception ex) { <line20> } <line21> return null; <line22> } <line23> } <line24> 	 <line11>	No
public class A { <line0> @Override <line1> @RequiredUIAccess <line2> protected void onBeforeDocumentChange(@Nonnull DocumentEvent e) { <line3> super.onBeforeDocumentChange(e); <line4> if (myDiffChanges.isEmpty()) return; <line5> List<Document> documents = ContainerUtil.map(getEditors(), Editor::getDocument); <line6> Side side = Side.fromValue(documents, e.getDocument()); <line7> if (side == null) { <line8> return; <line9> } <line10> LineRange lineRange = DiffUtil.getAffectedLineRange(e); <line11> int shift = DiffUtil.countLinesShift(e); <line12> List<SimpleDiffChange> invalid = new ArrayList<>(); <line13> for (SimpleDiffChange change : myDiffChanges) { <line14> if (change.processChange(lineRange.start, lineRange.end, shift, side)) { <line15> invalid.add(change); <line16> } <line17> } <line18> if (!invalid.isEmpty()) { <line19> myDiffChanges.removeAll(invalid); <line20> myInvalidDiffChanges.addAll(invalid); <line21> } <line22> } <line23> } <line24> 	 <line8>	Yes
public class A { <line0> @Override <line1> public void updateHeartbeat(final Long nodId) { <line2> final ONode node = nodeDAO.get(nodId); <line3> if (!lastHeartBeatTime.equals(node.getHeartbeat().truncatedTo(ChronoUnit.MILLIS))) { <line4> } <line5> lastHeartBeatTime = Instant.now().truncatedTo(ChronoUnit.MILLIS); <line6> node.setHeartbeat(lastHeartBeatTime); <line7> nodeDAO.update(node); <line8> } <line9> } <line10> 	 <line4>	Yes
"public class A { <line0> ProctorStore createStoreWithGlobalCache(final String branchName, final ProctorStore store) { <line1> if (globalCacheStore == null) { <line2> return store; <line3> } <line4> final Environment environment = Environment.fromName(branchName); <line5> Preconditions.checkNotNull( <line6> environment, ""branch name"" + branchName + "" should be trunk, qa, or production""); <line7> return new GlobalCachingProctorStore(store, globalCacheStore, environment); <line8> } <line9> } <line10> "	 <line2>	Yes
public class A { <line0> @Override <line1> public void onDeleted(Floatingip floatingIP, Neutron oldNeutron, Neutron newNeutron) { <line2> ReadWriteTransaction rwTx = dataProvider.newReadWriteTransaction(); <line3> Utils.removeNat(rwTx, floatingIP); <line4> try { <line5> rwTx.submit().get(); <line6> } catch (InterruptedException | ExecutionException e) { <line7> } <line8> } <line9> } <line10> 	 <line1>	No
"public class A { <line0> public WPSResponseHandler getResponseHandler(WPSResponse response, Toolbox toolbox) { <line1> WPSResponseHandler ret = null; <line2> if (response.getResponseType().contains(""vnd.ogc.se"")) { <line3> ret = new WPSServiceErrorHandler(response); <line4> } else if (response.getResponseType().contains(""image"")) { <line5> ret = new WPSImageResponseHandler(response); <line6> } else if (response.getResponseType().contains(""xml"")) { <line7> WpsToolbox wpsToolbox = toolbox.getPluginToolboxRegistry().getPluginToolbox(WpsToolbox.class); <line8> ret = wpsToolbox.createGmlResponseHandler(response); <line9> } else if (response.getResponseType().contains(""zip"") <line10> && response.getResponseType().contains(""shape"")) { <line11> ret = new WPSShapefileResponseHandler(response); <line12> } else { <line13> ret = new WPSTextResponseHandler(response); <line14> } <line15> return ret; <line16> } <line17> } <line18> "	 <line16>	No
public class A { <line0> private Future<CommandConsumer> doCreateCommandConsumer( <line1> final String tenantId, <line2> final String deviceId, <line3> final String gatewayId, <line4> final Handler<CommandContext> commandHandler, <line5> final Duration lifespan, <line6> final SpanContext context) { <line7> final Duration sanitizedLifespan = <line8> lifespan == null <line9> || lifespan.isNegative() <line10> || lifespan.getSeconds() > (Long.MAX_VALUE / 1000_000_000L) <line11> ? Duration.ofSeconds(-1) <line12> : lifespan; <line13> final CommandHandlerWrapper commandHandlerWrapper = <line14> new CommandHandlerWrapper( <line15> tenantId, deviceId, gatewayId, commandHandler, Vertx.currentContext()); <line16> commandHandlers.putCommandHandler(commandHandlerWrapper); <line17> final Instant lifespanStart = Instant.now(); <line18> return commandRouterClient <line19> .registerCommandConsumer(tenantId, deviceId, adapterInstanceId, sanitizedLifespan, context) <line20> .onFailure( <line21> thr -> { <line22> commandHandlers.removeCommandHandler(tenantId, deviceId); <line23> }) <line24> .map( <line25> v -> { <line26> return (CommandConsumer) <line27> new CommandConsumer() { <line28> @Override <line29> public Future<Void> close(final SpanContext spanContext) { <line30> return removeCommandConsumer( <line31> commandHandlerWrapper, sanitizedLifespan, lifespanStart, spanContext); <line32> } <line33> }; <line34> }); <line35> } <line36> } <line37> 	 <line13>	Yes
"public class A { <line0> @Override <line1> protected String getCommitID(String repositoryId, Version version) { <line2> try { <line3> GitlabProject project = <line4> gitlabAPI.getProject(repositoryId.split(""/"")[0], repositoryId.split(""/"")[1]); <line5> GitlabBranch gitlabBranch = gitlabAPI.getBranch(project, version.getReference()); <line6> return gitlabBranch.getCommit().getId(); <line7> } catch (IOException ex) { <line8> } <line9> return null; <line10> } <line11> } <line12> "	 <line8>	Yes
public class A { <line0> private static void readComposite(Element element, TemplateWidget parent) <line1> throws TemplateIOException { <line2> TemplateComposite templateComposite = new TemplateComposite(parent); <line3> readWidgetCommonProperties(element, templateComposite, false, ELEMENT_COMPOSITE); <line4> Attribute numberOfColumnsAttribute = element.attribute(ATTRIBUTE_NUMBEROFCOLUMNS); <line5> if ((numberOfColumnsAttribute != null) && (numberOfColumnsAttribute.getText() != null)) { <line6> templateComposite.setNumberOfColumns(readInteger(numberOfColumnsAttribute.getText())); <line7> } <line8> Attribute equalColumnsAttribute = element.attribute(ATTRIBUTE_EQUALCOLUMNS); <line9> if ((equalColumnsAttribute != null) && (equalColumnsAttribute.getText() != null)) { <line10> templateComposite.setEqualColumns(readBoolean(equalColumnsAttribute.getText())); <line11> } <line12> for (Iterator<?> i = element.elementIterator(); i.hasNext(); ) { <line13> Element childElement = (Element) i.next(); <line14> readWidget(childElement, templateComposite); <line15> } <line16> } <line17> } <line18> 	 <line4>	No
public class A { <line0> @Override <line1> public String call() { <line2> try { <line3> prepareSuiteWrapper(); <line4> init(); <line5> process(); <line6> save(); <line7> } catch (StorageException | JMSException | ValidatorException e) { <line8> FinishedSuiteProcessingMessage message = <line9> new FinishedSuiteProcessingMessage(Status.FAILED, objectToRunWrapper.getCorrelationId()); <line10> message.addError(e.getMessage()); <line11> messagesSender.sendMessage(message); <line12> } finally { <line13> cleanup(); <line14> } <line15> return objectToRunWrapper.getCorrelationId(); <line16> } <line17> } <line18> 	 <line15>	No
"public class A { <line0> public ServerInstanceList createServerInstanceList(Node node, long timestamp) { <line1> Objects.requireNonNull(node, ""node""); <line2> if (timestamp < 0) { <line3> return new ServerInstanceList(); <line4> } <line5> Application application = node.getApplication(); <line6> Set<AgentInfo> agentInfos = <line7> agentInfoService.getAgentsByApplicationNameWithoutStatus(application.getName(), timestamp); <line8> if (CollectionUtils.isEmpty(agentInfos)) { <line9> return new ServerInstanceList(); <line10> } <line11> agentInfos = filterAgentInfos(agentInfos, timestamp, node); <line12> ServerBuilder builder = new ServerBuilder(); <line13> builder.addAgentInfo(agentInfos); <line14> return builder.build(); <line15> } <line16> } <line17> "	 <line9>	Yes
"public class A { <line0> public static void executeApiTask( <line1> BlockService blockService, <line2> ExecutorService executorService, <line3> DbClient dbClient, <line4> VirtualArray varray, <line5> Project project, <line6> VirtualPool vpool, <line7> VirtualPoolCapabilityValuesWrapper capabilities, <line8> TaskList taskList, <line9> String task, <line10> BlockConsistencyGroup consistencyGroup, <line11> ArrayList<String> requestedTypes, <line12> VolumeCreate param, <line13> BlockServiceApi blockServiceImpl) { <line14> CreateVolumeSchedulingThread schedulingThread = <line15> new CreateVolumeSchedulingThread( <line16> blockService, <line17> varray, <line18> project, <line19> vpool, <line20> capabilities, <line21> taskList, <line22> task, <line23> consistencyGroup, <line24> requestedTypes, <line25> param, <line26> blockServiceImpl); <line27> try { <line28> executorService.execute(schedulingThread); <line29> } catch (Exception e) { <line30> for (TaskResourceRep taskObj : taskList.getTaskList()) { <line31> String message = <line32> ""Failed to execute volume creation API task for resource "" <line33> + taskObj.getResource().getId(); <line34> taskObj.setMessage(message); <line35> Volume volume = dbClient.queryObject(Volume.class, taskObj.getResource().getId()); <line36> volume.setInactive(true); <line37> dbClient.updateObject(volume); <line38> } <line39> } <line40> } <line41> } <line42> "	 <line34>	Yes
"public class A { <line0> @Bean(name = BEAN_NAME_EMBEDDED_ORACLE, destroyMethod = ""stop"") <line1> public OracleContainer oracle(ConfigurableEnvironment environment, OracleProperties properties) { <line2> OracleContainer oracle = <line3> new OracleContainer(properties.dockerImage) <line4> .withUsername(properties.getUser()) <line5> .withPassword(properties.getPassword()) <line6> .withInitScript(properties.initScriptPath); <line7> oracle = (OracleContainer) configureCommonsAndStart(oracle, properties, log); <line8> registerOracleEnvironment(oracle, environment, properties); <line9> return oracle; <line10> } <line11> } <line12> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public void createTestCaseStepAction(TestCaseStepAction testCaseStepAction) <line2> throws CerberusException { <line3> StringBuilder query = new StringBuilder(); <line4> query <line5> .append( <line6> ""INSERT INTO testcasestepaction (`test`, `testcase`, `stepId`, `actionId`, `sort`, "") <line7> .append( <line8> ""`conditionOperator`, `conditionValue1`, `conditionValue2`, `conditionValue3`,"" <line9> + "" `conditionOptions`, `action`, "") <line10> .append( <line11> ""`value1`, `value2`, `value3`, `options`, `IsFatal`, `description`,"" <line12> + "" `screenshotfilename`, `usrCreated`) ""); <line13> query.append(""VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""); <line14> if (LOG.isDebugEnabled()) { <line15> } <line16> try (Connection connection = this.databaseSpring.connect(); <line17> PreparedStatement preStat = connection.prepareStatement(query.toString()); ) { <line18> int i = 1; <line19> preStat.setString(i++, testCaseStepAction.getTest()); <line20> preStat.setString(i++, testCaseStepAction.getTestcase()); <line21> preStat.setInt(i++, testCaseStepAction.getStepId()); <line22> preStat.setInt(i++, testCaseStepAction.getActionId()); <line23> preStat.setInt(i++, testCaseStepAction.getSort()); <line24> preStat.setString(i++, testCaseStepAction.getConditionOperator()); <line25> preStat.setString(i++, testCaseStepAction.getConditionValue1()); <line26> preStat.setString(i++, testCaseStepAction.getConditionValue2()); <line27> preStat.setString(i++, testCaseStepAction.getConditionValue3()); <line28> preStat.setString(i++, testCaseStepAction.getConditionOptions().toString()); <line29> preStat.setString(i++, testCaseStepAction.getAction()); <line30> preStat.setString(i++, testCaseStepAction.getValue1()); <line31> preStat.setString(i++, testCaseStepAction.getValue2()); <line32> preStat.setString(i++, testCaseStepAction.getValue3()); <line33> preStat.setString(i++, testCaseStepAction.getOptions().toString()); <line34> preStat.setBoolean(i++, testCaseStepAction.isFatal()); <line35> preStat.setString(i++, testCaseStepAction.getDescription()); <line36> preStat.setString(i++, testCaseStepAction.getScreenshotFilename()); <line37> preStat.setString( <line38> i++, <line39> testCaseStepAction.getUsrCreated() == null ? """" : testCaseStepAction.getUsrCreated()); <line40> preStat.executeUpdate(); <line41> } catch (SQLException exception) { <line42> } <line43> } <line44> } <line45> "	 <line36>	No
public class A { <line0> private InetAddress getAddressByName(String host) { <line1> try { <line2> return InetAddress.getByName(host); <line3> } catch (Exception e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> private void resetHosts(long managementServerId, long lastPingSecondsAfter) { <line1> SearchCriteria<HostVO> sc = HostsForReconnectSearch.create(); <line2> sc.setParameters(""server"", managementServerId); <line3> sc.setParameters(""lastPinged"", lastPingSecondsAfter); <line4> sc.setParameters(""status"", Status.Disconnected, Status.Down, Status.Alert); <line5> StringBuilder sb = new StringBuilder(); <line6> List<HostVO> hosts = lockRows(sc, null, true); <line7> for (HostVO host : hosts) { <line8> host.setManagementServerId(null); <line9> update(host.getId(), host); <line10> sb.append(host.getId()); <line11> sb.append("" ""); <line12> } <line13> if (s_logger.isTraceEnabled()) { <line14> } <line15> } <line16> } <line17> "	 <line14>	Yes
public class A { <line0> @Override <line1> public void close() throws IOException { <line2> checkJournalWriterOpen(); <line3> mOutputStream.close(); <line4> completeLog(mCurrentLog, mNextSequenceNumber); <line5> } <line6> } <line7> 	 <line5>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public Map<String, Object> formatQuestionValuePickerDetails( <line2> QuestionsDto questionDto, Session session) throws DAOException { <line3> LOGGER.entry(""begin formatQuestionValuePickerDetails()""); <line4> Map<String, Object> questionFormat = new LinkedHashMap<>(); <line5> List<QuestionResponseSubTypeDto> responseSubTypeList = null; <line6> List<LinkedHashMap<String, Object>> valuePickerList = new ArrayList<>(); <line7> try { <line8> responseSubTypeList = <line9> session <line10> .createQuery( <line11> ""from QuestionResponseSubTypeDto QRSTDTO"" <line12> + "" where QRSTDTO.responseTypeId= :respType"") <line13> .setInteger(""respType"", questionDto.getId()) <line14> .list(); <line15> if ((responseSubTypeList != null) && !responseSubTypeList.isEmpty()) { <line16> for (QuestionResponseSubTypeDto subType : responseSubTypeList) { <line17> LinkedHashMap<String, Object> valuePickerMap = new LinkedHashMap<>(); <line18> valuePickerMap.put( <line19> ""text"", StringUtils.isEmpty(subType.getText()) ? """" : subType.getText()); <line20> valuePickerMap.put( <line21> ""value"", StringUtils.isEmpty(subType.getValue()) ? """" : subType.getValue()); <line22> valuePickerMap.put( <line23> ""detail"", StringUtils.isEmpty(subType.getDetail()) ? """" : subType.getDetail()); <line24> valuePickerMap.put( <line25> ""exclusive"", <line26> (StringUtils.isEmpty(subType.getExclusive()) <line27> || subType.getExclusive().equalsIgnoreCase(StudyMetaDataConstants.YES)) <line28> ? true <line29> : false); <line30> valuePickerList.add(valuePickerMap); <line31> } <line32> } <line33> questionFormat.put(""textChoices"", valuePickerList); <line34> } catch (Exception e) { <line35> } <line36> LOGGER.exit(""formatQuestionValuePickerDetails() :: Ends""); <line37> return questionFormat; <line38> } <line39> } <line40> "	 <line35>	Yes
"public class A { <line0> private Optional<TamrDerogListEntry> convertWatchlistItemToTamrDerogListEntry( <line1> WatchlistItem watchlistItem) { <line2> TamrDerogListEntry derogListEntry = new TamrDerogListEntry(); <line3> WatchlistItemSpec itemSpec; <line4> try { <line5> itemSpec = mapper.readValue(watchlistItem.getItemData(), WatchlistItemSpec.class); <line6> } catch (IOException e) { <line7> return Optional.empty(); <line8> } <line9> for (WatchlistTerm term : itemSpec.getTerms()) { <line10> if (term.getField().equals(""firstName"")) { <line11> derogListEntry.setFirstName(term.getValue()); <line12> } else if (term.getField().equals(""lastName"")) { <line13> derogListEntry.setLastName(term.getValue()); <line14> } else if (term.getField().equals(""dob"")) { <line15> try { <line16> SimpleDateFormat parser = new SimpleDateFormat(""yyyy-MM-dd""); <line17> derogListEntry.setDob(parser.parse(term.getValue())); <line18> } catch (ParseException e) { <line19> } <line20> } else if (term.getField().equals(""documentType"") <line21> || term.getField().equals(""documentNumber"")) { <line22> TamrDocument document; <line23> if (derogListEntry.getDocuments() == null) { <line24> document = new TamrDocument(); <line25> derogListEntry.setDocuments(Collections.singletonList(document)); <line26> } else { <line27> document = derogListEntry.getDocuments().get(0); <line28> } <line29> if (term.getField().equals(""documentType"")) { <line30> document.setDocumentType(term.getValue()); <line31> } else if (term.getField().equals(""documentNumber"")) { <line32> document.setDocumentId(term.getValue()); <line33> } <line34> } else { <line35> } <line36> } <line37> if (derogListEntry.getLastName() == null) { <line38> return Optional.empty(); <line39> } <line40> String itemIdStr = Long.toString(watchlistItem.getId()); <line41> derogListEntry.setGtasId(itemIdStr); <line42> derogListEntry.setDerogId(itemIdStr); <line43> return Optional.of(derogListEntry); <line44> } <line45> } <line46> "	 <line7>	Yes
public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSession session) <line2> throws ProcessException { <line3> updateMapping(context); <line4> final List<FlowFile> flowFiles = session.get(5); <line5> if (flowFiles.isEmpty()) { <line6> return; <line7> } <line8> final ComponentLog logger = getLogger(); <line9> final int maxBufferSize = <line10> context.getProperty(MAX_BUFFER_SIZE).asDataSize(DataUnit.B).intValue(); <line11> for (FlowFile flowFile : flowFiles) { <line12> if (flowFile.getSize() > maxBufferSize) { <line13> session.transfer(flowFile, REL_FAILURE); <line14> continue; <line15> } <line16> final StopWatch stopWatch = new StopWatch(true); <line17> flowFile = session.write(flowFile, new ReplaceTextCallback(context, flowFile, maxBufferSize)); <line18> session <line19> .getProvenanceReporter() <line20> .modifyContent(flowFile, stopWatch.getElapsed(TimeUnit.MILLISECONDS)); <line21> session.transfer(flowFile, REL_SUCCESS); <line22> } <line23> } <line24> } <line25> 	 <line22>	No
public class A { <line0> private void removeAndDeletePoolsOnOtherOwners(List<Pool> existingPools, Pool pool) { <line1> List<Pool> toRemove = new LinkedList<>(); <line2> for (Pool existing : existingPools) { <line3> if (!existing.getOwner().equals(pool.getOwner())) { <line4> toRemove.add(existing); <line5> if (existing.getType() == PoolType.NORMAL || existing.getType() == PoolType.BONUS) { <line6> deletePool(existing); <line7> } <line8> } <line9> } <line10> existingPools.removeAll(toRemove); <line11> } <line12> } <line13> 	 <line5>	Yes
public class A { <line0> public Map<String, String> toMap() { <line1> Map<String, String> configMap = new HashMap<>(); <line2> configMap.put(Segment.SEGMENT_NAME, _segmentName); <line3> configMap.put(Segment.SEGMENT_TYPE, _segmentType.toString()); <line4> configMap.put(Segment.START_TIME, Long.toString(_startTime)); <line5> configMap.put(Segment.END_TIME, Long.toString(_endTime)); <line6> configMap.put(Segment.TIME_UNIT, _timeUnit != null ? _timeUnit.name() : null); <line7> configMap.put(Segment.INDEX_VERSION, _indexVersion); <line8> configMap.put(Segment.TOTAL_DOCS, Long.toString(_totalDocs)); <line9> configMap.put(Segment.CRC, Long.toString(_crc)); <line10> configMap.put(Segment.CREATION_TIME, Long.toString(_creationTime)); <line11> if (_partitionMetadata != null) { <line12> try { <line13> String partitionMetadataJson = _partitionMetadata.toJsonString(); <line14> configMap.put(Segment.PARTITION_METADATA, partitionMetadataJson); <line15> } catch (IOException e) { <line16> } <line17> } <line18> if (_segmentUploadStartTime > 0) { <line19> configMap.put(Segment.SEGMENT_UPLOAD_START_TIME, Long.toString(_segmentUploadStartTime)); <line20> } <line21> if (_crypterName != null) { <line22> configMap.put(Segment.CRYPTER_NAME, _crypterName); <line23> } <line24> if (_customMap != null) { <line25> try { <line26> configMap.put(Segment.CUSTOM_MAP, JsonUtils.objectToString(_customMap)); <line27> } catch (JsonProcessingException e) { <line28> throw new RuntimeException(e); <line29> } <line30> } <line31> if (_rawTableName != null) { <line32> configMap.put(Segment.TABLE_NAME, _rawTableName); <line33> } <line34> return configMap; <line35> } <line36> } <line37> 	 <line16>	Yes
"public class A { <line0> public void startRoutine(Device device, String utterance) <line1> throws IOException, URISyntaxException, InterruptedException { <line2> JsonAutomation found = null; <line3> String deviceLocale = """"; <line4> JsonAutomation[] routines = getRoutines(); <line5> if (routines == null) { <line6> return; <line7> } <line8> for (JsonAutomation routine : routines) { <line9> if (routine != null) { <line10> if (routine.sequence != null) { <line11> List<JsonAutomation.Trigger> triggers = <line12> Objects.requireNonNullElse(routine.triggers, List.of()); <line13> for (JsonAutomation.Trigger trigger : triggers) { <line14> Payload payload = trigger.payload; <line15> if (payload == null) { <line16> continue; <line17> } <line18> String payloadUtterance = payload.utterance; <line19> if (payloadUtterance != null && payloadUtterance.equalsIgnoreCase(utterance)) { <line20> found = routine; <line21> deviceLocale = payload.locale; <line22> break; <line23> } <line24> } <line25> } <line26> } <line27> } <line28> if (found != null) { <line29> String sequenceJson = gson.toJson(found.sequence); <line30> JsonStartRoutineRequest request = new JsonStartRoutineRequest(); <line31> request.behaviorId = found.automationId; <line32> String deviceType = ""\""deviceType\"":\""ALEXA_CURRENT_DEVICE_TYPE\""""; <line33> String newDeviceType = ""\""deviceType\"":\"""" + device.deviceType + ""\""""; <line34> sequenceJson = <line35> sequenceJson.replace( <line36> deviceType.subSequence(0, deviceType.length()), <line37> newDeviceType.subSequence(0, newDeviceType.length())); <line38> String deviceSerial = ""\""deviceSerialNumber\"":\""ALEXA_CURRENT_DSN\""""; <line39> String newDeviceSerial = ""\""deviceSerialNumber\"":\"""" + device.serialNumber + ""\""""; <line40> sequenceJson = <line41> sequenceJson.replace( <line42> deviceSerial.subSequence(0, deviceSerial.length()), <line43> newDeviceSerial.subSequence(0, newDeviceSerial.length())); <line44> String customerId = ""\""customerId\"":\""ALEXA_CUSTOMER_ID\""""; <line45> String newCustomerId = <line46> ""\""customerId\"":\"""" + getCustomerId(device.deviceOwnerCustomerId) + ""\""""; <line47> sequenceJson = <line48> sequenceJson.replace( <line49> customerId.subSequence(0, customerId.length()), <line50> newCustomerId.subSequence(0, newCustomerId.length())); <line51> String locale = ""\""locale\"":\""ALEXA_CURRENT_LOCALE\""""; <line52> String newlocale = <line53> deviceLocale != null && !deviceLocale.isEmpty() <line54> ? ""\""locale\"":\"""" + deviceLocale + ""\"""" <line55> : ""\""locale\"":null""; <line56> sequenceJson = <line57> sequenceJson.replace( <line58> locale.subSequence(0, locale.length()), newlocale.subSequence(0, newlocale.length())); <line59> request.sequenceJson = sequenceJson; <line60> String requestJson = gson.toJson(request); <line61> makeRequest(""POST"", alexaServer + ""/api/behaviors/preview"", requestJson, true, true, null, 3); <line62> } else { <line63> } <line64> } <line65> } <line66> "	 <line63>	Yes
public class A { <line0> @Override <line1> public void injectCacheResult(Object result) { <line2> results = (ArrayList<List<String>>) result; <line3> resultInjectedFromCache = true; <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> 	 <line0>	No
public class A { <line0> @Override <line1> public void entriesDeleted(Collection<String> entries) { <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> public Set<String> getOpenInstancesInternal() { <line1> Set<String> openInstances = <line2> Sets.newHashSet(modifyConfig.getContainedNamespaces(REGISTRATION_NS)); <line3> return openInstances; <line4> } <line5> } <line6> 	 <line1>	No
"public class A { <line0> private void createCache2(Ignite ig, CacheAtomicityMode mode) { <line1> final CacheConfiguration<Integer, Organization> cfg = new CacheConfiguration<>(""Org"" + ""11""); <line2> cfg.setAtomicityMode(mode); <line3> final IgniteCache<Integer, Organization> cache = <line4> ig.getOrCreateCache(cfg).withKeepBinary().withAllowAtomicOpsInTx(); <line5> try (Transaction tx = ig.transactions().txStart()) { <line6> for (int i = 0; i < 10; i++) { <line7> cache.put(i, new Organization(i, ""Organization-"" + i)); <line8> if (i % 2 == 0) cache.put(i, new Organization(i, ""Organization-updated-"" + i)); <line9> if (i % 5 == 0) cache.remove(i); <line10> } <line11> tx.commit(); <line12> } <line13> } <line14> } <line15> "	 <line1>	Yes
public class A { <line0> @Override <line1> public void info(final String desc) { <line2> call( <line3> new Runnable() { <line4> public void run() { <line5> } <line6> }); <line7> } <line8> } <line9> 	 <line7>	No
"public class A { <line0> @RequestMapping(value = ""/{id}"", method = RequestMethod.DELETE) <line1> public ResponseEntity<E> delete(@PathVariable int id) { <line2> try { <line3> E entityToDelete = this.service.findById(id); <line4> this.service.delete(entityToDelete); <line5> final String proxyClassName = entityToDelete.getClass().getSimpleName(); <line6> final String simpleClassName = StringUtils.substringBefore(proxyClassName, ""_$$_""); <line7> return new ResponseEntity<E>(HttpStatus.NO_CONTENT); <line8> } catch (Exception e) { <line9> return new ResponseEntity<E>(HttpStatus.NOT_FOUND); <line10> } <line11> } <line12> } <line13> "	 <line9>	Yes
public class A { <line0> public void printMap(AbstractPostNormalizerWithVocabularyMap processor) { <line1> for (VocabularyEntry entry : processor.vocabulary.getEntries()) { <line2> } <line3> } <line4> } <line5> 	 <line3>	No
"public class A { <line0> @Bean <line1> @Conditional(InsightsSAMLBeanInitializationCondition.class) <line2> public FilterChainProxy samlFilter() throws Exception { <line3> AuthenticationUtils.setSecurityFilterchain( <line4> new DefaultSecurityFilterChain( <line5> new AntPathRequestMatcher(""/metadata/**""), metadataDisplayFilter())); <line6> AuthenticationUtils.setSecurityFilterchain( <line7> new DefaultSecurityFilterChain( <line8> new AntPathRequestMatcher(""/saml/login/**""), samlEntryPoint())); <line9> AuthenticationUtils.setSecurityFilterchain( <line10> new DefaultSecurityFilterChain( <line11> new AntPathRequestMatcher(""/saml/SSO/**""), samlWebSSOProcessingFilter())); <line12> AuthenticationUtils.setSecurityFilterchain( <line13> new DefaultSecurityFilterChain( <line14> new AntPathRequestMatcher(""/saml/logout/**""), samlLogoutFilter())); <line15> AuthenticationUtils.setSecurityFilterchain( <line16> new DefaultSecurityFilterChain( <line17> new AntPathRequestMatcher(""/saml/SingleLogout/**""), samlLogoutProcessingFilter())); <line18> AuthenticationUtils.setSecurityFilterchain( <line19> new DefaultSecurityFilterChain( <line20> new AntPathRequestMatcher(""/user/insightsso/**""), insightsSSOProcessingFilter())); <line21> List<Filter> filters = new ArrayList<>(); <line22> filters.add(0, new InsightsCustomCsrfFilter()); <line23> filters.add(1, new InsightsCrossScriptingFilter()); <line24> filters.add(2, insightsServiceProcessingFilter()); <line25> filters.add(3, new InsightsResponseHeaderWriterFilter()); <line26> AuthenticationUtils.setSecurityFilterchain( <line27> new DefaultSecurityFilterChain(new AntPathRequestMatcher(""/**""), filters)); <line28> return new FilterChainProxy(AuthenticationUtils.getSecurityFilterchains()); <line29> } <line30> } <line31> "	 <line23>	No
public class A { <line0> protected void doSuccessResponse(final SipServletResponse res) <line1> throws ServletException, IOException { <line2> final EventSource source = SessionUtils.getEventSource(res); <line3> if (source != null) { <line4> if (source instanceof SIPCallImpl) { <line5> final SIPCallImpl call = (SIPCallImpl) source; <line6> try { <line7> call.doResponse(res, null); <line8> } catch (final Exception e) { <line9> } <line10> if (SIPHelper.isInitial(res.getRequest())) { <line11> source.dispatch(new SIPAnsweredEventImpl<Call>((SIPCall) source, res)); <line12> } <line13> return; <line14> } else if (source instanceof Framework) { <line15> source.dispatch(new SIPAnsweredEventImpl<Framework>((Framework) source, res)); <line16> return; <line17> } else if (source instanceof Registration) { <line18> source.dispatch(new SIPAnsweredEventImpl<Registration>((Registration) source, res)); <line19> return; <line20> } else if (source instanceof Subscription) { <line21> source.dispatch(new SIPAnsweredEventImpl<Subscription>((Subscription) source, res)); <line22> return; <line23> } else { <line24> source.dispatch(new SIPAnsweredEventImpl(source, res)); <line25> } <line26> } else { <line27> } <line28> } <line29> } <line30> 	 <line3>	No
public class A { <line0> private NaturalLanguage deriveNaturalLanguage( <line1> ObjectContext context, PkgDumpExportJobSpecification specification) { <line2> if (StringUtils.isNotBlank(specification.getNaturalLanguageCode())) { <line3> return NaturalLanguage.tryGetByCode(context, specification.getNaturalLanguageCode()) <line4> .orElseGet( <line5> () -> { <line6> return NaturalLanguage.getEnglish(context); <line7> }); <line8> } <line9> return NaturalLanguage.getEnglish(context); <line10> } <line11> } <line12> 	 <line0>	No
"public class A { <line0> @Override <line1> public String getProcessId(Process process) { <line2> long end = TimeService.currentTimeMillis() + service.startupProcessTimeout; <line3> while (process.isAlive() && TimeService.currentTimeMillis() <= end) { <line4> try { <line5> Thread.sleep(500); <line6> } catch (InterruptedException e) { <line7> Thread.currentThread().interrupt(); <line8> } <line9> } <line10> File[] pidFiles = <line11> FileSystems.getDefault() <line12> .getPath(service.home, ""pids"") <line13> .toFile() <line14> .listFiles(new PidFileNameFilter()); <line15> if (pidFiles.length != 1) { <line16> return super.getProcessId(process); <line17> } <line18> byte[] buffer; <line19> try { <line20> buffer = Files.readAllBytes(pidFiles[0].toPath()); <line21> } catch (IOException e) { <line22> return super.getProcessId(process); <line23> } <line24> return new String(buffer).trim(); <line25> } <line26> } <line27> "	 <line7>	Yes
public class A { <line0> @Deactivate <line1> public void deactivate() { <line2> for (EncoderEngine engine : activeEncoder) { <line3> engine.close(); <line4> } <line5> } <line6> } <line7> 	 <line1>	No
public class A { <line0> public BadQueryHistory getBadQueriesForProject(String project) throws IOException { <line1> BadQueryHistory badQueryHistory = <line2> getStore().getResource(getResourcePathForProject(project), BAD_QUERY_INSTANCE_SERIALIZER); <line3> if (badQueryHistory == null) { <line4> badQueryHistory = new BadQueryHistory(project); <line5> } <line6> return badQueryHistory; <line7> } <line8> } <line9> 	 <line1>	No
"public class A { <line0> void createIndex(SqlgGraph sqlgGraph, SchemaTable schemaTable, String name) { <line1> StringBuilder sql = new StringBuilder(""CREATE ""); <line2> if (IndexType.UNIQUE.equals(getIndexType())) { <line3> sql.append(""UNIQUE ""); <line4> } <line5> sql.append(""INDEX ""); <line6> SqlDialect sqlDialect = sqlgGraph.getSqlDialect(); <line7> sql.append(sqlDialect.maybeWrapInQoutes(name)); <line8> sql.append("" ON ""); <line9> sql.append(sqlDialect.maybeWrapInQoutes(schemaTable.getSchema())); <line10> sql.append("".""); <line11> sql.append(sqlDialect.maybeWrapInQoutes(schemaTable.getTable())); <line12> if (this.indexType.isGIN()) { <line13> sql.append("" USING GIN""); <line14> } <line15> sql.append("" (""); <line16> List<PropertyColumn> props = getProperties(); <line17> if (IndexType.GIN_FULLTEXT.equals(getIndexType().getName())) { <line18> sql.append(""to_tsvector(""); <line19> String conf = indexType.getProperties().get(IndexType.GIN_CONFIGURATION); <line20> if (conf != null) { <line21> sql.append(""'"").append(conf).append(""'""); <line22> sql.append("",""); <line23> } <line24> int count = 1; <line25> for (PropertyColumn property : props) { <line26> sql.append(sqlDialect.maybeWrapInQoutes(property.getName())); <line27> if (count++ < props.size()) { <line28> sql.append("" || ' ' || ""); <line29> } <line30> } <line31> sql.append("")""); <line32> } else { <line33> int count = 1; <line34> for (PropertyColumn property : props) { <line35> sql.append(sqlDialect.maybeWrapInQoutes(property.getName())); <line36> if (property.getPropertyType().isString() <line37> && sqlgGraph.getSqlDialect().requiresIndexLengthLimit()) { <line38> sql.append(""(191)""); <line39> } <line40> if (count++ < props.size()) { <line41> sql.append("", ""); <line42> } <line43> } <line44> } <line45> sql.append("")""); <line46> if (sqlDialect.needsSemicolon()) { <line47> sql.append("";""); <line48> } <line49> if (logger.isDebugEnabled()) { <line50> } <line51> Connection conn = sqlgGraph.tx().getConnection(); <line52> try (Statement stmt = conn.createStatement()) { <line53> stmt.execute(sql.toString()); <line54> } catch (SQLException e) { <line55> throw new RuntimeException(e); <line56> } <line57> } <line58> } <line59> "	 <line51>	No
public class A { <line0> public void trace(final Marker marker, final String message, final Object object) { <line1> } <line2> } <line3> 	 <line2>	No
public class A { <line0> public static boolean deleteQuietly(final Path path) { <line1> try { <line2> if (!Files.isDirectory(path)) { <line3> return Files.deleteIfExists(path); <line4> } else { <line5> Files.walkFileTree(path, deleteDirVisitor); <line6> } <line7> return true; <line8> } catch (final IOException ioe) { <line9> return false; <line10> } <line11> } <line12> } <line13> 	 <line10>	No
"public class A { <line0> @Override <line1> public void process(final InputStream in, final OutputStream out) throws IOException { <line2> try { <line3> final RecordSchema writeSchema = <line4> determineRecordSchema(writerFactory, flowAttributes, valueIncluded); <line5> try (final RecordSetWriter writer = <line6> writerFactory.createWriter(getLogger(), writeSchema, out, Collections.emptyMap())) { <line7> int i = 0; <line8> writer.beginRecordSet(); <line9> for (; i < keysPerFlowFile && kvIter.hasNext(); i++) { <line10> Map.Entry<Key, Value> kv = kvIter.next(); <line11> final Key key = kv.getKey(); <line12> Map<String, Object> data = new HashMap<>(); <line13> data.put(""row"", key.getRow().toString()); <line14> data.put(""columnFamily"", key.getColumnFamily().toString()); <line15> data.put(""columnQualifier"", key.getColumnQualifier().toString()); <line16> data.put(""columnVisibility"", key.getColumnVisibility().toString()); <line17> data.put(""timestamp"", key.getTimestamp()); <line18> if (valueIncluded) { <line19> data.put(""value"", Objects.isNull(kv.getValue()) ? null : kv.getValue().toString()); <line20> } <line21> Record record = new MapRecord(writeSchema, data); <line22> writer.write(record); <line23> } <line24> recordCounter.add(i); <line25> final WriteResult writeResult = writer.finishRecordSet(); <line26> attributes.put(""record.count"", String.valueOf(i)); <line27> attributes.put(CoreAttributes.MIME_TYPE.key(), writer.getMimeType()); <line28> attributes.putAll(writeResult.getAttributes()); <line29> } <line30> } catch (SchemaNotFoundException e) { <line31> getLogger() <line32> throw new IOException(e); <line33> } <line34> } <line35> } <line36> "	 <line32>	Yes
public class A { <line0> @Override <line1> public void initialize() { <line2> super.initialize(); <line3> cavityTemperatureFuture = <line4> scheduler.scheduleWithFixedDelay( <line5> () -> { <line6> String operationState = getOperationState(); <line7> boolean manuallyUpdateCavityTemperature = this.manuallyUpdateCavityTemperature; <line8> if (STATE_OPERATION_RUN.equals(operationState)) { <line9> getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE) <line10> .ifPresent( <line11> c -> { <line12> if (manuallyUpdateCavityTemperature) { <line13> updateChannel(c.getUID()); <line14> } else { <line15> } <line16> }); <line17> } <line18> }, <line19> CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY, <line20> CAVITY_TEMPERATURE_SCHEDULER_PERIOD, <line21> TimeUnit.SECONDS); <line22> } <line23> } <line24> 	 <line9>	No
"public class A { <line0> private CompletableFuture<Void> handleRequestMessage(BackupRequestMessage requestMsg) { <line1> Preconditions.checkState(!mBackupTracker.inProgress(), ""Backup in progress""); <line2> CompletableFuture<Void> msgFuture = CompletableFuture.completedFuture(null); <line3> mBackupTracker.reset(); <line4> mBackupTracker.update(new BackupStatus(requestMsg.getBackupId(), BackupState.Initiating)); <line5> mBackupTracker.updateHostname( <line6> NetworkAddressUtils.getLocalHostName( <line7> (int) <line8> ServerConfiguration.global() <line9> .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS))); <line10> startHeartbeatThread(); <line11> if (!mBackupTimeoutTask.cancel(true)) { <line12> mBackupTracker.updateError(new BackupException(""Journal has been resumed due to a time-out"")); <line13> return msgFuture; <line14> } <line15> mBackupFuture = <line16> mExecutorService.submit( <line17> () -> { <line18> mBackupTracker.updateState(BackupState.Transitioning); <line19> try { <line20> CatchupFuture catchupFuture = <line21> mJournalSystem.catchup(requestMsg.getJournalSequences()); <line22> CompletableFuture.runAsync(() -> catchupFuture.waitTermination()) <line23> .get(BACKUP_ABORT_AFTER_TRANSITION_TIMEOUT_MS, TimeUnit.MILLISECONDS); <line24> mBackupTracker.updateState(BackupState.Running); <line25> AlluxioURI backupUri = <line26> takeBackup(requestMsg.getBackupRequest(), mBackupTracker.getEntryCounter()); <line27> mBackupTracker.updateBackupUri(backupUri); <line28> mBackupTracker.updateState(BackupState.Completed); <line29> try { <line30> mBackupProgressFuture.get(); <line31> } catch (Exception e) { <line32> } <line33> } catch (InterruptedException e) { <line34> mBackupTracker.updateError(new BackupException(""Backup interrupted at worker"", e)); <line35> } catch (Exception e) { <line36> mBackupTracker.updateError( <line37> new BackupException( <line38> String.format(""Backup failed at worker: %s"", e.getMessage()), e)); <line39> } finally { <line40> enforceResumeJournals(); <line41> } <line42> }); <line43> return msgFuture; <line44> } <line45> } <line46> "	 <line36>	Yes
"public class A { <line0> public synchronized WorkItemServiceState reportSuccess() throws IOException { <line1> checkState(!finalStateSent, ""cannot reportSuccess after sending a final state""); <line2> checkState(worker != null, ""setWorker should be called before reportSuccess""); <line3> WorkItemStatus status = createStatusUpdate(true); <line4> if (worker instanceof SourceOperationExecutor) { <line5> SourceOperationResponse response = ((SourceOperationExecutor) worker).getResponse(); <line6> if (response != null) { <line7> status.setSourceOperationResponse(response); <line8> } <line9> } <line10> return execute(status); <line11> } <line12> } <line13> "	 <line10>	Yes
"public class A { <line0> public String generateId(String p_idType, String p_idPrefix) { <line1> final IdType idType = IdType.fromString(p_idType); <line2> if (idType != null) { <line3> return generateId(idType, p_idPrefix); <line4> } else { <line5> } <line6> return """"; <line7> } <line8> } <line9> "	 <line7>	No
public class A { <line0> private boolean handleResponse( <line1> NukiBaseResponse nukiBaseResponse, String channelUID, String command) { <line2> if (nukiBaseResponse.getStatus() == 200 && nukiBaseResponse.isSuccess()) { <line3> return true; <line4> } else if (nukiBaseResponse.getStatus() != 200) { <line5> } else if (!nukiBaseResponse.isSuccess()) { <line6> } <line7> updateStatus( <line8> ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, nukiBaseResponse.getMessage()); <line9> Channel channelLock = thing.getChannel(NukiBindingConstants.CHANNEL_SMARTLOCK_LOCK); <line10> if (channelLock != null) { <line11> updateState(channelLock.getUID(), OnOffType.OFF); <line12> } <line13> Channel channelLockState = thing.getChannel(NukiBindingConstants.CHANNEL_SMARTLOCK_STATE); <line14> if (channelLockState != null) { <line15> updateState( <line16> channelLockState.getUID(), new DecimalType(NukiBindingConstants.LOCK_STATES_UNDEFINED)); <line17> } <line18> Channel channelDoorState = thing.getChannel(NukiBindingConstants.CHANNEL_SMARTLOCK_DOOR_STATE); <line19> if (channelDoorState != null) { <line20> updateState( <line21> channelDoorState.getUID(), <line22> new DecimalType(NukiBindingConstants.DOORSENSOR_STATES_UNKNOWN)); <line23> } <line24> startReInitJob(); <line25> return false; <line26> } <line27> } <line28> 	 <line8>	No
public class A { <line0> public static String generateCidFromAddrSpec(String addrSpec) { <line1> String cid = CID_URL_SCHEME; <line2> try { <line3> cid += URLEncoder.encode(addrSpec, StandardCharsets.UTF_8.name()); <line4> } catch (UnsupportedEncodingException e) { <line5> } <line6> return cid; <line7> } <line8> } <line9> 	 <line2>	No
public class A { <line0> public static int getItemCount(ResultModel model) { <line1> if (model instanceof Countable) { <line2> return ((Countable) model).size(); <line3> } <line4> Class modelClass = model.getClass(); <line5> List<Field> fields = modelFieldMap.get(modelClass.getName()); <line6> if (fields == null) { <line7> fields = new ArrayList<Field>(); <line8> Field[] declaredFields = modelClass.getDeclaredFields(); <line9> for (int i = 0; i < declaredFields.length; i++) { <line10> Field field = declaredFields[i]; <line11> Class<?> fieldClass = field.getType(); <line12> if (Collection.class.isAssignableFrom(fieldClass) <line13> || Map.class.isAssignableFrom(fieldClass) <line14> || Countable.class.isAssignableFrom(fieldClass) <line15> || fieldClass.isArray()) { <line16> field.setAccessible(true); <line17> fields.add(field); <line18> } <line19> } <line20> List<Field> old_fields = modelFieldMap.putIfAbsent(modelClass.getName(), fields); <line21> if (old_fields != null) { <line22> fields = old_fields; <line23> } <line24> } <line25> int count = 0; <line26> try { <line27> for (int i = 0; i < fields.size(); i++) { <line28> Field field = fields.get(i); <line29> if (!field.isAccessible()) { <line30> field.setAccessible(true); <line31> } <line32> Object value = field.get(model); <line33> if (value != null) { <line34> if (value instanceof Collection) { <line35> count += ((Collection) value).size(); <line36> } else if (value.getClass().isArray()) { <line37> count += Array.getLength(value); <line38> } else if (value instanceof Map) { <line39> count += ((Map) value).size(); <line40> } else if (value instanceof Countable) { <line41> count += ((Countable) value).size(); <line42> } <line43> } <line44> } <line45> } catch (Exception e) { <line46> } <line47> return count > 0 ? count : 1; <line48> } <line49> } <line50> 	 <line4>	No
"public class A { <line0> @Override <line1> public Optional<Account> getSingleAccount(String accountId) throws IOException { <line2> String url = buildCanvasUrl(""accounts/"" + accountId, Collections.emptyMap()); <line3> Response response = canvasMessenger.getSingleResponseFromCanvas(oauthToken, url); <line4> if (response.getErrorHappened() || response.getResponseCode() != 200) { <line5> return Optional.empty(); <line6> } <line7> return responseParser.parseToObject(Account.class, response); <line8> } <line9> } <line10> "	 <line3>	No
public class A { <line0> @Override <line1> protected void doStart() throws Exception { <line2> super.doStart(); <line3> for (Lifecycle lifecycle : lifecycleCallable()) { <line4> if (lifecycle.getLifecycleState().canStart()) { <line5> try { <line6> lifecycle.start(); <line7> } catch (Throwable th) { <line8> if (!logpass(th)) { <line9> throw th; <line10> } <line11> } <line12> } <line13> } <line14> } <line15> } <line16> 	 <line1>	No
public class A { <line0> public void ageOff() { <line1> HashSet<Long> oldTxs = new HashSet<>(); <line2> synchronized (this) { <line3> long time = timeSource.currentTimeMillis(); <line4> if (minTime < time && time - minTime >= ageOffTime) { <line5> for (Entry<Long, Long> entry : candidates.entrySet()) { <line6> if (time - entry.getValue() >= ageOffTime) { <line7> oldTxs.add(entry.getKey()); <line8> } <line9> } <line10> candidates.keySet().removeAll(oldTxs); <line11> updateMinTime(); <line12> } <line13> } <line14> for (Long txid : oldTxs) { <line15> try { <line16> store.reserve(txid); <line17> try { <line18> switch (store.getStatus(txid)) { <line19> case NEW: <line20> case FAILED: <line21> case SUCCESSFUL: <line22> store.delete(txid); <line23> break; <line24> default: <line25> break; <line26> } <line27> } finally { <line28> store.unreserve(txid, 0); <line29> } <line30> } catch (Exception e) { <line31> } <line32> } <line33> } <line34> } <line35> 	 <line32>	No
public class A { <line0> public Comparison compare(final TransferItem item) { <line1> if (null == comparison) { <line2> return Comparison.equal; <line3> } <line4> return comparison.get(item); <line5> } <line6> } <line7> 	 <line2>	Yes
public class A { <line0> public static com.liferay.asset.kernel.model.AssetCategorySoap moveCategory( <line1> long categoryId, <line2> long parentCategoryId, <line3> long vocabularyId, <line4> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line5> throws RemoteException { <line6> try { <line7> com.liferay.asset.kernel.model.AssetCategory returnValue = <line8> AssetCategoryServiceUtil.moveCategory( <line9> categoryId, parentCategoryId, vocabularyId, serviceContext); <line10> return com.liferay.asset.kernel.model.AssetCategorySoap.toSoapModel(returnValue); <line11> } catch (Exception exception) { <line12> throw new RemoteException(exception.getMessage()); <line13> } <line14> } <line15> } <line16> 	 <line12>	Yes
"public class A { <line0> @Override <line1> public Serializable execute() { <line2> jobStarted.countDown(); <line3> boolean fail; <line4> assert ignite != null; <line5> UUID locId = ignite.configuration().getNodeId(); <line6> assert locId != null; <line7> try { <line8> fail = ses.waitForAttribute(""fail"", 0); <line9> } catch (InterruptedException e) { <line10> throw new IgniteException(""Got interrupted while waiting for attribute to be set."", e); <line11> } <line12> if (fail) { <line13> ses.setAttribute(""fail"", false); <line14> assert nodeRef.get().id().equals(locId); <line15> throw new IgniteException(""Job exception.""); <line16> } <line17> assert !nodeRef.get().id().equals(locId); <line18> Integer res = Integer.parseInt(this.<String>argument(0)); <line19> return res; <line20> } <line21> } <line22> "	 <line16>	No
"public class A { <line0> @Override <line1> public GetVersionedInput.Response getVersionedInputs(GetVersionedInput request) <line2> throws InvalidProtocolBufferException { <line3> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line4> ExperimentRunEntity experimentRunObj = <line5> session.get(ExperimentRunEntity.class, request.getId()); <line6> if (experimentRunObj != null) { <line7> ExperimentRun experimentRun = experimentRunObj.getProtoObject(); <line8> if (experimentRun.getVersionedInputs() != null <line9> && experimentRun.getVersionedInputs().getRepositoryId() != 0 <line10> && config.populateConnectionsBasedOnPrivileges) { <line11> experimentRun = <line12> checkVersionInputBasedOnPrivileges(experimentRun, new HashSet<>(), new HashSet<>()); <line13> } <line14> return GetVersionedInput.Response.newBuilder() <line15> .setVersionedInputs(experimentRun.getVersionedInputs()) <line16> .build(); <line17> } else { <line18> String errorMessage = ""ExperimentRun not found for given ID : "" + request.getId(); <line19> throw new NotFoundException(errorMessage); <line20> } <line21> } catch (Exception ex) { <line22> if (ModelDBUtils.needToRetry(ex)) { <line23> return getVersionedInputs(request); <line24> } else { <line25> throw ex; <line26> } <line27> } <line28> } <line29> } <line30> "	 <line14>	Yes
"public class A { <line0> private static AmqpStartMessage decodeStart(IoBufferEx in) throws ProtocolDecoderException { <line1> Logger logger = LoggerFactory.getLogger(SERVICE_AMQP_PROXY_LOGGER); <line2> if (logger.isDebugEnabled()) { <line3> String s = "".decodeStart(): Raw bytes - "" + getHexDump(in); <line4> } <line5> AmqpStartMessage message = new AmqpStartMessage(); <line6> short versionMajor = in.getUnsigned(); <line7> short versionMinor = in.getUnsigned(); <line8> AmqpTable serverProperties = getTable(in); <line9> String mechanisms = getLongString(in); <line10> String locales = getLongString(in); <line11> message.setVersionMajor((byte) versionMajor); <line12> message.setVersionMinor((byte) versionMinor); <line13> message.setServerProperties(serverProperties); <line14> message.setSecurityMechanisms(mechanisms); <line15> message.setLocales(locales); <line16> if (logger.isDebugEnabled()) { <line17> } <line18> return message; <line19> } <line20> } <line21> "	 <line19>	No
"public class A { <line0> public void shutdown() throws Exception { <line1> this.toBeShutdown = true; <line2> try { <line3> mainThread.interrupt(); <line4> } catch (Exception e) { <line5> e.printStackTrace(); <line6> throw new Exception(""A listener could not be shutdown. Exception ["" + e + ""]""); <line7> } <line8> .""); <line9> } <line10> } <line11> "	 <line5>	No
public class A { <line0> @Override <line1> public int authenticateByScreenName( <line2> long companyId, <line3> String screenName, <line4> String password, <line5> Map<String, String[]> headerMap, <line6> Map<String, String[]> parameterMap) { <line7> User user = _userLocalService.fetchUserByScreenName(companyId, screenName); <line8> if (user == null) { <line9> if (_log.isWarnEnabled()) { <line10> } <line11> } else { <line12> _setSambaPasswords(user, password); <line13> } <line14> return SUCCESS; <line15> } <line16> } <line17> 	 <line10>	Yes
"public class A { <line0> @Override <line1> public void storeJSON(final String directory, final String name, final String description) { <line2> if (directory == null || directory.equals(EMPTY_DAG_DIRECTORY)) { <line3> return; <line4> } <line5> final File file = new File(directory, name + "".json""); <line6> file.getParentFile().mkdirs(); <line7> try (PrintWriter printWriter = new PrintWriter(file)) { <line8> printWriter.println(toString()); <line9> printWriter.close(); <line10> } catch (IOException e) { <line11> } <line12> } <line13> } <line14> "	 <line3>	No
public class A { <line0> private Bundle copy0(Path source, Path to) { <line1> Path from = source; <line2> merge(from, to); <line3> return this; <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void channelInactive(ChannelHandlerContext ctx) throws Exception { <line2> if (LOG.isTraceEnabled()) { <line3> } <line4> NettyCamelState state = getState(ctx, null); <line5> Exchange exchange = state != null ? state.getExchange() : null; <line6> boolean doneUoW = state != null ? state.isDone() : false; <line7> producer.getCorrelationManager().removeState(ctx, ctx.channel()); <line8> producer.getAllChannels().remove(ctx.channel()); <line9> if (exchange != null && !disconnecting) { <line10> NettyConfiguration configuration = producer.getConfiguration(); <line11> if (configuration.isSync() && !doneUoW && !messageReceived && !exceptionHandled) { <line12> exceptionHandled = true; <line13> String address = configuration.getAddress(); <line14> if (LOG.isDebugEnabled()) { <line15> } <line16> if (!configuration.isDisconnect()) { <line17> exchange.setException( <line18> new CamelExchangeException( <line19> ""No response received from remote server: "" + address, exchange)); <line20> } <line21> state.callbackDoneOnce(false); <line22> } <line23> } <line24> disconnecting = false; <line25> super.channelInactive(ctx); <line26> } <line27> } <line28> "	 <line10>	No
public class A { <line0> @Override <line1> public void onStop(TestInfo testInfo) { <line2> for (TestListener listener : listeners) { <line3> try { <line4> listener.onStop(testInfo); <line5> } catch (RuntimeException ex) { <line6> } <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
public class A { <line0> private boolean ensureNotNull(Class<?> c) { <line1> UserTask userTask = c.getAnnotation(UserTask.class); <line2> boolean isNull = userTask == null; <line3> if (isNull) { <line4> } <line5> return !isNull; <line6> } <line7> } <line8> 	 <line6>	No
public class A { <line0> public void onComplete( <line1> java.util.List< <line2> org.apache.airavata.model.appcatalog.appdeployment.ApplicationDeploymentDescription> <line3> o) { <line4> getApplicationDeploymentsForAppModuleAndGroupResourceProfile_result result = <line5> new getApplicationDeploymentsForAppModuleAndGroupResourceProfile_result(); <line6> result.success = o; <line7> try { <line8> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line9> } catch (org.apache.thrift.transport.TTransportException e) { <line10> fb.close(); <line11> } catch (java.lang.Exception e) { <line12> onError(e); <line13> } <line14> } <line15> } <line16> 	 <line10>	Yes
"public class A { <line0> @SuppressWarnings(""checkstyle:IllegalCatch"") <line1> public void start() { <line2> final SimpleTaskRetryLooper looper = <line3> new SimpleTaskRetryLooper(STARTUP_LOOP_TICK, STARTUP_LOOP_MAX_RETRIES); <line4> try { <line5> notificationRegistration = <line6> looper.loopUntilNoException( <line7> () -> notificationService.registerNotificationListener(DropTestRpcSender.this)); <line8> } catch (Exception e) { <line9> throw new IllegalStateException(""DropTest startup fail! Try again later."", e); <line10> } <line11> } <line12> } <line13> "	 <line1>	No
"public class A { <line0> private void apply(final JndiConsumer bean, final EnvEntry newEntry, final String componentName) { <line1> EnvEntry entry = bean.getEnvEntryMap().get(newEntry.getName()); <line2> if (entry == null) { <line3> entry = bean.getEnvEntryMap().get(""java:comp/env/"" + newEntry.getName()); <line4> } <line5> if (entry != null) { <line6> if (SystemInstance.get().getOptions().get(""envprops.override"", false)) { <line7> entry.setEnvEntryValue(newEntry.getEnvEntryValue()); <line8> } <line9> return; <line10> } <line11> bean.getEnvEntry().add(newEntry); <line12> } <line13> } <line14> "	 <line7>	Yes
"public class A { <line0> public byte[] signRequest( <line1> PrivateKey privateKey, Certificate[] certificates, byte[] request, String algorithm) { <line2> try { <line3> Security.addProvider(new BouncyCastleProvider()); <line4> X509Certificate signCert = (X509Certificate) certificates[0]; <line5> List<X509Certificate> certList = new ArrayList<>(); <line6> certList.add(signCert); <line7> CMSSignedDataGenerator generator = new CMSSignedDataGenerator(); <line8> String varAlgorithm = null; <line9> if (algorithm != null && !algorithm.isEmpty()) { <line10> varAlgorithm = algorithm; <line11> } else { <line12> if (Configuration.getInstance().getSO().toLowerCase().indexOf(""indows"") > 0) { <line13> varAlgorithm = ""SHA256withRSA""; <line14> } else { <line15> varAlgorithm = ""SHA512withRSA""; <line16> } <line17> } <line18> SignerInfoGenerator signerInfoGenerator = <line19> new JcaSimpleSignerInfoGeneratorBuilder().build(varAlgorithm, privateKey, signCert); <line20> generator.addSignerInfoGenerator(signerInfoGenerator); <line21> Store<?> certStore = new JcaCertStore(certList); <line22> generator.addCertificates(certStore); <line23> CMSTypedData data = new CMSProcessableByteArray(request); <line24> CMSSignedData signed = generator.generate(data, true); <line25> return signed.getEncoded(); <line26> } catch (CMSException <line27> | IOException <line28> | OperatorCreationException <line29> | CertificateEncodingException ex) { <line30> throw new CertificateCoreException(ex.getMessage()); <line31> } <line32> } <line33> } <line34> "	 <line3>	Yes
public class A { <line0> protected void assertRangeStatistic(RangeStatisticImpl stat) throws InterruptedException { <line1> assertEquals(0, stat.getCurrent()); <line2> assertEquals(0, stat.getLowWaterMark()); <line3> assertEquals(0, stat.getHighWaterMark()); <line4> stat.setCurrent(100); <line5> assertEquals(100, stat.getCurrent()); <line6> assertEquals(100, stat.getLowWaterMark()); <line7> assertEquals(100, stat.getHighWaterMark()); <line8> stat.setCurrent(50); <line9> assertEquals(50, stat.getCurrent()); <line10> assertEquals(50, stat.getLowWaterMark()); <line11> assertEquals(100, stat.getHighWaterMark()); <line12> stat.setCurrent(200); <line13> assertEquals(200, stat.getCurrent()); <line14> assertEquals(50, stat.getLowWaterMark()); <line15> assertEquals(200, stat.getHighWaterMark()); <line16> Thread.sleep(500); <line17> stat.setCurrent(10); <line18> assertEquals(10, stat.getCurrent()); <line19> assertEquals(10, stat.getLowWaterMark()); <line20> assertEquals(200, stat.getHighWaterMark()); <line21> assertLastTimeNotStartTime(stat); <line22> stat.reset(); <line23> assertEquals(0, stat.getCurrent()); <line24> assertEquals(0, stat.getLowWaterMark()); <line25> assertEquals(0, stat.getHighWaterMark()); <line26> stat.setCurrent(100); <line27> assertEquals(100, stat.getCurrent()); <line28> assertEquals(100, stat.getLowWaterMark()); <line29> assertEquals(100, stat.getHighWaterMark()); <line30> } <line31> } <line32> 	 <line20>	No
public class A { <line0> private static <T extends Serializable> T instantiateEventsProcessorClass( <line1> Class<T> clazz, String eventsProcessorClass) throws ReflectiveOperationException { <line2> try { <line3> Class<?> eventsProcessor = Class.forName(eventsProcessorClass); <line4> Constructor<?> constructor = eventsProcessor.getConstructor(); <line5> return (T) constructor.newInstance(); <line6> } catch (ClassNotFoundException <line7> | NoSuchMethodException <line8> | IllegalAccessException <line9> | InstantiationException <line10> | InvocationTargetException e) { <line11> throw e; <line12> } <line13> } <line14> } <line15> 	 <line14>	No
public class A { <line0> private @Nullable Account getAccount(@NonNull String user) throws DataServiceException { <line1> try { <line2> Account a = accountDao.findByUID(user); <line3> return a; <line4> } catch (NameNotFoundException e) { <line5> } <line6> return null; <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public void internalWrite(Server server, Query query, ImmutableList<Result> results) <line2> throws Exception { <line3> Socket socket = null; <line4> PrintWriter writer = null; <line5> try { <line6> socket = pool.borrowObject(address); <line7> writer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream(), UTF_8), true); <line8> for (String formattedResult : messageFormatter.formatResults(results, server)) { <line9> writer.write(""put "" + formattedResult + ""\n""); <line10> } <line11> } catch (ConnectException e) { <line12> } finally { <line13> if (writer != null && writer.checkError()) { <line14> pool.invalidateObject(address, socket); <line15> } else { <line16> pool.returnObject(address, socket); <line17> } <line18> } <line19> } <line20> } <line21> "	 <line2>	No
public class A { <line0> private void checkInstalled(boolean force) { <line1> if (!force && userDao.count() > 0) { <line2> } <line3> } <line4> } <line5> 	 <line0>	No
"public class A { <line0> protected static Class<?> toClass(ClassNode classNode, ClassLoader classLoader) { <line1> ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES); <line2> classNode.accept(classWriter); <line3> byte[] data = classWriter.toByteArray(); <line4> try { <line5> if (PropsValues.INTRABAND_PROXY_DUMP_CLASSES_ENABLED) { <line6> File classFile = new File(_DUMP_DIR, classNode.name.concat("".class"")); <line7> FileUtil.write(classFile, data); <line8> if (_log.isInfoEnabled()) { <line9> } <line10> } <line11> return (Class<?>) <line12> _defineClassMethod.invoke( <line13> classLoader, <line14> StringUtil.replace(classNode.name, CharPool.SLASH, CharPool.PERIOD), <line15> data, <line16> 0, <line17> data.length); <line18> } catch (Exception exception) { <line19> throw new RuntimeException(exception); <line20> } <line21> } <line22> } <line23> "	 <line9>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> while (MemcachedConnector.this.isStarted() && MemcachedConnector.this.enableHealSession) { <line3> ReconnectRequest request = null; <line4> try { <line5> request = MemcachedConnector.this.waitingQueue.take(); <line6> InetSocketAddress address = request.getInetSocketAddressWrapper().getInetSocketAddress(); <line7> if (!MemcachedConnector.this.removedAddrSet.contains(address)) { <line8> boolean connected = false; <line9> Future<Boolean> future = <line10> MemcachedConnector.this.connect(request.getInetSocketAddressWrapper()); <line11> request.setTries(request.getTries() + 1); <line12> try { <line13> if (!future.get(MemcachedClient.DEFAULT_CONNECT_TIMEOUT, TimeUnit.MILLISECONDS)) { <line14> connected = false; <line15> } else { <line16> connected = true; <line17> } <line18> } catch (TimeoutException e) { <line19> future.cancel(true); <line20> } catch (ExecutionException e) { <line21> future.cancel(true); <line22> } finally { <line23> if (!connected) { <line24> this.rescheduleConnectRequest(request); <line25> } else { <line26> continue; <line27> } <line28> } <line29> } else { <line30> } <line31> } catch (InterruptedException e) { <line32> } catch (Exception e) { <line33> this.rescheduleConnectRequest(request); <line34> } <line35> } <line36> } <line37> } <line38> 	 <line24>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> readLatch.countDown(); <line4> indexPersistenceMgr.getFileInfo(lid, null); <line5> readRc.set(BKException.Code.OK); <line6> } catch (Bookie.NoLedgerException nle) { <line7> readRc.set(BKException.Code.NoSuchLedgerExistsException); <line8> } catch (IOException e) { <line9> readRc.set(BKException.Code.ReadException); <line10> } <line11> readDoneLatch.countDown(); <line12> } <line13> } <line14> 	 <line9>	Yes
"public class A { <line0> private FileInfo getFileInfoInternal(LockedInodePath inodePath, Counter counter) <line1> throws FileDoesNotExistException, UnavailableException { <line2> Inode inode = inodePath.getInode(); <line3> AlluxioURI uri = inodePath.getUri(); <line4> FileInfo fileInfo = inode.generateClientFileInfo(uri.toString()); <line5> if (fileInfo.isFolder()) { <line6> fileInfo.setLength(inode.asDirectory().getChildCount()); <line7> } <line8> fileInfo.setInMemoryPercentage(getInMemoryPercentage(inode)); <line9> fileInfo.setInAlluxioPercentage(getInAlluxioPercentage(inode)); <line10> if (inode.isFile()) { <line11> if (!fileInfo.isCompleted()) { <line12> } <line13> try { <line14> fileInfo.setFileBlockInfos(getFileBlockInfoListInternal(inodePath)); <line15> } catch (InvalidPathException e) { <line16> throw new FileDoesNotExistException(e.getMessage(), e); <line17> } <line18> } <line19> if (fileInfo.isCompleted() <line20> && fileInfo.getBlockIds().size() > fileInfo.getFileBlockInfos().size() <line21> && inode.isPersisted()) { <line22> List<Long> missingBlockIds = <line23> fileInfo.getBlockIds().stream() <line24> .filter((bId) -> fileInfo.getFileBlockInfo(bId) != null) <line25> .collect(Collectors.toList()); <line26> mBlockMaster.removeBlocks(fileInfo.getBlockIds(), true); <line27> commitBlockInfosForFile( <line28> fileInfo.getBlockIds(), fileInfo.getLength(), fileInfo.getBlockSizeBytes()); <line29> try { <line30> fileInfo.setFileBlockInfos(getFileBlockInfoListInternal(inodePath)); <line31> } catch (InvalidPathException e) { <line32> throw new FileDoesNotExistException( <line33> String.format(""Hydration failed for file: %s"", inodePath.getUri()), e); <line34> } <line35> } <line36> fileInfo.setXAttr(inode.getXAttr()); <line37> MountTable.Resolution resolution; <line38> try { <line39> resolution = mMountTable.resolve(uri); <line40> } catch (InvalidPathException e) { <line41> throw new FileDoesNotExistException(e.getMessage(), e); <line42> } <line43> AlluxioURI resolvedUri = resolution.getUri(); <line44> fileInfo.setUfsPath(resolvedUri.toString()); <line45> fileInfo.setMountId(resolution.getMountId()); <line46> if (counter == null) { <line47> Metrics.getUfsOpsSavedCounter(resolution.getUfsMountPointUri(), Metrics.UFSOps.GET_FILE_INFO) <line48> .inc(); <line49> } else { <line50> counter.inc(); <line51> } <line52> Metrics.FILE_INFOS_GOT.inc(); <line53> return fileInfo; <line54> } <line55> } <line56> "	 <line40>	No
public class A { <line0> @Override <line1> public void initChannel(Channel connectedChannel) throws Exception { <line2> if (initRoutine != null) { <line3> try { <line4> initRoutine.run(); <line5> } catch (Throwable initError) { <line6> connectionFailed(connectedChannel, IOExceptionSupport.create(initError)); <line7> throw initError; <line8> } <line9> } <line10> configureChannel(connectedChannel); <line11> } <line12> } <line13> 	 <line2>	No
public class A { <line0> public boolean finalizeExtraction(DateTime startTime) { <line1> boolean success = true; <line2> try { <line3> ManifestFile metaDataFile = this.getManifestFile(); <line4> metaDataFile.generateMetaFile(startTime); <line5> } catch (IOException e) { <line6> success = false; <line7> } <line8> try { <line9> success = success && this.generateArchive(); <line10> } catch (Exception e) { <line11> success = false; <line12> } <line13> return success; <line14> } <line15> } <line16> 	 <line9>	No
public class A { <line0> private void collectAggregatesUnderThrottle( <line1> String agentId, <line2> boolean postV09, <line3> long captureTime, <line4> List<Aggregate.SharedQueryText> sharedQueryTexts, <line5> List<OldAggregatesByType> aggregatesByTypeList, <line6> StreamObserver<AggregateResponseMessage> responseObserver) { <line7> String postV09AgentId; <line8> try { <line9> postV09AgentId = grpcCommon.getAgentId(agentId, postV09); <line10> } catch (Throwable t) { <line11> responseObserver.onError(t); <line12> return; <line13> } <line14> try { <line15> aggregateDao.store(postV09AgentId, captureTime, aggregatesByTypeList, sharedQueryTexts); <line16> } catch (Throwable t) { <line17> responseObserver.onError(t); <line18> return; <line19> } <line20> String agentDisplay; <line21> try { <line22> agentDisplay = agentDisplayDao.readFullDisplay(postV09AgentId); <line23> } catch (Exception e) { <line24> responseObserver.onError(e); <line25> return; <line26> } <line27> try { <line28> centralAlertingService.checkForDeletedAlerts(postV09AgentId); <line29> centralAlertingService.checkAggregateAlertsAsync(postV09AgentId, agentDisplay, captureTime); <line30> } catch (InterruptedException e) { <line31> } <line32> responseObserver.onNext( <line33> AggregateResponseMessage.newBuilder().setNextDelayMillis(getNextDelayMillis()).build()); <line34> responseObserver.onCompleted(); <line35> } <line36> } <line37> 	 <line31>	Yes
"public class A { <line0> @Override <line1> public synchronized void initialize() { <line2> if (this.getThing().getStatus().equals(ThingStatus.ONLINE)) { <line3> updateStatus(ThingStatus.OFFLINE); <line4> } <line5> this.callbackDelegator.resetCache(); <line6> comms = null; <line7> request = null; <line8> disposed = false; <line9> try { <line10> config = getConfigAs(ModbusPollerConfiguration.class); <line11> String type = config.getType(); <line12> if (!ModbusBindingConstantsInternal.READ_FUNCTION_CODES.containsKey(type)) { <line13> updateStatus( <line14> ThingStatus.OFFLINE, <line15> ThingStatusDetail.CONFIGURATION_ERROR, <line16> String.format( <line17> ""No function code found for type='%s'. Was expecting one of: %s"", <line18> type, String.join("", "", SORTED_READ_FUNCTION_CODES))); <line19> return; <line20> } <line21> functionCode = ModbusBindingConstantsInternal.READ_FUNCTION_CODES.get(type); <line22> switch (functionCode) { <line23> case READ_INPUT_REGISTERS: <line24> case READ_MULTIPLE_REGISTERS: <line25> if (config.getLength() > ModbusConstants.MAX_REGISTERS_READ_COUNT) { <line26> updateStatus( <line27> ThingStatus.OFFLINE, <line28> ThingStatusDetail.CONFIGURATION_ERROR, <line29> String.format( <line30> ""Maximum of %d registers can be polled at once due to protocol limitations."" <line31> + "" Length %d is out of bounds."", <line32> ModbusConstants.MAX_REGISTERS_READ_COUNT, config.getLength())); <line33> return; <line34> } <line35> break; <line36> case READ_COILS: <line37> case READ_INPUT_DISCRETES: <line38> if (config.getLength() > ModbusConstants.MAX_BITS_READ_COUNT) { <line39> updateStatus( <line40> ThingStatus.OFFLINE, <line41> ThingStatusDetail.CONFIGURATION_ERROR, <line42> String.format( <line43> ""Maximum of %d coils/discrete inputs can be polled at once due to protocol"" <line44> + "" limitations. Length %d is out of bounds."", <line45> ModbusConstants.MAX_BITS_READ_COUNT, config.getLength())); <line46> return; <line47> } <line48> break; <line49> } <line50> cacheMillis = this.config.getCacheMillis(); <line51> registerPollTask(); <line52> } catch (EndpointNotInitializedException e) { <line53> updateStatus( <line54> ThingStatus.OFFLINE, <line55> ThingStatusDetail.CONFIGURATION_ERROR, <line56> String.format( <line57> ""Exception during initialization: %s (%s)"", <line58> e.getMessage(), e.getClass().getSimpleName())); <line59> } finally { <line60> } <line61> } <line62> } <line63> "	 <line28>	No
"public class A { <line0> @Override <line1> public void fillJobNodeIfNotExist(final String node, final Object value) { <line2> if (value == null) { <line3> return; <line4> } <line5> if (!checkExists(node)) { <line6> try { <line7> curatorFramework <line8> .create() <line9> .creatingParentsIfNeeded() <line10> .forPath(node, value.toString().getBytes(Charset.forName(""UTF-8""))); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> } <line16> "	 <line3>	Yes
"public class A { <line0> public List<SysUser> queryPageList( <line1> String userName, <line2> String email, <line3> String deptCode, <line4> String column, <line5> String field, <line6> int pageNo, <line7> int pageSize) <line8> throws Exception { <line9> List<SysUser> list = null; <line10> try (SqlSession sqlSession = MyBatisUtil.getSqlSession()) { <line11> SysUserMapper sysUserMapper = sqlSession.getMapper(SysUserMapper.class); <line12> Map<String, Object> where = new HashMap<>(); <line13> where.put(""userName"", userName); <line14> where.put(""email"", email); <line15> where.put(""deptCode"", deptCode); <line16> list = sysUserMapper.selectAll(where, new RowBounds(pageNo, pageSize)); <line17> } catch (Exception e) { <line18> throw new Exception(e); <line19> } <line20> return list; <line21> } <line22> } <line23> "	 <line18>	Yes
"public class A { <line0> @Override <line1> protected void configureComponents(@Nullable String model) { <line2> String mod = model == null ? MODEL_OPTION_OTHER : model; <line3> boolean caseta = mod.equalsIgnoreCase(MODEL_OPTION_CASETA); <line4> for (int x = 1; x <= 100; x++) { <line5> buttonList.add( <line6> new Component(x, String.format(""button%d"", x), ""Virtual Button"", ComponentType.BUTTON)); <line7> if (!caseta) { <line8> ledList.add( <line9> new Component(x + 100, String.format(""led%d"", x), ""Virtual LED"", ComponentType.LED)); <line10> } <line11> } <line12> } <line13> } <line14> "	 <line9>	No
"public class A { <line0> private void saveCriteria( <line1> final NiFiWebConfigurationRequestContext requestContext, final Criteria criteria) { <line2> final String annotationData = CriteriaSerDe.serialize(criteria); <line3> final NiFiWebConfigurationContext configurationContext = <line4> (NiFiWebConfigurationContext) servletContext.getAttribute(""nifi-web-configuration-context""); <line5> try { <line6> configurationContext.updateComponent(requestContext, annotationData, null); <line7> } catch (final InvalidRevisionException ire) { <line8> throw new WebApplicationException(ire, invalidRevision(ire.getMessage())); <line9> } catch (final IllegalArgumentException iae) { <line10> throw new WebApplicationException(iae, badRequest(iae.getMessage())); <line11> } catch (final Exception e) { <line12> final String message = <line13> String.format( <line14> ""Unable to save UpdateAttribute[id=%s] criteria: %s"", requestContext.getId(), e); <line15> throw new WebApplicationException(e, error(message)); <line16> } <line17> } <line18> } <line19> "	 <line15>	Yes
"public class A { <line0> public void testGetChildrenNoPropertyFilter() throws Exception { <line1> ByteArrayContainerResponseWriter writer = new ByteArrayContainerResponseWriter(); <line2> String requestPath = SERVICE_URI + ""children/"" + folderId; <line3> ContainerResponse response = <line4> launcher.service(HttpMethod.GET, requestPath, BASE_URI, null, null, writer, null); <line5> assertEquals(""Error: "" + response.getEntity(), 200, response.getStatus()); <line6> @SuppressWarnings(""unchecked"") <line7> ItemList children = (ItemList) response.getEntity(); <line8> assertEquals(4, children.getItems().size()); <line9> for (Item i : children.getItems()) { <line10> assertNull(getPropertyValue(i, ""MyProperty01"")); <line11> assertNull(getPropertyValue(i, ""MyProperty02"")); <line12> } <line13> } <line14> } <line15> "	 <line5>	Yes
public class A { <line0> @Override <line1> public void adjustTLSExtensionContext(PWDProtectExtensionMessage message) { <line2> if (context.getChooser().getConnectionEndType() == ConnectionEndType.CLIENT) { <line3> context.setClientPWDUsername(context.getConfig().getDefaultClientPWDUsername()); <line4> return; <line5> } <line6> ECCurve curve = <line7> ECNamedCurveTable.getParameterSpec( <line8> context.getConfig().getDefaultPWDProtectGroup().getJavaName()) <line9> .getCurve(); <line10> BigInteger prime = curve.getField().getCharacteristic(); <line11> HKDFAlgorithm hkdfAlgorithm; <line12> if (curve.getFieldSize() <= 256) { <line13> hkdfAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256; <line14> } else if (curve.getFieldSize() <= 384) { <line15> hkdfAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA384; <line16> } else { <line17> return; <line18> } <line19> byte[] protectedUsername = message.getUsername().getValue(); <line20> BigInteger clientPublicKeyX = <line21> new BigInteger(1, Arrays.copyOfRange(protectedUsername, 0, curve.getFieldSize() / 8)); <line22> BigInteger clientPublicKeyYSquared = <line23> clientPublicKeyX <line24> .pow(3) <line25> .add(clientPublicKeyX.multiply(curve.getA().toBigInteger())) <line26> .add(curve.getB().toBigInteger()) <line27> .mod(prime); <line28> BigInteger clientPublicKeyY = <line29> clientPublicKeyYSquared.modPow(prime.add(BigInteger.ONE).shiftRight(2), prime); <line30> ECPoint clientPublicKey = curve.createPoint(clientPublicKeyX, clientPublicKeyY); <line31> BigInteger sharedSecret = <line32> clientPublicKey <line33> .multiply(context.getConfig().getDefaultServerPWDProtectPrivateKey()) <line34> .normalize() <line35> .getXCoord() <line36> .toBigInteger(); <line37> try { <line38> byte[] key = <line39> HKDFunction.expand( <line40> hkdfAlgorithm, <line41> HKDFunction.extract( <line42> hkdfAlgorithm, null, ArrayConverter.bigIntegerToByteArray(sharedSecret)), <line43> new byte[0], <line44> curve.getFieldSize() / Bits.IN_A_BYTE); <line45> byte[] ctrKey = Arrays.copyOfRange(key, 0, key.length / 2); <line46> byte[] macKey = Arrays.copyOfRange(key, key.length / 2, key.length); <line47> byte[] encryptedUsername = <line48> Arrays.copyOfRange( <line49> protectedUsername, curve.getFieldSize() / Bits.IN_A_BYTE, protectedUsername.length); <line50> SivMode AES_SIV = new SivMode(); <line51> String username = new String(AES_SIV.decrypt(ctrKey, macKey, encryptedUsername)); <line52> context.setClientPWDUsername(username); <line53> } catch (IllegalBlockSizeException | UnauthenticCiphertextException | CryptoException e) { <line54> } <line55> } <line56> } <line57> 	 <line54>	Yes
"public class A { <line0> public OMElement sendReceive( <line1> String userName, <line2> String password, <line3> String endpointReference, <line4> String operation, <line5> OMElement payload, <line6> int securityScenarioNo) <line7> throws Exception { <line8> if (securityScenarioNo == 1) { <line9> Assert.assertTrue( <line10> endpointReference.startsWith(""https:""), ""Endpoint reference should be https""); <line11> } <line12> String keyPath = <line13> FrameworkPathUtil.getSystemResourceLocation() <line14> + File.separator <line15> + ""keystores"" <line16> + File.separator <line17> + ""products""; <line18> String securityPolicyPath = <line19> FrameworkPathUtil.getSystemResourceLocation() <line20> + File.separator <line21> + ""security"" <line22> + File.separator <line23> + ""policies"" <line24> + ""scenario"" <line25> + securityScenarioNo <line26> + ""-policy.xml""; <line27> ServiceClient sc = <line28> getServiceClient( <line29> userName, <line30> password, <line31> endpointReference, <line32> operation, <line33> securityPolicyPath, <line34> ""wso2carbon"", <line35> ""wso2carbon"", <line36> keyPath, <line37> ""wso2carbon""); <line38> OMElement result; <line39> if (log.isDebugEnabled()) { <line40> } <line41> try { <line42> result = buildResponse(sc.sendReceive(payload)); <line43> if (log.isDebugEnabled()) { <line44> } <line45> } catch (AxisFault axisFault) { <line46> throw axisFault; <line47> } finally { <line48> sc.cleanupTransport(); <line49> } <line50> Assert.assertNotNull(result); <line51> return result; <line52> } <line53> } <line54> "	 <line40>	Yes
"public class A { <line0> @Reference( <line1> cardinality = ReferenceCardinality.MULTIPLE, <line2> policy = ReferencePolicy.DYNAMIC, <line3> policyOption = ReferencePolicyOption.GREEDY) <line4> protected synchronized void setConfigurationProvider( <line5> ConfigurationProvider<?> configurationProvider, Map<String, Object> properties) { <line6> String factoryPid = MapUtil.getString(properties, ""factoryPid""); <line7> if (Validator.isNull(factoryPid)) { <line8> throw new IllegalArgumentException( <line9> ""No factory PID specified for configuration provider "" + configurationProvider); <line10> } <line11> _configurationProviders.put(factoryPid, configurationProvider); <line12> try { <line13> Configuration[] configurations = <line14> _configurationAdmin.listConfigurations(""(service.factoryPid="" + factoryPid + ""*)""); <line15> if (configurations != null) { <line16> for (Configuration configuration : configurations) { <line17> configurationProvider.registerConfiguration(configuration); <line18> } <line19> } <line20> } catch (Exception exception) { <line21> if (_log.isWarnEnabled()) { <line22> } <line23> } <line24> } <line25> } <line26> "	 <line22>	Yes
public class A { <line0> public static List<Map<String, Double>> getTopWords(File modelFile, int nWords, boolean normalize) <line1> throws IOException { <line2> ParallelTopicModel model; <line3> try { <line4> model = ParallelTopicModel.read(modelFile); <line5> } catch (Exception e) { <line6> throw new IOException(e); <line7> } <line8> Alphabet alphabet = model.getAlphabet(); <line9> List<Map<String, Double>> topics = new ArrayList<>(model.getNumTopics()); <line10> for (TreeSet<IDSorter> topic : model.getSortedWords()) { <line11> Map<String, Double> topicWords = new HashMap<>(nWords); <line12> for (IDSorter id : topic) { <line13> double weight = normalize ? id.getWeight() / alphabet.size() : id.getWeight(); <line14> String word = (String) alphabet.lookupObject(id.getID()); <line15> topicWords.put(word, weight); <line16> if (topicWords.size() >= nWords) { <line17> break; <line18> } <line19> } <line20> topics.add(topicWords); <line21> } <line22> return topics; <line23> } <line24> } <line25> 	 <line16>	No
public class A { <line0> private static void addARIifMatches( <line1> String refNameToMatch, <line2> boolean matchBaseOnly, <line3> AuthRefConfigInfo arci, <line4> Property prop, <line5> List<AuthRefInfo> authRefInfoList) { <line6> try { <line7> String value = (String) prop.getValue(); <line8> if (((refNameToMatch != null) <line9> && (matchBaseOnly <line10> ? (value != null && value.startsWith(refNameToMatch)) <line11> : refNameToMatch.equals(value))) <line12> || ((refNameToMatch == null) && Tools.notBlank(value))) { <line13> AuthRefInfo ari = new AuthRefInfo(arci, prop); <line14> authRefInfoList.add(ari); <line15> } <line16> } catch (PropertyException pe) { <line17> } <line18> } <line19> } <line20> 	 <line17>	Yes
public class A { <line0> public static H2Configuration asH2Configuration(OxdServerConfiguration configuration) { <line1> try { <line2> JsonNode node = configuration.getStorageConfiguration(); <line3> if (node != null) { <line4> return Jackson2.createJsonMapper().treeToValue(node, H2Configuration.class); <line5> } <line6> } catch (Exception e) { <line7> } <line8> return new H2Configuration(); <line9> } <line10> } <line11> 	 <line0>	No
public class A { <line0> protected void onLeaderChange( <line1> TopicName topicName, PartitionGroup oldPartitionGroup, PartitionGroup newPartitionGroup) <line2> throws Exception { <line3> electionService.onLeaderChange( <line4> topicName, newPartitionGroup.getGroup(), newPartitionGroup.getLeader()); <line5> } <line6> } <line7> 	 <line3>	Yes
public class A { <line0> private boolean isProjected(Path field) { <line1> for (Projection p : projections) { <line2> Projection.Inclusion inc = p.getFieldInclusion(field); <line3> if (inc == Projection.Inclusion.explicit_inclusion) { <line4> return true; <line5> } else { <line6> } <line7> } <line8> return false; <line9> } <line10> } <line11> 	 <line0>	No
public class A { <line0> @BuildStep(onlyIf = MicroprofileMetricsEnabled.class) <line1> void logWarningForMpMetricsUsage( <line2> CombinedIndexBuildItem combinedIndexBuildItem, <line3> BeanRegistrationPhaseBuildItem beanRegistrationPhase, <line4> BuildProducer<BeanConfiguratorBuildItem> errors) { <line5> IndexView index = combinedIndexBuildItem.getIndex(); <line6> boolean mpMetricsPresent = false; <line7> for (DotName annotation : MetricDotNames.individualMetrics) { <line8> if (index.getAnnotations(annotation).size() > 0) { <line9> mpMetricsPresent = true; <line10> break; <line11> } <line12> } <line13> if (!mpMetricsPresent) { <line14> if (index.getAnnotations(MetricDotNames.METRIC_ANNOTATION).size() > 0) { <line15> mpMetricsPresent = true; <line16> } <line17> } <line18> if (!mpMetricsPresent) { <line19> for (InjectionPointInfo injectionPoint : beanRegistrationPhase.getInjectionPoints()) { <line20> if (injectionPoint.getRequiredType().name().equals(MetricDotNames.METRIC_REGISTRY)) { <line21> mpMetricsPresent = true; <line22> break; <line23> } <line24> } <line25> } <line26> if (mpMetricsPresent) { <line27> } <line28> } <line29> } <line30> 	 <line27>	Yes
public class A { <line0> public static void sendClient(final IWsClient omClient, final RoomMessage m) { <line1> sendClient( <line2> omClient, <line3> c -> { <line4> try { <line5> c.sendMessage(m); <line6> } catch (Throwable e) { <line7> } <line8> }); <line9> } <line10> } <line11> 	 <line4>	No
"public class A { <line0> @GetMapping(CommonConstants.PATH_LOGBOOK) <line1> public JsonNode findHistoryById(final @PathVariable(""id"") String id) { <line2> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line3> final VitamContext vitamContext = <line4> securityService.buildVitamContext(securityService.getTenantIdentifier()); <line5> return operationInternalService.findHistoryByIdentifier(vitamContext, id); <line6> } <line7> } <line8> "	 <line5>	No
"public class A { <line0> @Override <line1> public synchronized void initActivity() { <line2> if (!super.getActivityDef().getParams().contains(""verify"") <line3> && !super.getActivityDef().getParams().contains(""verify-fields"")) { <line4> super.getActivityDef().getParams().put(""verify"", ""*""); <line5> } <line6> if (!super.getActivityDef().getParams().contains(""compare"")) { <line7> super.getActivityDef().getParams().put(""compare"", ""all""); <line8> } <line9> super.initActivity(); <line10> } <line11> } <line12> "	 <line0>	No
"public class A { <line0> protected Span getSpanFromContext(byte[] traceContext) { <line1> if (traceContext == null || traceContext.length == 0) { <line2> return BlankSpan.INSTANCE; <line3> } <line4> Tracer tracer = Tracing.getTracer(); <line5> BinaryFormat binaryFormat = Tracing.getPropagationComponent().getBinaryFormat(); <line6> try { <line7> SpanContext spanContext = binaryFormat.fromByteArray(traceContext); <line8> Span span = <line9> tracer <line10> .spanBuilderWithRemoteParent(""work/"" + getClass().getSimpleName(), spanContext) <line11> .startSpan(); <line12> span.addLink(Link.fromSpanContext(spanContext, Link.Type.PARENT_LINKED_SPAN)); <line13> HashMap<String, AttributeValue> map = new HashMap<>(); <line14> map.put(""tx.thread"", AttributeValue.stringAttributeValue(Thread.currentThread().getName())); <line15> map.put(""work.id"", AttributeValue.stringAttributeValue(getId())); <line16> map.put(""work.category"", AttributeValue.stringAttributeValue(getCategory())); <line17> String title = getTitle(); <line18> if (title != null) { <line19> map.put(""work.title"", AttributeValue.stringAttributeValue(title)); <line20> } <line21> map.put( <line22> ""work.parent_path"", <line23> AttributeValue.stringAttributeValue(getSchedulePath().getParentPath())); <line24> map.put(""work.caller_thread"", AttributeValue.stringAttributeValue(callerThread)); <line25> map.put(""work.to_string"", AttributeValue.stringAttributeValue(toString())); <line26> if (docId != null) { <line27> map.put(""work.doc_id"", AttributeValue.stringAttributeValue(docId)); <line28> } <line29> if (docIds != null && !docIds.isEmpty()) { <line30> map.put(""work.doc_count"", AttributeValue.longAttributeValue(docIds.size())); <line31> } <line32> span.putAttributes(map); <line33> return span; <line34> } catch (SpanContextParseException e) { <line35> return BlankSpan.INSTANCE; <line36> } <line37> } <line38> } <line39> "	 <line25>	No
"public class A { <line0> private static OWLOntology getNewAxiomOntology( <line1> OWLOntology ontology, <line2> OWLReasoner reasoner, <line3> List<InferredAxiomGenerator<? extends OWLAxiom>> gens, <line4> Map<String, String> options) <line5> throws OWLOntologyCreationException { <line6> OWLOntologyManager manager = ontology.getOWLOntologyManager(); <line7> OWLDataFactory dataFactory = manager.getOWLDataFactory(); <line8> boolean direct = !OptionsHelper.optionIsTrue(options, ""include-indirect""); <line9> boolean subClass = <line10> gens.stream() <line11> .anyMatch( <line12> g -> <line13> (g instanceof InferredSubClassAxiomGenerator) <line14> || (g instanceof InferredSubClassAxiomGeneratorIncludingIndirect)); <line15> OWLOntology newAxiomOntology = manager.createOntology(); <line16> InferredOntologyGenerator generator = new InferredOntologyGenerator(reasoner, gens); <line17> generator.fillOntology(dataFactory, newAxiomOntology); <line18> if (reasoner instanceof ExpressionMaterializingReasoner) { <line19> ExpressionMaterializingReasoner emr = (ExpressionMaterializingReasoner) reasoner; <line20> emr.materializeExpressions(); <line21> if (subClass) { <line22> for (OWLClass c : ontology.getClassesInSignature(Imports.INCLUDED)) { <line23> Set<OWLClassExpression> sces = emr.getSuperClassExpressions(c, direct); <line24> for (OWLClassExpression sce : sces) { <line25> if (!sce.getSignature().contains(dataFactory.getOWLThing())) { <line26> OWLAxiom ax = dataFactory.getOWLSubClassOfAxiom(c, sce); <line27> manager.addAxiom(newAxiomOntology, ax); <line28> } <line29> } <line30> } <line31> } <line32> } <line33> return newAxiomOntology; <line34> } <line35> } <line36> "	 <line19>	Yes
"public class A { <line0> @Test <line1> public void testInfo() { <line2> final InternalLogger logger = InternalLoggerFactory.getInstance(""mock""); <line3> } <line4> } <line5> "	 <line3>	Yes
public class A { <line0> @Override <line1> public void postCreateNamespace( <line2> ObserverContext<MasterCoprocessorEnvironment> ctx, NamespaceDescriptor ns) <line3> throws IOException { <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> try { <line7> activatePluginClassLoader(); <line8> implMasterObserver.postCreateNamespace(ctx, ns); <line9> } finally { <line10> deactivatePluginClassLoader(); <line11> } <line12> if (LOG.isDebugEnabled()) { <line13> } <line14> } <line15> } <line16> 	 <line13>	Yes
public class A { <line0> @Override <line1> public Map<String, ByteBuffer> performAssignment( <line2> String leaderId, <line3> String protocol, <line4> List<JoinGroupResponseMember> allMemberMetadata, <line5> WorkerCoordinator coordinator) { <line6> Map<String, ExtendedWorkerState> memberConfigs = new HashMap<>(); <line7> for (JoinGroupResponseMember member : allMemberMetadata) { <line8> memberConfigs.put( <line9> member.memberId(), <line10> IncrementalCooperativeConnectProtocol.deserializeMetadata( <line11> ByteBuffer.wrap(member.metadata()))); <line12> } <line13> long maxOffset = <line14> memberConfigs.values().stream().map(ExtendedWorkerState::offset).max(Long::compare).get(); <line15> short protocolVersion = <line16> memberConfigs.values().stream() <line17> .allMatch(state -> state.assignment().version() == CONNECT_PROTOCOL_V2) <line18> ? CONNECT_PROTOCOL_V2 <line19> : CONNECT_PROTOCOL_V1; <line20> Long leaderOffset = ensureLeaderConfig(maxOffset, coordinator); <line21> if (leaderOffset == null) { <line22> Map<String, ExtendedAssignment> assignments = <line23> fillAssignments( <line24> memberConfigs.keySet(), <line25> Assignment.CONFIG_MISMATCH, <line26> leaderId, <line27> memberConfigs.get(leaderId).url(), <line28> maxOffset, <line29> Collections.emptyMap(), <line30> Collections.emptyMap(), <line31> Collections.emptyMap(), <line32> 0, <line33> protocolVersion); <line34> return serializeAssignments(assignments); <line35> } <line36> return performTaskAssignment( <line37> leaderId, leaderOffset, memberConfigs, coordinator, protocolVersion); <line38> } <line39> } <line40> 	 <line31>	No
"public class A { <line0> private boolean checkSearchTerm(List<Property> propertyList, String searchTerm) { <line1> for (Property property : propertyList) { <line2> String value = property.getPropertyValue(); <line3> if (value != null && value.toLowerCase().contains(searchTerm.toLowerCase())) { <line4> if (value.length() > 30) { <line5> value = value.substring(0, 30) + ""...""; <line6> } <line7> return true; <line8> } <line9> } <line10> return false; <line11> } <line12> } <line13> "	 <line7>	Yes
"public class A { <line0> public static void main(String[] args) { <line1> PropertiesConfiguration sourceConfig = null; <line2> ThreatIntelSource threatIntelSource = null; <line3> ArrayList<Put> putList = null; <line4> HTable table = null; <line5> Configuration hConf = null; <line6> CommandLine commandLine = parseCommandLine(args); <line7> File configFile = new File(commandLine.getOptionValue(""configFile"")); <line8> try { <line9> sourceConfig = new PropertiesConfiguration(configFile); <line10> } catch (org.apache.commons.configuration.ConfigurationException e) { <line11> LOG.error(e); <line12> System.exit(-1); <line13> } <line14> try { <line15> threatIntelSource = <line16> (ThreatIntelSource) Class.forName(commandLine.getOptionValue(""source"")).newInstance(); <line17> threatIntelSource.initializeSource(sourceConfig); <line18> } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) { <line19> LOG.error(e); <line20> System.exit(-1); <line21> } <line22> hConf = HBaseConfiguration.create(); <line23> try { <line24> table = new HTable(hConf, commandLine.getOptionValue(""table"")); <line25> } catch (IOException e) { <line26> System.exit(-1); <line27> } <line28> putList = new ArrayList<Put>(); <line29> while (threatIntelSource.hasNext()) { <line30> JSONObject intel = threatIntelSource.next(); <line31> try { <line32> putList.add(putRequestFromIntel(intel)); <line33> if (putList.size() == BULK_SIZE) { <line34> table.put(putList); <line35> putList.clear(); <line36> } <line37> } catch (NullPointerException | ClassCastException e) { <line38> LOG.error(e); <line39> } catch (InterruptedIOException <line40> | org.apache.hadoop.hbase.client.RetriesExhaustedWithDetailsException e) { <line41> System.exit(-1); <line42> } <line43> } <line44> } <line45> } <line46> "	 <line18>	No
public class A { <line0> private void populateFieldInfosFromPojo(ColumnDefinitions rsMetaData) { <line1> fieldInfos = Lists.newArrayList(); <line2> Field[] fields = pojoClass.getDeclaredFields(); <line3> for (int i = 0; i < rsMetaData.size(); i++) { <line4> String columnName = rsMetaData.getName(i); <line5> String pojoField = getMatchingField(fields, columnName); <line6> if (pojoField != null && pojoField.length() != 0) { <line7> fieldInfos.add(new FieldInfo(columnName, pojoField, null)); <line8> } else { <line9> } <line10> } <line11> } <line12> } <line13> 	 <line6>	No
"public class A { <line0> @Override <line1> public void handle(HttpExchange he) throws IOException { <line2> Content content; <line3> if (he.getRemoteAddress().getAddress().isLoopbackAddress()) { <line4> try { <line5> content = handlePath(he); <line6> } catch (HttpErrorException e) { <line7> content = handleError(e.status); <line8> } <line9> } else { <line10> content = handleError(Status.FORBIDDEN); <line11> } <line12> Headers headers = he.getResponseHeaders(); <line13> headers.put(""Content-Type"", Arrays.asList(content.type)); <line14> he.sendResponseHeaders(content.status.code, content.body.length); <line15> try (OutputStream os = he.getResponseBody()) { <line16> os.write(content.body); <line17> } <line18> } <line19> } <line20> "	 <line0>	No
public class A { <line0> @Override <line1> public void init() { <line2> this.checkOpened(); <line3> for (RaftBackendStore store : this.stores()) { <line4> store.init(); <line5> } <line6> this.notifyAndWaitEvent(Events.STORE_INITED); <line7> } <line8> } <line9> 	 <line5>	No
"public class A { <line0> public void testReports() throws Exception { <line1> String uipath = ""/acquisition/""; <line2> String data = tester.acquisitionCreate(); <line3> HttpTester out; <line4> out = tester.POSTData(uipath, tester.makeSimpleRequest(data), jetty); <line5> String id = out.getHeader(""Location""); <line6> out = tester.jettyDo(jetty, ""GET"", ""/tenant/core"" + id, null); <line7> HttpTester out3 = <line8> tester.jettyDo(jetty, ""GET"", ""/tenant/core/reporting/search/acquisition"", null); <line9> JSONObject one = new JSONObject(out.getContent()); <line10> JSONObject list = new JSONObject(out3.getContent()); <line11> String reportcsid = list.getJSONArray(""reportlist"").getString(0); <line12> String path = one.getString(""csid""); <line13> JSONObject report = new JSONObject(); <line14> report.put(""docType"", ""acquisition""); <line15> report.put(""singleCSID"", path); <line16> report.put(""mode"", ""single""); <line17> JSONObject fields = new JSONObject(); <line18> fields.put(""fields"", report); <line19> String url = ""/invokereport/"" + reportcsid; <line20> HttpTester out2 = tester.POSTData(url, fields.toString(), jetty, ""GET""); <line21> assertEquals(200, out2.getStatus()); <line22> assertEquals(""application/pdf"", out2.getHeader(""Content-Type"")); <line23> tester.DELETEData(id, jetty); <line24> } <line25> } <line26> "	 <line21>	Yes
"public class A { <line0> public boolean register() { <line1> try { <line2> try { <line3> systemIP = getSystemIp(); <line4> } catch (IOException | InterruptedException e) { <line5> systemIP = InetAddress.getByName(""127.0.0.1""); <line6> } <line7> socket = new Socket(systemIP, systemPort); <line8> out = new PrintWriter(socket.getOutputStream(), true); <line9> in = new BufferedReader(new InputStreamReader(socket.getInputStream())); <line10> } catch (final IOException e) { <line11> } <line12> try { <line13> final String $ = new SensorMessage(MessageType.REGISTRATION, this).send(out, in); <line14> return $ != null && new SensorMessage($).isSuccesful(); <line15> } catch (final IllegalMessageBaseExecption e) { <line16> } <line17> return false; <line18> } <line19> } <line20> "	 <line5>	Yes
public class A { <line0> @Override <line1> public void onPostUpdate(final PostUpdateEvent event) { <line2> Object entity = event.getEntity(); <line3> if (!(entity instanceof HTextFlowTarget)) { <line4> return; <line5> } <line6> final HTextFlowTarget target = HTextFlowTarget.class.cast(event.getEntity()); <line7> try { <line8> runInTransaction( <line9> () -> { <line10> ContentState oldContentState = <line11> (ContentState) <line12> Iterables.find( <line13> Lists.newArrayList(event.getOldState()), <line14> Predicates.instanceOf(ContentState.class)); <line15> prepareTransUnitUpdatedEvent(target.getVersionNum() - 1, oldContentState, target); <line16> }); <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> 	 <line18>	Yes
public class A { <line0> protected void handleSessionEvent(ISessionListener listener, SessionEvent event) { <line1> try { <line2> listener.sessionChanged(event); <line3> } catch (RuntimeException e) { <line4> if (event.getType() != SessionEvent.TYPE_STOPPED <line5> && event.getType() != SessionEvent.TYPE_STOPPING) { <line6> throw e; <line7> } <line8> } <line9> } <line10> } <line11> 	 <line5>	No
public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> startScan_result result = new startScan_result(); <line4> if (e instanceof org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException) { <line5> result.sec = (org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException) e; <line6> result.setSecIsSet(true); <line7> msg = result; <line8> } else if (e instanceof NotServingTabletException) { <line9> result.nste = (NotServingTabletException) e; <line10> result.setNsteIsSet(true); <line11> msg = result; <line12> } else if (e instanceof TooManyFilesException) { <line13> result.tmfe = (TooManyFilesException) e; <line14> result.setTmfeIsSet(true); <line15> msg = result; <line16> } else if (e instanceof TSampleNotPresentException) { <line17> result.tsnpe = (TSampleNotPresentException) e; <line18> result.setTsnpeIsSet(true); <line19> msg = result; <line20> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line21> fb.close(); <line22> return; <line23> } else if (e instanceof org.apache.thrift.TApplicationException) { <line24> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line25> msg = (org.apache.thrift.TApplicationException) e; <line26> } else { <line27> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line28> msg = <line29> new org.apache.thrift.TApplicationException( <line30> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line31> } <line32> try { <line33> fcall.sendResponse(fb, msg, msgType, seqid); <line34> } catch (java.lang.Exception ex) { <line35> fb.close(); <line36> } <line37> } <line38> } <line39> 	 <line29>	No
"public class A { <line0> @SneakyThrows <line1> public static boolean metricsAvailable( <line2> FileSystem fs, String filePath, String datasetId, Integer attempt, String metricsFile) { <line3> String path = String.join(""/"", filePath, datasetId, attempt.toString(), metricsFile); <line4> Path metrics = new Path(path); <line5> return fs.exists(metrics); <line6> } <line7> } <line8> "	 <line0>	No
"public class A { <line0> @RequestMapping(value = ""/res/{apiKeyId}/{guid}"") <line1> public void getResource( <line2> @PathVariable(""apiKeyId"") long apiKeyId, <line3> @PathVariable(""guid"") String rawGuid, <line4> HttpServletResponse response) <line5> throws IOException, TrustRelationshipRevokedException { <line6> String guid = rawGuid; <line7> Integer maxWidth = null; <line8> if (rawGuid.indexOf(""@"") != -1) { <line9> guid = rawGuid.substring(0, rawGuid.indexOf(""@"")); <line10> String formatSpecs = rawGuid.substring(guid.length()); <line11> StringTokenizer st = new StringTokenizer(formatSpecs, ""=""); <line12> st.nextToken(); <line13> String w = st.nextToken(); <line14> maxWidth = Integer.valueOf(w); <line15> } <line16> final Query nativeQuery = <line17> em.createNativeQuery( <line18> String.format( <line19> ""SELECT mime, width FROM Facet_EvernoteResource WHERE apiKeyId=%s AND guid='%s'"", <line20> apiKeyId, guid)); <line21> final Object[] singleResult = (Object[]) nativeQuery.getSingleResult(); <line22> if (singleResult == null) { <line23> response.sendError(404); <line24> return; <line25> } <line26> final String mimeType = (String) singleResult[0]; <line27> response.setContentType(mimeType); <line28> final String devKvsLocation = env.get(""btdatastore.db.location""); <line29> if (devKvsLocation == null) <line30> throw new RuntimeException( <line31> ""No btdatastore.db.location property was specified (local.properties)""); <line32> ApiKey apiKey = guestService.getApiKey(apiKeyId); <line33> File resourceFile = <line34> EvernoteUpdater.getResourceFile( <line35> apiKey.getGuestId(), <line36> apiKeyId, <line37> guid, <line38> EvernoteUpdater.MAIN_APPENDIX, <line39> mimeType, <line40> devKvsLocation); <line41> if (!resourceFile.exists()) { <line42> response.sendError(404); <line43> return; <line44> } <line45> if (mimeType.indexOf(""image"") != -1) { <line46> short width = (Short) singleResult[1]; <line47> int specifiedWidth = maxWidth != null ? maxWidth : DEFAULT_MAX_WIDTH; <line48> if (width > specifiedWidth) { <line49> Thumbnailator.createThumbnail( <line50> new FileInputStream(resourceFile), <line51> response.getOutputStream(), <line52> specifiedWidth, <line53> Integer.MAX_VALUE); <line54> return; <line55> } <line56> } <line57> IOUtils.copy(new FileInputStream(resourceFile), response.getOutputStream()); <line58> } <line59> } <line60> "	 <line42>	Yes
"public class A { <line0> @Override <line1> public void prepare(Object configurationObject) { <line2> try { <line3> connectToCassandra(); <line4> client.start(); <line5> } catch (Exception e) { <line6> return; <line7> } <line8> String selectStatement = getSelectStatement(); <line9> ResultSet rs = client.client().execute(selectStatement); <line10> rowIterator = rs.iterator(); <line11> if (!rowIterator.hasNext()) { <line12> throw new RuntimeException(""Table"" + config.getTable() + ""is empty!""); <line13> } <line14> persistQueue = constructQueue(); <line15> executor = Executors.newSingleThreadExecutor(); <line16> } <line17> } <line18> "	 <line6>	Yes
public class A { <line0> @Override <line1> public SpiResponse<List<SpiAccountBalance>> requestCardBalancesForAccount( <line2> @NotNull SpiContextData contextData, <line3> @NotNull SpiAccountReference accountReference, <line4> @NotNull SpiAccountConsent accountConsent, <line5> @NotNull SpiAspspConsentDataProvider aspspConsentDataProvider) { <line6> byte[] aspspConsentData = aspspConsentDataProvider.loadAspspConsentData(); <line7> try { <line8> GlobalScaResponseTO response = applyAuthorisation(aspspConsentData); <line9> List<SpiAccountBalance> accountBalances = <line10> Optional.ofNullable( <line11> accountRestClient.getBalances(accountReference.getResourceId()).getBody()) <line12> .map(accountMapper::toSpiAccountBalancesList) <line13> .orElseThrow( <line14> () -> <line15> FeignExceptionHandler.getException( <line16> HttpStatus.NOT_FOUND, RESPONSE_STATUS_200_WITH_EMPTY_BODY)); <line17> aspspConsentDataProvider.updateAspspConsentData(consentDataService.store(response)); <line18> return SpiResponse.<List<SpiAccountBalance>>builder().payload(accountBalances).build(); <line19> } catch (FeignException feignException) { <line20> String devMessage = feignExceptionReader.getErrorMessage(feignException); <line21> return SpiResponse.<List<SpiAccountBalance>>builder() <line22> .build(); <line23> } finally { <line24> authRequestInterceptor.setAccessToken(null); <line25> } <line26> } <line27> } <line28> 	 <line12>	No
"public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSession session) <line2> throws ProcessException { <line3> final Integer batchCount = context.getProperty(BATCH_COUNT).asInteger(); <line4> final List<FlowFile> flowFiles = session.get(batchCount); <line5> if (flowFiles == null || flowFiles.isEmpty()) { <line6> return; <line7> } <line8> final StateMap stateMap; <line9> try { <line10> stateMap = session.getState(Scope.LOCAL); <line11> } catch (final IOException e) { <line12> context.yield(); <line13> return; <line14> } <line15> final OrderingContext oc = new OrderingContext(context, session); <line16> oc.groupStates.putAll(stateMap.toMap()); <line17> for (final FlowFile flowFile : flowFiles) { <line18> oc.setFlowFile(flowFile); <line19> if (oc.flowFile == null) { <line20> break; <line21> } <line22> if (!oc.computeGroupId() <line23> || !oc.computeOrder() <line24> || !oc.computeInitialOrder() <line25> || !oc.computeMaxOrder()) { <line26> continue; <line27> } <line28> oc.markFlowFileValid(); <line29> } <line30> oc.transferFlowFiles(); <line31> oc.cleanupInactiveStates(); <line32> try { <line33> session.setState(oc.groupStates, Scope.LOCAL); <line34> } catch (final IOException e) { <line35> throw new RuntimeException( <line36> ""Failed to update state due to "" <line37> + e <line38> + "". Session will be rollback and processor will be yielded for a while."", <line39> e); <line40> } <line41> } <line42> } <line43> "	 <line36>	No
public class A { <line0> public boolean analyzeAndCreate() { <line1> load(); <line2> spliceSequences(); <line3> spliceDonoAcceptorPairs(); <line4> createSpliceSites(); <line5> return true; <line6> } <line7> } <line8> 	 <line1>	Yes
"public class A { <line0> @PayloadRoot(localPart = ""GetMeasurementReportRequest"", namespace = NAMESPACE) <line1> @ResponsePayload <line2> public GetMeasurementReportResponse getMeasurementReport( <line3> @OrganisationIdentification final String organisationIdentification, <line4> @RequestPayload final GetMeasurementReportRequest request) <line5> throws OsgpException { <line6> final GetMeasurementReportResponse response = new GetMeasurementReportResponse(); <line7> try { <line8> final org.opensmartgridplatform.domain.da.measurements.MeasurementReport dataResponse = <line9> this.service.dequeueMeasurementReport(request.getCorrelationUid()); <line10> if (dataResponse != null) { <line11> final MeasurementReport report = this.mapper.map(dataResponse, MeasurementReport.class); <line12> response.setMeasurementReport(report); <line13> response.setResult(OsgpResultType.OK); <line14> } else { <line15> response.setResult(OsgpResultType.NOT_FOUND); <line16> } <line17> } catch (final ResponseNotFoundException e) { <line18> response.setResult(OsgpResultType.NOT_FOUND); <line19> } catch (final Exception e) { <line20> this.handleException(LOGGER, e); <line21> } <line22> return response; <line23> } <line24> } <line25> "	 <line6>	Yes
"public class A { <line0> private void doExecuteScript(final Resource scriptResource) { <line1> if (scriptResource == null || !scriptResource.exists()) { <line2> return; <line3> } <line4> TransactionTemplate transactionTemplate = <line5> new TransactionTemplate(new DataSourceTransactionManager(this.dataSource)); <line6> transactionTemplate.execute( <line7> (TransactionCallback<Void>) <line8> status -> { <line9> JdbcTemplate jdbcTemplate = new JdbcTemplate(this.dataSource); <line10> String[] scripts; <line11> try { <line12> scripts = <line13> StringUtils.delimitedListToStringArray( <line14> stripComments(getScriptLines(scriptResource)), "";""); <line15> } catch (IOException e) { <line16> throw new BeanInitializationException( <line17> ""Cannot load script from ["" + scriptResource + ""]"", e); <line18> } <line19> for (String script : scripts) { <line20> String trimmedScript = script.trim(); <line21> if (StringUtils.hasText(trimmedScript)) { <line22> try { <line23> jdbcTemplate.execute(trimmedScript); <line24> } catch (DataAccessException e) { <line25> if (this.ignoreFailedDrop <line26> && trimmedScript.toLowerCase().startsWith(""drop"") <line27> && logger.isDebugEnabled()) { <line28> } else { <line29> throw e; <line30> } <line31> } <line32> } <line33> } <line34> return null; <line35> }); <line36> } <line37> } <line38> "	 <line28>	Yes
"public class A { <line0> @Override <line1> public void onError(final Throwable th) { <line2> myInstance.setStatus(InstanceStatus.ERROR); <line3> if (th != null) { <line4> myInstance.updateErrors(TypedCloudErrorInfo.fromException(th)); <line5> LOG.warnAndDebugDetails( <line6> ""An error occurred: "" <line7> + th.getLocalizedMessage() <line8> + "" during processing "" <line9> + myInstance.getName(), <line10> th); <line11> th.printStackTrace(); <line12> } else { <line13> myInstance.updateErrors( <line14> new TypedCloudErrorInfo( <line15> ""Unknown error during processing instance "" + myInstance.getName())); <line16> } <line17> } <line18> } <line19> "	 <line10>	No
public class A { <line0> private ComputeLineageResult getLineageResult(long eventId, ComputeLineageSubmission submission) { <line1> final ComputeLineageResult result = submission.getResult(); <line2> try { <line3> if (result.awaitCompletion(10, TimeUnit.SECONDS)) { <line4> return result; <line5> } <line6> } catch (InterruptedException e) { <line7> } finally { <line8> submission.cancel(); <line9> } <line10> return null; <line11> } <line12> } <line13> 	 <line6>	Yes
public class A { <line0> @Override <line1> public void onNext(StreamAccessLogsMessage message) { <line2> counter.inc(); <line3> HistogramMetrics.Timer timer = histogram.createTimer(); <line4> try { <line5> if (isFirst) { <line6> identifier = message.getIdentifier(); <line7> isFirst = false; <line8> role = Role.NONE; <line9> for (ALSHTTPAnalysis analysis : envoyHTTPAnalysisList) { <line10> role = analysis.identify(identifier, role); <line11> } <line12> } <line13> StreamAccessLogsMessage.LogEntriesCase logCase = message.getLogEntriesCase(); <line14> if (LOGGER.isDebugEnabled()) { <line15> } <line16> List<ServiceMeshMetric.Builder> sourceResult = new ArrayList<>(); <line17> switch (logCase) { <line18> case HTTP_LOGS: <line19> StreamAccessLogsMessage.HTTPAccessLogEntries logs = message.getHttpLogs(); <line20> for (final HTTPAccessLogEntry log : logs.getLogEntryList()) { <line21> AccessLogAnalyzer.Result result = AccessLogAnalyzer.Result.builder().build(); <line22> for (ALSHTTPAnalysis analysis : envoyHTTPAnalysisList) { <line23> result = analysis.analysis(result, identifier, log, role); <line24> } <line25> if (CollectionUtils.isNotEmpty(result.getMetrics())) { <line26> sourceResult.addAll(result.getMetrics()); <line27> } <line28> } <line29> break; <line30> case TCP_LOGS: <line31> StreamAccessLogsMessage.TCPAccessLogEntries tcpLogs = message.getTcpLogs(); <line32> for (final TCPAccessLogEntry tcpLog : tcpLogs.getLogEntryList()) { <line33> AccessLogAnalyzer.Result result = AccessLogAnalyzer.Result.builder().build(); <line34> for (TCPAccessLogAnalyzer analyzer : envoyTCPAnalysisList) { <line35> result = analyzer.analysis(result, identifier, tcpLog, role); <line36> } <line37> if (CollectionUtils.isNotEmpty(result.getMetrics())) { <line38> sourceResult.addAll(result.getMetrics()); <line39> } <line40> } <line41> break; <line42> } <line43> sourceDispatcherCounter.inc(sourceResult.size()); <line44> sourceResult.forEach(TelemetryDataDispatcher::process); <line45> } finally { <line46> timer.finish(); <line47> } <line48> } <line49> } <line50> 	 <line15>	Yes
"public class A { <line0> private PlacementDemand buildDemand(String id, ModelInfoMetadata metadata) { <line1> PlacementDemand placementDemand = new PlacementDemand(); <line2> if (isNotBlank(id) && isNotBlank(metadata.getModelInstanceName())) { <line3> placementDemand.setServiceResourceId(id); <line4> placementDemand.setResourceModuleName(metadata.getModelInstanceName()); <line5> placementDemand.setResourceModelInfo(buildModelInfo(metadata)); <line6> } else { <line7> throw new BpmnError(UNPROCESSABLE, RESOURCE_MISSING_DATA + ""modelInstanceName""); <line8> } <line9> return placementDemand; <line10> } <line11> } <line12> "	 <line0>	No
"public class A { <line0> @Override <line1> public TaskState transition(Task task, TaskEvent taskEvent) { <line2> TaskTAttemptFailedEvent attemptEvent = <line3> TUtil.checkTypeAndGet(taskEvent, TaskTAttemptFailedEvent.class); <line4> task.failedAttempts++; <line5> task.finishedAttempts++; <line6> boolean retry = task.failedAttempts < task.maxAttempts; <line7> LOG.info( <line8> ""====================================================================================""); <line9> if (retry) { <line10> if (task.successfulAttempt == null) { <line11> task.addAndScheduleAttempt(); <line12> } <line13> } else { <line14> task.finishTask(); <line15> task.eventHandler.handle(new StageTaskFailedEvent(task.getId(), attemptEvent.getException())); <line16> return TaskState.FAILED; <line17> } <line18> return task.getState(); <line19> } <line20> } <line21> "	 <line17>	No
public class A { <line0> public void closeIfNecessary(Connection con, ResultSet rs) { <line1> try { <line2> if (rs != null) rs.close(); <line3> if (con != null) con.close(); <line4> } catch (SQLException sqle) { <line5> if (logger.isWarnEnabled()) { <line6> } <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
public class A { <line0> public void registerCustomizer(ICMLCustomizer customizer) { <line1> if (customizers == null) customizers = new HashMap<String, ICMLCustomizer>(); <line2> if (!customizers.containsKey(customizer.getClass().getName())) { <line3> customizers.put(customizer.getClass().getName(), customizer); <line4> } else { <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> public static void configureIndexAndTypes(String ds, List<Map<String, String>> errorList) { <line1> String _payLoad = <line2> ""{\""settings\"" : { \""number_of_shards\"" : 3,\""number_of_replicas\"" : 1 },\""mappings\"": {""; <line3> Set<String> types = ConfigManager.getTypes(ds); <line4> Iterator<String> it = types.iterator(); <line5> while (it.hasNext()) { <line6> String _type = it.next(); <line7> String indexName = ds + ""_"" + _type; <line8> if (!indexExists(indexName)) { <line9> StringBuilder payLoad = new StringBuilder(_payLoad); <line10> payLoad.append( <line11> ""\"""" <line12> + _type <line13> + ""\"":{},\""issue_"" <line14> + _type <line15> + ""\"": { \""_parent\"": {\""type\"": \"""" <line16> + _type <line17> + ""\""}},\""issue_"" <line18> + _type <line19> + ""_audit\"": { \""_parent\"": {\""type\"": \""issue_"" <line20> + _type <line21> + ""\""}},\""issue_"" <line22> + _type <line23> + ""_comment\"": { \""_parent\"": {\""type\"": \""issue_"" <line24> + _type <line25> + ""\""}},\""issue_"" <line26> + _type <line27> + ""_exception\"": { \""_parent\"": {\""type\"": \""issue_"" <line28> + _type <line29> + ""\""}}""); <line30> payLoad.append(""}}""); <line31> try { <line32> invokeAPI(""PUT"", indexName, payLoad.toString()); <line33> } catch (IOException e) { <line34> Map<String, String> errorMap = new HashMap<>(); <line35> errorMap.put(ERROR, ""Error in configureIndexAndTypes""); <line36> errorMap.put(ERROR_TYPE, WARN); <line37> errorMap.put(EXCEPTION, e.getMessage()); <line38> errorList.add(errorMap); <line39> } <line40> } <line41> try { <line42> invokeAPI(""PUT"", ""/"" + indexName + ""/_alias/"" + ds, null); <line43> invokeAPI(""PUT"", ""/"" + indexName + ""/_alias/"" + ""ds-all"", null); <line44> } catch (IOException e) { <line45> } <line46> } <line47> } <line48> } <line49> "	 <line28>	No
"public class A { <line0> public static void waitForKafkaUserDeletion(String userName) { <line1> TestUtils.waitFor( <line2> ""KafkaUser deletion "" + userName, <line3> Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, <line4> DELETION_TIMEOUT, <line5> () -> { <line6> if (KafkaUserResource.kafkaUserClient() <line7> .inNamespace(kubeClient().getNamespace()) <line8> .withName(userName) <line9> .get() <line10> == null) { <line11> return true; <line12> } else { <line13> cmdKubeClient().deleteByName(KafkaUser.RESOURCE_KIND, userName); <line14> return false; <line15> } <line16> }, <line17> () -> <line18> } <line19> } <line20> "	 <line18>	Yes
public class A { <line0> @Override <line1> public void abortJob(JobContext jobContext, State state) throws IOException { <line2> Configuration configuration = jobContext.getConfiguration(); <line3> Path tableOutput = BlurOutputFormat.getOutputPath(configuration); <line4> makeSureNoEmptyShards(configuration, tableOutput); <line5> FileSystem fileSystem = tableOutput.getFileSystem(configuration); <line6> for (FileStatus fileStatus : fileSystem.listStatus(tableOutput)) { <line7> if (isShard(fileStatus)) { <line8> commitOrAbortJob(jobContext, fileStatus.getPath(), false); <line9> } <line10> } <line11> } <line12> } <line13> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public String getTimeDescription(Locale locale, long milliseconds, boolean approximate) { <line2> String description = Time.getDescription(milliseconds, approximate); <line3> String value = null; <line4> try { <line5> String[] parts = description.split(StringPool.SPACE, 2); <line6> String unit = StringUtil.toLowerCase(parts[1]); <line7> if (unit.equals(""second"")) { <line8> unit += ""[time]""; <line9> } <line10> value = format(locale, ""x-"" + unit, parts[0]); <line11> } catch (Exception exception) { <line12> if (_log.isWarnEnabled()) { <line13> } <line14> } <line15> return value; <line16> } <line17> } <line18> "	 <line4>	No
public class A { <line0> public Optional<DataBroker> resolveDataBrokerForMountPoint( <line1> @Nonnull InstanceIdentifier<Node> iidToMountPoint) { <line2> try { <line3> if (VbdNetconfTransaction.NODE_DATA_BROKER_MAP.get(iidToMountPoint) != null) { <line4> return Optional.of( <line5> VbdNetconfTransaction.NODE_DATA_BROKER_MAP.get(iidToMountPoint).getKey()); <line6> } <line7> final SettableFuture<Boolean> futureNodeStatus = SettableFuture.create(); <line8> final NodeKey nodeKey = iidToMountPoint.firstKeyOf(Node.class); <line9> new GbpVppNetconfConnectionProbe(nodeKey, futureNodeStatus, dataBroker); <line10> if (futureNodeStatus.get(NODE_CONNECTION_TIMER, TimeUnit.SECONDS)) { <line11> Future<Optional<MountPoint>> mountPointfuture = getMountpointFromSal(iidToMountPoint); <line12> Optional<MountPoint> potentialMountPoint = mountPointfuture.get(); <line13> if (potentialMountPoint.isPresent()) { <line14> final Optional<DataBroker> dataBrokerOpt = <line15> potentialMountPoint.get().getService(DataBroker.class); <line16> VbdNetconfTransaction.NODE_DATA_BROKER_MAP.put( <line17> iidToMountPoint, <line18> new AbstractMap.SimpleEntry(dataBrokerOpt.get(), new ReentrantLock())); <line19> return dataBrokerOpt; <line20> } else { <line21> return Optional.absent(); <line22> } <line23> } else { <line24> return Optional.absent(); <line25> } <line26> } catch (TimeoutException e) { <line27> return Optional.absent(); <line28> } catch (ExecutionException | InterruptedException e) { <line29> return Optional.absent(); <line30> } <line31> } <line32> } <line33> 	 <line2>	No
public class A { <line0> public synchronized ClientSessionFactory getClientSessionFactory() throws Exception { <line1> if (this.sessionFactory == null || this.sessionFactory.isClosed()) { <line2> this.sessionFactory = locator.createSessionFactory(); <line3> this.sessionFactory.getConnection().addCloseListener(this); <line4> } <line5> return this.sessionFactory; <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public <V> V run(String callableName, RetryOperation<V> operation) { <line2> int attempt = 1; <line3> while (true) { <line4> try { <line5> return operation.run(); <line6> } catch (Exception e) { <line7> if (!exceptionClass.isInstance(e)) { <line8> throwIfUnchecked(e); <line9> throw new RuntimeException(e); <line10> } <line11> E qe = (E) e; <line12> exceptionCallback.accept(qe); <line13> if (attempt >= maxAttempts || !retryPredicate.test(qe)) { <line14> throw qe; <line15> } <line16> attempt++; <line17> int delayMillis = <line18> (int) <line19> min( <line20> minBackoffDelay.toMillis() * pow(scaleFactor, attempt - 1), <line21> maxBackoffDelay.toMillis()); <line22> int jitterMillis = ThreadLocalRandom.current().nextInt(max(1, (int) (delayMillis * 0.1))); <line23> try { <line24> MILLISECONDS.sleep(delayMillis + jitterMillis); <line25> } catch (InterruptedException ie) { <line26> currentThread().interrupt(); <line27> throw new RuntimeException(ie); <line28> } <line29> } <line30> } <line31> } <line32> } <line33> "	 <line23>	Yes
"public class A { <line0> private MassnahmeInformationTransfer processMassnahme( <line1> MbMassn mbMassn, <line2> String encoding, <line3> List<?> hqlResult, <line4> MassnahmeInformationTransfer massnahmeinformation) { <line5> MbMassnTxt mTxt = (MbMassnTxt) hqlResult.get(0); <line6> massnahmeinformation.setAbstract_(mTxt.getAbstract_()); <line7> massnahmeinformation.setTitel(mTxt.getName()); <line8> try { <line9> if (mTxt.getBeschreibung() != null) { <line10> massnahmeinformation.setDescription( <line11> convertClobToStringEncodingSave(mTxt.getBeschreibung(), encoding)); <line12> } <line13> if (mTxt.getHtmltext() != null) { <line14> massnahmeinformation.setHtmltext( <line15> convertClobToStringEncodingSave(mTxt.getHtmltext(), encoding)); <line16> } <line17> } catch (IOException e) { <line18> } <line19> String prefix = """"; <line20> if (mbMassn.getUserdef() == GSDBConstants.USERDEF_YES) { <line21> prefix = USER_DEFINED_CONTROL_IDENTIFIER; <line22> } <line23> massnahmeinformation.setId(prefix + mbMassn.getMskId().intValue() + ""."" + mbMassn.getNr()); <line24> massnahmeinformation.setSiegelstufe('A'); <line25> massnahmeinformation.setZyklus(""-1""); <line26> return massnahmeinformation; <line27> } <line28> } <line29> "	 <line18>	Yes
"public class A { <line0> public Response tpservice(TPSVCINFO svcinfo) throws ConnectionException, ConfigurationException { <line1> X_COMMON rcv = (X_COMMON) svcinfo.getBuffer(); <line2> long acct_no = rcv.getLong(""acct_no""); <line3> short amount = rcv.getShort(""amount""); <line4> String resp = ""NAMINGERROR""; <line5> try { <line6> Context ctx = new InitialContext(); <line7> CreditRemote bean = <line8> (CreditRemote) <line9> ctx.lookup( <line10> ""java:global/blacktie-quickstarts-integration1-ejb-ear-5.11.3.Final-SNAPSHOT/blacktie-quickstarts-integration1-ejb-5.11.3.Final-SNAPSHOT/CreditBean!org.jboss.narayana.blacktie.quickstarts.integration1.ejb.CreditRemote""); <line11> resp = bean.credit(acct_no, amount); <line12> } catch (NamingException e) { <line13> } <line14> X_OCTET buffer = (X_OCTET) svcinfo.getConnection().tpalloc(""X_OCTET"", null); <line15> buffer.setByteArray(resp.getBytes()); <line16> return new Response(Connection.TPSUCCESS, 0, buffer, 0); <line17> } <line18> } <line19> "	 <line13>	Yes
"public class A { <line0> protected void checkConcurrentUpdate(Throwable e) throws ConcurrentUpdateException { <line1> if (dialect.isConcurrentUpdateException(e)) { <line2> throw new ConcurrentUpdateException(""Concurrent update"", e); <line3> } <line4> } <line5> } <line6> "	 <line5>	No
public class A { <line0> private static void collectLogsScaleTestClient( <line1> String clientId, Path logsPath, Map<String, String> labels) { <line2> try { <line3> Files.createDirectories(logsPath); <line4> GlobalLogCollector collector = <line5> new GlobalLogCollector(kube, logsPath, SCALE_TEST_CLIENTS_PROJECT); <line6> collector.collectLogsOfPodsByLabels(SCALE_TEST_CLIENTS_PROJECT, null, labels); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
"public class A { <line0> public Referral getReferralOnAncestor( <line1> LdapSession session, Dn reqTargetDn, SearchRequest req, Entry referralAncestor) <line2> throws LdapException { <line3> if (IS_DEBUG) { <line4> } <line5> Attribute refAttr = <line6> ((ClonedServerEntry) referralAncestor).getOriginalEntry().get(SchemaConstants.REF_AT); <line7> Referral referral = new ReferralImpl(); <line8> for (Value value : refAttr) { <line9> String ref = value.getString(); <line10> if (IS_DEBUG) { <line11> } <line12> if (!ref.startsWith(""ldap"")) { <line13> referral.addLdapUrl(ref); <line14> continue; <line15> } <line16> LdapUrl ldapUrl = null; <line17> try { <line18> ldapUrl = new LdapUrl(ref); <line19> } catch (LdapURLEncodingException e) { <line20> ldapUrl = new LdapUrl(); <line21> } <line22> Dn urlDn = <line23> new Dn( <line24> session.getCoreSession().getDirectoryService().getSchemaManager(), <line25> ldapUrl.getDn().getName()); <line26> if (urlDn.equals(referralAncestor.getDn())) { <line27> StringBuilder buf = new StringBuilder(); <line28> buf.append(ldapUrl.getScheme()); <line29> buf.append(ldapUrl.getHost()); <line30> if (ldapUrl.getPort() > 0) { <line31> buf.append("":""); <line32> buf.append(ldapUrl.getPort()); <line33> } <line34> referral.addLdapUrl(buf.toString()); <line35> continue; <line36> } <line37> Dn suffix = req.getBase().getDescendantOf(referralAncestor.getDn()); <line38> urlDn = urlDn.add(suffix); <line39> StringBuilder buf = new StringBuilder(); <line40> buf.append(ldapUrl.getScheme()); <line41> buf.append(ldapUrl.getHost()); <line42> if (ldapUrl.getPort() > 0) { <line43> buf.append("":""); <line44> buf.append(ldapUrl.getPort()); <line45> } <line46> buf.append(""/""); <line47> buf.append(LdapUrl.urlEncode(urlDn.getName(), false)); <line48> referral.addLdapUrl(buf.toString()); <line49> } <line50> return referral; <line51> } <line52> } <line53> "	 <line20>	Yes
public class A { <line0> private void renameTempFile(File source) { <line1> File destination = <line2> new File(StringUtils.removeEnd(source.getAbsolutePath(), TEMP_FILE_EXTENSION)); <line3> boolean success = source.renameTo(destination); <line4> if (!success) { <line5> } <line6> } <line7> } <line8> 	 <line4>	No
public class A { <line0> private LabelDescriptor getLabelDescriptor() { <line1> Class<? extends LabelDescriptor> cls = EntityCreationPreferences.getLabelDescriptorClass(); <line2> if (labelDescriptor == null || !cls.equals(labelDescriptor.getClass())) { <line3> try { <line4> labelDescriptor = cls.newInstance(); <line5> } catch (InstantiationException | IllegalAccessException e) { <line6> } <line7> } <line8> return labelDescriptor; <line9> } <line10> } <line11> 	 <line6>	Yes
public class A { <line0> private CellMappingStrategy loadStrategyFromClassName(String strategyClassName) { <line1> ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); <line2> if (classLoader != null) { <line3> try { <line4> Class<?> clazz = classLoader.loadClass(strategyClassName); <line5> return (CellMappingStrategy) clazz.newInstance(); <line6> } catch (Throwable e) { <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	 <line11>	No
"public class A { <line0> private void enforce(ResponseCtx res) { <line1> @SuppressWarnings(""unchecked"") <line2> Set<Result> results = res.getResults(); <line3> for (Result r : results) { <line4> if (r.getDecision() != Result.DECISION_PERMIT) { <line5> if (logger.isDebugEnabled()) { <line6> } <line7> switch (r.getDecision()) { <line8> case Result.DECISION_DENY: <line9> throw CXFUtility.getFault(new AuthzDeniedException(""Deny"")); <line10> case Result.DECISION_INDETERMINATE: <line11> throw CXFUtility.getFault(new AuthzDeniedException(""Indeterminate"")); <line12> case Result.DECISION_NOT_APPLICABLE: <line13> throw CXFUtility.getFault(new AuthzDeniedException(""NotApplicable"")); <line14> default: <line15> } <line16> } <line17> } <line18> if (logger.isDebugEnabled()) { <line19> } <line20> } <line21> } <line22> "	 <line6>	Yes
public class A { <line0> @Override <line1> public NotificationRegistration registerService( <line2> final ReconciliationNotificationListener reconciliationTask) { <line3> registeredServices <line4> .computeIfAbsent(reconciliationTask.getPriority(), services -> new ArrayList<>()) <line5> .add(reconciliationTask); <line6> ReconciliationServiceDelegate registration = <line7> new ReconciliationServiceDelegate( <line8> () -> { <line9> registeredServices <line10> .computeIfPresent( <line11> reconciliationTask.getPriority(), (priority, services) -> services) <line12> .remove(reconciliationTask); <line13> decideResultState(reconciliationTask.getResultState()); <line14> }); <line15> decideResultState(reconciliationTask.getResultState()); <line16> return registration; <line17> } <line18> } <line19> 	 <line15>	No
"public class A { <line0> private RouterStatus collectStatus(RouterManagement routerManagement, Pod router) { <line1> try { <line2> int port = 0; <line3> for (Container container : router.getSpec().getContainers()) { <line4> if (container.getName().equals(""router"")) { <line5> for (ContainerPort containerPort : container.getPorts()) { <line6> if (containerPort.getName().equals(""amqps-normal"")) { <line7> port = containerPort.getContainerPort(); <line8> } <line9> } <line10> } <line11> } <line12> if (port != 0) { <line13> Map<RouterEntity, List<List<?>>> response = <line14> routerManagement.query(router.getStatus().getPodIP(), port, entities); <line15> RouterConnections connections = null; <line16> if (response.containsKey(connection)) { <line17> connections = collectConnectionInfo(response.get(connection)); <line18> } <line19> List<String> neighbors = null; <line20> if (response.containsKey(node)) { <line21> neighbors = <line22> filterOnAttribute(String.class, 0, response.get(node)).stream() <line23> .filter(n -> !n.equals(router.getMetadata().getName())) <line24> .collect(Collectors.toList()); <line25> } <line26> long undeliveredTotal = 0; <line27> if (response.containsKey(link)) { <line28> List<String> linkTypes = filterOnAttribute(String.class, 0, response.get(link)); <line29> List<UnsignedLong> undelivered = <line30> filterOnAttribute(UnsignedLong.class, 1, response.get(link)); <line31> for (int i = 0; i < linkTypes.size(); i++) { <line32> if (""inter-router"".equals(linkTypes.get(i))) { <line33> undeliveredTotal += undelivered.get(i) != null ? undelivered.get(i).longValue() : 0; <line34> } <line35> } <line36> } <line37> return new RouterStatus( <line38> router.getMetadata().getName(), connections, neighbors, undeliveredTotal); <line39> } <line40> } catch (Exception e) { <line41> } <line42> return null; <line43> } <line44> } <line45> "	 <line9>	No
"public class A { <line0> @Test(groups = ""Live"", dataProvider = ""fromImageNamePattern"") <line1> public void testProvisionVmUsingImageNamePattern( <line2> String regionName, String imageNamePattern, String imageOwner) { <line3> loc = <line4> (JcloudsLocation) <line5> mgmt() <line6> .getLocationRegistry() <line7> .getLocationManaged(provider + (regionName == null ? """" : "":"" + regionName)); <line8> SshMachineLocation machine = <line9> obtainMachine( <line10> MutableMap.of( <line11> ""imageNameRegex"", <line12> imageNamePattern, <line13> ""imageOwner"", <line14> imageOwner, <line15> JcloudsLocation.MACHINE_CREATE_ATTEMPTS, <line16> 2)); <line17> assertTrue(machine.isSshable()); <line18> } <line19> } <line20> "	 <line17>	Yes
"public class A { <line0> @Override <line1> public void execute(ITransaction transaction, HttpServletRequest req, HttpServletResponse resp) <line2> throws IOException, LockFailedException { <line3> if (readOnly) { <line4> resp.sendError(WebdavStatus.SC_FORBIDDEN); <line5> return; <line6> } <line7> String path = getRelativePath(req); <line8> String parentPath = getParentPath(getCleanPath(path)); <line9> if (!isUnlocked(transaction, req, resourceLocks, parentPath)) { <line10> resp.setStatus(WebdavStatus.SC_LOCKED); <line11> return; <line12> } <line13> if (!isUnlocked(transaction, req, resourceLocks, path)) { <line14> resp.setStatus(WebdavStatus.SC_LOCKED); <line15> return; <line16> } <line17> String tempLockOwner = ""doDelete"" + System.currentTimeMillis() + req.toString(); <line18> try { <line19> if (!resourceLocks.lock( <line20> transaction, path, tempLockOwner, false, 0, TEMP_TIMEOUT, TEMPORARY)) { <line21> resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR); <line22> return; <line23> } <line24> Hashtable<String, Integer> errorList = new Hashtable<String, Integer>(); <line25> deleteResource(transaction, path, errorList, req, resp); <line26> if (!errorList.isEmpty()) { <line27> sendReport(req, resp, errorList); <line28> } <line29> } catch (AccessDeniedException e) { <line30> resp.sendError(WebdavStatus.SC_FORBIDDEN); <line31> } catch (ObjectAlreadyExistsException e) { <line32> resp.sendError(WebdavStatus.SC_NOT_FOUND, req.getRequestURI()); <line33> } catch (WebdavException e) { <line34> resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR); <line35> } finally { <line36> resourceLocks.unlockTemporaryLockedObjects(transaction, path, tempLockOwner); <line37> } <line38> } <line39> } <line40> "	 <line18>	No
"public class A { <line0> @GetMapping(""/pauseAllGlobalTransactions"") <line1> public ResponseEntity<ReturnValue> pauseAllGlobalTransactions() { <line2> ReturnValue rv = new ReturnValue(); <line3> try { <line4> if (consistencyCache.getBooleanValue(null, null, ConfigCenterType.PauseGlobalTx)) { <line5> return ResponseEntity.ok(rv); <line6> } <line7> String ipPort = request.getRemoteAddr() + "":"" + request.getRemotePort(); <line8> configCenterService.createConfigCenter( <line9> new ConfigCenter( <line10> null, <line11> null, <line12> null, <line13> ConfigCenterStatus.Normal, <line14> 1, <line15> ConfigCenterType.PauseGlobalTx, <line16> TxleConstants.ENABLED, <line17> ipPort + "" - pauseAllTransaction"")); <line18> List<TxEvent> unendedTxEventList = <line19> eventRepository.selectUnendedTxEvents(EventScanner.getUnendedMinEventId()); <line20> if (unendedTxEventList != null && !unendedTxEventList.isEmpty()) { <line21> List<String> globalTxIdList = new ArrayList<>(); <line22> unendedTxEventList.forEach( <line23> event -> { <line24> if (!globalTxIdList.contains(event.globalTxId())) { <line25> globalTxIdList.add(event.globalTxId()); <line26> } <line27> }); <line28> unendedTxEventList.forEach( <line29> event -> { <line30> List<TxEvent> pauseContinueEventList = <line31> eventRepository.selectPausedAndContinueEvent(event.globalTxId()); <line32> if (pauseContinueEventList != null && !pauseContinueEventList.isEmpty()) { <line33> TxEvent pausedEvent = pauseContinueEventList.get(0); <line34> if (AdditionalEventType.SagaPausedEvent.name().equals(pausedEvent.type()) <line35> || AdditionalEventType.SagaAutoContinuedEvent.name() <line36> .equals(pausedEvent.type())) { <line37> globalTxIdList.remove(event.globalTxId()); <line38> } <line39> } <line40> }); <line41> if (globalTxIdList.isEmpty()) { <line42> return ResponseEntity.ok(rv); <line43> } <line44> unendedTxEventList.forEach( <line45> event -> { <line46> if (globalTxIdList.contains(event.globalTxId())) { <line47> globalTxIdList.remove(event.globalTxId()); <line48> TxEvent pausedEvent = <line49> new TxEvent( <line50> ipPort, <line51> ipPort, <line52> event.globalTxId(), <line53> event.localTxId(), <line54> event.parentTxId(), <line55> AdditionalEventType.SagaPausedEvent.name(), <line56> """", <line57> 0, <line58> """", <line59> 0, <line60> event.category(), <line61> null); <line62> eventRepository.save(pausedEvent); <line63> txleMetrics.countTxNumber(event); <line64> } <line65> }); <line66> } <line67> } catch (Exception e) { <line68> rv.setMessage(""Failed to pause all global transactions.""); <line69> return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(rv); <line70> } <line71> return ResponseEntity.ok(rv); <line72> } <line73> } <line74> "	 <line69>	Yes
public class A { <line0> private void addReplies() throws NodeStoreException { <line1> String rsmItem = afterItemId; <line2> boolean after = true; <line3> if (null != beforeItemId) { <line4> rsmItem = beforeItemId; <line5> after = false; <line6> } <line7> CloseableIterator<NodeItem> items = <line8> channelManager.getNodeItemReplies(node, parentId, rsmItem, after, maxResults); <line9> NodeItem item; <line10> Element entry; <line11> Element itemElement; <line12> Element itemsElement = pubsub.addElement(XMLConstants.ITEMS_ELEM); <line13> itemsElement.addAttribute(XMLConstants.NODE_ATTR, node); <line14> while (items.hasNext()) { <line15> item = items.next(); <line16> try { <line17> entry = xmlReader.read(new StringReader(item.getPayload())).getRootElement(); <line18> itemElement = itemsElement.addElement(XMLConstants.ITEM_ELEM); <line19> itemElement.addAttribute(XMLConstants.ID_ATTR, item.getId()); <line20> if (null == firstItemId) { <line21> firstItemId = item.getId(); <line22> } <line23> lastItemId = item.getId(); <line24> itemElement.add(entry); <line25> } catch (DocumentException e) { <line26> } <line27> } <line28> } <line29> } <line30> 	 <line26>	Yes
public class A { <line0> public void log(String msg) { <line1> } <line2> } <line3> 	 <line1>	Yes
public class A { <line0> @Override <line1> public synchronized void resetConnectionFactory(ConnectionFactory cachedFactory) { <line2> if (cachedFactory == connectionFactory) { <line3> connectionFactory = null; <line4> } <line5> } <line6> } <line7> 	 <line3>	Yes
public class A { <line0> @Override <line1> public void render(RenderRequest renderRequest, RenderResponse renderResponse) <line2> throws IOException, PortletException { <line3> try { <line4> CPAssetCategoriesNavigationDisplayContext cpAssetCategoryNavigationDisplayContext = <line5> new CPAssetCategoriesNavigationDisplayContext( <line6> _portal.getHttpServletRequest(renderRequest), <line7> _assetCategoryService, <line8> _assetVocabularyService, <line9> _commerceMediaResolver, <line10> _cpAttachmentFileEntryService, <line11> _cpFriendlyURL, <line12> _friendlyURLEntryLocalService, <line13> _portal); <line14> renderRequest.setAttribute( <line15> WebKeys.PORTLET_DISPLAY_CONTEXT, cpAssetCategoryNavigationDisplayContext); <line16> } catch (Exception exception) { <line17> } <line18> super.render(renderRequest, renderResponse); <line19> } <line20> } <line21> 	 <line17>	Yes
"public class A { <line0> @Test(groups = {""wso2.mb"", ""queue""}) <line1> public void allUnacknowledgeMessageListenerPerAckTestCase() <line2> throws AndesClientConfigurationException, XPathExpressionException, IOException, JMSException, <line3> AndesClientException, NamingException { <line4> long sendCount = 10; <line5> final List<String> receivedMessages = new ArrayList<>(); <line6> AndesJMSConsumerClientConfiguration consumerConfig = <line7> new AndesJMSConsumerClientConfiguration( <line8> getAMQPPort(), ExchangeType.QUEUE, ""allUnacknowledgePerAckQueue""); <line9> consumerConfig.setAcknowledgeMode(JMSAcknowledgeMode.PER_MESSAGE_ACKNOWLEDGE); <line10> consumerConfig.setAsync(false); <line11> AndesJMSPublisherClientConfiguration publisherConfig = <line12> new AndesJMSPublisherClientConfiguration( <line13> getAMQPPort(), ExchangeType.QUEUE, ""allUnacknowledgePerAckQueue""); <line14> publisherConfig.setNumberOfMessagesToSend(sendCount); <line15> AndesClient consumerClient = new AndesClient(consumerConfig, true); <line16> final AndesJMSConsumer andesJMSConsumer = consumerClient.getConsumers().get(0); <line17> MessageConsumer receiver = andesJMSConsumer.getReceiver(); <line18> receiver.setMessageListener( <line19> new MessageListener() { <line20> @Override <line21> public void onMessage(Message message) { <line22> try { <line23> TextMessage textMessage = (TextMessage) message; <line24> if (receivedMessages.contains(textMessage.getText())) { <line25> message.acknowledge(); <line26> } <line27> receivedMessages.add(textMessage.getText()); <line28> andesJMSConsumer.getReceivedMessageCount().incrementAndGet(); <line29> } catch (JMSException e) { <line30> throw new RuntimeException(""Exception occurred when receiving messages."", e); <line31> } <line32> } <line33> }); <line34> AndesClient publisherClient = new AndesClient(publisherConfig, true); <line35> MessageProducer sender = publisherClient.getPublishers().get(0).getSender(); <line36> for (int i = 0; i < sendCount; i++) { <line37> TextMessage textMessage = <line38> publisherClient <line39> .getPublishers() <line40> .get(0) <line41> .getSession() <line42> .createTextMessage(""#"" + Integer.toString(i)); <line43> sender.send(textMessage); <line44> } <line45> AndesClientUtils.waitForMessagesAndShutdown( <line46> consumerClient, AndesClientConstants.DEFAULT_RUN_TIME); <line47> for (int i = 0; i < sendCount * 2; i++) { <line48> if (i < sendCount) { <line49> Assert.assertEquals( <line50> receivedMessages.get(i), <line51> ""#"" + Integer.toString(i), <line52> ""Invalid messages received. "" + ""#"" + Integer.toString(i) + """" + "" expected.""); <line53> } else { <line54> Assert.assertEquals( <line55> receivedMessages.get(i), <line56> ""#"" + Integer.toString(i - 10), <line57> ""Invalid messages "" + ""received. #"" + Integer.toString(i - 10) + "" expected.""); <line58> } <line59> } <line60> Assert.assertEquals(receivedMessages.size(), sendCount * 2, ""Message receiving failed.""); <line61> } <line62> } <line63> "	 <line33>	No
"public class A { <line0> @Override <line1> protected void body() { <line2> Throwable err = null; <line3> try { <line4> U.enhanceThreadName("":"" + port); <line5> while (!isCancelled()) { <line6> Socket sock; <line7> blockingSectionBegin(); <line8> try { <line9> sock = srvrSock.accept(); <line10> } finally { <line11> blockingSectionEnd(); <line12> } <line13> long tsNanos = System.nanoTime(); <line14> if (log.isInfoEnabled()) <line15> SocketReader reader = new SocketReader(sock); <line16> synchronized (mux) { <line17> readers.add(reader); <line18> } <line19> if (log.isInfoEnabled()) <line20> reader.start(); <line21> spi.stats.onServerSocketInitialized(U.millisSinceNanos(tsNanos)); <line22> onIdle(); <line23> } <line24> } catch (IOException e) { <line25> onException(""Failed to accept TCP connection."", e); <line26> if (!runner().isInterrupted()) { <line27> err = e; <line28> if (U.isMacInvalidArgumentError(e)) <line29> } <line30> } catch (Throwable t) { <line31> err = t; <line32> throw t; <line33> } finally { <line34> if (spi.ignite() instanceof IgniteEx) { <line35> if (err == null && !spi.isNodeStopping0() && spiStateCopy() != DISCONNECTING) <line36> err = new IllegalStateException(""Worker "" + name() + "" is terminated unexpectedly.""); <line37> FailureProcessor failure = ((IgniteEx) spi.ignite()).context().failure(); <line38> if (err instanceof OutOfMemoryError) <line39> failure.process(new FailureContext(CRITICAL_ERROR, err)); <line40> else if (err != null) failure.process(new FailureContext(SYSTEM_WORKER_TERMINATION, err)); <line41> } <line42> U.closeQuiet(srvrSock); <line43> } <line44> } <line45> } <line46> "	 <line24>	No
public class A { <line0> @Override <line1> public List<DataTreeNode> getNextNodeList(final TreeMapState state) { <line2> List<DataTreeNode> result = TreeMapState.empty(); <line3> long now = JitterClock.globalTime(); <line4> DataTreeNode root = state.current(); <line5> if (preempt && (state.processorClosing() || expensiveShutdownTest())) { <line6> return result; <line7> } <line8> findAndPruneChildren(state, root, now, relativeDown, treePath); <line9> return result; <line10> } <line11> } <line12> 	 <line11>	No
"public class A { <line0> @Before <line1> public void setUp() { <line2> try { <line3> System.setProperty(""org.odftoolkit.odfdom.tmpfile.disable"", ""true""); <line4> String userPropTempEnable = System.getProperty(""org.odftoolkit.odfdom.tmpfile.disable""); <line5> } catch (Exception e) { <line6> Logger.getLogger(NoTempFileTest.class.getName()).log(Level.SEVERE, e.getMessage(), e); <line7> Assert.fail(e.getMessage()); <line8> } <line9> } <line10> } <line11> "	 <line5>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> toDispose.discardState(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
public class A { <line0> protected void localPerform() throws IOException { <line1> ServerName server = PolicyBasedChaosMonkey.selectRandomItem(getCurrentServers()); <line2> String hostname = server.getHostname(); <line3> try { <line4> clusterManager.execSudoWithRetries(hostname, timeout, getCommand(ADD)); <line5> Thread.sleep(duration); <line6> } catch (InterruptedException e) { <line7> } finally { <line8> clusterManager.execSudoWithRetries(hostname, timeout, getCommand(DELETE)); <line9> } <line10> } <line11> } <line12> 	 <line1>	Yes
public class A { <line0> protected void preparePremasterSecret(SSL2ClientMasterKeyMessage msg) { <line1> msg.getComputations().setPremasterSecret(premasterSecret); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void write(SinkRecord record) { <line2> if (schema == null) { <line3> schema = recordView.getViewSchema(record, true); <line4> try { <line5> org.apache.avro.Schema avroSchema = avroData.fromConnectSchema(schema); <line6> s3ParquetOutputFile = new S3ParquetOutputFile(storage, adjustedFilename); <line7> writer = <line8> AvroParquetWriter.<GenericRecord>builder(s3ParquetOutputFile) <line9> .withSchema(avroSchema) <line10> .withWriteMode(ParquetFileWriter.Mode.OVERWRITE) <line11> .withDictionaryEncoding(true) <line12> .withCompressionCodec(storage.conf().parquetCompressionCodecName()) <line13> .withPageSize(PAGE_SIZE) <line14> .build(); <line15> } catch (IOException e) { <line16> throw new ConnectException(e); <line17> } <line18> } <line19> Object value = avroData.fromConnectData(schema, recordView.getView(record, true)); <line20> try { <line21> writer.write((GenericRecord) value); <line22> } catch (IOException e) { <line23> throw new ConnectException(e); <line24> } <line25> } <line26> } <line27> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void bind(Object service, Map serviceProperties) { <line2> try { <line3> if (service instanceof DataProvider) { <line4> DataProvider provider = (DataProvider) service; <line5> taskDataProviderService.registerProvider(provider.toJSON()); <line6> if (handler != null) { <line7> handler.addDataProvider(provider); <line8> } <line9> } <line10> } catch (RuntimeException e) { <line11> } <line12> } <line13> } <line14> 	 <line9>	Yes
public class A { <line0> @Override <line1> public void registerAction(CudaContext context, INDArray result, INDArray... operands) { <line2> if (totalHits.incrementAndGet() % 25000 == 0) { <line3> } <line4> cudaEvent_t event = new cudaEvent_t(nativeOps.createEvent()); <line5> event.setLaneId(context.getLaneId()); <line6> nativeOps.registerEvent(event, context.getOldStream()); <line7> if (result != null) { <line8> setWriteLane(result, event); <line9> allocator.tickDeviceWrite(result); <line10> } <line11> for (INDArray operand : operands) { <line12> if (operand == null) continue; <line13> setReadLane(operand, event); <line14> } <line15> Integer deviceId = allocator.getDeviceId(); <line16> fillTail(deviceId, event.getLaneId(), event); <line17> } <line18> } <line19> 	 <line3>	Yes
public class A { <line0> public double[] readTemperatureByUuid() { <line1> double[] temperatures = new double[2]; <line2> try { <line3> temperatures = <line4> calculateTemperature( <line5> this.bluetoothGatt.readCharacteristicValueByUuid( <line6> TiSensorTagGatt.UUID_TEMP_SENSOR_VALUE)); <line7> } catch (KuraException e) { <line8> } <line9> return temperatures; <line10> } <line11> } <line12> 	 <line9>	No
public class A { <line0> public void messageReceived(IoSession session, Readable message) throws Exception { <line1> if (isClosing()) { <line2> } else { <line3> Buffer buffer = new Buffer(); <line4> buffer.putBuffer(message); <line5> out.write(buffer.array(), buffer.rpos(), buffer.available()); <line6> out.flush(); <line7> } <line8> } <line9> } <line10> 	 <line6>	No
public class A { <line0> private ReferenceTime readReferenceTime(SpaceSystem spaceSystem) throws XMLStreamException { <line1> checkStartElementPreconditions(); <line2> ReferenceTime referenceTime = null; <line3> while (true) { <line4> xmlEvent = xmlEventReader.nextEvent(); <line5> if (isStartElementWithName(XTCE_OFFSET_FROM)) { <line6> referenceTime = new ReferenceTime(readParameterInstanceRef(spaceSystem, null)); <line7> } else if (isStartElementWithName(XTCE_EPOCH)) { <line8> referenceTime = new ReferenceTime(readEpoch()); <line9> } else if (isEndElementWithName(XTCE_REFERENCE_TIME)) { <line10> return referenceTime; <line11> } else { <line12> logUnknown(); <line13> } <line14> } <line15> } <line16> } <line17> 	 <line16>	No
public class A { <line0> public static MFMIMT700711UV01QueryAck createQueryAck(PRPAIN201305UV02 query) { <line1> MFMIMT700711UV01QueryAck result = new MFMIMT700711UV01QueryAck(); <line2> if (query.getControlActProcess() != null <line3> && query.getControlActProcess().getQueryByParameter() != null <line4> && query.getControlActProcess().getQueryByParameter().getValue() != null <line5> && query.getControlActProcess().getQueryByParameter().getValue().getQueryId() != null) { <line6> result.setQueryId(query.getControlActProcess().getQueryByParameter().getValue().getQueryId()); <line7> } else { <line8> } <line9> CS respCode = new CS(); <line10> respCode.setCode(HL7Constants.QUERY_ACK_OK); <line11> result.setQueryResponseCode(respCode); <line12> INT totalQuanity = new INT(); <line13> totalQuanity.setValue(BigInteger.valueOf(1)); <line14> result.setResultTotalQuantity(totalQuanity); <line15> INT currQuanity = new INT(); <line16> currQuanity.setValue(BigInteger.valueOf(1)); <line17> result.setResultCurrentQuantity(currQuanity); <line18> INT remainQuanity = new INT(); <line19> remainQuanity.setValue(BigInteger.valueOf(0)); <line20> result.setResultRemainingQuantity(remainQuanity); <line21> return result; <line22> } <line23> } <line24> 	 <line9>	No
"public class A { <line0> @RequestMapping( <line1> value = ""/users/{login}/public"", <line2> method = RequestMethod.GET, <line3> produces = MediaType.APPLICATION_JSON_VALUE) <line4> @Secured({ <line5> AuthoritiesConstants.ADMIN, <line6> AuthoritiesConstants.DATA_PROVIDER, <line7> AuthoritiesConstants.PUBLISHER <line8> }) <line9> public ResponseEntity<UserDto> getUserPublic(@PathVariable String login) { <line10> return userService <line11> .getUserWithAuthoritiesByLogin(login) <line12> .map(user -> new UserDto(user)) <line13> .map( <line14> userDTO -> <line15> ResponseEntity.ok() <line16> .cacheControl(CacheControl.noCache().mustRevalidate()) <line17> .body(userDTO)) <line18> .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND)); <line19> } <line20> } <line21> "	 <line10>	Yes
"public class A { <line0> private void doLoadProperties(InputStream resourceAsStream) throws IOException, FalconException { <line1> Properties origProps = new Properties(); <line2> origProps.load(resourceAsStream); <line3> if (domain == null) { <line4> domain = origProps.getProperty(""*.domain""); <line5> if (domain == null) { <line6> throw new FalconException(""Domain is not set!""); <line7> } else { <line8> domain = ExpressionHelper.substitute(domain); <line9> } <line10> } <line11> Set<String> keys = getKeys(origProps.keySet()); <line12> for (String key : keys) { <line13> String value = origProps.getProperty(domain + ""."" + key, origProps.getProperty(""*."" + key)); <line14> if (value != null) { <line15> value = ExpressionHelper.substitute(value); <line16> put(key, value); <line17> } <line18> } <line19> } <line20> } <line21> "	 <line16>	Yes
public class A { <line0> @Override <line1> public void handleRequest(Transaction transaction, Request<JsonObject> request) throws Exception { <line2> transaction.sendResponse(request.getParams()); <line3> } <line4> } <line5> 	 <line1>	No
public class A { <line0> public void testExecute() { <line1> try { <line2> ActionResponse response = action.execute(protocolSessionManager); <line3> } catch (ActionException e) { <line4> e.printStackTrace(); <line5> Assert.fail(); <line6> } <line7> org.opennaas.extensions.router.model.System routerModel = <line8> (org.opennaas.extensions.router.model.System) action.getModelToUpdate(); <line9> Assert.assertNotNull(routerModel); <line10> List<LogicalDevice> ld = routerModel.getLogicalDevices(); <line11> for (LogicalDevice device : ld) { <line12> EthernetPort ep = (EthernetPort) device; <line13> } <line14> } <line15> } <line16> 	 <line6>	No
public class A { <line0> @Override <line1> public void startPlugins() { <line2> for (PluginWrapper pluginWrapper : resolvedPlugins) { <line3> PluginState pluginState = pluginWrapper.getPluginState(); <line4> if ((PluginState.DISABLED != pluginState) && (PluginState.STARTED != pluginState)) { <line5> try { <line6> pluginWrapper.getPlugin().start(); <line7> pluginWrapper.setPluginState(PluginState.STARTED); <line8> pluginWrapper.setFailedException(null); <line9> startedPlugins.add(pluginWrapper); <line10> } catch (Exception | LinkageError e) { <line11> pluginWrapper.setPluginState(PluginState.FAILED); <line12> pluginWrapper.setFailedException(e); <line13> } finally { <line14> firePluginStateEvent(new PluginStateEvent(this, pluginWrapper, pluginState)); <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	 <line6>	Yes
public class A { <line0> @Override <line1> public int run(final Configuration config, final PropertyManagement runTimeProperties) <line2> throws Exception { <line3> for (int i = 0; i < runners.length; i++) { <line4> final MapReduceJobRunner runner = runners[i]; <line5> final int status = runner.run(config, runTimeProperties); <line6> if (status != 0) { <line7> return status; <line8> } <line9> runSetUpTasks[i].runTask(config, runner); <line10> } <line11> return 0; <line12> } <line13> } <line14> 	 <line13>	No
"public class A { <line0> private <T> ServiceResponse<T> executePost(ServiceRequest request) { <line1> ServiceResponse<T> response = new ServiceResponse<>(); <line2> String urlPath = request.getUrlPath(); <line3> if (urlPath == null || urlPath.equals(""/"")) { <line4> return errorResponse(response, 400, POST_ONLY_ALLOWED_TO_COLLECTIONS); <line5> } <line6> PersistenceManager pm = getPm(); <line7> try { <line8> return handlePost(pm, urlPath, response, request); <line9> } catch (IOException | RuntimeException e) { <line10> if (pm != null) { <line11> pm.rollbackAndClose(); <line12> } <line13> return errorResponse(response, 500, ""Failed to store data.""); <line14> } finally { <line15> maybeRollbackAndClose(); <line16> } <line17> } <line18> } <line19> "	 <line10>	Yes
public class A { <line0> @Override <line1> public boolean onHeaders(int request) { <line2> HttpChannelOverFCGI channel = channels.get(request); <line3> if (channel != null) { <line4> channel.onRequest(); <line5> channel.dispatch(); <line6> } <line7> return false; <line8> } <line9> } <line10> 	 <line3>	Yes
public class A { <line0> public void update(String componentName, Class interfaceName) { <line1> synchronized (componentMap) { <line2> Map<String, Long> componentServicesMap = componentMap.get(componentName); <line3> if (componentServicesMap == null) { <line4> componentServicesMap = new HashMap<>(); <line5> componentMap.put(componentName, componentServicesMap); <line6> } <line7> Long serviceCount = componentServicesMap.get(interfaceName.getName()); <line8> if (serviceCount == null) { <line9> serviceCount = 1L; <line10> } else { <line11> serviceCount++; <line12> } <line13> componentServicesMap.put(interfaceName.getName(), serviceCount); <line14> } <line15> } <line16> } <line17> 	 <line3>	No
public class A { <line0> @Override <line1> public void evaluate() throws Throwable { <line2> try { <line3> super.evaluate(); <line4> Runtime rt = Runtime.getRuntime(); <line5> long usedKB = (rt.totalMemory() - rt.freeMemory()) / 1024; <line6> ThreadGroup tg = Thread.currentThread().getThreadGroup(); <line7> while (tg.getParent() != null) { <line8> tg = tg.getParent(); <line9> } <line10> } catch (Throwable t) { <line11> Test annotation = this.method.getAnnotation(Test.class); <line12> if (annotation != null <line13> && annotation.expected() != null <line14> && annotation.expected().isAssignableFrom(t.getClass())) { <line15> } else { <line16> } <line17> throw t; <line18> } <line19> } <line20> } <line21> 	 <line9>	No
public class A { <line0> @Override <line1> public void completed(ProgressEvent event) { <line2> isLoading = false; <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> if (html != null) { <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> setText(html); <line9> html = null; <line10> } <line11> } <line12> } <line13> 	 <line0>	No
"public class A { <line0> @POST(path = ""/backend/config/gauges/add"", permission = ""agent:config:edit:gauge"") <line1> String addGauge(@BindAgentId String agentId, @BindRequest GaugeConfigDto gaugeConfigDto) <line2> throws Exception { <line3> GaugeConfig gaugeConfig = gaugeConfigDto.convert(); <line4> try { <line5> configRepository.insertGaugeConfig(agentId, gaugeConfig); <line6> } catch (DuplicateMBeanObjectNameException e) { <line7> throw new JsonServiceException(CONFLICT, ""mbeanObjectName""); <line8> } <line9> return getGaugeResponse(agentId, gaugeConfig); <line10> } <line11> } <line12> "	 <line1>	No
"public class A { <line0> @Override <line1> public void operationComplete(ChannelFuture future) throws Exception { <line2> handleReconnectDisconnection(1001, ""Channel closed""); <line3> } <line4> } <line5> "	 <line4>	No
"public class A { <line0> private void capabilitiesAndRespond( <line1> CentralRequest request, StreamObserver<AgentResponse> responseObserver) { <line2> Capabilities capabilities; <line3> try { <line4> capabilities = liveJvmService.getCapabilities(""""); <line5> } catch (Exception e) { <line6> sendExceptionResponse(request, responseObserver); <line7> return; <line8> } <line9> responseObserver.onNext( <line10> AgentResponse.newBuilder() <line11> .setRequestId(request.getRequestId()) <line12> .setCapabilitiesResponse( <line13> CapabilitiesResponse.newBuilder().setCapabilities(capabilities)) <line14> .build()); <line15> } <line16> } <line17> "	 <line6>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> while (running.get()) { <line4> getMessagesAdded(queue); <line5> getMessageCount(queue); <line6> Thread.sleep(10); <line7> } <line8> } catch (InterruptedException e) { <line9> } <line10> } <line11> } <line12> 	 <line0>	No
"public class A { <line0> @Override <line1> public void createWiki(String wikiName, XWikiContext context) throws XWikiException { <line2> boolean bTransaction = true; <line3> String database = context.getWikiId(); <line4> Statement stmt = null; <line5> try { <line6> bTransaction = beginTransaction(context); <line7> Session session = getSession(context); <line8> Connection connection = session.connection(); <line9> stmt = connection.createStatement(); <line10> String schema = getSchemaFromWikiName(wikiName, context); <line11> String escapedSchema = escapeSchema(schema, context); <line12> DatabaseProduct databaseProduct = getDatabaseProductName(); <line13> if (DatabaseProduct.ORACLE == databaseProduct) { <line14> stmt.execute(""create user "" + escapedSchema + "" identified by "" + escapedSchema); <line15> stmt.execute(""grant resource to "" + escapedSchema); <line16> } else if (DatabaseProduct.DERBY == databaseProduct <line17> || DatabaseProduct.DB2 == databaseProduct <line18> || DatabaseProduct.H2 == databaseProduct) { <line19> stmt.execute(""CREATE SCHEMA "" + escapedSchema); <line20> } else if (DatabaseProduct.HSQLDB == databaseProduct) { <line21> stmt.execute(""CREATE SCHEMA "" + escapedSchema + "" AUTHORIZATION DBA""); <line22> } else if (DatabaseProduct.MYSQL == databaseProduct) { <line23> if (context.getWiki().getEncoding().equals(""UTF-8"")) { <line24> stmt.execute(""create database "" + escapedSchema + "" CHARACTER SET utf8 COLLATE utf8_bin""); <line25> } else { <line26> stmt.execute(""create database "" + escapedSchema); <line27> } <line28> } else if (DatabaseProduct.POSTGRESQL == databaseProduct) { <line29> if (isInSchemaMode()) { <line30> stmt.execute(""CREATE SCHEMA "" + escapedSchema); <line31> } else { <line32> } <line33> } else { <line34> stmt.execute(""create database "" + escapedSchema); <line35> } <line36> endTransaction(context, true); <line37> } catch (Exception e) { <line38> Object[] args = {wikiName}; <line39> throw new XWikiException( <line40> XWikiException.MODULE_XWIKI_STORE, <line41> XWikiException.ERROR_XWIKI_STORE_HIBERNATE_CREATE_DATABASE, <line42> ""Exception while create wiki database {0}"", <line43> e, <line44> args); <line45> } finally { <line46> context.setWikiId(database); <line47> try { <line48> if (stmt != null) { <line49> stmt.close(); <line50> } <line51> } catch (Exception e) { <line52> } <line53> try { <line54> if (bTransaction) { <line55> endTransaction(context, false); <line56> } <line57> } catch (Exception e) { <line58> } <line59> } <line60> } <line61> } <line62> "	 <line32>	Yes
"public class A { <line0> @Command <line1> @NotifyChange(""resources"") <line2> public void update(List<String[]> newResourcesData) { <line3> this.resources.clear(); <line4> for (String[] dr : newResourcesData) { <line5> if (dr[5] != null) { <line6> if (dr[5].startsWith(""0."")) { <line7> Float memsize = Float.parseFloat(dr[5]); <line8> dr[5] = String.valueOf(memsize * 1024) + "" MB""; <line9> } else if (!dr[5].isEmpty()) { <line10> dr[5] = dr[5] + "" GB""; <line11> } else { <line12> dr[5] = ""-""; <line13> } <line14> } else { <line15> dr[5] = ""-""; <line16> } <line17> if (dr[6] != null) { <line18> if (dr[6].startsWith(""0."")) { <line19> Float disksize = Float.parseFloat(dr[6]); <line20> dr[6] = String.valueOf(disksize * 1024) + "" MB""; <line21> } else if (!dr[6].isEmpty()) { <line22> dr[6] = dr[6] + "" GB""; <line23> } else { <line24> dr[6] = ""-""; <line25> } <line26> } else { <line27> dr[6] = ""-""; <line28> } <line29> Resource r = new Resource(dr); <line30> this.resources.add(r); <line31> } <line32> } <line33> } <line34> "	 <line3>	Yes
public class A { <line0> @Override <line1> public void afterInvocation(IInvokedMethod iInvokedMethod, ITestResult iTestResult) { <line2> } <line3> } <line4> 	 <line3>	No
public class A { <line0> private Optional<InputStream> locateInDirectories(String resourceName) { <line1> List<String> searchDirs = new ArrayList<>(); <line2> if (!StringUtils.isBlank(configDir)) { <line3> searchDirs.add(configDir); <line4> } else { <line5> searchDirs.add( <line6> dirProvider.getInstallationConfigLocation() <line7> + File.separator <line8> + dirProvider.getConfigName()); <line9> searchDirs.add( <line10> dirProvider.getSysConfigLocation() + File.separator + dirProvider.getConfigName()); <line11> searchDirs.add( <line12> dirProvider.getUserConfigLocation() + File.separator + dirProvider.getConfigName()); <line13> } <line14> if (log.isTraceEnabled()) { <line15> } <line16> FileInputStream is = null; <line17> for (String dir : searchDirs) { <line18> String p = dir + File.separator + resourceName; <line19> try { <line20> is = new FileInputStream(p); <line21> break; <line22> } catch (FileNotFoundException ignored) { <line23> } <line24> } <line25> return Optional.ofNullable(is); <line26> } <line27> } <line28> 	 <line15>	Yes
public class A { <line0> private boolean hasNextSafely(Iterator iterator) { <line1> try { <line2> return iterator.hasNext(); <line3> } catch (Exception e) { <line4> return false; <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> @Override <line1> public Map<String, List<String>> getMetadataMapping() { <line2> Map<String, List<String>> cachedMapping = this.getCacheWrapper().getMetadataMapping(); <line3> if (null != cachedMapping) { <line4> return cachedMapping; <line5> } <line6> Map<String, List<String>> mapping = new HashMap<>(); <line7> try { <line8> String xmlConfig = <line9> this.getConfigManager() <line10> .getConfigItem(JacmsSystemConstants.CONFIG_ITEM_RESOURCE_METADATA_MAPPING); <line11> InputStream stream = new ByteArrayInputStream(xmlConfig.getBytes(StandardCharsets.UTF_8)); <line12> JAXBContext context = JAXBContext.newInstance(JaxbMetadataMapping.class); <line13> Unmarshaller unmarshaller = context.createUnmarshaller(); <line14> JaxbMetadataMapping jaxbMapping = (JaxbMetadataMapping) unmarshaller.unmarshal(stream); <line15> jaxbMapping.getFields().stream() <line16> .forEach( <line17> m -> { <line18> String key = m.getKey(); <line19> String csv = m.getValue(); <line20> List<String> metadatas = <line21> (!StringUtils.isBlank(csv)) ? Arrays.asList(csv.split("","")) : new ArrayList<>(); <line22> mapping.put(key, metadatas); <line23> }); <line24> this.getCacheWrapper().updateMetadataMapping(mapping); <line25> } catch (Exception e) { <line26> throw new RuntimeException(""Error Extracting resource metadata mapping"", e); <line27> } <line28> return mapping; <line29> } <line30> } <line31> "	 <line10>	No
public class A { <line0> public StatementAgentInstanceFactoryResult newContext( <line1> AgentInstanceContext agentInstanceContext, boolean isRecoveringResilient) { <line2> TableInstance tableState = <line3> agentInstanceContext <line4> .getTableManagementService() <line5> .allocateTableInstance(table, agentInstanceContext); <line6> TableInstanceViewable finalView = new TableInstanceViewable(table, tableState); <line7> AgentInstanceMgmtCallback stop = <line8> new AgentInstanceMgmtCallback() { <line9> public void stop(AgentInstanceStopServices services) { <line10> TableInstance instance = <line11> table.getTableInstance(agentInstanceContext.getAgentInstanceId()); <line12> if (instance == null) { <line13> } else { <line14> instance.destroy(); <line15> } <line16> } <line17> }; <line18> return new StatementAgentInstanceFactoryCreateTableResult( <line19> finalView, stop, agentInstanceContext, tableState); <line20> } <line21> } <line22> 	 <line13>	Yes
"public class A { <line0> @ApiOperation( <line1> httpMethod = ""PUT"", <line2> value = ""API to update a particular config property value"", <line3> response = Response.class, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> @RequestMapping( <line6> path = """", <line7> method = RequestMethod.PUT, <line8> produces = MediaType.APPLICATION_JSON_VALUE) <line9> public ResponseEntity<Object> updateConfigProperties( <line10> @AuthenticationPrincipal Principal user, <line11> @RequestBody(required = true) ConfigPropertyRequest configPropertyRequest, <line12> @ApiParam(value = ""provide a message for this update"", required = false) <line13> @RequestParam(defaultValue = """", name = ""userMessage"", required = false) <line14> String userMessage) { <line15> try { <line16> if (!configPropertyRequest.isRequestComplete()) { <line17> return ResponseUtils.buildFailureResponse( <line18> new Exception(AdminConstants.ERROR_CONFIG_MANDATORY)); <line19> } <line20> if (!configPropertyService.isAllPropertiesExisting(configPropertyRequest)) { <line21> return ResponseUtils.buildFailureResponse( <line22> new Exception( <line23> ""One or more of the provided Config Properties does not exist in current"" <line24> + "" environment for the combination of config key and application. Use POST"" <line25> + "" method to 'add' new values."")); <line26> } <line27> return ResponseUtils.buildSucessResponse( <line28> configPropertyService.addUpdateProperties( <line29> configPropertyRequest, <line30> user.getName(), <line31> userMessage, <line32> AdminUtils.getFormatedStringDate(DATE_FORMAT, new Date()), <line33> false)); <line34> } catch (Exception exception) { <line35> return ResponseUtils.buildFailureResponse(exception, null, null); <line36> } <line37> } <line38> } <line39> "	 <line35>	Yes
"public class A { <line0> private Credential getOAuth2Credential() throws OAuthException { <line1> Credential credential = null; <line2> AuthToken authMcc = getAuthTokenFromStorage(managerAccountId); <line3> if (authMcc == null || authMcc.getScope() == null || !authMcc.getScope().equals(scope)) { <line4> try { <line5> credential = getNewOAuth2Credential(); <line6> } catch (OAuthException e) { <line7> if (e.getMessage().contains(""Connection reset"")) { <line8> credential = getNewOAuth2Credential(); <line9> } else { <line10> throw e; <line11> } <line12> } finally { <line13> if (credential != null) { <line14> String name = """"; <line15> try { <line16> AdWordsSession adWordsSession = authenticate(credential).buildImmutable(); <line17> CustomerServiceInterface customerService = <line18> AdWordsServicesUtil.getService(adWordsSession, CustomerServiceInterface.class); <line19> List<Customer> customers = customerService.getCustomers(); <line20> if (customers != null && !customers.isEmpty()) { <line21> name = customers.get(0).getDescriptiveName(); <line22> } <line23> } catch (ValidationException | ApiException e) { <line24> } <line25> saveAuthTokenToStorage(managerAccountId, name, credential.getRefreshToken(), scope); <line26> } <line27> } <line28> } else { <line29> credential = buildOAuth2Credential(authMcc.getAuthToken()); <line30> } <line31> return credential; <line32> } <line33> } <line34> "	 <line24>	Yes
public class A { <line0> @Override <line1> public void changeConfiguration(WorkloadConfiguration configuration) { <line2> for (Iterator<WorkloadService> it = threads.iterator(); it.hasNext(); ) { <line3> WorkloadService workloadService = it.next(); <line4> if (workloadService.state().equals(Service.State.TERMINATED)) { <line5> it.remove(); <line6> samplesCountStartedFromTerminatedThreads += workloadService.getStartedSamples(); <line7> samplesCountFinishedFromTerminatedThreads += workloadService.getFinishedSamples(); <line8> emptyTransactionsFromTerminatedThreads += workloadService.getEmptyTransactions(); <line9> } <line10> } <line11> final int threadDiff = configuration.getThreads() - threads.size(); <line12> if (threadDiff < 0) { <line13> removeThreads(Math.abs(threadDiff)); <line14> } <line15> if (totalSamplesCountRequested != configuration.getSamples()) { <line16> leftSamplesCount.addAndGet(configuration.getSamples() - totalSamplesCountRequested); <line17> totalSamplesCountRequested = configuration.getSamples(); <line18> } <line19> int delay = configuration.getDelay(); <line20> if (threadDiff > 0 && (!predefinedSamplesCount() || leftSamplesCount.get() > 0)) { <line21> for (int i = threadDiff; i > 0; i--) { <line22> startNewThread(delay); <line23> } <line24> } <line25> for (WorkloadService thread : threads) { <line26> thread.changeDelay(delay); <line27> } <line28> } <line29> } <line30> 	 <line13>	Yes
public class A { <line0> private <O extends ObjectType, C extends Containerable> void addContainerWrappers( <line1> List<ContainerWrapper<? extends Containerable>> containerWrappers, <line2> ObjectWrapper<O> oWrapper, <line3> PrismContainer<C> parentContainer, <line4> ItemPath path, <line5> OperationResult result) <line6> throws SchemaException { <line7> PrismContainerDefinition<C> parentContainerDefinition = parentContainer.getDefinition(); <line8> List<ItemPathSegment> segments = new ArrayList<>(); <line9> if (path != null) { <line10> segments.addAll(path.getSegments()); <line11> } <line12> ItemPath parentPath = new ItemPath(segments); <line13> for (ItemDefinition def : <line14> (Collection<ItemDefinition>) parentContainerDefinition.getDefinitions()) { <line15> if (!(def instanceof PrismContainerDefinition)) { <line16> continue; <line17> } <line18> if (isIgnoreContainer(def.getTypeName())) { <line19> continue; <line20> } <line21> PrismContainerDefinition<?> containerDef = (PrismContainerDefinition) def; <line22> if (!oWrapper.isShowAssignments() <line23> && AssignmentType.COMPLEX_TYPE.equals(containerDef.getTypeName())) { <line24> continue; <line25> } <line26> if (!oWrapper.isShowInheritedObjectAttributes()) { <line27> boolean res = INHERITED_OBJECT_SUBCONTAINERS.contains(containerDef.getName()); <line28> if (res) { <line29> continue; <line30> } <line31> } <line32> ItemPath newPath = createPropertyPath(parentPath, containerDef.getName()); <line33> if (parentContainer.size() <= 1) { <line34> boolean isMultiValued = <line35> parentContainer.getDefinition() != null <line36> && !parentContainer.getDefinition().isDynamic() <line37> && !parentContainer.getDefinition().isSingleValue(); <line38> if (!isMultiValued) { <line39> ContainerWrapperFactory cwf = new ContainerWrapperFactory(modelServiceLocator); <line40> PrismContainer prismContainer = parentContainer.findContainer(def.getName()); <line41> ContainerWrapper container; <line42> if (prismContainer != null) { <line43> container = <line44> cwf.createContainerWrapper( <line45> oWrapper, prismContainer, ContainerStatus.MODIFYING, newPath); <line46> } else { <line47> prismContainer = containerDef.instantiate(); <line48> container = <line49> cwf.createContainerWrapper( <line50> oWrapper, prismContainer, ContainerStatus.ADDING, newPath); <line51> } <line52> result.addSubresult(cwf.getResult()); <line53> containerWrappers.add(container); <line54> if (!AssignmentType.COMPLEX_TYPE.equals(containerDef.getTypeName()) <line55> || !ShadowType.F_ASSOCIATION.equals(parentContainer.getElementName())) { <line56> addContainerWrappers(containerWrappers, oWrapper, prismContainer, newPath, result); <line57> } <line58> } <line59> } <line60> } <line61> } <line62> } <line63> 	 <line21>	Yes
public class A { <line0> private boolean downloadChangelogFile( <line1> NetworkConfiguration.ProxyConfiguration proxyConfiguration, <line2> Source source, <line3> Package pkg, <line4> PackageManagerTaskSummary taskSummary) <line5> throws PackageManagerException { <line6> try { <line7> final Path changelogFile = directoryStructure.changelogFileLocation(source, pkg); <line8> Files.createDirectories(changelogFile.getParent()); <line9> downloadManager.downloadTo(createPackageChangeLogURL(pkg), changelogFile.toFile()); <line10> return true; <line11> } catch (final Exception e) { <line12> if (null != taskSummary) { <line13> taskSummary.addWarning(e.toString()); <line14> } <line15> return false; <line16> } <line17> } <line18> } <line19> 	 <line15>	Yes
"public class A { <line0> public EntityManager load(UUID appId) { <line1> EntityManager entityManager = _getEntityManager(appId); <line2> Application app = null; <line3> Throwable throwable = null; <line4> try { <line5> app = entityManager.getApplication(); <line6> } catch (Throwable t) { <line7> throwable = t; <line8> } <line9> if (CpNamingUtils.MANAGEMENT_APPLICATION_ID.equals(appId)) { <line10> if (app != null) { <line11> managementAppEntityManager = entityManager; <line12> } else if (managementAppEntityManager != null) { <line13> entityManager = managementAppEntityManager; <line14> } <line15> } <line16> final boolean isBootstrapping; <line17> if (throwable instanceof CollectionRuntimeException) { <line18> CollectionRuntimeException cre = (CollectionRuntimeException) throwable; <line19> isBootstrapping = cre.isBootstrapping(); <line20> } else { <line21> isBootstrapping = false; <line22> } <line23> if (app != null && app.getName() == null) { <line24> throw new RuntimeException(""Name is null for application "" + appId, throwable); <line25> } <line26> if (app == null && !isBootstrapping) { <line27> throw new RuntimeException(""Error getting application "" + appId, throwable); <line28> } <line29> return entityManager; <line30> } <line31> } <line32> "	 <line3>	No
public class A { <line0> public final String getJson(CnATreeElement element, String scopeTitle) { <line1> try { <line2> String json = null; <line3> if (isIndexableElement(element)) { <line4> json = doGetJson(element, scopeTitle); <line5> } <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> return json; <line9> } catch (RuntimeException e) { <line10> throw e; <line11> } catch (Exception e) { <line12> throw new RuntimeException(e); <line13> } <line14> } <line15> } <line16> 	 <line7>	Yes
"public class A { <line0> @Override <line1> protected void doGet(HttpServletRequest request, HttpServletResponse response) <line2> throws ServletException, IOException { <line3> try { <line4> GwtXSRFToken token = new GwtXSRFToken(request.getParameter(""xsrfToken"")); <line5> KuraRemoteServiceServlet.checkXSRFToken(request, token); <line6> } catch (Exception e) { <line7> throw new ServletException(""Security error: please retry this operation correctly."", e); <line8> } <line9> try { <line10> final List<ComponentConfiguration> result = new ArrayList<>(); <line11> ServiceLocator.applyToServiceOptionally( <line12> CryptoService.class, <line13> cryptoService -> { <line14> ServiceLocator.applyToServiceOptionally( <line15> WireGraphService.class, <line16> wireGraphService -> { <line17> wireGraphService.get().getWireComponentConfigurations().stream() <line18> .map(WireComponentConfiguration::getConfiguration) <line19> .map(config -> removeDefinition(processPasswords(config, cryptoService))) <line20> .forEach(result::add); <line21> return null; <line22> }); <line23> final Set<String> driverPids = findReferencedDrivers(result); <line24> ServiceLocator.applyToServiceOptionally( <line25> ConfigurationService.class, <line26> configurationService -> { <line27> configurationService.getComponentConfigurations().stream() <line28> .filter(config -> driverPids.contains(config.getPid())) <line29> .map(config -> removeDefinition(processPasswords(config, cryptoService))) <line30> .forEach(result::add); <line31> result.add( <line32> removeDefinition( <line33> configurationService.getComponentConfiguration(WIRE_GRAPH_SERVICE_PID))); <line34> return null; <line35> }); <line36> return null; <line37> }); <line38> final XmlComponentConfigurations xmlConfigs = new XmlComponentConfigurations(); <line39> xmlConfigs.setConfigurations(result); <line40> final String marshalled = toSnapshot(xmlConfigs); <line41> final String snapshotName = ""graph_snapshot_"" + System.currentTimeMillis() + "".xml""; <line42> response.setCharacterEncoding(""UTF-8""); <line43> response.setContentType(""application/xml""); <line44> response.setHeader(""Content-Disposition"", ""attachment; filename="" + snapshotName); <line45> response.setHeader(""Cache-Control"", ""no-transform, max-age=0""); <line46> try (PrintWriter writer = response.getWriter()) { <line47> writer.write(marshalled); <line48> } <line49> } catch (Exception e) { <line50> throw new ServletException(""Failed to download snapshot""); <line51> } <line52> } <line53> } <line54> "	 <line50>	Yes
public class A { <line0> private boolean _isSkipEvent(Calendar calendar) { <line1> CalendarResource guestCalendarResource = null; <line2> try { <line3> guestCalendarResource = <line4> CalendarResourceUtil.fetchGuestCalendarResource(calendar.getCompanyId()); <line5> } catch (PortalException portalException) { <line6> if (_log.isDebugEnabled()) { <line7> } <line8> } <line9> if ((guestCalendarResource != null) <line10> && (guestCalendarResource.getCalendarResourceId() == calendar.getCalendarResourceId())) { <line11> return true; <line12> } <line13> return false; <line14> } <line15> } <line16> 	 <line7>	Yes
public class A { <line0> public boolean recallThreadLocalOutRequestIsEntryCall() { <line1> final Boolean curIsEntryCall = this.threadLocalOutRequestIsEntryCall.get(); <line2> if (curIsEntryCall == null) { <line3> return true; <line4> } <line5> return curIsEntryCall; <line6> } <line7> } <line8> 	 <line7>	No
public class A { <line0> public boolean detachShader(GL gl, int shaderId) { <line1> boolean result = false; <line2> if (isShaderIdValid(gl, shaderId)) { <line3> gl.glDetachShader(oglProgramId, shaderId); <line4> result = true; <line5> } else { <line6> } <line7> return result; <line8> } <line9> } <line10> 	 <line1>	No
public class A { <line0> public void attachClean(MbB2mDel instance) { <line1> try { <line2> sessionFactory.getCurrentSession().lock(instance, LockMode.NONE); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void create(User user, Device device, FolderSyncKey folderSyncKey, FolderSnapshot snapshot) <line2> throws DaoException { <line3> BatchStatement batch = new BatchStatement(Type.LOGGED); <line4> insertSnapshot(batch, user, device, folderSyncKey, snapshot); <line5> insertMapping(batch, user, device, snapshot.getFolders()); <line6> getSession().execute(batch); <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> @Override <line1> public MetadataConnection<HiveConnection> getConnection( <line2> String operator, Map<String, Object> params) throws Exception { <line3> Resource resource = <line4> new PathMatchingResourcePatternResolver().getResource(TMP_FILE_STORE_LOCATION.getValue()); <line5> String uris = <line6> String.valueOf(params.getOrDefault(HiveParamsMapper.PARAM_HIVE_URIS.getValue(), """")); <line7> String principle = <line8> String.valueOf(params.getOrDefault(HiveParamsMapper.PARAM_HIVE_PRINCIPLE.getValue(), """")); <line9> HiveConnection conn = null; <line10> if (StringUtils.isNotBlank(principle)) { <line11> String keytabResourceId = <line12> String.valueOf(params.getOrDefault(HiveParamsMapper.PARAM_HIVE_KEYTAB.getValue(), """")); <line13> if (StringUtils.isNotBlank(keytabResourceId)) { <line14> String keytabFilePath = <line15> resource.getFile().getAbsolutePath() <line16> + ""/"" <line17> + UUID.randomUUID().toString().replace(""-"", """"); <line18> if (!downloadResource(keytabResourceId, operator, keytabFilePath)) { <line19> throw new MetaRuntimeException(""Fail to download resource i:["" + keytabResourceId + ""]""); <line20> } <line21> conn = new HiveConnection(uris, principle, keytabFilePath); <line22> } else { <line23> throw new MetaRuntimeException(""Cannot find the keytab file in connect parameters""); <line24> } <line25> } else { <line26> conn = new HiveConnection(uris); <line27> } <line28> return new MetadataConnection<>(conn, true); <line29> } <line30> } <line31> "	 <line11>	Yes
"public class A { <line0> private Set<Artifact> readStartupProperties(AetherUtil aetherUtil) { <line1> Set<Artifact> artifacts = new LinkedHashSet<>(); <line2> File file = new File(new File(localRepo.getParentFile(), ""etc""), ""startup.properties""); <line3> Properties prop = new Properties(); <line4> try (InputStream is = new FileInputStream(file)) { <line5> prop.load(is); <line6> Enumeration<Object> mvnUrls = prop.keys(); <line7> while (mvnUrls.hasMoreElements()) { <line8> String mvnUrl = (String) mvnUrls.nextElement(); <line9> Artifact artifact = aetherUtil.resolveArtifact(FeatureUtil.toCoord(new URL(mvnUrl))); <line10> artifacts.add(artifact); <line11> } <line12> } catch (FileNotFoundException e) { <line13> } catch (IOException e) { <line14> } <line15> return artifacts; <line16> } <line17> } <line18> "	 <line14>	Yes
public class A { <line0> @Override <line1> public Optional<Action> execute(Action action, GraphicalModelState modelState) { <line2> if (action instanceof RequestTypeHintsAction) { <line3> Optional<String> diagramType = getDiagramType((RequestTypeHintsAction) action, modelState); <line4> if (!diagramType.isPresent()) { <line5> return Optional.empty(); <line6> } <line7> Optional<DiagramConfiguration> configuration = <line8> diagramConfigurationProvider.get(diagramType.get()); <line9> if (!configuration.isPresent()) { <line10> return Optional.empty(); <line11> } <line12> return Optional.of( <line13> new SetTypeHintsAction( <line14> configuration.get().getNodeTypeHints(), configuration.get().getEdgeTypeHints())); <line15> } <line16> return Optional.empty(); <line17> } <line18> } <line19> 	 <line5>	Yes
public class A { <line0> public ActionForward execute( <line1> Exception ex, <line2> ExceptionConfig ae, <line3> ActionMapping mapping, <line4> ActionForm formInstance, <line5> HttpServletRequest request, <line6> HttpServletResponse response) <line7> throws ServletException { <line8> ActionForward forward; <line9> ActionMessage error; <line10> String property; <line11> if (ae.getPath() != null) { <line12> forward = new ActionForward(ae.getPath()); <line13> } else { <line14> forward = mapping.getInputForward(); <line15> } <line16> if (ex instanceof ModuleException) { <line17> error = ((ModuleException) ex).getActionMessage(); <line18> property = ((ModuleException) ex).getProperty(); <line19> } else { <line20> error = new ActionMessage(ae.getKey(), ex.getMessage()); <line21> property = error.getKey(); <line22> } <line23> this.logException(ex); <line24> request.setAttribute(Globals.EXCEPTION_KEY, ex); <line25> this.storeException(request, property, error, forward, ae.getScope()); <line26> if (!response.isCommitted()) { <line27> return forward; <line28> } <line29> if (!silent(ae)) { <line30> handleCommittedResponse(ex, ae, mapping, formInstance, request, response, forward); <line31> } else { <line32> } <line33> return null; <line34> } <line35> } <line36> 	 <line6>	No
"public class A { <line0> public String search(String query) { <line1> Map<String, Object> request = new HashMap<>(); <line2> request.put(""query"", query); <line3> String response = ""Needs to be implemented...""; <line4> return response; <line5> } <line6> } <line7> "	 <line2>	No
public class A { <line0> @Override <line1> public void start() throws IgniteException { <line2> synchronized (segmentsLock) { <line3> if (started) return; <line4> started = true; <line5> directMemoryProvider.initialize(sizes); <line6> List<DirectMemoryRegion> regions = new ArrayList<>(sizes.length); <line7> while (true) { <line8> DirectMemoryRegion reg = directMemoryProvider.nextRegion(); <line9> if (reg == null) break; <line10> regions.add(reg); <line11> } <line12> int regs = regions.size(); <line13> Segment[] segments = new Segment[regs - 1]; <line14> DirectMemoryRegion cpReg = regions.get(regs - 1); <line15> checkpointPool = new PagePool(regs - 1, cpReg, sysPageSize, rwLock); <line16> long checkpointBuf = cpReg.size(); <line17> long totalAllocated = 0; <line18> int pages = 0; <line19> long totalTblSize = 0; <line20> for (int i = 0; i < regs - 1; i++) { <line21> assert i < segments.length; <line22> DirectMemoryRegion reg = regions.get(i); <line23> totalAllocated += reg.size(); <line24> segments[i] = <line25> new Segment(i, regions.get(i), checkpointPool.pages() / segments.length, throttlingPlc); <line26> pages += segments[i].pages(); <line27> totalTblSize += segments[i].tableSize(); <line28> } <line29> initWriteThrottle(); <line30> this.segments = segments; <line31> if (log.isInfoEnabled()) <line32> } <line33> } <line34> } <line35> 	 <line32>	Yes
public class A { <line0> public GroupStructuralData getGroupStructuralContents(String group) throws EngineException { <line1> Stopwatch watch = Stopwatch.createStarted(); <line2> GroupStructuralDataImpl ret = <line3> GroupStructuralDataImpl.builder() <line4> .withGroup(group) <line5> .withGroups(groupDAO.getAllAsMap()) <line6> .build(); <line7> return ret; <line8> } <line9> } <line10> 	 <line6>	No
"public class A { <line0> private HashMap<String, HostVmStateReportEntry> getHostVmStateReport(final Connect conn) { <line1> final HashMap<String, HostVmStateReportEntry> vmStates = <line2> new HashMap<String, HostVmStateReportEntry>(); <line3> String[] vms = null; <line4> int[] ids = null; <line5> try { <line6> ids = conn.listDomains(); <line7> } catch (final LibvirtException e) { <line8> s_logger.warn(""Unable to listDomains"", e); <line9> return null; <line10> } <line11> try { <line12> vms = conn.listDefinedDomains(); <line13> } catch (final LibvirtException e) { <line14> return null; <line15> } <line16> Domain dm = null; <line17> for (int i = 0; i < ids.length; i++) { <line18> try { <line19> dm = conn.domainLookupByID(ids[i]); <line20> final DomainState ps = dm.getInfo().state; <line21> final PowerState state = convertToPowerState(ps); <line22> final String vmName = dm.getName(); <line23> if (state == PowerState.PowerOn) { <line24> vmStates.put(vmName, new HostVmStateReportEntry(state, conn.getHostName())); <line25> } <line26> } catch (final LibvirtException e) { <line27> s_logger.warn(""Unable to get vms"", e); <line28> } finally { <line29> try { <line30> if (dm != null) { <line31> dm.free(); <line32> } <line33> } catch (final LibvirtException e) { <line34> s_logger.trace(""Ignoring libvirt error."", e); <line35> } <line36> } <line37> } <line38> for (int i = 0; i < vms.length; i++) { <line39> try { <line40> dm = conn.domainLookupByName(vms[i]); <line41> final DomainState ps = dm.getInfo().state; <line42> final PowerState state = convertToPowerState(ps); <line43> final String vmName = dm.getName(); <line44> if (state == PowerState.PowerOn) { <line45> vmStates.put(vmName, new HostVmStateReportEntry(state, conn.getHostName())); <line46> } <line47> } catch (final LibvirtException e) { <line48> } finally { <line49> try { <line50> if (dm != null) { <line51> dm.free(); <line52> } <line53> } catch (final LibvirtException e) { <line54> } <line55> } <line56> } <line57> return vmStates; <line58> } <line59> } <line60> "	 <line48>	Yes
"public class A { <line0> @Override <line1> public Runnable createRunnable(PipelinesInterpretedMessage message) { <line2> return () -> { <line3> try { <line4> long recordsNumber = getRecordNumber(message); <line5> String indexName = computeIndexName(message, recordsNumber); <line6> int numberOfShards = computeNumberOfShards(indexName, recordsNumber); <line7> ProcessRunnerBuilderBuilder builder = <line8> ProcessRunnerBuilder.builder() <line9> .config(config) <line10> .message(message) <line11> .esIndexName(indexName) <line12> .esAlias(config.indexConfig.occurrenceAlias) <line13> .esShardsNumber(numberOfShards); <line14> Predicate<StepRunner> runnerPr = sr -> config.processRunner.equalsIgnoreCase(sr.name()); <line15> if (runnerPr.test(StepRunner.DISTRIBUTED)) { <line16> runDistributed(message, builder, recordsNumber); <line17> } else if (runnerPr.test(StepRunner.STANDALONE)) { <line18> runLocal(builder); <line19> } <line20> } catch (Exception ex) { <line21> throw new IllegalStateException( <line22> ""Failed interpretation on "" + message.getDatasetUuid().toString(), ex); <line23> } <line24> }; <line25> } <line26> } <line27> "	 <line15>	Yes
public class A { <line0> @Override <line1> public int hashCode() { <line2> int result = 1; <line3> try { <line4> final int prime = 31; <line5> result = prime * result + ((cnaTreeElement == null) ? 0 : cnaTreeElement.hashCode()); <line6> result = prime * result + ((role == null) ? 0 : role.hashCode()); <line7> } catch (Exception t) { <line8> } <line9> return result; <line10> } <line11> } <line12> 	 <line10>	No
public class A { <line0> @Override <line1> public void postOpen(final ObserverContext<RegionCoprocessorEnvironment> c) { <line2> Multimap<HTableInterfaceReference, Mutation> updates = <line3> failedIndexEdits.getEdits(c.getEnvironment().getRegion()); <line4> if (this.disabled) { <line5> super.postOpen(c); <line6> return; <line7> } <line8> if (updates == null || updates.size() == 0) { <line9> return; <line10> } <line11> try { <line12> writer.writeAndKillYourselfOnFailure(updates); <line13> } catch (IOException e) { <line14> } <line15> } <line16> } <line17> 	 <line8>	Yes
"public class A { <line0> private void processIdentifiers(JsonNode identifiers) { <line1> identifiers.forEach( <line2> identifier -> { <line3> Integer ringgoldId = identifier.get(""ringgold_id"").asInt(); <line4> String identifierType = identifier.get(""identifier_type"").asText(); <line5> if (ALLOWED_EXTERNAL_IDENTIFIERS.contains(identifierType)) { <line6> identifiersMap <line7> .computeIfAbsent(ringgoldId, element -> new ArrayList<>()) <line8> .add(identifier); <line9> } else { <line10> } <line11> }); <line12> } <line13> } <line14> "	 <line1>	Yes
"public class A { <line0> @Schedule(hour = ""*"", minute = ""*"", second = ""*/30"", persistent = false) <line1> public void removeIdleOrExpired() { <line2> if (log.isDebugEnabled()) { <line3> } <line4> long now = System.currentTimeMillis(); <line5> clearQueries(now); <line6> qlCache.clearQueryLogics(now, conf.getCallTimeInMS()); <line7> } <line8> } <line9> "	 <line6>	No
"public class A { <line0> public static String restoreLocale(String username) { <line1> String currentLocale = null; <line2> if (StringUtils.isNotBlank(username)) { <line3> PreparedStatement statement = null; <line4> Connection connection = null; <line5> try { <line6> connection = DatabaseUpdater.getConnection(); <line7> Integer userId = getUserIdByName(username, connection); <line8> if (userId != null) { <line9> String select = <line10> ""select property_value from user_property where user_id = ? and property = ?""; <line11> statement = connection.prepareStatement(select); <line12> statement.setInt(1, userId); <line13> statement.setString(2, OpenmrsConstants.USER_PROPERTY_DEFAULT_LOCALE); <line14> if (statement.execute()) { <line15> ResultSet results = statement.getResultSet(); <line16> if (results.next()) { <line17> currentLocale = results.getString(1); <line18> } <line19> } <line20> statement.close(); <line21> } <line22> if (currentLocale == null) { <line23> currentLocale = readSystemDefaultLocale(connection); <line24> } <line25> } catch (Exception e) { <line26> } finally { <line27> try { <line28> if (statement != null && !statement.isClosed()) { <line29> statement.close(); <line30> } <line31> } catch (SQLException e) { <line32> } <line33> if (connection != null) { <line34> try { <line35> connection.close(); <line36> } catch (SQLException e) { <line37> } <line38> } <line39> } <line40> } <line41> if (currentLocale == null) { <line42> currentLocale = OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE_DEFAULT_VALUE; <line43> } <line44> return currentLocale; <line45> } <line46> } <line47> "	 <line37>	Yes
"public class A { <line0> private void loadResource( <line1> Map<String, Class<?>> extensionClasses, <line2> ClassLoader classLoader, <line3> java.net.URL resourceURL, <line4> boolean overridden, <line5> String... excludedPackages) { <line6> try { <line7> try (BufferedReader reader = <line8> new BufferedReader( <line9> new InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) { <line10> String line; <line11> String clazz = null; <line12> while ((line = reader.readLine()) != null) { <line13> final int ci = line.indexOf('#'); <line14> if (ci >= 0) { <line15> line = line.substring(0, ci); <line16> } <line17> line = line.trim(); <line18> if (line.length() > 0) { <line19> try { <line20> String name = null; <line21> int i = line.indexOf('='); <line22> if (i > 0) { <line23> name = line.substring(0, i).trim(); <line24> clazz = line.substring(i + 1).trim(); <line25> } else { <line26> clazz = line; <line27> } <line28> if (StringUtils.isNotEmpty(clazz) && !isExcluded(clazz, excludedPackages)) { <line29> loadClass( <line30> extensionClasses, <line31> resourceURL, <line32> Class.forName(clazz, true, classLoader), <line33> name, <line34> overridden); <line35> } <line36> } catch (Throwable t) { <line37> IllegalStateException e = <line38> new IllegalStateException( <line39> ""Failed to load extension class (interface: "" <line40> + type <line41> + "", class line: "" <line42> + line <line43> + "") in "" <line44> + resourceURL <line45> + "", cause: "" <line46> + t.getMessage(), <line47> t); <line48> exceptions.put(line, e); <line49> } <line50> } <line51> } <line52> } <line53> } catch (Throwable t) { <line54> } <line55> } <line56> } <line57> "	 <line54>	Yes
public class A { <line0> private boolean bgStartScanning(boolean active, int interval, int window) { <line1> try { <line2> BlueGigaSetScanParametersCommand scanCommand = <line3> new BlueGigaSetScanParametersCommand.CommandBuilder() <line4> .withActiveScanning(active) <line5> .withScanInterval(interval) <line6> .withScanWindow(window) <line7> .build(); <line8> if (sendCommand(scanCommand, BlueGigaSetScanParametersResponse.class, false).getResult() <line9> == BgApiResponse.SUCCESS) { <line10> BlueGigaDiscoverCommand discoverCommand = <line11> new BlueGigaDiscoverCommand.CommandBuilder() <line12> .withMode(GapDiscoverMode.GAP_DISCOVER_OBSERVATION) <line13> .build(); <line14> if (sendCommand(discoverCommand, BlueGigaDiscoverResponse.class, false).getResult() <line15> == BgApiResponse.SUCCESS) { <line16> return true; <line17> } <line18> } <line19> } catch (BlueGigaException e) { <line20> } <line21> return false; <line22> } <line23> } <line24> 	 <line16>	Yes
public class A { <line0> @Override <line1> public Response toResponse(ArlasException e) { <line2> for (StackTraceElement s : Arrays.copyOf(e.getStackTrace(), 10)) { <line3> } <line4> return e.getResponse(); <line5> } <line6> } <line7> 	 <line3>	Yes
"public class A { <line0> private static RestconfDocumentedException dataMissing(final String identifier) { <line1> return new RestconfDocumentedException( <line2> ""Request could not be completed because the relevant data model content "" <line3> + ""does not exist"", <line4> ErrorType.APPLICATION, <line5> ErrorTag.DATA_MISSING); <line6> } <line7> } <line8> "	 <line6>	No
public class A { <line0> void restoreLeaderElection(TopicPartitionGroup topicPartitionGroup, ElectionMetadata metadata) <line1> throws Exception { <line2> ReplicaGroup replicaGroup = <line3> replicationManager.createReplicaGroup( <line4> topicPartitionGroup.getTopic(), <line5> topicPartitionGroup.getPartitionGroupId(), <line6> new LinkedList<>(metadata.getAllNodes()), <line7> metadata.getLearners(), <line8> metadata.getLocalNodeId(), <line9> metadata.getLeaderId(), <line10> brokerMonitor); <line11> LeaderElection leaderElection = <line12> createLeaderElection( <line13> metadata.getElectType(), <line14> topicPartitionGroup.getTopic(), <line15> topicPartitionGroup.getPartitionGroupId(), <line16> new LinkedList<>(metadata.getAllNodes()), <line17> metadata.getLearners(), <line18> metadata.getLocalNodeId(), <line19> metadata.getLeaderId(), <line20> replicaGroup); <line21> replicaGroup.setLeaderElection(leaderElection); <line22> } <line23> } <line24> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void destroy() { <line2> try { <line3> doSendUnregister(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	 <line4>	No
public class A { <line0> @Modified <line1> protected void modified(final ComponentContext componentContext) { <line2> bindingConfig.updateFromProperties(componentContext.getProperties()); <line3> } <line4> } <line5> 	 <line0>	No
"public class A { <line0> @Override <line1> protected void execute() throws Exception { <line2> if (srcPath == null) { <line3> throw new IllegalArgumentException(""File parameter is missing.""); <line4> } <line5> if (attName == null) { <line6> throw new IllegalArgumentException(""attName parameter is missing.""); <line7> } <line8> if (attValue == null) { <line9> throw new IllegalArgumentException(""attValue parameter is missing.""); <line10> } <line11> if (!dfsClient.exists(srcPath)) { <line12> throw new ActionException(""SetXAttr Action fails, file doesn't exist!""); <line13> } <line14> appendLog(String.format(""SetXattr path=%s name=%s value=%s"", srcPath, attName, attValue)); <line15> dfsClient.setXAttr( <line16> srcPath, <line17> attName, <line18> attValue.getBytes(), <line19> EnumSet.of(XAttrSetFlag.CREATE, XAttrSetFlag.REPLACE)); <line20> appendLog(""SetXattr Successfully!!""); <line21> } <line22> } <line23> "	 <line4>	No
public class A { <line0> public static String[] trimAll(String[] v) { <line1> String[] t = new String[v.length]; <line2> for (int i = 0; i < v.length; i++) { <line3> t[i] = v[i].trim(); <line4> if (t[i].length() == 0) { <line5> } <line6> } <line7> return t; <line8> } <line9> } <line10> 	 <line2>	No
public class A { <line0> private void setValue(boolean bool) { <line1> try { <line2> pin.setValue(bool); <line3> TimeUnit.SECONDS.sleep(1); <line4> } catch (InterruptedException <line5> | KuraUnavailableDeviceException <line6> | IOException <line7> | KuraClosedDeviceException e) { <line8> } <line9> } <line10> } <line11> 	 <line9>	No
"public class A { <line0> public Document getServiceTemplateInstanceRawProperties(final Long id) throws NotFoundException { <line1> final ServiceTemplateInstance service = getServiceTemplateInstance(id, false); <line2> final Optional<ServiceTemplateInstanceProperty> firstProp = <line3> service.getProperties().stream().findFirst(); <line4> if (firstProp.isPresent()) { <line5> return convertPropertyToDocument(firstProp.get()); <line6> } <line7> final String msg = <line8> String.format(""No properties are found for the service template instance <%s>"", id); <line9> return null; <line10> } <line11> } <line12> "	 <line10>	No
"public class A { <line0> public void start(int receiverPort) throws DataBridgeException { <line1> DataPublisherTestUtil.setKeyStoreParams(); <line2> streamDefinitionStore = getStreamDefinitionStore(); <line3> numberOfEventsReceived = new AtomicInteger(0); <line4> databridge = <line5> new DataBridge( <line6> new AuthenticationHandler() { <line7> @Override <line8> public boolean authenticate(String userName, String password) { <line9> return true; <line10> } <line11>  <line12> @Override <line13> public String getTenantDomain(String userName) { <line14> return ""admin""; <line15> } <line16>  <line17> @Override <line18> public int getTenantId(String tenantDomain) throws UserStoreException { <line19> return -1234; <line20> } <line21>  <line22> @Override <line23> public void initContext(AgentSession agentSession) { <line24> } <line25>  <line26> @Override <line27> public void destroyContext(AgentSession agentSession) {} <line28> }, <line29> streamDefinitionStore, <line30> DataPublisherTestUtil.getDataBridgeConfigPath()); <line31> thriftDataReceiver = new ThriftDataReceiver(receiverPort, databridge); <line32> databridge.subscribe( <line33> new AgentCallback() { <line34> @Override <line35> public void definedStream(StreamDefinition streamDefinition, int tenantId) { <line36> } <line37>  <line38> @Override <line39> public void removeStream(StreamDefinition streamDefinition, int tenantId) { <line40> } <line41>  <line42> @Override <line43> public void receive(List<Event> eventList, Credentials credentials) { <line44> numberOfEventsReceived.addAndGet(eventList.size()); <line45> } <line46> }); <line47> String address = ""localhost""; <line48> thriftDataReceiver.start(address); <line49> } <line50> } <line51> "	 <line5>	No
public class A { <line0> @Override <line1> public void flush() { <line2> try { <line3> xDMA.storeMetadataToStorage(UNO.XStorageBasedDocument(doc).getDocumentStorage()); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	 <line7>	No
public class A { <line0> @Override <line1> public void stop() { <line2> delegate.stop(); <line3> super.stop(); <line4> } <line5> } <line6> 	 <line0>	No
public class A { <line0> public OutputStream createOutputStream(long offset) throws IOException { <line1> postClientAction(ClientActionEvent.ClientAction.UPLOAD); <line2> if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { <line3> Uri uri = DocumentsContract.buildDocumentUriUsingTree(startUrl, documentId); <line4> return new TracingBufferedOutputStream(contentResolver.openOutputStream(uri), logger); <line5> } <line6> return null; <line7> } <line8> } <line9> 	 <line1>	Yes
"public class A { <line0> @Override <line1> public List<HivePrivilegeInfo> showPrivileges( <line2> HivePrincipal principal, HivePrivilegeObject privObj) throws HiveAuthzPluginException { <line3> List<HivePrivilegeInfo> ret; <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> if (hivePlugin == null) { <line7> new HiveAuthzPluginException(""RangerHiveAuthorizer.showPrivileges error: hivePlugin is null""); <line8> } <line9> try { <line10> HiveObjectRef msObjRef = AuthorizationUtils.getThriftHiveObjectRef(privObj); <line11> if (msObjRef.getDbName() == null) { <line12> throw new HiveAuthzPluginException( <line13> ""RangerHiveAuthorizer.showPrivileges() only supports SHOW PRIVILEGES for Hive resources"" <line14> + "" and not user level""); <line15> } <line16> ret = getHivePrivilegeInfos(principal, privObj); <line17> } catch (Exception e) { <line18> throw new HiveAuthzPluginException( <line19> ""RangerHiveAuthorizer.showPrivileges() error: "" + e.getMessage(), e); <line20> } <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> return ret; <line24> } <line25> } <line26> "	 <line20>	No
"public class A { <line0> void queueMutations(final MutationSet mutationsToSend) { <line1> if (mutationsToSend == null) return; <line2> binningThreadPool.execute( <line3> Trace.wrap( <line4> () -> { <line5> if (mutationsToSend != null) { <line6> try { <line7> addMutations(mutationsToSend); <line8> } catch (Exception e) { <line9> updateUnknownErrors(""Error processing mutation set"", e); <line10> } <line11> } <line12> })); <line13> } <line14> } <line15> "	 <line0>	No
"public class A { <line0> @Override <line1> public void onError(AsyncEvent asyncEvent) throws IOException { <line2> int httpCode = CMBErrorCodes.InternalError.getHttpCode(); <line3> String code = CMBErrorCodes.InternalError.getCMBCode(); <line4> String message = ""There is an internal problem with CMB""; <line5> if (asyncEvent.getThrowable() instanceof CMBException) { <line6> httpCode = ((CMBException) asyncEvent.getThrowable()).getHttpCode(); <line7> code = ((CMBException) asyncEvent.getThrowable()).getCMBCode(); <line8> message = asyncEvent.getThrowable().getMessage(); <line9> } <line10> String errXml = CMBControllerServlet.createErrorResponse(code, message); <line11> HttpServletResponse response = ((HttpServletResponse) asyncEvent.getSuppliedResponse()); <line12> response.setStatus(httpCode); <line13> Action.writeResponse(errXml, response); <line14> if (!(asyncEvent.getSuppliedRequest() instanceof CQSHttpServletRequest)) { <line15> return; <line16> } <line17> CQSQueue queue = ((CQSHttpServletRequest) asyncEvent.getSuppliedRequest()).getQueue(); <line18> AsyncContext asyncContext = asyncEvent.getAsyncContext(); <line19> if (queue != null) { <line20> ConcurrentLinkedQueue<AsyncContext> queueContextsList = <line21> CQSLongPollReceiver.contextQueues.get(queue.getArn()); <line22> if (queueContextsList != null && asyncContext != null) { <line23> queueContextsList.remove(asyncContext); <line24> } <line25> } else { <line26> } <line27> asyncContext.complete(); <line28> } <line29> } <line30> "	 <line20>	Yes
public class A { <line0> @Override <line1> public void reportFinished(JasperPrint jasperPrint) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> lock(); <line5> try { <line6> if (this.jasperPrint == null) { <line7> this.jasperPrint = jasperPrint; <line8> } <line9> pageCount = jasperPrint.getPages().size(); <line10> done = true; <line11> fillHandle = null; <line12> trackedPages.clear(); <line13> pageCondition.signalAll(); <line14> } finally { <line15> unlock(); <line16> } <line17> } <line18> } <line19> 	 <line3>	Yes
"public class A { <line0> @GET <line1> @Path(""/tags"") <line2> @Produces(APPLICATION_JSON) <line3> @ApiOperation(value = ""Returns a Map of Applications to their tags"", response = Map.class) <line4> @Timed <line5> public Response getAllExperimentTags( <line6> @HeaderParam(AUTHORIZATION) @ApiParam(value = EXAMPLE_AUTHORIZATION_HEADER, required = true) <line7> final String authorizationHeader) { <line8> try { <line9> UserInfo.Username userName = authorization.getUser(authorizationHeader); <line10> Set<Application.Name> allowed = new HashSet<>(); <line11> List<UserPermissions> authorized = <line12> authorization.getUserPermissionsList(userName).getPermissionsList(); <line13> for (UserPermissions perm : authorized) { <line14> allowed.add(perm.getApplicationName()); <line15> } <line16> Map<Application.Name, Set<String>> allTags = experiments.getTagsForApplications(allowed); <line17> return httpHeader.headers().entity(allTags).build(); <line18> } catch (Exception exception) { <line19> throw exception; <line20> } <line21> } <line22> } <line23> "	 <line19>	Yes
public class A { <line0> @Override <line1> public void after(Object target, Object[] args, Object result, Throwable throwable) { <line2> if (target instanceof WebappLoader) { <line3> WebappLoader webappLoader = (WebappLoader) target; <line4> try { <line5> String contextKey = extractContextKey(webappLoader); <line6> List<String> loadedJarNames = extractLibJars(webappLoader); <line7> dispatchLibJars(contextKey, loadedJarNames); <line8> } catch (Exception e) { <line9> if (logger.isWarnEnabled()) { <line10> } <line11> } <line12> } else { <line13> } <line14> } <line15> } <line16> 	 <line13>	Yes
"public class A { <line0> private <T> T innerCallRest(String uri, Class<T> json) <line1> throws ExecutionException, InterruptedException, TimeoutException, JsonSyntaxException { <line2> Request request = httpClient.newRequest(uri).method(HttpMethod.GET); <line3> request.header(""Authorization"", authorizationHeader); <line4> ContentResponse response = request.send(); <line5> String content = response.getContentAsString(); <line6> return gson.fromJson(content, json); <line7> } <line8> } <line9> "	 <line2>	Yes
"public class A { <line0> @GET <line1> @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line2> @Path(""/{id}/acl"") <line3> @CheckPermission( <line4> roles = {Role.SYSTEM_MONITOR, Role.TENANT_ADMIN}, <line5> acls = {ACL.ANY}) <line6> public BucketACL getBucketACL(@PathParam(""id"") URI id) throws InternalException { <line7> Bucket bucket = null; <line8> ArgValidator.checkFieldUriType(id, Bucket.class, ""id""); <line9> bucket = _dbClient.queryObject(Bucket.class, id); <line10> ArgValidator.checkEntity(bucket, id, isIdEmbeddedInURL(id)); <line11> if (bucket.getVersion() == null) { <line12> syncBucketACL(bucket); <line13> } <line14> BucketACL bucketAcl = new BucketACL(); <line15> BucketACLUtility bucketACLUtil = <line16> new BucketACLUtility(_dbClient, bucket.getName(), bucket.getId()); <line17> List<BucketACE> bucketAces = bucketACLUtil.queryExistingBucketACL(); <line18> if (!bucketAces.isEmpty()) { <line19> bucketAcl.setBucketACL(bucketAces); <line20> } <line21> return bucketAcl; <line22> } <line23> } <line24> "	 <line7>	Yes
"public class A { <line0> @Override <line1> public List<Account> listAccounts(ListAccountOptions options) throws IOException { <line2> String url = buildCanvasUrl(""accounts"", options.getOptionsMap()); <line3> return getListFromCanvas(url); <line4> } <line5> } <line6> "	 <line1>	No
public class A { <line0> private Date retrieveLastModifiedDateByIdP(String idp) { <line1> Date date = null; <line2> try { <line3> date = clientDetailsManager.getLastModifiedByIdp(idp); <line4> } catch (javax.persistence.NoResultException e) { <line5> } <line6> return date; <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> final Manufacturer manufacturer = <line4> this.findManufacturer(this.deviceConnectionScheduledTaskManufacturerName); <line5> if (manufacturer == null) { <line6> return; <line7> } <line8> final List<DeviceModel> deviceModels = this.findDeviceModels(manufacturer); <line9> if (deviceModels == null || deviceModels.isEmpty()) { <line10> return; <line11> } <line12> final List<Device> devices = this.findDevices(deviceModels, LightMeasurementDevice.LMD_TYPE); <line13> if (devices.isEmpty()) { <line14> return; <line15> } <line16> final List<Device> devicesToContact = <line17> this.findDevicesToContact(devices, this.deviceConnectionScheduledTaskMaximumAllowedAge); <line18> if (devicesToContact == null || devicesToContact.isEmpty()) { <line19> return; <line20> } <line21> this.contactDevices(devicesToContact, DeviceFunction.GET_LIGHT_SENSOR_STATUS); <line22> } catch (final Exception e) { <line23> } <line24> } <line25> } <line26> 	 <line21>	No
"public class A { <line0> @Ignore(""Goes zombie too frequently; needs work. See HBASE-14563"") <line1> @Test <line2> public void test_TIMERANGE() throws Exception { <line3> Configuration conf = new Configuration(this.util.getConfiguration()); <line4> RecordWriter<ImmutableBytesWritable, Cell> writer = null; <line5> TaskAttemptContext context = null; <line6> Path dir = util.getDataTestDir(""test_TIMERANGE_present""); <line7> try { <line8> Job job = new Job(conf); <line9> FileOutputFormat.setOutputPath(job, dir); <line10> context = createTestTaskAttemptContext(job); <line11> HFileOutputFormat2 hof = new HFileOutputFormat2(); <line12> writer = hof.getRecordWriter(context); <line13> final byte[] b = Bytes.toBytes(""b""); <line14> KeyValue kv = new KeyValue(b, b, b, 2000, b); <line15> KeyValue original = kv.clone(); <line16> writer.write(new ImmutableBytesWritable(), kv); <line17> assertEquals(original, kv); <line18> kv = new KeyValue(b, b, b, 1000, b); <line19> original = kv.clone(); <line20> writer.write(new ImmutableBytesWritable(), kv); <line21> assertEquals(original, kv); <line22> writer.close(context); <line23> FileSystem fs = FileSystem.get(conf); <line24> Path attemptDirectory = hof.getDefaultWorkFile(context, """").getParent(); <line25> FileStatus[] sub1 = fs.listStatus(attemptDirectory); <line26> FileStatus[] file = fs.listStatus(sub1[0].getPath()); <line27> HFile.Reader rd = <line28> HFile.createReader(fs, file[0].getPath(), new CacheConfig(conf), true, conf); <line29> Map<byte[], byte[]> finfo = rd.getHFileInfo(); <line30> byte[] range = finfo.get(Bytes.toBytes(""TIMERANGE"")); <line31> assertNotNull(range); <line32> TimeRangeTracker timeRangeTracker = TimeRangeTracker.parseFrom(range); <line33> assertEquals(1000, timeRangeTracker.getMin()); <line34> assertEquals(2000, timeRangeTracker.getMax()); <line35> rd.close(); <line36> } finally { <line37> if (writer != null && context != null) writer.close(context); <line38> dir.getFileSystem(conf).delete(dir, true); <line39> } <line40> } <line41> } <line42> "	 <line19>	No
public class A { <line0> public void stepEnded(ConstructionHeuristicStepScope<Solution_> stepScope) { <line1> super.stepEnded(stepScope); <line2> entityPlacer.stepEnded(stepScope); <line3> decider.stepEnded(stepScope); <line4> if (logger.isDebugEnabled()) { <line5> long timeMillisSpent = stepScope.getPhaseScope().calculateSolverTimeMillisSpentUpToNow(); <line6> } <line7> } <line8> } <line9> 	 <line4>	No
"public class A { <line0> private synchronized void onUpdate() { <line1> ScheduledFuture<?> job = refreshJob; <line2> if (job == null || job.isCancelled()) { <line3> Configuration config = getThing().getConfiguration(); <line4> int refreshInterval = DEFAULT_REFRESH_INTERVALL_SECONDS; <line5> Object refreshConfig = config.get(""pollingInterval""); <line6> if (refreshConfig != null) { <line7> refreshInterval = ((BigDecimal) refreshConfig).intValue(); <line8> } <line9> refreshJob = <line10> scheduler.scheduleWithFixedDelay(refreshRunnable, 0, refreshInterval, TimeUnit.SECONDS); <line11> } <line12> } <line13> } <line14> "	 <line9>	No
"public class A { <line0> public boolean isExpired() { <line1> Date expDate = this.expDate; <line2> if (expDate == null) { <line3> try { <line4> expDate = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss z"").parse(expires); <line5> } catch (ParseException e) { <line6> Calendar calendar = Calendar.getInstance(); <line7> calendar.setTime(new Date()); <line8> calendar.add(Calendar.DAY_OF_YEAR, 1); <line9> expDate = calendar.getTime(); <line10> } <line11> } <line12> return (expDate == null || expDate.before(new Date())); <line13> } <line14> } <line15> "	 <line5>	No
"public class A { <line0> public static String reqApi( <line1> String api, Map<String, String> params, String curServer, boolean isPost) throws Exception { <line2> try { <line3> List<String> headers = <line4> Arrays.asList( <line5> HttpHeaderConsts.CLIENT_VERSION_HEADER, <line6> VersionUtils.version, <line7> HttpHeaderConsts.USER_AGENT_HEADER, <line8> UtilsAndCommons.SERVER_VERSION, <line9> ""Accept-Encoding"", <line10> ""gzip,deflate,sdch"", <line11> ""Connection"", <line12> ""Keep-Alive"", <line13> ""Content-Encoding"", <line14> ""gzip""); <line15> RestResult<String> result; <line16> if (!InternetAddressUtil.containsPort(curServer)) { <line17> curServer = curServer + InternetAddressUtil.IP_PORT_SPLITER + EnvUtil.getPort(); <line18> } <line19> if (isPost) { <line20> result = <line21> HttpClient.httpPost( <line22> ""http://"" <line23> + curServer <line24> + EnvUtil.getContextPath() <line25> + UtilsAndCommons.NACOS_NAMING_CONTEXT <line26> + ""/api/"" <line27> + api, <line28> headers, <line29> params); <line30> } else { <line31> result = <line32> HttpClient.httpGet( <line33> ""http://"" <line34> + curServer <line35> + EnvUtil.getContextPath() <line36> + UtilsAndCommons.NACOS_NAMING_CONTEXT <line37> + ""/api/"" <line38> + api, <line39> headers, <line40> params); <line41> } <line42> if (result.ok()) { <line43> return result.getData(); <line44> } <line45> if (HttpURLConnection.HTTP_NOT_MODIFIED == result.getCode()) { <line46> return StringUtils.EMPTY; <line47> } <line48> throw new IOException( <line49> ""failed to req API:"" <line50> + ""http://"" <line51> + curServer <line52> + EnvUtil.getContextPath() <line53> + UtilsAndCommons.NACOS_NAMING_CONTEXT <line54> + ""/api/"" <line55> + api <line56> + "". code:"" <line57> + result.getCode() <line58> + "" msg: "" <line59> + result.getMessage()); <line60> } catch (Exception e) { <line61> } <line62> return StringUtils.EMPTY; <line63> } <line64> } <line65> "	 <line56>	No
public class A { <line0> @Override <line1> protected Object doGetTransaction() throws TransactionException { <line2> HazelcastTransactionObject txObject = new HazelcastTransactionObject(); <line3> TransactionContextHolder transactionContextHolder = <line4> (TransactionContextHolder) TransactionSynchronizationManager.getResource(hazelcastInstance); <line5> if (transactionContextHolder != null) { <line6> if (logger.isDebugEnabled()) { <line7> } <line8> txObject.setTransactionContextHolder(transactionContextHolder, false); <line9> } <line10> return txObject; <line11> } <line12> } <line13> 	 <line9>	No
"public class A { <line0> private SearchResult performFTPRequest( <line1> String filenamepart, String catalog, int startIndex, int rows) { <line2> if (StringUtils.isBlank(ftpUsername) || StringUtils.isBlank(ftpPassword)) { <line3> throw new CatalogException( <line4> ""Incomplete credentials configured for FTP import in OPAC configuration for "" <line5> + ""catalog '"" <line6> + catalog <line7> + ""'""); <line8> } <line9> SearchResult searchResult = new SearchResult(); <line10> FTPFileFilter searchFilter = file -> file.isFile() && file.getName().contains(filenamepart); <line11> try { <line12> ftpLogin(); <line13> FTPFile[] files = ftpClient.listFiles(path, searchFilter); <line14> searchResult.setNumberOfHits(files.length); <line15> LinkedList<SingleHit> hits = new LinkedList<>(); <line16> for (int i = startIndex; i < Math.min(startIndex + rows, files.length); i++) { <line17> hits.add(new SingleHit(files[i].getName(), files[i].getName())); <line18> } <line19> searchResult.setHits(hits); <line20> ftpLogout(); <line21> } catch (IOException e) { <line22> throw new CatalogException(e.getMessage()); <line23> } finally { <line24> if (ftpClient.isConnected()) { <line25> try { <line26> ftpClient.disconnect(); <line27> } catch (IOException e) { <line28> } <line29> } <line30> } <line31> return searchResult; <line32> } <line33> } <line34> "	 <line25>	No
"public class A { <line0> @Test <line1> public void testF35() { <line2> setup(VehicleType.CONVENTIONAL.toString(), false); <line3> String content = FileReader.readFileInString(""src/test/resources/responses/F35/status.json""); <line4> assertTrue( <line5> testVehicle( <line6> content, <line7> STATUS_CONV + DOORS + RANGE_CONV + POSITION + SERVICE_EMPTY + CHECK_EMPTY, <line8> Optional.empty())); <line9> } <line10> } <line11> "	 <line2>	Yes
"public class A { <line0> @Test <line1> public void testCreateSharedLink() throws Exception { <line2> final Map<String, Object> headers = new HashMap<>(); <line3> headers.put(""CamelBox.folderId"", testFolder.getID()); <line4> headers.put(""CamelBox.access"", BoxSharedLink.Access.COLLABORATORS); <line5> headers.put(""CamelBox.unshareDate"", null); <line6> headers.put(""CamelBox.permissions"", new BoxSharedLink.Permissions()); <line7> final com.box.sdk.BoxSharedLink result = <line8> requestBodyAndHeaders(""direct://CREATEFOLDERSHAREDLINK"", null, headers); <line9> assertNotNull(result, ""createFolderSharedLink result""); <line10> } <line11> } <line12> "	 <line10>	Yes
public class A { <line0> private void notifyNoActivity() { <line1> enquireLinkSender.enquireLink(); <line2> } <line3> } <line4> 	 <line3>	No
public class A { <line0> public Invitation get(InvitationDTO dto, Long userId) { <line1> Invitation i = new Invitation(); <line2> i.setHash(randomUUID().toString()); <line3> i.setPasswordProtected(dto.isPasswordProtected()); <line4> if (dto.isPasswordProtected()) { <line5> i.setPassword(CryptProvider.get().hash(dto.getPassword())); <line6> } <line7> i.setUsed(false); <line8> i.setValid(dto.getValid()); <line9> try { <line10> switch (dto.getValid()) { <line11> case PERIOD: <line12> i.setValidFrom(new Date(SDF.parse(dto.getValidFrom()).getTime() - (5 * 60 * 1000))); <line13> i.setValidTo(SDF.parse(dto.getValidTo())); <line14> break; <line15> case ENDLESS: <line16> case ONE_TIME: <line17> default: <line18> break; <line19> } <line20> } catch (ParseException e) { <line21> throw new RuntimeException(e); <line22> } <line23> i.setDeleted(false); <line24> i.setInvitedBy(userDao.get(userId)); <line25> i.setInvitee(userDao.getContact(dto.getEmail(), dto.getFirstname(), dto.getLastname(), userId)); <line26> if (Type.CONTACT == i.getInvitee().getType()) { <line27> i.getInvitee().setLanguageId(dto.getLanguageId()); <line28> } <line29> i.setRoom(roomDao.get(dto.getRoomId())); <line30> i.setInserted(new Date()); <line31> i.setAppointment(null); <line32> return i; <line33> } <line34> } <line35> 	 <line21>	Yes
public class A { <line0> void undeploy() { <line1> this.stopDeployedApplicationContext(); <line2> try { <line3> this.archiveLoader.close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> private DDMFormField _getDDMFormField( <line1> BiFunction<List<DDMFormField>, String, DDMFormField> biFunction, <line2> String identifier, <line3> UnsafeBiFunction<DDMStructure, String, DDMFormField, PortalException> unsafeBiFunction) <line4> throws PortalException { <line5> DDMForm ddmForm = _getDDMForm(); <line6> DDMFormField ddmFormField = biFunction.apply(ddmForm.getDDMFormFields(), identifier); <line7> if (ddmFormField != null) { <line8> return ddmFormField; <line9> } <line10> try { <line11> DDMStructure parentDDMStructure = getParentDDMStructure(); <line12> if (parentDDMStructure != null) { <line13> return unsafeBiFunction.apply(parentDDMStructure, identifier); <line14> } <line15> } catch (PortalException portalException) { <line16> } <line17> throw new StructureFieldException(""Unable to find field "" + identifier); <line18> } <line19> } <line20> "	 <line12>	No
"public class A { <line0> public String delete() throws Exception { <line1> if (update) { <line2> try { <line3> groupService.removeGroup(this.group); <line4> oxTrustAuditService.audit( <line5> ""GROUP "" + this.group.getInum() + "" **"" + this.group.getDisplayName() + ""** REMOVED"", <line6> identity.getUser(), <line7> (HttpServletRequest) <line8> FacesContext.getCurrentInstance().getExternalContext().getRequest()); <line9> facesMessages.add( <line10> FacesMessage.SEVERITY_INFO, <line11> ""Group '#{updateGroupAction.group.displayName}' removed successfully""); <line12> conversationService.endConversation(); <line13> return OxTrustConstants.RESULT_SUCCESS; <line14> } catch (BasePersistenceException ex) { <line15> } <line16> } <line17> facesMessages.add( <line18> FacesMessage.SEVERITY_ERROR, <line19> ""Failed to remove group '#{updateGroupAction.group.displayName}'""); <line20> return OxTrustConstants.RESULT_FAILURE; <line21> } <line22> } <line23> "	 <line15>	Yes
public class A { <line0> @Override <line1> public void clear() throws BackendException { <line2> this.checkOpened(); <line3> for (BackendStore store : this.stores.values()) { <line4> store.clear(false); <line5> } <line6> for (BackendStore store : this.stores.values()) { <line7> store.clear(true); <line8> } <line9> this.notifyAndWaitEvent(Events.STORE_CLEAR); <line10> } <line11> } <line12> 	 <line10>	Yes
public class A { <line0> private boolean availabilityCheck() { <line1> try { <line2> final WebClient client = factory.getWebClient(); <line3> final Response response = client.head(); <line4> return response != null && !(response.getStatus() >= 404 || response.getStatus() == 402); <line5> } catch (Exception e) { <line6> return false; <line7> } <line8> } <line9> } <line10> 	 <line8>	No
public class A { <line0> public static com.liferay.fragment.model.FragmentCompositionSoap[] getFragmentCompositions( <line1> long fragmentCollectionId, int start, int end) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.fragment.model.FragmentComposition> returnValue = <line4> FragmentCompositionServiceUtil.getFragmentCompositions(fragmentCollectionId, start, end); <line5> return com.liferay.fragment.model.FragmentCompositionSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line1>	No
public class A { <line0> @Override <line1> public void onPreConnect() { <line2> if (count++ == 1) { <line3> startCountDown.countDown(); <line4> try { <line5> endCountDown.await(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line2>	Yes
"public class A { <line0> public Location getLocation(BlobStore blobStore, String locationId) { <line1> Location location = null; <line2> if (locationId != null && !locationId.isEmpty()) { <line3> Set<? extends Location> listAssignableLocations = blobStore.listAssignableLocations(); <line4> for (Location loc : listAssignableLocations) { <line5> if (loc.getId().equalsIgnoreCase(locationId)) { <line6> location = loc; <line7> break; <line8> } <line9> } <line10> if (location == null) { <line11> throw new IllegalArgumentException(""unknown location: "" + locationId); <line12> } <line13> } <line14> return location; <line15> } <line16> } <line17> "	 <line4>	Yes
public class A { <line0> public void reopen(final boolean enforce) { <line1> final long ts = file.timeStamp(); <line2> if (!opened() || timeStamp == ts && !enforce) return; <line3> timeStamp = 0; <line4> return; <line5> } <line6> try { <line7> setText(file.read()); <line8> file(file, false); <line9> release(Action.PARSE); <line10> timeStamp = ts; <line11> } catch (final IOException ex) { <line12> timeStamp = 0; <line13> } <line14> } <line15> } <line16> 	 <line11>	No
public class A { <line0> @Override <line1> protected void onNodeAdded(final String networkId, final Node node) { <line2> String connType = conversionTable().getConnectionType(networkId); <line3> if (connType != null && connType.equals(AGGREGATED)) { <line4> return; <line5> } <line6> String aggNetworkId = getNetworkIdByType(AGGREGATED); <line7> if (aggNetworkId == null) { <line8> return; <line9> } <line10> NetworkInterface aggNetworkIf = networkInterfaces().get(aggNetworkId); <line11> if (getConvNodeId(aggNetworkId, this.getObjectId()) == null) { <line12> node.putAttribute(AttrElements.PHYSICAL_ID, this.getObjectId()); <line13> Node aggNodeMsg = <line14> new Node( <line15> node.getVersion(), <line16> this.getObjectId(), <line17> new HashMap<String, Port>(), <line18> node.getAttributes()); <line19> aggNetworkIf.putNode(aggNodeMsg); <line20> } <line21> Map<String, String> updateAttr = new HashMap<>(); <line22> updateAttr.put(Logic.AttrElements.OPER_STATUS, STATUS_DOWN); <line23> aggNetworkIf.putAttributeOfNode(updateAttr); <line24> conversionTable().addEntryNode(networkId, node.getId(), aggNetworkId, this.getObjectId()); <line25> } <line26> } <line27> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public Object postProcessBeforeInitialization(Object bean, String beanName) <line2> throws BeansException { <line3> if (!(bean instanceof IdentifiableOSGiService) <line4> && beanName.endsWith(""Service"") <line5> && _log.isWarnEnabled()) { <line6> } <line7> _autoInject(bean, beanName, bean.getClass()); <line8> return bean; <line9> } <line10> } <line11> "	 <line6>	Yes
public class A { <line0> @Override <line1> public void waitForDrain() throws InterruptedException { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> unlockCompletely(recoveryPutLock); <line5> unlockCompletely(recoveryGetLock); <line6> notFull.await(); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
public class A { <line0> private boolean loadItems() { <line1> long start = System.currentTimeMillis(); <line2> ClassLoader contextClassLoader = currentThread().getContextClassLoader(); <line3> try { <line4> currentThread().setContextClassLoader(getClass().getClassLoader()); <line5> CloudBlobContainer container = Utils.getBlobContainer(connectionString, containerName); <line6> if (!firstCall && (resultContinuation == null || !resultContinuation.hasContinuation())) { <line7> return false; <line8> } <line9> firstCall = false; <line10> ResultSegment<ListBlobItem> results = <line11> container.listBlobsSegmented( <line12> null, <line13> false, <line14> EnumSet.noneOf(BlobListingDetails.class), <line15> null, <line16> resultContinuation, <line17> null, <line18> null); <line19> resultContinuation = results.getContinuationToken(); <line20> for (ListBlobItem item : results.getResults()) { <line21> if (item instanceof CloudBlob) { <line22> items.add(AzureBlobInfo.fromCloudBlob((CloudBlob) item)); <line23> } <line24> } <line25> return results.getLength() > 0; <line26> } catch (StorageException e) { <line27> } catch (DataStoreException e) { <line28> } finally { <line29> if (contextClassLoader != null) { <line30> currentThread().setContextClassLoader(contextClassLoader); <line31> } <line32> } <line33> return false; <line34> } <line35> } <line36> 	 <line17>	No
"public class A { <line0> @Override <line1> public ActionLogRecord getActionRecord(int id) { <line2> Connection conn = null; <line3> PreparedStatement stat = null; <line4> ResultSet res = null; <line5> ActionLogRecord actionRecord = null; <line6> try { <line7> conn = this.getConnection(); <line8> conn.setAutoCommit(false); <line9> stat = conn.prepareStatement(GET_ACTION_RECORD); <line10> stat.setInt(1, id); <line11> res = stat.executeQuery(); <line12> if (res.next()) { <line13> actionRecord = new ActionLogRecord(); <line14> actionRecord.setId(id); <line15> Timestamp actionDate = res.getTimestamp(""actiondate""); <line16> actionRecord.setActionDate(new Date(actionDate.getTime())); <line17> Timestamp updateDate = res.getTimestamp(""updatedate""); <line18> actionRecord.setUpdateDate(new Date(updateDate.getTime())); <line19> actionRecord.setActionName(res.getString(""actionname"")); <line20> actionRecord.setNamespace(res.getString(""namespace"")); <line21> actionRecord.setParameters(res.getString(""parameters"")); <line22> actionRecord.setUsername(res.getString(""username"")); <line23> String asiXml = res.getString(""activitystreaminfo""); <line24> if (null != asiXml && asiXml.trim().length() > 0) { <line25> ActivityStreamInfo asi = ActivityStreamInfoDOM.unmarshalInfo(asiXml); <line26> actionRecord.setActivityStreamInfo(asi); <line27> } <line28> } <line29> conn.commit(); <line30> } catch (Throwable t) { <line31> this.executeRollback(conn); <line32> throw new RuntimeException(""Error loading actionlogger record with id: "" + id, t); <line33> } finally { <line34> closeDaoResources(res, stat, conn); <line35> } <line36> return actionRecord; <line37> } <line38> } <line39> "	 <line32>	Yes
"public class A { <line0> @Then(""^I wait (\\d+) seconds$"") <line1> public void iWaitXSeconds(final Integer seconds) { <line2> try { <line3> Thread.sleep(seconds * 1000); <line4> } catch (final InterruptedException e) { <line5> Thread.currentThread().interrupt(); <line6> } <line7> } <line8> } <line9> "	 <line1>	No
public class A { <line0> @Override <line1> public void close() { <line2> if (this.httpServer == null) { <line3> return; <line4> } <line5> try { <line6> for (WebAppContext webapp : webApps) { <line7> webapp.stop(); <line8> } <line9> this.httpServer.stop(); <line10> } catch (Exception e) { <line11> } finally { <line12> try { <line13> this.httpServer.destroy(); <line14> } catch (Exception e) { <line15> } finally { <line16> this.httpServer = null; <line17> } <line18> } <line19> } <line20> } <line21> 	 <line5>	Yes
"public class A { <line0> public static void positionalTest01(RoboClaw rc) throws Exception { <line1> boolean done = false; <line2> while (!done) { <line3> rc.readPidM1(); <line4> rc.readPidM1(); <line5> rc.setPidQppsDeadzoneMinMaxM1(0, 15000, 50, 56000, 500, 0, 4000000); <line6> rc.readPidM1(); <line7> rc.readPidM1(); <line8> rc.resetEncoders(); <line9> int speed = 1000000; <line10> int accel = 1000000; <line11> int deccel = 1000000; <line12> int pos = 3000000; <line13> rc.driveSpeedAccelDeccelPosM1(speed, accel, deccel, pos); <line14> rc.driveSpeedAccelDeccelPosM1(speed, accel, deccel, 1000000); <line15> rc.readEncoderM1(); <line16> rc.driveForwardM1(0); <line17> sleep(500); <line18> rc.resetEncoders(); <line19> log.info(""encoder {}"", rc.readEncoderM1()); <line20> log.info(""running forward 90 duty for 1s""); <line21> rc.driveForwardM1(90); <line22> sleep(500); <line23> log.info(""mid raw speed {}"", rc.readSpeedM1()); <line24> sleep(500); <line25> log.info(""stopping motor waiting 0.5s""); <line26> rc.driveForwardM1(0); <line27> sleep(500); <line28> log.info(""raw speed {} encoder {}"", rc.readSpeedM1(), rc.readEncoderM1()); <line29> rc.driveBackwardM1(0); <line30> sleep(500); <line31> rc.driveBackwardM1(90); <line32> sleep(500); <line33> sleep(500); <line34> rc.driveBackwardM1(0); <line35> sleep(500); <line36> } <line37> } <line38> } <line39> "	 <line36>	Yes
public class A { <line0> @Override <line1> public void onError(Exception exception) { <line2> if (exception instanceof ConnectException) { <line3> } else { <line4> } <line5> } <line6> } <line7> 	 <line2>	No
public class A { <line0> public static TestServer createAndStartServer(Class<?>... configClasses) { <line1> int port = NEXT_PORT.incrementAndGet(); <line2> Server server = new Server(port); <line3> AnnotationConfigWebApplicationContext applicationContext = <line4> new AnnotationConfigWebApplicationContext(); <line5> applicationContext.register(configClasses); <line6> applicationContext.refresh(); <line7> try { <line8> server.setHandler(getServletContextHandler(applicationContext)); <line9> server.start(); <line10> } catch (Exception e) { <line11> } <line12> return new TestServer(server, applicationContext, port); <line13> } <line14> } <line15> 	 <line3>	No
public class A { <line0> @Override <line1> public void appendChildren(final Txn transaction, NodeList nodes, final int child) <line2> throws DOMException { <line3> nodes = checkForAttributes(transaction, nodes); <line4> if (nodes == null || nodes.getLength() == 0) { <line5> return; <line6> } <line7> try (final DBBroker broker = ownerDocument.getBrokerPool().getBroker()) { <line8> final NodePath path = getPath(); <line9> StreamListener listener = null; <line10> final IndexController indexes = broker.getIndexController(); <line11> indexes.setDocument(ownerDocument); <line12> final IStoredNode reindexRoot = indexes.getReindexRoot(this, path, true, true); <line13> indexes.setMode(ReindexMode.STORE); <line14> if (reindexRoot == null) { <line15> listener = indexes.getStreamListener(); <line16> } <line17> if (children == 0) { <line18> appendChildren( <line19> transaction, nodeId.newChild(), null, new NodeImplRef(this), path, nodes, listener); <line20> } else { <line21> if (child == 1) { <line22> final Node firstChild = getFirstChild(); <line23> insertBefore(transaction, nodes, firstChild); <line24> } else { <line25> if (child > 1 && child <= children) { <line26> final NodeList cl = getAttrsAndChildNodes(); <line27> final IStoredNode<?> last = (IStoredNode<?>) cl.item(child - 2); <line28> insertAfter(transaction, nodes, last); <line29> } else { <line30> final IStoredNode<?> last = (IStoredNode<?>) getLastChild(true); <line31> appendChildren( <line32> transaction, <line33> last.getNodeId().nextSibling(), <line34> null, <line35> new NodeImplRef(getLastNode(last)), <line36> path, <line37> nodes, <line38> listener); <line39> } <line40> } <line41> } <line42> broker.updateNode(transaction, this, false); <line43> indexes.reindex(transaction, reindexRoot, ReindexMode.STORE); <line44> broker.flush(); <line45> } catch (final EXistException e) { <line46> } <line47> } <line48> } <line49> 	 <line46>	Yes
"public class A { <line0> public static synchronized File getArtifactsFolder() { <line1> if (artifactsDirectory == null) { <line2> String absolutePath = getBaseDir().getAbsolutePath(); <line3> try { <line4> if (Configuration.get(Parameter.CUSTOM_ARTIFACTS_FOLDER).isEmpty()) { <line5> artifactsDirectory = <line6> new File( <line7> String.format( <line8> ""%s/%s"", URLDecoder.decode(absolutePath, ""utf-8""), ARTIFACTS_FOLDER)); <line9> } else { <line10> artifactsDirectory = new File(Configuration.get(Parameter.CUSTOM_ARTIFACTS_FOLDER)); <line11> } <line12> } catch (UnsupportedEncodingException e) { <line13> throw new RuntimeException(""Artifacts folder not created in base dir: "" + absolutePath); <line14> } <line15> boolean isCreated = artifactsDirectory.exists() && artifactsDirectory.isDirectory(); <line16> if (!isCreated) { <line17> isCreated = artifactsDirectory.mkdir(); <line18> } else { <line19> } <line20> if (!isCreated) { <line21> throw new RuntimeException( <line22> ""Artifacts folder not created: "" + artifactsDirectory.getAbsolutePath()); <line23> } else { <line24> } <line25> } <line26> return artifactsDirectory; <line27> } <line28> } <line29> "	 <line13>	No
"public class A { <line0> @Override <line1> public boolean refreshMaterializedView(SqlView sqlView) { <line2> final String sql = ""REFRESH MATERIALIZED VIEW "" + sqlView.getViewName(); <line3> try { <line4> jdbcTemplate.update(sql); <line5> return true; <line6> } catch (Exception ex) { <line7> return false; <line8> } <line9> } <line10> } <line11> "	 <line3>	Yes
public class A { <line0> public String dispatchAuthorization(String servletBaseURL, String state, String code) <line1> throws SmartherGatewayException { <line2> final SmartherAccountHandler accountHandler = getAccountHandlerByUID(state); <line3> if (accountHandler != null) { <line4> final String notificationUrl = <line5> servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS); <line6> return accountHandler.authorize(servletBaseURL, code, notificationUrl); <line7> } else { <line8> throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE); <line9> } <line10> } <line11> } <line12> 	 <line8>	Yes
public class A { <line0> private KuraPayload doGetInventory() { <line1> List<SystemResourceInfo> inventory = new ArrayList<>(); <line2> try { <line3> inventory.addAll(this.systemService.getSystemPackages()); <line4> } catch (KuraProcessExecutionErrorException e) { <line5> } <line6> Bundle[] bundles = this.bundleContext.getBundles(); <line7> Arrays.asList(bundles).stream() <line8> .forEach( <line9> b -> <line10> inventory.add( <line11> new SystemResourceInfo( <line12> b.getSymbolicName(), <line13> b.getVersion().toString(), <line14> SystemResourceType.BUNDLE))); <line15> DeploymentPackage[] dps = this.deploymentAdmin.listDeploymentPackages(); <line16> Arrays.asList(dps).stream() <line17> .forEach( <line18> dp -> <line19> inventory.add( <line20> new SystemResourceInfo( <line21> dp.getName(), dp.getVersion().toString(), SystemResourceType.DP))); <line22> inventory.sort(Comparator.comparing(SystemResourceInfo::getName)); <line23> SystemResourcesInfo systemResourcesInfo = new SystemResourcesInfo(inventory); <line24> KuraResponsePayload respPayload = new KuraResponsePayload(KuraResponsePayload.RESPONSE_CODE_OK); <line25> try { <line26> String s = marshal(systemResourcesInfo); <line27> respPayload.setTimestamp(new Date()); <line28> respPayload.setBody(s.getBytes(Charsets.UTF_8)); <line29> } catch (Exception e1) { <line30> respPayload.setResponseCode(KuraResponsePayload.RESPONSE_CODE_ERROR); <line31> } <line32> return respPayload; <line33> } <line34> } <line35> 	 <line30>	Yes
"public class A { <line0> @Override <line1> public User getUserByIdentity(String identity) throws AuthorizationAccessException { <line2> User user; <line3> synchronized (usersByName) { <line4> user = usersByName.get(identity); <line5> } <line6> if (user == null) { <line7> refreshOneUser(selectedShellCommands.getUserByName(identity), ""Get Single User by Name""); <line8> user = usersByName.get(identity); <line9> } <line10> if (user == null) { <line11> } else { <line12> } <line13> return user; <line14> } <line15> } <line16> "	 <line10>	No
public class A { <line0> @Override <line1> public synchronized void initialize( <line2> final EventReporter eventReporter, <line3> final Authorizer authorizer, <line4> final ProvenanceAuthorizableFactory resourceFactory, <line5> final IdentifierLookup idLookup) <line6> throws IOException { <line7> final RecordWriterFactory recordWriterFactory = <line8> (file, idGenerator, compressed, createToc) -> { <line9> final TocWriter tocWriter = <line10> createToc ? new StandardTocWriter(TocUtil.getTocFile(file), false, false) : null; <line11> return new EventIdFirstSchemaRecordWriter( <line12> file, idGenerator, tocWriter, compressed, BLOCK_SIZE, idLookup); <line13> }; <line14> final EventFileManager fileManager = new EventFileManager(); <line15> final RecordReaderFactory recordReaderFactory = <line16> (file, logs, maxChars) -> { <line17> fileManager.obtainReadLock(file); <line18> try { <line19> return RecordReaders.newRecordReader(file, logs, maxChars); <line20> } finally { <line21> fileManager.releaseReadLock(file); <line22> } <line23> }; <line24> eventStore = <line25> new PartitionedWriteAheadEventStore( <line26> config, recordWriterFactory, recordReaderFactory, eventReporter, fileManager); <line27> final IndexManager indexManager = new SimpleIndexManager(config); <line28> eventIndex = new LuceneEventIndex(config, indexManager, eventReporter); <line29> this.eventReporter = eventReporter; <line30> this.authorizer = authorizer; <line31> this.resourceFactory = resourceFactory; <line32> eventStore.initialize(); <line33> eventIndex.initialize(eventStore); <line34> try { <line35> eventStore.reindexLatestEvents(eventIndex); <line36> } catch (final Exception e) { <line37> } <line38> } <line39> } <line40> 	 <line27>	No
public class A { <line0> @Override <line1> public Set<DiscoveredResourceDetails> discoverResources( <line2> final ResourceDiscoveryContext<ApplicationResourceComponent> context) { <line3> final HashSet<DiscoveredResourceDetails> discoveredResources = <line4> new HashSet<DiscoveredResourceDetails>(); <line5> final ApplicationResourceComponent parent = context.getParentResourceComponent(); <line6> final Map<String, Reference> references = parent.getReferences(); <line7> for (Reference reference : references.values()) { <line8> final Configuration pluginConfig = context.getDefaultPluginConfiguration(); <line9> final QName name = reference.getName(); <line10> final DiscoveredResourceDetails resource = <line11> new DiscoveredResourceDetails( <line12> context.getResourceType(), <line13> name.toString(), <line14> name.getLocalPart(), <line15> name.getNamespaceURI(), <line16> null, <line17> pluginConfig, <line18> null); <line19> discoveredResources.add(resource); <line20> } <line21> return discoveredResources; <line22> } <line23> } <line24> 	 <line5>	No
"public class A { <line0> public void getData(File toFile) throws IOFailure, ArgumentNotValid { <line1> ArgumentNotValid.checkNotNull(toFile, ""toFile""); <line2> if (theRemoteFile == null) { <line3> throw new IOFailure(""No remoteFile in this message.""); <line4> } <line5> theRemoteFile.copyTo(toFile); <line6> try { <line7> theRemoteFile.cleanup(); <line8> } catch (IOFailure e) { <line9> } <line10> theRemoteFile = null; <line11> } <line12> } <line13> "	 <line7>	No
"public class A { <line0> public void updateProfile(String profile, String value) { <line1> switch (profile) { <line2> case ""driving-car"": <line3> case ""driving-hgv"": <line4> break; <line5> case ""test"": <line6> try { <line7> ORSKafkaConsumerMessageSpeedUpdate msg = <line8> mapper.readValue(value, ORSKafkaConsumerMessageSpeedUpdate.class); <line9> this.kafkaMessagesProcessed++; <line10> } catch (JsonProcessingException e) { <line11> this.kafkaMessagesFailed++; <line12> } <line13> break; <line14> default: <line15> this.kafkaMessagesFailed++; <line16> break; <line17> } <line18> } <line19> } <line20> "	 <line9>	Yes
"public class A { <line0> private void rewritePropertiesToFile(Properties props, File propsFile) throws IOException { <line1> StringBuilder sb = new StringBuilder(); <line2> sb.append(""#Generated by the VcapPropertyLoader\n""); <line3> sb.append(""#"").append(new Date().toString()).append(""\n""); <line4> for (Object key : props.keySet()) { <line5> sb.append(key).append(""="").append(props.getProperty(key.toString())).append(""\n""); <line6> } <line7> FileUtils.writeStringToFile(propsFile, sb + ""\n"", false); <line8> } <line9> } <line10> "	 <line6>	No
"public class A { <line0> protected void testTenant() { <line1> if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) { <line2> return; <line3> } <line4> if (this.tenantName == null || this.tenantName.isEmpty()) { <line5> throw new IllegalStateException(""Missing tenant name""); <line6> } <line7> if (tenantKeyFileName != null) { <line8> tenantKey = this.tenantKeyFileUtil.readTenantFile(tenantKeyFileName); <line9> } <line10> if (this.tenantKey == null || this.tenantKey.isEmpty()) { <line11> throw new IllegalArgumentException(""No tenant-key value provided""); <line12> } <line13> Db2Adapter adapter = new Db2Adapter(connectionPool); <line14> try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) { <line15> try { <line16> Db2SetTenantVariable cmd = <line17> new Db2SetTenantVariable(schema.getAdminSchemaName(), tenantName, tenantKey); <line18> adapter.runStatement(cmd); <line19> Db2GetTenantVariable getter = new Db2GetTenantVariable(schema.getAdminSchemaName()); <line20> Integer tid = adapter.runStatement(getter); <line21> if (tid == null) { <line22> throw new IllegalStateException(""SV_TENANT_ID not set!""); <line23> } <line24> GetResourceTypeList rtListGetter = new GetResourceTypeList(schema.getSchemaName()); <line25> List<ResourceType> rtList = adapter.runStatement(rtListGetter); <line26> } catch (DataAccessException x) { <line27> tx.setRollbackOnly(); <line28> throw x; <line29> } <line30> } <line31> } <line32> } <line33> "	 <line26>	Yes
public class A { <line0> private void stop() { <line1> if (monitoringStarted) { <line2> dcAgent.stop(); <line3> monitoringStarted = false; <line4> } else { <line5> } <line6> } <line7> } <line8> 	 <line4>	No
public class A { <line0> public Optional<Method> getGetter(Class<?> originatingClass) { <line1> try { <line2> return Optional.ofNullable(_Reflect.getGetter(originatingClass, field.getName())); <line3> } catch (IntrospectionException e) { <line4> } <line5> return Optional.empty(); <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> @Override <line1> protected void doNotify(Record notification) { <line2> for (Object event : Notifications.getLifecycleEvents(notification)) { <line3> if (event == Notifications.LifecycleEvent.SHUTDOWN) { <line4> try { <line5> databaseReader.close(); <line6> } catch (IOException e) { <line7> } <line8> } <line9> } <line10> super.doNotify(notification); <line11> } <line12> } <line13> 	 <line7>	Yes
public class A { <line0> private static org.apache.hadoop.fs.Path getSystemDir(Configuration conf) throws IOException { <line1> try { <line2> return HadoopDataSourceUtil.getSystemDir(conf, true); <line3> } catch (IOException e) { <line4> org.apache.hadoop.fs.Path raw = HadoopDataSourceUtil.getSystemDir(conf, false); <line5> return raw; <line6> } <line7> } <line8> } <line9> 	 <line2>	No
public class A { <line0> private void registerSystemMBeans() { <line1> try { <line2> addMBean(new ObjectName(SystemInfo.OBJECT_NAME), new org.exist.management.impl.SystemInfo()); <line3> } catch (final MalformedObjectNameException | DatabaseConfigurationException e) { <line4> } <line5> } <line6> } <line7> 	 <line2>	No
public class A { <line0> public void addConnection(final EISConnection connection) { <line1> synchronized (this.connections) { <line2> this.connections.add(connection); <line3> } <line4> } <line5> } <line6> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void afterJobScheduled(AsynchronousJobEvent event) { <line2> Long data = event.getJob().getId(); <line3> clusterService.addData( <line4> ClusterAwareService.CLUSTER_JOBS_KEY, clusterService.getThisNode().toKey(), data); <line5> } <line6> } <line7> 	 <line2>	Yes
"public class A { <line0> public static TriggerConfiguration createConfiguration( <line1> String jobTriggerStrategy, TriggeredScrapeJobImpl triggeredScrapeJob) <line2> throws ScraperConfigurationException { <line3> Matcher matcher = TRIGGER_STRATEGY_PATTERN.matcher(jobTriggerStrategy); <line4> if (matcher.matches()) { <line5> String triggerStrategy = matcher.group(""strategy""); <line6> String scheduledMs = matcher.group(""scheduledInterval""); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> String triggerVar = matcher.group(""triggerVar""); <line10> String comparatorString = matcher.group(""comp""); <line11> String comparatorVariable = matcher.group(""compVar""); <line12> switch (triggerStrategy) { <line13> case TRIGGER: <line14> if (triggerVar == null || comparatorString == null || comparatorVariable == null) { <line15> throw new ScraperConfigurationException( <line16> ""TRIGGER_VAR trigger strategy needs the trigger-condition - information missing!"" <line17> + "" given configString: "" <line18> + jobTriggerStrategy); <line19> } <line20> List<TriggerElement> triggerElements = new ArrayList<>(); <line21> String connectionString = <line22> triggeredScrapeJob <line23> .getSourceConnections() <line24> .get(triggeredScrapeJob.getSourceConnections().keySet().iterator().next()); <line25> TriggerElement triggerElement = <line26> new TriggerElement( <line27> comparatorString, <line28> null, <line29> comparatorVariable, <line30> triggerVar, <line31> triggerStrategy, <line32> connectionString); <line33> triggerElement.setTriggerJob(triggeredScrapeJob.getJobName()); <line34> triggerElements.add(triggerElement); <line35> String concatConn = matcher.group(""concatConn""); <line36> String triggerVar2 = matcher.group(""triggerVar2""); <line37> String comparatorString2 = matcher.group(""comp2""); <line38> String comparatorVariable2 = matcher.group(""compVar2""); <line39> if (triggerVar2 != null <line40> && comparatorString2 != null <line41> && comparatorVariable2 != null <line42> && concatConn != null) { <line43> TriggerElement triggerElement2 = <line44> new TriggerElement( <line45> comparatorString2, <line46> concatConn, <line47> comparatorVariable2, <line48> triggerVar2, <line49> triggerStrategy, <line50> connectionString); <line51> triggerElement2.setTriggerJob(triggeredScrapeJob.getJobName()); <line52> triggerElements.add(triggerElement2); <line53> } <line54> return new TriggerConfiguration( <line55> TriggerType.TRIGGER_VAR, scheduledMs, triggerElements, triggeredScrapeJob); <line56> case SCHEDULED: <line57> if (triggerVar != null || comparatorString != null || comparatorVariable != null) { <line58> throw new ScraperConfigurationException( <line59> ""SCHEDULED trigger strategy must only be used with scheduled interval - nothing"" <line60> + "" more!  given configString: "" <line61> + jobTriggerStrategy); <line62> } <line63> return new TriggerConfiguration(TriggerType.SCHEDULED, scheduledMs); <line64> default: <line65> throw new ScraperConfigurationException(""Unknown Trigger Strategy "" + triggerStrategy); <line66> } <line67> } <line68> throw new ScraperConfigurationException( <line69> ""Invalid trigger strategy string description: "" + jobTriggerStrategy); <line70> } <line71> } <line72> "	 <line31>	No
"public class A { <line0> @Override <line1> public List<Artifact> getProjectArtifacts(String projectId) <line2> throws InvalidProtocolBufferException, ExecutionException, InterruptedException { <line3> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line4> Query query = session.createQuery(GET_PROJECT_BY_ID_HQL); <line5> query.setParameter(""id"", projectId); <line6> ProjectEntity projectEntity = (ProjectEntity) query.uniqueResult(); <line7> if (projectEntity == null) { <line8> String errorMessage = ""Project not found for given ID: "" + projectId; <line9> throw new NotFoundException(errorMessage); <line10> } <line11> Project project = <line12> projectEntity.getProtoObject(roleService, authService, new HashMap<>(), new HashMap<>()); <line13> if (project.getArtifactsList() != null && !project.getArtifactsList().isEmpty()) { <line14> return project.getArtifactsList(); <line15> } else { <line16> String errorMessage = ""Artifacts not found in the Project""; <line17> throw new NotFoundException(errorMessage); <line18> } <line19> } catch (Exception ex) { <line20> if (ModelDBUtils.needToRetry(ex)) { <line21> return getProjectArtifacts(projectId); <line22> } else { <line23> throw ex; <line24> } <line25> } <line26> } <line27> } <line28> "	 <line7>	No
public class A { <line0> public static Properties getProperties() { <line1> Properties kuraExtendedProps = new Properties(); <line2> File kuranetFile = new File(KURANET_FILENAME); <line3> if (kuranetFile.exists()) { <line4> FileInputStream fis = null; <line5> try { <line6> fis = new FileInputStream(kuranetFile); <line7> kuraExtendedProps.load(fis); <line8> } catch (Exception e) { <line9> } finally { <line10> if (null != fis) { <line11> try { <line12> fis.close(); <line13> } catch (IOException e) { <line14> } <line15> } <line16> } <line17> } else { <line18> } <line19> return kuraExtendedProps; <line20> } <line21> } <line22> 	 <line14>	Yes
"public class A { <line0> public String toTableName(String name) { <line1> String identifier = toIdentifier(name, tableNamePrefix, tableNameSuffix); <line2> if (identifierNamingConvention.equals(""snake_case"")) { <line3> identifier = underscore(identifier); <line4> } <line5> if (identifier.length() > IDENTIFIER_MAX_LENGTH) { <line6> identifier = identifier.substring(0, IDENTIFIER_MAX_LENGTH); <line7> } <line8> return identifier; <line9> } <line10> } <line11> "	 <line6>	Yes
"public class A { <line0> @Override <line1> protected void finalize() throws Throwable { <line2> if (getIrodsConnection().isConnected()) { <line3> log.error( <line4> ""**************************************************************************************""); <line5> obliterateConnectionAndDiscardErrors(); <line6> } <line7> super.finalize(); <line8> } <line9> } <line10> "	 <line8>	No
public class A { <line0> @Override <line1> public ServerResource reloadResource(HostVO host) { <line2> String resourceName = host.getResource(); <line3> ServerResource resource = getResource(resourceName); <line4> if (resource != null) { <line5> _hostDao.loadDetails(host); <line6> HashMap<String, Object> params = buildConfigParams(host); <line7> try { <line8> resource.configure(host.getName(), params); <line9> } catch (ConfigurationException e) { <line10> return null; <line11> } <line12> if (!resource.start()) { <line13> return null; <line14> } <line15> } <line16> return resource; <line17> } <line18> } <line19> 	 <line16>	No
"public class A { <line0> private String performSplitting(String source, String splitString, String indexString) <line1> throws TransformationOperationException { <line2> Integer index = parseIntString(indexString, false, 0); <line3> Matcher matcher = generateMatcher(splitString, source); <line4> for (int i = 0; i <= index; i++) { <line5> matcher.find(); <line6> } <line7> String value = matcher.group(); <line8> if (value == null) { <line9> getLogger() <line10> value = """"; <line11> } <line12> return value; <line13> } <line14> } <line15> "	 <line10>	Yes
"public class A { <line0> private void invokeScript(Binding binding) { <line1> GroovyShell shell = new GroovyShell(binding); <line2> Reader scriptReader = getFileReader(config.scriptPath); <line3> Stopwatch timer = Stopwatch.createStarted(); <line4> try { <line5> shell.evaluate(scriptReader); <line6> } catch (Exception e) { <line7> throw new InternalException( <line8> ""Failed to execute Groovy "" <line9> + "" script: "" <line10> + config.scriptPath <line11> + "": reason: "" <line12> + e.getMessage(), <line13> e); <line14> } <line15> } <line16> } <line17> "	 <line15>	Yes
public class A { <line0> private static void doTestHashDistribution(int features, double sampleRate, int numCores) { <line1> LocalitySensitiveHash lsh = new LocalitySensitiveHash(sampleRate, features, numCores); <line2> int numHashes = lsh.getNumHashes(); <line3> RandomGenerator random = RandomManager.getRandom(); <line4> int[] counts = new int[1 << numHashes]; <line5> int trials = 100_000; <line6> for (int i = 0; i < trials; i++) { <line7> counts[lsh.getIndexFor(VectorMath.randomVectorF(features, random))]++; <line8> } <line9> IntSummaryStatistics stats = Arrays.stream(counts).summaryStatistics(); <line10> assertEquals(trials, stats.getSum()); <line11> assertLessOrEqual(stats.getMax(), 2 * stats.getMin()); <line12> } <line13> } <line14> 	 <line12>	No
public class A { <line0> @Override <line1> public void processMessage(final ObjectMessage message) { <line2> String correlationUid = null; <line3> String messageType = null; <line4> String organisationIdentification = null; <line5> String deviceIdentification = null; <line6> GetPQValuesRequest getPQValuesRequest = null; <line7> try { <line8> correlationUid = message.getJMSCorrelationID(); <line9> messageType = message.getJMSType(); <line10> organisationIdentification = message.getStringProperty(Constants.ORGANISATION_IDENTIFICATION); <line11> deviceIdentification = message.getStringProperty(Constants.DEVICE_IDENTIFICATION); <line12> if (message.getObject() instanceof GetPQValuesRequest) { <line13> getPQValuesRequest = (GetPQValuesRequest) message.getObject(); <line14> } <line15> } catch (final JMSException e) { <line16> return; <line17> } <line18> try { <line19> final CorrelationIds ids = <line20> new CorrelationIds(organisationIdentification, deviceIdentification, correlationUid); <line21> this.monitoringService.getPQValues(ids, messageType, getPQValuesRequest); <line22> } catch (final Exception e) { <line23> this.handleError( <line24> e, correlationUid, organisationIdentification, deviceIdentification, messageType); <line25> } <line26> } <line27> } <line28> 	 <line25>	No
public class A { <line0> @Override <line1> public CompletableFuture<Void> close() { <line2> final List<CompletableFuture<Void>> futures = <line3> partitions.values().stream().map(RaftPartition::close).collect(Collectors.toList()); <line4> return CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()])) <line5> .thenRun( <line6> () -> { <line7> if (communicationService != null) { <line8> communicationService.unsubscribe(snapshotSubject); <line9> } <line10> }); <line11> } <line12> } <line13> 	 <line10>	Yes
public class A { <line0> void processRegionStateMessage(RegionStateMessage msg) { <line1> if (msg.eventState != null) { <line2> region.recordEventState(msg.getSender(), msg.eventState); <line3> } <line4> if (msg.versionVector != null <line5> && msg.getSender().getVersion().isOlderThan(KnownVersion.GFE_80) <line6> && region.getConcurrencyChecksEnabled()) { <line7> if (internalBeforeSavedReceivedRVV != null <line8> && internalBeforeSavedReceivedRVV.getRegionName().equals(region.getName())) { <line9> internalBeforeSavedReceivedRVV.run(); <line10> } <line11> saveReceivedRVV(msg.versionVector); <line12> if (internalAfterSavedReceivedRVV != null <line13> && internalAfterSavedReceivedRVV.getRegionName().equals(region.getName())) { <line14> internalAfterSavedReceivedRVV.run(); <line15> } <line16> } <line17> } <line18> } <line19> 	 <line18>	No
public class A { <line0> private void closePrewarmDagClient() { <line1> if (prewarmDagClient == null) { <line2> return; <line3> } <line4> try { <line5> prewarmDagClient.close(); <line6> } catch (Exception e) { <line7> } <line8> prewarmDagClient = null; <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> @Override <line1> public void createTable(final TableLayoutDesc tableLayout) throws IOException { <line2> final State state = mState.get(); <line3> Preconditions.checkState( <line4> state == State.OPEN, ""Cannot create table in Kiji instance %s in state %s."", this, state); <line5> final KijiURI tableURI = KijiURI.newBuilder(mURI).withTableName(tableLayout.getName()).build(); <line6> ensureValidationCompatibility(tableLayout); <line7> if (isSecurityEnabled()) { <line8> getSecurityManager().lock(); <line9> try { <line10> createTableUnchecked(tableLayout); <line11> getSecurityManager().applyPermissionsToNewTable(tableURI); <line12> } finally { <line13> getSecurityManager().unlock(); <line14> } <line15> } else { <line16> createTableUnchecked(tableLayout); <line17> } <line18> } <line19> } <line20> "	 <line5>	No
public class A { <line0> private void validateTargetVolumeVpoolWithSourceVolume( <line1> UnManagedVolume unManagedVolume, VirtualArray virtualArray) { <line2> String sourceUnManagedVolumeId = <line3> PropertySetterUtil.extractValueFromStringSet( <line4> SupportedVolumeInformation.REMOTE_MIRROR_SOURCE_VOLUME.toString(), <line5> unManagedVolume.getVolumeInformation()); <line6> String sourceVolumeId = <line7> sourceUnManagedVolumeId.replace( <line8> VolumeIngestionUtil.UNMANAGEDVOLUME, VolumeIngestionUtil.VOLUME); <line9> List<URI> sourceUris = <line10> _dbClient.queryByConstraint( <line11> AlternateIdConstraint.Factory.getVolumeNativeGuidConstraint(sourceVolumeId)); <line12> if (sourceUris.isEmpty()) { <line13> } else { <line14> Volume sourceVolume = _dbClient.queryObject(Volume.class, sourceUris.get(0)); <line15> VirtualPool sourceVPool = <line16> _dbClient.queryObject(VirtualPool.class, sourceVolume.getVirtualPool()); <line17> Map<URI, VpoolRemoteCopyProtectionSettings> settings = <line18> sourceVPool.getRemoteProtectionSettings(sourceVPool, _dbClient); <line19> if (null == settings || settings.isEmpty() || !settings.containsKey(virtualArray.getId())) { <line20> throw IngestionException.exceptions.unmanagedSRDFTargetVolumeVArrayMismatch( <line21> unManagedVolume.getLabel(), sourceVolume.getVirtualArray().toString()); <line22> } <line23> } <line24> } <line25> } <line26> 	 <line10>	No
"public class A { <line0> private void validate(String alarmFileWarn, String alarmFileCritical, String hookFile) <line1> throws Exception { <line2> GetAlarm alarms = <line3> graphql.readAlarms( <line4> new AlarmQuery() <line5> .start(startTime) <line6> .end(now()) <line7> .addTag(""level"", ""WARNING"") <line8> .addTag(""receivers"", ""lisi"")); <line9> LOGGER.info(""alarms query: {}"", alarms); <line10> load(alarmFileWarn).as(AlarmsMatcher.class).verify(alarms); <line11> alarms = <line12> graphql.readAlarms( <line13> new AlarmQuery() <line14> .start(startTime) <line15> .end(now()) <line16> .addTag(""level"", ""CRITICAL"") <line17> .addTag(""receivers"", ""zhangsan"")); <line18> load(alarmFileCritical).as(AlarmsMatcher.class).verify(alarms); <line19> ResponseEntity<HookAlarms> responseEntity = <line20> restTemplate.postForEntity( <line21> ""http://"" + serviceHostPort.host() + "":"" + serviceHostPort.port() + ""/alarm/read"", <line22> null, <line23> HookAlarms.class); <line24> load(hookFile).as(HookAlarmsMatcher.class).verify(responseEntity.getBody()); <line25> } <line26> } <line27> "	 <line15>	No
"public class A { <line0> void updateMissingMembers() { <line1> if (config.getMissingCPMemberAutoRemovalSeconds() == 0 <line2> || !metadataGroupManager.isDiscoveryCompleted() <line3> || (!isStartCompleted() <line4> && getCPPersistenceService().getCPMetadataStore().containsLocalMemberFile())) { <line5> return; <line6> } <line7> Collection<CPMemberInfo> activeMembers = metadataGroupManager.getActiveMembers(); <line8> missingMembers.keySet().retainAll(activeMembers); <line9> ClusterService clusterService = nodeEngine.getClusterService(); <line10> for (CPMemberInfo cpMember : activeMembers) { <line11> if (clusterService.getMember(cpMember.getAddress()) == null) { <line12> if (missingMembers.putIfAbsent(cpMember, Clock.currentTimeMillis()) == null) { <line13> logger.warning( <line14> cpMember <line15> + "" is not present in the cluster. It will be auto-removed after "" <line16> + config.getMissingCPMemberAutoRemovalSeconds() <line17> + "" seconds.""); <line18> } <line19> } else if (missingMembers.remove(cpMember) != null) { <line20> } <line21> } <line22> } <line23> } <line24> "	 <line20>	Yes
public class A { <line0> protected boolean isStagingUseVirtualHostForRemoteSite() { <line1> try { <line2> StagingConfiguration stagingConfiguration = <line3> _configurationProvider.getCompanyConfiguration( <line4> StagingConfiguration.class, CompanyThreadLocal.getCompanyId()); <line5> return stagingConfiguration.stagingUseVirtualHostForRemoteSite(); <line6> } catch (Exception exception) { <line7> } <line8> return false; <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> public static int getCommerceChannelRelsCount( <line1> HttpPrincipal httpPrincipal, <line2> String className, <line3> long classPK, <line4> String classPKField, <line5> String name) { <line6> try { <line7> MethodKey methodKey = <line8> new MethodKey( <line9> CommerceChannelRelServiceUtil.class, <line10> ""getCommerceChannelRelsCount"", <line11> _getCommerceChannelRelsCountParameterTypes12); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, className, classPK, classPKField, name); <line14> Object returnObj = null; <line15> try { <line16> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line17> } catch (Exception exception) { <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return ((Integer) returnObj).intValue(); <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	 <line22>	Yes
public class A { <line0> @Override <line1> public String compare() { <line2> if (filesToCompare.size() >= MAX_FILES_COUNT) { <line3> File file1 = filesToCompare.get(0); <line4> File file2 = filesToCompare.get(1); <line5> filesToCompare.clear(); <line6> try { <line7> setDiffTree(null); <line8> XlsDiff2 x = new XlsDiff2(); <line9> DiffTreeNode diffTree = x.diffFiles(file1, file2); <line10> setDiffTree(diffTree); <line11> defineChangesStatus(diffTree); <line12> } catch (Exception e) { <line13> WebStudioUtils.addErrorMessage(e.getMessage()); <line14> } <line15> } <line16> return null; <line17> } <line18> } <line19> 	 <line5>	No
"public class A { <line0> public static EventSerializer getInstance( <line1> String serializerType, Context context, OutputStream out) { <line2> Preconditions.checkNotNull(serializerType, ""serializer type must not be null""); <line3> EventSerializerType type; <line4> try { <line5> type = EventSerializerType.valueOf(serializerType.toUpperCase(Locale.ENGLISH)); <line6> } catch (IllegalArgumentException e) { <line7> type = EventSerializerType.OTHER; <line8> } <line9> Class<? extends EventSerializer.Builder> builderClass = type.getBuilderClass(); <line10> if (builderClass == null) { <line11> try { <line12> Class c = Class.forName(serializerType); <line13> if (c != null && EventSerializer.Builder.class.isAssignableFrom(c)) { <line14> builderClass = (Class<? extends EventSerializer.Builder>) c; <line15> } else { <line16> String errMessage = <line17> ""Unable to instantiate Builder from "" <line18> + serializerType <line19> + "": does not appear to implement "" <line20> + EventSerializer.Builder.class.getName(); <line21> throw new FlumeException(errMessage); <line22> } <line23> } catch (ClassNotFoundException ex) { <line24> throw new FlumeException(ex); <line25> } <line26> } <line27> EventSerializer.Builder builder; <line28> try { <line29> builder = builderClass.newInstance(); <line30> } catch (InstantiationException ex) { <line31> String errMessage = ""Cannot instantiate builder: "" + serializerType; <line32> logger.error(errMessage, ex); <line33> throw new FlumeException(errMessage, ex); <line34> } catch (IllegalAccessException ex) { <line35> String errMessage = ""Cannot instantiate builder: "" + serializerType; <line36> throw new FlumeException(errMessage, ex); <line37> } <line38> return builder.build(context, out); <line39> } <line40> } <line41> "	 <line7>	Yes
"public class A { <line0> @Override <line1> public FileVirtualPoolBulkRep queryBulkResourceReps(List<URI> ids) { <line2> if (!ids.iterator().hasNext()) { <line3> return new FileVirtualPoolBulkRep(); <line4> } <line5> String shortVdcId = VdcUtil.getVdcId(VirtualArray.class, ids.iterator().next()).toString(); <line6> Iterator<VirtualPool> dbIterator; <line7> if (shortVdcId.equals(VdcUtil.getLocalShortVdcId())) { <line8> dbIterator = _dbClient.queryIterativeObjects(getResourceClass(), ids); <line9> } else { <line10> GeoServiceClient geoClient = _geoHelper.getClient(shortVdcId); <line11> try { <line12> dbIterator = geoClient.queryObjects(getResourceClass(), ids); <line13> } catch (Exception ex) { <line14> throw APIException.internalServerErrors.genericApisvcError( <line15> ""error retrieving remote virtual pool"", ex); <line16> } <line17> } <line18> return new FileVirtualPoolBulkRep( <line19> BulkList.wrapping( <line20> dbIterator, <line21> new mapFileVirtualPoolWithResources(), <line22> new BulkList.VirtualPoolFilter(Type.file))); <line23> } <line24> } <line25> "	 <line14>	Yes
"public class A { <line0> @Override <line1> public void onRepositoryInitialized( <line2> String dataSourceName, <line3> String repositoryName, <line4> String cspaceInstanceId, <line5> ServiceBindingType sbt, <line6> List<Field> fields, <line7> List<Property> properties) <line8> throws Exception { <line9> if (properties == null || properties.isEmpty()) { <line10> logger.warn(CANNOT_PERFORM_TASKS_MESSAGE); <line11> return; <line12> } <line13> String scriptContents; <line14> List<String> scriptNames = getSqlScriptNames(properties); <line15> if (scriptNames == null || scriptNames.isEmpty()) { <line16> return; <line17> } <line18> for (String scriptName : scriptNames) { <line19> String scriptPath = getSqlScriptPath(dataSourceName, repositoryName, scriptName); <line20> if (Tools.isBlank(scriptPath)) { <line21> logger.warn(CANNOT_PERFORM_TASKS_MESSAGE); <line22> continue; <line23> } <line24> scriptContents = getSqlScriptContents(scriptPath); <line25> if (Tools.isBlank(scriptContents)) { <line26> logger.warn(CANNOT_PERFORM_TASKS_MESSAGE); <line27> continue; <line28> } <line29> runScript( <line30> dataSourceName, <line31> repositoryName, <line32> cspaceInstanceId, <line33> scriptContents, <line34> ""resource path "" + scriptPath); <line35> } <line36> List<File> scriptFiles = getSqlScriptFiles(dataSourceName, repositoryName); <line37> Collections.sort( <line38> scriptFiles, <line39> new Comparator<File>() { <line40> @Override <line41> public int compare(File f1, File f2) { <line42> return Collator.getInstance().compare(f1.getName(), f2.getName()); <line43> } <line44> }); <line45> for (File scriptFile : scriptFiles) { <line46> scriptContents = FileTools.readFile(scriptFile); <line47> if (Tools.isBlank(scriptContents)) { <line48> continue; <line49> } <line50> runScript( <line51> dataSourceName, <line52> repositoryName, <line53> cspaceInstanceId, <line54> scriptContents, <line55> ""file "" + scriptFile.getName()); <line56> } <line57> } <line58> } <line59> "	 <line48>	Yes
"public class A { <line0> public List<FileFormatDto> getAll(VitamContext vitamContext) { <line1> final RequestResponse<FileFormatModel> requestResponse; <line2> try { <line3> requestResponse = <line4> vitamFileFormatService.findFileFormats(vitamContext, new Select().getFinalSelect()); <line5> final FileFormatResponseDto fileFormatResponseDto = <line6> objectMapper.treeToValue(requestResponse.toJsonNode(), FileFormatResponseDto.class); <line7> return converter.convertVitamsToDtos(fileFormatResponseDto.getResults()); <line8> } catch (VitamClientException | JsonProcessingException e) { <line9> throw new InternalServerException(""Unable to find fileFormats"", e); <line10> } <line11> } <line12> } <line13> "	 <line5>	Yes
public class A { <line0> private UriComponents createEchoUri(final String scheme) { <line1> final String echoUriStr = CommonConstants.SERVICE_REGISTRY_URI + CommonConstants.ECHO_URI; <line2> return Utilities.createURI( <line3> scheme, <line4> coreSystemRegistrationProperties.getServiceRegistryAddress(), <line5> coreSystemRegistrationProperties.getServiceRegistryPort(), <line6> echoUriStr); <line7> } <line8> } <line9> 	 <line1>	Yes
public class A { <line0> private void extractRestCheckUrl() { <line1> Configuration conf = HadoopUtil.getCurrentConfiguration(); <line2> yarnMasterUrlBase = HadoopConfExtractor.extractYarnMasterUrl(conf); <line3> jobHistoryUrlBase = HadoopConfExtractor.extractJobHistoryUrl(yarnMasterUrlBase, conf); <line4> } <line5> } <line6> 	 <line3>	No
public class A { <line0> public void activate(BundleContext bc) throws Exception { <line1> final String name = this.getClass().getSimpleName(); <line2> url = bc.getProperty(ACTIVEMQ_BROKER_URL_KEY); <line3> if (StringUtils.isBlank(url)) { <line4> url = ACTIVEMQ_DEFAULT_URL; <line5> } <line6> username = bc.getProperty(ACTIVEMQ_BROKER_USERNAME_KEY); <line7> password = bc.getProperty(ACTIVEMQ_BROKER_PASSWORD_KEY); <line8> if (reconnect()) { <line9> } <line10> } <line11> } <line12> 	 <line6>	No
public class A { <line0> public void loadCollection(User user) { <line1> try { <line2> collection = new CollectionController().retrieveLazy(item.getCollection(), user); <line3> } catch (Exception e) { <line4> collection = null; <line5> } <line6> } <line7> } <line8> 	 <line7>	No
"public class A { <line0> private Authorizable createNewAuthorizable( <line1> AcConfiguration acConfiguration, <line2> AuthorizableConfigBean principalConfigBean, <line3> InstallationLogger installLog, <line4> AuthInstallerUserManager userManager, <line5> Session session) <line6> throws AuthorizableExistsException, RepositoryException, AuthorizableCreatorException { <line7> boolean isGroup = principalConfigBean.isGroup(); <line8> String authorizableId = principalConfigBean.getAuthorizableId(); <line9> Authorizable newAuthorizable = null; <line10> if (isGroup) { <line11> newAuthorizable = <line12> createNewGroup( <line13> userManager, <line14> acConfiguration.getAuthorizablesConfig(), <line15> principalConfigBean, <line16> installLog, <line17> session); <line18> } else { <line19> if (StringUtils.isNotEmpty(principalConfigBean.getExternalId())) { <line20> throw new IllegalStateException( <line21> ""External IDs are not supported for users ("" <line22> + principalConfigBean.getAuthorizableId() <line23> + "" is using '"" <line24> + principalConfigBean.getExternalId() <line25> + ""') - use a ootb sync handler to have users automatically created.""); <line26> } <line27> newAuthorizable = <line28> createNewUser( <line29> userManager, <line30> acConfiguration.getAuthorizablesConfig(), <line31> principalConfigBean, <line32> installLog, <line33> session); <line34> } <line35> return newAuthorizable; <line36> } <line37> } <line38> "	 <line13>	No
"public class A { <line0> @Override <line1> public FormatInfo process( <line2> String templatePath, ImageFormat format, String templateName, long processTimeout) { <line3> if (format != null) { <line4> return null; <line5> } <line6> String isoPath = <line7> templatePath + File.separator + templateName + ""."" + ImageFormat.ISO.getFileExtension(); <line8> if (!_storage.exists(isoPath)) { <line9> return null; <line10> } <line11> FormatInfo info = new FormatInfo(); <line12> info.format = ImageFormat.ISO; <line13> info.filename = templateName + ""."" + ImageFormat.ISO.getFileExtension(); <line14> info.size = _storage.getSize(isoPath); <line15> info.virtualSize = info.size; <line16> return info; <line17> } <line18> } <line19> "	 <line7>	No
"public class A { <line0> protected void setRealtimePacketTime(TmPacket tmPacket, int offset) { <line1> if (useLocalGenerationTime) { <line2> tmPacket.setGenerationTime(tmPacket.getReceptionTime()); <line3> tmPacket.setLocalGenTimeFlag(); <line4> return; <line5> } <line6> byte[] packet = tmPacket.getPacket(); <line7> try { <line8> if (timeEpoch == null || timeEpoch == TimeEpochs.NONE) { <line9> long obt = timeDecoder.decodeRaw(packet, offset); <line10> tmPacket.setObt(obt); <line11> tcoService.timestamp(obt, tmPacket); <line12> } else { <line13> long t = timeDecoder.decode(packet, offset); <line14> long gentime = timeEpoch == null ? t : shiftFromEpoch(t); <line15> tmPacket.setGenerationTime(gentime); <line16> if (tcoService != null) { <line17> tcoService.verify(tmPacket); <line18> } <line19> } <line20> } catch (Exception e) { <line21> eventProducer.sendWarning(""Failed to extract time from packet: "" + e); <line22> tmPacket.setInvalid(true); <line23> } <line24> } <line25> } <line26> "	 <line21>	Yes
"public class A { <line0> @Override <line1> public void updateRemoteContext( <line2> String bodyJSON, String orionToken, String fiwareService, String fiwareServicePath) <line3> throws CygnusRuntimeError, CygnusPersistenceError, UnsupportedEncodingException, <line4> CygnusBadAuthorization, JSONException { <line5> String relativeURL = ""/v2/entities""; <line6> ArrayList<Header> headers = getHeaders(orionToken, fiwareService, fiwareServicePath); <line7> JSONObject body; <line8> try { <line9> body = new JSONObject(bodyJSON); <line10> } catch (Exception e) { <line11> throw e; <line12> } <line13> String relativeUrlUpdate = relativeURL + ""/"" + body.get(""id"") + ""/attrs""; <line14> body.remove(""id""); <line15> body.remove(""type""); <line16> body.remove(""isPattern""); <line17> StringEntity entity = new StringEntity(body.toString()); <line18> JsonResponse response = doRequest(""POST"", relativeUrlUpdate, true, headers, entity); <line19> if (response.getStatusCode() == 404) { <line20> JSONObject bodyJsonCreate = new JSONObject(bodyJSON); <line21> bodyJsonCreate.remove(""isPattern""); <line22> entity = new StringEntity(bodyJsonCreate.toString()); <line23> response = doRequest(""POST"", relativeURL, true, headers, entity); <line24> } else if (response.getStatusCode() == 401) { <line25> throw new CygnusBadAuthorization(""Error of authorization.""); <line26> } <line27> if (response.getStatusCode() != 200 <line28> && response.getStatusCode() != 201 <line29> && response.getStatusCode() != 204) { <line30> throw new CygnusPersistenceError( <line31> ""The context could not be updated. HttpFS response: "" <line32> + response.getStatusCode() <line33> + "" "" <line34> + response.getReasonPhrase()); <line35> } <line36> } <line37> } <line38> "	 <line24>	Yes
public class A { <line0> void exerciseEconomicControl(EconomicControlEvent event) { <line1> Tariff tariff = tariffRepo.findTariffById(event.getTariffId()); <line2> if (null == tariff) { <line3> return; <line4> } <line5> List<TariffSubscription> subs = tariffSubscriptionRepo.findSubscriptionsForTariff(tariff); <line6> for (TariffSubscription sub : subs) { <line7> sub.postRatioControl(event.getCurtailmentRatio()); <line8> } <line9> } <line10> } <line11> 	 <line3>	Yes
public class A { <line0> public void init(EmbeddedCacheManager cacheManager) { <line1> this.cacheManager = cacheManager; <line2> cacheManager.addListener(this); <line3> Cache<Address, ClusterNode> nodes = <line4> cacheManager.<Address, ClusterNode>getCache(CLUSTER_NODES_KEY); <line5> nodes.addListener(this); <line6> nodes.put(cacheManager.getAddress(), getThisNode()); <line7> } <line8> } <line9> 	 <line5>	No
"public class A { <line0> @Override <line1> public void handleConfigurationUpdate(Map<String, Object> configurationParameters) { <line2> boolean refresh = true; <line3> Configuration configuration = editConfiguration(); <line4> for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) { <line5> if (configurationParameter.getKey().startsWith(""ntp"")) { <line6> sendNtpUpdate(configurationParameters); <line7> if (configurationParameters.size() == 1) { <line8> refresh = false; <line9> } <line10> } <line11> if (configurationParameter.getKey().startsWith(""action-"")) { <line12> if (configurationParameter.getValue().toString().equals(BUTTON_ACTION_VALUE)) { <line13> if (configurationParameter.getKey().equals(ACTION_CUBE_REBOOT)) { <line14> cubeReboot(); <line15> } <line16> if (configurationParameter.getKey().equals(ACTION_CUBE_RESET)) { <line17> cubeConfigReset(); <line18> refresh = false; <line19> } <line20> } <line21> configuration.put( <line22> configurationParameter.getKey(), BigDecimal.valueOf(BUTTON_NOACTION_VALUE)); <line23> } else { <line24> configuration.put(configurationParameter.getKey(), configurationParameter.getValue()); <line25> } <line26> } <line27> updateConfiguration(configuration); <line28> if (refresh) { <line29> try { <line30> stopAutomaticRefresh(); <line31> } catch (InterruptedException e) { <line32> Thread.currentThread().interrupt(); <line33> } <line34> clearDeviceList(); <line35> socketClose(); <line36> initialize(); <line37> } <line38> } <line39> } <line40> "	 <line29>	No
"public class A { <line0> public String fetchSystemConfiguration(final String keyname) { <line1> String query = ""SELECT value FROM cf_SystemConfiguration WHERE keyname =\"""" + keyname + ""\""""; <line2> try { <line3> return rdsepository.queryForString(query); <line4> } catch (Exception exception) { <line5> return StringUtils.EMPTY; <line6> } <line7> } <line8> } <line9> "	 <line1>	No
public class A { <line0> public void task() throws Exception { <line1> FromDefinition from = route.getInput(); <line2> from.setUri(null); <line3> from.setEndpoint(endpoint); <line4> } <line5> } <line6> 	 <line1>	No
public class A { <line0> public static String getUptime() { <line1> Date now = new Date(); <line2> Platform platform = Platform.getLocalInstance(); <line3> String uptime = getDiffTime(now.getTime() - platform.getStartTime().getTime()); <line4> return uptime; <line5> } <line6> } <line7> 	 <line4>	Yes
"public class A { <line0> private long mutate(Mutator m, String key, long by, long def, int exp) { <line1> final AtomicLong rv = new AtomicLong(); <line2> final CountDownLatch latch = new CountDownLatch(1); <line3> mconn.enqueueOperation( <line4> key, <line5> opFact.mutate( <line6> m, <line7> key, <line8> by, <line9> def, <line10> exp, <line11> new OperationCallback() { <line12> @Override <line13> public void receivedStatus(OperationStatus s) { <line14> rv.set(new Long(s.isSuccess() ? s.getMessage() : ""-1"")); <line15> } <line16>  <line17> @Override <line18> public void complete() { <line19> latch.countDown(); <line20> } <line21> })); <line22> try { <line23> if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { <line24> throw new OperationTimeoutException( <line25> ""Mutate operation timed out,"" + ""unable to modify counter ["" + key + ']'); <line26> } <line27> } catch (InterruptedException e) { <line28> throw new RuntimeException(""Interrupted"", e); <line29> } <line30> return rv.get(); <line31> } <line32> } <line33> "	 <line7>	No
public class A { <line0> @Override <line1> public boolean isDisabled(Object object) { <line2> DDMStructure structure = (DDMStructure) object; <line3> PermissionChecker permissionChecker = PermissionThreadLocal.getPermissionChecker(); <line4> try { <line5> if (!DDMStructurePermission.contains(permissionChecker, structure, ActionKeys.DELETE)) { <line6> return true; <line7> } <line8> } catch (Exception exception) { <line9> } <line10> return super.isDisabled(object); <line11> } <line12> } <line13> 	 <line4>	No
"public class A { <line0> protected void addOnEntryActionToServiceCheckState(final Flow flow) { <line1> final DecisionState state = (DecisionState) flow.getState(STATE_DEFINITION_ID_SERVICE_CHECK); <line2> final EvaluateAction action = createEvaluateAction(""removeHostnameServiceInContextAction""); <line3> state.getEntryActionList().add(action); <line4> } <line5> } <line6> "	 <line5>	No
"public class A { <line0> @Test <line1> public void test_01_DUP_fusion() { <line2> String genome = ""testHg19Chr4""; <line3> String vcf = path(""test_fusion_FGFR3-TACC3.vcf""); <line4> String args[] = {""-noLog"", ""-ud"", ""0"", genome, vcf}; <line5> SnpEff snpEff = new SnpEff(args); <line6> snpEff.setVerbose(verbose); <line7> snpEff.setSupressOutput(!verbose); <line8> snpEff.setDebug(debug); <line9> SnpEffCmdEff seff = (SnpEffCmdEff) snpEff.cmd(); <line10> boolean checked = false; <line11> List<VcfEntry> vcfEntries = seff.run(true); <line12> for (VcfEntry ve : vcfEntries) { <line13> for (VcfEffect veff : ve.getVcfEffects()) { <line14> if (veff.getEffectType() == EffectType.GENE_FUSION) { <line15> Assert.assertEquals(EffectImpact.HIGH, veff.getImpact()); <line16> Assert.assertEquals(veff.getGeneId(), ""FGFR3&TACC3""); <line17> checked = true; <line18> } <line19> } <line20> } <line21> Assert.assertTrue(""No translocation found"", checked); <line22> } <line23> } <line24> "	 <line22>	No
"public class A { <line0> @Test(timeOut = 10_000) <line1> public void runTestDeleteFamilyRowLevelCA(ITestContext context) throws Exception { <line2> TransactionManager tm = newTransactionManager(context); <line3> TTable tt = new TTable(connection, TEST_TABLE); <line4> ((HBaseTransactionManager) tm).setConflictDetectionLevel(ConflictDetectionLevel.ROW); <line5> Transaction t1 = tm.begin(); <line6> int rowsWritten = 10; <line7> FamCol famColA = new FamCol(famA, colA); <line8> FamCol famColB = new FamCol(famB, colB); <line9> writeRows(tt, t1, rowsWritten, famColA, famColB); <line10> tm.commit(t1); <line11> Transaction t2 = tm.begin(); <line12> Delete d = new Delete(modrow); <line13> d.addFamily(famA); <line14> tt.delete(t2, d); <line15> Transaction tscan = tm.begin(); <line16> ResultScanner rs = tt.getScanner(tscan, new Scan()); <line17> Map<FamCol, Integer> count = countColsInRows(rs, famColA, famColB); <line18> assertEquals( <line19> (int) count.get(famColA), rowsWritten, ""ColA count should be equal to rowsWritten""); <line20> assertEquals( <line21> (int) count.get(famColB), rowsWritten, ""ColB count should be equal to rowsWritten""); <line22> if (getClient(context).isLowLatency()) { <line23> return; <line24> } <line25> tm.commit(t2); <line26> tscan = tm.begin(); <line27> rs = tt.getScanner(tscan, new Scan()); <line28> count = countColsInRows(rs, famColA, famColB); <line29> assertEquals( <line30> (int) count.get(famColA), <line31> (rowsWritten - 1), <line32> ""ColA count should be equal to rowsWritten - 1""); <line33> assertEquals( <line34> (int) count.get(famColB), rowsWritten, ""ColB count should be equal to rowsWritten""); <line35> ((HBaseTransactionManager) tm).setConflictDetectionLevel(ConflictDetectionLevel.CELL); <line36> } <line37> } <line38> "	 <line6>	Yes
public class A { <line0> void remove(final String id) { <line1> EntityManager em = daoManager.getEntityManagerFromFactory(); <line2> try { <line3> daoManager.startTransaction(em); <line4> UserTokenEntity item = em.find(UserTokenEntity.class, id); <line5> em.remove(item); <line6> daoManager.commitTransaction(em); <line7> } catch (Exception e) { <line8> daoManager.rollBackTransaction(em); <line9> } finally { <line10> daoManager.closeEntityManager(em); <line11> } <line12> } <line13> } <line14> 	 <line1>	No
"public class A { <line0> private HttpServer getHttpServer(HiveConf conf) throws IOException { <line1> String baseURI = <line2> conf.get(LensConfConstants.SERVER_BASE_URL, LensConfConstants.DEFAULT_SERVER_BASE_URL); <line3> if (Boolean.valueOf( <line4> conf.get( <line5> LensConfConstants.SSL_ENABLED, <line6> String.valueOf(LensConfConstants.DEFAULT_SSL_ENABLED_VALUE)))) { <line7> SSLContextConfigurator sslCon = new SSLContextConfigurator(); <line8> String keyStoreFile = conf.get(LensConfConstants.SSL_KEYSTORE_FILE_PATH); <line9> String sslPassword = conf.get(LensConfConstants.SSL_KEYSTORE_PASSWORD); <line10> if (keyStoreFile == null || keyStoreFile.isEmpty()) { <line11> throw new IOException( <line12> String.format( <line13> ""SSL is enabled but cert file is missing, "" <line14> + ""%s should be initialize with valid cert file path."", <line15> LensConfConstants.SSL_KEYSTORE_FILE_PATH)); <line16> } <line17> sslCon.setKeyStoreFile(keyStoreFile); <line18> sslCon.setKeyStorePass(sslPassword); <line19> return GrizzlyHttpServerFactory.createHttpServer( <line20> UriBuilder.fromUri(baseURI).build(), <line21> getApp(), <line22> true, <line23> new SSLEngineConfigurator(sslCon).setClientMode(false).setNeedClientAuth(false)); <line24> } else { <line25> return GrizzlyHttpServerFactory.createHttpServer( <line26> UriBuilder.fromUri(baseURI).build(), getApp(), false); <line27> } <line28> } <line29> } <line30> "	 <line25>	Yes
public class A { <line0> @Override <line1> public void setProcessor(Processor newProcessor) throws ProcessorException { <line2> Processor oldProcessor = getProcessor(); <line3> super.setProcessor(newProcessor); <line4> for (WebSocketResource resource : resources) { <line5> if (oldProcessor != null) { <line6> resource.unselectProcessor(); <line7> } <line8> if (newProcessor != null) { <line9> resource.selectProcessor(newProcessor); <line10> } <line11> } <line12> } <line13> } <line14> 	 <line13>	No
public class A { <line0> @Override <line1> public synchronized void stop() throws KrbException { <line2> super.stop(); <line3> try { <line4> krb5Conf.deleteKrb5conf(); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> 	 <line8>	No
public class A { <line0> private long readLongInitParameter( <line1> final ServletContext c, final String paramName, final long defaultValue) { <line2> long val = -1; <line3> final String valStr = c.getInitParameter(paramName); <line4> if (valStr != null) { <line5> try { <line6> val = Long.parseLong(valStr); <line7> } catch (final NumberFormatException exc) { <line8> val = -1; <line9> } <line10> } <line11> if (val < 0) { <line12> val = defaultValue; <line13> } <line14> return val; <line15> } <line16> } <line17> 	 <line6>	No
public class A { <line0> public void stop() { <line1> try { <line2> DataOutput out = getWriter(); <line3> if (out != null) { <line4> flushCurrent(); <line5> for (int i = 0; i < MAX_RETRY_ATTEMPTS; i++) { <line6> if (isWriteInProgress()) { <line7> try { <line8> TimeUnit.SECONDS.sleep(i); <line9> } catch (InterruptedException e) { <line10> break; <line11> } <line12> continue; <line13> } <line14> fileLockedReadWrite.close(); <line15> currentIndexRecord.setStatusPending(); <line16> indexFileManager.updateIndex(currentIndexRecord); <line17> break; <line18> } <line19> } <line20> } catch (FileNotFoundException e) { <line21> } catch (IOException exception) { <line22> } catch (Exception exception) { <line23> } <line24> } <line25> } <line26> 	 <line14>	Yes
public class A { <line0> private CswRecordCollection queryCsw(GetRecordsType request) throws CswException { <line1> if (LOGGER.isDebugEnabled()) { <line2> try { <line3> Writer writer = new StringWriter(); <line4> try { <line5> Marshaller marshaller = CswQueryFactory.getJaxBContext().createMarshaller(); <line6> marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE); <line7> JAXBElement<GetRecordsType> jaxbElement = new ObjectFactory().createGetRecords(request); <line8> marshaller.marshal(jaxbElement, writer); <line9> } catch (JAXBException e) { <line10> } <line11> } catch (Exception e) { <line12> } <line13> } <line14> QueryType query = (QueryType) request.getAbstractQuery().getValue(); <line15> CswRecordCollection response = new CswRecordCollection(); <line16> response.setRequest(request); <line17> response.setOutputSchema(request.getOutputSchema()); <line18> response.setMimeType(request.getOutputFormat()); <line19> response.setElementName(query.getElementName()); <line20> response.setElementSetType( <line21> (query.getElementSetName() != null) ? query.getElementSetName().getValue() : null); <line22> response.setResultType( <line23> (ResultType) ObjectUtils.defaultIfNull(request.getResultType(), ResultType.HITS)); <line24> if (ResultType.HITS.equals(request.getResultType()) <line25> || ResultType.RESULTS.equals(request.getResultType())) { <line26> QueryRequest queryRequest = queryFactory.getQuery(request); <line27> try { <line28> queryRequest = queryFactory.updateQueryRequestTags(queryRequest, request.getOutputSchema()); <line29> AtomicLong hitCount = new AtomicLong(0); <line30> QueryFunction qf = <line31> qr -> { <line32> SourceResponse sr = framework.query(qr); <line33> hitCount.compareAndSet(0, sr.getHits()); <line34> return sr; <line35> }; <line36> ResultIterable results = <line37> ResultIterable.resultIterable(qf, queryRequest, request.getMaxRecords().intValue()); <line38> List<Result> resultList = results.stream().collect(Collectors.toList()); <line39> long totalHits = hitCount.get(); <line40> totalHits = totalHits != 0 ? totalHits : resultList.size(); <line41> QueryResponse queryResponse = new QueryResponseImpl(queryRequest, resultList, totalHits); <line42> response.setSourceResponse(queryResponse); <line43> } catch (UnsupportedQueryException | CatalogQueryException e) { <line44> throw new CswException(e); <line45> } <line46> } <line47> return response; <line48> } <line49> } <line50> 	 <line29>	Yes
"public class A { <line0> public static void loadConfig(InputStream input, Map<Object, Object> properties) { <line1> try { <line2> DocumentBuilderFactory xmlDocumentBuilderFactory = DocumentBuilderFactory.newInstance(); <line3> xmlDocumentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true); <line4> xmlDocumentBuilderFactory.setFeature( <line5> ""http://xml.org/sax/features/external-general-entities"", false); <line6> xmlDocumentBuilderFactory.setFeature( <line7> ""http://xml.org/sax/features/external-parameter-entities"", false); <line8> xmlDocumentBuilderFactory.setIgnoringComments(true); <line9> xmlDocumentBuilderFactory.setNamespaceAware(true); <line10> DocumentBuilder xmlDocumentBuilder = xmlDocumentBuilderFactory.newDocumentBuilder(); <line11> Document xmlDocument = xmlDocumentBuilder.parse(input); <line12> xmlDocument.getDocumentElement().normalize(); <line13> NodeList nList = xmlDocument.getElementsByTagName(XMLCONFIG_PROPERTY_TAGNAME); <line14> for (int temp = 0; temp < nList.getLength(); temp++) { <line15> Node nNode = nList.item(temp); <line16> if (nNode.getNodeType() == Node.ELEMENT_NODE) { <line17> Element eElement = (Element) nNode; <line18> String propertyName = """"; <line19> String propertyValue = """"; <line20> if (eElement.getElementsByTagName(XMLCONFIG_NAME_TAGNAME).item(0) != null) { <line21> propertyName = <line22> eElement <line23> .getElementsByTagName(XMLCONFIG_NAME_TAGNAME) <line24> .item(0) <line25> .getTextContent() <line26> .trim(); <line27> } <line28> if (eElement.getElementsByTagName(XMLCONFIG_VALUE_TAGNAME).item(0) != null) { <line29> propertyValue = <line30> eElement <line31> .getElementsByTagName(XMLCONFIG_VALUE_TAGNAME) <line32> .item(0) <line33> .getTextContent() <line34> .trim(); <line35> } <line36> if (properties.get(propertyName) != null) { <line37> properties.remove(propertyName); <line38> } <line39> properties.put(propertyName, propertyValue); <line40> } <line41> } <line42> } catch (Exception e) { <line43> } <line44> } <line45> } <line46> "	 <line43>	Yes
public class A { <line0> private void prepareServerNameType(ServerNamePair pair) { <line1> pair.setServerNameType(pair.getServerNameTypeConfig()); <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public List<MediaPackageElement> distributeSync( <line2> String channelId, <line3> MediaPackage mediapackage, <line4> Set<String> elementIds, <line5> boolean checkAvailability) <line6> throws DistributionException { <line7> final HttpPost req = <line8> post( <line9> ""/distributesync"", <line10> param(PARAM_CHANNEL_ID, channelId), <line11> param(PARAM_MEDIAPACKAGE, MediaPackageParser.getAsXml(mediapackage)), <line12> param(PARAM_ELEMENT_ID, gson.toJson(elementIds)), <line13> param(PARAM_CHECK_AVAILABILITY, Boolean.toString(checkAvailability))); <line14> for (List<MediaPackageElement> elements : join(runRequest(req, elementsFromHttpResponse))) { <line15> return elements; <line16> } <line17> throw new DistributionException( <line18> format( <line19> ""Unable to distribute '%s' elements of "" <line20> + ""mediapackage '%s' using a remote destribution service proxy"", <line21> elementIds.size(), mediapackage.getIdentifier().toString())); <line22> } <line23> } <line24> "	 <line7>	Yes
"public class A { <line0> @Override <line1> @Transactional <line2> public <MT extends IBaseMetaType> MT metaDeleteOperation( <line3> IIdType theResourceId, MT theMetaDel, RequestDetails theRequest) { <line4> TransactionDetails transactionDetails = new TransactionDetails(); <line5> if (theRequest != null) { <line6> ActionRequestDetails requestDetails = <line7> new ActionRequestDetails(theRequest, getResourceName(), theResourceId); <line8> notifyInterceptors(RestOperationTypeEnum.META_DELETE, requestDetails); <line9> } <line10> StopWatch w = new StopWatch(); <line11> BaseHasResource entity = readEntity(theResourceId, theRequest); <line12> if (entity == null) { <line13> throw new ResourceNotFoundException(theResourceId); <line14> } <line15> ResourceTable latestVersion = readEntityLatestVersion(theResourceId, theRequest); <line16> if (latestVersion.getVersion() != entity.getVersion()) { <line17> doMetaDelete(theMetaDel, entity, theRequest, transactionDetails); <line18> } else { <line19> doMetaDelete(theMetaDel, latestVersion, theRequest, transactionDetails); <line20> ResourceHistoryTable history = <line21> myResourceHistoryTableDao.findForIdAndVersionAndFetchProvenance( <line22> entity.getId(), entity.getVersion()); <line23> doMetaDelete(theMetaDel, history, theRequest, transactionDetails); <line24> } <line25> @SuppressWarnings(""unchecked"") <line26> MT retVal = (MT) metaGetOperation(theMetaDel.getClass(), theResourceId, theRequest); <line27> return retVal; <line28> } <line29> } <line30> "	 <line13>	No
public class A { <line0> @Override <line1> public final synchronized void stop() { <line2> Logging.withPrefix( <line3> getName(), <line4> new Runnable() { <line5> @Override <line6> public void run() { <line7> setStatus(STOP_PENDING); <line8> onStop(); <line9> setStatus(STOPPED); <line10> } <line11> }); <line12> } <line13> } <line14> 	 <line0>	No
"public class A { <line0> @Test <line1> public void testTheBasics() throws IOException { <line2> JAXBConfigImpl config = getConfig(); <line3> config.setSystemOverride(true); <line4> Assert.assertTrue(config.isSystemOverride()); <line5> config.putProperty(""joe"", ""blow""); <line6> Properties p = config.getProperties(); <line7> Map<String, Object> objects = config.getObjects(); <line8> Assert.assertEquals(""Bill"", p.getProperty(""name"")); <line9> Assert.assertEquals(""Bill"", config.getProperty(""name"")); <line10> Assert.assertTrue(objects.size() == 0); <line11> Assert.assertNull(config.getObject(""whatever"")); <line12> config.putConfig(new JAXBConfigImpl()); <line13> config.putObject(""truck"", ""chevy""); <line14> Assert.assertEquals(""chevy"", (String) config.getObject(""truck"")); <line15> config.removeObject(""truck""); <line16> Assert.assertNull(config.getObject(""truck"")); <line17> config.putProperty(""truck"", ""chevy""); <line18> Assert.assertEquals(""chevy"", config.getProperty(""truck"")); <line19> config.removeProperty(""truck""); <line20> Assert.assertNull(config.getProperty(""truck"")); <line21> Properties newProperties = new Properties(); <line22> newProperties.setProperty(""hello"", ""world""); <line23> config.putProperties(null); <line24> config.putProperties(new Properties()); <line25> config.putProperties(newProperties); <line26> String path = config.getProperty(""path""); <line27> Assert.assertEquals(""/usr/bin;/usr/local/bin;"", path); <line28> } <line29> } <line30> "	 <line28>	Yes
public class A { <line0> public void updateDoorbellChannel(long timestamp) { <line1> DoorbirdImage dbImage = api.downloadCurrentImage(); <line2> if (dbImage != null) { <line3> RawType image = dbImage.getImage(); <line4> updateState(CHANNEL_DOORBELL_IMAGE, image != null ? image : UnDefType.UNDEF); <line5> updateState(CHANNEL_DOORBELL_TIMESTAMP, getLocalDateTimeType(dbImage.getTimestamp())); <line6> } <line7> triggerChannel(CHANNEL_DOORBELL, CommonTriggerEvents.PRESSED); <line8> startDoorbellOffJob(); <line9> updateDoorbellMontage(); <line10> } <line11> } <line12> 	 <line1>	Yes
public class A { <line0> @Override <line1> public String toString() { <line2> try { <line3> return toString(getCharacterEncoding()); <line4> } catch (UnsupportedEncodingException unsupportedEncodingException) { <line5> } <line6> return StringPool.BLANK; <line7> } <line8> } <line9> 	 <line6>	No
"public class A { <line0> @Test(timeout = EXPECTED_RUNTIME) <line1> public void runLoopTest() throws InterruptedException { <line2> final int pollCount = 5; <line3> final int expectedInterval = 5000; <line4> JobSchedulerService schedulerService = springResource.getBean(JobSchedulerService.class); <line5> final long interval = schedulerService.getInterval(); <line6> final int numberOfWorkers = schedulerService.getWorkerSize(); <line7> final int expectedExecutions = numberOfWorkers * pollCount; <line8> assertEquals( <line9> ""Interval must be set to "" + expectedInterval + "" for test to work properly"", <line10> expectedInterval, <line11> interval); <line12> CountdownLatchJob counterJob = springResource.getBean(CountdownLatchJob.class); <line13> counterJob.setLatch(expectedExecutions); <line14> getJobListener().setExpected(expectedExecutions); <line15> long fireTime = System.currentTimeMillis(); <line16> for (int i = 0; i < pollCount; i++) { <line17> for (int j = 0; j < numberOfWorkers; j++) { <line18> scheduler.createJob(""countdownLatch"", fireTime, new JobData()); <line19> } <line20> fireTime += expectedInterval * 2; <line21> } <line22> boolean waited = counterJob.waitForCount(EXPECTED_RUNTIME, TimeUnit.MILLISECONDS); <line23> assertTrue(""Ran"" + getCount() + "" number of jobs"", waited); <line24> while (!getJobListener().blockTilDone(EXPECTED_RUNTIME)) { <line25> } <line26> } <line27> } <line28> "	 <line25>	Yes
"public class A { <line0> public void updateStatusLabel() { <line1> boolean executeable = false; <line2> if (_datastore == null) { <line3> setStatusLabelText(""Welcome to DataCleaner "" + Version.getDistributionVersion()); <line4> _statusLabel.setIcon( <line5> imageManager.getImageIcon(IconUtils.APPLICATION_ICON, IconUtils.ICON_SIZE_SMALL)); <line6> } else { <line7> if (!_analysisJobBuilder.getSourceColumns().isEmpty()) { <line8> executeable = true; <line9> } <line10> try { <line11> if (_analysisJobBuilder.isConfigured(true)) { <line12> setStatusLabelText(""Job is correctly configured""); <line13> setStatusLabelValid(); <line14> } else { <line15> setStatusLabelText(""Job is not correctly configured""); <line16> setStatusLabelWarning(); <line17> } <line18> } catch (final Exception ex) { <line19> executeable = false; <line20> final String errorMessage; <line21> if (ex instanceof UnconfiguredConfiguredPropertyException) { <line22> final UnconfiguredConfiguredPropertyException unconfiguredConfiguredPropertyException = <line23> (UnconfiguredConfiguredPropertyException) ex; <line24> final ConfiguredPropertyDescriptor configuredProperty = <line25> unconfiguredConfiguredPropertyException.getConfiguredProperty(); <line26> final ComponentBuilder componentBuilder = <line27> unconfiguredConfiguredPropertyException.getComponentBuilder(); <line28> errorMessage = <line29> ""Property '"" <line30> + configuredProperty.getName() <line31> + ""' in "" <line32> + LabelUtils.getLabel(componentBuilder) <line33> + "" is not set!""; <line34> } else if (ex instanceof ComponentValidationException) { <line35> final ComponentValidationException componentValidationException = <line36> (ComponentValidationException) ex; <line37> errorMessage = <line38> componentValidationException.getComponentDescriptor().getDisplayName() <line39> + "" validation failed: "" <line40> + ex.getMessage(); <line41> } else { <line42> errorMessage = ex.getMessage(); <line43> } <line44> setStatusLabelText(""Job error status: "" + errorMessage); <line45> setStatusLabelError(); <line46> } <line47> } <line48> _executeButton.setEnabled(executeable); <line49> } <line50> } <line51> "	 <line2>	No
public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent ev) { <line2> Document document = getActionFocusSelector().getActiveDocument(); <line3> if (document == null) { <line4> return; <line5> } <line6> if ((document instanceof SignalDocument) <line7> || (document instanceof MonitorSignalDocument) <line8> || (document instanceof BookDocument)) { <line9> actionFocusManager.setActiveDocument(document); <line10> } else if (document instanceof TagDocument) { <line11> actionFocusManager.setActiveDocument(((TagDocument) document).getParent()); <line12> } <line13> } <line14> } <line15> 	 <line2>	Yes
public class A { <line0> public boolean isFirstCustomization() { <line1> try { <line2> return (WebloggerFactory.getWeblogger() <line3> .getWeblogManager() <line4> .getTemplateByAction(getActionWeblog(), ComponentType.WEBLOG) <line5> == null); <line6> } catch (WebloggerException ex) { <line7> } <line8> return false; <line9> } <line10> } <line11> 	 <line5>	No
public class A { <line0> private static void checkConnection(String dbFile) { <line1> try { <line2> Connection connection = connections.get(dbFile); <line3> if (connection.isClosed()) initializeConnection(dbFile); <line4> } catch (SQLException e) { <line5> throw new RuntimeException(e); <line6> } <line7> } <line8> } <line9> 	 <line4>	No
public class A { <line0> public static Map<String, String> parseReplicas(Optional<String> json) { <line1> try { <line2> return json.isPresent() ? MAP_READER.readValue(json.get()) : Collections.emptyMap(); <line3> } catch (IOException e) { <line4> throw new IllegalArgumentException(e); <line5> } <line6> } <line7> } <line8> 	 <line0>	No
"public class A { <line0> public String sourceCode() { <line1> if (sourceCode != null) return sourceCode; <line2> StringWriter writer = new StringWriter(); <line3> try { <line4> Decompiler decompiler = new Decompiler(); <line5> decompiler.setClassPath(cp); <line6> decompiler.decompile(classInfo().getName(), writer, null); <line7> } catch (IOException ex) { <line8> log.error(ex.toString()); <line9> } catch (jode.AssertError ex) { <line10> return ex.toString() <line11> + "" occurred. \n\n"" <line12> + ""Please check if you have all necessary jar and class files \n"" <line13> + ""added to ClassPaths property in the Localizable.strings file.""; <line14> } <line15> sourceCode = writer.toString(); <line16> try { <line17> Class JavaCCtoHTML = Class.forName(""JavaCCtoHTML""); <line18> NSSelector prettyString = new NSSelector(""prettyString"", new Class[] {String.class}); <line19> prettyString.invoke(JavaCCtoHTML, sourceCode); <line20> } catch (Exception ex) { <line21> } <line22> sourceCode = StringUtils.replace(sourceCode, ""\n\n"", ""<br>""); <line23> return sourceCode; <line24> } <line25> } <line26> "	 <line14>	No
public class A { <line0> @Override <line1> protected void shutDown() throws Exception { <line2> eventBus.unregister(this); <line3> for (IOState<MessageInput> state : inputRegistry.getRunningInputs()) { <line4> MessageInput input = state.getStoppable(); <line5> Stopwatch s = Stopwatch.createStarted(); <line6> try { <line7> input.stop(); <line8> } catch (Exception e) { <line9> } finally { <line10> s.stop(); <line11> } <line12> } <line13> } <line14> } <line15> 	 <line2>	Yes
public class A { <line0> private void randomSleep() { <line1> long delay = random.nextInt(100); <line2> try { <line3> Thread.sleep(delay); <line4> } catch (InterruptedException e) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public AuthorizationResult checkAuthorization( <line2> final Authorizer authorizer, <line3> final RequestAction action, <line4> final NiFiUser user, <line5> final Map<String, String> resourceContext) { <line6> final Resource requestResource = wrappedAuthorizable.getRequestedResource(); <line7> if (LOGGER.isDebugEnabled()) { <line8> } <line9> final Boolean isPublicAccessAllowed = publicResourceCheck.apply(requestResource, action); <line10> if (isPublicAccessAllowed) { <line11> if (LOGGER.isDebugEnabled()) { <line12> } <line13> return AuthorizationResult.approved(); <line14> } <line15> NiFiUser proxyUser = user.getChain(); <line16> while (proxyUser != null) { <line17> if (LOGGER.isDebugEnabled()) { <line18> } <line19> final AuthorizationResult proxyAuthorizationResult = <line20> proxyAuthorizable.checkAuthorization(authorizer, action, proxyUser); <line21> if (proxyAuthorizationResult.getResult() == AuthorizationResult.Result.Denied) { <line22> final String deniedMessage = <line23> String.format( <line24> ""Untrusted proxy [%s] for %s operation."", <line25> proxyUser.getIdentity(), action.toString()); <line26> return AuthorizationResult.denied(deniedMessage); <line27> } <line28> proxyUser = proxyUser.getChain(); <line29> } <line30> return wrappedAuthorizable.checkAuthorization(authorizer, action, user, resourceContext); <line31> } <line32> } <line33> "	 <line15>	No
public class A { <line0> public static void deleteCPMeasurementUnit(long cpMeasurementUnitId) throws RemoteException { <line1> try { <line2> CPMeasurementUnitServiceUtil.deleteCPMeasurementUnit(cpMeasurementUnitId); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> @Override <line1> public void updateStatus( <line2> String topic, <line3> String app, <line4> Long[] messageIds, <line5> RetryStatus status, <line6> long updateTime, <line7> int updateBy) <line8> throws Exception { <line9> int update = <line10> DaoUtil.update( <line11> dataSource, <line12> Lists.newArrayList(messageIds), <line13> UPDATE_SQL, <line14> (DaoUtil.UpdateCallback<Long>) <line15> (statement, target) -> { <line16> statement.setShort(1, status.getValue()); <line17> statement.setTimestamp(2, new Timestamp(updateTime)); <line18> statement.setInt(3, updateBy); <line19> statement.setString(4, topic); <line20> statement.setLong(5, target); <line21> }); <line22> if (update > 0) { <line23> } else { <line24> } <line25> } <line26> } <line27> 	 <line24>	Yes
public class A { <line0> private List<SpiCardAccountDetails> getSpiCardAccountDetails( <line1> @NotNull SpiAccountConsent accountConsent, byte[] aspspConsentData) { <line2> List<SpiCardAccountDetails> accountDetailsList; <line3> if (isGlobalConsent(accountConsent.getAccess()) <line4> || isAllAvailableAccountsConsent(accountConsent)) { <line5> accountDetailsList = getAccountDetailsByConsentId(aspspConsentData); <line6> } else { <line7> accountDetailsList = getAccountDetailsFromReferences(accountConsent, aspspConsentData); <line8> } <line9> return accountDetailsList; <line10> } <line11> } <line12> 	 <line5>	Yes
"public class A { <line0> static Collection<Path> toMappings( <line1> File contractFile, Collection<Contract> contracts, File mappingsFolder) { <line2> StubGeneratorProvider provider = new StubGeneratorProvider(); <line3> Collection<StubGenerator> stubGenerators = <line4> provider.allOrDefault(new DslToWireMockClientConverter()); <line5> if (log.isDebugEnabled()) { <line6> } <line7> Collection<Path> mappings = new LinkedList<>(); <line8> for (StubGenerator stubGenerator : stubGenerators) { <line9> Map<Contract, String> map = <line10> stubGenerator.convertContents( <line11> contractFile.getName(), <line12> new ContractMetadata( <line13> contractFile.toPath(), false, contracts.size(), null, contracts)); <line14> for (Map.Entry<Contract, String> entry : map.entrySet()) { <line15> String value = entry.getValue(); <line16> File mapping = <line17> new File( <line18> mappingsFolder, <line19> StringUtils.stripFilenameExtension(contractFile.getName()) <line20> + ""_"" <line21> + Math.abs(entry.getKey().hashCode()) <line22> + stubGenerator.fileExtension()); <line23> mappings.add(storeFile(mapping.toPath(), value.getBytes())); <line24> } <line25> } <line26> return mappings; <line27> } <line28> } <line29> "	 <line6>	Yes
"public class A { <line0> public static String getSyncDLObjectUpdate( <line1> HttpPrincipal httpPrincipal, long repositoryId, long parentFolderId, long lastAccessTime) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SyncDLObjectServiceUtil.class, <line7> ""getSyncDLObjectUpdate"", <line8> _getSyncDLObjectUpdateParameterTypes18); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, repositoryId, parentFolderId, lastAccessTime); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (String) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	 <line15>	No
"public class A { <line0> @Override <line1> public void addSpecificQuery(final SpecificQueryDefinition specificQuery) <line2> throws JargonException, DuplicateDataException { <line3> checkSupportForSpecificQuery(); <line4> GeneralAdminInpForSQ queryPI; <line5> if (specificQuery == null) { <line6> throw new IllegalArgumentException( <line7> ""cannot create specific query with null SpecificQueryDefinition object""); <line8> } <line9> queryPI = GeneralAdminInpForSQ.instanceForAddSpecificQuery(specificQuery); <line10> try { <line11> getIRODSProtocol().irodsFunction(queryPI); <line12> } catch (InvalidArgumentException e) { <line13> if (e.getMessage().indexOf(""Alias is not unique"") != -1) { <line14> throw new DuplicateDataException(e.getMessage()); <line15> } else { <line16> throw e; <line17> } <line18> } <line19> } <line20> } <line21> "	 <line9>	Yes
"public class A { <line0> @Test <line1> public void testManagedOptionMasking() throws BackendException { <line2> Duration customCommitTime = Duration.ofMillis(456L); <line3> Preconditions.checkState(ALLOW_STALE_CONFIG.getDefaultValue()); <line4> Preconditions.checkState(ALLOW_STALE_CONFIG.getType().equals(ConfigOption.Type.MASKABLE)); <line5> Preconditions.checkState(!customCommitTime.equals(MAX_COMMIT_TIME.getDefaultValue())); <line6> close(); <line7> WriteConfiguration wc = getConfiguration(); <line8> wc.set(ConfigElement.getPath(ALLOW_STALE_CONFIG), false); <line9> wc.set(ConfigElement.getPath(MAX_COMMIT_TIME), customCommitTime); <line10> try { <line11> graph = (StandardJanusGraph) JanusGraphFactory.open(wc); <line12> fail(""Masking managed config options should be disabled in this configuration""); <line13> } catch (JanusGraphConfigurationException e) { <line14> assertTrue(e.getMessage().contains(ConfigElement.getPath(MAX_COMMIT_TIME))); <line15> } <line16> close(); <line17> wc = getConfiguration(); <line18> wc.set(ConfigElement.getPath(ALLOW_STALE_CONFIG), true); <line19> wc.set(ConfigElement.getPath(MAX_COMMIT_TIME), customCommitTime); <line20> graph = (StandardJanusGraph) JanusGraphFactory.open(wc); <line21> assertEquals(MAX_COMMIT_TIME.getDefaultValue(), graph.getConfiguration().getMaxCommitTime()); <line22> graph.getBackend().clearStorage(); <line23> try { <line24> graph.close(); <line25> } catch (Throwable t) { <line26> } <line27> wc = getConfiguration(); <line28> wc.set(ConfigElement.getPath(ALLOW_STALE_CONFIG), false); <line29> graph = (StandardJanusGraph) JanusGraphFactory.open(wc); <line30> close(); <line31> wc = getConfiguration(); <line32> wc.set(ConfigElement.getPath(MAX_COMMIT_TIME), customCommitTime); <line33> try { <line34> graph = (StandardJanusGraph) JanusGraphFactory.open(wc); <line35> fail(""Masking managed config options should be disabled in this configuration""); <line36> } catch (JanusGraphConfigurationException e) { <line37> assertTrue(e.getMessage().contains(ConfigElement.getPath(MAX_COMMIT_TIME))); <line38> } <line39> wc = getConfiguration(); <line40> wc.set(ConfigElement.getPath(ALLOW_STALE_CONFIG), true); <line41> wc.set(ConfigElement.getPath(MAX_COMMIT_TIME), customCommitTime); <line42> graph = (StandardJanusGraph) JanusGraphFactory.open(wc); <line43> assertEquals(MAX_COMMIT_TIME.getDefaultValue(), graph.getConfiguration().getMaxCommitTime()); <line44> } <line45> } <line46> "	 <line26>	Yes
public class A { <line0> private void updateChannelState(Channel channel) { <line1> if (!isLinked(channel.getUID())) { <line2> return; <line3> } <line4> if (comfoAirConnector != null) { <line5> boolean isActive = !comfoAirConnector.getIsSuspended(); <line6> String commandKey = channel.getUID().getId(); <line7> if (commandKey.equals(ACTIVATE_CHANNEL_ID)) { <line8> State state = OnOffType.from(isActive); <line9> updateState(channel.getUID(), state); <line10> return; <line11> } <line12> if (!isActive) { <line13> return; <line14> } <line15> ComfoAirCommand readCommand = ComfoAirCommandType.getReadCommand(commandKey); <line16> if (readCommand != null && readCommand.getRequestCmd() != null) { <line17> scheduler.submit( <line18> () -> { <line19> State state = sendCommand(readCommand, commandKey); <line20> updateState(channel.getUID(), state); <line21> }); <line22> } <line23> } <line24> } <line25> } <line26> 	 <line23>	No
public class A { <line0> private void debugResponse(HttpResponse res) { <line1> if (log.isDebugEnabled()) { <line2> Header[] headers = res.getAllHeaders(); <line3> for (Header header : headers) { <line4> } <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> public void runNext(WorkFlowContext ctx) { <line1> if (!isInitialized) { <line2> throw new CloudRuntimeException( <line3> String.format(""runNext() can only be called from AysncWorkFlow"")); <line4> } <line5> WorkFlowVO vo = getFlowVOByPosition(currentPosition); <line6> vo.setState(flowState.getNextState(vo.getState(), WorkFlowStateEvent.done)); <line7> vo.setContext(ctx.toBytes()); <line8> dbf.update(vo); <line9> currentPosition++; <line10> if (currentPosition < flows.size()) { <line11> chainvo.setCurrentPosition(currentPosition); <line12> chainvo = dbf.updateAndRefresh(chainvo); <line13> AsyncWorkFlow flow = flows.get(currentPosition); <line14> processFlow(flow, ctx, null, currentPosition); <line15> } else { <line16> chainvo.setState(WorkFlowChainState.ProcessDone); <line17> chainvo = dbf.updateAndRefresh(chainvo); <line18> tellCallbackSuccess(ctx); <line19> } <line20> } <line21> } <line22> "	 <line0>	No
"public class A { <line0> @Override <line1> public CommerceAccountGroupRel findByC_C_C( <line2> long classNameId, long classPK, long commerceAccountGroupId) <line3> throws NoSuchAccountGroupRelException { <line4> CommerceAccountGroupRel commerceAccountGroupRel = <line5> fetchByC_C_C(classNameId, classPK, commerceAccountGroupId); <line6> if (commerceAccountGroupRel == null) { <line7> StringBundler sb = new StringBundler(8); <line8> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line9> sb.append(""classNameId=""); <line10> sb.append(classNameId); <line11> sb.append("", classPK=""); <line12> sb.append(classPK); <line13> sb.append("", commerceAccountGroupId=""); <line14> sb.append(commerceAccountGroupId); <line15> sb.append(""}""); <line16> if (_log.isDebugEnabled()) { <line17> } <line18> throw new NoSuchAccountGroupRelException(sb.toString()); <line19> } <line20> return commerceAccountGroupRel; <line21> } <line22> } <line23> "	 <line13>	No
"public class A { <line0> public static TrasformazioneDTOResponse trasformazioneInputCSV( <line1> Logger log, <line2> String codDominio, <line3> String codTipoVersamento, <line4> String lineaCSV, <line5> String tipoTemplate, <line6> String trasformazioneRichiesta) <line7> throws GovPayException { <line8> String name = ""TrasformazionePendenzaCSVtoJSON""; <line9> try { <line10> if (trasformazioneRichiesta.startsWith(""\"""")) <line11> trasformazioneRichiesta = trasformazioneRichiesta.substring(1); <line12> if (trasformazioneRichiesta.endsWith(""\"""")) <line13> trasformazioneRichiesta = <line14> trasformazioneRichiesta.substring(0, trasformazioneRichiesta.length() - 1); <line15> byte[] template = Base64.getDecoder().decode(trasformazioneRichiesta.getBytes()); <line16> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line17> Map<String, Object> dynamicMap = new HashMap<String, Object>(); <line18> TrasformazioniUtils.fillDynamicMapRichiestaTracciatoCSV( <line19> log, dynamicMap, ContextThreadLocal.get(), lineaCSV, codDominio, codTipoVersamento); <line20> TrasformazioniUtils.convertFreeMarkerTemplate(name, template, dynamicMap, baos); <line21> return new TrasformazioneDTOResponse(baos.toString(), dynamicMap); <line22> } catch (TrasformazioneException | UnprocessableEntityException e) { <line23> throw new GovPayException(e.getMessage(), EsitoOperazione.TRASFORMAZIONE, e, e.getMessage()); <line24> } <line25> } <line26> } <line27> "	 <line26>	No
"public class A { <line0> public void clickDeleteButton() { <line1> WebElement findElement = driver.findElement(By.className(""t-client-remove-btn"")); <line2> findElement.click(); <line3> } <line4> } <line5> "	 <line2>	No
public class A { <line0> @JDebug <line1> public String getAction(Field field, Object element, Object parent) { <line2> return GET_ACTION.execute(field, element, parent); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> while (!interrupted()) { <line3> for (ServiceBeanInstance<?> leasedService : leasedServices) { <line4> if (!leasedService.isBound()) { <line5> bind(leasedService); <line6> } <line7> } <line8> try { <line9> Thread.sleep(config.get(AstrixSettings.BEAN_BIND_ATTEMPT_INTERVAL).get()); <line10> } catch (InterruptedException e) { <line11> interrupt(); <line12> } <line13> } <line14> } <line15> } <line16> 	 <line14>	Yes
public class A { <line0> @Override <line1> public boolean onOwnerChanged(GridCacheEntryEx entry, GridCacheMvccCandidate owner) { <line2> if (log.isDebugEnabled()) <line3> if (tx.remainingTime() == -1) return false; <line4> if ((entry.context().isNear() || entry.context().isLocal()) <line5> && owner != null <line6> && tx.hasWriteKey(entry.txKey())) { <line7> if (keyLockFut != null) keyLockFut.onKeyLocked(entry.txKey()); <line8> return true; <line9> } <line10> return false; <line11> } <line12> } <line13> 	 <line3>	Yes
"public class A { <line0> @Override <line1> public void execute() { <line2> try { <line3> CallContext.current().setEventDetails(getEventDescription()); <line4> String uploadUrl = _templateService.extract(this); <line5> if (uploadUrl != null) { <line6> ExtractResponse response = <line7> _responseGenerator.createExtractResponse( <line8> id, zoneId, getEntityOwnerId(), mode, uploadUrl); <line9> response.setResponseName(getCommandName()); <line10> response.setObjectName(""iso""); <line11> this.setResponseObject(response); <line12> } else { <line13> throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to extract ISO""); <line14> } <line15> } catch (InternalErrorException ex) { <line16> throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage()); <line17> } <line18> } <line19> } <line20> "	 <line16>	Yes
public class A { <line0> public void removeEventStream(String eventStreamName, String eventStreamVersion) <line1> throws RemoteException { <line2> try { <line3> eventStreamAdminServiceStub.removeEventStreamDefinition(eventStreamName, eventStreamVersion); <line4> } catch (RemoteException e) { <line5> throw new RemoteException(); <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> private void handleCommand(MetaCommand cmd) throws IOException { <line1> if (cmd == null) { <line2> return; <line3> } <line4> switch (cmd) { <line5> case MetaCommand_Nothing: <line6> break; <line7> case MetaCommand_Register: <line8> setIdAndRegister(); <line9> break; <line10> case MetaCommand_Unknown: <line11> break; <line12> default: <line13> throw new RuntimeException(""Un-recognized command from leader master "" + cmd); <line14> } <line15> } <line16> } <line17> "	 <line11>	Yes
"public class A { <line0> @Test( <line1> dataProvider = ""testName"", <line2> dependsOnMethods = {""delete""}) <line3> public void verifyCreateWithFlippedRoles(String testName) throws Exception { <line4> int statusCode; <line5> setupCreate(); <line6> DimensionClient client = new DimensionClient(); <line7> flipInitialAccountRoles(); <line8> client.setAuth(true, ""elmo2010"", true, ""elmo2010"", true); <line9> client = new DimensionClient(); <line10> String identifier = createIdentifier(); <line11> DimensionsCommon dimension = new DimensionsCommon(); <line12> dimension.setDimension(""dimensionType""); <line13> dimension.setMeasurementUnit(""measurementUnit-"" + identifier); <line14> dimension.setValueDate(new Date().toString()); <line15> PoxPayloadOut multipart = <line16> DimensionFactory.createDimensionInstance(client.getCommonPartName(), dimension); <line17> Response res = client.create(multipart); <line18> try { <line19> statusCode = res.getStatus(); <line20> if (logger.isDebugEnabled()) { <line21> } <line22> Assert.assertTrue( <line23> testRequestType.isValidStatusCode(statusCode), <line24> invalidStatusCodeMessage(testRequestType, statusCode)); <line25> Assert.assertEquals(statusCode, Response.Status.CREATED.getStatusCode()); <line26> knownResourceId = extractId(res); <line27> if (logger.isDebugEnabled()) { <line28> } <line29> } finally { <line30> res.close(); <line31> } <line32> client.setAuth(true, ""bigbird2010"", true, ""bigbird2010"", true); <line33> res = client.create(multipart); <line34> try { <line35> statusCode = res.getStatus(); <line36> if (logger.isDebugEnabled()) { <line37> } <line38> Assert.assertTrue( <line39> testRequestType.isValidStatusCode(statusCode), <line40> invalidStatusCodeMessage(testRequestType, statusCode)); <line41> Assert.assertEquals(statusCode, Response.Status.FORBIDDEN.getStatusCode()); <line42> } finally { <line43> res.close(); <line44> } <line45> restoreInitialAccountRoles(); <line46> } <line47> } <line48> "	 <line45>	No
public class A { <line0> public void start() throws Exception { <line1> tioServer = appContext.getIoc().getByType(TioServer.class); <line2> String ip = appContext.getServerHost(PROP_IP); <line3> int port = appContext.getServerPort(PROP_PORT, 9420); <line4> tioServer.start(ip, port); <line5> } <line6> } <line7> 	 <line0>	No
"public class A { <line0> public static java.util.List<com.liferay.journal.model.JournalArticle> getLatestArticles( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> int status, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.journal.model.JournalArticle> <line7> orderByComparator) { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> JournalArticleServiceUtil.class, <line12> ""getLatestArticles"", <line13> _getLatestArticlesParameterTypes48); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, groupId, status, start, end, orderByComparator); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (java.util.List<com.liferay.journal.model.JournalArticle>) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	 <line24>	Yes
public class A { <line0> private void onNotification(final String jobType) { <line1> actor.run(() -> resetFailedAttemptsAndHandlePendingRequests(jobType)); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> private JChannel newChannel(String jgroupsConfig) throws Exception { <line1> if (StringUtil.isBlank(jgroupsConfig)) { <line2> return new JChannel(); <line3> } <line4> ProtocolStackConfigurator configurator = null; <line5> InputStream stream = <line6> ClusteringService.class.getClassLoader().getResourceAsStream(jgroupsConfig); <line7> if (stream == null) { <line8> try { <line9> stream = new FileInputStream(jgroupsConfig); <line10> } catch (FileNotFoundException e) { <line11> throw new RepositoryException(ClusteringI18n.missingConfigurationFile.text(jgroupsConfig)); <line12> } <line13> } <line14> try { <line15> configurator = XmlConfigurator.getInstance(stream); <line16> } catch (IOException e) { <line17> stream = new ByteArrayInputStream(jgroupsConfig.getBytes()); <line18> try { <line19> configurator = XmlConfigurator.getInstance(stream); <line20> } catch (IOException e1) { <line21> } <line22> } finally { <line23> if (stream != null) { <line24> try { <line25> stream.close(); <line26> } catch (IOException e) { <line27> } <line28> } <line29> } <line30> if (configurator == null) { <line31> throw new RepositoryException(ClusteringI18n.channelConfigurationError.text(jgroupsConfig)); <line32> } <line33> return new JChannel(configurator); <line34> } <line35> } <line36> 	 <line19>	No
"public class A { <line0> private FTPClient getFtpClient() throws IOException { <line1> final FTPClient ftpClient; <line2> final Settings.FtpMode ftpMode = <line3> Settings.FtpMode.valueOf(settings.getSetting(Settings.Setting.ftpMode)); <line4> switch (ftpMode) { <line5> case ftp: <line6> ftpClient = new FTPClient(); <line7> break; <line8> case ftps: <line9> ftpClient = new FTPSClient(); <line10> break; <line11> default: <line12> throw new IllegalArgumentException(""unexpected ftp mode""); <line13> } <line14> ftpClient.connect(settings.getSetting(Settings.Setting.ftpSite)); <line15> if (!StringUtil.isEmpty(settings.getSetting(Settings.Setting.ftpUser)) <line16> && !StringUtil.isEmpty(settings.getSetting(Settings.Setting.ftpPassword))) { <line17> final boolean loggedInSuccess = <line18> ftpClient.login( <line19> settings.getSetting(Settings.Setting.ftpUser), <line20> settings.getSetting(Settings.Setting.ftpPassword)); <line21> } <line22> ftpClient.enterLocalPassiveMode(); <line23> return ftpClient; <line24> } <line25> } <line26> "	 <line3>	No
public class A { <line0> public byte[] toBytes(Schema toSchema, Object o) { <line1> if (toSchema != null && toSchema.getType() == Type.UNION) { <line2> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line3> org.apache.avro.io.BinaryEncoder avroEncoder = EncoderFactory.get().binaryEncoder(baos, null); <line4> int unionIndex = 0; <line5> try { <line6> if (o == null) { <line7> unionIndex = firstNullSchemaTypeIndex(toSchema); <line8> avroEncoder.writeIndex(unionIndex); <line9> avroEncoder.writeNull(); <line10> } else { <line11> unionIndex = firstNotNullSchemaTypeIndex(toSchema); <line12> avroEncoder.writeIndex(unionIndex); <line13> avroEncoder.writeBytes(toBytes(o)); <line14> } <line15> avroEncoder.flush(); <line16> return baos.toByteArray(); <line17> } catch (IOException e) { <line18> return toBytes(o); <line19> } <line20> } else { <line21> return toBytes(o); <line22> } <line23> } <line24> } <line25> 	 <line18>	Yes
public class A { <line0> @Nullable <line1> private static Integer getInt(Map<String, String> map, String key, String description) { <line2> String value = map.get(key); <line3> if (value == null) { <line4> return null; <line5> } <line6> try { <line7> return Integer.parseInt(value); <line8> } catch (NumberFormatException e) { <line9> } <line10> return null; <line11> } <line12> } <line13> 	 <line9>	Yes
public class A { <line0> @VisibleForTesting <line1> void finishAsyncRequestInstanceSteps(AsyncRequestInstanceState asyncRequestInstanceState) { <line2> asyncRequestInstanceState.setState(AsyncRequestInstanceState.StateType.READY); <line3> } <line4> } <line5> 	 <line3>	Yes
public class A { <line0> public void warn(String message, Exception e) { <line1> synchronized (lockObject) { <line2> } <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> private DatenMediaDB getUrlAusZeile(String zeile) { <line1> if (zeile.isEmpty()) { <line2> return null; <line3> } <line4> String name = """", pfad = """", s = """"; <line5> long size = 0; <line6> try { <line7> if (zeile.contains(TRENNER)) { <line8> name = zeile.substring(0, zeile.indexOf(TRENNER)).trim(); <line9> pfad = <line10> zeile <line11> .substring(zeile.indexOf(TRENNER) + TRENNER.length(), zeile.lastIndexOf(TRENNER)) <line12> .trim(); <line13> s = zeile.substring(zeile.lastIndexOf(TRENNER) + TRENNER.length()).trim(); <line14> } <line15> if (!s.isEmpty()) { <line16> try { <line17> size = Long.parseLong(s); <line18> } catch (Exception ignore) { <line19> size = 0; <line20> } <line21> } <line22> return new DatenMediaDB(name, pfad, size, true); <line23> } catch (Exception ex) { <line24> } <line25> return null; <line26> } <line27> } <line28> "	 <line24>	Yes
public class A { <line0> private Folder handlerCreateFolderException(String newUri, String name) <line1> throws IOException, HttpException, NotAuthorizedException, BadRequestException { <line2> this.flush(); <line3> Resource child = this.child(name); <line4> if (child instanceof Folder) { <line5> return (Folder) child; <line6> } else { <line7> if (child == null) { <line8> } else { <line9> } <line10> throw new GenericHttpException(405, newUri); <line11> } <line12> } <line13> } <line14> 	 <line8>	Yes
"public class A { <line0> @Test <line1> public void oracleParser1() { <line2> DatabaseInfo dbInfo = jdbcUrlParser.parse(""jdbc:oracle:thin:@hostname:port:SID""); <line3> Assert.assertTrue(dbInfo.isParsingComplete()); <line4> Assert.assertEquals(dbInfo.getType(), OracleConstants.ORACLE); <line5> Assert.assertEquals(dbInfo.getHost().get(0), ""hostname:port""); <line6> Assert.assertEquals(dbInfo.getDatabaseId(), ""SID""); <line7> Assert.assertEquals(dbInfo.getUrl(), ""jdbc:oracle:thin:@hostname:port:SID""); <line8> } <line9> } <line10> "	 <line8>	Yes
public class A { <line0> public String save(Path path) { <line1> try (BufferedWriter writer = Files.newBufferedWriter(path)) { <line2> writer.write(toJson().toString(new NullStringer(2))); <line3> } catch (IOException e) { <line4> return e.getMessage(); <line5> } <line6> return null; <line7> } <line8> } <line9> 	 <line4>	Yes
"public class A { <line0> public OperatingSystem apply(final org.jclouds.cloudservers.domain.Image from) { <line1> OsFamily osFamily = null; <line2> String osName = null; <line3> String osArch = null; <line4> String osVersion = null; <line5> String osDescription = from.getName(); <line6> boolean is64Bit = true; <line7> if (from.getName().indexOf(""Red Hat EL"") != -1) { <line8> osFamily = OsFamily.RHEL; <line9> } else if (from.getName().indexOf(""Oracle EL"") != -1) { <line10> osFamily = OsFamily.OEL; <line11> } else if (from.getName().indexOf(""Windows"") != -1) { <line12> osFamily = OsFamily.WINDOWS; <line13> Matcher matcher = WINDOWS_PATTERN.matcher(from.getName()); <line14> if (matcher.find()) { <line15> osVersion = <line16> ComputeServiceUtils.parseVersionOrReturnEmptyString( <line17> osFamily, matcher.group(1), osVersionMap); <line18> is64Bit = matcher.group(2).equals(""x64""); <line19> } <line20> } else { <line21> Matcher matcher = DEFAULT_PATTERN.matcher(from.getName()); <line22> if (matcher.find()) { <line23> try { <line24> osFamily = OsFamily.fromValue(matcher.group(2).toLowerCase()); <line25> } catch (IllegalArgumentException e) { <line26> } <line27> osVersion = <line28> ComputeServiceUtils.parseVersionOrReturnEmptyString( <line29> osFamily, matcher.group(3), osVersionMap); <line30> } <line31> } <line32> return new OperatingSystem(osFamily, osName, osVersion, osArch, osDescription, is64Bit); <line33> } <line34> } <line35> "	 <line26>	Yes
"public class A { <line0> private void writeAttrChangeLogs(Connection conn, int txNumber) throws SQLException { <line1> int numRecords = (attrChangeLogs == null) ? 0 : attrChangeLogs.size(); <line2> int bufferCapacity = <line3> Math.min(MIN_BUFFER_CAPACITY + (numRecords * PER_RECORD_LENGTH), MAX_BUFFER_CAPACITY); <line4> StringBuilder sqlCmd = new StringBuilder(bufferCapacity); <line5> sqlCmd.append(SQL_CHANGE_LOGS_CMD_PREFIX); <line6> Statement stmt = null; <line7> try { <line8> stmt = conn.createStatement(); <line9> boolean addedRecord = false; <line10> if (attrChangeLogs == null) { <line11> sqlCmd.append(""(0,'',""); <line12> sqlCmd.append(txNumber); <line13> sqlCmd.append("")""); <line14> addedRecord = true; <line15> } else { <line16> for (AttrChangeLog log : attrChangeLogs) { <line17> if (isNewObject(log.obj)) { <line18> continue; <line19> } <line20> if (addedRecord) { <line21> sqlCmd.append("",""); <line22> } <line23> sqlCmd.append(""(""); <line24> sqlCmd.append(log.obj.getOid()); <line25> sqlCmd.append("",'""); <line26> sqlCmd.append(log.attr); <line27> sqlCmd.append(""',""); <line28> sqlCmd.append(txNumber); <line29> sqlCmd.append("")""); <line30> addedRecord = true; <line31> if ((bufferCapacity - sqlCmd.length()) < BUFFER_THRESHOLD) { <line32> stmt.execute(sqlCmd.toString()); <line33> sqlCmd.setLength(0); <line34> sqlCmd.append(SQL_CHANGE_LOGS_CMD_PREFIX); <line35> addedRecord = false; <line36> } <line37> } <line38> } <line39> if (addedRecord) { <line40> try { <line41> stmt.execute(sqlCmd.toString()); <line42> } catch (SQLException ex) { <line43> throw new CommitException(); <line44> } <line45> } <line46> } finally { <line47> if (stmt != null) { <line48> stmt.close(); <line49> } <line50> } <line51> } <line52> } <line53> "	 <line21>	No
"public class A { <line0> private static Stream<IRI> getEditMediaFileIRIStream( <line1> final String collection, final String derivateId) { <line2> MCRPath derivateRootPath = MCRPath.getPath(derivateId, ""/""); <line3> try { <line4> List<IRI> iris = new ArrayList<>(); <line5> Files.walkFileTree( <line6> derivateRootPath, <line7> new SimpleFileVisitor<Path>() { <line8> @Override <line9> public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) <line10> throws IOException { <line11> String relativePath = derivateRootPath.relativize(file).toString(); <line12> final String uri = <line13> new MessageFormat(""{0}{1}{2}/{3}/{4}"", Locale.ROOT) <line14> .format( <line15> new Object[] { <line16> MCRFrontendUtil.getBaseURL(), <line17> MCRSwordConstants.SWORD2_EDIT_MEDIA_IRI, <line18> collection, <line19> derivateId, <line20> encodeURLPart(relativePath) <line21> }); <line22> iris.add(new IRI(uri)); <line23> return FileVisitResult.CONTINUE; <line24> } <line25> }); <line26> return iris.stream(); <line27> } catch (IOException e) { <line28> throw new MCRException(e); <line29> } <line30> } <line31> } <line32> "	 <line28>	Yes
public class A { <line0> private CharSequence getString(long lo, long hi, CharSequence errorMessage) <line1> throws BadProtocolException { <line2> CharacterStoreEntry e = characterStore.newEntry(); <line3> if (Chars.utf8Decode(lo, hi, e)) { <line4> return characterStore.toImmutable(); <line5> } else { <line6> throw BadProtocolException.INSTANCE; <line7> } <line8> } <line9> } <line10> 	 <line8>	No
public class A { <line0> @Override <line1> public void resultChanged(LookupEvent e) { <line2> } <line3> } <line4> 	 <line1>	No
public class A { <line0> private Map<PhysicalPlan, PartitionGroup> splitPlan(PhysicalPlan plan) <line1> throws UnsupportedPlanException, CheckConsistencyException { <line2> Map<PhysicalPlan, PartitionGroup> planGroupMap = null; <line3> try { <line4> planGroupMap = router.splitAndRoutePlan(plan); <line5> } catch (StorageGroupNotSetException e) { <line6> metaGroupMember.syncLeaderWithConsistencyCheck(true); <line7> try { <line8> planGroupMap = router.splitAndRoutePlan(plan); <line9> } catch (MetadataException ex) { <line10> } <line11> } catch (MetadataException e) { <line12> } <line13> return planGroupMap; <line14> } <line15> } <line16> 	 <line8>	No
public class A { <line0> private void forceClose() { <line1> assert adminExecutor.inEventLoop(); <line2> if (forceCloseWasCalled) { <line3> return; <line4> } <line5> forceCloseWasCalled = true; <line6> if (closeWasCalled) { <line7> for (AsyncAutoCloseable closeable : internalComponentsToClose()) { <line8> closeable.forceCloseAsync(); <line9> } <line10> } else { <line11> closePolicies(); <line12> List<CompletionStage<Void>> childrenCloseStages = new ArrayList<>(); <line13> for (AsyncAutoCloseable closeable : internalComponentsToClose()) { <line14> childrenCloseStages.add(closeable.forceCloseAsync()); <line15> } <line16> CompletableFutures.whenAllDone( <line17> childrenCloseStages, () -> onChildrenClosed(childrenCloseStages), adminExecutor); <line18> } <line19> } <line20> } <line21> 	 <line6>	Yes
public class A { <line0> @Test <line1> public void testSerializeData() throws Exception { <line2> Writer serializeData = <line3> bindingSerializer.serializeData(this.effectiveModelContext, testedToasterNormalizedNodes); <line4> Assert.assertFalse(Strings.isNullOrEmpty(serializeData.toString())); <line5> } <line6> } <line7> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void planOperation(Runnable operation) { <line2> operations.add(operation); <line3> if (operation instanceof AbstractOperation) { <line4> ExecutionEntity execution = ((AbstractOperation) operation).getExecution(); <line5> if (execution != null) { <line6> commandContext.addInvolvedExecution(execution); <line7> } <line8> } <line9> } <line10> } <line11> 	 <line9>	Yes
public class A { <line0> void enqueue(Handler<Void> event) { <line1> vertx.runOnContext(event); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> private void processNodeRequests(boolean flagInvalid) { <line1> for (StramToNodeRequest req : nodeRequests) { <line2> if (req.isDeleted()) { <line3> continue; <line4> } <line5> if (req instanceof StramToNodeChangeLoggersRequest) { <line6> handleChangeLoggersRequest((StramToNodeChangeLoggersRequest) req); <line7> continue; <line8> } <line9> Node<?> node = nodes.get(req.getOperatorId()); <line10> if (node == null) { <line11> continue; <line12> } <line13> Thread thread = node.context.getThread(); <line14> if (thread == null || !thread.isAlive()) { <line15> if (flagInvalid) { <line16> req.setDeleted(true); <line17> } <line18> } else { <line19> OperatorRequest requestExecutor = <line20> requestFactory.getRequestExecutor(nodes.get(req.operatorId), req); <line21> if (requestExecutor != null) { <line22> node.context.request(requestExecutor); <line23> } else { <line24> } <line25> req.setDeleted(true); <line26> } <line27> } <line28> } <line29> } <line30> 	 <line27>	No
"public class A { <line0> public void visualFullMolecule2DEvaluation() throws Exception { <line1> HydrogenPlacer hydrogenPlacer = new HydrogenPlacer(); <line2> String filename = ""data/mdl/reserpine.mol""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> MDLReader reader = new MDLReader(ins, Mode.STRICT); <line5> ChemFile chemFile = (ChemFile) reader.read((ChemObject) new ChemFile()); <line6> org.openscience.cdk.interfaces.IChemSequence seq = chemFile.getChemSequence(0); <line7> org.openscience.cdk.interfaces.IChemModel model = seq.getChemModel(0); <line8> IAtomContainer mol = model.getMoleculeSet().getAtomContainer(0); <line9> double bondLength = GeometryUtil.getBondLengthAverage(mol); <line10> addExplicitHydrogens(mol); <line11> hydrogenPlacer.placeHydrogens2D(mol, bondLength); <line12> } <line13> } <line14> "	 <line1>	No
"public class A { <line0> public void outputNPMResource(String npmResourcePath) { <line1> try (NPMResolverRef npmResolverRef = new NPMResolverRef(_tagAccessor)) { <line2> NPMResolver npmResolver = npmResolverRef.getNPMResolver(); <line3> String resourcePath = npmResolver.resolveModuleName(npmResourcePath); <line4> URL url = _bundle.getEntry(""META-INF/resources/node_modules/"" + resourcePath); <line5> outputResource(Position.BOTTOM, StringUtil.read(url.openStream())); <line6> } catch (Exception exception) { <line7> } <line8> } <line9> } <line10> "	 <line9>	No
"public class A { <line0> OpenCGAResult<Object> privateUpdate( <line1> ClientSession clientSession, Project project, ObjectMap parameters) <line2> throws CatalogDBException { <line3> Document updateParams = getDocumentUpdateParams(parameters); <line4> if (updateParams.isEmpty() && !parameters.containsKey(QueryParams.ID.key())) { <line5> if (!parameters.isEmpty()) { <line6> } <line7> throw new CatalogDBException(""Nothing to be updated""); <line8> } <line9> Document updates = new Document(""$set"", updateParams); <line10> long tmpStartTime = startQuery(); <line11> if (parameters.containsKey(QueryParams.ID.key())) { <line12> editId( <line13> clientSession, <line14> project.getFqn().split(""@"")[0], <line15> project.getUid(), <line16> parameters.getString(QueryParams.ID.key())); <line17> } <line18> if (!updateParams.isEmpty()) { <line19> Query tmpQuery = new Query(QueryParams.UID.key(), project.getUid()); <line20> Bson finalQuery = parseQuery(tmpQuery); <line21> DataResult result = userCollection.update(clientSession, finalQuery, updates, null); <line22> if (result.getNumMatches() == 0) { <line23> throw new CatalogDBException(""Project "" + project.getId() + "" not found""); <line24> } <line25> List<Event> events = new ArrayList<>(); <line26> if (result.getNumUpdated() == 0) { <line27> events.add(new Event(Event.Type.WARNING, project.getId(), ""Project was already updated"")); <line28> } <line29> } <line30> return endWrite(tmpStartTime, 1, 1, null); <line31> } <line32> } <line33> "	 <line17>	No
"public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> int nodeIdx = idx.getAndIncrement() % clients.size(); <line3> Ignite node = clients.get(nodeIdx); <line4> Thread.currentThread().setName(""update-"" + node.name()); <line5> final IgniteTransactions txs = node.transactions(); <line6> final IgniteCache<Integer, Account> cache = <line7> nearCache <line8> ? node.createNearCache(cacheName, new NearCacheConfiguration<Integer, Account>()) <line9> : node.<Integer, Account>cache(cacheName); <line10> assertNotNull(cache); <line11> ThreadLocalRandom rnd = ThreadLocalRandom.current(); <line12> while (U.currentTimeMillis() < stopTime) { <line13> int id1 = rnd.nextInt(ACCOUNTS); <line14> int id2 = rnd.nextInt(ACCOUNTS); <line15> while (id2 == id1) id2 = rnd.nextInt(ACCOUNTS); <line16> try { <line17> while (true) { <line18> try { <line19> try (Transaction tx = txs.txStart(OPTIMISTIC, SERIALIZABLE)) { <line20> if (getAll) { <line21> Map<Integer, Account> map = cache.getAll(F.asSet(id1, id2)); <line22> Account a1 = cache.get(id1); <line23> Account a2 = cache.get(id2); <line24> assertNotNull(a1); <line25> assertNotNull(a2); <line26> if (a1.value() > 0) { <line27> a1 = new Account(a1.value() - 1); <line28> a2 = new Account(a2.value() + 1); <line29> } <line30> map.put(id1, a1); <line31> map.put(id2, a2); <line32> cache.putAll(map); <line33> } else { <line34> Account a1 = cache.get(id1); <line35> Account a2 = cache.get(id2); <line36> assertNotNull(a1); <line37> assertNotNull(a2); <line38> if (a1.value() > 0) { <line39> a1 = new Account(a1.value() - 1); <line40> a2 = new Account(a2.value() + 1); <line41> } <line42> cache.put(id1, a1); <line43> cache.put(id2, a2); <line44> } <line45> tx.commit(); <line46> } <line47> break; <line48> } catch (TransactionOptimisticException ignore) { <line49> } catch (IgniteException | CacheException e) { <line50> assertTrue( <line51> ""Unexpected exception [err="" + e + "", cause="" + e.getCause() + ']', <line52> restart && X.hasCause(e, ClusterTopologyCheckedException.class)); <line53> } <line54> } <line55> } catch (Throwable e) { <line56> throw e; <line57> } <line58> } <line59> return null; <line60> } <line61> } <line62> "	 <line5>	Yes
"public class A { <line0> @Path(""/getShouldSucceed"") <line1> @POST <line2> public void getShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.GET); <line4> Subnet out = <line5> template.requestBodyAndHeader(uri, null, OpenstackConstants.ID, SUBNET_ID, Subnet.class); <line6> assertNotNull(out); <line7> assertEquals(SUBNET_NAME, out.getName()); <line8> assertEquals(Ipv6AddressMode.DHCPV6_STATEFUL, out.getIpv6AddressMode()); <line9> assertEquals(Ipv6RaMode.DHCPV6_STATEFUL, out.getIpv6RaMode()); <line10> assertNotNull(out.getDnsNames()); <line11> assertTrue(out.getDnsNames().isEmpty()); <line12> } <line13> } <line14> "	 <line12>	No
"public class A { <line0> public StgMYesnoTxt findById(sernet.gs.reveng.StgMYesnoTxtId id) { <line1> try { <line2> StgMYesnoTxt instance = <line3> (StgMYesnoTxt) <line4> sessionFactory.getCurrentSession().get(""sernet.gs.reveng.StgMYesnoTxt"", id); <line5> if (instance == null) { <line6> } else { <line7> } <line8> return instance; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line12>	No
public class A { <line0> public void setDataID(String newId) throws UnknownIDException { <line1> if (newId.equals(dataId.toString())) return; <line2> if (newId.length() == 0) { <line3> throw new UnknownIDException(); <line4> } <line5> if (sourceType == FORM_TYPE) { <line6> IdModel newDataId = <line7> formularMax4000 <line8> .getIDManager() <line9> .getExistingID(FormularMax4kController.NAMESPACE_FORMCONTROLMODEL, newId); <line10> if (newDataId == null) { <line11> throw new UnknownIDException(); <line12> } <line13> dataId.removeIDChangeListener(myIDChangeListener); <line14> dataId = newDataId; <line15> dataId.addIDChangeListener(myIDChangeListener); <line16> } else { <line17> dataId.removeIDChangeListener(myIDChangeListener); <line18> dataId = <line19> formularMax4000.getIDManager().getID(FormularMax4kController.NAMESPACE_DB_SPALTE, newId); <line20> dataId.addIDChangeListener(myIDChangeListener); <line21> } <line22> notifyListeners(ID_ATTR, dataId); <line23> } <line24> } <line25> 	 <line11>	Yes
"public class A { <line0> @PUT <line1> @Path(""{id}"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @RestQuery( <line4> name = ""updateacl"", <line5> description = ""Update an ACL"", <line6> returnDescription = ""Update an ACL"", <line7> pathParameters = { <line8> @RestParameter( <line9> name = ""id"", <line10> isRequired = true, <line11> description = ""The ACL identifier"", <line12> type = INTEGER) <line13> }, <line14> restParameters = { <line15> @RestParameter( <line16> name = ""name"", <line17> isRequired = true, <line18> description = ""The ACL name"", <line19> type = STRING), <line20> @RestParameter( <line21> name = ""acl"", <line22> isRequired = true, <line23> description = ""The access control list"", <line24> type = STRING) <line25> }, <line26> responses = { <line27> @RestResponse(responseCode = SC_OK, description = ""The ACL has successfully been updated""), <line28> @RestResponse(responseCode = SC_NOT_FOUND, description = ""The ACL has not been found""), <line29> @RestResponse(responseCode = SC_BAD_REQUEST, description = ""Unable to parse the ACL"") <line30> }) <line31> public Response updateAcl( <line32> @PathParam(""id"") long aclId, <line33> @FormParam(""name"") String name, <line34> @FormParam(""acl"") String accessControlList) <line35> throws NotFoundException { <line36> final Organization org = securityService.getOrganization(); <line37> final AccessControlList acl = parseAcl.apply(accessControlList); <line38> final ManagedAclImpl managedAcl = new ManagedAclImpl(aclId, name, org.getId(), acl); <line39> if (!aclService().updateAcl(managedAcl)) { <line40> throw new NotFoundException(); <line41> } <line42> return RestUtils.okJson(full(managedAcl)); <line43> } <line44> } <line45> "	 <line40>	Yes
"public class A { <line0> private void insertErrorLog(String dataBase, String errorQuery, Exception exception) <line1> throws CygnusBadContextData, CygnusRuntimeError, CygnusPersistenceError, SQLException { <line2> Statement stmt = null; <line3> java.util.Date date = new Date(); <line4> Timestamp timestamp = new Timestamp(date.getTime()); <line5> String errorTable = dataBase + DEFAULT_ERROR_TABLE_SUFFIX; <line6> String fieldNames = ""("" + ""timestamp"" + "", error"" + "", query)""; <line7> Connection con = driver.getConnection(dataBase); <line8> String query = """"; <line9> if (sqlInstance == SQLInstance.MYSQL) { <line10> query = ""insert into `"" + errorTable + ""` "" + fieldNames + "" values (?, ?, ?)""; <line11> } else if (sqlInstance == SQLInstance.POSTGRESQL) { <line12> query = ""INSERT INTO "" + dataBase + ""."" + errorTable + "" "" + fieldNames + "" VALUES (?, ?, ?)""; <line13> } <line14> PreparedStatement preparedStatement = con.prepareStatement(query); <line15> try { <line16> preparedStatement.setObject(1, java.sql.Timestamp.from(Instant.now())); <line17> preparedStatement.setString(2, exception.getMessage()); <line18> preparedStatement.setString(3, errorQuery); <line19> preparedStatement.executeUpdate(); <line20> } catch (SQLTimeoutException e) { <line21> throw new CygnusPersistenceError( <line22> sqlInstance.toString().toUpperCase() <line23> + "" Data insertion error. Query: `"" <line24> + preparedStatement, <line25> ""SQLTimeoutException"", <line26> e.getMessage()); <line27> } catch (SQLException e) { <line28> throw new CygnusBadContextData( <line29> sqlInstance.toString().toUpperCase() <line30> + "" Data insertion error. Query: `"" <line31> + preparedStatement, <line32> ""SQLException"", <line33> e.getMessage()); <line34> } finally { <line35> closeSQLObjects(con, preparedStatement); <line36> } <line37> cache.addDataBase(dataBase); <line38> cache.addTable(dataBase, errorTable); <line39> } <line40> } <line41> "	 <line32>	No
public class A { <line0> @Override <line1> public void run() { <line2> while (true) { <line3> try { <line4> runInternal(); <line5> } catch (InterruptedException e) { <line6> return; <line7> } catch (Throwable t) { <line8> } <line9> } <line10> } <line11> } <line12> 	 <line6>	Yes
public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (command == RefreshType.REFRESH) { <line3> updateData(); <line4> } else { <line5> } <line6> } <line7> } <line8> 	 <line2>	No
"public class A { <line0> @Override <line1> public void notify( <line2> XWikiNotificationRule rule, XWikiDocument doc, String action, XWikiContext context) { <line3> try { <line4> String notifpages = context.getWiki().getXWikiPreference(""notification_pages"", context); <line5> if ((notifpages != null) && (!notifpages.equals(""""))) { <line6> String[] notifpages2 = StringUtils.split(notifpages, "" ,""); <line7> for (int i = 0; i < notifpages2.length; i++) { <line8> notifyPage(notifpages2[i], rule, doc, action, context); <line9> } <line10> } <line11> String xnotif = <line12> (context.getRequest() != null) <line13> ? context.getRequest().getParameter(""xnotification"") <line14> : null; <line15> if ((xnotif != null) && (!xnotif.equals(""""))) { <line16> notifyPage(xnotif, rule, doc, action, context); <line17> } <line18> } catch (Throwable e) { <line19> XWikiException e2 = <line20> new XWikiException( <line21> XWikiException.MODULE_XWIKI_NOTIFICATION, <line22> XWikiException.ERROR_XWIKI_NOTIFICATION, <line23> ""Error executing notifications"", <line24> e); <line25> if (LOGGER.isErrorEnabled()) { <line26> } <line27> } <line28> } <line29> } <line30> "	 <line18>	No
public class A { <line0> public void delete(StgMMetastatusTxt persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
"public class A { <line0> protected Map<String, Set<String>> getReverseRelationships(String object, String relationship) <line1> throws MelcoeXacmlException { <line2> Map<String, Set<String>> rels = new HashMap<String, Set<String>>(); <line3> if (object == null) { <line4> return rels; <line5> } <line6> PredicateNode p; <line7> ObjectNode o; <line8> try { <line9> o = TripleMaker.createResource(getFedoraResourceURI(object)); <line10> if (relationship != null) { <line11> p = TripleMaker.createResource(relationship); <line12> } else { <line13> p = null; <line14> } <line15> } catch (TrippiException e) { <line16> throw new MelcoeXacmlException(""Error creating nodes for trippi query "" + e.getMessage(), e); <line17> } <line18> try { <line19> TripleIterator it = RI.findTriples(null, p, o, 0); <line20> while (it.hasNext()) { <line21> Triple t = it.next(); <line22> String pred = t.getPredicate().toString(); <line23> Set<String> values = rels.get(pred); <line24> if (values == null) { <line25> values = new HashSet<String>(); <line26> } <line27> values.add(t.getSubject().stringValue()); <line28> rels.put(pred, values); <line29> } <line30> } catch (TrippiException e) { <line31> throw new MelcoeXacmlException(""Error finding relationships "" + e.getMessage(), e); <line32> } <line33> return rels; <line34> } <line35> } <line36> "	 <line4>	Yes
"public class A { <line0> @Override <line1> public List<String> getCategoryUtilizers(String categoryCode) { <line2> List<String> dataids = null; <line3> try { <line4> dataids = this.getUtilizers(categoryCode, LOAD_REFERENCED_DATAOBJECTS_FOR_CATEGORY); <line5> } catch (Throwable t) { <line6> throw new RuntimeException( <line7> ""Error loading referenced datatypes for category "" + categoryCode, t); <line8> } <line9> return dataids; <line10> } <line11> } <line12> "	 <line0>	No
public class A { <line0> @Override <line1> public void removeMatch(final String match) { <line2> lock.writeLock().lock(); <line3> try { <line4> String modMatch = matchModifier.modify(match); <line5> boolean isImmutable = immutables.contains(modMatch); <line6> if (isImmutable) { <line7> } else { <line8> if (usesWildcards(modMatch)) { <line9> clearCache(); <line10> wildcardMatches.remove(modMatch); <line11> } else { <line12> clearCache(); <line13> exactMatches.remove(modMatch); <line14> } <line15> onChange(); <line16> } <line17> } finally { <line18> lock.writeLock().unlock(); <line19> } <line20> } <line21> } <line22> 	 <line7>	Yes
"public class A { <line0> public List findByExample(StgG20Konz instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.StgG20Konz"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line8>	Yes
"public class A { <line0> public List<String> invoke(String... args) { <line1> try { <line2> List<String> arguments = new ArrayList<>(); <line3> Collections.addAll(arguments, args); <line4> Collections.addAll(arguments, ""--conf"", writeConfFile().getAbsolutePath()); <line5> if (workingDir != null) { <line6> Collections.addAll(arguments, ""--working-directory"", workingDir.getAbsolutePath()); <line7> } <line8> File outFile = new File(folder.getRoot(), ""__OUTPUT__""); <line9> Collections.addAll(arguments, ""--output"", outFile.getAbsolutePath()); <line10> Collections.addAll(arguments, ""--encoding"", StandardCharsets.UTF_8.name()); <line11> try { <line12> DirectIo.exec(arguments.toArray(new String[arguments.size()])); <line13> } catch (RuntimeException e) { <line14> throw e; <line15> } <line16> return collectOutput(outFile); <line17> } catch (IOException e) { <line18> throw new AssertionError(e); <line19> } <line20> } <line21> } <line22> "	 <line2>	No
public class A { <line0> @Override <line1> public void shutdown() { <line2> cleanScheduler.shutdown(); <line3> try { <line4> cleanScheduler.awaitTermination(10, TimeUnit.SECONDS); <line5> } catch (InterruptedException e) { <line6> } <line7> } <line8> } <line9> 	 <line0>	No
public class A { <line0> @Override <line1> public BulkOperationResults<String, TaskanaException> setOwnerOfTasks( <line2> String owner, List<String> argTaskIds) { <line3> BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>(); <line4> if (argTaskIds == null || argTaskIds.isEmpty()) { <line5> return bulkLog; <line6> } <line7> List<String> taskIds = argTaskIds.stream().distinct().collect(Collectors.toList()); <line8> final int requestSize = taskIds.size(); <line9> try { <line10> taskanaEngine.openConnection(); <line11> Pair<List<MinimalTaskSummary>, BulkLog> resultsPair = getMinimalTaskSummaries(taskIds); <line12> List<MinimalTaskSummary> existingMinimalTaskSummaries = resultsPair.getLeft(); <line13> taskIds = <line14> existingMinimalTaskSummaries.stream() <line15> .map(MinimalTaskSummary::getTaskId) <line16> .collect(Collectors.toList()); <line17> bulkLog.addAllErrors(resultsPair.getRight()); <line18> if (!taskIds.isEmpty()) { <line19> final int numberOfAffectedTasks = taskMapper.setOwnerOfTasks(owner, taskIds, Instant.now()); <line20> if (numberOfAffectedTasks != taskIds.size()) { <line21> existingMinimalTaskSummaries = taskMapper.findExistingTasks(taskIds, null); <line22> bulkLog.addAllErrors( <line23> addExceptionsForTasksWhoseOwnerWasNotSet(owner, existingMinimalTaskSummaries)); <line24> if (LOGGER.isDebugEnabled()) { <line25> } <line26> } <line27> } <line28> return bulkLog; <line29> } finally { <line30> taskanaEngine.returnConnection(); <line31> } <line32> } <line33> } <line34> 	 <line33>	No
public class A { <line0> public boolean entityExists(PostgresPersistenceManager<J> pm, EntityType type, Id entityId) { <line1> J id = (J) entityId.getValue(); <line2> StaMainTable<J, ?, ?> table = tableCollection.getTablesByType().get(type); <line3> DSLContext dslContext = pm.getDslContext(); <line4> Integer count = <line5> dslContext.selectCount().from(table).where(table.getId().equal(id)).fetchOne().component1(); <line6> if (count > 1) { <line7> } <line8> return count > 0; <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> @Override <line1> public Response testSubscription( <line2> @PathParam(""checkId"") String checkId, <line3> @PathParam(""subscriptionId"") final String subscriptionId) { <line4> Check check = checksStore.getCheck(checkId); <line5> if (check == null) { <line6> return Response.status(Response.Status.NOT_FOUND).build(); <line7> } <line8> Collection<Subscription> subscriptions = <line9> Collections2.filter( <line10> check.getSubscriptions(), <line11> new Predicate<Subscription>() { <line12> @Override <line13> public boolean apply(Subscription subscription) { <line14> return subscription.getId().equals(subscriptionId); <line15> } <line16> }); <line17> if (subscriptions.size() != 1) { <line18> return Response.status(Response.Status.NOT_FOUND).build(); <line19> } <line20> check.setState(AlertType.ERROR); <line21> Subscription subscription = subscriptions.iterator().next(); <line22> List<Alert> interestingAlerts = new ArrayList<Alert>(); <line23> Alert alert = <line24> new Alert() <line25> .withTarget(check.getTarget()) <line26> .withValue(BigDecimal.valueOf(0.0)) <line27> .withWarn(check.getWarn()) <line28> .withError(check.getError()) <line29> .withFromType(AlertType.OK) <line30> .withToType(AlertType.ERROR) <line31> .withTimestamp(new DateTime()); <line32> interestingAlerts.add(alert); <line33> for (NotificationService notificationService : notificationServices) { <line34> if (notificationService.canHandle(subscription.getType())) { <line35> try { <line36> notificationService.sendNotification(check, subscription, interestingAlerts); <line37> } catch (Exception e) { <line38> return Response.status(Response.Status.INTERNAL_SERVER_ERROR) <line39> .entity(String.format(""Notifying failed '%s'"", e.getMessage())) <line40> .type(MediaType.TEXT_PLAIN) <line41> .build(); <line42> } <line43> } <line44> } <line45> return Response.noContent().build(); <line46> } <line47> } <line48> "	 <line38>	Yes
public class A { <line0> @Override <line1> public void stop() { <line2> dockerClient.stopContainerCmd(getContainerId()).exec(); <line3> super.stop(); <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> @BeforeAll <line1> void setUp(ExtensionContext extensionContext) { <line2> super.beforeAllMayOverride(extensionContext); <line3> super.setupCoAndKeycloak(extensionContext, NAMESPACE); <line4> keycloakInstance.setRealm(""internal"", true); <line5> resourceManager.createResource( <line6> extensionContext, <line7> KafkaTemplates.kafkaEphemeral(oauthClusterName, 3) <line8> .editSpec() <line9> .editKafka() <line10> .withNewListeners() <line11> .addNewGenericKafkaListener() <line12> .withName(Constants.TLS_LISTENER_DEFAULT_NAME) <line13> .withPort(9093) <line14> .withType(KafkaListenerType.INTERNAL) <line15> .withTls(true) <line16> .withNewKafkaListenerAuthenticationOAuth() <line17> .withValidIssuerUri(keycloakInstance.getValidIssuerUri()) <line18> .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds()) <line19> .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds()) <line20> .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri()) <line21> .withUserNameClaim(keycloakInstance.getUserNameClaim()) <line22> .withTlsTrustedCertificates( <line23> new CertSecretSourceBuilder() <line24> .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME) <line25> .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT) <line26> .build()) <line27> .withDisableTlsHostnameVerification(true) <line28> .endKafkaListenerAuthenticationOAuth() <line29> .endGenericKafkaListener() <line30> .endListeners() <line31> .endKafka() <line32> .endSpec() <line33> .build()); <line34> resourceManager.createResource( <line35> extensionContext, KafkaUserTemplates.tlsUser(oauthClusterName, OAUTH_CLIENT_NAME).build()); <line36> } <line37> } <line38> "	 <line9>	No
public class A { <line0> protected String determineHdfsDirWithFallback( <line1> Map<String, Object> globalConfig, String hdfsFile, String hdfsFallbackFile) { <line2> if (!globalConfig.containsKey(GEO_HDFS_FILE)) { <line3> FileSystem fs = MaxMindDbUtilities.getFileSystem(); <line4> try { <line5> if (hdfsPathsExist(fs, hdfsFile, hdfsFallbackFile)) { <line6> hdfsFile = hdfsFallbackFile; <line7> } <line8> } catch (IOException e) { <line9> } <line10> } <line11> return hdfsFile; <line12> } <line13> } <line14> 	 <line9>	Yes
"public class A { <line0> @SuppressWarnings(""squid:S1166"") <line1> public Charset getPartCharset(Part part) throws MessagingException { <line2> String charset = getPartCharsetInternal(part); <line3> try { <line4> return charset == null ? null : Charset.forName(charset); <line5> } catch (UnsupportedCharsetException e) { <line6> return null; <line7> } <line8> } <line9> } <line10> "	 <line3>	No
public class A { <line0> public synchronized void updateRatio(double currentCompressionRatio) throws IOException { <line1> File oldFile = <line2> SystemFileFactory.INSTANCE.getFile( <line3> directory, <line4> String.format(Locale.ENGLISH, RATIO_FILE_PATH_FORMAT, compressionRatioSum, calcTimes)); <line5> compressionRatioSum += currentCompressionRatio; <line6> calcTimes++; <line7> File newFile = <line8> SystemFileFactory.INSTANCE.getFile( <line9> directory, <line10> String.format(Locale.ENGLISH, RATIO_FILE_PATH_FORMAT, compressionRatioSum, calcTimes)); <line11> persist(oldFile, newFile); <line12> compressionRatio.set(compressionRatioSum / calcTimes); <line13> if (LOGGER.isInfoEnabled()) { <line14> } <line15> } <line16> } <line17> 	 <line15>	No
"public class A { <line0> @Test <line1> public void loadCardsTest() { <line2> try { <line3> OpticalSwitchCardFactory factory; <line4> try { <line5> factory = new OpticalSwitchCardFactory(); <line6> } catch (IOException e) { <line7> throw new Exception( <line8> ""Failed to load received data into model. Error loading card profiles file:"", e); <line9> } <line10> ProteusOpticalSwitch proteus = new ProteusOpticalSwitch(); <line11> int chasis = 0; <line12> int slot = 1; <line13> int type = 11; <line14> int subtype = 1; <line15> ProteusOpticalSwitchCard card = factory.createCard(chasis, slot, type, subtype); <line16> proteus.addLogicalDevice(card); <line17> Assert.assertTrue(card.getChasis() == chasis); <line18> Assert.assertTrue(card.getSlot() == slot); <line19> Assert.assertTrue(card.getSlot() == card.getModuleNumber()); <line20> Assert.assertTrue(card.getType() == type); <line21> Assert.assertTrue(card.getSubtype() == subtype); <line22> Assert.assertTrue(card.getCardType().equals(CardType.ROADM_DROP)); <line23> Assert.assertTrue(card.getChannelPlan() != null); <line24> Assert.assertTrue( <line25> card.getChannelPlan().getChannelType().equals(FiberChannelPlan.ChannelType.WDM)); <line26> WonesysDropCard dropCard = (WonesysDropCard) card; <line27> Assert.assertTrue(dropCard.getCommonPort() != null); <line28> Assert.assertTrue(dropCard.getExpressPort() != null); <line29> Assert.assertTrue(dropCard.getPorts().contains(dropCard.getCommonPort())); <line30> Assert.assertTrue(dropCard.getPorts().contains(dropCard.getExpressPort())); <line31> Assert.assertTrue(dropCard.getPorts().size() > 0); <line32> boolean connectionFound = false; <line33> for (NetworkPort port : dropCard.getPorts()) { <line34> if (dropCard.getInternalConnections(port).size() > 0) { <line35> connectionFound = true; <line36> break; <line37> } <line38> } <line39> Assert.assertTrue(connectionFound); <line40> } catch (Exception e) { <line41> Assert.fail(); <line42> } <line43> } <line44> } <line45> "	 <line39>	No
"public class A { <line0> public SCMGetCrlsResponseProto getCrls(SCMGetCrlsRequestProto request) throws IOException { <line1> List<CRLInfo> crls = impl.getCrls(request.getCrlIdList()); <line2> SCMGetCrlsResponseProto.Builder builder = SCMGetCrlsResponseProto.newBuilder(); <line3> for (CRLInfo crl : crls) { <line4> try { <line5> builder.addCrlInfos(crl.getProtobuf()); <line6> } catch (SCMSecurityException e) { <line7> throw new SCMSecurityException(""Fail in parsing CRL info"", e); <line8> } <line9> } <line10> return builder.build(); <line11> } <line12> } <line13> "	 <line9>	No
"public class A { <line0> public void store(File file) throws IOFailure, ArgumentNotValid { <line1> ArgumentNotValid.checkNotNull(file, ""file""); <line2> ArgumentNotValid.checkTrue( <line3> file.isFile(), ""The file '"" + file.getPath() + ""' is not an existing file.""); <line4> StringBuilder messages = new StringBuilder(); <line5> for (long i = 0; i < storeRetries; i++) { <line6> StoreMessage outMsg = null; <line7> try { <line8> outMsg = new StoreMessage(replyQ, file); <line9> NetarkivetMessage replyMsg = sendAndWaitForOneReply(outMsg, storeTimeout); <line10> if (replyMsg != null && replyMsg.isOk()) { <line11> try { <line12> FileUtils.removeRecursively(file); <line13> } catch (IOFailure e) { <line14> } <line15> return; <line16> } else if (replyMsg == null) { <line17> String msg = <line18> ""Timed out"" <line19> + "" while waiting for reply on store of file '"" <line20> + file.getPath() <line21> + ""' on attempt number "" <line22> + (i + 1) <line23> + "" of "" <line24> + storeRetries; <line25> log.warn(msg); <line26> messages.append(msg).append(""\n""); <line27> } else { <line28> String msg = <line29> ""The returned message '"" <line30> + replyMsg <line31> + ""' was not ok while waiting for reply on store "" <line32> + ""of file '"" <line33> + file.getPath() <line34> + ""' on attempt number "" <line35> + (i + 1) <line36> + "" of "" <line37> + storeRetries <line38> + "". Error message was '"" <line39> + replyMsg.getErrMsg() <line40> + ""'""; <line41> messages.append(msg).append(""\n""); <line42> } <line43> } catch (Exception e) { <line44> String msg = <line45> ""Client-side exception occurred while storing '"" <line46> + file.getPath() <line47> + ""' on attempt number "" <line48> + (i + 1) <line49> + "" of "" <line50> + storeRetries <line51> + "".""; <line52> messages.append(msg).append(""\n""); <line53> messages.append(ExceptionUtils.getStackTrace(e)); <line54> } finally { <line55> if (outMsg != null) { <line56> cleanUpAfterStore(outMsg); <line57> } <line58> } <line59> } <line60> String errMsg = <line61> ""Could not store '"" <line62> + file.getPath() <line63> + ""' after "" <line64> + storeRetries <line65> + "" attempts. Giving up.\n"" <line66> + messages; <line67> NotificationsFactory.getInstance().notify(errMsg, NotificationType.ERROR); <line68> throw new IOFailure(errMsg); <line69> } <line70> } <line71> "	 <line14>	Yes
"public class A { <line0> private Thread ripAlbum(String urlString) { <line1> if (!logPanel.isVisible()) { <line2> optionLog.doClick(); <line3> } <line4> urlString = urlString.trim(); <line5> if (urlString.toLowerCase().startsWith(""gonewild:"")) { <line6> urlString = ""http://gonewild.com/user/"" + urlString.substring(urlString.indexOf(':') + 1); <line7> } <line8> if (!urlString.startsWith(""http"")) { <line9> urlString = ""http://"" + urlString; <line10> } <line11> URL url = null; <line12> try { <line13> url = new URL(urlString); <line14> } catch (MalformedURLException e) { <line15> error(""Given URL is not valid, expecting http://website.com/page/...""); <line16> return null; <line17> } <line18> stopButton.setEnabled(true); <line19> statusProgress.setValue(100); <line20> openButton.setVisible(false); <line21> statusLabel.setVisible(true); <line22> pack(); <line23> boolean failed = false; <line24> try { <line25> ripper = AbstractRipper.getRipper(url); <line26> ripper.setup(); <line27> } catch (Exception e) { <line28> failed = true; <line29> error(e.getMessage()); <line30> } <line31> if (!failed) { <line32> try { <line33> mainFrame.setTitle(""Ripping - RipMe v"" + UpdateUtils.getThisJarVersion()); <line34> status(""Starting rip...""); <line35> ripper.setObserver(this); <line36> Thread t = new Thread(ripper); <line37> if (configShowPopup.isSelected() && (!mainFrame.isVisible() || !mainFrame.isActive())) { <line38> try { <line39> mainFrame.toFront(); <line40> mainFrame.setAlwaysOnTop(true); <line41> trayIcon.displayMessage( <line42> mainFrame.getTitle(), <line43> ""Started ripping "" + ripper.getURL().toExternalForm(), <line44> MessageType.INFO); <line45> mainFrame.setAlwaysOnTop(false); <line46> } catch (NullPointerException e) { <line47> } <line48> } <line49> return t; <line50> } catch (Exception e) { <line51> error(""Unable to rip this URL: "" + e.getMessage()); <line52> } <line53> } <line54> stopButton.setEnabled(false); <line55> statusProgress.setValue(0); <line56> pack(); <line57> return null; <line58> } <line59> } <line60> "	 <line29>	Yes
public class A { <line0> protected ConnectionFactory getConnectionFactory() { <line1> return connectionFactoryBuilder.buildConnectionFactory(); <line2> } <line3> } <line4> 	 <line2>	No
"public class A { <line0> @Override <line1> public Iterator<? extends KBHandle> getRoots() { <line2> try { <line3> return kbService <line4> .listRootConcepts(kbModel.getObject(), preferences.getObject().showAllConcepts) <line5> .iterator(); <line6> } catch (QueryEvaluationException e) { <line7> error(getString(""listRootConceptsErrorMsg"") + "": "" + e.getLocalizedMessage()); <line8> return Collections.emptyIterator(); <line9> } <line10> } <line11> } <line12> "	 <line4>	No
public class A { <line0> protected void runAnyPendingCompactions(HoodieTable<T, I, K, O> table) { <line1> table <line2> .getActiveTimeline() <line3> .getWriteTimeline() <line4> .filterPendingCompactionTimeline() <line5> .getInstants() <line6> .forEach( <line7> instant -> { <line8> compact(instant.getTimestamp(), true); <line9> }); <line10> } <line11> } <line12> 	 <line1>	No
public class A { <line0> @Override <line1> public MBeanServer addingService(ServiceReference<MBeanServer> serviceReference) { <line2> mbeanServerReference = serviceReference; <line3> MBeanServer server = context.getService(serviceReference); <line4> try { <line5> installFilteringRuntimeBean(context, server); <line6> } catch (JMException e) { <line7> } <line8> return server; <line9> } <line10> } <line11> 	 <line10>	No
"public class A { <line0> public void setRateLimit( <line1> LoadBalancerEndpointConfiguration config, LoadBalancer loadBalancer, String vsName) <line2> throws InsufficientRequestException, StmRollBackException { <line3> StingrayRestClient client = loadSTMRestClient(config); <line4> ResourceTranslator rt = new ResourceTranslator(); <line5> try { <line6> rt.translateLoadBalancerResource(config, vsName, loadBalancer, loadBalancer); <line7> Bandwidth bandwidth = rt.getcBandwidth(); <line8> VirtualServer virtualServer = rt.getcVServer(); <line9> virtualServer.getProperties().getBasic().setBandwidthClass(vsName); <line10> client.createBandwidth(vsName, bandwidth); <line11> updateVirtualServer(client, vsName, virtualServer); <line12> } catch (StingrayRestClientObjectNotFoundException e) { <line13> client.destroy(); <line14> throw new StmRollBackException(""Add rate limit request canceled."", e); <line15> } catch (StingrayRestClientException e) { <line16> client.destroy(); <line17> throw new StmRollBackException(""Add rate limit request canceled."", e); <line18> } <line19> client.destroy(); <line20> } <line21> } <line22> "	 <line6>	Yes
"public class A { <line0> @Test <line1> public void test() throws IOException { <line2> RomServerJsonRpcHandler jsonRpcHandler = <line3> new RomServerJsonRpcHandler(""org.kurento.client.internal.test.model.server"", ""Impl""); <line4> startJsonRpcServer(jsonRpcHandler); <line5> JsonRpcClient client = createJsonRpcClient(); <line6> useRom(client); <line7> client.close(); <line8> destroyJsonRpcServer(); <line9> } <line10> } <line11> "	 <line5>	Yes
public class A { <line0> private void handlePacket(byte[] p) { <line1> if (log.isTraceEnabled()) { <line2> } <line3> numPackets++; <line4> TmPacket pwt = new TmPacket(timeService.getMissionTime(), p); <line5> pwt.setEarthRceptionTime(ertime); <line6> pwt = packetPreprocessor.process(pwt); <line7> if (pwt != null) { <line8> tmSink.processPacket(pwt); <line9> } <line10> } <line11> } <line12> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void handle( <line2> PacketViolationWarning packet, long currentTimeMillis, PlayerConnection connection) <line3> throws Exception { <line4> } <line5> } <line6> 	 <line4>	Yes
"public class A { <line0> @Test <line1> public void testConcatEdit2segments() throws Exception { <line2> URL sourceUrl = getClass().getResource(""/audiovideo.mov""); <line3> File sourceFile1 = new File(workingDirectory, ""audiovideo.mov""); <line4> FileUtils.copyURLToFile(sourceUrl, sourceFile1); <line5> URL sourceUrl1 = sourceUrl; <line6> File sourceFile2 = sourceFile1; <line7> FileUtils.copyURLToFile(sourceUrl1, sourceFile2); <line8> EncodingProfile[] eprofiles = { <line9> profileScanner.getProfile(""h264-low.http""), <line10> profileScanner.getProfile(""h264-medium.http""), <line11> profileScanner.getProfile(""h264-large.http"") <line12> }; <line13> File[] files = {sourceFile1, sourceFile2}; <line14> Map<String, String> params = new HashMap<String, String>(); <line15> String outDir = sourceFile1.getAbsoluteFile().getParent(); <line16> String outFileName = FilenameUtils.getBaseName(sourceFile1.getName()); <line17> params.put(""out.file.basename"", outFileName); <line18> params.put(""out.dir"", outDir); <line19> ArrayList<Long> edits = new ArrayList<Long>(); <line20> edits.add((long) 0); <line21> edits.add((long) 0); <line22> edits.add((long) 2500); <line23> edits.add((long) 0); <line24> edits.add((long) 3000); <line25> edits.add((long) 5500); <line26> edits.add((long) 1); <line27> edits.add((long) 8000); <line28> edits.add((long) 10500); <line29> List<File> outputs = <line30> engine.multiTrimConcat(Arrays.asList(files), edits, Arrays.asList(eprofiles), 1000); <line31> assertTrue(outputs.size() == eprofiles.length); <line32> for (int i = 0; i < eprofiles.length; i++) assertTrue(outputs.get(i).length() > 0); <line33> } <line34> } <line35> "	 <line2>	Yes
"public class A { <line0> @DELETE <line1> @Timed <line2> @Path(""{id}"") <line3> @Consumes(APPLICATION_JSON) <line4> public void delete( <line5> @Context GraphManager manager, @PathParam(""graph"") String graph, @PathParam(""id"") String id) { <line6> @SuppressWarnings(""unused"") <line7> HugeGraph g = graph(manager, graph); <line8> try { <line9> manager.authManager().deleteTarget(UserAPI.parseId(id)); <line10> } catch (NotFoundException e) { <line11> throw new IllegalArgumentException(""Invalid target id: "" + id); <line12> } <line13> } <line14> } <line15> "	 <line4>	No
"public class A { <line0> @Test <line1> public void noFile() throws Exception { <line2> this.loggingSystem.beforeInitialize(); <line3> this.loggingSystem.initialize(this.initializationContext, null, null); <line4> String output = this.output.toString().trim(); <line5> assertThat(output).contains(""Hello world"").doesNotContain(""Hidden""); <line6> assertThat(getLineWithText(output, ""Hello world"")).contains(""INFO""); <line7> assertThat(new File(tmpDir() + ""/spring.log"").exists()).isFalse(); <line8> } <line9> } <line10> "	 <line3>	Yes
public class A { <line0> private void deletePermObjs() throws BuildException { <line1> if (delpermObjs == null) { <line2> return; <line3> } <line4> for (DelpermObj delpermObj : delpermObjs) { <line5> List<PermObj> permObjs = delpermObj.getObjs(); <line6> for (PermObj permObj : permObjs) { <line7> try { <line8> adminMgr.deletePermObj(permObj); <line9> } catch (SecurityException se) { <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	 <line10>	Yes
"public class A { <line0> private void _configure(String[] args) { <line1> GnuParser parser = new GnuParser(); <line2> CommandLine cmd; <line3> try { <line4> cmd = parser.parse(new MetricsOptions(), args); <line5> } catch (ParseException e) { <line6> return; <line7> } <line8> Configuration conf = getConf(); <line9> URL metricsConfig = MetricsIngester.class.getClassLoader().getResource(""metrics.xml""); <line10> if (metricsConfig != null) { <line11> conf.addResource(metricsConfig); <line12> } <line13> for (Option opt : cmd.getOptions()) { <line14> conf.set(MetricsConfig.MTX + opt.getOpt(), opt.getValue()); <line15> } <line16> } <line17> } <line18> "	 <line6>	Yes
"public class A { <line0> @Override <line1> protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) <line2> throws AuthenticationException { <line3> if (token instanceof CertificateToken) { <line4> if (!((CertificateToken) token) <line5> .getUserName() <line6> .equals(info.getPrincipals().getPrimaryPrincipal())) { <line7> throw new IncorrectCredentialsException( <line8> ""certificate presented did not match the awaited username""); <line9> } <line10> return; <line11> } <line12> super.assertCredentialsMatch(token, info); <line13> } <line14> } <line15> "	 <line13>	No
public class A { <line0> public Object[] retrieveActivityContextIDByActivityType(String fullQualifiedActivityClassName) { <line1> return listWithCriteria(true, true, LIST_BY_ACTIVITY_CLASS, fullQualifiedActivityClassName); <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> @Override <line1> public void operationComplete() { <line2> cursor.setActive(); <line3> cursors.add(cursor); <line4> if (cursorCount.decrementAndGet() == 0) { <line5> callback.initializeComplete(); <line6> } <line7> } <line8> } <line9> 	 <line2>	Yes
public class A { <line0> @VisibleForTesting <line1> boolean isMessageMovedToSpamMailbox(MessageMoveEvent event) { <line2> try { <line3> MailboxId spamMailboxId = <line4> systemMailboxesProvider.findMailbox(Role.SPAM, event.getUsername()).getId(); <line5> return event.getMessageMoves().addedMailboxIds().contains(spamMailboxId); <line6> } catch (MailboxException e) { <line7> return false; <line8> } <line9> } <line10> } <line11> 	 <line10>	No
"public class A { <line0> @Override <line1> protected CalculatedStatus calculateStatus() { <line2> Maybe<SshMachineLocation> sshMachineOption = <line3> Machines.findUniqueMachineLocation(entity.getLocations(), SshMachineLocation.class); <line4> if (sshMachineOption.isPresent()) { <line5> SshMachineLocation sshMachine = sshMachineOption.get(); <line6> try { <line7> Duration timeout = config().get(CONNECT_TIMEOUT); <line8> Map<String, ?> flags = <line9> ImmutableMap.of( <line10> SshTool.PROP_CONNECT_TIMEOUT.getName(), <line11> timeout.toMilliseconds(), <line12> SshTool.PROP_SESSION_TIMEOUT.getName(), <line13> timeout.toMilliseconds(), <line14> SshTool.PROP_SSH_TRIES.getName(), <line15> 1); <line16> int exitCode = <line17> sshMachine.execCommands( <line18> flags, SshMachineFailureDetector.class.getName(), ImmutableList.of(""exit"")); <line19> return new BasicCalculatedStatus(exitCode == 0, sshMachine.toString()); <line20> } catch (Exception e) { <line21> Exceptions.propagateIfFatal(e); <line22> boolean isFirstFailure = <line23> lastPublished != LastPublished.FAILED && currentFailureStartTime == null; <line24> if (isFirstFailure) { <line25> if (LOG.isDebugEnabled()) { <line26> } <line27> } else { <line28> if (LOG.isTraceEnabled()) { <line29> } <line30> } <line31> return new BasicCalculatedStatus(false, e.getMessage()); <line32> } <line33> } else { <line34> return new BasicCalculatedStatus(true, ""no machine started, not complaining""); <line35> } <line36> } <line37> } <line38> "	 <line26>	Yes
"public class A { <line0> @Override <line1> public ConfigInfoBetaWrapper findConfigInfo4Beta( <line2> final String dataId, final String group, final String tenant) { <line3> String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant; <line4> try { <line5> return this.jt.queryForObject( <line6> ""SELECT ID,data_id,group_id,tenant_id,app_name,content,beta_ips FROM config_info_beta"" <line7> + "" WHERE data_id=? AND group_id=? AND tenant_id=?"", <line8> new Object[] {dataId, group, tenantTmp}, <line9> CONFIG_INFO_BETA_WRAPPER_ROW_MAPPER); <line10> } catch (EmptyResultDataAccessException e) { <line11> return null; <line12> } catch (CannotGetJdbcConnectionException e) { <line13> throw e; <line14> } <line15> } <line16> } <line17> "	 <line15>	No
"public class A { <line0> @Override <line1> public void removeRegion(String id) { <line2> Entity entity = getManagementContext().getEntityManager().getEntity(id); <line3> Preconditions.checkNotNull(entity, ""No entity found for %s"", id); <line4> Preconditions.checkArgument( <line5> this.equals(entity.getParent()), ""Wrong parent (%s) for %s"", entity.getParent(), entity); <line6> Collection<Location> childLocations = entity.getLocations(); <line7> if (entity instanceof Startable) { <line8> try { <line9> Entities.invokeEffector(this, entity, Startable.STOP).get(); <line10> } catch (Exception e) { <line11> Exceptions.propagateIfFatal(e); <line12> } <line13> } <line14> removeChild(entity); <line15> removeLocations(childLocations); <line16> } <line17> } <line18> "	 <line5>	No
"public class A { <line0> private void updateGroup(@Nullable String address, @Nullable String value) { <line1> if (address == null || value == null) { <line2> return; <line3> } <line4> if (!address.startsWith(""//"")) { <line5> return; <line6> } <line7> String[] addressParts = address.substring(2).split(""/""); <line8> if (addressParts.length != 4) { <line9> return; <line10> } <line11> updateGroup( <line12> Integer.parseInt(addressParts[1]), <line13> Integer.parseInt(addressParts[2]), <line14> Integer.parseInt(addressParts[3]), <line15> value); <line16> } <line17> } <line18> "	 <line3>	No
"public class A { <line0> public List<IndexMetadata> getIndices(String table, String column, Split split) { <line1> if (cache == null) { <line2> return Collections.emptyList(); <line3> } <line4> URI splitUri = URI.create(URIUtil.encodePath(split.getConnectorSplit().getFilePath())); <line5> long lastModifiedTime = split.getConnectorSplit().getLastModifiedTime(); <line6> List<IndexMetadata> indices = new LinkedList<>(); <line7> for (String indexType : INDEX_TYPES) { <line8> String filterKeyPath = table + ""/"" + column + ""/"" + indexType + splitUri.getRawPath(); <line9> IndexCacheKey filterKey = new IndexCacheKey(filterKeyPath, lastModifiedTime); <line10> List<IndexMetadata> indexOfThisType; <line11> indexOfThisType = cache.getIfPresent(filterKey); <line12> if (indexOfThisType == null) { <line13> executor.schedule( <line14> () -> { <line15> try { <line16> cache.get(filterKey); <line17> } catch (ExecutionException e) { <line18> if (e.getCause() instanceof IndexNotCreatedException) { <line19> } else if (LOG.isDebugEnabled()) { <line20> } <line21> } <line22> }, <line23> loadDelay, <line24> TimeUnit.MILLISECONDS); <line25> } else { <line26> for (IndexMetadata index : indexOfThisType) { <line27> if (index.getLastModifiedTime() != lastModifiedTime) { <line28> cache.invalidate(filterKey); <line29> indexOfThisType = Collections.emptyList(); <line30> break; <line31> } <line32> } <line33> indices.addAll(indexOfThisType); <line34> } <line35> } <line36> return indices; <line37> } <line38> } <line39> "	 <line33>	No
"public class A { <line0> @Override <line1> public boolean queueAudioBuffers(Queue<AudioBuffer> audioBuffers) { <line2> if (!_initialised || !isAudioAlive()) { <line3> return false; <line4> } <line5> int[] bids = new int[1]; <line6> int i = 0; <line7> AudioBuffer b; <line8> while ((b = audioBuffers.poll()) != null) { <line9> if (b instanceof JoalAudioBuffer) { <line10> bids[0] = ((JoalAudioBuffer) b).getDataStorageBuffer()[0]; <line11> } else { <line12> throw new IllegalArgumentException(b.getSystemName() + "" is not a JoalAudioBuffer""); <line13> } <line14> al.alSourceQueueBuffers(_source[0], 1, bids, 0); <line15> if (log.isDebugEnabled()) { <line16> } <line17> i++; <line18> if (JoalAudioFactory.checkALError()) { <line19> return false; <line20> } <line21> } <line22> return true; <line23> } <line24> } <line25> "	 <line16>	Yes
public class A { <line0> @Verify(global = false) <line1> public void verify() { <line2> EventCount total = new EventCount(); <line3> for (EventCount eventCount : eventCounts) { <line4> total.add(eventCount); <line5> } <line6> total.waitWhileListenerEventsIncrease(listener, 10); <line7> total.assertEventsEquals(listener); <line8> } <line9> } <line10> 	 <line8>	No
"public class A { <line0> public static java.util.List<com.liferay.social.kernel.model.SocialActivity> getActivities( <line1> HttpPrincipal httpPrincipal, long classNameId, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SocialActivityServiceUtil.class, ""getActivities"", _getActivitiesParameterTypes0); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, classNameId, start, end); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (java.util.List<com.liferay.social.kernel.model.SocialActivity>) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	 <line8>	No
public class A { <line0> public void onComplete(Void o) { <line1> createInterpreter_result result = new createInterpreter_result(); <line2> try { <line3> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line4> return; <line5> } catch (Exception e) { <line6> } <line7> fb.close(); <line8> } <line9> } <line10> 	 <line0>	No
"public class A { <line0> private boolean httpPostSend(String successCode, String urlPrefix, String content) { <line1> URL url = null; <line2> InputStream in = null; <line3> OutputStreamWriter writer = null; <line4> URLConnection conn = null; <line5> boolean sendSuccess = false; <line6> try { <line7> url = new URL(urlPrefix); <line8> conn = url.openConnection(); <line9> conn.setConnectTimeout(2000); <line10> conn.setReadTimeout(3000); <line11> conn.setDoOutput(true); <line12> conn.setDoInput(true); <line13> conn.setRequestProperty(""content-type"", ""application/x-www-form-urlencoded;charset=UTF-8""); <line14> writer = new OutputStreamWriter(conn.getOutputStream()); <line15> writer.write(content); <line16> writer.flush(); <line17> in = conn.getInputStream(); <line18> StringBuilder sb = new StringBuilder(); <line19> sb.append(Files.forIO().readFrom(in, ""utf-8"")).append(""""); <line20> if (sb.toString().contains(successCode)) { <line21> sendSuccess = true; <line22> return true; <line23> } else { <line24> return false; <line25> } <line26> } catch (Exception e) { <line27> return false; <line28> } finally { <line29> try { <line30> if (in != null) { <line31> in.close(); <line32> } <line33> if (writer != null) { <line34> writer.close(); <line35> } <line36> } catch (IOException e) { <line37> } <line38> if (!sendSuccess) { <line39> recordSendLog(urlPrefix, content); <line40> } <line41> } <line42> } <line43> } <line44> "	 <line10>	No
public class A { <line0> public void setOffStatus() { <line1> if (mgrOK()) { <line2> try { <line3> p.setPower(PowerManager.OFF); <line4> } catch (JmriException e) { <line5> try { <line6> sendErrorStatus(); <line7> } catch (IOException ie) { <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	 <line1>	No
"public class A { <line0> @Override <line1> public Answer create(TestCaseCountryProperties testCaseCountryProperties) { <line2> MessageEvent msg = null; <line3> StringBuilder query = new StringBuilder(); <line4> query.append( <line5> ""INSERT INTO testcasecountryproperties"" <line6> + "" (`Test`,`TestCase`,`Country`,`Property`,`Description`,`Type`""); <line7> query.append( <line8> "",`Database`,`Value1`,`Value2`,`Length`,`RowLimit`,`Nature`,`RetryNb`,`RetryPeriod`,`CacheExpire`,`Rank`,"" <line9> + "" `UsrCreated`)""); <line10> query.append(""VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""); <line11> loggingQuery(query.toString()); <line12> try (Connection connection = this.databaseSpring.connect(); <line13> PreparedStatement preStat = connection.prepareStatement(query.toString()); ) { <line14> int i = 1; <line15> preStat.setString(i++, testCaseCountryProperties.getTest()); <line16> preStat.setString(i++, testCaseCountryProperties.getTestcase()); <line17> preStat.setString(i++, testCaseCountryProperties.getCountry()); <line18> preStat.setString(i++, testCaseCountryProperties.getProperty()); <line19> preStat.setString(i++, testCaseCountryProperties.getDescription()); <line20> preStat.setString(i++, testCaseCountryProperties.getType()); <line21> preStat.setString(i++, testCaseCountryProperties.getDatabase()); <line22> preStat.setString(i++, testCaseCountryProperties.getValue1()); <line23> preStat.setString(i++, testCaseCountryProperties.getValue2()); <line24> preStat.setString(i++, testCaseCountryProperties.getLength()); <line25> preStat.setInt(i++, testCaseCountryProperties.getRowLimit()); <line26> preStat.setString(i++, testCaseCountryProperties.getNature()); <line27> preStat.setInt(i++, testCaseCountryProperties.getRetryNb()); <line28> preStat.setInt(i++, testCaseCountryProperties.getRetryPeriod()); <line29> preStat.setInt(i++, testCaseCountryProperties.getCacheExpire()); <line30> preStat.setInt(i++, testCaseCountryProperties.getRank()); <line31> preStat.setString( <line32> i++, <line33> testCaseCountryProperties.getUsrCreated() == null <line34> ? """" <line35> : testCaseCountryProperties.getUsrCreated()); <line36> preStat.executeUpdate(); <line37> msg = successExecuteQuery(OBJECT_NAME, ""INSERT""); <line38> } catch (SQLException exception) { <line39> if (exception.getSQLState().equals(SQL_DUPLICATED_CODE)) { <line40> msg = new MessageEvent(MessageEventEnum.DATA_OPERATION_ERROR_DUPLICATE); <line41> msg.setDescription( <line42> msg.getDescription() <line43> .replace(""%ITEM%"", OBJECT_NAME) <line44> .replace(""%OPERATION%"", ""INSERT"") <line45> .replace(""%REASON%"", exception.toString())); <line46> } else { <line47> msg = unexpectedError(exception); <line48> } <line49> } <line50> return new Answer(msg); <line51> } <line52> } <line53> "	 <line40>	Yes
"public class A { <line0> @Override <line1> public InputStream read(DataIdentifier identifier) throws DataStoreException { <line2> long start = System.currentTimeMillis(); <line3> String key = getKeyName(identifier); <line4> ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); <line5> try { <line6> Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); <line7> S3Object object = s3service.getObject(bucket, key); <line8> InputStream in = object.getObjectContent(); <line9> if (LOG_STREAMS_DOWNLOAD.isDebugEnabled()) { <line10> } <line11> return in; <line12> } catch (AmazonServiceException e) { <line13> throw new DataStoreException(""Object not found: "" + key, e); <line14> } finally { <line15> if (contextClassLoader != null) { <line16> Thread.currentThread().setContextClassLoader(contextClassLoader); <line17> } <line18> } <line19> } <line20> } <line21> "	 <line10>	Yes
public class A { <line0> @Override <line1> public void start() throws GridException { <line2> Map<GridPredicate<? extends GridEvent>, int[]> evtLsnrs = ctx.config().getLocalEventListeners(); <line3> if (evtLsnrs != null) { <line4> for (GridPredicate<? extends GridEvent> lsnr : evtLsnrs.keySet()) <line5> addLocalEventListener(lsnr, evtLsnrs.get(lsnr)); <line6> } <line7> startSpi(); <line8> msgLsnr = new RequestListener(); <line9> ctx.io().addMessageListener(TOPIC_EVENT, msgLsnr); <line10> } <line11> } <line12> 	 <line10>	Yes
"public class A { <line0> @Override <line1> public void handle( <line2> String target, <line3> HttpServletRequest request, <line4> HttpServletResponse response, <line5> boolean[] isHandled) { <line6> if (target.lastIndexOf('.') != -1) { <line7> return; <line8> } <line9> isHandled[0] = true; <line10> String[] urlPara = {null}; <line11> Action action = getAction(target, urlPara, request); <line12> if (action == null) { <line13> if (LOG.isWarnEnabled()) { <line14> String qs = request.getQueryString(); <line15> } <line16> renderManager.getRenderFactory().getErrorRender(404).setContext(request, response).render(); <line17> return; <line18> } <line19> Controller controller = null; <line20> try { <line21> controller = controllerFactory.getController(action.getControllerClass()); <line22> CPI._init_(controller, action, request, response, urlPara[0]); <line23> JbootControllerContext.hold(controller); <line24> Invocation invocation = getInvocation(action, controller); <line25> if (JbootActionReporter.isReportEnable()) { <line26> long time = System.currentTimeMillis(); <line27> try { <line28> doStartRender(target, request, response, isHandled, action, controller, invocation); <line29> } finally { <line30> JbootActionReporter.report(target, controller, action, invocation, time); <line31> } <line32> } else { <line33> doStartRender(target, request, response, isHandled, action, controller, invocation); <line34> } <line35> } catch (RenderException e) { <line36> if (LOG.isErrorEnabled()) { <line37> String qs = request.getQueryString(); <line38> } <line39> } catch (ActionException e) { <line40> handleActionException(target, request, response, action, e); <line41> } catch (ValidException e) { <line42> handleValidException(target, request, response, action, e); <line43> } catch (Exception e) { <line44> if (LOG.isErrorEnabled()) { <line45> String qs = request.getQueryString(); <line46> String targetInfo = qs == null ? target : target + ""?"" + qs; <line47> String info = ClassUtil.buildMethodString(action.getMethod()); <line48> } <line49> renderManager <line50> .getRenderFactory() <line51> .getErrorRender(500) <line52> .setContext(request, response, action.getViewPath()) <line53> .render(); <line54> } finally { <line55> JbootControllerContext.release(); <line56> controllerFactory.recycle(controller); <line57> } <line58> } <line59> } <line60> "	 <line20>	No
"public class A { <line0> @Test(groups = ""Live"") <line1> public void testEnvVarResolution() throws Exception { <line2> List<String> yaml = Lists.newArrayList(); <line3> yaml.addAll(yamlLocation); <line4> String in = ""%KEY1%: %ADDR_RESOLVED%""; <line5> yaml.addAll( <line6> ImmutableList.of( <line7> ""services:"", <line8> ""  - type: org.apache.brooklyn.entity.software.base.VanillaWindowsProcess"", <line9> ""    brooklyn.config:"", <line10> ""      install.command: "" + JavaStringEscapes.wrapJavaString(""echo "" + in), <line11> ""      customize.command: "" + JavaStringEscapes.wrapJavaString(""echo "" + in), <line12> ""      launch.command: "" + JavaStringEscapes.wrapJavaString(""echo "" + in), <line13> ""      stop.command: echo true"", <line14> ""      checkRunning.command: echo true"", <line15> ""      shell.env:"", <line16> ""        KEY1: Address"", <line17> ""        ADDR_RESOLVED: $brooklyn:attributeWhenReady(\""host.address\"")"")); <line18> app = createAndStartApplication(Joiner.on(""\n"").join(yaml)); <line19> waitForApplicationTasks(app); <line20> Dumper.dumpInfo(app); <line21> Entity win = Iterables.getOnlyElement(app.getChildren()); <line22> String out = ""Address: "" + win.sensors().get(SoftwareProcess.ADDRESS); <line23> assertPhaseStreamSatisfies(win, ""install"", ""stdout"", Predicates.equalTo(in)); <line24> assertPhaseStreamSatisfies(win, ""customize"", ""stdout"", Predicates.equalTo(out)); <line25> assertPhaseStreamSatisfies(win, ""launch"", ""stdout"", Predicates.equalTo(out)); <line26> } <line27> } <line28> "	 <line20>	Yes
"public class A { <line0> @Override <line1> public void run() { <line2> MixedOperation<Pod, PodList, PodResource<Pod>> w = getEndpoint().getKubernetesClient().pods(); <line3> if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getNamespace())) { <line4> w.inNamespace(getEndpoint().getKubernetesConfiguration().getNamespace()); <line5> } <line6> if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getLabelKey()) <line7> && ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getLabelValue())) { <line8> w.withLabel( <line9> getEndpoint().getKubernetesConfiguration().getLabelKey(), <line10> getEndpoint().getKubernetesConfiguration().getLabelValue()); <line11> } <line12> if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getResourceName())) { <line13> w.withName(getEndpoint().getKubernetesConfiguration().getResourceName()); <line14> } <line15> watch = <line16> w.watch( <line17> new Watcher<Pod>() { <line18> @Override <line19> public void eventReceived( <line20> io.fabric8.kubernetes.client.Watcher.Action action, Pod resource) { <line21> PodEvent pe = new PodEvent(action, resource); <line22> Exchange exchange = createExchange(false); <line23> exchange.getIn().setBody(pe.getPod()); <line24> exchange <line25> .getIn() <line26> .setHeader(KubernetesConstants.KUBERNETES_EVENT_ACTION, pe.getAction()); <line27> exchange <line28> .getIn() <line29> .setHeader( <line30> KubernetesConstants.KUBERNETES_EVENT_TIMESTAMP, System.currentTimeMillis()); <line31> try { <line32> processor.process(exchange); <line33> } catch (Exception e) { <line34> getExceptionHandler().handleException(""Error during processing"", exchange, e); <line35> } finally { <line36> releaseExchange(exchange, false); <line37> } <line38> } <line39>  <line40> @Override <line41> public void onClose(WatcherException cause) { <line42> if (cause != null) { <line43> } <line44> } <line45> }); <line46> } <line47> } <line48> "	 <line45>	No
"public class A { <line0> private Path sendSingleDocument(ObjectOutputStream out, EDoc eDoc, Integer demographicId) <line1> throws IOException, ParseException { <line2> Path documentPath = <line3> Paths.get( <line4> OscarProperties.getInstance().getProperty(""DOCUMENT_DIR"") <line5> + File.separator <line6> + eDoc.getFileName()); <line7> if (!Files.exists(documentPath)) { <line8> return null; <line9> } <line10> CachedDemographicDocument cachedDemographicDocument = new CachedDemographicDocument(); <line11> FacilityIdIntegerCompositePk facilityIdIntegerCompositePk = new FacilityIdIntegerCompositePk(); <line12> facilityIdIntegerCompositePk.setCaisiItemId(Integer.parseInt(eDoc.getDocId())); <line13> cachedDemographicDocument.setFacilityIntegerPk(facilityIdIntegerCompositePk); <line14> if (eDoc.getAppointmentNo() != null) { <line15> cachedDemographicDocument.setAppointmentNo(eDoc.getAppointmentNo()); <line16> } <line17> cachedDemographicDocument.setCaisiDemographicId(demographicId); <line18> cachedDemographicDocument.setContentType(eDoc.getContentType()); <line19> cachedDemographicDocument.setDocCreator(eDoc.getCreatorId()); <line20> cachedDemographicDocument.setDocFilename(eDoc.getFileName()); <line21> cachedDemographicDocument.setDocType(eDoc.getType()); <line22> cachedDemographicDocument.setDocXml(eDoc.getHtml()); <line23> cachedDemographicDocument.setNumberOfPages(eDoc.getNumberOfPages()); <line24> cachedDemographicDocument.setObservationDate( <line25> org.oscarehr.util.DateUtils.parseIsoDateAsCalendar(eDoc.getObservationDate()).getTime()); <line26> cachedDemographicDocument.setProgramId(eDoc.getProgramId()); <line27> cachedDemographicDocument.setPublic1(Integer.parseInt(eDoc.getDocPublic())); <line28> cachedDemographicDocument.setResponsible(eDoc.getResponsibleId()); <line29> cachedDemographicDocument.setReviewDateTime(eDoc.getReviewDateTimeDate()); <line30> cachedDemographicDocument.setReviewer(eDoc.getReviewerId()); <line31> cachedDemographicDocument.setSource(eDoc.getSource()); <line32> cachedDemographicDocument.setStatus("""" + eDoc.getStatus()); <line33> cachedDemographicDocument.setUpdateDateTime(eDoc.getDateTimeStampAsDate()); <line34> cachedDemographicDocument.setDescription(eDoc.getDescription()); <line35> out.writeUnshared(cachedDemographicDocument); <line36> return documentPath; <line37> } <line38> } <line39> "	 <line1>	No
public class A { <line0> public static com.liferay.portal.kernel.model.AddressSoap addAddress( <line1> String className, <line2> long classPK, <line3> String street1, <line4> String street2, <line5> String street3, <line6> String city, <line7> String zip, <line8> long regionId, <line9> long countryId, <line10> long typeId, <line11> boolean mailing, <line12> boolean primary, <line13> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line14> throws RemoteException { <line15> try { <line16> com.liferay.portal.kernel.model.Address returnValue = <line17> AddressServiceUtil.addAddress( <line18> className, <line19> classPK, <line20> street1, <line21> street2, <line22> street3, <line23> city, <line24> zip, <line25> regionId, <line26> countryId, <line27> typeId, <line28> mailing, <line29> primary, <line30> serviceContext); <line31> return com.liferay.portal.kernel.model.AddressSoap.toSoapModel(returnValue); <line32> } catch (Exception exception) { <line33> throw new RemoteException(exception.getMessage()); <line34> } <line35> } <line36> } <line37> 	 <line33>	Yes
public class A { <line0> @Override <line1> public void resetModel(Resource resource) throws ResourceException { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> protected void closeTdbDS() { <line1> if (getTdbDS(false) != null) { <line2> while (tdbDS.isInTransaction()) { <line3> } <line4> TDB.sync(tdbDS); <line5> tdbDS.close(); <line6> TDB.closedown(); <line7> setTdbDS(null); <line8> } <line9> } <line10> } <line11> 	 <line3>	Yes
public class A { <line0> @Override <line1> @PreDestroy <line2> public void close() { <line3> super.close(); <line4> try { <line5> indexWriter.close(); <line6> } catch (IOException e) { <line7> } <line8> } <line9> } <line10> 	 <line4>	No
"public class A { <line0> @Override <line1> public Attributes getUserAttributes( <line2> long ldapServerId, <line3> long companyId, <line4> SafeLdapContext safeLdapContext, <line5> SafeLdapName userSafeLdapName) <line6> throws Exception { <line7> Properties userMappings = _ldapSettings.getUserMappings(ldapServerId, companyId); <line8> Properties userExpandoMappings = _ldapSettings.getUserExpandoMappings(ldapServerId, companyId); <line9> PropertiesUtil.merge(userMappings, userExpandoMappings); <line10> Properties contactMappings = _ldapSettings.getContactMappings(ldapServerId, companyId); <line11> PropertiesUtil.merge( <line12> contactMappings, _ldapSettings.getContactExpandoMappings(ldapServerId, companyId)); <line13> PropertiesUtil.merge(userMappings, contactMappings); <line14> Collection<Object> values = userMappings.values(); <line15> values.removeIf(Validator::isNull); <line16> String[] mappedUserAttributeIds = <line17> ArrayUtil.toStringArray(values.toArray(new Object[userMappings.size()])); <line18> Attributes attributes = <line19> _getAttributes(safeLdapContext, userSafeLdapName, mappedUserAttributeIds); <line20> if (_log.isDebugEnabled()) { <line21> if ((attributes == null) || (attributes.size() == 0)) { <line22> } else { <line23> for (String attributeId : mappedUserAttributeIds) { <line24> Attribute attribute = attributes.get(attributeId); <line25> if (attribute == null) { <line26> continue; <line27> } <line28> String attributeID = StringUtil.toLowerCase(attribute.getID()); <line29> if (attributeID.indexOf(""password"") > -1) { <line30> Attribute clonedAttribute = (Attribute) attribute.clone(); <line31> clonedAttribute.clear(); <line32> clonedAttribute.add(""********""); <line33> continue; <line34> } <line35> } <line36> } <line37> } <line38> return attributes; <line39> } <line40> } <line41> "	 <line22>	Yes
public class A { <line0> protected void initWithJNDI(final String jndiName) { <line1> try { <line2> IDBDatasourceService datasourceService = <line3> PentahoSystem.getObjectFactory().get(IDBDatasourceService.class, null); <line4> DataSource dataSource = datasourceService.getDataSource(jndiName); <line5> if (dataSource != null) { <line6> nativeConnection = captureConnection(dataSource.getConnection()); <line7> if (nativeConnection == null) { <line8> datasourceService.clearDataSource(jndiName); <line9> } else { <line10> enhanceConnection(nativeConnection); <line11> } <line12> } else { <line13> datasourceService.clearDataSource(jndiName); <line14> } <line15> } catch (Exception e) { <line16> close(); <line17> try { <line18> IDBDatasourceService datasourceService = <line19> PentahoSystem.getObjectFactory().get(IDBDatasourceService.class, null); <line20> datasourceService.clearDataSource(jndiName); <line21> } catch (ObjectFactoryException objface) { <line22> } <line23> } <line24> } <line25> } <line26> 	 <line18>	No
public class A { <line0> private void executeEvent(final Collection<DataTreeModification<Subnet>> changes) { <line1> for (DataTreeModification<Subnet> change : changes) { <line2> DataObjectModification<Subnet> rootNode = change.getRootNode(); <line3> switch (rootNode.getModificationType()) { <line4> case SUBTREE_MODIFIED: <line5> case WRITE: <line6> Subnet updatedSubnet = rootNode.getDataAfter(); <line7> ulnDatastoreUtil.submitSubnetToDs(initSubnetBuilder(updatedSubnet).build()); <line8> break; <line9> case DELETE: <line10> Subnet deletedSubnet = rootNode.getDataBefore(); <line11> ReadWriteTransaction rwTx = dataProvider.newReadWriteTransaction(); <line12> Optional<MappedSubnet> op = <line13> DataStoreHelper.removeIfExists( <line14> LogicalDatastoreType.OPERATIONAL, <line15> FaasIidFactory.mappedSubnetIid(gbpTenantId, deletedSubnet.getId()), <line16> rwTx); <line17> if (op.isPresent()) { <line18> DataStoreHelper.submitToDs(rwTx); <line19> } <line20> Uuid faasSubnetId = mappedSubnets.remove(deletedSubnet.getId()); <line21> if (faasSubnetId != null) { <line22> ulnDatastoreUtil.removeSubnetFromDsIfExists(faasTenantId, faasSubnetId); <line23> } <line24> break; <line25> default: <line26> break; <line27> } <line28> } <line29> } <line30> } <line31> 	 <line3>	No
public class A { <line0> protected String assertTableIsRegistered( <line1> String fullTableName, AssertPredicate assertPredicate, boolean isTemporary) throws Exception { <line2> String tableQualifiedName = <line3> (fullTableName + AtlasImpalaHookContext.QNAME_SEP_METADATA_NAMESPACE).toLowerCase() <line4> + CLUSTER_NAME; <line5> return assertEntityIsRegistered( <line6> HIVE_TYPE_TABLE, REFERENCEABLE_ATTRIBUTE_NAME, tableQualifiedName, assertPredicate); <line7> } <line8> } <line9> 	 <line2>	Yes
"public class A { <line0> protected int update( <line1> final PreparedStatementCreator psc, <line2> final PreparedStatementSetter pss, <line3> final KeyHolder generatedKeyHolder) <line4> throws DataAccessException { <line5> if (logger.isDebugEnabled()) { <line6> } <line7> Integer result = <line8> execute( <line9> psc, <line10> new PreparedStatementCallback<Integer>() { <line11> @Override <line12> @SuppressWarnings(""synthetic-access"") <line13> public Integer doInPreparedStatement(PreparedStatement ps) throws SQLException { <line14> try { <line15> if (pss != null) { <line16> pss.setValues(ps); <line17> } <line18> int rows = ps.executeUpdate(); <line19> List<Map<String, Object>> generatedKeys = generatedKeyHolder.getKeyList(); <line20> generatedKeys.clear(); <line21> ResultSet keys = ps.getGeneratedKeys(); <line22> if (keys != null) { <line23> try { <line24> RowMapper<Map<String, Object>> rowMapper = getColumnMapRowMapperImpl(); <line25> RowMapperResultSetExtractor<Map<String, Object>> rse = <line26> new RowMapperResultSetExtractor<Map<String, Object>>(rowMapper, 1); <line27> generatedKeys.addAll(rse.extractData(keys)); <line28> } finally { <line29> JdbcUtils.closeResultSet(keys); <line30> } <line31> } <line32> if (logger.isDebugEnabled()) <line33> return Integer.valueOf(rows); <line34> } finally { <line35> if (pss instanceof ParameterDisposer) { <line36> ((ParameterDisposer) pss).cleanupParameters(); <line37> } <line38> } <line39> } <line40> }); <line41> return result.intValue(); <line42> } <line43> } <line44> "	 <line33>	Yes
public class A { <line0> @Override <line1> public void done(boolean doneSync) { <line2> org.apache.camel.Message body = null; <line3> Exception cause = null; <line4> RuntimeCamelException rce = null; <line5> if (exchange.isFailed() || exchange.isRollbackOnly()) { <line6> if (exchange.isRollbackOnly()) { <line7> rce = wrapRuntimeCamelException(new RollbackExchangeException(exchange)); <line8> } else if (exchange.getException() != null) { <line9> if (endpoint.isTransferException()) { <line10> body = null; <line11> cause = exchange.getException(); <line12> } else { <line13> rce = wrapRuntimeCamelException(exchange.getException()); <line14> } <line15> } <line16> } else { <line17> if (sendReply && exchange.getPattern().isOutCapable()) { <line18> if (exchange.hasOut()) { <line19> body = exchange.getOut(); <line20> } else { <line21> body = exchange.getIn(); <line22> } <line23> cause = null; <line24> } <line25> } <line26> if (rce == null && sendReply && (body != null || cause != null)) { <line27> if (replyDestination instanceof Destination) { <line28> sendReply((Destination) replyDestination, message, exchange, body, cause); <line29> } else { <line30> sendReply((String) replyDestination, message, exchange, body, cause); <line31> } <line32> } <line33> if (rce != null) { <line34> if (doneSync) { <line35> exchange.setException(rce); <line36> } else { <line37> if (endpoint.getErrorHandler() != null) { <line38> endpoint.getErrorHandler().handleError(rce); <line39> } <line40> } <line41> } <line42> if (!doneSync) { <line43> consumer.releaseExchange(exchange, false); <line44> } <line45> } <line46> } <line47> 	 <line41>	No
"public class A { <line0> private ResponseData createResponseDataRecord( <line1> final Map<String, String> settings, final ResponseDataRepository responseDataRepository) { <line2> ResponseData responseData = new ResponseDataBuilder().fromSettings(settings).build(); <line3> responseData = responseDataRepository.save(responseData); <line4> ScenarioContext.current() <line5> .put(PlatformKeys.KEY_CORRELATION_UID, responseData.getCorrelationUid()); <line6> try { <line7> if (settings.containsKey(PlatformKeys.KEY_CREATION_TIME)) { <line8> final Field fld = responseData.getClass().getSuperclass().getDeclaredField(""creationTime""); <line9> fld.setAccessible(true); <line10> fld.set( <line11> responseData, <line12> DateTimeHelper.getDateTime(settings.get(PlatformKeys.KEY_CREATION_TIME)).toDate()); <line13> responseDataRepository.saveAndFlush(responseData); <line14> } <line15> } catch (final Exception e) { <line16> Assertions.fail(""Failed to create response data record.""); <line17> } <line18> return responseData; <line19> } <line20> } <line21> "	 <line16>	Yes
public class A { <line0> private void processGroups( <line1> MappingResult result, EntityParam principal, Set<Attribute> processedAttributes) <line2> throws EngineException { <line3> Map<String, List<Attribute>> attributesByGroup = getAttributesByGroup(result); <line4> Map<String, GroupMembership> currentGroups = idsMan.getGroups(principal); <line5> Set<String> currentSimple = new HashSet<>(currentGroups.keySet()); <line6> for (MappedGroup gm : result.getGroups()) { <line7> if (!currentGroups.containsKey(gm.getGroup())) { <line8> Deque<String> missingGroups = Group.getMissingGroups(gm.getGroup(), currentSimple); <line9> addToGroupRecursive( <line10> principal, <line11> missingGroups, <line12> currentSimple, <line13> gm.getIdp(), <line14> gm.getProfile(), <line15> gm.getCreateIfMissing(), <line16> attributesByGroup, <line17> processedAttributes); <line18> } else { <line19> } <line20> } <line21> if (result.isCleanStaleGroups()) removeStaleMemberships(currentGroups, result, principal); <line22> } <line23> } <line24> 	 <line1>	No
"public class A { <line0> @ApiOperation(""Alias of /{id}/record, returns the tracking record for the specified key"") <line1> @ApiResponses({ <line2> @ApiResponse(code = 404, message = ""No such tracking record exists.""), <line3> @ApiResponse(code = 200, message = ""Tracking record"", response = TrackedContentDTO.class), <line4> }) <line5> @Path(""/{id}/report"") <line6> @GET <line7> public Response getReport( <line8> @ApiParam(""User-assigned tracking session key"") final @PathParam(""id"") String id, <line9> @Context final UriInfo uriInfo) { <line10> Response response; <line11> try { <line12> final String baseUrl = uriInfo.getBaseUriBuilder().path(""api"").build().toString(); <line13> final TrackedContentDTO report = controller.renderReport(id, baseUrl); <line14> if (report == null) { <line15> response = Response.status(Status.NOT_FOUND).build(); <line16> } else { <line17> response = responseHelper.formatOkResponseWithJsonEntity(report); <line18> } <line19> } catch (final IndyWorkflowException e) { <line20> response = responseHelper.formatResponse(e); <line21> } <line22> return response; <line23> } <line24> } <line25> "	 <line20>	Yes
public class A { <line0> public void setIsCADIUp(HealthCheckInfo.HealthCheckStatus cadiStatus) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> isCADIUpOrDown = cadiStatus; <line4> } <line5> } <line6> 	 <line1>	No
"public class A { <line0> public String getDiagram(Properties properties) { <line1> final String configId = properties.getProperty(""configId""); <line2> if (null != configId) { <line3> try { <line4> final BpmWidgetInfo bpmWidgetInfo = <line5> bpmWidgetInfoManager.getBpmWidgetInfo(Integer.parseInt(configId)); <line6> final String information = bpmWidgetInfo.getInformationDraft(); <line7> if (StringUtils.isNotEmpty(information)) { <line8> final ApsProperties config = new ApsProperties(); <line9> config.loadFromXml(information); <line10> String knowledgetSource = <line11> (String) config.get(KieBpmSystemConstants.WIDGET_INFO_PROP_KIE_SOURCE_ID); <line12> KieBpmConfig bpmConfig = <line13> this.getKieFormManager().getKieServerConfigurations().get(knowledgetSource); <line14> final String containerId = config.getProperty(""containerId""); <line15> final String processInstanceId = properties.getProperty(""processInstanceId""); <line16> return this.getKieFormManager() <line17> .getProcInstDiagramImage(bpmConfig, containerId, processInstanceId); <line18> } <line19> } catch (ApsSystemException e) { <line20> } catch (IOException e) { <line21> } catch (Throwable ex) { <line22> } <line23> } <line24> return """"; <line25> } <line26> } <line27> "	 <line21>	Yes
public class A { <line0> @Override <line1> public int count(final Set<String> adminRealms, final SearchCond cond, final AnyTypeKind kind) { <line2> if (adminRealms == null || adminRealms.isEmpty()) { <line3> return 0; <line4> } <line5> if (cond == null || !cond.isValid()) { <line6> return 0; <line7> } <line8> return doCount(adminRealms, cond, kind); <line9> } <line10> } <line11> 	 <line2>	No
public class A { <line0> public boolean deleteSeriesSynchronously(String seriesId) throws SearchException { <line1> SearchResult result; <line2> try { <line3> SearchQuery searchQuery = new SearchQuery(); <line4> searchQuery.withId(seriesId); <line5> searchQuery.includeSeries(true); <line6> result = solrRequester.getForWrite(searchQuery); <line7> if (result.getItems().length == 0) { <line8> return false; <line9> } <line10> Date now = new Date(); <line11> return indexManager.delete(seriesId, now); <line12> } catch (SolrServerException e) { <line13> throw new SearchException(e); <line14> } <line15> } <line16> } <line17> 	 <line0>	No
"public class A { <line0> @Override <line1> public Resource getAppResource(App app, String pageName) throws IOException { <line2> if (app == null || !app.getAppStorageSource().equals(AppStorageSource.JCLOUDS)) { <line3> return null; <line4> } <line5> String key = (app.getFolderName() + (""/"" + pageName)).replaceAll(""//"", ""/""); <line6> URI uri = getSignedGetContentUri(key); <line7> if (uri == null) { <line8> String filepath = <line9> configurationProvider.getProperty(ConfigurationKey.FILESTORE_CONTAINER) + ""/"" + key; <line10> filepath = filepath.replaceAll(""//"", ""/""); <line11> File res; <line12> try { <line13> res = locationManager.getFileForReading(filepath); <line14> } catch (LocationManagerException e) { <line15> return null; <line16> } <line17> if (res.isDirectory()) { <line18> String indexPath = pageName.replaceAll(""/+$"", """") + ""/index.html""; <line19> return getAppResource(app, indexPath); <line20> } else if (res.exists()) { <line21> return new FileSystemResource(res); <line22> } else { <line23> return null; <line24> } <line25> } <line26> return new UrlResource(uri); <line27> } <line28> } <line29> "	 <line3>	Yes
public class A { <line0> protected static void writeWarn(String msg) { <line1> if (LOG.isWarnEnabled()) { <line2> } <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void setPermissions(final Set<PosixFilePermission> perms) throws IOException { <line2> if (file == null) { <line3> return; <line4> } <line5> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line6> file.setProperty( <line7> AbstractNode.visibleToAuthenticatedUsers, perms.contains(PosixFilePermission.GROUP_READ)); <line8> file.setProperty( <line9> AbstractNode.visibleToPublicUsers, perms.contains(PosixFilePermission.OTHERS_READ)); <line10> tx.success(); <line11> } catch (FrameworkException fex) { <line12> } <line13> } <line14> } <line15> 	 <line12>	Yes
"public class A { <line0> public void copyDmlToClipboard() { <line1> try { <line2> XulTextbox dmlField = (XulTextbox) document.getElementById(ELEM_ID_DML_FIELD); <line3> Assert.notNull(dmlField, ""could not find element with id '"" + ELEM_ID_DML_FIELD + ""'""); <line4> ((XulWindow) document.getRootElement()).copy(dmlField.getValue()); <line5> } catch (XulException e) { <line6> if (logger.isErrorEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> "	 <line7>	Yes
public class A { <line0> @Override <line1> @Transactional(readOnly = true) <line2> public List<Alert> getAlerts(User user, boolean includeRead, boolean includeExpired) <line3> throws APIException { <line4> return dao.getAlerts(user, includeRead, includeExpired); <line5> } <line6> } <line7> 	 <line6>	No
"public class A { <line0> public List findByExample(NZielobjZielobj instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.NZielobjZielobj"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line11>	No
"public class A { <line0> private void checkSupportedColumns(List<String> csvHeaders, List<String> supportedHeaders) { <line1> supportedHeaders.forEach( <line2> suppColumn -> { <line3> if (!csvHeaders.contains(suppColumn)) { <line4> throw new ProjectCommonException( <line5> ResponseCode.errorUnsupportedField.getErrorCode(), <line6> ResponseCode.errorUnsupportedField.getErrorMessage(), <line7> ResponseCode.CLIENT_ERROR.getResponseCode(), <line8> ""Invalid provided column:"" <line9> .concat(suppColumn) <line10> .concat("":supported headers are:"") <line11> .concat(ArrayUtils.stringifyContents(supportedHeaders.toArray()))); <line12> } <line13> }); <line14> } <line15> } <line16> "	 <line1>	Yes
public class A { <line0> @Override <line1> public ExceptionPolicyKey getExceptionPolicy( <line2> Set<ExceptionPolicyKey> exceptionPolicies, Exchange exchange, Throwable exception) { <line3> Map<Integer, ExceptionPolicyKey> candidates = new TreeMap<>(); <line4> Set<ExceptionPolicyKey> routeScoped = new LinkedHashSet<>(); <line5> Set<ExceptionPolicyKey> contextScoped = new LinkedHashSet<>(); <line6> initRouteAndContextScopedExceptionPolicies(exceptionPolicies, routeScoped, contextScoped); <line7> Iterable<Throwable> throwables = createExceptionIterable(exception); <line8> boolean exactMatch = false; <line9> Iterator<Throwable> it = throwables.iterator(); <line10> while (!exactMatch && it.hasNext()) { <line11> exactMatch = findMatchedExceptionPolicy(routeScoped, exchange, it.next(), candidates); <line12> } <line13> it = throwables.iterator(); <line14> while (!exactMatch && it.hasNext()) { <line15> exactMatch = findMatchedExceptionPolicy(contextScoped, exchange, it.next(), candidates); <line16> } <line17> if (candidates.isEmpty()) { <line18> return null; <line19> } else { <line20> return candidates.values().iterator().next(); <line21> } <line22> } <line23> } <line24> 	 <line17>	Yes
"public class A { <line0> @Before <line1> public void setup() throws Exception { <line2> projectId = getTestProperty(BigtableOptionsFactory.PROJECT_ID_KEY); <line3> instanceId = getTestProperty(BigtableOptionsFactory.INSTANCE_ID_KEY); <line4> dataflowStagingLocation = getTestProperty(GOOGLE_DATAFLOW_STAGING_LOCATION); <line5> region = getTestProperty(DATAFLOW_REGION); <line6> String cloudTestDataFolder = getTestProperty(CLOUD_TEST_DATA_FOLDER); <line7> if (!cloudTestDataFolder.endsWith(File.separator)) { <line8> cloudTestDataFolder = cloudTestDataFolder + File.separator; <line9> } <line10> hbaseSnapshotDir = cloudTestDataFolder + ""data/""; <line11> UUID test_uuid = UUID.randomUUID(); <line12> hashDir = cloudTestDataFolder + ""hashtable/""; <line13> syncTableOutputDir = dataflowStagingLocation; <line14> if (!syncTableOutputDir.endsWith(File.separator)) { <line15> syncTableOutputDir = syncTableOutputDir + File.separator; <line16> } <line17> syncTableOutputDir = syncTableOutputDir + ""sync-table-output/"" + test_uuid + ""/""; <line18> GcpOptions gcpOptions = PipelineOptionsFactory.create().as(GcpOptions.class); <line19> gcpOptions.setProject(projectId); <line20> gcsUtil = new GcsUtil.GcsUtilFactory().create(gcpOptions); <line21> connection = BigtableConfiguration.connect(projectId, instanceId); <line22> tableId = ""test_"" + UUID.randomUUID().toString(); <line23> String[] keys = new String[] {""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""}; <line24> keySplits = new byte[keys.length][]; <line25> for (int i = 0; i < keys.length; i++) { <line26> keySplits[i] = keys[i].getBytes(); <line27> } <line28> TableName tableName = TableName.valueOf(tableId); <line29> HTableDescriptor descriptor = new HTableDescriptor(tableName); <line30> descriptor.addFamily(new HColumnDescriptor(CF)); <line31> connection.getAdmin().createTable(descriptor, SnapshotTestingUtils.getSplitKeys()); <line32> } <line33> } <line34> "	 <line23>	Yes
"public class A { <line0> public void parse(XMLStreamReader xtr, BpmnModel model) throws Exception { <line1> Interface interfaceObject = new Interface(); <line2> BpmnXMLUtil.addXMLLocation(interfaceObject, xtr); <line3> interfaceObject.setId( <line4> model.getTargetNamespace() + "":"" + xtr.getAttributeValue(null, ATTRIBUTE_ID)); <line5> interfaceObject.setName(xtr.getAttributeValue(null, ATTRIBUTE_NAME)); <line6> interfaceObject.setImplementationRef( <line7> parseMessageRef(xtr.getAttributeValue(null, ATTRIBUTE_IMPLEMENTATION_REF), model)); <line8> boolean readyWithInterface = false; <line9> Operation operation = null; <line10> try { <line11> while (!readyWithInterface && xtr.hasNext()) { <line12> xtr.next(); <line13> if (xtr.isStartElement() && ELEMENT_OPERATION.equals(xtr.getLocalName())) { <line14> operation = new Operation(); <line15> BpmnXMLUtil.addXMLLocation(operation, xtr); <line16> operation.setId( <line17> model.getTargetNamespace() + "":"" + xtr.getAttributeValue(null, ATTRIBUTE_ID)); <line18> operation.setName(xtr.getAttributeValue(null, ATTRIBUTE_NAME)); <line19> operation.setImplementationRef( <line20> parseMessageRef(xtr.getAttributeValue(null, ATTRIBUTE_IMPLEMENTATION_REF), model)); <line21> } else if (xtr.isStartElement() && ELEMENT_IN_MESSAGE.equals(xtr.getLocalName())) { <line22> String inMessageRef = xtr.getElementText(); <line23> if (operation != null && StringUtils.isNotEmpty(inMessageRef)) { <line24> operation.setInMessageRef(parseMessageRef(inMessageRef.trim(), model)); <line25> } <line26> } else if (xtr.isStartElement() && ELEMENT_OUT_MESSAGE.equals(xtr.getLocalName())) { <line27> String outMessageRef = xtr.getElementText(); <line28> if (operation != null && StringUtils.isNotEmpty(outMessageRef)) { <line29> operation.setOutMessageRef(parseMessageRef(outMessageRef.trim(), model)); <line30> } <line31> } else if (xtr.isEndElement() && ELEMENT_OPERATION.equalsIgnoreCase(xtr.getLocalName())) { <line32> if (operation != null && StringUtils.isNotEmpty(operation.getImplementationRef())) { <line33> interfaceObject.getOperations().add(operation); <line34> } <line35> } else if (xtr.isEndElement() && ELEMENT_INTERFACE.equals(xtr.getLocalName())) { <line36> readyWithInterface = true; <line37> } <line38> } <line39> } catch (Exception e) { <line40> } <line41> model.getInterfaces().add(interfaceObject); <line42> } <line43> } <line44> "	 <line40>	Yes
public class A { <line0> private void updateChannel(ChannelUID channelUID) { <line1> String channelGroupId = channelUID.getGroupId(); <line2> switch (channelGroupId) { <line3> case CHANNEL_GROUP_CURRENT_WEATHER: <line4> updateCurrentChannel(channelUID); <line5> break; <line6> case CHANNEL_GROUP_FORECAST_TODAY: <line7> updateDailyForecastChannel(channelUID, 0); <line8> break; <line9> case CHANNEL_GROUP_FORECAST_TOMORROW: <line10> updateDailyForecastChannel(channelUID, 1); <line11> break; <line12> default: <line13> int i; <line14> Matcher hourlyForecastMatcher = <line15> CHANNEL_GROUP_HOURLY_FORECAST_PREFIX_PATTERN.matcher(channelGroupId); <line16> if (hourlyForecastMatcher.find() <line17> && (i = Integer.parseInt(hourlyForecastMatcher.group(1))) >= 1 <line18> && i <= 48) { <line19> updateHourlyForecastChannel(channelUID, i); <line20> break; <line21> } <line22> Matcher dailyForecastMatcher = <line23> CHANNEL_GROUP_DAILY_FORECAST_PREFIX_PATTERN.matcher(channelGroupId); <line24> if (dailyForecastMatcher.find() <line25> && (i = Integer.parseInt(dailyForecastMatcher.group(1))) > 1 <line26> && i <= 8) { <line27> updateDailyForecastChannel(channelUID, i); <line28> break; <line29> } <line30> Matcher alertsMatcher = CHANNEL_GROUP_ALERTS_PREFIX_PATTERN.matcher(channelGroupId); <line31> if (alertsMatcher.find() && (i = Integer.parseInt(alertsMatcher.group(1))) >= 1) { <line32> updateAlertsChannel(channelUID, i); <line33> break; <line34> } <line35> break; <line36> } <line37> } <line38> } <line39> 	 <line35>	Yes
"public class A { <line0> @Test <line1> public void checkAccessWithWrongHostname() { <line2> HttpClient wrongHostnameClient = <line3> makeCustomHttpClient(""client_tls/invalid_hostname_client.jks"", ""invalid_hostname_client""); <line4> checkFailedAccessWrongHostname( <line5> wrongHostnameClient, HttpMethod.GET, config.getCoordinatorTLSUrl()); <line6> checkFailedAccessWrongHostname(wrongHostnameClient, HttpMethod.GET, config.getOverlordTLSUrl()); <line7> checkFailedAccessWrongHostname(wrongHostnameClient, HttpMethod.GET, config.getBrokerTLSUrl()); <line8> checkFailedAccessWrongHostname( <line9> wrongHostnameClient, HttpMethod.GET, config.getHistoricalTLSUrl()); <line10> checkFailedAccessWrongHostname(wrongHostnameClient, HttpMethod.GET, config.getRouterTLSUrl()); <line11> makeRequest( <line12> wrongHostnameClient, HttpMethod.GET, config.getPermissiveRouterTLSUrl() + ""/status"", null); <line13> makeRequest( <line14> wrongHostnameClient, <line15> HttpMethod.GET, <line16> config.getNoClientAuthRouterTLSUrl() + ""/status"", <line17> null); <line18> } <line19> } <line20> "	 <line2>	Yes
public class A { <line0> protected void clearCache() { <line1> this.cache.clear(); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void consume() throws InterruptedException { <line2> DirtyDataEntity dataEntity = queue.take(); <line3> count.incrementAndGet(); <line4> if (count.get() % printLimit == 0) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void info(I18nResource message, Object... params) { <line2> if (!isInfoEnabled()) return; <line3> if (message == null) return; <line4> } <line5> } <line6> 	 <line5>	No
"public class A { <line0> public static String serialize(Object obj) { <line1> String json = null; <line2> try { <line3> json = getMapper().writeValueAsString(obj); <line4> } catch (JsonProcessingException e) { <line5> throw new RuntimeException(""Error serializing object"", e); <line6> } <line7> return json; <line8> } <line9> } <line10> "	 <line5>	Yes
public class A { <line0> public IndexerRequestBufferExecutor getIndexerRequestBufferExecutor() { <line1> String bufferedExecutionMode = _indexerRegistryConfiguration.bufferedExecutionMode(); <line2> IndexerRequestBufferExecutor indexerRequestBufferExecutor = <line3> _indexerRequestBufferExecutors.get(bufferedExecutionMode); <line4> if (indexerRequestBufferExecutor == null) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> indexerRequestBufferExecutor = _defaultIndexerRequestBufferExecutor; <line8> } <line9> return indexerRequestBufferExecutor; <line10> } <line11> } <line12> 	 <line6>	Yes
"public class A { <line0> @Test <line1> public void callSetAndGetGetAttributeEnumeration() { <line2> Enumeration enumerationArg = Enumeration.ENUM_0_VALUE_2; <line3> genericGetterSetterTestMethod(enumerationArg, ""AttributeEnumeration""); <line4> } <line5> } <line6> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Document doc = Http.url(url).get(); <line4> URL videoSourceUrl = new URL(getVideoUrl(doc)); <line5> addURLToDownload(videoSourceUrl, """", """", """", null, getVideoName(), ""mp4""); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> "	 <line7>	Yes
public class A { <line0> @Override <line1> public Position addEntry(byte[] data, int numberOfMessages, int offset, int length) <line2> throws InterruptedException, ManagedLedgerException { <line3> final CountDownLatch counter = new CountDownLatch(1); <line4> class Result { <line5> ManagedLedgerException status = null; <line6> Position position = null; <line7> } <line8> final Result result = new Result(); <line9> asyncAddEntry( <line10> data, <line11> numberOfMessages, <line12> offset, <line13> length, <line14> new AddEntryCallback() { <line15> @Override <line16> public void addComplete(Position position, ByteBuf entryData, Object ctx) { <line17> result.position = position; <line18> counter.countDown(); <line19> } <line20>  <line21> @Override <line22> public void addFailed(ManagedLedgerException exception, Object ctx) { <line23> result.status = exception; <line24> counter.countDown(); <line25> } <line26> }, <line27> null); <line28> counter.await(); <line29> if (result.status != null) { <line30> throw result.status; <line31> } <line32> return result.position; <line33> } <line34> } <line35> 	 <line30>	Yes
public class A { <line0> @Override <line1> public void stop() { <line2> if (this.running.getAndSet(false)) { <line3> this.disconnect(); <line4> if (this.executor != null) { <line5> try { <line6> this.executor.shutdown(); <line7> this.executor.awaitTermination(5L, TimeUnit.SECONDS); <line8> } catch (InterruptedException exception) { <line9> throw new RuntimeException(exception); <line10> } finally { <line11> this.executor.shutdownNow(); <line12> this.executor = null; <line13> } <line14> } <line15> } <line16> } <line17> } <line18> 	 <line3>	Yes
"public class A { <line0> private Short getServerVersion(final HostAndPort address, final int timeout) <line1> throws IOException, ClassNotFoundException { <line2> Short serverVersion = serverVersions.get(address); <line3> if (serverVersion != null) { <line4> return serverVersion; <line5> } <line6> final Socket sock; <line7> try { <line8> sock = socketCreator.forCluster().connect(address, timeout, null, socketFactory); <line9> sock.setSoTimeout(timeout); <line10> } catch (SSLHandshakeException e) { <line11> if ((e.getCause() instanceof EOFException) <line12> && (e.getCause().getMessage().contains(""SSL peer shut down incorrectly""))) { <line13> throw new IOException(""Remote host terminated the handshake"", e); <line14> } else { <line15> throw new IllegalStateException(""Unable to form SSL connection"", e); <line16> } <line17> } catch (SSLException e) { <line18> throw new IllegalStateException(""Unable to form SSL connection"", e); <line19> } <line20> try (OutputStream outputStream = new BufferedOutputStream(sock.getOutputStream()); <line21> final DataOutputStream out = <line22> new VersionedDataOutputStream(new DataOutputStream(outputStream), KnownVersion.OLDEST); <line23> final InputStream inputStream = sock.getInputStream(); <line24> final DataInputStream in = new DataInputStream(inputStream); <line25> final VersionedDataInputStream versionedIn = <line26> new VersionedDataInputStream(in, KnownVersion.OLDEST)) { <line27> out.writeInt(TcpServer.GOSSIPVERSION); <line28> out.writeShort(KnownVersion.OLDEST.ordinal()); <line29> final VersionRequest verRequest = new VersionRequest(); <line30> objectSerializer.writeObject(verRequest, out); <line31> out.flush(); <line32> try { <line33> final Object readObject = objectDeserializer.readObject(versionedIn); <line34> if (!(readObject instanceof VersionResponse)) { <line35> throw new IllegalThreadStateException( <line36> ""Server version response invalid: This could be the result of trying to connect a"" <line37> + "" non-SSL-enabled client to an SSL-enabled locator.""); <line38> } <line39> final VersionResponse response = (VersionResponse) readObject; <line40> serverVersion = response.getVersionOrdinal(); <line41> serverVersions.put(address, serverVersion); <line42> return serverVersion; <line43> } catch (EOFException ex) { <line44> } <line45> } finally { <line46> if (!sock.isClosed()) { <line47> try { <line48> sock.setSoLinger(true, 0); <line49> } catch (Exception e) { <line50> } <line51> try { <line52> sock.close(); <line53> } catch (Exception e) { <line54> } <line55> } <line56> } <line57> serverVersions.putIfAbsent(address, KnownVersion.OLDEST.ordinal()); <line58> return KnownVersion.OLDEST.ordinal(); <line59> } <line60> } <line61> "	 <line51>	No
public class A { <line0> public void joinDone( <line1> String invokerRemoteAddress, String remoteAddress, Cause cause, Exception exception) { <line2> String rmiAddress = getRmiAddress(remoteAddress); <line3> try { <line4> RemoteCommunication ske = null; <line5> ske = (RemoteCommunication) Naming.lookup(rmiAddress); <line6> ske.remoteJoinDone(invokerRemoteAddress, remoteAddress, cause, exception); <line7> } catch (Exception ex) { <line8> } <line9> } <line10> } <line11> 	 <line3>	No
public class A { <line0> @Override <line1> public PdfPTable createTableWithHeader( <line2> final int numOfColumns, <line3> final List<String> header, <line4> final boolean lastColumnAlignmentToLeft, <line5> final int[] columnWidths) { <line6> PdfPTable table = new PdfPTable(numOfColumns); <line7> try { <line8> table.setWidths(columnWidths); <line9> } catch (DocumentException e) { <line10> } <line11> return setTableProperties(header, table, null); <line12> } <line13> } <line14> 	 <line10>	Yes
public class A { <line0> @Override <line1> public void initialize() { <line2> eventQueue.append( <line3> () -> { <line4> initialized = true; <line5> }); <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> public void stop() { <line1> if (log.isDebugEnabled()) { <line2> } <line3> if (runInfo.getDuration().getPeriodType() == PeriodType.TIME) { <line4> runInfo.stop(); <line5> waitForReportingTasks(); <line6> } else { <line7> waitForReportingTasks(); <line8> runInfo.stop(); <line9> } <line10> reportFinalTimeResults(); <line11> reporters.forEach(org.perfcake.reporting.reporter.Reporter::stop); <line12> if (periodicThread != null) { <line13> periodicThread.interrupt(); <line14> } <line15> periodicThread = null; <line16> } <line17> } <line18> 	 <line10>	No
public class A { <line0> public static Map<String, Object> postProcessReconnectBackoffConfigs( <line1> AbstractConfig config, Map<String, Object> parsedValues) { <line2> HashMap<String, Object> rval = new HashMap<>(); <line3> if ((!config.originals().containsKey(RECONNECT_BACKOFF_MAX_MS_CONFIG)) <line4> && config.originals().containsKey(RECONNECT_BACKOFF_MS_CONFIG)) { <line5> rval.put(RECONNECT_BACKOFF_MAX_MS_CONFIG, parsedValues.get(RECONNECT_BACKOFF_MS_CONFIG)); <line6> } <line7> return rval; <line8> } <line9> } <line10> 	 <line5>	Yes
"public class A { <line0> private void saveProfiles(final String sessionId, final String taskId) throws IOException { <line1> String dir; <line2> dir = sessionId + ""/"" + taskId + ""/"" + MonitorProcess.PROFILER_MARKER; <line3> Set<String> fileNameList = fileStorage.getFileNameList(dir); <line4> if (fileNameList.isEmpty()) { <line5> return; <line6> } <line7> final TaskData taskData = getTaskData(taskId, sessionId); <line8> if (taskData == null) { <line9> return; <line10> } <line11> for (final String fileName : fileNameList) { <line12> LogReader.FileReader reader; <line13> try { <line14> reader = logReader.read(fileName, Object.class); <line15> } catch (IllegalArgumentException e) { <line16> return; <line17> } <line18> final ProfileDTO profileDTO = <line19> SerializationUtils.fromString(reader.iterator().next().toString()); <line20> getHibernateTemplate() <line21> .execute( <line22> new HibernateCallback<Void>() { <line23> @Override <line24> public Void doInHibernate(Session session) throws HibernateException, SQLException { <line25> String prefix = ""Agent on ("" + profileDTO.getHostAddress() + "") : ""; <line26> for (Map.Entry<String, RuntimeGraph> runtimeGraphEntry : <line27> profileDTO.getRuntimeGraphs().entrySet()) { <line28> String context = SerializationUtils.toString(runtimeGraphEntry.getValue()); <line29> session.persist( <line30> new ProfilingSuT( <line31> prefix + runtimeGraphEntry.getKey(), sessionId, taskData, context)); <line32> } <line33> session.flush(); <line34> return null; <line35> } <line36> }); <line37> } <line38> } <line39> } <line40> "	 <line33>	No
public class A { <line0> @Override <line1> public boolean calculateQuotaUsage() { <line2> List<AccountVO> accounts = _accountDao.listAll(); <line3> for (AccountVO account : accounts) { <line4> Pair<List<? extends UsageVO>, Integer> usageRecords = <line5> _usageDao.getUsageRecordsPendingQuotaAggregation( <line6> account.getAccountId(), account.getDomainId()); <line7> if (s_logger.isDebugEnabled()) { <line8> } <line9> List<QuotaUsageVO> quotaListForAccount = <line10> aggregatePendingQuotaRecordsForAccount(account, usageRecords); <line11> if (s_logger.isDebugEnabled()) { <line12> } <line13> processQuotaBalanceForAccount(account, quotaListForAccount); <line14> } <line15> return true; <line16> } <line17> } <line18> 	 <line8>	Yes
public class A { <line0> @Override <line1> public void configurePipeline(PipelineConfigurer pipelineConfigurer) { <line2> FailureCollector collector = pipelineConfigurer.getStageConfigurer().getFailureCollector(); <line3> config.validate(collector); <line4> collector.getOrThrowException(); <line5> if (config.containsMacro(NAME_FORMAT)) { <line6> for (FileFormat f : FileFormat.values()) { <line7> try { <line8> pipelineConfigurer.usePlugin( <line9> ValidatingOutputFormat.PLUGIN_TYPE, <line10> f.name().toLowerCase(), <line11> f.name().toLowerCase(), <line12> config.getRawProperties()); <line13> } catch (InvalidPluginConfigException e) { <line14> } <line15> } <line16> return; <line17> } <line18> String format = config.getFormatName(); <line19> ValidatingOutputFormat validatingOutputFormat = getValidatingOutputFormat(pipelineConfigurer); <line20> FormatContext context = <line21> new FormatContext(collector, pipelineConfigurer.getStageConfigurer().getInputSchema()); <line22> validateOutputFormatProvider(context, format, validatingOutputFormat); <line23> } <line24> } <line25> 	 <line21>	No
public class A { <line0> private void execute(GenericCli shell, String[] args) { <line1> CommandLine cmd = shell.getCmd(); <line2> IExceptionHandler2<List<Object>> exceptionHandler = <line3> new IExceptionHandler2<List<Object>>() { <line4> @Override <line5> public List<Object> handleParseException(ParameterException ex, String[] args) { <line6> throw ex; <line7> } <line8>  <line9> @Override <line10> public List<Object> handleExecutionException( <line11> ExecutionException ex, ParseResult parseRes) { <line12> throw ex; <line13> } <line14> }; <line15> String[] argsWithHAConf = getHASetConfStrings(args); <line16> cmd.parseWithHandlers(new RunLast(), exceptionHandler, argsWithHAConf); <line17> } <line18> } <line19> 	 <line9>	No
public class A { <line0> public void cleanUp(GL gl) { <line1> for (FragmentTexture ft : markedAsRemoved) { <line2> if (ft != null) { <line3> remove(ft.getId()); <line4> if (values().contains(ft)) { <line5> } <line6> ft.disable(gl); <line7> ft.unload(); <line8> } <line9> } <line10> markedAsRemoved.clear(); <line11> } <line12> } <line13> 	 <line5>	Yes
"public class A { <line0> protected void logLife(Game game) { <line1> StringBuilder sb = new StringBuilder(); <line2> sb.append(game.getTurn().getValue(game.getTurnNum())); <line3> for (Player player : game.getPlayers().values()) { <line4> sb.append(""[player "") <line5> .append(player.getName()) <line6> .append(':') <line7> .append(player.getLife()) <line8> .append(']'); <line9> } <line10> } <line11> } <line12> "	 <line1>	No
"public class A { <line0> @Test <line1> public void testDebug() { <line2> buf.setLength(0); <line3> final VitamUILogger logger = VitamUILoggerFactory.getInstance(VitamUIDebugLoggerTest.class); <line4> final String message = ""message""; <line5> assertTrue(""Log message should be written."", buf.length() > 0); <line6> assertTrue(""Log message should be written."", buf.lastIndexOf(message) > 0); <line7> assertTrue(""Log message should be written."", buf.length() > message.length()); <line8> } <line9> } <line10> "	 <line5>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> watchForIdleBulkWriters(); <line4> } catch (Throwable t) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> private void parse(String commandOutput) { <line1> boolean associated = false; <line2> for (String line : commandOutput.split(""\n"")) { <line3> line = line.trim(); <line4> if (line.contains(MODE)) { <line5> associated = parseMode(line); <line6> } else if (line.contains(BIT_RATE)) { <line7> parseBitrate(line); <line8> } else if (line.contains(SIGNAL_LEVEL)) { <line9> int sig = parseSignalLevel(line); <line10> if (associated && sig > -100) { <line11> setSignal(sig); <line12> setLinkDetected(true); <line13> } <line14> } <line15> if (!associated) { <line16> break; <line17> } <line18> } <line19> } <line20> } <line21> "	 <line11>	Yes
"public class A { <line0> @Scheduled(fixedDelayString = ""${execInterval}000"") <line1> public void loadDataToNeo4j() { <line2> syncTaskExecutor.execute(runnableTask); <line3> } <line4> } <line5> "	 <line1>	No
"public class A { <line0> protected static void checkConnection(int numRetries, Iterable<? extends Entity> nodes) <line1> throws ConnectionException { <line2> CassandraNode first = (CassandraNode) Iterables.get(nodes, 0); <line3> String uniqueName = Identifiers.makeRandomId(8); <line4> AstyanaxSample astyanaxFirst = <line5> AstyanaxSample.builder().node(first).columnFamilyName(uniqueName).build(); <line6> Map<String, List<String>> versions; <line7> AstyanaxContext<Cluster> context = astyanaxFirst.newAstyanaxContextForCluster(); <line8> try { <line9> versions = context.getEntity().describeSchemaVersions(); <line10> } finally { <line11> context.shutdown(); <line12> } <line13> if (versions.size() > 1) { <line14> Assert.fail(""Inconsistent versions on Cassandra start: "" + versions); <line15> } <line16> String keyspacePrefix = ""BrooklynTests_"" + Identifiers.makeRandomId(8); <line17> String keyspaceName = astyanaxFirst.writeData(keyspacePrefix, numRetries); <line18> for (Entity node : nodes) { <line19> AstyanaxSample astyanaxSecond = <line20> AstyanaxSample.builder().node((CassandraNode) node).columnFamilyName(uniqueName).build(); <line21> astyanaxSecond.readData(keyspaceName, numRetries); <line22> } <line23> } <line24> } <line25> "	 <line21>	No
"public class A { <line0> private <X> TypedValue<X> convertToType( <line1> final XQueryContext xqueryContext, <line2> final String argumentName, <line3> final TypedValue typedValue, <line4> final org.exquery.xquery.Type destinationType, <line5> final Class<X> underlyingDestinationClass) <line6> throws RestXqServiceException { <line7> final Item convertedValue; <line8> try { <line9> final int existDestinationType = TypeAdapter.toExistType(destinationType); <line10> final Item value; <line11> if (typedValue instanceof org.exquery.xdm.type.StringTypedValue) { <line12> value = new StringValue(((org.exquery.xdm.type.StringTypedValue) typedValue).getValue()); <line13> } else if (typedValue instanceof org.exquery.xdm.type.Base64BinaryTypedValue) { <line14> value = <line15> BinaryValueFromInputStream.getInstance( <line16> xqueryContext, <line17> new Base64BinaryValueType(), <line18> ((org.exquery.xdm.type.Base64BinaryTypedValue) typedValue).getValue()); <line19> } else { <line20> value = (Item) typedValue.getValue(); <line21> } <line22> if (existDestinationType == value.getType()) { <line23> convertedValue = value; <line24> } else if (value instanceof AtomicValue) { <line25> convertedValue = value.convertTo(existDestinationType); <line26> } else { <line27> convertedValue = value; <line28> } <line29> } catch (final XPathException xpe) { <line30> throw new RestXqServiceException( <line31> ""TODO need to implement error code for problem with parameter conversion!: "" <line32> + xpe.getMessage(), <line33> xpe); <line34> } <line35> return new TypedValue<X>() { <line36> @Override <line37> public org.exquery.xquery.Type getType() { <line38> return TypeAdapter.toExQueryType(convertedValue.getType()); <line39> } <line40>  <line41> @Override <line42> public X getValue() { <line43> return (X) convertedValue; <line44> } <line45> }; <line46> } <line47> } <line48> "	 <line28>	No
"public class A { <line0> private void updateSslVerify(StoredConfig config, boolean value) { <line1> String uriPattern = uri.getScheme() + ""://"" + uri.getHost(); <line2> int port = uri.getPort(); <line3> if (port > 0) { <line4> uriPattern += "":"" + port; <line5> } <line6> config.setBoolean(HttpConfig.HTTP, uriPattern, HttpConfig.SSL_VERIFY_KEY, value); <line7> try { <line8> config.save(); <line9> } catch (IOException e) { <line10> } <line11> } <line12> } <line13> "	 <line10>	Yes
"public class A { <line0> private static void registerLifecycleHandlers( <line1> Configuration configuration, <line2> Object component, <line3> Class<? extends Annotation> lifecycleAnnotation, <line4> LifecycleRegistration registrationMethod) { <line5> for (Method method : ReflectionUtils.methodsOf(component.getClass())) { <line6> AnnotationUtils.findAnnotationAttributes(method, lifecycleAnnotation) <line7> .ifPresent( <line8> lifecycleAnnotationAttributes -> { <line9> if (method.getParameterCount() > 0) { <line10> throw new AxonConfigurationException( <line11> format( <line12> ""The @%s annotated method [%s] should not contain any parameters"" <line13> + "" as none are allowed on lifecycle handlers"", <line14> lifecycleAnnotation.getSimpleName(), method)); <line15> } <line16> method.setAccessible(true); <line17> int phase = (int) lifecycleAnnotationAttributes.get(LIFECYCLE_PHASE_ATTRIBUTE_NAME); <line18> LifecycleHandler lifecycleHandler = <line19> () -> <line20> invokeAndReturn( <line21> component, method, lifecycleAnnotation.getSimpleName(), phase); <line22> registrationMethod.registerLifecycleHandler(configuration, phase, lifecycleHandler); <line23> }); <line24> } <line25> } <line26> } <line27> "	 <line20>	No
"public class A { <line0> protected ClientResource sendRegistrationRequest(User user, Boolean dryRun) { <line1> ClientResource clientResource = createClientResource(regUrl, true); <line2> addCredentialsIfAny(clientResource); <line3> if (dryRun) { <line4> addHeaderAttribute(clientResource, ""dryRun"", ""true""); <line5> } <line6> writeRequestInfoToLog(clientResource); <line7> try { <line8> clientResource.post(user); <line9> } catch (ResourceException e) { <line10> } <line11> return clientResource; <line12> } <line13> } <line14> "	 <line8>	No
"public class A { <line0> @Deprecated <line1> public void setPdfOcr(boolean pdfOcr) { <line2> String strategy; <line3> if (pdfOcr) { <line4> strategy = ""ocr_and_text""; <line5> } else { <line6> strategy = ""no_ocr""; <line7> } <line8> if (this.ocr == null) { <line9> this.ocr = new Ocr(); <line10> } <line11> this.ocr.setPdfStrategy(strategy); <line12> } <line13> } <line14> "	 <line8>	Yes
public class A { <line0> private void tryToPerformLocalSnapshotOperation() { <line1> try { <line2> long start = System.nanoTime(); <line3> IgniteInternalFuture fut = <line4> cctx.snapshot().tryStartLocalSnapshotOperation(firstDiscoEvt, exchId.topologyVersion()); <line5> if (fut != null) { <line6> fut.get(); <line7> long end = System.nanoTime(); <line8> if (log.isInfoEnabled()) <line9> } <line10> } catch (IgniteException | IgniteCheckedException e) { <line11> } <line12> } <line13> } <line14> 	 <line9>	Yes
"public class A { <line0> @Override <line1> public void pushTaskReports(String taskid, File reportFile) throws IOException { <line2> final String taskKey = getTaskLogKey(taskid, ""report.json""); <line3> pushTaskFile(reportFile, taskKey); <line4> } <line5> } <line6> "	 <line5>	No
"public class A { <line0> private List<String> getGeneNames( <line1> GenomeLoc target, LocationAwareSeekableRODIterator refseqIterator) { <line2> List<String> unknown = Arrays.asList(""UNKNOWN""); <line3> if (refseqIterator == null) { <line4> return unknown; <line5> } <line6> RODRecordList annotationList = refseqIterator.seekForward(target); <line7> if (annotationList == null) { <line8> return unknown; <line9> } <line10> List<String> geneNames = new ArrayList<String>(); <line11> for (GATKFeature rec : annotationList) { <line12> if (((RefSeqFeature) rec.getUnderlyingObject()).overlapsExonP(target)) { <line13> geneNames.add(((RefSeqFeature) rec.getUnderlyingObject()).getGeneName()); <line14> } else { <line15> } <line16> } <line17> if (geneNames.isEmpty()) { <line18> geneNames = unknown; <line19> } <line20> return geneNames; <line21> } <line22> } <line23> "	 <line2>	Yes
"public class A { <line0> @Test <line1> public void testDelayedClosed() throws Exception { <line2> BlockingQueue<Callback> receivedCallbacks = new BlockingArrayQueue<>(); <line3> TestFrameHandler serverHandler = <line4> new TestFrameHandler() { <line5> @Override <line6> public void onOpen(CoreSession coreSession, Callback callback) { <line7> super.onOpen(coreSession); <line8> callback.succeeded(); <line9> coreSession.demand(2); <line10> } <line11>  <line12> @Override <line13> public boolean isDemanding() { <line14> return true; <line15> } <line16>  <line17> @Override <line18> public void onFrame(Frame frame, Callback callback) { <line19> receivedFrames.offer(frame); <line20> receivedCallbacks.offer(callback); <line21> } <line22> }; <line23> server = new WebSocketServer(serverHandler); <line24> server.start(); <line25> try (Socket client = newClient(server.getLocalPort())) { <line26> ByteBuffer buffer = BufferUtil.allocate(4096); <line27> BufferUtil.append(buffer, RawFrameBuilder.buildText(""Hello"", true)); <line28> BufferUtil.append(buffer, RawFrameBuilder.buildClose(CloseStatus.NORMAL_STATUS, true)); <line29> client.getOutputStream().write(BufferUtil.toArray(buffer)); <line30> long end = System.nanoTime() + TimeUnit.SECONDS.toNanos(10); <line31> while (serverHandler.receivedFrames.size() < 2) { <line32> assertThat(System.nanoTime(), Matchers.lessThan(end)); <line33> Thread.sleep(10); <line34> } <line35> assertThat(serverHandler.receivedFrames.size(), is(2)); <line36> assertThat(receivedCallbacks.size(), is(2)); <line37> assertThat(serverHandler.receivedFrames.poll().getPayloadAsUTF8(), is(""Hello"")); <line38> receivedCallbacks.poll().succeeded(); <line39> serverHandler <line40> .getCoreSession() <line41> .sendFrame(new Frame(OpCode.TEXT, ""Ciao""), Callback.NOOP, false); <line42> Frame frame = receiveFrame(client.getInputStream()); <line43> assertNotNull(frame); <line44> assertThat(frame.getPayloadAsUTF8(), is(""Ciao"")); <line45> assertThat(serverHandler.receivedFrames.poll().getOpCode(), is(OpCode.CLOSE)); <line46> receivedCallbacks.poll().succeeded(); <line47> frame = receiveFrame(client.getInputStream()); <line48> assertNotNull(frame); <line49> assertThat(frame.getOpCode(), is(OpCode.CLOSE)); <line50> } <line51> } <line52> } <line53> "	 <line27>	No
"public class A { <line0> @VisibleForTesting <line1> void destroy() { <line2> if (twillRunnerService != null) { <line3> try { <line4> twillRunnerService.stop(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> if (locationFactory != null) { <line9> Location location = locationFactory.create(""/""); <line10> try { <line11> location.delete(true); <line12> } catch (IOException e) { <line13> } <line14> } <line15> if (zkServer != null) { <line16> try { <line17> zkServer.stopAndWait(); <line18> } catch (Exception e) { <line19> } <line20> } <line21> } <line22> } <line23> "	 <line17>	No
public class A { <line0> private void resolveReferencesForRootTypes() { <line1> try { <line2> AtlasEntityType.ENTITY_ROOT.resolveReferences(this); <line3> AtlasClassificationType.CLASSIFICATION_ROOT.resolveReferences(this); <line4> } catch (AtlasBaseException e) { <line5> throw new RuntimeException(e); <line6> } <line7> } <line8> } <line9> 	 <line3>	No
public class A { <line0> public void changeToSlave(int brokerId) { <line1> brokerConfig.setBrokerId(brokerId == 0 ? 1 : brokerId); <line2> messageStoreConfig.setBrokerRole(BrokerRole.SLAVE); <line3> try { <line4> this.messageStore.handleScheduleMessageService(BrokerRole.SLAVE); <line5> } catch (Throwable t) { <line6> } <line7> try { <line8> this.shutdownProcessorByHa(); <line9> } catch (Throwable t) { <line10> } <line11> handleSlaveSynchronize(BrokerRole.SLAVE); <line12> try { <line13> this.registerBrokerAll(true, true, brokerConfig.isForceRegister()); <line14> } catch (Throwable ignored) { <line15> } <line16> } <line17> } <line18> 	 <line16>	Yes
public class A { <line0> @Override <line1> public void onMouseDown(Event event) { <line2> super.onMouseDown(event); <line3> if (writing) { <line4> return; <line5> } <line6> if (processing) { <line7> divElement.getParentElement().removeChild(divElement); <line8> } <line9> image = getRootImage(event); <line10> int[] absoluteTopLeft = Utils.getAbsoluteTopLeft(image, Document.get()); <line11> ax = event.getClientX() - absoluteTopLeft[1] + Window.getScrollLeft(); <line12> ay = event.getClientY() - absoluteTopLeft[0] + Window.getScrollTop(); <line13> bx = ax; <line14> by = ay; <line15> writing = true; <line16> processing = true; <line17> controller.disablePopupListeners(); <line18> addMap(ax, ay, bx, by, image); <line19> } <line20> } <line21> 	 <line15>	No
public class A { <line0> public void onCompletion(RecordMetadata metadata, Exception exception) { <line1> if (exception != null) { <line2> } <line3> if (logger.isDebugEnabled()) { <line4> long eventElapsedTime = System.currentTimeMillis() - startTime; <line5> if (metadata != null) { <line6> } <line7> } <line8> } <line9> } <line10> 	 <line3>	No
public class A { <line0> public boolean getLocalDefaultResolvesWithAncestorValue() { <line1> if (localDefaultResolvesWithAncestorValue == null) { <line2> readResolve(); <line3> } <line4> return localDefaultResolvesWithAncestorValue; <line5> } <line6> } <line7> 	 <line2>	Yes
"public class A { <line0> void init(final NettyProtocol protocol, NettyBufferPool nettyBufferPool) throws IOException { <line1> checkState(bootstrap == null, ""Netty client has already been initialized.""); <line2> this.protocol = protocol; <line3> final long start = System.nanoTime(); <line4> bootstrap = new Bootstrap(); <line5> switch (config.getTransportType()) { <line6> case NIO: <line7> initNioBootstrap(); <line8> break; <line9> case EPOLL: <line10> initEpollBootstrap(); <line11> break; <line12> case AUTO: <line13> if (Epoll.isAvailable()) { <line14> initEpollBootstrap(); <line15> } else { <line16> initNioBootstrap(); <line17> } <line18> } <line19> bootstrap.option(ChannelOption.TCP_NODELAY, true); <line20> bootstrap.option(ChannelOption.SO_KEEPALIVE, true); <line21> bootstrap.option( <line22> ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getClientConnectTimeoutSeconds() * 1000); <line23> bootstrap.option(ChannelOption.ALLOCATOR, nettyBufferPool); <line24> int receiveAndSendBufferSize = config.getSendAndReceiveBufferSize(); <line25> if (receiveAndSendBufferSize > 0) { <line26> bootstrap.option(ChannelOption.SO_SNDBUF, receiveAndSendBufferSize); <line27> bootstrap.option(ChannelOption.SO_RCVBUF, receiveAndSendBufferSize); <line28> } <line29> try { <line30> clientSSLFactory = config.createClientSSLEngineFactory(); <line31> } catch (Exception e) { <line32> throw new IOException(""Failed to initialize SSL Context for the Netty client"", e); <line33> } <line34> final long duration = (System.nanoTime() - start) / 1_000_000; <line35> } <line36> } <line37> "	 <line35>	Yes
"public class A { <line0> protected boolean verifyActivityOfStorageOnHost( <line1> HashMap<StoragePool, List<Volume>> poolVolMap, <line2> StoragePool pool, <line3> Host agent, <line4> DateTime suspectTime, <line5> boolean activityStatus) <line6> throws HACheckerException, IllegalStateException { <line7> List<Volume> volume_list = poolVolMap.get(pool); <line8> final CheckVMActivityOnStoragePoolCommand cmd = <line9> new CheckVMActivityOnStoragePoolCommand(agent, pool, volume_list, suspectTime); <line10> try { <line11> Answer answer = storageManager.sendToPool(pool, getNeighbors(agent), cmd); <line12> if (answer != null) { <line13> activityStatus = !answer.getResult(); <line14> } else { <line15> String message = <line16> String.format( <line17> ""Did not get a valid response for VM activity check for %s on storage pool [%s]."", <line18> agent.toString(), pool.getId()); <line19> throw new IllegalStateException(message); <line20> } <line21> } catch (StorageUnavailableException e) { <line22> String message = <line23> String.format( <line24> ""Storage [%s] is unavailable to do the check, probably the %s is not reachable."", <line25> pool.getId(), agent.toString()); <line26> throw new HACheckerException(message, e); <line27> } <line28> return activityStatus; <line29> } <line30> } <line31> "	 <line11>	No
public class A { <line0> private SingleRegionBlocker.SingleRegionBlockerConfiguration toSingleRegionBlockerConfig( <line1> String jsonConfiguration) { <line2> try { <line3> return mapper.readValue( <line4> jsonConfiguration, SingleRegionBlocker.SingleRegionBlockerConfiguration.class); <line5> } catch (IOException e) { <line6> throw new UncheckedIOException(e); <line7> } <line8> } <line9> } <line10> 	 <line1>	No
public class A { <line0> public void processEntityOccurance(int start, int end, String instURI, String classURI) { <line1> FeatureMap fm = Factory.newFeatureMap(); <line2> if (instURI != null) { <line3> fm.put(FeatureConstants.INSTANCE, instURI); <line4> } <line5> fm.put(FeatureConstants.CLASS, classURI); <line6> try { <line7> annotationSet.add(Long.valueOf(start), Long.valueOf(end), KIMConstants.LOOKUP, fm); <line8> } catch (InvalidOffsetException ioe) { <line9> throw new LuckyException(ioe.toString()); <line10> } <line11> ++annotatedEntities; <line12> if (!kimParser.isInterrupted() && annotationLimit > 0 && annotatedEntities > annotationLimit) { <line13> kimParser.setInterrupted(true); <line14> } <line15> } <line16> } <line17> 	 <line13>	Yes
"public class A { <line0> public static com.liferay.site.navigation.model.SiteNavigationMenu addSiteNavigationMenu( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> String name, <line4> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line5> throws com.liferay.portal.kernel.exception.PortalException { <line6> try { <line7> MethodKey methodKey = <line8> new MethodKey( <line9> SiteNavigationMenuServiceUtil.class, <line10> ""addSiteNavigationMenu"", <line11> _addSiteNavigationMenuParameterTypes2); <line12> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, name, serviceContext); <line13> Object returnObj = null; <line14> try { <line15> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line18> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line19> } <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (com.liferay.site.navigation.model.SiteNavigationMenu) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	 <line24>	Yes
"public class A { <line0> private IAtomContainerSet readAtomContainerSet(IAtomContainerSet molSet) throws IOException { <line1> SmilesParser parser = new SmilesParser(molSet.getBuilder()); <line2> parser.kekulise(false); <line3> String line = input.readLine(); <line4> line = input.readLine(); <line5> while (line != null) { <line6> String[] cols = line.split("",""); <line7> try { <line8> IAtomContainer mol = parser.parseSmiles(cols[1]); <line9> mol.setProperty(""focusSupport"", cols[5]); <line10> mol.setProperty(""complementSupport"", cols[7]); <line11> mol.setProperty(""atomCount"", cols[2]); <line12> mol.setProperty(""bondCount"", cols[3]); <line13> molSet.addAtomContainer(mol); <line14> } catch (InvalidSmilesException exception) { <line15> } <line16> line = input.readLine(); <line17> } <line18> return molSet; <line19> } <line20> } <line21> "	 <line15>	Yes
"public class A { <line0> public JobRunnable SubmitConcurrentJobs( <line1> final int threadCount, <line2> AppConfig config, <line3> final boolean killThreads, <line4> boolean interruptThreads, <line5> final Answer<Integer> responseAnswer, <line6> final Answer<QueueStatusBean> timeoutResponseAnswer, <line7> final String jobIdResponse) <line8> throws IOException, InterruptedException, QueueException, NotAuthorizedException, <line9> BusyException, TimeoutException, Exception { <line10> LauncherDelegator delegator = new LauncherDelegator(config); <line11> final LauncherDelegator mockDelegator = Mockito.spy(delegator); <line12> final List<String> listArgs = new ArrayList<String>(); <line13> TempletonControllerJob mockCtrl = Mockito.mock(TempletonControllerJob.class); <line14> doReturn(jobIdResponse).when(mockCtrl).getSubmittedId(); <line15> doReturn(mockCtrl).when(mockDelegator).getTempletonController(); <line16> doAnswer(responseAnswer) <line17> .when(mockDelegator) <line18> .runTempletonControllerJob(any(TempletonControllerJob.class), any(List.class)); <line19> doAnswer(timeoutResponseAnswer) <line20> .when(mockDelegator) <line21> .killJob(any(String.class), any(String.class)); <line22> doNothing() <line23> .when(mockDelegator) <line24> .registerJob(any(String.class), any(String.class), any(String.class), any()); <line25> JobRunnable submitJobRunnable = <line26> new JobRunnable() { <line27> @Override <line28> public void run() { <line29> try { <line30> int threadId = waitForAllThreadsToStart(this, threadCount); <line31> mockDelegator.enqueueController(""admin"", null, """", listArgs); <line32> } catch (Throwable ex) { <line33> exception = ex; <line34> } <line35> } <line36> }; <line37> executeJobOperations(submitJobRunnable, threadCount, killThreads, interruptThreads); <line38> return submitJobRunnable; <line39> } <line40> } <line41> "	 <line0>	No
"public class A { <line0> @RolesAllowed(""system-user"") <line1> public void activateMaintenanceMode(String reason) { <line2> GenericSetting maintenanceMode = createGenericParameterIfNotFound(MAINTENANCE_MODE); <line3> maintenanceMode.setValue(Boolean.TRUE.toString()); <line4> genericSettingRepository.save(maintenanceMode); <line5> notifier.sendMessage(GenericSettingNotification.maintenanceModeChanged(true)); <line6> setAnnouncementBanner(reason); <line7> } <line8> } <line9> "	 <line2>	Yes
public class A { <line0> public void addFactory(Factory factory) { <line1> if (factory.keyClasses() != null) { <line2> for (Class c : factory.keyClasses()) { <line3> if (!factoriesByClass.containsKey(c)) { <line4> factoriesByClass.put(c, factory); <line5> } <line6> } <line7> } <line8> if (factory.keyIds() != null) { <line9> for (String id : factory.keyIds()) { <line10> if (!factoriesById.containsKey(id)) { <line11> factoriesById.put(id, factory); <line12> } <line13> } <line14> } <line15> factories.add(factory); <line16> } <line17> } <line18> 	 <line11>	No
"public class A { <line0> @Override <line1> public byte[] generateTimeStamp() throws CertificateCoreException { <line2> byte[] resp = null; <line3> int attempt = 1; <line4> while (attempt < 3) { <line5> try { <line6> TimeStampOperator timeStampOperator = new TimeStampOperator(); <line7> byte[] request = timeStampOperator.createRequest(privateKey, certificates, content, hash); <line8> resp = timeStampOperator.invoke(request); <line9> break; <line10> } catch (CertificateCoreException e) { <line11> attempt++; <line12> } <line13> } <line14> if (resp != null && resp.length > 1) { <line15> return resp; <line16> } else { <line17> throw new CertificateCoreException( <line18> timeStampMessagesBundle.getString(""info.timestamp.attempt.exceeded"", attempt)); <line19> } <line20> } <line21> } <line22> "	 <line17>	Yes
public class A { <line0> public long readData(InputStream is, long startPosition, long maxReadSize) throws IOException { <line1> OutputStream out = null; <line2> BufferedInputStream in = null; <line3> setPartStartPosition((int) startPosition); <line4> long readSize = 0; <line5> try { <line6> long skippedBytes = is.skip(startPosition); <line7> if (skippedBytes != startPosition) { <line8> } <line9> in = new BufferedInputStream(is); <line10> out = getCompressedOutputStream(); <line11> int bufferSize = ONE_HUNDRED_KILO_BYTE; <line12> byte[] b = new byte[bufferSize]; <line13> int len; <line14> int maxBufferBoundary; <line15> while ((readSize < maxReadSize || maxReadSize == -1) && (len = in.read(b)) > 0) { <line16> maxBufferBoundary = len; <line17> if (maxReadSize > -1 && readSize + len > maxReadSize) { <line18> maxBufferBoundary = (int) (maxReadSize - readSize); <line19> } <line20> if (maxBufferBoundary < len) { <line21> len = maxBufferBoundary; <line22> } <line23> out.write(b, 0, len); <line24> readSize += len; <line25> } <line26> out.flush(); <line27> m_exists = true; <line28> } finally { <line29> if (out != null) { <line30> out.close(); <line31> } <line32> if (in != null) { <line33> in.close(); <line34> } <line35> } <line36> return getCRC(); <line37> } <line38> } <line39> 	 <line27>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private Map<String, String> extractMessageProperties(Message message) { <line2> Map<String, String> properties = new HashMap<>(); <line3> try { <line4> Enumeration<String> propertyNames = message.getPropertyNames(); <line5> while (propertyNames.hasMoreElements()) { <line6> String propertyName = propertyNames.nextElement(); <line7> properties.put(propertyName, String.valueOf(message.getObjectProperty(propertyName))); <line8> } <line9> } catch (JMSException e) { <line10> } <line11> return properties; <line12> } <line13> } <line14> "	 <line3>	No
public class A { <line0> protected void removeCachedInstance( <line1> LaunchConfiguration configuration, ChromeInstance chromeInstance) { <line2> ChromeInstance cachedInstance = instances.get(configuration); <line3> if (cachedInstance == chromeInstance) { <line4> instances.remove(configuration); <line5> } else { <line6> if (log.isDebugEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line10>	No
"public class A { <line0> public static void sendRoom( <line1> final Long roomId, <line2> final JSONObject m, <line3> Predicate<Client> check, <line4> BiFunction<JSONObject, Client, JSONObject> func) { <line5> sendRoom(roomId, (t, c) -> doSend(t, c, m, func, ""room""), check); <line6> } <line7> } <line8> "	 <line3>	No
public class A { <line0> public static com.liferay.portal.kernel.model.ContactSoap getContact(long contactId) <line1> throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.Contact returnValue = <line4> ContactServiceUtil.getContact(contactId); <line5> return com.liferay.portal.kernel.model.ContactSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> private void finishSplitAtRecord( <line1> TopicPartition tp, <line2> long stoppingOffset, <line3> long currentOffset, <line4> List<TopicPartition> finishedPartitions, <line5> KafkaPartitionSplitRecords<Tuple3<T, Long, Long>> recordsBySplits) { <line6> finishedPartitions.add(tp); <line7> recordsBySplits.addFinishedSplit(KafkaPartitionSplit.toSplitId(tp)); <line8> } <line9> } <line10> 	 <line7>	No
public class A { <line0> @Override <line1> public void execute() { <line2> try (CasStorageSession session = CasStorageSession.open()) { <line3> User user = getUser(); <line4> String username = user.getUsername(); <line5> Project project = getProject(); <line6> List<SourceDocument> docs = documentService.listSourceDocuments(project); <line7> List<SourceDocument> inherit = Collections.emptyList(); <line8> if (!recommendationService.isPredictForAllDocuments(username, project)) { <line9> inherit = <line10> docs.stream().filter(d -> !d.equals(currentDocument)).collect(Collectors.toList()); <line11> docs = Collections.singletonList(currentDocument); <line12> } <line13> long startTime = System.currentTimeMillis(); <line14> Predictions predictions = <line15> recommendationService.computePredictions(user, project, docs, inherit); <line16> predictions.inheritLog(logMessages); <line17> recommendationService.putIncomingPredictions(user, project, predictions); <line18> } <line19> } <line20> } <line21> 	 <line13>	Yes
"public class A { <line0> protected TransactionReceipt updateFile( <line1> String scenario, <line2> FileID fid, <line3> AccountID payerID, <line4> AccountID nodeID, <line5> ByteString fileData, <line6> List<Key> oldWaclKeyList, <line7> List<Key> newWaclKeyList) <line8> throws Throwable { <line9> if (scenario.equals(INVALID_FILE_ID)) { <line10> fid = FileID.newBuilder().setFileNum(0).setRealmNum(0).setShardNum(0).build(); <line11> } <line12> Timestamp fileExp = ProtoCommonUtils.getCurrentTimestampUTC(DAY_SEC * 10); <line13> KeyList wacl = KeyList.newBuilder().addAllKeys(newWaclKeyList).build(); <line14> Timestamp timestamp = TestHelperComplex.getDefaultCurrentTimestampUTC(); <line15> Transaction FileUpdateRequest = <line16> RequestBuilder.getFileUpdateBuilder( <line17> payerID.getAccountNum(), <line18> payerID.getRealmNum(), <line19> payerID.getShardNum(), <line20> nodeID.getAccountNum(), <line21> nodeID.getRealmNum(), <line22> nodeID.getShardNum(), <line23> MAX_TX_FEE, <line24> timestamp, <line25> fileExp, <line26> transactionDuration, <line27> true, <line28> ""FileUpdate"", <line29> fileData, <line30> fid, <line31> wacl); <line32> Key payerKey = acc2ComplexKeyMap.get(payerID); <line33> Key existingWaclKey = <line34> Key.newBuilder().setKeyList(KeyList.newBuilder().addAllKeys(oldWaclKeyList)).build(); <line35> Key newWaclKey = Key.newBuilder().setKeyList(wacl).build(); <line36> List<Key> keys = new ArrayList<Key>(); <line37> keys.add(payerKey); <line38> keys.add(existingWaclKey); <line39> if (scenario.equals(INCORRECT_WACL_SIG)) { <line40> keys.add(payerKey); <line41> } else { <line42> keys.add(newWaclKey); <line43> } <line44> Transaction txSigned = <line45> TransactionSigner.signTransactionComplexWithSigMap( <line46> FileUpdateRequest, keys, pubKey2privKeyMap); <line47> FileServiceBlockingStub stub = getStub(nodeID); <line48> TransactionResponse response = stub.updateFile(txSigned); <line49> Assert.assertNotNull(response); <line50> TransactionBody body = TransactionBody.parseFrom(FileUpdateRequest.getBodyBytes()); <line51> TransactionID txId = body.getTransactionID(); <line52> cache.addTransactionID(txId); <line53> TransactionReceipt receipt = getTxReceipt(txId); <line54> return receipt; <line55> } <line56> } <line57> "	 <line47>	Yes
public class A { <line0> private void prepareUsernameLength(PWDClearExtensionMessage msg) { <line1> msg.setUsernameLength(msg.getUsername().getValue().length()); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> public Set<String> getMatchedZonesForResourceAndChildren(RangerAccessResource accessResource) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> Set<String> ret = null; <line4> if (MapUtils.isNotEmpty(this.resourceZoneTrie)) { <line5> ret = getMatchedZonesForResourceAndChildren(accessResource.getAsMap(), accessResource); <line6> } <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> return ret; <line10> } <line11> } <line12> 	 <line8>	Yes
public class A { <line0> private CompiledXQuery getScript(boolean isBefore, DBBroker broker, Txn transaction, XmldbURI src) <line1> throws TriggerException { <line2> final Source query = getQuerySource(broker); <line3> if (query == null) { <line4> return null; <line5> } <line6> if (isBefore && !TriggerStatePerThread.verifyUniqueTriggerPerThreadBeforePrepare(this, src)) { <line7> return null; <line8> } else if (!isBefore <line9> && !TriggerStatePerThread.verifyUniqueTriggerPerThreadBeforeFinish(this, src)) { <line10> return null; <line11> } <line12> TriggerStatePerThread.setTransaction(transaction); <line13> final XQueryContext context = new XQueryContext(broker.getBrokerPool()); <line14> if (query instanceof DBSource) { <line15> context.setModuleLoadPath( <line16> XmldbURI.EMBEDDED_SERVER_URI_PREFIX <line17> + ((DBSource) query).getDocumentPath().removeLastSegment().toString()); <line18> } <line19> CompiledXQuery compiledQuery; <line20> try { <line21> compiledQuery = service.compile(broker, context, query); <line22> for (Object o : userDefinedVariables.keySet()) { <line23> final String varName = (String) o; <line24> final String varValue = userDefinedVariables.getProperty(varName); <line25> context.declareVariable(bindingPrefix + varName, new StringValue(varValue)); <line26> } <line27> compiledQuery.reset(); <line28> context.getWatchDog().reset(); <line29> context.prepareForExecution(); <line30> return compiledQuery; <line31> } catch (final XPathException | IOException | PermissionDeniedException e) { <line32> TriggerStatePerThread.setTriggerRunningState( <line33> TriggerStatePerThread.NO_TRIGGER_RUNNING, this, null); <line34> TriggerStatePerThread.setTransaction(null); <line35> throw new TriggerException(PREPARE_EXCEPTION_MESSAGE, e); <line36> } <line37> } <line38> } <line39> 	 <line32>	Yes
public class A { <line0> public static com.liferay.asset.kernel.model.AssetCategoryDisplay searchCategoriesDisplay( <line1> long[] groupIds, <line2> String title, <line3> long[] parentCategoryIds, <line4> long[] vocabularyIds, <line5> int start, <line6> int end) <line7> throws RemoteException { <line8> try { <line9> com.liferay.asset.kernel.model.AssetCategoryDisplay returnValue = <line10> AssetCategoryServiceUtil.searchCategoriesDisplay( <line11> groupIds, title, parentCategoryIds, vocabularyIds, start, end); <line12> return returnValue; <line13> } catch (Exception exception) { <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	 <line14>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (log.open) { <line4> log.writeCheckpoint(); <line5> } <line6> } catch (IOException e) { <line7> log.channelCounter.incrementCheckpointWriteErrorCount(); <line8> } catch (Throwable e) { <line9> log.channelCounter.incrementCheckpointWriteErrorCount(); <line10> } <line11> } <line12> } <line13> 	 <line8>	Yes
public class A { <line0> private ArrayList<RefCCDAValidationResult> validateFileImplementation( <line1> String validationObjective, <line2> String referenceFileName, <line3> String ccdaFile, <line4> String vocabularyConfig, <line5> SeverityLevel severityLevel) <line6> throws SAXException { <line7> ArrayList<RefCCDAValidationResult> results = null; <line8> if (ccdaFile != null) { <line9> final XPathIndexer xpathIndexer = new XPathIndexer(); <line10> trackXPathsInXML(xpathIndexer, ccdaFile); <line11> try { <line12> results = doValidation(ccdaFile, xpathIndexer, vocabularyConfig, severityLevel); <line13> } catch (IOException e) { <line14> e.printStackTrace(); <line15> } <line16> } <line17> return results; <line18> } <line19> } <line20> 	 <line19>	No
"public class A { <line0> @RequestMapping(""/statistics"") <line1> @ResponseBody <line2> public String getCollectionStatistics() throws Exception { <line3> Map<String, Object> result = new HashMap<>(); <line4> ObjectMapper mapper = new ObjectMapper(); <line5> try { <line6> result = getUIWrapper(collectionService.getCollectionStatistics(), true); <line7> } catch (Exception e) { <line8> result = <line9> getUIWrapper( <line10> false, <line11> ""System is down or under maintenance. For further inquiries please contact admin.""); <line12> } <line13> return ""jsonp("" + mapper.writeValueAsString(result) + "")""; <line14> } <line15> } <line16> "	 <line7>	No
"public class A { <line0> @Test <line1> public void test_08_02() { <line2> Chromosome chr = genome.getChromosome(""1""); <line3> Marker m1 = new Marker(chr, 0, 99, false, """"); <line4> Marker m2 = new Marker(chr, 200, 299, false, """"); <line5> Marker m3 = new Marker(chr, 400, 499, false, """"); <line6> ArrayList<Marker> list = new ArrayList<>(); <line7> list.add(m1); <line8> list.add(m2); <line9> list.add(m3); <line10> int last = m3.getEnd() + 10; <line11> for (int i = m1.getStart(); i <= last; i++) { <line12> Marker m = new Marker(chr, i, i, false, """"); <line13> int dist = m.distanceBases(list, false); <line14> Assert.assertEquals(i % 100, dist % 100); <line15> } <line16> } <line17> } <line18> "	 <line2>	Yes
"public class A { <line0> private boolean CheckUrl(URI url) throws DiscoveryException { <line1> if (""http"".equals(url.getScheme()) || ""https"".equals(url.getScheme())) { <line2> String msg = ""Discovering "" + url + "": "" + _params; <line3> } else { <line4> String msg = <line5> ""urlString is not http(s) so we're not taking care of the discovery for this: "" + url; <line6> throw new DiscoveryException(msg); <line7> } <line8> return true; <line9> } <line10> } <line11> "	 <line3>	Yes
public class A { <line0> @Override <line1> public void handleMessage(Message message) { <line2> Map<String, List> headers = (Map<String, List>) message.get(Message.PROTOCOL_HEADERS); <line3> if (headers == null) { <line4> headers = new HashMap<>(); <line5> } <line6> final Map<String, String> customHttpHeaders = getCustomHttpHeaders(message); <line7> if (MapUtils.isNotEmpty(customHttpHeaders)) { <line8> for (Entry<String, String> entry : customHttpHeaders.entrySet()) { <line9> headers.put(entry.getKey(), Collections.singletonList(entry.getValue())); <line10> } <line11> } <line12> message.put(Message.PROTOCOL_HEADERS, headers); <line13> } <line14> } <line15> 	 <line10>	Yes
"public class A { <line0> protected void reloadContentTypeConfigForChildren( <line1> String site, RepositoryItem node, List<ContentTypeConfigTO> contentTypes) { <line2> String contentTypesRootPath = getConfigPath().replaceAll(StudioConstants.PATTERN_SITE, site); <line3> String fullPath = node.path + FILE_SEPARATOR + node.name; <line4> RepositoryItem[] folders = contentRepository.getContentChildren(site, fullPath); <line5> if (folders != null) { <line6> for (int i = 0; i < folders.length; i++) { <line7> if (folders[i].isFolder) { <line8> String configPath = <line9> folders[i].path <line10> + FILE_SEPARATOR <line11> + folders[i].name <line12> + FILE_SEPARATOR <line13> + getConfigFileName(); <line14> if (contentService.contentExists(site, configPath)) { <line15> ContentTypeConfigTO config = <line16> contentTypesConfig.reloadConfiguration( <line17> site, <line18> configPath <line19> .replace(contentTypesRootPath, """") <line20> .replace(FILE_SEPARATOR + getConfigFileName(), """")); <line21> if (config != null) { <line22> contentTypes.add(config); <line23> } <line24> } <line25> reloadContentTypeConfigForChildren(site, folders[i], contentTypes); <line26> } <line27> } <line28> } <line29> } <line30> } <line31> "	 <line4>	Yes
"public class A { <line0> public static boolean executeRunnerSSHCommands( <line1> ICoordinatedStack stack, File runnerJar, String keyFile) { <line2> Collection<SshValues> sshValues = new HashSet<SshValues>(stack.getRunnerCount()); <line3> StringBuilder sb = new StringBuilder(); <line4> Collection<Command> commands = new ArrayList<Command>(); <line5> for (Instance instance : stack.getRunnerInstances()) { <line6> sshValues.add(new InstanceValues(instance, keyFile)); <line7> } <line8> sb.append(""/home/"").append(Utils.DEFAULT_USER).append(""/"").append(runnerJar.getName()); <line9> String destFile = sb.toString(); <line10> commands.add(new SCPCommand(runnerJar.getAbsolutePath(), destFile)); <line11> sb = new StringBuilder(); <line12> for (Cluster cluster : stack.getClusters()) { <line13> for (Object obj : cluster.getInstanceSpec().getScriptEnvironment().keySet()) { <line14> String envVar = obj.toString(); <line15> String value = cluster.getInstanceSpec().getScriptEnvironment().getProperty(envVar); <line16> sb.append(""export "").append(envVar).append(""=\"""").append(value).append(""\"";""); <line17> } <line18> String exportVars = sb.toString(); <line19> for (URL scriptFile : cluster.getInstanceSpec().getRunnerScripts()) { <line20> File file = new File(scriptFile.getPath()); <line21> File fileToSave = new File(runnerJar.getParentFile(), file.getName()); <line22> writeToFile( <line23> getResourceAsStreamFromRunnerJar(runnerJar, file.getName()), fileToSave.getPath()); <line24> sb = new StringBuilder(); <line25> sb.append(""/home/"").append(Utils.DEFAULT_USER).append(""/"").append(fileToSave.getName()); <line26> String destinationFile = sb.toString(); <line27> commands.add(new SCPCommand(fileToSave.getAbsolutePath(), destinationFile)); <line28> sb = new StringBuilder(); <line29> sb.append(""chmod 0755 "") <line30> .append(""/home/"") <line31> .append(Utils.DEFAULT_USER) <line32> .append(""/"") <line33> .append(fileToSave.getName()) <line34> .append("";""); <line35> sb.append(exportVars).append(""sudo -E "").append(destinationFile); <line36> commands.add(new SSHCommand(sb.toString())); <line37> } <line38> } <line39> sb = new StringBuilder(); <line40> sb.append(""sudo su -c \""nohup /usr/bin/java -Darchaius.deployment.environment=CHOP -jar "") <line41> .append(destFile) <line42> .append("" > /var/log/chop-runner.log 2>&1 &\""""); <line43> commands.add(new SSHCommand(sb.toString())); <line44> return executeSSHCommands(sshValues, commands); <line45> } <line46> } <line47> "	 <line5>	Yes
"public class A { <line0> BillReceipt linkBillToReceipt(final BillReceiptInfo bri) <line1> throws InvalidAccountHeadException, ObjectNotFoundException { <line2> BillReceipt billRecpt = null; <line3> if (bri == null) throw new ApplicationRuntimeException("" BillReceiptInfo Object is null ""); <line4> final EgBill egBill = egBillDAO.findById(Long.valueOf(bri.getBillReferenceNum()), false); <line5> if (egBill == null) <line6> throw new ApplicationRuntimeException( <line7> "" EgBill Object is null for the Bill Number"" + bri.getBillReferenceNum()); <line8> final List<EgBillDetails> billDetList = egBillDetailsDAO.getBillDetailsByBill(egBill); <line9> final BigDecimal totalCollectedAmt = calculateTotalCollectedAmt(bri, billDetList); <line10> if (bri.getEvent() == null) <line11> throw new ApplicationRuntimeException("" Event in BillReceiptInfo Object is Null""); <line12> if (bri.getEvent().equals(BillingIntegrationService.EVENT_RECEIPT_CREATED)) { <line13> billRecpt = prepareBillReceiptBean(bri, egBill, totalCollectedAmt); <line14> egBillReceiptDAO.create(billRecpt); <line15> } else if (bri.getEvent().equals(BillingIntegrationService.EVENT_RECEIPT_CANCELLED)) <line16> billRecpt = updateBillReceiptForCancellation(bri, egBill, totalCollectedAmt); <line17> return billRecpt; <line18> } <line19> } <line20> "	 <line2>	Yes
public class A { <line0> public String getPath() { <line1> String clusterName = _params[0]; <line2> String[] subKeys = Arrays.copyOfRange(_params, 1, _params.length); <line3> String path = PropertyPathBuilder.getPath(_type, clusterName, subKeys); <line4> if (path == null) { <line5> } <line6> return path; <line7> } <line8> } <line9> 	 <line7>	No
public class A { <line0> public RelNode genLogicalPlan(HiveParserASTNode ast) throws SemanticException { <line1> HiveParserPreCboCtx cboCtx = new HiveParserPreCboCtx(); <line2> processPositionAlias(ast, semanticAnalyzer.getConf()); <line3> if (!semanticAnalyzer.genResolvedParseTree(ast, cboCtx)) { <line4> return null; <line5> } <line6> for (String alias : semanticAnalyzer.getQB().getSubqAliases()) { <line7> removeOBInSubQuery(semanticAnalyzer.getQB().getSubqForAlias(alias)); <line8> } <line9> HiveParserASTNode queryForCbo = ast; <line10> if (cboCtx.type == HiveParserPreCboCtx.Type.CTAS <line11> || cboCtx.type == HiveParserPreCboCtx.Type.VIEW) { <line12> queryForCbo = cboCtx.nodeOfInterest; <line13> } <line14> verifyCanHandleAst(queryForCbo, getQB(), semanticAnalyzer.getQueryProperties()); <line15> semanticAnalyzer.disableJoinMerge = true; <line16> return logicalPlan(); <line17> } <line18> } <line19> 	 <line1>	Yes
"public class A { <line0> private void _initializeJasperVersion() { <line1> Class<?> clazz = getClass(); <line2> URL url = clazz.getResource(""/org/apache/jasper/JasperException.class""); <line3> if (url == null) { <line4> return; <line5> } <line6> String path = url.getPath(); <line7> int pos = path.indexOf(CharPool.EXCLAMATION); <line8> if (pos == -1) { <line9> return; <line10> } <line11> try (JarFile jarFile = new JarFile(new File(new URI(path.substring(0, pos))))) { <line12> Manifest manifest = jarFile.getManifest(); <line13> Attributes attributes = manifest.getMainAttributes(); <line14> if (attributes.containsKey(Attributes.Name.SPECIFICATION_VERSION)) { <line15> _jasperVersion = <line16> GetterUtil.getString(attributes.getValue(Attributes.Name.SPECIFICATION_VERSION)); <line17> if (_isValidJasperVersion(_jasperVersion)) { <line18> return; <line19> } <line20> } <line21> if (attributes.containsKey(Attributes.Name.IMPLEMENTATION_VERSION)) { <line22> _jasperVersion = <line23> GetterUtil.getString(attributes.get(Attributes.Name.IMPLEMENTATION_VERSION)); <line24> if (_isValidJasperVersion(_jasperVersion)) { <line25> return; <line26> } <line27> } <line28> Attributes.Name bundleVersionAttributesName = new Attributes.Name(""Bundle-Version""); <line29> if (attributes.containsKey(bundleVersionAttributesName)) { <line30> _jasperVersion = GetterUtil.getString(attributes.get(bundleVersionAttributesName)); <line31> if (_isValidJasperVersion(_jasperVersion)) { <line32> return; <line33> } <line34> _jasperVersion = StringPool.BLANK; <line35> } <line36> } catch (Exception exception) { <line37> } <line38> } <line39> } <line40> "	 <line23>	No
"public class A { <line0> @Override <line1> public void onEvent(final DiscoveryEvent evt, final DiscoCache discoCache) { <line2> if (!enterBusy()) return; <line3> try { <line4> final UUID snd = evt.eventNode().id(); <line5> final int evtType = evt.type(); <line6> assert snd != null : ""Event's node id shouldn't be null.""; <line7> assert evtType == EVT_NODE_JOINED <line8> || evtType == EVT_NODE_LEFT <line9> || evtType == EVT_NODE_FAILED <line10> || evtType == EVT_DISCOVERY_CUSTOM_EVT <line11> : ""Unexpected event was received, evt="" + evt; <line12> if (evtType == EVT_DISCOVERY_CUSTOM_EVT) { <line13> DiscoveryCustomMessage msg = ((DiscoveryCustomEvent) evt).customMessage(); <line14> if (msg instanceof ChangeGlobalStateFinishMessage) { <line15> ChangeGlobalStateFinishMessage msg0 = (ChangeGlobalStateFinishMessage) msg; <line16> if (msg0.clusterActive()) <line17> pendingEvts.forEach(t -> addTask(t.evt, t.topVer, t.depActions)); <line18> else if (log.isDebugEnabled()) <line19> pendingEvts.clear(); <line20> } else { <line21> if (msg instanceof ServiceClusterDeploymentResultBatch) { <line22> ServiceClusterDeploymentResultBatch msg0 = (ServiceClusterDeploymentResultBatch) msg; <line23> if (log.isDebugEnabled()) { <line24> } <line25> ServiceDeploymentProcessId depId = msg0.deploymentId(); <line26> assert depId != null; <line27> ServiceDeploymentTask task = tasks.get(depId); <line28> if (task != null) task.onReceiveFullDeploymentsMessage(msg0); <line29> } else if (msg instanceof CacheAffinityChangeMessage) <line30> addTask(copyIfNeeded((DiscoveryCustomEvent) evt), discoCache.version(), null); <line31> else { <line32> ServiceDeploymentActions depActions = null; <line33> if (msg instanceof ChangeGlobalStateMessage) <line34> depActions = ((ChangeGlobalStateMessage) msg).servicesDeploymentActions(); <line35> else if (msg instanceof ServiceChangeBatchRequest) { <line36> depActions = ((ServiceChangeBatchRequest) msg).servicesDeploymentActions(); <line37> } else if (msg instanceof DynamicCacheChangeBatch) <line38> depActions = ((DynamicCacheChangeBatch) msg).servicesDeploymentActions(); <line39> if (depActions != null) <line40> addTask(copyIfNeeded((DiscoveryCustomEvent) evt), discoCache.version(), depActions); <line41> } <line42> } <line43> } else { <line44> if (evtType == EVT_NODE_LEFT || evtType == EVT_NODE_FAILED) <line45> tasks.values().forEach(t -> t.onNodeLeft(snd)); <line46> checkClusterStateAndAddTask(evt, discoCache, null); <line47> } <line48> } finally { <line49> leaveBusy(); <line50> } <line51> } <line52> } <line53> "	 <line1>	No
public class A { <line0> @LifecycleStop <line1> public void stop() { <line2> synchronized (startStopLock) { <line3> if (started) { <line4> if (exec != null) { <line5> exec.shutdownNow(); <line6> exec = null; <line7> } <line8> started = false; <line9> } <line10> } <line11> } <line12> } <line13> 	 <line9>	Yes
"public class A { <line0> @Override <line1> public CompletableFuture<X509CertificateHolder> inspectCSR(PKCS10CertificationRequest csr) { <line2> CompletableFuture<X509CertificateHolder> response = new CompletableFuture<>(); <line3> try { <line4> if (!verifyPkcs10Request(csr)) { <line5> response.completeExceptionally(new SCMSecurityException(""Failed to "" + ""verify the CSR."")); <line6> } <line7> for (RDN rdn : csr.getSubject().getRDNs()) { <line8> if (!profile.validateRDN(rdn)) { <line9> response.completeExceptionally( <line10> new SCMSecurityException( <line11> ""Failed to "" + ""verify the RDNs. Please check the subject name."")); <line12> } <line13> } <line14> if (!verfiyExtensions(csr)) { <line15> response.completeExceptionally( <line16> new SCMSecurityException(""Failed to "" + ""verify extensions."")); <line17> } <line18> } catch (OperatorCreationException | PKCSException e) { <line19> response.completeExceptionally(new SCMSecurityException(e)); <line20> } <line21> return response; <line22> } <line23> } <line24> "	 <line5>	Yes
"public class A { <line0> @Test <line1> public void test_01() { <line2> if (verbose) { <line3> Exon exFirst = transcript.sorted().get(0); <line4> String exFirstSeq = <line5> exFirst.isStrandPlus() ? exFirst.getSequence() : GprSeq.reverseWc(exFirst.getSequence()); <line6> } <line7> Variant variant = new Variant(chromosome, 1001, """", ""C"", """"); <line8> VariantEffects effs = snpEffectPredictor.variantEffect(variant); <line9> VariantEffect eff = effs.get(); <line10> HgvsDna hgvsc = new HgvsDna(eff); <line11> String hgvsDna = hgvsc.toString(); <line12> Assert.assertEquals(""c.1dupG"", hgvsDna); <line13> } <line14> } <line15> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public Representation get() { <line2> StringRepresentation presentation = null; <line3> try { <line4> String clusterName = (String) getRequest().getAttributes().get(""clusterName""); <line5> String instanceName = (String) getRequest().getAttributes().get(""instanceName""); <line6> presentation = getInstanceErrorsRepresentation(clusterName, instanceName); <line7> } catch (Exception e) { <line8> String error = ClusterRepresentationUtil.getErrorAsJsonStringFromException(e); <line9> presentation = new StringRepresentation(error, MediaType.APPLICATION_JSON); <line10> } <line11> return presentation; <line12> } <line13> } <line14> "	 <line3>	No
public class A { <line0> public static com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecordSoap[] <line1> getFormInstanceRecords(long ddmFormInstanceId) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecord> returnValue = <line4> DDMFormInstanceRecordServiceUtil.getFormInstanceRecords(ddmFormInstanceId); <line5> return com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecordSoap.toSoapModels( <line6> returnValue); <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	 <line8>	Yes
"public class A { <line0> @Path(""/deploy/from/{environment}"") <line1> @GET <line2> public Response deploy(@PathParam(""environment"") String environment) { <line3> String url = getTDMURL() + ""/api/bundle/deploy/from/"" + environment; <line4> String json = _remoteConnectionService.getContent(url); <line5> return Response.ok(json).build(); <line6> } <line7> } <line8> "	 <line2>	No
"public class A { <line0> @Override <line1> @Retryable( <line2> backoff = <line3> @Backoff( <line4> delayExpression = ""#{@recordParserProperties.getRetry().getMinBackoff().toMillis()}"", <line5> maxDelayExpression = <line6> ""#{@recordParserProperties.getRetry().getMaxBackoff().toMillis()}"", <line7> multiplierExpression = ""#{@recordParserProperties.getRetry().getMultiplier()}""), <line8> maxAttemptsExpression = ""#{@recordParserProperties.getRetry().getMaxAttempts()}"") <line9> @ServiceActivator( <line10> inputChannel = CHANNEL_RECORD, <line11> poller = @Poller(fixedDelay = ""${hedera.mirror.importer.parser.record.frequency:100}"")) <line12> @Transactional <line13> public void parse(RecordFile recordFile) { <line14> if (!parserProperties.isEnabled()) { <line15> return; <line16> } <line17> Stopwatch stopwatch = Stopwatch.createStarted(); <line18> DateRangeFilter dateRangeFilter = <line19> mirrorDateRangePropertiesProcessor.getDateRangeFilter(parserProperties.getStreamType()); <line20> AtomicInteger counter = new AtomicInteger(0); <line21> boolean success = false; <line22> try { <line23> recordStreamFileListener.onStart(); <line24> recordFile <line25> .getItems() <line26> .forEach( <line27> recordItem -> { <line28> if (processRecordItem(recordItem, dateRangeFilter)) { <line29> counter.incrementAndGet(); <line30> } <line31> }); <line32> byte[] bytes = recordFile.getBytes(); <line33> if (!parserProperties.isPersistBytes()) { <line34> recordFile.setBytes(null); <line35> } <line36> Instant loadEnd = Instant.now(); <line37> recordFile.setLoadEnd(loadEnd.getEpochSecond()); <line38> recordStreamFileListener.onEnd(recordFile); <line39> if (parserProperties.isKeepFiles()) { <line40> Utility.archiveFile(recordFile.getName(), bytes, parserProperties.getParsedPath()); <line41> } <line42> Instant consensusEnd = Instant.ofEpochSecond(0L, recordFile.getConsensusEnd()); <line43> parseLatencyMetric.record(Duration.between(consensusEnd, loadEnd)); <line44> success = true; <line45> } catch (Exception ex) { <line46> recordStreamFileListener.onError(); <line47> throw ex; <line48> } finally { <line49> parseDurationMetrics.get(success).record(stopwatch.elapsed()); <line50> } <line51> } <line52> } <line53> "	 <line46>	Yes
public class A { <line0> public static Optional<String> createIndexIfNotExists(EsConfig config, IndexParams indexParams) { <line1> try (EsClient esClient = EsClient.from(config)) { <line2> if (!EsService.existsIndex(esClient, indexParams.getIndexName())) { <line3> return Optional.of(EsService.createIndex(esClient, indexParams)); <line4> } <line5> } <line6> return Optional.empty(); <line7> } <line8> } <line9> 	 <line8>	No
public class A { <line0> @Override <line1> public void remoteDeviceAdded(Registry registry, RemoteDevice device) { <line2> for (UpnpDiscoveryParticipant participant : participants) { <line3> try { <line4> DiscoveryResult result = participant.createResult(device); <line5> if (result != null) { <line6> if (participant.getRemovalGracePeriodSeconds(device) > 0) { <line7> cancelRemovalTask(device.getIdentity().getUdn()); <line8> } <line9> thingDiscovered(result); <line10> } <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> } <line16> 	 <line12>	Yes
"public class A { <line0> @GET <line1> @Path(""subregion/{subregion}"") <line2> public Object getBySubregion(@PathParam(""subregion"") String subregion) { <line3> try { <line4> List<Country> countries = CountryService.getInstance().getBySubregion(subregion); <line5> if (!countries.isEmpty()) { <line6> return countries; <line7> } <line8> return getResponse(Status.NOT_FOUND); <line9> } catch (Exception e) { <line10> return getResponse(Status.INTERNAL_SERVER_ERROR); <line11> } <line12> } <line13> } <line14> "	 <line9>	No
"public class A { <line0> public static com.liferay.journal.model.JournalArticle removeArticleLocale( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> String articleId, <line4> double version, <line5> String languageId) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey( <line10> JournalArticleServiceUtil.class, <line11> ""removeArticleLocale"", <line12> _removeArticleLocaleParameterTypes58); <line13> MethodHandler methodHandler = <line14> new MethodHandler(methodKey, groupId, articleId, version, languageId); <line15> Object returnObj = null; <line16> try { <line17> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line18> } catch (Exception exception) { <line19> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line20> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line21> } <line22> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line23> } <line24> return (com.liferay.journal.model.JournalArticle) returnObj; <line25> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line26> throw systemException; <line27> } <line28> } <line29> } <line30> "	 <line26>	Yes
public class A { <line0> @Override <line1> public Row nextRecordInternal(Row row) throws IOException { <line2> try { <line3> row = queue.take(); <line4> } catch (InterruptedException e) { <line5> } <line6> return row; <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> public static void updateWorker(UUID taskId, WorkerType workerType) { <line1> Connection connection = Persistence.getInstance().getConnection(); <line2> try (CallableStatement query = connection.prepareCall(""{call update_task_worker(?,?)}"")) { <line3> query.setObject(1, taskId); <line4> query.setString(2, workerType.toString()); <line5> query.executeQuery(); <line6> } catch (SQLException e) { <line7> } <line8> } <line9> } <line10> "	 <line7>	Yes
public class A { <line0> public void fillTile(InternalTile tile, Envelope maxTileExtent) throws GeomajasException { <line1> List<InternalFeature> origFeatures = tile.getFeatures(); <line2> tile.setFeatures(new ArrayList<InternalFeature>()); <line3> for (InternalFeature feature : origFeatures) { <line4> if (!addTileCode(tile, maxTileExtent, feature.getGeometry())) { <line5> tile.addFeature(feature); <line6> } <line7> } <line8> } <line9> } <line10> 	 <line9>	No
"public class A { <line0> private void formatMonitorUrl(String monitorUrlStr) { <line1> if (monitorUrlStr.startsWith(ConstantValue.KEY_HTTP)) { <line2> String url; <line3> if (monitorUrlStr.endsWith(ConstantValue.SINGLE_SLASH_SYMBOL)) { <line4> url = monitorUrlStr + ""jobs/"" + jobId + ""/accumulators""; <line5> } else { <line6> url = monitorUrlStr + ""/jobs/"" + jobId + ""/accumulators""; <line7> } <line8> monitorUrls.add(url); <line9> } else { <line10> String[] monitor = monitorUrlStr.split("",""); <line11> for (int i = 0; i < monitor.length; ++i) { <line12> String url = ""http://"" + monitor[i] + ""/jobs/"" + jobId + ""/accumulators""; <line13> monitorUrls.add(url); <line14> } <line15> } <line16> if (DtLogger.isEnableDebug()) { <line17> } <line18> } <line19> } <line20> "	 <line3>	No
"public class A { <line0> public List findByExample(MbZielobjZusatz instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.MbZielobjZusatz"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line7>	No
public class A { <line0> @Override <line1> public void initialize( <line2> AnnotatorCompatible walker, GenomeAnalysisEngine toolkit, Set<VCFHeaderLine> headerLines) { <line3> if (founderIds == null && walker != null) { <line4> founderIds = ((Walker) walker).getSampleDB().getFounderIds(); <line5> } <line6> if (walker != null <line7> && (((Walker) walker).getSampleDB().getSamples().size() < MIN_SAMPLES <line8> || (!founderIds.isEmpty() && founderIds.size() < MIN_SAMPLES))) <line9> heterozygosityUtils = new HeterozygosityUtils(RETURN_ROUNDED); <line10> } <line11> } <line12> 	 <line3>	No
"public class A { <line0> private String createBitarchiveAppId() throws UnknownID { <line1> String id; <line2> id = SystemUtils.getLocalIP(); <line3> try { <line4> String applicationInstanceId = Settings.get(CommonSettings.APPLICATION_INSTANCE_ID); <line5> if (!applicationInstanceId.isEmpty()) { <line6> id += ""_"" + applicationInstanceId; <line7> } <line8> } catch (UnknownID e) { <line9> } <line10> return id; <line11> } <line12> } <line13> "	 <line10>	No
"public class A { <line0> Future<ReconciliationState> kafkaRoutes() { <line1> List<Route> routes = new ArrayList<>(kafkaCluster.generateExternalBootstrapRoutes()); <line2> if (routes.size() > 0) { <line3> if (pfa.hasRoutes()) { <line4> int replicas = kafkaCluster.getReplicas(); <line5> for (int i = 0; i < replicas; i++) { <line6> routes.addAll(kafkaCluster.generateExternalRoutes(i)); <line7> } <line8> Future fut = <line9> routeOperations <line10> .listAsync(namespace, kafkaCluster.getSelectorLabels()) <line11> .compose( <line12> existingRoutes -> { <line13> List<Future> routeFutures = new ArrayList<>(routes.size()); <line14> List<String> existingRouteNames = <line15> existingRoutes.stream() <line16> .map(route -> route.getMetadata().getName()) <line17> .collect(Collectors.toList()); <line18> for (Route route : routes) { <line19> String routeName = route.getMetadata().getName(); <line20> existingRouteNames.remove(routeName); <line21> routeFutures.add(routeOperations.reconcile(namespace, routeName, route)); <line22> } <line23> for (String routeName : existingRouteNames) { <line24> routeFutures.add(routeOperations.reconcile(namespace, routeName, null)); <line25> } <line26> return CompositeFuture.join(routeFutures); <line27> }); <line28> return withVoid(fut); <line29> } else { <line30> return withVoid( <line31> Future.failedFuture( <line32> ""The OpenShift route API is not available in this Kubernetes cluster. Exposing"" <line33> + "" Kafka cluster "" <line34> + name <line35> + "" using routes is not possible."")); <line36> } <line37> } <line38> return withVoid(Future.succeededFuture()); <line39> } <line40> } <line41> "	 <line37>	No
"public class A { <line0> @Override <line1> public void put( <line2> final String uri, MultiMap headers, Buffer buffer, final Handler<Integer> doneHandler) { <line3> HttpClientRequest request = <line4> client.put( <line5> uri, <line6> response -> { <line7> response.exceptionHandler( <line8> exception -> { <line9> doneHandler.handle(StatusCode.INTERNAL_SERVER_ERROR.getStatusCode()); <line10> }); <line11> response.endHandler(event -> doneHandler.handle(response.statusCode())); <line12> }); <line13> request.exceptionHandler( <line14> exception -> { <line15> doneHandler.handle(StatusCode.INTERNAL_SERVER_ERROR.getStatusCode()); <line16> }); <line17> if (headers != null) { <line18> request.headers().addAll(headers); <line19> } <line20> request.setTimeout(TIMEOUT); <line21> request.putHeader(""Content-Length"", """" + buffer.length()); <line22> request.write(buffer); <line23> request.end(); <line24> } <line25> } <line26> "	 <line15>	Yes
public class A { <line0> @Override <line1> public void loadChannelValues(HmChannel channel) throws IOException { <line2> if (channel.getDevice().isGatewayExtras()) { <line3> if (!HmChannel.CHANNEL_NUMBER_EXTRAS.equals(channel.getNumber())) { <line4> List<HmDatapoint> datapoints = channel.getDatapoints(); <line5> if (HmChannel.CHANNEL_NUMBER_VARIABLE.equals(channel.getNumber())) { <line6> loadVariables(channel); <line7> } else if (HmChannel.CHANNEL_NUMBER_SCRIPT.equals(channel.getNumber())) { <line8> loadScripts(channel); <line9> } <line10> } <line11> } else { <line12> setChannelDatapointValues(channel, HmParamsetType.MASTER); <line13> setChannelDatapointValues(channel, HmParamsetType.VALUES); <line14> } <line15> for (HmDatapoint dp : channel.getDatapoints()) { <line16> handleVirtualDatapointEvent(dp, false); <line17> } <line18> channel.setInitialized(true); <line19> } <line20> } <line21> 	 <line3>	No
public class A { <line0> private static <E extends Exception> void doWhenExceptionCaught( <line1> E e, <line2> Map<Class<?>, String> exceptionStringMap, <line3> AtomicInteger retriesCounter, <line4> int maxRetries, <line5> int periodBetweenRetriesInMillis) <line6> throws E { <line7> retriesCounter.incrementAndGet(); <line8> final boolean causeMatches = <line9> doesExceptionCauseMatchAnyOfProvidedExceptions(exceptionStringMap, e); <line10> if (retriesCounter.get() > maxRetries || !causeMatches) { <line11> throw e; <line12> } <line13> if (LOGGER.isWarnEnabled()) { <line14> } <line15> try { <line16> Thread.sleep(periodBetweenRetriesInMillis); <line17> } catch (InterruptedException ex) { <line18> Thread.currentThread().interrupt(); <line19> } <line20> } <line21> } <line22> 	 <line18>	Yes
public class A { <line0> @ViewChanged <line1> public void viewChanged(ViewChangedEvent event) { <line2> if (Event.Type.VIEW_CHANGED.equals(event.getType()) && isCoordinator()) { <line3> List<Address> changedAddress = event.getNewMembers(); <line4> Cache<Address, ClusterNode> nodes = <line5> cacheManager.<Address, ClusterNode>getCache(CLUSTER_NODES_KEY); <line6> CacheSet<Address> currentView = <line7> cacheManager.<Address, ClusterNode>getCache(CLUSTER_NODES_KEY).keySet(); <line8> List<Address> membersLeft = new ArrayList<>(); <line9> Iterator<Address> oldAddresses = currentView.iterator(); <line10> while (oldAddresses.hasNext()) { <line11> Address address = oldAddresses.next(); <line12> if (!changedAddress.contains(address)) { <line13> membersLeft.add(address); <line14> } <line15> } <line16> membersLeft.forEach(node -> nodes.remove(node)); <line17> } <line18> } <line19> } <line20> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void onDropSentryRole(TDropSentryRoleRequest request) throws SentryPluginException { <line2> PermissionsUpdate update = new PermissionsUpdate(permSeqNum.incrementAndGet(), false); <line3> update <line4> .addPrivilegeUpdate(PermissionsUpdate.ALL_AUTHZ_OBJ) <line5> .putToDelPrivileges(request.getRoleName(), PermissionsUpdate.ALL_AUTHZ_OBJ); <line6> update.addRoleUpdate(request.getRoleName()).addToDelGroups(PermissionsUpdate.ALL_GROUPS); <line7> permsUpdater.handleUpdateNotification(update); <line8> } <line9> } <line10> 	 <line8>	Yes
public class A { <line0> public void push(Object obj) { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> this.stack.push(obj); <line4> } <line5> } <line6> 	 <line5>	No
"public class A { <line0> public static ContentResponse sendOpenAPIRequest(Request request) throws NanoleafException { <line1> try { <line2> traceSendRequest(request); <line3> ContentResponse openAPIResponse; <line4> openAPIResponse = request.send(); <line5> if (LOGGER.isTraceEnabled()) { <line6> } <line7> int responseStatus = openAPIResponse.getStatus(); <line8> if (responseStatus == HttpStatus.OK_200 || responseStatus == HttpStatus.NO_CONTENT_204) { <line9> return openAPIResponse; <line10> } else { <line11> if (openAPIResponse.getStatus() == HttpStatus.UNAUTHORIZED_401) { <line12> throw new NanoleafUnauthorizedException(""OpenAPI request unauthorized""); <line13> } else if (openAPIResponse.getStatus() == HttpStatus.NOT_FOUND_404) { <line14> throw new NanoleafNotFoundException(""OpenAPI request did not get any result back""); <line15> } else if (openAPIResponse.getStatus() == HttpStatus.BAD_REQUEST_400) { <line16> throw new NanoleafBadRequestException( <line17> String.format( <line18> ""Nanoleaf did not expect this request. HTTP response code %s"", <line19> openAPIResponse.getStatus())); <line20> } else { <line21> throw new NanoleafException( <line22> String.format( <line23> ""OpenAPI request failed. HTTP response code %s"", openAPIResponse.getStatus())); <line24> } <line25> } <line26> } catch (ExecutionException | TimeoutException clientException) { <line27> if (clientException.getCause() instanceof HttpResponseException <line28> && ((HttpResponseException) clientException.getCause()).getResponse().getStatus() <line29> == HttpStatus.UNAUTHORIZED_401) { <line30> throw new NanoleafUnauthorizedException(""Invalid authorization token""); <line31> } <line32> throw new NanoleafException(""Failed to send OpenAPI request"", clientException); <line33> } catch (InterruptedException interruptedException) { <line34> throw new NanoleafInterruptedException( <line35> ""OpenAPI request has been interrupted"", interruptedException); <line36> } <line37> } <line38> } <line39> "	 <line6>	Yes
public class A { <line0> @Override <line1> public BrokerResponse get() throws InterruptedException, ExecutionException { <line2> try { <line3> return get(1000L, TimeUnit.DAYS); <line4> } catch (TimeoutException e) { <line5> throw new InterruptedException(); <line6> } <line7> } <line8> } <line9> 	 <line7>	No
public class A { <line0> @Override <line1> public Map<String, Object> getStats() { <line2> if (job == null) { <line3> return null; <line4> } <line5> try { <line6> Counters jobCounters = job.getCounters(); <line7> Map<String, Object> metrics = <line8> TaskMetricsUtils.makeIngestionRowMetrics( <line9> jobCounters <line10> .findCounter(HadoopDruidIndexerConfig.IndexJobCounters.ROWS_PROCESSED_COUNTER) <line11> .getValue(), <line12> jobCounters <line13> .findCounter( <line14> HadoopDruidIndexerConfig.IndexJobCounters.ROWS_PROCESSED_WITH_ERRORS_COUNTER) <line15> .getValue(), <line16> jobCounters <line17> .findCounter(HadoopDruidIndexerConfig.IndexJobCounters.ROWS_UNPARSEABLE_COUNTER) <line18> .getValue(), <line19> jobCounters <line20> .findCounter(HadoopDruidIndexerConfig.IndexJobCounters.ROWS_THROWN_AWAY_COUNTER) <line21> .getValue()); <line22> return metrics; <line23> } catch (IllegalStateException ise) { <line24> return null; <line25> } catch (Exception e) { <line26> return null; <line27> } <line28> } <line29> } <line30> 	 <line26>	Yes
public class A { <line0> private void persistVehiclePipoData( <line1> VehicleAndCrewDataPersistenceService vehicleAndCrewDataPersistenceService) { <line2> boolean retry = true; <line3> int retryCount = 0; <line4> while (retry) { <line5> try { <line6> vehicleAndCrewDataPersistenceService.saveVehiclePulloutData(); <line7> retry = false; <line8> } catch (DataAccessResourceFailureException e) { <line9> retryCount++; <line10> if (retryCount > 1) { <line11> retry = false; <line12> e.printStackTrace(); <line13> } <line14> if (retry) { <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	 <line15>	Yes
public class A { <line0> private List<TimeSeriesRequestContainer> makeRequests( <line1> Collection<MetricEntity> metrics, long start, long end, Multimap<String, String> filters) { <line2> List<TimeSeriesRequestContainer> requests = new ArrayList<>(); <line3> for (MetricEntity me : metrics) { <line4> Multimap<String, String> jointFilters = ArrayListMultimap.create(); <line5> jointFilters.putAll(filters); <line6> jointFilters.putAll(me.getFilters()); <line7> MetricSlice slice = MetricSlice.from(me.getId(), start, end, jointFilters, this.granularity); <line8> try { <line9> requests.add( <line10> DataFrameUtils.makeTimeSeriesRequestAligned( <line11> slice, me.getUrn(), this.metricDAO, this.datasetDAO)); <line12> } catch (Exception ex) { <line13> } <line14> } <line15> return requests; <line16> } <line17> } <line18> 	 <line12>	No
"public class A { <line0> protected void assertCreatedRepositoryHas6Locales( <line1> String testRepoName, String testDescription, Boolean expectIntegrityChecker) { <line2> assertTrue(outputCapture.toString().contains(""--> repository id: "")); <line3> Repository repository = repositoryRepository.findByName(testRepoName); <line4> assertEquals(testDescription, repository.getDescription()); <line5> assertEquals(6, repository.getRepositoryLocales().size()); <line6> Map<String, RepositoryLocale> repoLocaleMapByBcp47Tag = getRepoLocaleMapByBcp47Tag(repository); <line7> assertNotNull(repoLocaleMapByBcp47Tag.get(""fr-FR"")); <line8> assertNotNull(repoLocaleMapByBcp47Tag.get(""fr-CA"")); <line9> assertNotNull(repoLocaleMapByBcp47Tag.get(""en-GB"")); <line10> assertNotNull(repoLocaleMapByBcp47Tag.get(""en-CA"")); <line11> assertNotNull(repoLocaleMapByBcp47Tag.get(""en-AU"")); <line12> assertNotNull(repoLocaleMapByBcp47Tag.get(""en"")); <line13> assertEquals( <line14> ""fr-FR"", repoLocaleMapByBcp47Tag.get(""fr-CA"").getParentLocale().getLocale().getBcp47Tag()); <line15> assertEquals( <line16> ""en-GB"", repoLocaleMapByBcp47Tag.get(""en-CA"").getParentLocale().getLocale().getBcp47Tag()); <line17> assertEquals( <line18> ""en-GB"", repoLocaleMapByBcp47Tag.get(""en-AU"").getParentLocale().getLocale().getBcp47Tag()); <line19> assertEquals(true, repoLocaleMapByBcp47Tag.get(""fr-FR"").isToBeFullyTranslated()); <line20> assertEquals(false, repoLocaleMapByBcp47Tag.get(""fr-CA"").isToBeFullyTranslated()); <line21> assertEquals(true, repoLocaleMapByBcp47Tag.get(""en-GB"").isToBeFullyTranslated()); <line22> assertEquals(false, repoLocaleMapByBcp47Tag.get(""en-CA"").isToBeFullyTranslated()); <line23> assertEquals(true, repoLocaleMapByBcp47Tag.get(""en-AU"").isToBeFullyTranslated()); <line24> if (expectIntegrityChecker) { <line25> assertEquals(2, repository.getAssetIntegrityCheckers().size()); <line26> for (AssetIntegrityChecker assetIntegrityChecker : repository.getAssetIntegrityCheckers()) { <line27> assertEquals(""properties"", assetIntegrityChecker.getAssetExtension()); <line28> assertTrue( <line29> IntegrityCheckerType.MESSAGE_FORMAT == assetIntegrityChecker.getIntegrityCheckerType() <line30> || IntegrityCheckerType.TRAILING_WHITESPACE <line31> == assetIntegrityChecker.getIntegrityCheckerType()); <line32> } <line33> } <line34> } <line35> } <line36> "	 <line25>	Yes
public class A { <line0> @Test <line1> public void schedulerHelperIsSynchronized() throws Exception { <line2> helper = <line3> SchedulerHelper.create( <line4> new DestroyableLazyInitializer<Runnable>() { <line5> @Override <line6> protected Runnable initialize() { <line7> return new Runnable() { <line8> public void run() { <line9> try { <line10> Thread.sleep(40); <line11> } catch (final Exception e) { <line12> } <line13> } <line14> }; <line15> } <line16> }); <line17> final ThreadLocal<Long> period = <line18> new InheritableThreadLocal<Long>() { <line19> @Override <line20> protected Long initialValue() { <line21> return 0l; <line22> } <line23> }; <line24> final ExecutorService service = Executors.newFixedThreadPool(5); <line25> for (int i = 0; i < 10; i++) { <line26> period.set(period.get() + 30); <line27> service.execute( <line28> new Runnable() { <line29> public void run() { <line30> helper.scheduleWithPeriod(period.get(), TimeUnit.MILLISECONDS); <line31> } <line32> }); <line33> } <line34> Thread.sleep(400); <line35> helper.destroy(); <line36> service.shutdown(); <line37> } <line38> } <line39> 	 <line10>	Yes
"public class A { <line0> @Override <line1> public Map<String, List<Entity>> getEntities(final String question) { <line2> HashMap<String, List<Entity>> mappedEntitiesReturn = new HashMap<>(); <line3> String foxJSONOutput = null; <line4> foxJSONOutput = doTask(question); <line5> if (!"""".equals(foxJSONOutput) && (foxJSONOutput != null)) { <line6> try { <line7> JSONParser parser = new JSONParser(); <line8> JSONObject jsonArray = (JSONObject) parser.parse(foxJSONOutput); <line9> ArrayList<Entity> tmpList = new ArrayList<>(); <line10> for (Object key : jsonArray.keySet()) { <line11> JSONObject json = (JSONObject) jsonArray.get(key); <line12> if (json.keySet().contains(""http://www.w3.org/2005/11/its/rdf#taIdentRef"")) { <line13> Entity ent = new Entity(); <line14> JSONArray uriArray = <line15> (JSONArray) json.get(""http://www.w3.org/2005/11/its/rdf#taIdentRef""); <line16> String uri = (String) ((JSONObject) uriArray.get(0)).get(""value""); <line17> String encode = uri.replaceAll("","", ""%2C""); <line18> ResourceImpl e = new ResourceImpl(encode); <line19> ent.getUris().add(e); <line20> JSONArray typeArray = <line21> (JSONArray) json.get(""http://www.w3.org/2005/11/its/rdf#taClassRef""); <line22> for (int i = 0; i < typeArray.size(); i++) { <line23> JSONObject types = (JSONObject) typeArray.get(i); <line24> encode = ((String) types.get(""value"")).replaceAll("","", ""%2C""); <line25> e = new ResourceImpl(encode); <line26> ent.getPosTypesAndCategories().add(e); <line27> } <line28> JSONArray labelArray = <line29> (JSONArray) <line30> json.get( <line31> ""http://persistence.uni-leipzig.org/nlp2rdf/ontologies/nif-core#anchorOf""); <line32> String label = (String) ((JSONObject) labelArray.get(0)).get(""value""); <line33> ent.setLabel(label); <line34> JSONArray offsetArray = <line35> (JSONArray) <line36> json.get( <line37> ""http://persistence.uni-leipzig.org/nlp2rdf/ontologies/nif-core#beginIndex""); <line38> String offset = (String) ((JSONObject) offsetArray.get(0)).get(""value""); <line39> ent.setOffset(Integer.parseInt(offset)); <line40> tmpList.add(ent); <line41> } <line42> } <line43> mappedEntitiesReturn.put(""en"", tmpList); <line44> } catch (ParseException e) { <line45> } <line46> } <line47> if (!mappedEntitiesReturn.isEmpty()) { <line48> } <line49> return mappedEntitiesReturn; <line50> } <line51> } <line52> "	 <line31>	No
public class A { <line0> public void close() { <line1> closed = true; <line2> executor.shutdown(); <line3> try { <line4> boolean terminated = executor.awaitTermination(timeout.toMillis(), TimeUnit.MILLISECONDS); <line5> if (!terminated) { <line6> } <line7> } catch (InterruptedException e) { <line8> } <line9> } <line10> } <line11> 	 <line3>	No
"public class A { <line0> public BasicFileAttributeView[] getFilesAttributes() { <line1> try { <line2> if (!StorageManagerUtil.isValidDirName(this.getCurrentPath())) { <line3> this.setCurrentPath(""""); <line4> } <line5> if (null == this.getProtectedFolder()) { <line6> BasicFileAttributeView[] bfav = new BasicFileAttributeView[2]; <line7> bfav[0] = this.getRootFolder(false); <line8> bfav[1] = this.getRootFolder(true); <line9> return bfav; <line10> } else { <line11> return this.getStorageManager() <line12> .listAttributes(this.getCurrentPath(), this.getProtectedFolderBoolean()); <line13> } <line14> } catch (Throwable t) { <line15> return null; <line16> } <line17> } <line18> } <line19> "	 <line3>	Yes
public class A { <line0> private static boolean cleanupFilesWithRetry(String[] filesToClean, int maxRetries) <line1> throws Exception { <line2> boolean allCleaned = false; <line3> while (!allCleaned && maxRetries-- > 0) { <line4> allCleaned = true; <line5> for (String f : filesToClean) { <line6> if (!f.trim().isEmpty()) { <line7> URI url = new URI(f); <line8> File file = new File(url); <line9> if (file.exists()) { <line10> deleteFolder(file); <line11> allCleaned = false; <line12> } <line13> } <line14> } <line15> Thread.sleep(200); <line16> } <line17> if (!allCleaned) { <line18> } <line19> return allCleaned; <line20> } <line21> } <line22> 	 <line18>	Yes
public class A { <line0> @Transactional <line1> public void regenerateCertificatesOf(Consumer consumer, boolean lazy) { <line2> Owner owner = ownerCurator.findOwnerById(consumer.getOwnerId()); <line3> if (owner.isUsingSimpleContentAccess()) { <line4> this.contentAccessManager.removeContentAccessCert(consumer); <line5> } <line6> this.regenerateCertificatesOf(consumer.getEntitlements(), lazy); <line7> } <line8> } <line9> 	 <line3>	No
public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (active) { <line3> if (command instanceof RefreshType) { <line4> coapClient.asyncGet(this); <line5> return; <line6> } <line7> switch (channelUID.getId()) { <line8> case CHANNEL_POWER: <line9> if (command instanceof OnOffType) { <line10> setState(((OnOffType) command)); <line11> } else { <line12> } <line13> break; <line14> default: <line15> } <line16> } <line17> } <line18> } <line19> 	 <line18>	No
"public class A { <line0> public Peer findOrCreatePeer( <line1> PeerAddress actualAddr, final String announcedAddress, final boolean create) { <line2> if (actualAddr == null) { <line3> actualAddr = resolveAnnouncedAddress(announcedAddress); <line4> } <line5> if (actualAddr == null) { <line6> return null; <line7> } <line8> String hostName = actualAddr.getHostName(); <line9> if (hostName != null && cjdnsOnly && !hostName.startsWith(""fc"")) { <line10> return null; <line11> } <line12> if (isMyAddress(actualAddr)) { <line13> return null; <line14> } <line15> Peer peer; <line16> if ((peer = inboundPeers.get(actualAddr.getAddrWithPort())) != null) { <line17> return peer; <line18> } <line19> if ((peer = connectablePeers.get(actualAddr.getAddrWithPort())) != null) { <line20> return peer; <line21> } <line22> if (!create) { <line23> return null; <line24> } <line25> PeerAddress apa = resolveAnnouncedAddress(announcedAddress); <line26> peer = <line27> new PeerImpl( <line28> actualAddr, <line29> apa, <line30> blockchainConfig, <line31> blockchain, <line32> timeService, <line33> peerHttpServer.getPeerServlet(), <line34> this, <line35> timeLimiterService.acquireLimiter(""P2PTransport""), <line36> accountService); <line37> listeners.notify(peer, Event.NEW_PEER); <line38> if (apa != null) { <line39> connectablePeers.put(apa.getAddrWithPort(), peer); <line40> } else { <line41> inboundPeers.put(actualAddr.getAddrWithPort(), peer); <line42> } <line43> return peer; <line44> } <line45> } <line46> "	 <line20>	Yes
"public class A { <line0> private void initializeSpringSecurityAclDB() { <line1> SQL_ACLS = Activator.getBundleTextFileContents(""/security_db_scripts/acls.sql""); <line2> executeSqlQuery(SQL_ACLS); <line3> } <line4> } <line5> "	 <line0>	No
"public class A { <line0> public String getContainerId() { <line1> try { <line2> BufferedReader br = <line3> Files.newBufferedReader(Paths.get(""/proc/self/cgroup""), StandardCharsets.UTF_8); <line4> String line = null; <line5> while ((line = br.readLine()) != null) { <line6> if (line.contains(""docker"")) { <line7> return line.substring(line.lastIndexOf('/') + 1, line.length()); <line8> } <line9> } <line10> throw new DockerClientException( <line11> ""Exception obtaining containerId. "" <line12> + ""The file /proc/self/cgroup doesn't contain a line with 'docker'""); <line13> } catch (IOException e) { <line14> throw new DockerClientException( <line15> ""Exception obtaining containerId. "" + ""Exception reading file /proc/self/cgroup"", e); <line16> } <line17> } <line18> } <line19> "	 <line6>	Yes
"public class A { <line0> protected void writeContentType(final StreamResponse response, final ResponseData responseData) { <line1> final String mimeType = responseData.getMimeType(); <line2> if (logger.isDebugEnabled()) { <line3> } <line4> if (mimeType == null) { <line5> response.contentTypeOctetStream(); <line6> return; <line7> } <line8> if (mimeType.startsWith(""text/"")) { <line9> final String charset = LaResponseUtil.getResponse().getCharacterEncoding(); <line10> if (charset != null) { <line11> response.contentType(mimeType + ""; charset="" + charset); <line12> return; <line13> } <line14> } <line15> response.contentType(mimeType); <line16> } <line17> } <line18> "	 <line7>	No
public class A { <line0> public String resolveJndiProperty(String name) { <line1> String propValue = null; <line2> try { <line3> Context initContext = new InitialContext(); <line4> Context envContext = (Context) initContext.lookup(TOMCAT_CONTEXT_NAME); <line5> propValue = (String) envContext.lookup(name); <line6> } catch (NamingException e) { <line7> } <line8> return propValue; <line9> } <line10> } <line11> 	 <line6>	Yes
"public class A { <line0> @DELETE <line1> @Timed <line2> @Path(""{id}"") <line3> @Consumes(APPLICATION_JSON) <line4> @RolesAllowed({""admin"", ""$owner=$graph $action=vertex_delete""}) <line5> public void delete( <line6> @Context GraphManager manager, <line7> @PathParam(""graph"") String graph, <line8> @PathParam(""id"") String idValue, <line9> @QueryParam(""label"") String label) { <line10> Id id = checkAndParseVertexId(idValue); <line11> HugeGraph g = graph(manager, graph); <line12> commit( <line13> g, <line14> () -> { <line15> try { <line16> g.removeVertex(label, id); <line17> } catch (NotFoundException e) { <line18> throw new IllegalArgumentException( <line19> String.format(""No such vertex with id: '%s', %s"", id, e)); <line20> } catch (NoSuchElementException e) { <line21> throw new IllegalArgumentException(String.format(""No such vertex with id: '%s'"", id)); <line22> } <line23> }); <line24> } <line25> } <line26> "	 <line9>	No
public class A { <line0> public void setValue(String value) { <line1> if (componentDao != null) { <line2> Component component = componentDao.getComponent(); <line3> component.setProperty(name, value); <line4> componentDao.saveOrUpdate(component); <line5> } else { <line6> } <line7> } <line8> } <line9> 	 <line7>	No
public class A { <line0> protected final void handleClosed(AmqpProvider provider, ProviderException cause) { <line1> provider.removeFromFailOnConnectionDropTracking(request); <line2> resourceInfo.setState(ResourceState.REMOTELY_CLOSED); <line3> afterClosed(getResource(), getResourceInfo()); <line4> ProviderException openError; <line5> if (hasRemoteError()) { <line6> openError = getOpenAbortExceptionFromRemote(); <line7> } else if (cause != null) { <line8> openError = cause; <line9> } else { <line10> openError = getDefaultOpenAbortException(); <line11> } <line12> if (requestTimeoutTask != null) { <line13> requestTimeoutTask.cancel(false); <line14> } <line15> getEndpoint().close(); <line16> getEndpoint().free(); <line17> getEndpoint().setContext(null); <line18> getRequest().onFailure(openError); <line19> } <line20> } <line21> 	 <line15>	Yes
"public class A { <line0> private void doAsyncGetLedgersInSingleNode( <line1> final String nodePath, final GenericCallback<HashSet<Long>> getLedgersCallback) { <line2> zk.getChildren( <line3> nodePath, <line4> false, <line5> new AsyncCallback.ChildrenCallback() { <line6> @Override <line7> public void processResult(int rc, String path, Object ctx, List<String> ledgerNodes) { <line8> if (rc != Code.OK.intValue()) { <line9> getLedgersCallback.operationComplete(rc, null); <line10> return; <line11> } <line12> HashSet<Long> allActiveLedgers = new HashSet<Long>(ledgerNodes.size(), 1.0f); <line13> for (String ledgerNode : ledgerNodes) { <line14> if (isSpecialZnode(ledgerNode)) { <line15> continue; <line16> } <line17> try { <line18> allActiveLedgers.add(getLedgerId(path + ""/"" + ledgerNode)); <line19> } catch (IOException ie) { <line20> continue; <line21> } <line22> } <line23> getLedgersCallback.operationComplete(rc, allActiveLedgers); <line24> } <line25> }, <line26> null); <line27> } <line28> } <line29> "	 <line8>	No
"public class A { <line0> @Test <line1> public void linearringQueryTest() throws IOException { <line2> final String linearring = ""LINEARRING (12 12, 14 10, 13 14, 12 12)""; <line3> OccurrenceSearchRequest searchRequest = new OccurrenceSearchRequest(); <line4> searchRequest.addGeometryFilter(linearring); <line5> QueryBuilder query = <line6> EsSearchRequestBuilder.buildQueryNode(searchRequest) <line7> .orElseThrow(IllegalArgumentException::new); <line8> JsonNode jsonQuery = MAPPER.readTree(query.toString()); <line9> assertTrue( <line10> jsonQuery <line11> .path(BOOL) <line12> .path(FILTER) <line13> .get(0) <line14> .path(BOOL) <line15> .path(SHOULD) <line16> .get(0) <line17> .path(GEO_SHAPE) <line18> .path(COORDINATE_SHAPE.getFieldName()) <line19> .has(SHAPE)); <line20> JsonNode shape = <line21> jsonQuery <line22> .path(BOOL) <line23> .path(FILTER) <line24> .get(0) <line25> .path(BOOL) <line26> .path(SHOULD) <line27> .get(0) <line28> .path(GEO_SHAPE) <line29> .path(COORDINATE_SHAPE.getFieldName()) <line30> .path(SHAPE); <line31> assertEquals(""LineString"", shape.get(TYPE).asText()); <line32> assertTrue(shape.get(COORDINATES).isArray()); <line33> assertEquals(4, shape.get(COORDINATES).size()); <line34> assertEquals(12, shape.get(COORDINATES).get(0).get(0).asDouble(), 0); <line35> } <line36> } <line37> "	 <line19>	No
"public class A { <line0> @Override <line1> public Router createGlobalRouter() { <line2> Router router = Router.router(vertx()); <line3> router <line4> .route(""/scope"") <line5> .handler( <line6> rc -> { <line7> rc.response().end(ConflictingClass.scope); <line8> }); <line9> router <line10> .route(""/check"") <line11> .handler( <line12> rc -> { <line13> rc.response().end(ConflictingClass.check()); <line14> }); <line15> return router; <line16> } <line17> } <line18> "	 <line7>	No
"public class A { <line0> private DeploymentPackage installDeploymentPackageInternal(String urlSpec) <line1> throws DeploymentException, IOException, GeneralSecurityException { <line2> URL url = new URL(urlSpec); <line3> File dpFile = null; <line4> if (!""file"".equals(url.getProtocol())) { <line5> dpFile = getFileFromRemote(url); <line6> } else { <line7> dpFile = getFileFromFilesystem(url); <line8> } <line9> DeploymentPackage dp = null; <line10> try (InputStream dpInputStream = new FileInputStream(dpFile); ) { <line11> dp = this.deploymentAdmin.installDeploymentPackage(dpInputStream); <line12> String dpFsName = dp.getName() + ""_"" + dp.getVersion() + "".dp""; <line13> String dpPersistentFilePath = this.packagesPath + File.separator + dpFsName; <line14> File dpPersistentFile = new File(dpPersistentFilePath); <line15> if (!dpFile.getCanonicalPath().equals(dpPersistentFile.getCanonicalPath())) { <line16> FileUtils.copyFile(dpFile, dpPersistentFile); <line17> addPackageToConfFile(dp.getName(), ""file:"" + dpPersistentFilePath); <line18> } <line19> } finally { <line20> File packagesFolder = new File(this.packagesPath); <line21> if (!dpFile.getCanonicalPath().startsWith(packagesFolder.getCanonicalPath())) { <line22> Files.delete(dpFile.toPath()); <line23> } <line24> } <line25> return dp; <line26> } <line27> } <line28> "	 <line12>	No
public class A { <line0> public boolean move(FsFile<T> destination) { <line1> postClientAction(ClientActionEvent.ClientAction.RENAME); <line2> return file.renameTo(new File(destination.getAbsolutePath())); <line3> } <line4> } <line5> 	 <line1>	Yes
"public class A { <line0> @Override <line1> public JMXConnector connect(Object credentials) { <line2> try { <line3> String jmxSerURL = """"; <line4> if (repository.getJmxUseLocator()) { <line5> JmxManagerInfo jmxManagerInfo = getManagerInfoFromLocator(repository); <line6> if (jmxManagerInfo.port == 0) { <line7> } else { <line8> jmxSerURL = <line9> formJMXServiceURLString(jmxManagerInfo.host, String.valueOf(jmxManagerInfo.port)); <line10> } <line11> } else { <line12> jmxSerURL = formJMXServiceURLString(serverName, port); <line13> } <line14> if (StringUtils.isNotBlank(jmxSerURL)) { <line15> JMXServiceURL url = new JMXServiceURL(jmxSerURL); <line16> Map<String, Object> env = new HashMap<>(); <line17> env.put(JMXConnector.CREDENTIALS, credentials); <line18> Properties originalProperties = System.getProperties(); <line19> try { <line20> Properties updatedProperties = new Properties(originalProperties); <line21> if (repository.isUseSSLManager()) { <line22> for (String sslProperty : repository.getJavaSslProperties().stringPropertyNames()) { <line23> updatedProperties.setProperty( <line24> sslProperty, repository.getJavaSslProperties().getProperty(sslProperty)); <line25> } <line26> System.setProperties(updatedProperties); <line27> env.put(""com.sun.jndi.rmi.factory.socket"", new SslRMIClientSocketFactory()); <line28> } <line29> conn = JMXConnectorFactory.connect(url, env); <line30> mbs = conn.getMBeanServerConnection(); <line31> cluster.setConnectedFlag(true); <line32> } finally { <line33> System.setProperties(originalProperties); <line34> } <line35> } <line36> } catch (Exception e) { <line37> cluster.setConnectedFlag(false); <line38> cluster.setConnectionErrorMsg(e.getMessage()); <line39> if (conn != null) { <line40> try { <line41> conn.close(); <line42> } catch (Exception e1) { <line43> } <line44> conn = null; <line45> } <line46> } <line47> return conn; <line48> } <line49> } <line50> "	 <line18>	No
public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSession session) <line2> throws ProcessException { <line3> FlowFile flowFile = session.get(); <line4> if (flowFile == null) { <line5> return; <line6> } <line7> final String charsetName = context.getProperty(CHARSET).getValue(); <line8> final SyslogParser parser = new SyslogParser(Charset.forName(charsetName)); <line9> final byte[] buffer = new byte[(int) flowFile.getSize()]; <line10> session.read( <line11> flowFile, <line12> new InputStreamCallback() { <line13> @Override <line14> public void process(final InputStream in) throws IOException { <line15> StreamUtils.fillBuffer(in, buffer); <line16> } <line17> }); <line18> final SyslogEvent event; <line19> try { <line20> event = parser.parseEvent(buffer, null); <line21> } catch (final ProcessException pe) { <line22> getLogger() <line23> session.transfer(flowFile, REL_FAILURE); <line24> return; <line25> } <line26> if (!event.isValid()) { <line27> getLogger() <line28> session.transfer(flowFile, REL_FAILURE); <line29> return; <line30> } <line31> final Map<String, String> attributes = new HashMap<>(8); <line32> attributes.put(SyslogAttributes.PRIORITY.key(), event.getPriority()); <line33> attributes.put(SyslogAttributes.SEVERITY.key(), event.getSeverity()); <line34> attributes.put(SyslogAttributes.FACILITY.key(), event.getFacility()); <line35> attributes.put(SyslogAttributes.VERSION.key(), event.getVersion()); <line36> attributes.put(SyslogAttributes.TIMESTAMP.key(), event.getTimeStamp()); <line37> attributes.put(SyslogAttributes.HOSTNAME.key(), event.getHostName()); <line38> attributes.put(SyslogAttributes.BODY.key(), event.getMsgBody()); <line39> flowFile = session.putAllAttributes(flowFile, attributes); <line40> session.transfer(flowFile, REL_SUCCESS); <line41> } <line42> } <line43> 	 <line15>	No
public class A { <line0> private void addResourceToIndex( <line1> String lookupPath, ResourceInfo resourceInfo, Bundle bundleWithResource) { <line2> if (StringUtils.isBlank(lookupPath) || resourceInfo == null || bundleWithResource == null) { <line3> return; <line4> } <line5> if (indexMap.containsKey(lookupPath)) { <line6> ResourceBundleIndexEntry entry = indexMap.get(lookupPath); <line7> Bundle currentlyProvidingBundle = context.getBundle(entry.getResourceInfo().getBundleId()); <line8> shadowedMap.add(indexMap.get(lookupPath)); <line9> } <line10> indexMap.put(lookupPath, new ResourceBundleIndexEntry(lookupPath, resourceInfo)); <line11> } <line12> } <line13> 	 <line8>	Yes
"public class A { <line0> @Override <line1> public void deleteHistoryEventsByTaskIds(List<String> taskIds) <line2> throws InvalidArgumentException, NotAuthorizedException { <line3> taskanaHistoryEngine.checkRoleMembership(TaskanaRole.ADMIN); <line4> if (taskIds == null) { <line5> throw new InvalidArgumentException(""List of taskIds must not be null.""); <line6> } <line7> try { <line8> taskanaHistoryEngine.openConnection(); <line9> taskHistoryEventMapper.deleteMultipleByTaskIds(taskIds); <line10> } catch (SQLException e) { <line11> } finally { <line12> taskanaHistoryEngine.returnConnection(); <line13> } <line14> } <line15> } <line16> "	 <line11>	Yes
"public class A { <line0> @ApiOperation( <line1> value = ""migrates a project by applying a similar input schema to the mappings"", <line2> notes = <line3> ""Returns a new Project object. Persists this project (incl. all its parts, i.e., new sub"" <line4> + "" elements, e.g., mappings will be persisted as well)."", <line5> response = Project.class) <line6> @ApiResponses( <line7> value = { <line8> @ApiResponse(code = 201, message = ""project was successfully persisted""), <line9> @ApiResponse(code = 500, message = ""internal processing error (see body for details)"") <line10> }) <line11> @POST <line12> @Path(""migrateprojecttonewinputschema"") <line13> @Consumes(MediaType.APPLICATION_JSON) <line14> @Produces(MediaType.APPLICATION_JSON) <line15> public Response migrateProjectToNewInputSchema( <line16> @ApiParam(value = ""project (as JSON)"", required = true) final String requestJsonObjectString) <line17> throws DMPControllerException { <line18> final Tuple2<DataModel, Project> migrationInput = getMigrationInput(requestJsonObjectString); <line19> final DataModel inputDataModel = migrationInput._1; <line20> final Project referenceProject = migrationInput._2; <line21> final String newProjectId = UUIDService.getUUID(Project.class.getSimpleName()); <line22> final Project newProject = <line23> createNewProjectForMigration(inputDataModel, referenceProject, newProjectId, MIGRATION); <line24> final Schema referenceInputSchema = referenceProject.getInputDataModel().getSchema(); <line25> final Schema newInputSchema = inputDataModel.getSchema(); <line26> final Map<AttributePath, AttributePath> attributePathMap = <line27> mapAttributePaths(referenceInputSchema, newInputSchema); <line28> migrateMappingsToSomehowSimilarInputAttributePaths( <line29> referenceProject, newProject, attributePathMap); <line30> return persistProjectForMigration(newProjectId, newProject); <line31> } <line32> } <line33> "	 <line2>	No
public class A { <line0> @Override <line1> public synchronized void close() throws IOException { <line2> if (closed) { <line3> return; <line4> } <line5> closed = true; <line6> if (connectionFactory != null) { <line7> connectionFactory.shutdown(); <line8> connectionFactory = null; <line9> } <line10> if (zkServer != null) { <line11> zkServer.shutdown(); <line12> zkServer = null; <line13> } <line14> if (transactionLog != null) { <line15> transactionLog.close(); <line16> transactionLog = null; <line17> } <line18> if (purgeManager != null) { <line19> purgeManager.shutdown(); <line20> purgeManager = null; <line21> } <line22> if (dataDir != null) { <line23> IOUtils.deleteRecursively(dataDir); <line24> dataDir = null; <line25> } <line26> } <line27> } <line28> 	 <line2>	Yes
"public class A { <line0> @Test <line1> public void testSlice2() { <line2> String expectedJavascript = ""$('div').slice(1, 3);""; <line3> String generatedJavascript = <line4> new JsStatement().$(null, ""div"").chain(TraversingHelper.slice(1, 3)).render().toString(); <line5> assertEquals(generatedJavascript, expectedJavascript); <line6> } <line7> } <line8> "	 <line5>	Yes
public class A { <line0> @Override <line1> protected void doCommit(DefaultTransactionStatus status) { <line2> MolgenisTransaction transaction = (MolgenisTransaction) status.getTransaction(); <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> DefaultTransactionStatus jpaTransactionStatus = <line6> new DefaultTransactionStatus( <line7> transaction.getDataSourceTransaction(), <line8> status.isNewTransaction(), <line9> status.isNewSynchronization(), <line10> status.isReadOnly(), <line11> status.isDebug(), <line12> status.getSuspendedResources()); <line13> if (!status.isReadOnly()) { <line14> transactionListeners.forEach(j -> j.commitTransaction(transaction.getId())); <line15> } <line16> try { <line17> super.doCommit(jpaTransactionStatus); <line18> } catch (TransactionException e) { <line19> throw translateTransactionException(e); <line20> } <line21> if (!status.isReadOnly()) { <line22> transactionListeners.forEach(j -> j.afterCommitTransaction(transaction.getId())); <line23> } <line24> } <line25> } <line26> 	 <line4>	Yes
"public class A { <line0> @Test <line1> public void testDbFailureUnderLoad() throws Exception { <line2> cnx.runUpdate(""dp_update_threads_by_id"", 50, TestHelpers.dpVip.getId()); <line3> cnx.commit(); <line4> TestHelpers.setNodesLogLevel(""INFO"", cnx); <line5> CreationTools.createJobDef( <line6> null, <line7> true, <line8> ""pyl.Nothing"", <line9> null, <line10> ""jqm-tests/jqm-test-pyl-nodep/target/test.jar"", <line11> TestHelpers.qVip, <line12> -1, <line13> ""TestJqmApplication"", <line14> ""appFreeName"", <line15> ""TestModule"", <line16> ""kw1"", <line17> ""kw2"", <line18> ""kw3"", <line19> false, <line20> cnx); <line21> JobRequest j = new JobRequest(""TestJqmApplication"", ""TestUser""); <line22> for (int i = 0; i < 1000; i++) { <line23> JqmClientFactory.getClient().enqueue(j); <line24> } <line25> addAndStartEngine(); <line26> this.sleep(1); <line27> simulateDbFailure(); <line28> TestHelpers.waitFor(1000, 120000, this.getNewDbSession()); <line29> Assert.assertEquals(1000, TestHelpers.getOkCount(this.getNewDbSession())); <line30> } <line31> } <line32> "	 <line13>	No
"public class A { <line0> @Override <line1> public ObjectName createName(String type, String domain, String name) { <line2> try { <line3> StringBuilder sb = new StringBuilder(); <line4> sb.append(domain).append("":""); <line5> String[] nameSplit = name.split(SEPARATOR_RGX, 3); <line6> ObjectName objectName = null; <line7> if (nameSplit.length == 1) { <line8> objectName = new ObjectName(domain, ""name"", name); <line9> } else { <line10> for (int i = 0; i < nameSplit.length - 1 && i < jmxHierarchies.length; i++) { <line11> sb.append(jmxHierarchies[i]).append(""="").append(nameSplit[i]).append("",""); <line12> } <line13> sb.append(""name="").append(nameSplit[nameSplit.length - 1]); <line14> objectName = new ObjectName(sb.toString()); <line15> } <line16> if (objectName.isPattern()) { <line17> objectName = new ObjectName(domain, ""name"", ObjectName.quote(name)); <line18> } <line19> return objectName; <line20> } catch (MalformedObjectNameException e) { <line21> try { <line22> return new ObjectName(domain, ""name"", ObjectName.quote(name)); <line23> } catch (MalformedObjectNameException e1) { <line24> if (LOG.isDebugEnabled()) { <line25> } else { <line26> } <line27> throw new RuntimeException(e1); <line28> } <line29> } <line30> } <line31> } <line32> "	 <line26>	Yes
"public class A { <line0> public void assertGeneralProperties(FeedMerlin newFeed) { <line1> SoftAssert softAssert = new SoftAssert(); <line2> softAssert.assertEquals(newFeed.getName(), getName(), ""Feed Name is different""); <line3> softAssert.assertEquals( <line4> newFeed.getDescription(), getDescription(), ""Feed Description is different""); <line5> softAssert.assertEquals(newFeed.getTags(), getTags(), ""Feed Tags is different""); <line6> softAssert.assertEquals(newFeed.getGroups(), getGroups(), ""Feed Groups is different""); <line7> softAssert.assertEquals( <line8> newFeed.getACL().getOwner(), getACL().getOwner(), ""Feed ACL Owner is different""); <line9> softAssert.assertEquals( <line10> newFeed.getACL().getGroup(), getACL().getGroup(), ""Feed ACL Group is different""); <line11> softAssert.assertEquals( <line12> newFeed.getACL().getPermission(), <line13> getACL().getPermission(), <line14> ""Feed ACL Permission is different""); <line15> softAssert.assertEquals( <line16> newFeed.getSchema().getLocation(), <line17> getSchema().getLocation(), <line18> ""Feed Schema Location is different""); <line19> softAssert.assertEquals( <line20> newFeed.getSchema().getProvider(), <line21> getSchema().getProvider(), <line22> ""Feed Schema Provider is different""); <line23> softAssert.assertAll(); <line24> } <line25> } <line26> "	 <line1>	Yes
"public class A { <line0> public String getFunctionDesc(String function_code) { <line1> try { <line2> String queryString = <line3> ""select description from Secobjectname obj where obj.objectname='"" + function_code + ""'""; <line4> List lst = getHibernateTemplate().find(queryString); <line5> if (lst.size() > 0 && lst.get(0) != null) return lst.get(0).toString(); <line6> else return """"; <line7> } catch (RuntimeException re) { <line8> throw re; <line9> } <line10> } <line11> } <line12> "	 <line6>	No
public class A { <line0> @Override <line1> public List<DropdownItem> getActionDropdownItems() { <line2> InheritedFragmentEntryActionDropdownItemsProvider <line3> inheritedFragmentEntryActionDropdownItemsProvider = <line4> new InheritedFragmentEntryActionDropdownItemsProvider( <line5> fragmentEntry, _renderRequest, _renderResponse); <line6> try { <line7> return inheritedFragmentEntryActionDropdownItemsProvider.getActionDropdownItems(); <line8> } catch (Exception exception) { <line9> if (_log.isDebugEnabled()) { <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	 <line10>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public static long getTotalDocumentCountForIndexAndType( <line2> String url, <line3> String index, <line4> String type, <line5> Map<String, Object> filter, <line6> Map<String, Object> mustNotFilter, <line7> HashMultimap<String, Object> shouldFilter) { <line8> String urlToQuery = buildURL(url, index, type); <line9> Map<String, Object> requestBody = new HashMap<String, Object>(); <line10> Map<String, Object> matchFilters = Maps.newHashMap(); <line11> if (filter == null) { <line12> matchFilters.put(""match_all"", new HashMap<String, String>()); <line13> } else { <line14> matchFilters.putAll(filter); <line15> } <line16> if (null != filter) { <line17> requestBody.put(QUERY, CommonUtils.buildQuery(matchFilters, mustNotFilter, shouldFilter)); <line18> } else { <line19> requestBody.put(QUERY, matchFilters); <line20> } <line21> String responseDetails = null; <line22> Gson gson = new GsonBuilder().create(); <line23> try { <line24> String requestJson = gson.toJson(requestBody, Object.class); <line25> responseDetails = CommonUtils.doHttpPost(urlToQuery, requestJson, new HashMap<>()); <line26> Map<String, Object> response = <line27> (Map<String, Object>) gson.fromJson(responseDetails, Object.class); <line28> return (long) (Double.parseDouble(response.get(""count"").toString())); <line29> } catch (Exception e) { <line30> ; <line31> } <line32> return -1; <line33> } <line34> } <line35> "	 <line31>	No
"public class A { <line0> private Message sendMessageForActionUpdate(Session cmisSession, Message message) <line1> throws SenderException, TimeOutException { <line2> String objectId = null; <line3> Map<String, Object> props = new HashMap<String, Object>(); <line4> Element cmisElement; <line5> try { <line6> if (XmlUtils.isWellFormed(message, ""cmis"")) { <line7> cmisElement = XmlUtils.buildElement(message); <line8> } else { <line9> cmisElement = XmlUtils.buildElement(""<cmis/>""); <line10> } <line11> objectId = XmlUtils.getChildTagAsString(cmisElement, ""id""); <line12> Element propertiesElement = XmlUtils.getFirstChildTag(cmisElement, ""properties""); <line13> if (propertiesElement != null) { <line14> processProperties(propertiesElement, props); <line15> } <line16> } catch (DomBuilderException e) { <line17> throw new SenderException(getLogPrefix() + ""exception parsing ["" + message + ""]"", e); <line18> } <line19> CmisObject object = null; <line20> try { <line21> object = cmisSession.getObject(cmisSession.createObjectId(objectId)); <line22> } catch (CmisObjectNotFoundException e) { <line23> if (StringUtils.isNotEmpty(getResultOnNotFound())) { <line24> return new Message(getResultOnNotFound()); <line25> } else { <line26> throw new SenderException(e); <line27> } <line28> } <line29> object.updateProperties(props); <line30> return new Message(object.getId()); <line31> } <line32> } <line33> "	 <line28>	No
"public class A { <line0> protected RequestHandler.Result handleExecParsed(String request, String commandLine) <line1> throws IOException { <line2> ServerSession cmdSession = Objects.requireNonNull(getServerSession(), ""No server session""); <line3> ServerFactoryManager manager = <line4> Objects.requireNonNull(cmdSession.getFactoryManager(), ""No server factory manager""); <line5> CommandFactory factory = manager.getCommandFactory(); <line6> if (factory == null) { <line7> return RequestHandler.Result.ReplyFailure; <line8> } <line9> boolean debugEnabled = log.isDebugEnabled(); <line10> if (debugEnabled) { <line11> } <line12> try { <line13> commandInstance = factory.createCommand(this, commandLine); <line14> } catch (RuntimeException | IOException | Error e) { <line15> warn( <line16> ""handleExec({}) Failed ({}) to create command for {}: {}"", <line17> this, <line18> e.getClass().getSimpleName(), <line19> commandLine, <line20> e.getMessage(), <line21> e); <line22> return RequestHandler.Result.ReplyFailure; <line23> } <line24> if (commandInstance == null) { <line25> return RequestHandler.Result.ReplyFailure; <line26> } <line27> return prepareChannelCommand(request, commandInstance); <line28> } <line29> } <line30> "	 <line27>	No
public class A { <line0> @Override <line1> public void unRegisterInterpreterProcess(String intpGroupId) <line2> throws InterpreterRPCException, TException { <line3> InterpreterGroup interpreterGroup = <line4> interpreterSettingManager.getInterpreterGroupById(intpGroupId); <line5> if (interpreterGroup == null) { <line6> return; <line7> } <line8> interpreterGroup.close(); <line9> interpreterSettingManager.removeInterpreterGroup(intpGroupId); <line10> } <line11> } <line12> 	 <line11>	No
"public class A { <line0> public boolean backupOldConfig(String resourceId, String configType, String oldConfig) <line1> throws AutoFixException { <line2> String url = <line3> CommonUtils.getPropValue(com.tmobile.pacman.common.PacmanSdkConstants.BACKUP_ASSET_CONFIG); <line4> url = url.concat(""?resourceId="").concat(resourceId).concat(""&configType="").concat(configType); <line5> try { <line6> String resp = CommonUtils.doHttpPost(url, oldConfig, Maps.newHashMap()); <line7> if (!Strings.isNullOrEmpty(resp)) { <line8> return true; <line9> } else { <line10> throw new AutoFixException(); <line11> } <line12> } catch (Exception exception) { <line13> throw new AutoFixException(exception); <line14> } <line15> } <line16> } <line17> "	 <line16>	No
public class A { <line0> private void onAlterSentryRoleGrantPrivilegeCore(String roleName, TSentryPrivilege privilege) <line1> throws SentryPluginException { <line2> String authzObj = getAuthzObj(privilege); <line3> if (authzObj != null) { <line4> PermissionsUpdate update = new PermissionsUpdate(permSeqNum.incrementAndGet(), false); <line5> update <line6> .addPrivilegeUpdate(authzObj) <line7> .putToAddPrivileges(roleName, privilege.getAction().toUpperCase()); <line8> permsUpdater.handleUpdateNotification(update); <line9> } <line10> } <line11> } <line12> 	 <line9>	Yes
"public class A { <line0> private void checkAndCreateStageTable(String dbName, String baseTable, String ddl) { <line1> try { <line2> Connection con = getHiveJDBCConnection(dbName); <line3> Statement stmt = con.createStatement(); <line4> ResultSet rs = stmt.executeQuery(CreateRawBaseTables.getQuery(baseTable)); <line5> if (!rs.next()) { <line6> GetGeneralConfig generalConfig = new GetGeneralConfig(); <line7> String hdfsURI = <line8> generalConfig.byConigGroupAndKey(""imconfig"", ""common.default-fs-name"").getDefaultVal(); <line9> String bdreLinuxUserName = <line10> generalConfig.byConigGroupAndKey(""scripts_config"", ""bdreLinuxUserName"").getDefaultVal(); <line11> ProcessInfo process = new GetProcess().getProcess(Integer.parseInt(processIdSelected)); <line12> String serdePath = <line13> hdfsURI <line14> + ""/user/"" <line15> + bdreLinuxUserName <line16> + ""/wf/1/5/"" <line17> + process.getParentProcessId() <line18> + ""/lib/hive-hcatalog-core-0.13.1.jar""; <line19> String addSerde = ""add jar "" + serdePath; <line20> stmt.execute(addSerde); <line21> stmt.executeUpdate(ddl); <line22> } <line23> stmt.close(); <line24> con.close(); <line25> } catch (Exception e) { <line26> throw new ETLException(e); <line27> } <line28> } <line29> } <line30> "	 <line26>	Yes
"public class A { <line0> private String generateNextAuditEventId() { <line1> final String ret; <line2> if (auditIdStrictUUID) { <line3> ret = MiscUtil.generateGuid(); <line4> } else { <line5> int nextId = counter.getAndIncrement(); <line6> if (nextId == Integer.MAX_VALUE) { <line7> UUID = MiscUtil.generateUniqueId(); <line8> counter = new AtomicInteger(0); <line9> } <line10> ret = UUID + ""-"" + Integer.toString(nextId); <line11> } <line12> if (LOG.isDebugEnabled()) { <line13> } <line14> return ret; <line15> } <line16> } <line17> "	 <line13>	Yes
public class A { <line0> private String toScript(List<String> paths, SparkCommandBuilder commandBuilder) { <line1> StringBuffer sb = new StringBuffer(); <line2> if (paths.size() > 1) { <line3> sb.append(commandBuilder.build(paths)); <line4> } else { <line5> sb.append(commandBuilder.build(paths.get(0))); <line6> } <line7> return sb.toString(); <line8> } <line9> } <line10> 	 <line7>	Yes
"public class A { <line0> private List<AppInfo> getAppsFromPackageAndConfig( <line1> AppPackage ap, ConfigPackage cp, String configApps) { <line2> if (cp == null <line3> || configApps == null <line4> || !(configApps.equals(CONFIG_INCLUSIVE) || configApps.equals(CONFIG_EXCLUSIVE))) { <line5> return ap.getApplications(); <line6> } <line7> File src = new File(cp.tempDirectory(), ""app""); <line8> File dest = new File(ap.tempDirectory(), ""app""); <line9> if (!src.exists()) { <line10> return ap.getApplications(); <line11> } <line12> if (configApps.equals(CONFIG_EXCLUSIVE)) { <line13> for (File file : dest.listFiles()) { <line14> if (file.getName().endsWith("".json"")) { <line15> FileUtils.deleteQuietly(new File(dest, file.getName())); <line16> } <line17> } <line18> } else { <line19> for (File file : src.listFiles()) { <line20> FileUtils.deleteQuietly(new File(dest, file.getName())); <line21> } <line22> } <line23> for (File file : src.listFiles()) { <line24> try { <line25> FileUtils.moveFileToDirectory(file, dest, true); <line26> } catch (IOException e) { <line27> } <line28> } <line29> try { <line30> FileUtils.deleteDirectory(src); <line31> } catch (IOException e) { <line32> } <line33> ap.processAppDirectory(configApps.equals(CONFIG_EXCLUSIVE)); <line34> return ap.getApplications(); <line35> } <line36> } <line37> "	 <line27>	Yes
public class A { <line0> public void pdb() { <line1> pdbFileNames = findPdbFiles(); <line2> createTranscriptMap(); <line3> pdbAnalysis(); <line4> closeOuptut(); <line5> } <line6> } <line7> 	 <line3>	Yes
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception { <line3> CopyOnWriteArraySet<SubscriptionInfo> commandSubscriptions = <line4> (CopyOnWriteArraySet) session.getAttributes().get(CommandHandlers.SUBSCRIPTION_SET_NAME); <line5> commandService.sendUnsubscribeRequest( <line6> commandSubscriptions.stream() <line7> .map(SubscriptionInfo::getSubscriptionId) <line8> .collect(Collectors.toSet())); <line9> CopyOnWriteArraySet<SubscriptionInfo> notificationSubscriptions = <line10> (CopyOnWriteArraySet) <line11> session.getAttributes().get(NotificationHandlers.SUBSCRIPTION_SET_NAME); <line12> notificationService.unsubscribe( <line13> notificationSubscriptions.stream() <line14> .map(SubscriptionInfo::getSubscriptionId) <line15> .collect(Collectors.toSet())); <line16> sessionMonitor.removeSession(session.getId()); <line17> if (session.isOpen()) { <line18> session.close(); <line19> } <line20> } <line21> } <line22> "	 <line20>	Yes
"public class A { <line0> @Test <line1> public void testReading() throws Exception { <line2> String filename = ""data/vasp/LiMoS2_optimisation_ISIF3.vasp""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> VASPReader reader = new VASPReader(ins); <line5> ChemFile chemFile = (ChemFile) reader.read(new ChemFile()); <line6> Assert.assertNotNull(chemFile); <line7> org.openscience.cdk.interfaces.IChemSequence sequence = chemFile.getChemSequence(0); <line8> Assert.assertNotNull(sequence); <line9> Assert.assertEquals(6, sequence.getChemModelCount()); <line10> org.openscience.cdk.interfaces.IChemModel model = sequence.getChemModel(0); <line11> Assert.assertNotNull(model); <line12> org.openscience.cdk.interfaces.ICrystal crystal = model.getCrystal(); <line13> Assert.assertNotNull(crystal); <line14> Assert.assertEquals(16, crystal.getAtomCount()); <line15> org.openscience.cdk.interfaces.IAtom atom = crystal.getAtom(0); <line16> Assert.assertNotNull(atom); <line17> Assert.assertNotNull(atom.getFractionalPoint3d()); <line18> } <line19> } <line20> "	 <line8>	No
"public class A { <line0> @Test(timeout = 60 * 1000) <line1> public void testOfflineSubscriptionAfterRestart() throws Exception { <line2> Connection con = createConnection(""offCli1""); <line3> Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE); <line4> MessageConsumer consumer = session.createDurableSubscriber(topic, ""SubsId"", null, false); <line5> DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener(); <line6> consumer.setMessageListener(listener); <line7> MessageProducer producer = session.createProducer(null); <line8> int sent = 0; <line9> for (int i = 0; i < 10; i++) { <line10> sent++; <line11> Message message = session.createMessage(); <line12> message.setStringProperty(""filter"", ""false""); <line13> producer.send(topic, message); <line14> } <line15> Thread.sleep(5 * 1000); <line16> session.close(); <line17> con.close(); <line18> assertEquals(sent, listener.count); <line19> Thread.sleep(3 * 1000); <line20> broker.stop(); <line21> createBroker(false); <line22> con = createConnection(); <line23> session = con.createSession(false, Session.AUTO_ACKNOWLEDGE); <line24> producer = session.createProducer(null); <line25> for (int i = 0; i < 10; i++) { <line26> sent++; <line27> Message message = session.createMessage(); <line28> message.setStringProperty(""filter"", ""false""); <line29> producer.send(topic, message); <line30> } <line31> Thread.sleep(1 * 1000); <line32> session.close(); <line33> con.close(); <line34> con = createConnection(""offCli1""); <line35> session = con.createSession(false, Session.AUTO_ACKNOWLEDGE); <line36> consumer = session.createDurableSubscriber(topic, ""SubsId"", null, true); <line37> consumer.setMessageListener(listener); <line38> Thread.sleep(3 * 1000); <line39> session.close(); <line40> con.close(); <line41> assertEquals(sent, listener.count); <line42> } <line43> } <line44> "	 <line2>	No
"public class A { <line0> public int executeRaw(DatabaseConnection connection, String statement, String[] arguments) <line1> throws SQLException { <line2> if (arguments.length > 0) { <line3> } <line4> CompiledStatement compiledStatement = <line5> connection.compileStatement( <line6> statement, <line7> StatementType.EXECUTE, <line8> noFieldTypes, <line9> DatabaseConnection.DEFAULT_RESULT_FLAGS, <line10> false); <line11> try { <line12> assignStatementArguments(compiledStatement, arguments); <line13> return compiledStatement.runExecute(); <line14> } finally { <line15> IOUtils.closeThrowSqlException(compiledStatement, ""compiled statement""); <line16> } <line17> } <line18> } <line19> "	 <line8>	No
public class A { <line0> public void run() { <line1> boolean error = false; <line2> int errorCount = 0; <line3> while (!Thread.currentThread().isInterrupted()) { <line4> try { <line5> String r = outputBuffer.take(); <line6> boolean success = zmqSocket.send(topicName, ZMQ.SNDMORE); <line7> if (success) { <line8> zmqSocket.send(r.getBytes(), 0); <line9> } else { <line10> error = true; <line11> errorCount++; <line12> } <line13> } catch (InterruptedException ie) { <line14> return; <line15> } <line16> if (processedCount > 1000) { <line17> if (error) { <line18> errorCount = 0; <line19> } <line20> markTimestamp = new Date(); <line21> processedCount = 0; <line22> } <line23> processedCount++; <line24> } <line25> } <line26> } <line27> 	 <line17>	Yes
public class A { <line0> public MarketoRecordResult describeCustomObject(TMarketoInputProperties parameters) { <line1> String customObjectName = parameters.customObjectName.getValue(); <line2> current_uri = <line3> new StringBuilder(basicPath) <line4> .append(API_PATH_CUSTOMOBJECTS) <line5> .append(customObjectName) <line6> .append(API_PATH_URI_DESCRIBE) <line7> .append(fmtParams(FIELD_ACCESS_TOKEN, accessToken, true)); <line8> return getRecordResultForFromRequestBySchema( <line9> parameters.schemaInput.schema.getValue(), false, null); <line10> } <line11> } <line12> 	 <line9>	No
public class A { <line0> void handleStart(Exchange exchange, MetricRegistry registry, String metricsName) { <line1> String propertyName = getPropertyName(metricsName); <line2> Timer.Context context = getTimerContextFromExchange(exchange, propertyName); <line3> if (context == null) { <line4> Timer timer = registry.timer(metricsName); <line5> context = timer.time(); <line6> exchange.setProperty(propertyName, context); <line7> } else { <line8> } <line9> } <line10> } <line11> 	 <line7>	No
public class A { <line0> public void cache(Identity oid, Object obj) { <line1> super.cache(oid, obj); <line2> boolean cached = (super.lookup(oid) != null); <line3> } <line4> } <line5> 	 <line3>	Yes
"public class A { <line0> private Class<?> getMessageDTOClass(final String messageType, final boolean request) { <line1> switch (messageType) { <line2> case CoreCommonConstants.RELAY_MESSAGE_TYPE_GSD_POLL: <line3> return request ? GSDPollRequestDTO.class : GSDPollResponseDTO.class; <line4> case CoreCommonConstants.RELAY_MESSAGE_TYPE_ICN_PROPOSAL: <line5> return request ? ICNProposalRequestDTO.class : ICNProposalResponseDTO.class; <line6> case CoreCommonConstants.RELAY_MESSAGE_TYPE_ACCESS_TYPE: <line7> return request ? GeneralRelayRequestDTO.class : AccessTypeRelayResponseDTO.class; <line8> case CoreCommonConstants.RELAY_MESSAGE_TYPE_SYSTEM_ADDRESS_LIST: <line9> return request ? GeneralRelayRequestDTO.class : SystemAddressSetRelayResponseDTO.class; <line10> case CoreCommonConstants.RELAY_MESSAGE_TYPE_QOS_RELAY_TEST: <line11> return request <line12> ? QoSRelayTestProposalRequestDTO.class <line13> : QoSRelayTestProposalResponseDTO.class; <line14> default: <line15> throw new ArrowheadException(""Invalid message type: "" + messageType); <line16> } <line17> } <line18> } <line19> "	 <line1>	Yes
"public class A { <line0> public static int getMountFoldersCount( <line1> HttpPrincipal httpPrincipal, long repositoryId, long parentFolderId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DLAppServiceUtil.class, <line7> ""getMountFoldersCount"", <line8> _getMountFoldersCountParameterTypes76); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, repositoryId, parentFolderId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Integer) returnObj).intValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	 <line2>	No
"public class A { <line0> public default void zoom( <line1> int startx1, <line2> int starty1, <line3> int endx1, <line4> int endy1, <line5> int startx2, <line6> int starty2, <line7> int endx2, <line8> int endy2, <line9> int duration) { <line10> MobileDriver<?> driver = (MobileDriver<?>) castDriver(); <line11> try { <line12> MultiTouchAction multiTouch = new MultiTouchAction(driver); <line13> @SuppressWarnings(""rawtypes"") <line14> TouchAction<?> tAction0 = new TouchAction(driver); <line15> @SuppressWarnings(""rawtypes"") <line16> TouchAction<?> tAction1 = new TouchAction(driver); <line17> PointOption<?> startPoint1 = PointOption.point(startx1, starty1); <line18> PointOption<?> endPoint1 = PointOption.point(endx1, endy1); <line19> PointOption<?> startPoint2 = PointOption.point(startx2, starty2); <line20> PointOption<?> endPoint2 = PointOption.point(endx2, endy2); <line21> WaitOptions waitOptions = WaitOptions.waitOptions(Duration.ofMillis(duration)); <line22> tAction0.press(startPoint1).waitAction(waitOptions).moveTo(endPoint1).release(); <line23> tAction1.press(startPoint2).waitAction(waitOptions).moveTo(endPoint2).release(); <line24> multiTouch.add(tAction0).add(tAction1); <line25> multiTouch.perform(); <line26> } catch (Exception e) { <line27> } <line28> } <line29> } <line30> "	 <line27>	Yes
"public class A { <line0> @Test <line1> public void testSearchByUrl() throws Exception { <line2> String url = ""Patient?given=Vincent&family=Freeman&_format=json""; <line3> Bundle result = requestBody(""direct://SEARCH_BY_URL"", url); <line4> assertNotNull(result, ""searchByUrl result""); <line5> Patient patient = (Patient) result.getEntry().get(0).getResource(); <line6> assertNotNull(patient); <line7> assertEquals(""Freeman"", patient.getName().get(0).getFamily()); <line8> } <line9> } <line10> "	 <line4>	Yes
"public class A { <line0> @Override <line1> public URI getId() { <line2> final URI parentId = parent.getId(); <line3> if (parentId != null) { <line4> try { <line5> final URI containerURI = new URI(parentId.toString() + ""/""); <line6> return containerURI.resolve(""properties/"" + getName()); <line7> } catch (URISyntaxException urex) { <line8> } <line9> } <line10> return null; <line11> } <line12> } <line13> "	 <line8>	Yes
public class A { <line0> public void logout() { <line1> PFUserDO user = userContext != null ? userContext.getUser() : null; <line2> if (user != null) { <line3> user = null; <line4> } <line5> ThreadLocalUserContext.clear(); <line6> userContext = null; <line7> super.clear(); <line8> super.invalidateNow(); <line9> } <line10> } <line11> 	 <line3>	Yes
public class A { <line0> public Object[] retrieveActivityContextIDByResourceAdaptorEntityName(String entityName) { <line1> return listWithCriteria(false, true, LIST_BY_RAENTITY, entityName); <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> protected void updateControllerOnAdd( <line1> String containerId, String releaseId, String alias, ContainerInfo containerInfo) { <line2> if (CONTROLLER != null && releaseId != null && !controllerContainers.contains(containerId)) { <line3> controllerContainers.add(containerId); <line4> containersToAddToController.add(containerInfo); <line5> if (addToControllerAttempts == null) { <line6> addToControllerAttempts = <line7> executorService.scheduleAtFixedRate( <line8> () -> { <line9> try { <line10> List<ContainerInfo> sent = new ArrayList<>(); <line11> for (ContainerInfo container : containersToAddToController) { <line12> if (!controllerContainers.contains(container.getContainerId())) { <line13> sent.add(container); <line14> continue; <line15> } <line16> pushToController( <line17> container.getReleaseId(), <line18> container.getContainerId(), <line19> container.getAlias()); <line20> sent.add(container); <line21> } <line22> containersToAddToController.removeAll(sent); <line23> if (containersToAddToController.isEmpty()) { <line24> addToControllerAttempts.cancel(false); <line25> addToControllerAttempts = null; <line26> } <line27> } catch (Exception e) { <line28> } <line29> }, <line30> interval, <line31> interval, <line32> TimeUnit.SECONDS); <line33> } <line34> } <line35> } <line36> } <line37> 	 <line13>	No
public class A { <line0> public static com.liferay.commerce.model.CommerceAddressSoap[] getShippingCommerceAddresses( <line1> long companyId, String className, long classPK) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.commerce.model.CommerceAddress> returnValue = <line4> CommerceAddressServiceUtil.getShippingCommerceAddresses(companyId, className, classPK); <line5> return com.liferay.commerce.model.CommerceAddressSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line0>	No
public class A { <line0> private static void manageApis() throws APIException { <line1> if (log.isDebugEnabled()) { <line2> } <line3> List<API> apis = cellConfig.getApis(); <line4> for (API api : apis) { <line5> if (api.isGlobal()) { <line6> String existingApiId = getExistingApiId(api); <line7> if (existingApiId.equals(Constants.Utils.EMPTY_STRING)) { <line8> ApiCreateRequest globalApiPayload = createGlobalApiPayload(api); <line9> String id = createGlobalApi(globalApiPayload); <line10> publishGlobalAPI(id); <line11> } else if (abelToCreateNewVersion(api)) { <line12> String newApiVersionId = createNewApiVersion(existingApiId, getVersion(api)); <line13> ApiUpdateRequest globalApiUpdatePayload = <line14> createGlobalApiUpdatePayload(api, newApiVersionId); <line15> String id = updateGlobalAPI(globalApiUpdatePayload, newApiVersionId); <line16> publishGlobalAPI(id); <line17> } <line18> } <line19> } <line20> } <line21> } <line22> 	 <line2>	Yes
public class A { <line0> private void updateServiceForFailover(EntityManager em, JpaJob job) <line1> throws IllegalArgumentException, ServiceRegistryException { <line2> if (job.getStatus() != Status.FAILED && job.getStatus() != Status.FINISHED) return; <line3> job.setStatus(job.getStatus(), job.getFailureReason()); <line4> ServiceRegistrationJpaImpl currentService = job.getProcessorServiceRegistration(); <line5> if (currentService == null) return; <line6> if (job.getStatus() == FAILED && !DATA.equals(job.getFailureReason())) { <line7> List<ServiceRegistrationJpaImpl> relatedWarningOrErrorServices = <line8> getRelatedWarningErrorServices(job); <line9> if (relatedWarningOrErrorServices.size() > 0) { <line10> for (ServiceRegistrationJpaImpl relatedService : relatedWarningOrErrorServices) { <line11> if (currentService.equals(relatedService)) continue; <line12> if (relatedService.getServiceState() == WARNING) { <line13> relatedService.setServiceState(NORMAL, job.toJob().getSignature()); <line14> } else if (relatedService.getServiceState() == ERROR) { <line15> relatedService.setServiceState(WARNING, relatedService.getWarningStateTrigger()); <line16> } <line17> updateServiceState(em, relatedService); <line18> } <line19> } else { <line20> if (currentService.getServiceState() == NORMAL) { <line21> currentService.setServiceState(WARNING, job.toJob().getSignature()); <line22> updateServiceState(em, currentService); <line23> } else if (getHistorySize(currentService) >= maxAttemptsBeforeErrorState) { <line24> currentService.setServiceState(ERROR, job.toJob().getSignature()); <line25> updateServiceState(em, currentService); <line26> } <line27> } <line28> } else if (job.getStatus() == Status.FINISHED) { <line29> if (currentService.getServiceState() == WARNING) { <line30> currentService.setServiceState(NORMAL); <line31> updateServiceState(em, currentService); <line32> } <line33> } <line34> } <line35> } <line36> 	 <line24>	Yes
"public class A { <line0> @Override <line1> public Job animate(URI animation, Map<String, String> metadata, List<String> options) <line2> throws AnimateServiceException { <line3> String metadataJson = gson.toJson(metadata); <line4> String optionJson = gson.toJson(options); <line5> List<NameValuePair> params = new ArrayList<>(); <line6> params.add(new BasicNameValuePair(""animation"", animation.toString())); <line7> params.add(new BasicNameValuePair(""arguments"", optionJson)); <line8> params.add(new BasicNameValuePair(""metadata"", metadataJson)); <line9> HttpResponse response = null; <line10> try { <line11> HttpPost post = new HttpPost(""/animate""); <line12> post.setEntity(new UrlEncodedFormEntity(params, ""UTF-8"")); <line13> response = getResponse(post); <line14> if (response == null) { <line15> throw new AnimateServiceException(""No response from service""); <line16> } <line17> Job receipt = JobParser.parseJob(response.getEntity().getContent()); <line18> return receipt; <line19> } catch (IOException e) { <line20> throw new AnimateServiceException(""Failed building service request"", e); <line21> } finally { <line22> closeConnection(response); <line23> } <line24> } <line25> } <line26> "	 <line4>	No
"public class A { <line0> @Override <line1> public void updatePortletTitleMenuItems( <line2> List<MenuItem> menuItems, <line3> Folder folder, <line4> ThemeDisplay themeDisplay, <line5> PortletRequest portletRequest, <line6> PortletResponse portletResponse) { <line7> try { <line8> long folderId = DLFolderConstants.DEFAULT_PARENT_FOLDER_ID; <line9> if (folder != null) { <line10> folderId = folder.getFolderId(); <line11> } <line12> if (!_dlOpenerOneDriveManager.isConfigured(themeDisplay.getCompanyId()) <line13> || !ModelResourcePermissionUtil.contains( <line14> _folderEntryModelResourcePermission, <line15> themeDisplay.getPermissionChecker(), <line16> themeDisplay.getScopeGroupId(), <line17> folderId, <line18> ActionKeys.ADD_DOCUMENT)) { <line19> return; <line20> } <line21> menuItems.add( <line22> _createURLMenuItem( <line23> portletRequest, <line24> folder, <line25> ""onedrive-word"", <line26> DLOpenerMimeTypes.APPLICATION_VND_DOCX, <line27> _ICON_NAME_DOCUMENT, <line28> _ICON_COLOR_DOCUMENT, <line29> _translate(portletRequest, ""create-word-document""))); <line30> menuItems.add( <line31> _createURLMenuItem( <line32> portletRequest, <line33> folder, <line34> ""onedrive-powerpoint"", <line35> DLOpenerMimeTypes.APPLICATION_VND_PPTX, <line36> _ICON_NAME_PRESENTATION, <line37> _ICON_COLOR_PRESENTATION, <line38> _translate(portletRequest, ""create-powerpoint-document""))); <line39> menuItems.add( <line40> _createURLMenuItem( <line41> portletRequest, <line42> folder, <line43> ""onedrive-excel"", <line44> DLOpenerMimeTypes.APPLICATION_VND_XLSX, <line45> _ICON_NAME_SPREADSHEET, <line46> _ICON_COLOR_SPREADSHEET, <line47> _translate(portletRequest, ""create-excel-document""))); <line48> } catch (PortalException portalException) { <line49> } <line50> } <line51> } <line52> "	 <line49>	Yes
public class A { <line0> @Override <line1> public IQ handleIQ(IQ packet) throws UnauthorizedException, PacketException { <line2> try { <line3> IQ returnPacket; <line4> org.xmpp.packet.Roster roster = (org.xmpp.packet.Roster) packet; <line5> JID recipientJID = packet.getTo(); <line6> if (recipientJID == null || recipientJID.equals(packet.getFrom().asBareJID())) { <line7> returnPacket = manageRoster(roster); <line8> } else { <line9> returnPacket = IQ.createResultIQ(packet); <line10> returnPacket.setError(PacketError.Condition.forbidden); <line11> } <line12> return returnPacket; <line13> } catch (SharedGroupException e) { <line14> IQ result = IQ.createResultIQ(packet); <line15> result.setChildElement(packet.getChildElement().createCopy()); <line16> result.setError(PacketError.Condition.not_acceptable); <line17> return result; <line18> } catch (UnauthorizedException e) { <line19> IQ result = IQ.createResultIQ(packet); <line20> result.setChildElement(packet.getChildElement().createCopy()); <line21> result.setError(PacketError.Condition.not_authorized); <line22> return result; <line23> } catch (Exception e) { <line24> if (e.getCause() instanceof IDNAException <line25> || e.getCause() instanceof IllegalArgumentException) { <line26> IQ result = IQ.createResultIQ(packet); <line27> result.setChildElement(packet.getChildElement().createCopy()); <line28> result.setError(PacketError.Condition.jid_malformed); <line29> return result; <line30> } else { <line31> IQ result = IQ.createResultIQ(packet); <line32> result.setChildElement(packet.getChildElement().createCopy()); <line33> result.setError(PacketError.Condition.internal_server_error); <line34> return result; <line35> } <line36> } <line37> } <line38> } <line39> 	 <line5>	No
public class A { <line0> private void error(String message) { <line1> } <line2> } <line3> 	 <line1>	Yes
public class A { <line0> public void shutdown() { <line1> if (null != _pool) { <line2> try { <line3> _pool.shutdown().get(); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> if (null != _timedExecutor) { <line8> _timedExecutor.shutdown(); <line9> } <line10> if (null != _eventLoopGroup) { <line11> _eventLoopGroup.shutdownGracefully(); <line12> } <line13> if (null != _service) { <line14> _service.shutdown(); <line15> } <line16> if (null != _timer) { <line17> _timer.stop(); <line18> } <line19> } <line20> } <line21> 	 <line15>	Yes
"public class A { <line0> @Override <line1> public void doLaunch(MessageInput input) throws MisfireException { <line2> int heartbeatTimeout = ConnectionFactory.DEFAULT_HEARTBEAT; <line3> if (configuration.intIsSet(CK_HEARTBEAT_TIMEOUT)) { <line4> heartbeatTimeout = configuration.getInt(CK_HEARTBEAT_TIMEOUT); <line5> if (heartbeatTimeout < 0) { <line6> heartbeatTimeout = ConnectionFactory.DEFAULT_HEARTBEAT; <line7> } <line8> } <line9> consumer = <line10> new AmqpConsumer( <line11> configuration.getString(CK_HOSTNAME), <line12> configuration.getInt(CK_PORT), <line13> configuration.getString(CK_VHOST), <line14> configuration.getString(CK_USERNAME), <line15> configuration.getString(CK_PASSWORD), <line16> configuration.getInt(CK_PREFETCH), <line17> configuration.getString(CK_QUEUE), <line18> configuration.getString(CK_EXCHANGE), <line19> configuration.getBoolean(CK_EXCHANGE_BIND), <line20> configuration.getString(CK_ROUTING_KEY), <line21> configuration.getInt(CK_PARALLEL_QUEUES), <line22> configuration.getBoolean(CK_TLS), <line23> configuration.getBoolean(CK_REQUEUE_INVALID_MESSAGES), <line24> heartbeatTimeout, <line25> input, <line26> scheduler, <line27> this); <line28> eventBus.register(this); <line29> try { <line30> consumer.run(); <line31> } catch (IOException e) { <line32> eventBus.unregister(this); <line33> throw new MisfireException(""Could not launch AMQP consumer."", e); <line34> } <line35> } <line36> } <line37> "	 <line22>	No
public class A { <line0> private boolean extenderCapabilityWired(Bundle bundle) { <line1> BundleWiring wiring = bundle.adapt(BundleWiring.class); <line2> if (wiring == null) { <line3> return true; <line4> } <line5> List<BundleWire> requiredWires = wiring.getRequiredWires(EXTENDER_NAMESPACE); <line6> for (BundleWire requiredWire : requiredWires) { <line7> if (CAMEL_EXTENDER.equals( <line8> requiredWire.getCapability().getAttributes().get(EXTENDER_NAMESPACE))) { <line9> if (this.bundleId == requiredWire.getProviderWiring().getBundle().getBundleId()) { <line10> return true; <line11> } else { <line12> return false; <line13> } <line14> } <line15> } <line16> return true; <line17> } <line18> } <line19> 	 <line11>	No
"public class A { <line0> @OnError <line1> public void onError(Session session, Throwable cause) throws IOException { <line2> session.getBasicRemote().sendText(""Exception: "" + StackUtils.toString(cause)); <line3> } <line4> } <line5> "	 <line1>	No
"public class A { <line0> @Override <line1> public TaggerCrisis getCrisesByCode(String code) throws AidrException { <line2> Client client = ClientBuilder.newBuilder().register(JacksonFeature.class).build(); <line3> try { <line4> WebTarget webResource = client.target(taggerMainUrl + ""/crisis/by-code/"" + code); <line5> ObjectMapper objectMapper = JacksonWrapper.getObjectMapper(); <line6> Response clientResponse = webResource.request(MediaType.APPLICATION_JSON).get(); <line7> String jsonResponse = clientResponse.readEntity(String.class); <line8> CollectionDTO dto = null; <line9> TaggerResponseWrapper response = <line10> objectMapper.readValue(jsonResponse, TaggerResponseWrapper.class); <line11> if (response.getDataObject() != null) { <line12> dto = <line13> objectMapper.readValue( <line14> objectMapper.writeValueAsString(response.getDataObject()), CollectionDTO.class); <line15> } <line16> if (dto != null) { <line17> TaggerCrisis crisis = new TaggerCrisis(dto); <line18> if (crisis != null) { <line19> } <line20> return crisis; <line21> } <line22> return null; <line23> } catch (Exception e) { <line24> return null; <line25> } <line26> } <line27> } <line28> "	 <line7>	No
public class A { <line0> public void export( <line1> String surveyName, <line2> String rootEntityName, <line3> Step step, <line4> String targetSchemaName, <line5> Connection targetConn, <line6> RelationalSchemaConfig config, <line7> ProgressListener progressListener) <line8> throws CollectRdbException { <line9> try { <line10> targetConn.setAutoCommit(false); <line11> } catch (SQLException e) { <line12> } <line13> try { <line14> CollectSurvey survey = surveyManager.get(surveyName); <line15> RelationalSchemaGenerator schemaGenerator = new RelationalSchemaGenerator(config); <line16> RelationalSchema relationalSchema = schemaGenerator.generateSchema(survey, targetSchemaName); <line17> RelationalSchemaCreator relationalSchemaCreator = createRelationalSchemaCreator(); <line18> relationalSchemaCreator.createRelationalSchema(relationalSchema, targetConn); <line19> relationalSchemaCreator.addConstraints(relationalSchema, targetConn); <line20> relationalSchemaCreator.addIndexes(relationalSchema, targetConn); <line21> insertData(survey, rootEntityName, step, targetConn, relationalSchema, progressListener); <line22> targetConn.commit(); <line23> if (LOG.isInfoEnabled()) { <line24> } <line25> } catch (Exception e) { <line26> try { <line27> targetConn.rollback(); <line28> } catch (SQLException e1) { <line29> } <line30> throw new RuntimeException(e); <line31> } <line32> } <line33> } <line34> 	 <line23>	No
public class A { <line0> public static boolean setTransactionRollbackOnly() { <line1> if (log.isDebugEnabled()) { <line2> if (log.isTraceEnabled()) { <line3> } <line4> } <line5> UserTransaction ut = NuxeoContainer.getUserTransaction(); <line6> if (ut == null) { <line7> return false; <line8> } <line9> try { <line10> ut.setRollbackOnly(); <line11> return true; <line12> } catch (Exception cause) { <line13> } <line14> return false; <line15> } <line16> } <line17> 	 <line12>	No
public class A { <line0> private Folder _getParentFolder() { <line1> try { <line2> if (_parentFolder != null) { <line3> return _parentFolder; <line4> } <line5> if (getParentFolderId() == DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) { <line6> return null; <line7> } <line8> _parentFolder = DLAppServiceUtil.getFolder(getParentFolderId()); <line9> return _parentFolder; <line10> } catch (Exception exception) { <line11> if (_log.isDebugEnabled()) { <line12> } <line13> return null; <line14> } <line15> } <line16> } <line17> 	 <line9>	No
"public class A { <line0> @Override <line1> public void deleteCapabilities(final String providerName) { <line2> em.getTransaction().begin(); <line3> TypedQuery<Capability> query = em.createNamedQuery(Capability.byProvider, Capability.class); <line4> query.setParameter(""providerName"", providerName); <line5> for (ProviderType providerType : ProviderType.values()) { <line6> query.setParameter(""providerType"", providerType); <line7> query.getResultList().forEach(em::remove); <line8> } <line9> em.getTransaction().commit(); <line10> } <line11> } <line12> "	 <line2>	Yes
public class A { <line0> protected void evaluateDDMFormRuleAction(String action) { <line1> try { <line2> evaluateExpression(action); <line3> } catch (DDMExpressionException ddmExpressionException) { <line4> if (_log.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public String getAmilAvailDate(int year, int quarter) { <line2> try { <line3> String query = <line4> ""select Date(createdDate) from cf_SystemConfiguration where keyname ="" <line5> + "" 'pacman.kernel.compliance.map."" <line6> + year <line7> + "".q"" <line8> + quarter <line9> + ""'""; <line10> return rdsrepository.queryForString(query); <line11> } catch (Exception e) { <line12> return null; <line13> } <line14> } <line15> } <line16> "	 <line12>	Yes
"public class A { <line0> protected void syncSourceVersion(final boolean initial) { <line1> lockManager.lock( <line2> new SyncSourceVersionLock(), <line3> new LockCallbackNoReturn() { <line4> @Override <line5> public void doWithLockNoResult() { <line6> for (ConfigItem item : itemRegistry.getConfigItems()) { <line7> if (!initial) { <line8> if (item instanceof RefreshableConfigItem) { <line9> try { <line10> ((RefreshableConfigItem) item).refresh(); <line11> } catch (IOException e) { <line12> continue; <line13> } <line14> } else { <line15> continue; <line16> } <line17> } <line18> versionManager.setItemSourceVersion(item.getName(), item.getSourceRevision()); <line19> } <line20> for (String item : PRELOAD.get()) { <line21> versionManager.setItemSourceVersion(item, """"); <line22> } <line23> } <line24> }); <line25> } <line26> } <line27> "	 <line19>	No
"public class A { <line0> private String establishUserDN( <line1> String username, LdapClientConfiguration configuration, LDAPConnection connection) <line2> throws LDAPException, LdapAuthenticationException { <line3> SearchSpecification searchForUser = configuration.getSearchForUserSpec(); <line4> if (searchForUser == null) return configuration.getBindDN(username); <line5> bindAsSystem(connection, configuration); <line6> int timeLimit = configuration.getSearchTimeLimit(); <line7> int sizeLimit = configuration.getResultEntriesLimit(); <line8> DereferencePolicy derefPolicy = configuration.getDereferencePolicy(); <line9> SearchResult result = <line10> performSearch(connection, searchForUser, username, timeLimit, sizeLimit, derefPolicy); <line11> if (result.getEntryCount() == 0) { <line12> throw new LdapAuthenticationException(""User was not found""); <line13> } else if (result.getEntryCount() > 1) { <line14> throw new LdapAuthenticationException(""Too many users found""); <line15> } else { <line16> return result.getSearchEntries().get(0).getDN(); <line17> } <line18> } <line19> } <line20> "	 <line14>	Yes
public class A { <line0> private static void initRootACL(SessionImpl session, AccessControlEditor editor) <line1> throws RepositoryException { <line2> try { <line3> String rootPath = session.getRootNode().getPath(); <line4> AccessControlPolicy[] acls = editor.editAccessControlPolicies(rootPath); <line5> if (acls.length > 0) { <line6> ACLTemplate acl = (ACLTemplate) acls[0]; <line7> PrincipalManager pMgr = session.getPrincipalManager(); <line8> AccessControlManager acMgr = session.getAccessControlManager(); <line9> String pName = SecurityConstants.ADMINISTRATORS_NAME; <line10> if (pMgr.hasPrincipal(pName)) { <line11> Principal administrators = pMgr.getPrincipal(pName); <line12> Privilege[] privs = new Privilege[] {acMgr.privilegeFromName(Privilege.JCR_ALL)}; <line13> acl.addAccessControlEntry(administrators, privs); <line14> } else { <line15> } <line16> Principal everyone = pMgr.getEveryone(); <line17> Privilege[] privs = new Privilege[] {acMgr.privilegeFromName(Privilege.JCR_READ)}; <line18> acl.addAccessControlEntry(everyone, privs); <line19> editor.setPolicy(rootPath, acl); <line20> session.save(); <line21> } else { <line22> } <line23> } catch (RepositoryException e) { <line24> session.getRootNode().refresh(false); <line25> } <line26> } <line27> } <line28> 	 <line0>	No
"public class A { <line0> private boolean isComplete(BundleResponse response) { <line1> if (response == null && errorCount <= MAX_ERRORS) { <line2> errorCount++; <line3> return false; <line4> } else if (response == null && errorCount > MAX_ERRORS) { <line5> return true; <line6> } else if (response.isComplete()) { <line7> return true; <line8> } else if (pollCount > MAX_COUNT) { <line9> response.addStatusMessage(""Bailing due to build timeout""); <line10> return true; <line11> } <line12> errorCount = 0; <line13> return false; <line14> } <line15> } <line16> "	 <line9>	Yes
public class A { <line0> private void releaseClient(T client, boolean broken) { <line1> if (broken) { <line2> releaseBrokenClient(client); <line3> } else { <line4> try { <line5> clientPool.returnObject(client); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> private void initialize() { <line1> List<File> sourcePaths = transpilationTask.getInputDirList(); <line2> try { <line3> for (; ; ) { <line4> WatchService watchService = FileSystems.getDefault().newWatchService(); <line5> List<Path> watchedPaths = new ArrayList<>(); <line6> for (File sourceDirectory : sourcePaths) { <line7> Path path = sourceDirectory.toPath(); <line8> watchedPaths.add(path); <line9> walkDirectoryTree(path, watchedPaths, watchService); <line10> } <line11> try { <line12> watch(watchService); <line13> } catch (Exception exception) { <line14> watchService.close(); <line15> } <line16> Thread.yield(); <line17> } <line18> } catch (IOException ioException) { <line19> } <line20> } <line21> } <line22> 	 <line10>	No
"public class A { <line0> protected List<String> listRuntimeDependencies(String collectionName) <line1> throws IOException, SolrServerException { <line2> ModifiableSolrParams params = new ModifiableSolrParams().set(""file"", RUNTIME_LIB_FILE_NAME); <line3> SolrRequest request = new QueryRequest(params); <line4> request.setPath(""/admin/file""); <line5> request.setResponseParser(new InputStreamResponseParser(""json"")); <line6> try (CloudSolrClient client = createCloudSolrClient()) { <line7> final NamedList o = client.request(request, collectionName); <line8> final LineIterator it = IOUtils.lineIterator((InputStream) o.get(""stream""), ""utf-8""); <line9> final List<String> returnValues = Streams.stream(it).collect(Collectors.toList()); <line10> if (returnValues.size() == 1 <line11> && returnValues.get(0).startsWith(""{\""responseHeader\"":{\""status\"":404"")) { <line12> return Collections.emptyList(); <line13> } <line14> return returnValues; <line15> } <line16> } <line17> } <line18> "	 <line9>	No
public class A { <line0> @Override <line1> protected HttpConsumer resolve(HttpServletRequest request) { <line2> String path = request.getPathInfo(); <line3> String endpointName = getEndpointNameFromPath(path); <line4> HttpConsumer answer = consumers.get(endpointName); <line5> if (answer == null) { <line6> if (LOGGER.isDebugEnabled()) { <line7> } <line8> for (Entry<String, HttpConsumer> entry : consumers.entrySet()) { <line9> if (entry.getValue().getEndpoint().isMatchOnUriPrefix() <line10> && path.startsWith(entry.getKey())) { <line11> answer = consumers.get(entry.getKey()); <line12> break; <line13> } <line14> } <line15> } <line16> return answer; <line17> } <line18> } <line19> 	 <line17>	No
public class A { <line0> @Override <line1> public UploadStatistics loadSnomedCt( <line2> List<FileDescriptor> theFiles, RequestDetails theRequestDetails) { <line3> try (LoadedFileDescriptors descriptors = new LoadedFileDescriptors(theFiles)) { <line4> List<String> expectedFilenameFragments = <line5> Arrays.asList(SCT_FILE_DESCRIPTION, SCT_FILE_RELATIONSHIP, SCT_FILE_CONCEPT); <line6> descriptors.verifyMandatoryFilesExist(expectedFilenameFragments); <line7> return processSnomedCtFiles(descriptors, theRequestDetails); <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> @Override <line1> public void handleMessage(Message msg) { <line2> TIMESTAMP_LAST_STAT_UPDATE = System.currentTimeMillis(); <line3> if (updateStats) { <line4> switch (msg.what) { <line5> case EVENT_UPDATE_STATS: <line6> long bytesRead = 0; <line7> long bytesWritten = 0; <line8> for (DataTransferredEvent event : DATA_TRANSFERRED_EVENTS) { <line9> if (event.getTimestamp() > TIMESTAMP_LAST_STAT_UPDATE - INTERVAL_UPDATE_STATS) { <line10> if (event.isWrite()) { <line11> bytesWritten += event.getBytes(); <line12> } else { <line13> bytesRead += event.getBytes(); <line14> } <line15> } <line16> } <line17> bytesRead *= FACTOR_1S; <line18> bytesWritten *= FACTOR_1S; <line19> sentTotal.setText(humanReadableByteCountSI(TOTAL_BYTES_READ)); <line20> receivedTotal.setText(humanReadableByteCountSI(TOTAL_BYTES_WRITTEN)); <line21> sentPerSec.setText(humanReadableByteCountSI(bytesRead, ""/s"")); <line22> receivedPerSec.setText(humanReadableByteCountSI(bytesWritten, ""/s"")); <line23> break; <line24> default: <line25> break; <line26> } <line27> Message nextMsg = this.obtainMessage(EVENT_UPDATE_STATS); <line28> this.sendMessageDelayed(nextMsg, INTERVAL_UPDATE_STATS); <line29> } <line30> } <line31> } <line32> "	 <line2>	Yes
public class A { <line0> @Override <line1> public void handleReturn( <line2> int replyCode, <line3> String replyText, <line4> String exchange, <line5> String routingKey, <line6> AMQP.BasicProperties properties, <line7> byte[] body) <line8> throws IOException { <line9> basicReturnReceived = true; <line10> } <line11> } <line12> 	 <line7>	No
public class A { <line0> private void clearReplicaFlagsInIngestionContext( <line1> RecoverPointVolumeIngestionContext volumeContext, List<Volume> volumes) { <line2> for (Set<DataObject> updatedObjects : volumeContext.getDataObjectsToBeUpdatedMap().values()) { <line3> for (DataObject updatedObject : updatedObjects) { <line4> if (updatedObject instanceof BlockMirror <line5> || updatedObject instanceof BlockSnapshot <line6> || updatedObject instanceof BlockSnapshotSession <line7> || (updatedObject instanceof Volume <line8> && !NullColumnValueGetter.isNullURI( <line9> ((Volume) updatedObject).getAssociatedSourceVolume()))) { <line10> updatedObject.clearInternalFlags(INTERNAL_VOLUME_FLAGS); <line11> } <line12> } <line13> } <line14> List<String> rpVolumes = new ArrayList<String>(); <line15> for (Volume volume : volumes) { <line16> rpVolumes.add(volume.getId().toString()); <line17> if (RPHelper.isVPlexVolume(volume, _dbClient) <line18> && volumeContext instanceof RpVplexVolumeIngestionContext) { <line19> VplexVolumeIngestionContext vplexVolumeContext = <line20> ((RpVplexVolumeIngestionContext) volumeContext.getVolumeContext()) <line21> .getVplexVolumeIngestionContext(); <line22> StringSet associatedVolumes = vplexVolumeContext.getAssociatedVolumeIds(volume); <line23> rpVolumes.addAll(associatedVolumes); <line24> } <line25> } <line26> for (VolumeIngestionContext volumeIngestionContext : <line27> volumeContext.getRootIngestionRequestContext().getProcessedUnManagedVolumeMap().values()) { <line28> if (volumeIngestionContext instanceof IngestionRequestContext) { <line29> for (Set<DataObject> objectsToBeUpdated : <line30> ((IngestionRequestContext) volumeIngestionContext) <line31> .getDataObjectsToBeUpdatedMap() <line32> .values()) { <line33> for (DataObject o : objectsToBeUpdated) { <line34> if (o instanceof BlockSnapshot <line35> && rpVolumes.contains(((BlockSnapshot) o).getParent().getURI().toString())) { <line36> o.clearInternalFlags(INTERNAL_VOLUME_FLAGS); <line37> } else if (o instanceof BlockSnapshotSession <line38> && rpVolumes.contains(((BlockSnapshotSession) o).getParent().getURI().toString())) { <line39> o.clearInternalFlags(INTERNAL_VOLUME_FLAGS); <line40> } <line41> } <line42> } <line43> } <line44> } <line45> } <line46> } <line47> 	 <line10>	Yes
public class A { <line0> private GuacamoleRadiusChallenge getRadiusChallenge(RadiusPacket challengePacket) { <line1> RadiusAttribute stateAttr = challengePacket.findAttribute(Attr_State.TYPE); <line2> if (stateAttr == null) { <line3> return null; <line4> } <line5> RadiusAttribute replyAttr = challengePacket.findAttribute(Attr_ReplyMessage.TYPE); <line6> if (replyAttr == null) { <line7> return null; <line8> } <line9> String replyMsg = replyAttr.getValue().toString(); <line10> String radiusState = BaseEncoding.base16().encode(stateAttr.getValue().getBytes()); <line11> Field radiusResponseField = new PasswordField(CHALLENGE_RESPONSE_PARAM); <line12> Field radiusStateField = new RadiusStateField(radiusState); <line13> return new GuacamoleRadiusChallenge( <line14> replyMsg, new CredentialsInfo(Arrays.asList(radiusResponseField, radiusStateField))); <line15> } <line16> } <line17> 	 <line7>	Yes
"public class A { <line0> @Bean(destroyMethod = ""stop"", name = ""domainCoreOutboundOsgpCoreResponsesConnectionFactory"") <line1> public ConnectionFactory connectionFactory() { <line2> return this.jmsConfigurationFactory.getPooledConnectionFactory(); <line3> } <line4> } <line5> "	 <line1>	No
public class A { <line0> void startPeonsForNewServers(List<ImmutableDruidServer> currentServers) { <line1> for (ImmutableDruidServer server : currentServers) { <line2> loadManagementPeons.computeIfAbsent( <line3> server.getName(), <line4> serverName -> { <line5> LoadQueuePeon loadQueuePeon = taskMaster.giveMePeon(server); <line6> loadQueuePeon.start(); <line7> return loadQueuePeon; <line8> }); <line9> } <line10> } <line11> } <line12> 	 <line7>	Yes
public class A { <line0> private void doUpgrade(final Upgrades.Context resources) { <line1> try { <line2> lastUpgradeId = upgrades.applyUpgradesSince(lastUpgradeId, resources); <line3> LocalDocumentStore store = documentStore().localStore(); <line4> EditableDocument editor = store.edit(REPOSITORY_INFO_KEY, true); <line5> DateTime now = context().getValueFactories().getDateFactory().create(); <line6> editor.setDate(REPOSITORY_UPGRADED_AT_FIELD_NAME, now.toDate()); <line7> editor.setNumber(REPOSITORY_UPGRADE_ID_FIELD_NAME, lastUpgradeId); <line8> editor.remove(REPOSITORY_UPGRADER_FIELD_NAME); <line9> } catch (Throwable err) { <line10> resources.getProblems().addError(err, JcrI18n.failureDuringUpgradeOperation, getName(), err); <line11> } <line12> } <line13> } <line14> 	 <line2>	Yes
public class A { <line0> @NotNull <line1> @Override <line2> public AccessControlPolicyIterator getApplicablePolicies(@Nullable String absPath) <line3> throws RepositoryException { <line4> String oakPath = getOakPath(absPath); <line5> Tree tree = getTree(oakPath, Permissions.READ_ACCESS_CONTROL, true); <line6> AccessControlPolicy policy = null; <line7> Tree aclTree = getAclTree(oakPath, tree); <line8> if (aclTree == null) { <line9> if (tree.hasChild(Util.getAclName(oakPath))) { <line10> } else { <line11> String mixinName = Util.getMixinName(oakPath); <line12> if (ntMgr.isNodeType(tree, mixinName) <line13> || ntMgr.getEffectiveNodeType(tree).supportsMixin(mixinName)) { <line14> policy = new NodeACL(oakPath); <line15> } else { <line16> } <line17> } <line18> } <line19> if (policy == null) { <line20> return AccessControlPolicyIteratorAdapter.EMPTY; <line21> } else { <line22> return new AccessControlPolicyIteratorAdapter(Collections.singleton(policy)); <line23> } <line24> } <line25> } <line26> 	 <line20>	No
public class A { <line0> private boolean mustTrigger(Rule r) { <line1> for (Trigger t : r.getTriggers()) { <line2> if (t.getTypeUID() == SystemTriggerHandler.STARTLEVEL_MODULE_TYPE_ID) { <line3> Object slObj = t.getConfiguration().get(SystemTriggerHandler.CFG_STARTLEVEL); <line4> try { <line5> Integer sl = Integer.valueOf(slObj.toString()); <line6> if (sl <= StartLevelService.STARTLEVEL_RULEENGINE) { <line7> return true; <line8> } <line9> } catch (NumberFormatException e) { <line10> } <line11> } <line12> } <line13> return false; <line14> } <line15> } <line16> 	 <line10>	Yes
public class A { <line0> private Iterable<Result<TitanElement>> execute(ElementCategory resultType) { <line1> Preconditions.checkNotNull(indexName); <line2> Preconditions.checkNotNull(query); <line3> if (tx.hasModifications()) <line4> Iterable<RawQuery.Result> result = <line5> serializer.executeQuery(this, resultType, tx.getTxHandle(), tx); <line6> final Function<Object, ? extends TitanElement> conversionFct = <line7> tx.getConversionFunction(resultType); <line8> return Iterables.filter( <line9> Iterables.transform( <line10> result, <line11> new Function<RawQuery.Result, Result<TitanElement>>() { <line12> @Nullable <line13> @Override <line14> public Result<TitanElement> apply(@Nullable RawQuery.Result result) { <line15> return new ResultImpl<TitanElement>( <line16> conversionFct.apply(result.getResult()), result.getScore()); <line17> } <line18> }), <line19> new Predicate<Result<TitanElement>>() { <line20> @Override <line21> public boolean apply(@Nullable Result<TitanElement> r) { <line22> return !r.getElement().isRemoved(); <line23> } <line24> }); <line25> } <line26> } <line27> 	 <line6>	No
"public class A { <line0> public static File downloadArtifact(WebDriver driver, String name, long timeout) { <line1> File file = getArtifact(name); <line2> if (file == null) { <line3> String url = getUrl(driver, name); <line4> String username = getField(url, 1); <line5> String password = getField(url, 2); <line6> if (!artifactExists(driver, name, timeout)) { <line7> Assert.fail(""Unable to find artifact: "" + name); <line8> } <line9> file = new File(getArtifactsFolder() + File.separator + name); <line10> String path = file.getAbsolutePath(); <line11> if (!username.isEmpty() && !password.isEmpty()) { <line12> Authenticator.setDefault(new CustomAuthenticator(username, password)); <line13> } <line14> try { <line15> FileUtils.copyURLToFile(new URL(url), file); <line16> Artifact.attachToTest(name, file); <line17> } catch (IOException e) { <line18> } <line19> } <line20> return file; <line21> } <line22> } <line23> "	 <line3>	No
public class A { <line0> void updateNodeStatus(final NodeConnectionStatus status, final boolean waitForCoordinator) { <line1> final NodeIdentifier nodeId = status.getNodeIdentifier(); <line2> final NodeConnectionStatus currentStatus = forcefullyUpdateNodeStatus(nodeId, status, true); <line3> final NodeConnectionState currentState = <line4> currentStatus == null ? null : currentStatus.getState(); <line5> if (Objects.equals(status, currentStatus)) { <line6> } else { <line7> } <line8> latestUpdateId.updateAndGet(curVal -> Math.max(curVal, status.getUpdateIdentifier())); <line9> if (currentState == null || currentState != status.getState()) { <line10> final boolean notifyAllNodes = isActiveClusterCoordinator(); <line11> if (notifyAllNodes) { <line12> } else { <line13> } <line14> notifyOthersOfNodeStatusChange(status, notifyAllNodes, waitForCoordinator); <line15> } else { <line16> } <line17> } <line18> } <line19> 	 <line16>	Yes
"public class A { <line0> public static int getFileEntriesAndFileShortcutsCount( <line1> HttpPrincipal httpPrincipal, long groupId, long folderId, int status, String[] mimeTypes) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DLFolderServiceUtil.class, <line7> ""getFileEntriesAndFileShortcutsCount"", <line8> _getFileEntriesAndFileShortcutsCountParameterTypes6); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, groupId, folderId, status, mimeTypes); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return ((Integer) returnObj).intValue(); <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	 <line22>	Yes
public class A { <line0> @Override <line1> public String removeUser(Map<String, Object> request, RequestContext context) { <line2> Keycloak keycloak = KeyCloakConnectionProvider.getConnection(); <line3> String userId = (String) request.get(JsonKey.USER_ID); <line4> try { <line5> String fedUserId = getFederatedUserId(userId); <line6> UserResource resource = <line7> keycloak.realm(KeyCloakConnectionProvider.SSO_REALM).users().get(fedUserId); <line8> if (isNotNull(resource)) { <line9> resource.remove(); <line10> } <line11> } catch (Exception ex) { <line12> ProjectUtil.createAndThrowInvalidUserDataException(); <line13> } <line14> return JsonKey.SUCCESS; <line15> } <line16> } <line17> 	 <line14>	No
public class A { <line0> @Override <line1> public void onNext(final LogData logData) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> HistogramMetrics.Timer timer = histogram.createTimer(); <line5> try { <line6> LogData.Builder builder = logData.toBuilder(); <line7> setServiceName(builder); <line8> logAnalyzerService.doAnalysis(builder); <line9> } catch (Exception e) { <line10> errorCounter.inc(); <line11> } finally { <line12> timer.finish(); <line13> } <line14> } <line15> } <line16> 	 <line11>	Yes
public class A { <line0> @Override <line1> public void doFilter( <line2> ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) <line3> throws IOException, ServletException { <line4> Collection<String> globalAllowedOrigins = null; <line5> if (this.filterEnabled) { <line6> try { <line7> globalAllowedOrigins = doFilterImpl(servletRequest); <line8> } catch (Exception ex) { <line9> } <line10> super.doFilter(servletRequest, servletResponse, filterChain); <line11> setAllowedOrigins(globalAllowedOrigins); <line12> } else { <line13> filterChain.doFilter(servletRequest, servletResponse); <line14> } <line15> } <line16> } <line17> 	 <line9>	Yes
"public class A { <line0> private void updateButtonMouseClicked(java.awt.event.MouseEvent evt) { <line1> int idRow = this.JtableData.getSelectedRow(); <line2> OperationRow operationRow = null; <line3> if (idRow < 0) { <line4> return; <line5> } else { <line6> operationRow = oprowData.get(idRow); <line7> } <line8> opeRowEdit = new OperationRowEdit(operationRow); <line9> opeRowEdit.setMyOpd(myOpd); <line10> opeRowEdit.addOperationRowListener(OperationList.this); <line11> dialogOpe.setContentPane(opeRowEdit); <line12> dialogOpe.setIconImage(ico); <line13> dialogOpe.setTitle(MessageBundle.getMessage(""angal.operationrowlist.editoperation.title"")); <line14> opeRowEdit.setMyParent(dialogOpe); <line15> opeRowEdit <line16> .getTitleLabel() <line17> .setText(MessageBundle.getMessage(""angal.operationrowlist.editoperation.title"")); <line18> dialogOpe.setVisible(true); <line19> dialogOpe.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE); <line20> } <line21> } <line22> "	 <line4>	Yes
public class A { <line0> @Override <line1> public boolean clear(GridCacheVersion ver, boolean readers) throws IgniteCheckedException { <line2> lockEntry(); <line3> try { <line4> if (obsolete()) return false; <line5> try { <line6> if ((!hasReaders() || readers)) { <line7> if (!(markObsolete0(ver, true, null))) { <line8> if (log.isDebugEnabled()) <line9> return false; <line10> } <line11> clearReaders(); <line12> } else { <line13> if (log.isDebugEnabled()) <line14> return false; <line15> } <line16> } catch (GridCacheEntryRemovedException ignore) { <line17> assert false; <line18> return false; <line19> } <line20> if (log.isTraceEnabled()) { <line21> } <line22> if (cctx.mvccEnabled()) cctx.offheap().mvccRemoveAll(this); <line23> else removeValue(); <line24> } finally { <line25> unlockEntry(); <line26> } <line27> onMarkedObsolete(); <line28> cctx.cache().removeEntry(this); <line29> return true; <line30> } <line31> } <line32> 	 <line22>	No
"public class A { <line0> private PluginDescriptor verifyVersionedPlugin( <line1> Plugin plugin, MavenProject project, ArtifactRepository localRepository) <line2> throws PluginVersionResolutionException, ArtifactNotFoundException, <line3> ArtifactResolutionException, InvalidVersionSpecificationException, InvalidPluginException, <line4> PluginManagerException, PluginNotFoundException { <line5> try { <line6> VersionRange versionRange = VersionRange.createFromVersionSpec(plugin.getVersion()); <line7> List remoteRepositories = new ArrayList(); <line8> remoteRepositories.addAll(project.getPluginArtifactRepositories()); <line9> remoteRepositories.addAll(project.getRemoteArtifactRepositories()); <line10> checkRequiredMavenVersion(plugin, localRepository, remoteRepositories); <line11> Artifact pluginArtifact = <line12> artifactFactory.createPluginArtifact( <line13> plugin.getGroupId(), plugin.getArtifactId(), versionRange); <line14> pluginArtifact = project.replaceWithActiveArtifact(pluginArtifact); <line15> artifactResolver.resolve( <line16> pluginArtifact, project.getPluginArtifactRepositories(), localRepository); <line17> plugin.setVersion(pluginArtifact.getBaseVersion()); <line18> String pluginKey = PluginUtils.constructVersionedKey(plugin); <line19> PlexusContainer pluginContainer = container.getChildContainer(pluginKey); <line20> File pluginFile = pluginArtifact.getFile(); <line21> if (!pluginCollector.isPluginInstalled(plugin) || (pluginContainer == null)) { <line22> addPlugin(plugin, pluginArtifact, project, localRepository); <line23> } else if (pluginFile.lastModified() > pluginContainer.getCreationDate().getTime()) { <line24> getLogger() <line25> pluginContainer.dispose(); <line26> pluginCollector.flushPluginDescriptor(plugin); <line27> addPlugin(plugin, pluginArtifact, project, localRepository); <line28> } <line29> project.addPlugin(plugin); <line30> } catch (ArtifactNotFoundException e) { <line31> String groupId = plugin.getGroupId(); <line32> String artifactId = plugin.getArtifactId(); <line33> String version = plugin.getVersion(); <line34> if ((groupId == null) || (artifactId == null) || (version == null)) { <line35> throw new PluginNotFoundException(e); <line36> } else if (groupId.equals(e.getGroupId()) <line37> && artifactId.equals(e.getArtifactId()) <line38> && version.equals(e.getVersion()) <line39> && ""maven-plugin"".equals(e.getType())) { <line40> throw new PluginNotFoundException(e); <line41> } else { <line42> throw e; <line43> } <line44> } <line45> return pluginCollector.getPluginDescriptor(plugin); <line46> } <line47> } <line48> "	 <line25>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> server.stop(); <line4> } catch (Throwable t) { <line5> } <line6> } <line7> } <line8> 	 <line6>	No
"public class A { <line0> private String createURL( <line1> String apiKey, String text, String locale, String voice, String audioFormat) { <line2> String encodedMsg; <line3> try { <line4> encodedMsg = URLEncoder.encode(text, ""UTF-8""); <line5> } catch (UnsupportedEncodingException ex) { <line6> encodedMsg = text; <line7> } <line8> String url = ""http://api.voicerss.org/?key="" + apiKey + ""&hl="" + locale + ""&c="" + audioFormat; <line9> if (!DEFAULT_VOICE.equals(voice)) { <line10> url += ""&v="" + voice; <line11> } <line12> url += ""&f=44khz_16bit_mono&src="" + encodedMsg; <line13> return url; <line14> } <line15> } <line16> "	 <line2>	No
"public class A { <line0> @Test <line1> public void findDatasetsByAttributeWithPaginationTest() { <line2> LOGGER.info( <line3> ""FindDatasets by attribute with pagination test start................................""); <line4> DatasetTest datasetTest = new DatasetTest(); <line5> Value numValue = Value.newBuilder().setNumberValue(0.6543210).build(); <line6> KeyValueQuery keyValueQuery2 = <line7> KeyValueQuery.newBuilder() <line8> .setKey(""attributes.attribute_1"") <line9> .setValue(numValue) <line10> .setOperator(OperatorEnum.Operator.LTE) <line11> .build(); <line12> int pageLimit = 2; <line13> int count = 0; <line14> boolean isExpectedResultFound = false; <line15> for (int pageNumber = 1; pageNumber < 100; pageNumber++) { <line16> FindDatasets findDatasets = <line17> FindDatasets.newBuilder() <line18> .addAllDatasetIds(datasetMap.keySet()) <line19> .addPredicates(keyValueQuery2) <line20> .setPageLimit(pageLimit) <line21> .setPageNumber(pageNumber) <line22> .setAscending(true) <line23> .setSortKey(""name"") <line24> .build(); <line25> FindDatasets.Response response = datasetServiceStub.findDatasets(findDatasets); <line26> assertEquals( <line27> ""Total records count not matched with expected records count"", <line28> 3, <line29> response.getTotalRecords()); <line30> if (response.getDatasetsList() != null && response.getDatasetsList().size() > 0) { <line31> isExpectedResultFound = true; <line32> for (Dataset dataset : response.getDatasetsList()) { <line33> assertTrue( <line34> ""Dataset not match with expected dataset"", datasetMap.containsKey(dataset.getId())); <line35> if (count == 0) { <line36> assertEquals( <line37> ""Dataset name not match with expected dataset name"", <line38> dataset1.getName(), <line39> dataset.getName()); <line40> } else if (count == 1) { <line41> assertEquals( <line42> ""Dataset name not match with expected dataset name"", <line43> dataset2.getName(), <line44> dataset.getName()); <line45> } else if (count == 2) { <line46> assertEquals( <line47> ""Dataset name not match with expected dataset name"", <line48> dataset3.getName(), <line49> dataset.getName()); <line50> } <line51> count++; <line52> } <line53> } else { <line54> if (isExpectedResultFound) { <line55> assertTrue(true); <line56> } else { <line57> fail(""Expected dataset not found in response""); <line58> } <line59> break; <line60> } <line61> } <line62> } <line63> } <line64> "	 <line50>	No
public class A { <line0> @Override <line1> protected void onEntityChange(Entity member) { <line2> ((CassandraFabricImpl) entity).update(); <line3> } <line4> } <line5> 	 <line4>	No
"public class A { <line0> protected void initializeProcessEngine() { <line1> if (cachedProcessEngine == null) { <line2> ProcessEngines.destroy(); <line3> cachedProcessEngine = ProcessEngines.getDefaultProcessEngine(); <line4> if (cachedProcessEngine == null) { <line5> throw new ActivitiException(""no default process engine available""); <line6> } <line7> } <line8> processEngine = cachedProcessEngine; <line9> processEngineConfiguration = <line10> ((ProcessEngineImpl) processEngine).getProcessEngineConfiguration(); <line11> if (this.getClass().isAnnotationPresent(EnableVerboseExecutionTreeLogging.class)) { <line12> swapCommandInvoker(true); <line13> } <line14> } <line15> } <line16> "	 <line9>	No
public class A { <line0> @Override <line1> public IndexedRecord getCurrent() throws NoSuchElementException { <line2> if (!started || (advanceable != null && !advanceable)) { <line3> throw new NoSuchElementException(); <line4> } <line5> try { <line6> return getFactory().convertToAvro(current); <line7> } catch (Exception e) { <line8> if (properties.dieOnError.getValue()) { <line9> throw new ComponentException(e); <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	 <line8>	Yes
public class A { <line0> protected boolean pop() { <line1> boolean returnValue = false; <line2> try { <line3> ifStack.pop(); <line4> } catch (Exception e) { <line5> } <line6> return returnValue; <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void onReceiveCommand(String channelId, LGWebOSHandler handler, Command command) { <line2> final PercentType percent; <line3> if (RefreshType.REFRESH == command) { <line4> handler.getSocket().getVolume(createResponseListener(channelId, handler)); <line5> return; <line6> } <line7> if (command instanceof PercentType) { <line8> percent = (PercentType) command; <line9> } else if (command instanceof DecimalType) { <line10> percent = new PercentType(((DecimalType) command).toBigDecimal()); <line11> } else if (command instanceof StringType) { <line12> percent = new PercentType(((StringType) command).toString()); <line13> } else { <line14> percent = null; <line15> } <line16> if (percent != null) { <line17> handler.getSocket().setVolume(percent.floatValue() / 100.0f, objResponseListener); <line18> } else if (IncreaseDecreaseType.INCREASE == command) { <line19> handler.getSocket().volumeUp(objResponseListener); <line20> } else if (IncreaseDecreaseType.DECREASE == command) { <line21> handler.getSocket().volumeDown(objResponseListener); <line22> } else if (OnOffType.OFF == command || OnOffType.ON == command) { <line23> handler.getSocket().setMute(OnOffType.OFF == command, objResponseListener); <line24> } else { <line25> } <line26> } <line27> } <line28> 	 <line9>	No
public class A { <line0> private byte[] pack(InputStream stream) { <line1> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line2> try { <line3> StreamUtils.copyStream(stream, out, true); <line4> } catch (IOException e) { <line5> } <line6> return out.toByteArray(); <line7> } <line8> } <line9> 	 <line1>	Yes
"public class A { <line0> @Override <line1> public CollectedUpdateMetrics parse(ContentResponse entity) throws IOException { <line2> String content = entity.getContentAsString(); <line3> String[] lines = content.split(""\\r?\\n""); <line4> CollectedUpdateMetrics collectedUpdateMetrics = extractMetrics(lines); <line5> return collectedUpdateMetrics; <line6> } <line7> } <line8> "	 <line4>	No
"public class A { <line0> private void startDbServer() { <line1> final String mode = Config.getInstance().getProperty(Config.AlpineKey.DATABASE_MODE); <line2> final int port = Config.getInstance().getPropertyAsInt(Config.AlpineKey.DATABASE_PORT); <line3> if (StringUtils.isEmpty(mode) <line4> || !(""server"".equals(mode) || ""embedded"".equals(mode) || ""external"".equals(mode))) { <line5> } <line6> if (dbServer != null || ""embedded"".equals(mode) || ""external"".equals(mode)) { <line7> return; <line8> } <line9> final String[] args = <line10> new String[] {""-tcp"", ""-tcpPort"", String.valueOf(port), ""-tcpAllowOthers"", ""-ifNotExists""}; <line11> try { <line12> dbServer = Server.createTcpServer(args).start(); <line13> } catch (SQLException e) { <line14> stopDbServer(); <line15> } <line16> } <line17> } <line18> "	 <line6>	No
"public class A { <line0> @Override <line1> public String makeDiffHtml(final Context ctx, final String p1, final String p2) { <line2> File f1 = null; <line3> File f2 = null; <line4> String diff = null; <line5> try { <line6> f1 = FileUtil.newTmpFile(p1, m_encoding); <line7> f2 = FileUtil.newTmpFile(p2, m_encoding); <line8> String cmd = TextUtil.replaceString(m_diffCommand, ""%s1"", f1.getPath()); <line9> cmd = TextUtil.replaceString(cmd, ""%s2"", f2.getPath()); <line10> final String output = FileUtil.runSimpleCommand(cmd, f1.getParent()); <line11> final String rawWikiDiff = <line12> new String(output.getBytes(StandardCharsets.ISO_8859_1), m_encoding); <line13> final String htmlWikiDiff = TextUtil.replaceEntities(rawWikiDiff); <line14> if (m_traditionalColorization) { <line15> diff = colorizeDiff(htmlWikiDiff); <line16> } else { <line17> diff = htmlWikiDiff; <line18> } <line19> } catch (final IOException e) { <line20> } catch (final InterruptedException e) { <line21> } finally { <line22> if (f1 != null) { <line23> f1.delete(); <line24> } <line25> if (f2 != null) { <line26> f2.delete(); <line27> } <line28> } <line29> return diff; <line30> } <line31> } <line32> "	 <line22>	No
"public class A { <line0> @Override <line1> public void rollback() throws Exception { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> synchronized (timeoutLock) { <line5> if (state == State.ROLLEDBACK) { <line6> return; <line7> } <line8> if (xid != null) { <line9> if (state != State.PREPARED && state != State.ACTIVE && state != State.ROLLBACK_ONLY) { <line10> throw new ActiveMQIllegalStateException(""Transaction is in invalid state "" + state); <line11> } <line12> } else { <line13> if (state != State.ACTIVE && state != State.ROLLBACK_ONLY) { <line14> throw new ActiveMQIllegalStateException(""Transaction is in invalid state "" + state); <line15> } <line16> } <line17> internalRollback(); <line18> } <line19> } <line20> } <line21> "	 <line6>	Yes
"public class A { <line0> @RequestMapping(value = ""/{id}"", method = RequestMethod.DELETE) <line1> public ResponseEntity<Boolean> delete(@PathVariable(""id"") long id) { <line2> roleManagementService.deleteRole(id); <line3> return new ResponseEntity<>(Boolean.TRUE, HttpStatus.OK); <line4> } <line5> } <line6> "	 <line0>	No
"public class A { <line0> private void register(Bundle bundle, CdiContainer cdiContainer) { <line1> CdiServletContainerInitializer initializer = <line2> new CdiServletContainerInitializer(cdiContainer, this); <line3> WebAppDependencyHolder dependencyHolder = <line4> new CdiWebAppDependencyHolder(bundle.getBundleContext(), initializer); <line5> Dictionary<String, String> props = new Hashtable<String, String>(); <line6> props.put(""bundle.id"", Long.toString(bundle.getBundleId())); <line7> ServiceRegistration<WebAppDependencyHolder> registration = <line8> bundle <line9> .getBundleContext() <line10> .registerService(WebAppDependencyHolder.class, dependencyHolder, props); <line11> registrations.put(bundle, registration); <line12> } <line13> } <line14> "	 <line12>	Yes
public class A { <line0> @Override <line1> public AttributeList setAttributes(AttributeList attributes) { <line2> AttributeList results = new AttributeList(attributes.size()); <line3> for (Attribute attribute : attributes.asList()) { <line4> try { <line5> setAttribute(attribute); <line6> results.add(new Attribute(attribute.getName(), getAttribute(attribute.getName()))); <line7> } catch (Throwable x) { <line8> } <line9> } <line10> return results; <line11> } <line12> } <line13> 	 <line8>	Yes
"public class A { <line0> private static Future<String> extractVersionForUpdate( <line1> final ResultSet device, final Optional<String> resourceVersion) { <line2> final Optional<String> version = <line3> device.getRows(true).stream().map(o -> o.getString(""version"")).findAny(); <line4> if (version.isEmpty()) { <line5> return Future.failedFuture(new EntityNotFoundException()); <line6> } <line7> final var currentVersion = version.get(); <line8> return resourceVersion <line9> .<Future<String>>map( <line10> expected -> { <line11> if (expected.equals(currentVersion)) { <line12> return Future.succeededFuture(currentVersion); <line13> } else { <line14> return Future.failedFuture(new OptimisticLockingException()); <line15> } <line16> }) <line17> .orElseGet(() -> Future.succeededFuture(currentVersion)); <line18> } <line19> } <line20> "	 <line7>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> action.perform(); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	 <line1>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> long logIdBeforeFlush = entryLogger.getCurLogId(); <line4> memTable.flush(SortedLedgerStorage.this); <line5> long logIdAfterFlush = entryLogger.getCurLogId(); <line6> if (entryLogger.reachEntryLogLimit(0) || logIdAfterFlush != logIdBeforeFlush) { <line7> entryLogger.rollLog(); <line8> } <line9> } catch (IOException e) { <line10> } <line11> } <line12> } <line13> 	 <line4>	No
public class A { <line0> protected Map< <line1> org.opendaylight.yang.gen.v1.urn.opendaylight.table.types.rev131026.table.features <line2> .TableFeaturesKey, <line3> org.opendaylight.yang.gen.v1.urn.opendaylight.table.types.rev131026.table.features <line4> .TableFeatures> <line5> convertToSalTableFeatures(final List<MultipartReply> multipartReplies) { <line6> final var salTableFeaturesAll = <line7> BindingMap <line8> .<org.opendaylight.yang.gen.v1.urn.opendaylight.table.types.rev131026.table.features <line9> .TableFeaturesKey, <line10> org.opendaylight.yang.gen.v1.urn.opendaylight.table.types.rev131026.table.features <line11> .TableFeatures> <line12> orderedBuilder(); <line13> for (final MultipartReply multipartReply : multipartReplies) { <line14> if (multipartReply.getType().equals(MultipartType.OFPMPTABLEFEATURES)) { <line15> final MultipartReplyBody multipartReplyBody = multipartReply.getMultipartReplyBody(); <line16> if (multipartReplyBody instanceof MultipartReplyTableFeaturesCase) { <line17> final MultipartReplyTableFeaturesCase tableFeaturesCase = <line18> (MultipartReplyTableFeaturesCase) multipartReplyBody; <line19> final MultipartReplyTableFeatures salTableFeatures = <line20> tableFeaturesCase.getMultipartReplyTableFeatures(); <line21> final Optional<List<TableFeatures>> salTableFeaturesPartial = <line22> convertorExecutor.convert(salTableFeatures, data); <line23> salTableFeaturesPartial.ifPresent(salTableFeaturesAll::addAll); <line24> } <line25> } <line26> } <line27> return salTableFeaturesAll.build(); <line28> } <line29> } <line30> 	 <line24>	Yes
"public class A { <line0> private EntitySpec<?> resolve( <line1> Collection<EntitySpecResolver> resolvers, <line2> String localType, <line3> BrooklynClassLoadingContext loader, <line4> Set<String> encounteredTypes) { <line5> Collection<String> resolversWhoDontSupport = new ArrayList<String>(); <line6> Collection<Exception> otherProblemsFromResolvers = new ArrayList<Exception>(); <line7> for (EntitySpecResolver resolver : resolvers) { <line8> if (resolver.accepts(localType, loader)) { <line9> try { <line10> EntitySpec<?> spec = resolver.resolve(localType, loader, encounteredTypes); <line11> if (spec != null) { <line12> return spec; <line13> } else { <line14> resolversWhoDontSupport.add(resolver.getName() + "" (returned null)""); <line15> } <line16> } catch (Exception e) { <line17> otherProblemsFromResolvers.add( <line18> new PropagatedRuntimeException( <line19> ""Transformer for "" + resolver.getName() + "" gave an error creating this plan: "", <line20> Exceptions.collapseText(e), <line21> e)); <line22> } <line23> } <line24> } <line25> if (!otherProblemsFromResolvers.isEmpty()) { <line26> throw otherProblemsFromResolvers.size() == 1 <line27> ? Exceptions.create(null, otherProblemsFromResolvers) <line28> : Exceptions.create(""ServiceSpecResolvers all failed"", otherProblemsFromResolvers); <line29> } <line30> return null; <line31> } <line32> } <line33> "	 <line26>	Yes
public class A { <line0> private String convertToBytes(String value, String unit) { <line1> BigDecimal resourceSize = new BigDecimal(value); <line2> resourceSize = resourceSize.setScale(1, BigDecimal.ROUND_HALF_UP); <line3> switch (unit) { <line4> case B: <line5> break; <line6> case KB: <line7> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_KB)); <line8> break; <line9> case MB: <line10> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_MB)); <line11> break; <line12> case GB: <line13> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_GB)); <line14> break; <line15> case TB: <line16> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_TB)); <line17> break; <line18> case PB: <line19> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_PB)); <line20> break; <line21> default: <line22> break; <line23> } <line24> String resourceSizeAsString = resourceSize.toPlainString(); <line25> return resourceSizeAsString; <line26> } <line27> } <line28> 	 <line25>	Yes
public class A { <line0> private void rewriteProjectsForArrayDataType() { <line1> if (hasIntersect) { <line2> Set<TblColRef> tblColRefs = new HashSet<>(context.allColumns); <line3> IRealization realization = context.realization; <line4> TblColRef groupBy = null; <line5> DataType groupByType = null; <line6> if (realization instanceof CubeInstance) { <line7> CubeDesc cubeDesc = ((CubeInstance) realization).getDescriptor(); <line8> for (MeasureDesc measureDesc : cubeDesc.getMeasures()) { <line9> if (measureDesc.getFunction().getMeasureType() instanceof BitmapMeasureType) { <line10> TblColRef col1 = measureDesc.getFunction().getParameter().getColRef(); <line11> tblColRefs.remove(col1); <line12> } <line13> } <line14> if (tblColRefs.size() == 1) { <line15> for (TblColRef colRef : tblColRefs) { <line16> groupBy = colRef; <line17> groupByType = groupBy.getType(); <line18> } <line19> if (groupByType != null && groupByType.isDateTimeFamily()) { <line20> for (int i = 0; i < this.rewriteProjects.size(); i++) { <line21> RexNode rex = this.rewriteProjects.get(i); <line22> if (groupByType.isTimestamp()) { <line23> rewriteProjectForIntersect( <line24> rex, SqlTypeName.TIMESTAMP, timestampType, timestampArrayType, i); <line25> } else if (groupByType.isDate()) { <line26> rewriteProjectForIntersect(rex, SqlTypeName.DATE, dateType, dateArrayType, i); <line27> } <line28> } <line29> } <line30> } else { <line31> } <line32> } <line33> } <line34> } <line35> } <line36> 	 <line18>	Yes
"public class A { <line0> public void verifyTest_2_6() throws Exception { <line1> Context context = new Context(); <line2> CheckPointReport result = <line3> verifyValidation( <line4> log, context, ""trip_6"", ""2-GTFS-Trip-6"", SEVERITY.WARNING, RESULT.NOK, true); <line5> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line6> for (CheckPointErrorReport detail : getDetails(context, result)) { <line7> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line8> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line9> Assert.assertEquals( <line10> detail.getSource().getFile().getFilename(), ""trips.txt"", ""detail must refer bad file""); <line11> Assert.assertEquals( <line12> detail.getSource().getFile().getLineNumber(), <line13> Integer.valueOf(2), <line14> ""detail must refer bad line""); <line15> } <line16> } <line17> } <line18> "	 <line1>	Yes
public class A { <line0> private void onLineReceived(String line) { <line1> if (line.isEmpty()) { <line2> return; <line3> } <line4> if (line.startsWith(SSE_KEY_EVENT)) { <line5> event = line.substring(SSE_KEY_EVENT.length()).trim(); <line6> } else if (line.startsWith(SSE_KEY_DATA)) { <line7> String event = this.event; <line8> String data = line.substring(SSE_KEY_DATA.length()).trim(); <line9> if (event == null) { <line10> } else { <line11> onServerSentEventCallback.accept(new ServerSentEvent(event, data)); <line12> } <line13> } else { <line14> } <line15> } <line16> } <line17> 	 <line3>	No
public class A { <line0> public void writeToXML(File f, XStream streamer) throws IOException { <line1> XMLUtils.objectToFile(this, f, streamer); <line2> } <line3> } <line4> 	 <line3>	No
"public class A { <line0> Event readEvent(InputStream input) throws ErrorResponseException { <line1> String streamPreview = null; <line2> try { <line3> input = Payload.prepareInputStream(input); <line4> streamPreview = previewInput(input); <line5> Event receivedEvent = XyzSerializable.deserialize(input); <line6> return receivedEvent; <line7> } catch (JsonMappingException e) { <line8> logger.error( <line9> ""{} [{} ms] - Exception {} occurred while reading the event: {}"", <line10> ""FATAL"", <line11> ms(), <line12> e.getMessage(), <line13> streamPreview, <line14> e); <line15> throw new ErrorResponseException(streamId, XyzError.ILLEGAL_ARGUMENT, ""Unknown event type""); <line16> } catch (ClassCastException e) { <line17> logger.error( <line18> ""{} [{} ms] - Exception {} occurred while reading the event: {}"", <line19> ""FATAL"", <line20> ms(), <line21> e.getMessage(), <line22> streamPreview, <line23> e); <line24> throw new ErrorResponseException( <line25> streamId, XyzError.ILLEGAL_ARGUMENT, ""The input should be of type Event""); <line26> } catch (Exception e) { <line27> throw new ErrorResponseException(streamId, XyzError.EXCEPTION, e); <line28> } <line29> } <line30> } <line31> "	 <line30>	No
"public class A { <line0> @RequestMapping(value = ""/{packageName}-{versionCode}.apk"", method = RequestMethod.GET) <line1> public void handleRequest( <line2> @PathVariable String packageName, <line3> @PathVariable Integer versionCode, <line4> HttpServletRequest request, <line5> HttpServletResponse response, <line6> OutputStream outputStream) { <line7> Application application = applicationDao.readByPackageName(packageName); <line8> ApplicationVersion applicationVersion = applicationVersionDao.read(application, versionCode); <line9> response.setContentType(applicationVersion.getContentType()); <line10> byte[] bytes = applicationVersion.getBytes(); <line11> response.setContentLength(bytes.length); <line12> try { <line13> outputStream.write(bytes); <line14> } catch (EOFException ex) { <line15> } catch (IOException ex) { <line16> } finally { <line17> try { <line18> try { <line19> outputStream.flush(); <line20> outputStream.close(); <line21> } catch (EOFException ex) { <line22> } <line23> } catch (IOException ex) { <line24> } <line25> } <line26> } <line27> } <line28> "	 <line5>	No
public class A { <line0> protected boolean parse( <line1> final Path workdir, <line2> final ListProgressListener listener, <line3> final AttributedList<Path> list, <line4> final SearchV2Result result) <line5> throws ConnectionCanceledException { <line6> final List<SearchMatchV2> matches = result.getMatches(); <line7> for (SearchMatchV2 match : matches) { <line8> final Metadata metadata = match.getMetadata().getMetadataValue(); <line9> final EnumSet<Path.Type> type; <line10> if (metadata instanceof FileMetadata) { <line11> type = EnumSet.of(Path.Type.file); <line12> } else if (metadata instanceof FolderMetadata) { <line13> type = EnumSet.of(Path.Type.directory); <line14> } else { <line15> return true; <line16> } <line17> list.add(new Path(metadata.getPathDisplay(), type, attributes.toAttributes(metadata))); <line18> listener.chunk(workdir, list); <line19> } <line20> return false; <line21> } <line22> } <line23> 	 <line1>	No
public class A { <line0> @Override <line1> protected AmazonCloudWatchClient createClient( <line2> ProcessContext processContext, <line3> AWSCredentials awsCredentials, <line4> ClientConfiguration clientConfiguration) { <line5> return new AmazonCloudWatchClient(awsCredentials, clientConfiguration); <line6> } <line7> } <line8> 	 <line2>	No
"public class A { <line0> private ListenableFuture<Void> stopTask(final String id, final boolean publish) { <line1> return Futures.transform( <line2> taskClient.stopAsync(id, publish), <line3> new Function<Boolean, Void>() { <line4> @Nullable <line5> @Override <line6> public Void apply(@Nullable Boolean result) { <line7> if (result == null || !result) { <line8> killTask(id, ""Task [%s] failed to stop in a timely manner, killing task"", id); <line9> } <line10> return null; <line11> } <line12> }); <line13> } <line14> } <line15> "	 <line2>	No
public class A { <line0> @Override <line1> public void remotelyClosed(AmqpConnection connection) { <line2> Exception error = AmqpSupport.convertToException(getEndpoint().getRemoteCondition()); <line3> if (endpoint != null) { <line4> endpoint.close(); <line5> } <line6> connection.fireClientException(error); <line7> } <line8> } <line9> 	 <line6>	Yes
"public class A { <line0> @Override <line1> public Object registerUser( <line2> String login, <line3> String password, <line4> String lastname, <line5> String firstname, <line6> String email, <line7> String country, <line8> long languageId, <line9> String tzId) { <line10> try { <line11> if (isAllowRegisterFrontend()) { <line12> User u = getNewUserInstance(null); <line13> u.setFirstname(firstname); <line14> u.setLogin(login); <line15> u.setLastname(lastname); <line16> u.getAddress().setCountry(country); <line17> u.getAddress().setEmail(email); <line18> u.setTimeZoneId(getTimeZone(tzId).getID()); <line19> u.setLanguageId(languageId != 0 ? languageId : 1); <line20> u.addGroup(groupDao.get(getDefaultGroup())); <line21> Object user = registerUser(u, password, null); <line22> if (user instanceof User && sendConfirmation()) { <line23> return -40L; <line24> } <line25> return user; <line26> } else { <line27> return ""error.reg.disabled""; <line28> } <line29> } catch (Exception e) { <line30> } <line31> return null; <line32> } <line33> } <line34> "	 <line13>	No
"public class A { <line0> @Test <line1> public void testTriggerHasUnexistentAttribute() { <line2> Payload event = new Payload(); <line3> event.addStatement(Statement.AND, ""number"", Statement.EQUALS, ""1""); <line4> event.addStatement(Statement.AND, ""text"", Statement.EQUALS, ""abc""); <line5> Payload trigger = new Payload(); <line6> trigger.addStatement(Statement.AND, ""unexistentPropertyOne"", Statement.REGEX, ""*""); <line7> trigger.addStatement(Statement.AND, ""unexistentPropertyTwo"", Statement.EQUALS, ""1""); <line8> trigger.addStatement(Statement.AND, ""event.number"", Statement.EQUALS, ""123""); <line9> trigger.addStatement(""SET"", ""defineANewProperty"", Statement.EQUALS, ""123""); <line10> boolean result = trigger.equals(event); <line11> assertEquals(false, result); <line12> } <line13> } <line14> "	 <line2>	Yes
"public class A { <line0> public static File switchClusterRolesToRolesIfNeeded(File oldFile) { <line1> if (Environment.isNamespaceRbacScope()) { <line2> try { <line3> File tmpFile = <line4> File.createTempFile(""rbac-"" + oldFile.getName().replace("".yaml"", """"), "".yaml""); <line5> TestUtils.writeFile( <line6> tmpFile.getAbsolutePath(), TestUtils.readFile(oldFile).replace(""ClusterRole"", ""Role"")); <line7> return tmpFile; <line8> } catch (IOException e) { <line9> throw new RuntimeException(e); <line10> } <line11> } else { <line12> return oldFile; <line13> } <line14> } <line15> } <line16> "	 <line12>	No
public class A { <line0> @BeforeAll <line1> public static void doCollectionSetup() { <line2> EmbedMongoConfiguration.DATABASE.createCollection(COLLECTION); <line3> } <line4> } <line5> 	 <line4>	No
"public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryReplenishmentItem <line1> getCommerceInventoryReplenishmentItem( <line2> HttpPrincipal httpPrincipal, long commerceInventoryReplenishmentItemId) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> new MethodKey( <line7> CommerceInventoryReplenishmentItemServiceUtil.class, <line8> ""getCommerceInventoryReplenishmentItem"", <line9> _getCommerceInventoryReplenishmentItemParameterTypes2); <line10> MethodHandler methodHandler = <line11> new MethodHandler(methodKey, commerceInventoryReplenishmentItemId); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.commerce.inventory.model.CommerceInventoryReplenishmentItem) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	 <line23>	Yes
"public class A { <line0> @org.junit.Test <line1> public void testValidateRedeliveryFlagAfterRecovery() throws Exception { <line2> ConnectionFactory connectionFactory = <line3> new ActiveMQConnectionFactory( <line4> broker.getTransportConnectors().get(0).getPublishableConnectString() <line5> + ""?jms.prefetchPolicy.all=0""); <line6> connection = (ActiveMQConnection) connectionFactory.createConnection(); <line7> connection.start(); <line8> Session session = connection.createSession(true, Session.SESSION_TRANSACTED); <line9> Destination destination = session.createQueue(queueName); <line10> populateDestination(1, destination, connection); <line11> MessageConsumer consumer = session.createConsumer(destination); <line12> TextMessage msg = (TextMessage) consumer.receive(5000); <line13> assertNotNull(""got the message"", msg); <line14> assertEquals(""first delivery"", 1, msg.getLongProperty(""JMSXDeliveryCount"")); <line15> assertEquals(""not a redelivery"", false, msg.getJMSRedelivered()); <line16> stopBrokerWithStoreFailure(broker, persistenceAdapterChoice); <line17> broker = createRestartedBroker(); <line18> broker.start(); <line19> connection.close(); <line20> connectionFactory = <line21> new ActiveMQConnectionFactory( <line22> broker.getTransportConnectors().get(0).getPublishableConnectString()); <line23> connection = (ActiveMQConnection) connectionFactory.createConnection(); <line24> connection.start(); <line25> session = connection.createSession(true, Session.SESSION_TRANSACTED); <line26> consumer = session.createConsumer(destination); <line27> msg = (TextMessage) consumer.receive(10000); <line28> assertNotNull(""got the message again"", msg); <line29> assertEquals(""redelivery count survives restart"", 2, msg.getLongProperty(""JMSXDeliveryCount"")); <line30> assertEquals(""re delivery flag"", true, msg.getJMSRedelivered()); <line31> session.commit(); <line32> connection.close(); <line33> } <line34> } <line35> "	 <line34>	No
"public class A { <line0> private boolean printFinalJobReport() throws YarnException, IOException { <line1> ApplicationReport report; <line2> try { <line3> report = yarnClient.getApplicationReport(appId); <line4> FinalApplicationStatus finalAppStatus = report.getFinalApplicationStatus(); <line5> final long secs = (report.getFinishTime() - report.getStartTime()) / 1000L; <line6> final String time = String.format(""%d minutes, %d seconds."", secs / 60L, secs % 60L); <line7> } catch (YarnException yre) { <line8> return false; <line9> } <line10> return true; <line11> } <line12> } <line13> "	 <line2>	No
public class A { <line0> @Test <line1> public void multipleCompactions() { <line2> int tableCount = 4; <line3> SlowOps.setExpectedCompactions(client, tableCount); <line4> List<SlowOps> tables = <line5> Arrays.stream(getUniqueNames(tableCount)) <line6> .map(tableName -> new SlowOps(client, tableName, maxWaitMillis)) <line7> .collect(Collectors.toList()); <line8> tables.forEach(SlowOps::startCompactTask); <line9> assertEquals( <line10> tableCount, tables.stream().map(SlowOps::getTableName).filter(this::findFate).count()); <line11> tables.forEach( <line12> t -> { <line13> try { <line14> client.tableOperations().cancelCompaction(t.getTableName()); <line15> } catch (AccumuloSecurityException | TableNotFoundException | AccumuloException ex) { <line16> } <line17> boolean cancelled = t.blockWhileCompactionRunning(); <line18> if (!cancelled) { <line19> } <line20> }); <line21> } <line22> } <line23> 	 <line8>	No
"public class A { <line0> @Test <line1> public void testSdkNettyRxJavaThreadsShutdownProperly() throws Exception { <line2> assumeTrue(!ClusterDependentTest.useMock()); <line3> Thread.sleep(500); <line4> ThreadMXBean mx = ManagementFactory.getThreadMXBean(); <line5> Set<String> ignore = dump(threads(mx)); <line6> connect(); <line7> Set<String> beforeShutdown = dump(threads(mx, ignore, false)); <line8> LOGGER.info(""""); <line9> disconnect(); <line10> boolean hasShutdown = env.shutdownAsync().toBlocking().single(); <line11> Set<String> afterShutdown = dump(threads(mx, ignore, true)); <line12> boolean hasCleanedUpThreads = Collections.disjoint(afterShutdown, beforeShutdown); <line13> assertTrue(""Some threads created by the SDK remained after shutdown"", hasCleanedUpThreads); <line14> assertTrue(""env.shutdown() returned false"", hasShutdown); <line15> } <line16> } <line17> "	 <line0>	No
"public class A { <line0> private <R> void coprocssorService( <line1> String serviceName, byte[] startKey, byte[] endKey, Callback<R> callback, StubCall<R> call) <line2> throws Throwable { <line3> ExecutorService pool = this.poolSupplier.get(); <line4> List<byte[]> keys = getStartKeysInRange(startKey, endKey); <line5> Map<byte[], Future<R>> futures = new TreeMap<>(Bytes.BYTES_COMPARATOR); <line6> try { <line7> for (byte[] r : keys) { <line8> RegionCoprocessorRpcChannel channel = coprocessorService(r); <line9> Future<R> future = <line10> pool.submit( <line11> new Callable<R>() { <line12> @Override <line13> public R call() throws Exception { <line14> R result = call.call(channel); <line15> byte[] region = channel.getLastRegion(); <line16> if (callback != null) { <line17> callback.update(region, r, result); <line18> } <line19> return result; <line20> } <line21> }); <line22> futures.put(r, future); <line23> } <line24> } catch (RejectedExecutionException e) { <line25> if (conn.isClosed()) { <line26> throw new DoNotRetryIOException(""Connection is closed"", e); <line27> } else { <line28> throw new HBaseIOException(""Coprocessor operation is rejected"", e); <line29> } <line30> } <line31> for (Map.Entry<byte[], Future<R>> e : futures.entrySet()) { <line32> try { <line33> e.getValue().get(); <line34> } catch (ExecutionException ee) { <line35> throw ee.getCause(); <line36> } catch (InterruptedException ie) { <line37> throw new InterruptedIOException( <line38> ""Interrupted calling coprocessor service "" <line39> + serviceName <line40> + "" for row "" <line41> + Bytes.toStringBinary(e.getKey())) <line42> .initCause(ie); <line43> } <line44> } <line45> } <line46> } <line47> "	 <line41>	No
public class A { <line0> private MethodResult makeExceptionResult(Exception e) { <line1> return new MethodResult(Throwables.getStackTraceAsString(e), ReturnType.Exception); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> public void start(BundleContext bundleContext) throws Exception { <line1> } <line2> } <line3> 	 <line0>	No
"public class A { <line0> public void cancel(final Path file, final String uploadToken) throws BackgroundException { <line1> try { <line2> new UploadsApi(session.getClient()).cancelFileUploadByToken(uploadToken); <line3> } catch (ApiException e) { <line4> throw new SDSExceptionMappingService().map(""Upload {0} failed"", e, file); <line5> } <line6> } <line7> } <line8> "	 <line1>	Yes
"public class A { <line0> public static URL getConfigurationPath(Map<String, String> environmentVariables) { <line1> if (environmentVariables == null) { <line2> throw new IllegalArgumentException(""environmentVariables must not be null""); <line3> } <line4> File conf = getConfigurationDirectory(environmentVariables); <line5> if (conf == null) { <line6> if (SAW_HADOOP_CONF_MISSING.compareAndSet(false, true)) { <line7> } <line8> return null; <line9> } <line10> if (conf.getPath().equals(PATH_CONF_DIR_IGNORE)) { <line11> return null; <line12> } <line13> if (conf.isDirectory() == false) { <line14> return null; <line15> } <line16> try { <line17> return conf.toURI().toURL(); <line18> } catch (MalformedURLException e) { <line19> return null; <line20> } <line21> } <line22> } <line23> "	 <line11>	Yes
"public class A { <line0> @Test <line1> public void testALSServingModel() throws Exception { <line2> Map<String, Object> overlayConfig = new HashMap<>(); <line3> overlayConfig.put( <line4> ""oryx.serving.application-resources"", <line5> ""\""com.cloudera.oryx.app.serving,com.cloudera.oryx.app.serving.als\""""); <line6> overlayConfig.put(""oryx.serving.model-manager-class"", ALSServingModelManager.class.getName()); <line7> Config config = ConfigUtils.overlayOn(overlayConfig, getConfig()); <line8> startMessaging(); <line9> startServer(config); <line10> startUpdateTopics(new MockALSModelUpdateGenerator(), 10); <line11> sleepSeconds(5); <line12> ALSServingModelManager manager = <line13> (ALSServingModelManager) <line14> getServingLayer() <line15> .getContext() <line16> .getServletContext() <line17> .getAttribute(OryxResource.MODEL_MANAGER_KEY); <line18> assertNotNull(""Manager must initialize in web context"", manager); <line19> ALSServingModel model = manager.getModel(); <line20> assertNotNull(model); <line21> assertEquals(2, model.getFeatures()); <line22> assertTrue(model.isImplicit()); <line23> assertContainsSame(MockALSModelUpdateGenerator.Y.keySet(), model.getAllItemIDs()); <line24> assertNotNull(model.getYTYSolver()); <line25> MockALSModelUpdateGenerator.X.forEach( <line26> (id, vector) -> assertArrayEquals(vector, model.getUserVector(id))); <line27> MockALSModelUpdateGenerator.Y.forEach( <line28> (id, vector) -> assertArrayEquals(vector, model.getItemVector(id))); <line29> MockALSModelUpdateGenerator.A.forEach( <line30> (id, expected) -> assertContainsSame(expected, model.getKnownItems(id))); <line31> } <line32> } <line33> "	 <line20>	Yes
public class A { <line0> @Override <line1> public void beforeSendRequest(Invocation invocation, HttpServletRequestEx requestEx) { <line2> HttpHeaders httpHeaders = <line3> (HttpHeaders) invocation.getHandlerContext().get(RestConst.CONSUMER_HEADER); <line4> if (httpHeaders == null) { <line5> return; <line6> } <line7> httpHeaders.forEach( <line8> (key, values) -> { <line9> if (HttpHeaders.CONTENT_LENGTH.equalsIgnoreCase(key)) { <line10> return; <line11> } <line12> for (String value : values) { <line13> if (null == value) { <line14> continue; <line15> } <line16> requestEx.addHeader(key, value); <line17> } <line18> }); <line19> } <line20> } <line21> 	 <line14>	Yes
public class A { <line0> @Override <line1> protected void execute(String detailId) throws Exception { <line2> AttendanceWorkDayConfigServiceAdv attendanceWorkDayConfigServiceAdv = <line3> new AttendanceWorkDayConfigServiceAdv(); <line4> AttendanceStatisticalCycleServiceAdv statisticalCycleServiceAdv = <line5> new AttendanceStatisticalCycleServiceAdv(); <line6> AttendanceDetailAnalyseServiceAdv detailAnalyseServiceAdv = <line7> new AttendanceDetailAnalyseServiceAdv(); <line8> AttendanceDetailServiceAdv detailServiceAdv = new AttendanceDetailServiceAdv(); <line9> AttendanceDetail record = detailServiceAdv.get(detailId); <line10> if (record != null) { <line11> try { <line12> List<AttendanceWorkDayConfig> workDayConfigList = <line13> attendanceWorkDayConfigServiceAdv.getAllWorkDayConfigWithCache(false); <line14> Map<String, Map<String, List<AttendanceStatisticalCycle>>> statisticalCycleMap = <line15> statisticalCycleServiceAdv.getAllStatisticalCycleMapWithCache(false); <line16> detailAnalyseServiceAdv.analyseAttendanceDetail( <line17> record, workDayConfigList, statisticalCycleMap, false); <line18> } catch (Exception e) { <line19> e.printStackTrace(); <line20> } <line21> } else { <line22> } <line23> } <line24> } <line25> 	 <line22>	Yes
"public class A { <line0> public static List<Float> floatParser(String[] arr, List failedTermMsgList, int lineIndex) { <line1> List<Float> ret = new ArrayList(); <line2> for (String s : arr) { <line3> try { <line4> ret.add(Float.parseFloat(s)); <line5> } catch (Exception e) { <line6> failedTermMsgList.add( <line7> ""Provided value "" + s + "" is Float of Long type at line #"" + lineIndex); <line8> } <line9> } <line10> return ret; <line11> } <line12> } <line13> "	 <line6>	Yes
public class A { <line0> @Override <line1> public void trace(String format, Object[] argArray) { <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> protected final Event<Boolean> updateFromSource( <line1> final T dataTag, final SourceDataTagValue sourceDataTagValue) { <line2> long eventTime = 0; <line3> Boolean updated = Boolean.FALSE; <line4> if (sourceDataTagValue != null) { <line5> if (!filterout(dataTag, sourceDataTagValue)) { <line6> if (sourceDataTagValue.getValue() == null) { <line7> if (sourceDataTagValue.isValid()) { <line8> invalidateQuietly( <line9> dataTag, <line10> TagQualityStatus.UNKNOWN_REASON, <line11> ""Null value received from DAQ"", <line12> new Timestamp(System.currentTimeMillis())); <line13> } else { <line14> DataTagQuality newTagQuality = <line15> qualityConverter.convert(sourceDataTagValue.getQuality()); <line16> dataTagCacheObjectFacade.setQuality( <line17> dataTag, newTagQuality, new Timestamp(System.currentTimeMillis())); <line18> } <line19> } else { <line20> if (sourceDataTagValue.isValid()) { <line21> updateAndValidateQuietly( <line22> dataTag, <line23> sourceDataTagValue.getValue(), <line24> sourceDataTagValue.getValueDescription(), <line25> sourceDataTagValue.getTimestamp(), <line26> sourceDataTagValue.getDaqTimestamp(), <line27> new Timestamp(System.currentTimeMillis())); <line28> } else { <line29> DataTagQuality newTagQuality = <line30> qualityConverter.convert(sourceDataTagValue.getQuality()); <line31> dataTagCacheObjectFacade.updateAndInvalidate( <line32> dataTag, <line33> sourceDataTagValue.getValue(), <line34> sourceDataTagValue.getValueDescription(), <line35> sourceDataTagValue.getTimestamp(), <line36> sourceDataTagValue.getDaqTimestamp(), <line37> new Timestamp(System.currentTimeMillis()), <line38> newTagQuality); <line39> } <line40> } <line41> updated = true; <line42> } else { <line43> } <line44> } else { <line45> } <line46> eventTime = dataTag.getCacheTimestamp().getTime(); <line47> return new Event<Boolean>(eventTime, updated); <line48> } <line49> } <line50> "	 <line8>	Yes
public class A { <line0> @Override <line1> protected void handleError(Exception exception) { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> private void reconnect(MockHost host) { <line1> if (s_logger.isDebugEnabled()) { <line2> } <line3> this.agentHost = host; <line4> } <line5> } <line6> 	 <line5>	No
public class A { <line0> private static boolean startEsClient(FsCrawlerImpl fsCrawler) { <line1> try { <line2> fsCrawler.start(); <line3> return true; <line4> } catch (Exception t) { <line5> return false; <line6> } <line7> } <line8> } <line9> 	 <line8>	No
public class A { <line0> @Override <line1> public void clearProceduresForFeatureOfInterest() { <line2> this.proceduresForFeaturesOfInterest.clear(); <line3> } <line4> } <line5> 	 <line1>	No
public class A { <line0> private void checkFileTTL(TsFileResource resource, long timeLowerBound, boolean isSeq) { <line1> if (resource.isMerging() <line2> || !resource.isClosed() <line3> || !resource.isDeleted() && resource.stillLives(timeLowerBound)) { <line4> return; <line5> } <line6> writeLock(); <line7> try { <line8> resource.setDeleted(true); <line9> if (resource.isMerging()) { <line10> return; <line11> } <line12> if (resource.tryWriteLock()) { <line13> try { <line14> resource.remove(); <line15> if (logger.isInfoEnabled()) { <line16> } <line17> tsFileManagement.remove(resource, isSeq); <line18> } finally { <line19> resource.writeUnlock(); <line20> } <line21> } <line22> } finally { <line23> writeUnlock(); <line24> } <line25> } <line26> } <line27> 	 <line9>	No
public class A { <line0> public void setNumFound(int theNumFound) { <line1> myNumFound = theNumFound; <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> public Either<Either<ArtifactDefinition, Operation>, ResponseFormat> <line1> createOrUpdateCsarArtifactFromJson( <line2> Component component, <line3> User user, <line4> Map<String, Object> json, <line5> ArtifactOperationInfo operation) { <line6> String jsonStr = gson.toJson(json); <line7> ArtifactDefinition artifactDefinitionFromJson = <line8> RepresentationUtils.convertJsonToArtifactDefinition( <line9> jsonStr, ArtifactDefinition.class, false); <line10> Either<ArtifactDefinition, Operation> result; <line11> try { <line12> result = <line13> artifactsBusinessLogic.handleLoadedArtifact( <line14> component, <line15> user, <line16> operation, <line17> false, <line18> true, <line19> component.getComponentType(), <line20> artifactDefinitionFromJson); <line21> } catch (ComponentException e) { <line22> return Either.right(componentsUtils.getResponseFormat(e)); <line23> } catch (Exception e) { <line24> ResponseFormat responseFormat = componentsUtils.getResponseFormat(ActionStatus.GENERAL_ERROR); <line25> return Either.right(responseFormat); <line26> } <line27> return Either.left(result); <line28> } <line29> } <line30> 	 <line25>	Yes
public class A { <line0> @Override <line1> public CompletableFuture<Void> enableControllerService(final ControllerServiceNode service) { <line2> return service.enable(componentLifeCycleThreadPool, ADMINISTRATIVE_YIELD_MILLIS); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void debug(String arg0, Throwable arg1) { <line2> if (debug) { <line3> } <line4> } <line5> } <line6> 	 <line2>	No
"public class A { <line0> @Override <line1> public boolean filter(Bundle bundle) { <line2> String urlValue = url.template(bundle); <line3> CacheObject cached = cacheGet(urlValue); <line4> if (cached == null || (cache.age > 0 && System.currentTimeMillis() - cached.time > cache.age)) { <line5> if (log.isDebugEnabled() <line6> && cached != null <line7> && cache.age > 0 <line8> && System.currentTimeMillis() - cached.time > cache.age) { <line9> } <line10> int retries = http.retries; <line11> while (retries-- > 0) { <line12> try { <line13> byte[] val = httpGet(urlValue, null, null, http.timeout, trace); <line14> if (val != null && val.length >= 0) { <line15> cached = cachePut(urlValue, LessBytes.toString(val)); <line16> break; <line17> } else if (trace) { <line18> System.err.println( <line19> urlValue <line20> + "" returned "" <line21> + (val != null ? val.length : -1) <line22> + "" retries left = "" <line23> + retries); <line24> } <line25> } catch (IllegalArgumentException e) { <line26> break; <line27> } catch (IOException e) { <line28> } <line29> try { <line30> Thread.sleep(http.retryTimeout); <line31> } catch (InterruptedException e) { <line32> e.printStackTrace(); <line33> } <line34> } <line35> if (cached == null && defaultValue != null) { <line36> cachePut(urlValue, defaultValue); <line37> } <line38> } <line39> if (cached != null) { <line40> set.setValue(bundle, ValueFactory.create(cached.data)); <line41> } <line42> return true; <line43> } <line44> } <line45> "	 <line24>	No
public class A { <line0> public void attachDirty(MYesno instance) { <line1> try { <line2> getSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line3>	Yes
public class A { <line0> ActionResult<Wo> execute( <line1> EffectivePerson effectivePerson, @Context ServletContext servletContext, String className) <line2> throws Exception { <line3> ActionResult<Wo> result = new ActionResult<>(); <line4> AbstractContext ctx = AbstractContext.fromServletContext(servletContext); <line5> Class<?> clz = Class.forName(className); <line6> ctx.fireScheduleOnLocal((Class<AbstractJob>) clz, 1); <line7> Wo wo = new Wo(); <line8> wo.setValue(true); <line9> result.setData(wo); <line10> return result; <line11> } <line12> } <line13> 	 <line3>	Yes
"public class A { <line0> @PostConstruct <line1> public void init() { <line2> attributes = Attributes.getComponentAttributesFromFacesConfig(UINotify.class, getClass()); <line3> attributes.setAttribute(""detail"", DEFAULT_DETAIL); <line4> attributes.setAttribute(""rendered"", true); <line5> attributes.setAttribute(""showCloseButton"", true); <line6> attributes.setAttribute(""stayTime"", 100000); <line7> attributes.setAttribute(""summary"", DEFAULT_SUMMARY); <line8> } <line9> } <line10> "	 <line0>	No
"public class A { <line0> @Override <line1> protected List<Resource> findJars(WebAppContext context) throws Exception { <line2> List<Resource> list = new ArrayList<>(); <line3> MavenWebAppContext jwac = (MavenWebAppContext) context; <line4> List<File> files = jwac.getWebInfLib(); <line5> if (files != null) { <line6> files.forEach( <line7> file -> { <line8> if (file.getName().toLowerCase(Locale.ENGLISH).endsWith("".jar"") || file.isDirectory()) { <line9> try { <line10> list.add(Resource.newResource(file.toURI())); <line11> } catch (Exception e) { <line12> } <line13> } <line14> }); <line15> } <line16> List<Resource> superList = super.findJars(context); <line17> if (superList != null) list.addAll(superList); <line18> return list; <line19> } <line20> } <line21> "	 <line10>	Yes
public class A { <line0> @Override <line1> public ShareStudy findBySWAccession(Integer swAccession) { <line2> ShareStudy shareStudy = null; <line3> if (swAccession != null) { <line4> try { <line5> shareStudy = dao.findByID(swAccession); <line6> } catch (Exception exception) { <line7> } <line8> } <line9> return shareStudy; <line10> } <line11> } <line12> 	 <line6>	No
public class A { <line0> private ErrorCode extractErrorCode(final XPathException xpe) { <line1> final String message = xpe.getMessage(); <line2> if (':' == message.charAt(8)) { <line3> final String[] data = extractLocalName(xpe.getMessage()); <line4> final ErrorCode errorCode = new ErrorCode(data[0], data[1]); <line5> return errorCode; <line6> } <line7> Throwable retVal = xpe; <line8> Throwable cause = xpe.getCause(); <line9> if (cause != null && !(cause instanceof XPathException)) { <line10> retVal = cause; <line11> } <line12> return new ErrorCodes.JavaErrorCode(retVal); <line13> } <line14> } <line15> 	 <line8>	No
"public class A { <line0> @Override <line1> public final void authenticate( <line2> final JsonObject authRequest, final Handler<AsyncResult<HonoUser>> resultHandler) { <line3> final String mechanism = <line4> Objects.requireNonNull(authRequest).getString(AuthenticationConstants.FIELD_MECHANISM); <line5> final boolean isSupportedMechanism = <line6> Arrays.asList(getSupportedSaslMechanisms()).contains(mechanism); <line7> if (isSupportedMechanism && AuthenticationConstants.MECHANISM_PLAIN.equals(mechanism)) { <line8> final byte[] saslResponse = <line9> authRequest.getBinary(AuthenticationConstants.FIELD_SASL_RESPONSE, new byte[0]); <line10> try { <line11> final String[] fields = AuthenticationConstants.parseSaslResponse(saslResponse); <line12> final String authzid = fields[0]; <line13> final String authcid = fields[1]; <line14> final String pwd = fields[2]; <line15> verifyPlain(authzid, authcid, pwd, resultHandler); <line16> } catch (final CredentialException e) { <line17> resultHandler.handle( <line18> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST, e))); <line19> } <line20> } else if (isSupportedMechanism <line21> && AuthenticationConstants.MECHANISM_EXTERNAL.equals(mechanism)) { <line22> final String authzid = <line23> new String( <line24> authRequest.getBinary(AuthenticationConstants.FIELD_SASL_RESPONSE), <line25> StandardCharsets.UTF_8); <line26> final String subject = authRequest.getString(AuthenticationConstants.FIELD_SUBJECT_DN); <line27> verifyExternal(authzid, subject, resultHandler); <line28> } else { <line29> resultHandler.handle( <line30> Future.failedFuture( <line31> new ClientErrorException( <line32> HttpURLConnection.HTTP_BAD_REQUEST, ""unsupported SASL mechanism""))); <line33> } <line34> } <line35> } <line36> "	 <line6>	No
public class A { <line0> protected void startRegion(int i) throws Exception { <line1> String regionName = REGION_PREFIX + i; <line2> regionNameToIndexMap.put(regionName, i); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> List<PubSubServer> serversList = new LinkedList<PubSubServer>(); <line6> for (int j = 0; j < numServersPerRegion; j++) { <line7> HedwigSocketAddress a = regionHubAddresses.get(i).get(j); <line8> PubSubServer s = <line9> new PubSubServer( <line10> getServerConfiguration(a.getPort(), a.getSSLPort(), regionName), <line11> getRegionClientConfiguration()); <line12> serversList.add(s); <line13> s.start(); <line14> } <line15> regionServersMap.put(regionName, serversList); <line16> HedwigClient regionClient = <line17> new HedwigClient( <line18> getClientConfiguration( <line19> regionHubAddresses.get(i).get(0).getPort(), <line20> regionHubAddresses.get(i).get(0).getSSLPort())); <line21> regionClientsMap.put(regionName, regionClient); <line22> } <line23> } <line24> 	 <line23>	No
"public class A { <line0> public static void backupFile(File outputFile) { <line1> if (outputFile.exists()) { <line2> int lastIndexOfDot = outputFile.getName().lastIndexOf('.'); <line3> String extension = lastIndexOfDot > 0 ? outputFile.getName().substring(lastIndexOfDot) : """"; <line4> File old = new File(outputFile.getParentFile(), ""old""); <line5> if (!old.exists()) { <line6> if (old.mkdirs()) { <line7> } <line8> } <line9> String fileName = <line10> outputFile.getName() + "".old."" + TimeService.currentTimeMillis() + extension; <line11> File newFile = new File(old, fileName); <line12> if (!outputFile.renameTo(newFile)) { <line13> } <line14> } <line15> } <line16> } <line17> "	 <line13>	Yes
"public class A { <line0> public boolean hasAdminViewPermission(AccessGroupSet accessGroups) { <line1> StringBuilder query = new StringBuilder(); <line2> String joinedGroups = <line3> accessGroups.stream() <line4> .filter(p -> !PrincipalClassifier.isPatronPrincipal(p)) <line5> .map(p -> p.replaceAll(""\\:"", ""\\\\:"")) <line6> .collect(Collectors.joining("" OR "")); <line7> query.append(""adminGroup:("").append(joinedGroups).append(')'); <line8> SolrQuery solrQuery = new SolrQuery(); <line9> solrQuery.setQuery(query.toString()); <line10> solrQuery.addFacetQuery( <line11> solrSettings.getFieldName(SearchFieldKeys.RESOURCE_TYPE.name()) <line12> + "":("" <line13> + ResourceType.Collection.name() <line14> + "" "" <line15> + ResourceType.AdminUnit.name() <line16> + "")""); <line17> solrQuery.setRows(0); <line18> try { <line19> QueryResponse queryResponse = this.executeQuery(solrQuery); <line20> return queryResponse.getResults().getNumFound() > 0; <line21> } catch (SolrServerException e) { <line22> } <line23> return false; <line24> } <line25> } <line26> "	 <line22>	Yes
"public class A { <line0> public String fetchUserIdByMobile(String mobile) throws Exception { <line1> OapiUserGetByMobileRequest request = new OapiUserGetByMobileRequest(); <line2> request.setMobile(mobile); <line3> OapiUserGetByMobileResponse execute = userIdClient.execute(request, accessToken); <line4> if (execute.isSuccess()) { <line5> return execute.getUserid(); <line6> } <line7> throw new PowerJobException( <line8> ""fetch userId by phone number failed, reason is "" + execute.getErrmsg()); <line9> } <line10> } <line11> "	 <line1>	No
"public class A { <line0> protected void verifyApplicationControllerTaskRequest( <line1> BuildingBlockExecution execution, ApplicationControllerTaskRequest appcTaskRequest) <line2> throws ValidationException { <line3> String errorMessage = null; <line4> switch (appcTaskRequest.getAction()) { <line5> case QuiesceTraffic: <line6> if (appcTaskRequest.getOperationsTimeout() == null <line7> || appcTaskRequest.getOperationsTimeout().isEmpty()) { <line8> errorMessage = ""APPC action QuiesceTraffic is missing operations_timeout parameter. ""; <line9> } <line10> break; <line11> case UpgradePreCheck: <line12> case UpgradePostCheck: <line13> case UpgradeBackup: <line14> case UpgradeSoftware: <line15> if (appcTaskRequest.getExistingSoftwareVersion() == null <line16> || appcTaskRequest.getExistingSoftwareVersion().isEmpty()) { <line17> errorMessage = <line18> ""APPC action "" <line19> + appcTaskRequest.getAction() <line20> + "" is missing existing_software parameter. ""; <line21> } <line22> if (appcTaskRequest.getNewSoftwareVersion() == null <line23> || appcTaskRequest.getNewSoftwareVersion().isEmpty()) { <line24> errorMessage = <line25> ""APPC action "" + appcTaskRequest.getAction() + "" is missing new_software parameter. ""; <line26> } <line27> break; <line28> case Snapshot: <line29> if (appcTaskRequest.getApplicationControllerVnf().getApplicationControllerVm() != null) { <line30> if (appcTaskRequest.getApplicationControllerVnf().getApplicationControllerVm().getVmId() <line31> == null <line32> || appcTaskRequest <line33> .getApplicationControllerVnf() <line34> .getApplicationControllerVm() <line35> .getVmId() <line36> .isEmpty()) { <line37> errorMessage = ""APPC action Snapshot is missing vmId parameter. ""; <line38> } <line39> if (appcTaskRequest <line40> .getApplicationControllerVnf() <line41> .getApplicationControllerVm() <line42> .getVserverId() <line43> == null <line44> || appcTaskRequest <line45> .getApplicationControllerVnf() <line46> .getApplicationControllerVm() <line47> .getVserverId() <line48> .isEmpty()) { <line49> errorMessage = ""APPC action Snapshot is missing vserverId parameter. ""; <line50> } <line51> } <line52> break; <line53> case ConfigModify: <line54> if (appcTaskRequest.getConfigParams().isEmpty() <line55> || appcTaskRequest.getConfigParams() == null) { <line56> errorMessage = ""APPC action ConfigModify is missing Configuration parameters. ""; <line57> } <line58> break; <line59> default: <line60> break; <line61> } <line62> if (errorMessage != null) { <line63> throw new ValidationException(errorMessage, false); <line64> } <line65> return; <line66> } <line67> } <line68> "	 <line63>	Yes
public class A { <line0> @Override <line1> public void jbossWSUnableToCreateBinaryToken(Throwable t) { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> public TSStatus testInsertTablets(TSInsertTabletsReq req) { <line2> return RpcUtils.getStatus(TSStatusCode.SUCCESS_STATUS); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> public static List<NamedThing> getSchemaNames(PartnerConnection connection) throws IOException { <line1> List<NamedThing> returnList = new ArrayList<>(); <line2> DescribeGlobalResult result = null; <line3> try { <line4> result = connection.describeGlobal(); <line5> } catch (ConnectionException e) { <line6> throw new ComponentException(e); <line7> } <line8> DescribeGlobalSObjectResult[] objects = result.getSobjects(); <line9> for (DescribeGlobalSObjectResult obj : objects) { <line10> returnList.add(new SimpleNamedThing(obj.getName(), obj.getLabel())); <line11> } <line12> return returnList; <line13> } <line14> } <line15> 	 <line7>	No
public class A { <line0> private synchronized void killAndUnregisterHook(final S stat) { <line1> try { <line2> killImpl(stat); <line3> } catch (IOException e) { <line4> throw new RuntimeException(e); <line5> } <line6> if (null != killerHook) { <line7> try { <line8> Runtime.getRuntime().removeShutdownHook(killerHook); <line9> } catch (IllegalStateException e) { <line10> } <line11> killerHook = null; <line12> } <line13> } <line14> } <line15> 	 <line9>	Yes
"public class A { <line0> @Override <line1> public final Future<JsonObject> getTargetGatewayAndAdapterInstance( <line2> final String tenantId, final String deviceId, final SpanContext context) { <line3> if (!initialized.get()) { <line4> return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR)); <line5> } <line6> final Span span = <line7> TracingHelper.buildChildSpan( <line8> tracer, <line9> context, <line10> ""get target gateway and adapter instance"", <line11> CommandTargetMapper.class.getSimpleName()) <line12> .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER) <line13> .withTag(TracingHelper.TAG_TENANT_ID, tenantId) <line14> .withTag(TracingHelper.TAG_DEVICE_ID, deviceId) <line15> .start(); <line16> return mapperContext <line17> .getViaGateways(tenantId, deviceId, span.context()) <line18> .recover( <line19> t -> { <line20> return Future.failedFuture(t); <line21> }) <line22> .compose( <line23> viaGateways -> { <line24> return mapperContext <line25> .getCommandHandlingAdapterInstances( <line26> tenantId, deviceId, viaGateways, span.context()) <line27> .compose( <line28> resultJson -> <line29> determineTargetInstanceJson(resultJson, deviceId, viaGateways, span)); <line30> }) <line31> .map( <line32> result -> { <line33> span.finish(); <line34> return result; <line35> }) <line36> .recover( <line37> t -> { <line38> TracingHelper.logError(span, t); <line39> Tags.HTTP_STATUS.set(span, ServiceInvocationException.extractStatusCode(t)); <line40> span.finish(); <line41> return Future.failedFuture(t); <line42> }); <line43> } <line44> } <line45> "	 <line4>	Yes
public class A { <line0> private void storeToken(TrackingToken token) { <line1> tokenStore.storeToken(token, name, segment.getSegmentId()); <line2> lastStoredToken = token; <line3> lastClaimExtension = clock.instant().toEpochMilli(); <line4> } <line5> } <line6> 	 <line4>	No
public class A { <line0> @Override <line1> protected AuthorizationDecision combineDecisions( <line2> AuthorizationDecision[] decisions, boolean errorsInTarget) { <line3> if (decisions.length == 0) return AuthorizationDecision.DENY; <line4> var entitlement = DENY; <line5> var collector = new ObligationAdviceCollector(); <line6> Optional<JsonNode> resource = Optional.empty(); <line7> for (var decision : decisions) { <line8> if (decision.getDecision() == PERMIT) { <line9> entitlement = PERMIT; <line10> } <line11> collector.add(decision); <line12> if (decision.getResource().isPresent()) { <line13> if (resource.isPresent()) { <line14> entitlement = DENY; <line15> } else { <line16> resource = decision.getResource(); <line17> } <line18> } <line19> } <line20> var finalDecision = <line21> new AuthorizationDecision( <line22> entitlement, <line23> resource, <line24> collector.getObligations(entitlement), <line25> collector.getAdvices(entitlement)); <line26> return finalDecision; <line27> } <line28> } <line29> 	 <line26>	Yes
public class A { <line0> public void finish() { <line1> while (true) { <line2> try { <line3> documents.put(FINAL_DOCUMENT); <line4> thread.join(); <line5> break; <line6> } catch (InterruptedException e) { <line7> Thread.currentThread().interrupt(); <line8> } <line9> } <line10> } <line11> } <line12> 	 <line8>	No
"public class A { <line0> @Override <line1> public UpgradeStatus getStatus(Optional<DataSource> dataSource) { <line2> SelectStatement select = <line3> SqlUtils.select(SqlUtils.field(STATUS_COLUMN)) <line4> .from(tableRef(UpgradeStatusTableService.UPGRADE_STATUS)); <line5> Connection connection = null; <line6> try { <line7> if (dataSource.isPresent()) { <line8> try { <line9> connection = dataSource.get().getConnection(); <line10> return sqlScriptExecutorProvider <line11> .get() <line12> .executeQuery( <line13> sqlDialect.convertStatementToSQL(select), connection, resultSetProcessor()); <line14> } finally { <line15> if (connection != null) connection.close(); <line16> } <line17> } else { <line18> return sqlScriptExecutorProvider <line19> .get() <line20> .executeQuery(sqlDialect.convertStatementToSQL(select), resultSetProcessor()); <line21> } <line22> } catch (RuntimeSqlException e) { <line23> return UpgradeStatus.NONE; <line24> } catch (SQLException e) { <line25> throw new RuntimeException(""Unable to get a connection to retrieve upgrade status."", e); <line26> } <line27> } <line28> } <line29> "	 <line25>	Yes
public class A { <line0> @Override <line1> public SyncDLObject remove(Serializable primaryKey) throws NoSuchDLObjectException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> SyncDLObject syncDLObject = (SyncDLObject) session.get(SyncDLObjectImpl.class, primaryKey); <line6> if (syncDLObject == null) { <line7> if (_log.isDebugEnabled()) { <line8> } <line9> throw new NoSuchDLObjectException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> return remove(syncDLObject); <line12> } catch (NoSuchDLObjectException noSuchEntityException) { <line13> throw noSuchEntityException; <line14> } catch (Exception exception) { <line15> throw processException(exception); <line16> } finally { <line17> closeSession(session); <line18> } <line19> } <line20> } <line21> 	 <line8>	Yes
public class A { <line0> private ConfigDataEnvironmentContributors processWithProfiles( <line1> ConfigDataEnvironmentContributors contributors, <line2> ConfigDataImporter importer, <line3> ConfigDataActivationContext activationContext) { <line4> contributors = contributors.withProcessedImports(importer, activationContext); <line5> registerBootstrapBinder(contributors, activationContext, ALLOW_INACTIVE_BINDING); <line6> return contributors; <line7> } <line8> } <line9> 	 <line4>	Yes
"public class A { <line0> @Override <line1> public String getStagingDirectory(String key) { <line2> return ""/tmp/"" + key.replaceAll("" "", ""_""); <line3> } <line4> } <line5> "	 <line1>	No
public class A { <line0> @Override <line1> public void init(ServletConfig servletConfig) throws ServletException { <line2> super.init(servletConfig); <line3> this.planetCache = PlanetCache.getInstance(); <line4> } <line5> } <line6> 	 <line1>	No
"public class A { <line0> @ApiOperation(value = ""delete securityProfile"") <line1> @DeleteMapping(CommonConstants.PATH_ID) <line2> public void delete(final @PathVariable String id) { <line3> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line4> service.delete(buildUiHttpContext(), id); <line5> } <line6> } <line7> "	 <line3>	Yes
"public class A { <line0> @Override <line1> public void contribute(Document document, DDMFormInstanceRecord ddmFormInstanceRecord) { <line2> try { <line3> DDMFormInstanceRecordVersion ddmFormInstanceRecordVersion = <line4> ddmFormInstanceRecord.getFormInstanceRecordVersion(); <line5> DDMFormInstance ddmFormInstance = ddmFormInstanceRecordVersion.getFormInstance(); <line6> document.addKeyword( <line7> Field.CLASS_NAME_ID, classNameLocalService.getClassNameId(DDMFormInstance.class)); <line8> document.addKeyword(Field.CLASS_PK, ddmFormInstance.getFormInstanceId()); <line9> document.addKeyword(Field.CLASS_TYPE_ID, ddmFormInstanceRecordVersion.getFormInstanceId()); <line10> document.addKeyword(Field.RELATED_ENTRY, true); <line11> document.addKeyword(Field.STATUS, ddmFormInstanceRecordVersion.getStatus()); <line12> document.addKeyword(Field.VERSION, ddmFormInstanceRecordVersion.getVersion()); <line13> document.addKeyword(""formInstanceId"", ddmFormInstance.getFormInstanceId()); <line14> DDMStructure ddmStructure = ddmFormInstance.getStructure(); <line15> DDMFormValues ddmFormValues = ddmFormInstanceRecordVersion.getDDMFormValues(); <line16> addContent(ddmFormInstanceRecordVersion, ddmFormValues, document); <line17> ddmIndexer.addAttributes(document, ddmStructure, ddmFormValues); <line18> } catch (Exception exception) { <line19> if (_log.isDebugEnabled()) { <line20> } <line21> } <line22> } <line23> } <line24> "	 <line19>	No
public class A { <line0> public void attachDirty(MbGefaehrskat instance) { <line1> try { <line2> sessionFactory.getCurrentSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> protected DfSqlFileRunner getSqlFileRunner4TakeFinally(final DfRunnerInformation runInfo) { <line1> final DfReplaceSchemaProperties prop = getReplaceSchemaProperties(); <line2> final DfSqlFileRunnerExecute runnerExecute = <line3> new DfSqlFileRunnerExecute(runInfo, _dataSource) { <line4> @Override <line5> protected String filterSql(String sql) { <line6> sql = super.filterSql(sql); <line7> sql = prop.resolveFilterVariablesIfNeeds(sql); <line8> return sql; <line9> } <line10>  <line11> @Override <line12> protected boolean isHandlingCommentOnLineSeparator() { <line13> return true; <line14> } <line15>  <line16> @Override <line17> protected boolean isDbCommentLine(String line) { <line18> final boolean commentLine = super.isDbCommentLine(line); <line19> if (commentLine) { <line20> return commentLine; <line21> } <line22> return isDbCommentLineForIrregularPattern(line); <line23> } <line24>  <line25> @Override <line26> protected String getTerminator4Tool() { <line27> return resolveTerminator4Tool(); <line28> } <line29>  <line30> @Override <line31> protected boolean isTargetFile(String sql) { <line32> return getReplaceSchemaProperties().isTargetRepsFile(sql); <line33> } <line34> }; <line35> final String loadType = getReplaceSchemaProperties().getRepsEnvType(); <line36> final DfDataAssertProvider dataAssertProvider = new DfDataAssertProvider(loadType); <line37> runnerExecute.setDispatcher( <line38> new DfSqlFileRunnerDispatcher() { <line39> public DfRunnerDispatchResult dispatch(File sqlFile, Statement st, String sql) <line40> throws SQLException { <line41> final DfDataAssertHandler dataAssertHandler = <line42> dataAssertProvider.provideDataAssertHandler(sql); <line43> if (dataAssertHandler == null) { <line44> if (_skipIfNonAssetionSql) { <line45> return DfRunnerDispatchResult.SKIPPED; <line46> } else if (_restrictIfNonAssetionSql) { <line47> throwTakeFinallyNonAssertionSqlFoundException(sqlFile, sql); <line48> } else { <line49> return DfRunnerDispatchResult.NONE; <line50> } <line51> } <line52> try { <line53> dataAssertHandler.handle(sqlFile, st, sql); <line54> } catch (DfTakeFinallyAssertionFailureException e) { <line55> handleAssertionFailureException(e); <line56> } <line57> return DfRunnerDispatchResult.DISPATCHED; <line58> } <line59> }); <line60> return runnerExecute; <line61> } <line62> } <line63> 	 <line45>	Yes
"public class A { <line0> @Override <line1> @PutMapping(CommonConstants.PATH_ID) <line2> @Secured(ServicesData.ROLE_UPDATE_USERS) <line3> public UserDto update( <line4> final @PathVariable(""id"") String id, final @Valid @RequestBody UserDto dto) { <line5> SanityChecker.check(id); <line6> Assert.isTrue( <line7> StringUtils.equals(id, dto.getId()), <line8> ""Unable to update user : the DTO id must match the path id""); <line9> return userExternalService.update(dto); <line10> } <line11> } <line12> "	 <line6>	No
"public class A { <line0> private AuthenticationToken runWithPrincipal( <line1> String serverPrincipal, byte[] clientToken, Base64 base64, HttpServletResponse response) <line2> throws IOException, GSSException { <line3> GSSContext gssContext = null; <line4> GSSCredential gssCreds = null; <line5> AuthenticationToken token = null; <line6> try { <line7> gssCreds = <line8> this.gssManager.createCredential( <line9> this.gssManager.createName(serverPrincipal, KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID), <line10> GSSCredential.INDEFINITE_LIFETIME, <line11> new Oid[] {KerberosUtil.GSS_SPNEGO_MECH_OID, KerberosUtil.GSS_KRB5_MECH_OID}, <line12> GSSCredential.ACCEPT_ONLY); <line13> gssContext = this.gssManager.createContext(gssCreds); <line14> byte[] serverToken = gssContext.acceptSecContext(clientToken, 0, clientToken.length); <line15> if (serverToken != null && serverToken.length > 0) { <line16> String authenticate = base64.encodeToString(serverToken); <line17> response.setHeader( <line18> KerberosAuthenticator.WWW_AUTHENTICATE, <line19> KerberosAuthenticator.NEGOTIATE + "" "" + authenticate); <line20> } <line21> if (!gssContext.isEstablished()) { <line22> response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); <line23> } else { <line24> String clientPrincipal = gssContext.getSrcName().toString(); <line25> KerberosName kerberosName = new KerberosName(clientPrincipal); <line26> String userName = kerberosName.getShortName(); <line27> token = new AuthenticationToken(userName, clientPrincipal, TYPE); <line28> response.setStatus(HttpServletResponse.SC_OK); <line29> } <line30> } finally { <line31> if (gssContext != null) { <line32> gssContext.dispose(); <line33> } <line34> if (gssCreds != null) { <line35> gssCreds.dispose(); <line36> } <line37> } <line38> return token; <line39> } <line40> } <line41> "	 <line32>	No
"public class A { <line0> public Date rescheduleJob(Long scheduleJobId) throws Exception { <line1> ScheduleJob scheduleJob = this.schedulerService.loadScheduleJob(scheduleJobId); <line2> if (scheduleJob == null) { <line3> return null; <line4> } <line5> Date nextDate; <line6> CronTrigger trigger = <line7> (CronTrigger) <line8> this.scheduler.getTrigger( <line9> triggerKey(scheduleJob.getTriggerName(), scheduleJob.getGroupn())); <line10> if (null == trigger) { <line11> throw new CoreException(""trigger not exist:scheduleJobId="" + scheduleJobId); <line12> } else { <line13> TriggerKey key = trigger.getKey(); <line14> trigger = <line15> newTrigger().withIdentity(key).withSchedule(cronSchedule(scheduleJob.getCron())).build(); <line16> nextDate = this.scheduler.rescheduleJob(key, trigger); <line17> } <line18> if (scheduleJob.getStatus() != BCConstants.STATUS_ENABLED) { <line19> scheduleJob.setStatus(BCConstants.STATUS_ENABLED); <line20> this.schedulerService.saveScheduleJob(scheduleJob); <line21> } <line22> return nextDate; <line23> } <line24> } <line25> "	 <line3>	Yes
"public class A { <line0> @Test <line1> public void test_02() { <line2> String genome = ""testHg3775Chr22""; <line3> String args[] = {genome}; <line4> SnpEffCmdEff snpeff = new SnpEffCmdEff(); <line5> snpeff.parseArgs(args); <line6> snpeff.setDebug(debug); <line7> snpeff.setVerbose(verbose); <line8> snpeff.setSupressOutput(!verbose); <line9> snpeff.load(); <line10> GenomicSequences genomicSequences = snpeff.getConfig().getGenome().getGenomicSequences(); <line11> genomicSequences.setDisableLoad(true); <line12> int i = 1; <line13> for (Gene g : snpeff.getConfig().getGenome().getGenes()) { <line14> for (Transcript tr : g) { <line15> for (Exon ex : tr) { <line16> Gpr.showMark(i++, 100); <line17> String seq = genomicSequences.querySequence(ex); <line18> if (verbose) <line19> Assert.assertNotNull(seq == null); <line20> Assert.assertEquals(seq, ex.getSequence()); <line21> } <line22> } <line23> } <line24> System.err.println(""\n""); <line25> } <line26> } <line27> "	 <line2>	Yes
public class A { <line0> private static <S extends Service> void stop(S s) { <line1> try { <line2> s.stop(); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	 <line5>	No
public class A { <line0> @Override <line1> public void run() { <line2> HConnectionManager.deleteAllConnections(); <line3> try { <line4> ZooKeeperUtils.closeAllZooKeeperConnections(); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
"public class A { <line0> public void format() throws IOException { <line1> URI location = getLocation(); <line2> if (mUfs.isDirectory(location.toString())) { <line3> for (UfsStatus status : mUfs.listStatus(location.toString())) { <line4> String childPath = URIUtils.appendPathOrDie(location, status.getName()).toString(); <line5> if (status.isDirectory() <line6> && !mUfs.deleteDirectory(childPath, DeleteOptions.defaults().setRecursive(true)) <line7> || status.isFile() && !mUfs.deleteFile(childPath)) { <line8> throw new IOException(String.format(""Failed to delete %s"", childPath)); <line9> } <line10> } <line11> } else if (!mUfs.mkdirs(location.toString())) { <line12> throw new IOException(String.format(""Failed to create %s"", location)); <line13> } <line14> UnderFileSystemUtils.touch( <line15> mUfs, <line16> URIUtils.appendPathOrDie( <line17> location, <line18> ServerConfiguration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX) <line19> + System.currentTimeMillis()) <line20> .toString()); <line21> } <line22> } <line23> "	 <line2>	Yes
public class A { <line0> public void process(Packet packet) throws ComponentException { <line1> String to = packet.getTo().toString(); <line2> String uniqueId = packet.getID(); <line3> if (null == packet.getID()) { <line4> uniqueId = generateUniqueId(packet); <line5> packet.setID(uniqueId); <line6> } <line7> if (true == performIdMapping(packet)) { <line8> uniqueId = generateUniqueId(packet); <line9> idMap.put(uniqueId, packet.getID()); <line10> packet.setID(uniqueId); <line11> } <line12> sentRemotePackets.put(uniqueId, packet.getFrom()); <line13> try { <line14> extractNodeDetails(packet); <line15> if (discoveredServers.containsKey(to)) { <line16> packet.setTo(new JID(discoveredServers.get(to))); <line17> sendPacket(packet.createCopy()); <line18> return; <line19> } <line20> if (!remoteChannelDiscoveryStatus.containsKey(to)) { <line21> discoverRemoteChannelServer(to, packet.getID()); <line22> } else if (remoteChannelDiscoveryStatus.get(to).equals(NO_CHANNEL_SERVER)) { <line23> IQ reply = IQ.createResultIQ((IQ) packet); <line24> reply.setFrom(this.localServer); <line25> reply.setError( <line26> new PacketError( <line27> PacketError.Condition.remote_server_not_found, PacketError.Type.cancel)); <line28> component.sendPacket(reply); <line29> return; <line30> } <line31> if (!waitingStanzas.containsKey(to)) { <line32> waitingStanzas.put(to, new ArrayList<Packet>()); <line33> } <line34> waitingStanzas.get(to).add(packet); <line35> attemptDnsDiscovery(to); <line36> } catch (Exception e) { <line37> } <line38> } <line39> } <line40> 	 <line35>	Yes
public class A { <line0> private void parseCertificatesListLength(CertificateMessage msg) { <line1> msg.setCertificatesListLength(parseIntField(HandshakeByteLength.CERTIFICATES_LENGTH)); <line2> } <line3> } <line4> 	 <line1>	No
public class A { <line0> public static EncryptionCipher getEncryptionCipher( <line1> CipherSuite cipherSuite, ConnectionEndType connectionEndType, KeySet keySet) { <line2> CipherAlgorithm cipherAlg = AlgorithmResolver.getCipher(cipherSuite); <line3> if (cipherAlg == CipherAlgorithm.GOST_28147_CNT) { <line4> return new GOST28147Cipher( <line5> GOSTUtils.getGostSpec(cipherSuite), <line6> keySet.getWriteKey(connectionEndType), <line7> keySet.getWriteIv(connectionEndType)); <line8> } else if (cipherAlg == CipherAlgorithm.ChaCha20Poly1305) { <line9> return new ChaCha20Poly1305Cipher(keySet.getWriteKey(connectionEndType)); <line10> } else if (cipherAlg.getJavaName() != null) { <line11> return new JavaCipher(cipherAlg, keySet.getWriteKey(connectionEndType)); <line12> } else if (cipherAlg == CipherAlgorithm.NULL) { <line13> return new NullCipher(); <line14> } else { <line15> return new NullCipher(); <line16> } <line17> } <line18> } <line19> 	 <line1>	No
"public class A { <line0> @Override <line1> public void onWebSocketText(String data) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> Object event = javaScript.evaluate(""event"", ""({data:'"" + data + ""'})""); <line5> javaScript.invoke(false, jsWebSocket, ""onmessage"", event); <line6> } <line7> } <line8> "	 <line3>	Yes
public class A { <line0> protected Result greedyPvalue(Result prevResult, int minGeneSetSize, int maxGeneSetSize) { <line1> Apfloat pValue = Apfloat.ONE; <line2> int geneSetCount = 0; <line3> HashSet<GeneSet> genesetSet = new HashSet<GeneSet>(); <line4> if (prevResult.getGeneSets() != null) genesetSet.addAll(prevResult.getGeneSets()); <line5> start = new Date(); <line6> latest = new Date(); <line7> Result best = new Result(prevResult); <line8> best.setPvalue(1.0); <line9> for (GeneSet geneSet : geneSets) { <line10> if ((geneSet.getGeneCount() > 0) <line11> && ((genesetSet == null) || (!genesetSet.contains(geneSet))) <line12> && (geneSet.getGeneCount() >= minGeneSetSize) <line13> && (geneSet.getGeneCount() <= maxGeneSetSize)) { <line14> List<GeneSet> geneSetListNew = new LinkedList<GeneSet>(); <line15> if (genesetSet != null) geneSetListNew.addAll(genesetSet); <line16> geneSetListNew.add(geneSet); <line17> pValue = pValue(geneSetListNew); <line18> if ((pValue.compareTo(Apfloat.ZERO) > 0) && (pValue.compareTo(best.getPvalue()) < 0)) <line19> best.set(geneSetListNew, pValue); <line20> showProgress(geneSetListNew, pValue, best); <line21> geneSetCount++; <line22> } <line23> } <line24> best.addGeneSetCount(geneSetCount); <line25> return best; <line26> } <line27> } <line28> 	 <line23>	No
public class A { <line0> public byte[] run() throws SaslException { <line1> return saslClient.evaluateChallenge(saslToken); <line2> } <line3> } <line4> 	 <line2>	No
"public class A { <line0> public String runSSMDocument( <line1> String documentName, String targetEc2InstanceId, Map<String, List<String>> commandParameters) <line2> throws S3SyncFileSystemDownloader.CannotLaunchCommandException { <line3> SsmClient client = clientFactory.get(); <line4> final String migrationS3BucketName; <line5> try { <line6> migrationS3BucketName = migrationHelperDeploymentService.getMigrationS3BucketName(); <line7> } catch (InfrastructureDeploymentError infrastructureDeploymentError) { <line8> throw new S3SyncFileSystemDownloader.CannotLaunchCommandException( <line9> ""cannot get migration bucket for publishing SSM command logs"", <line10> infrastructureDeploymentError); <line11> } <line12> SendCommandRequest request = <line13> SendCommandRequest.builder() <line14> .documentName(documentName) <line15> .documentVersion(""$LATEST"") <line16> .instanceIds(targetEc2InstanceId) <line17> .parameters(commandParameters) <line18> .timeoutSeconds(600) <line19> .comment(""Command run by Jira DC Migration Assistant"") <line20> .outputS3BucketName(migrationS3BucketName) <line21> .outputS3KeyPrefix(ssmS3KeyPrefix) <line22> .build(); <line23> SendCommandResponse response = client.sendCommand(request); <line24> return response.command().commandId(); <line25> } <line26> } <line27> "	 <line3>	Yes
"public class A { <line0> public static java.util.List<com.liferay.social.kernel.model.SocialActivity> getGroupActivities( <line1> HttpPrincipal httpPrincipal, long groupId, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SocialActivityServiceUtil.class, <line7> ""getGroupActivities"", <line8> _getGroupActivitiesParameterTypes10); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, start, end); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (java.util.List<com.liferay.social.kernel.model.SocialActivity>) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	 <line21>	Yes
public class A { <line0> @Override <line1> protected void finalize() throws Throwable { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> public SegmentsExperiment remove(Serializable primaryKey) throws NoSuchExperimentException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> SegmentsExperiment segmentsExperiment = <line6> (SegmentsExperiment) session.get(SegmentsExperimentImpl.class, primaryKey); <line7> if (segmentsExperiment == null) { <line8> if (_log.isDebugEnabled()) { <line9> } <line10> throw new NoSuchExperimentException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line11> } <line12> return remove(segmentsExperiment); <line13> } catch (NoSuchExperimentException noSuchEntityException) { <line14> throw noSuchEntityException; <line15> } catch (Exception exception) { <line16> throw processException(exception); <line17> } finally { <line18> closeSession(session); <line19> } <line20> } <line21> } <line22> 	 <line9>	Yes
"public class A { <line0> private void initializeServantsFromProperties(Properties ejbServants) throws ResourceException { <line1> deregisterServants(bus); <line2> try { <line3> Enumeration<?> keys = ejbServants.keys(); <line4> while (keys.hasMoreElements()) { <line5> String theJNDIName = (String) keys.nextElement(); <line6> String value = (String) ejbServants.get(theJNDIName); <line7> EJBServantConfig config = new EJBServantConfig(theJNDIName, value); <line8> EJBEndpoint ejbEndpoint = new EJBEndpoint(config); <line9> ejbEndpoint.setEjbServantBaseURL(mcf.getEJBServantBaseURL()); <line10> ejbEndpoint.setWorkManager(getWorkManager()); <line11> Server servant = ejbEndpoint.publish(); <line12> synchronized (servantsCache) { <line13> if (servant != null) { <line14> servantsCache.add(servant); <line15> } <line16> } <line17> } <line18> } catch (Exception e) { <line19> e.printStackTrace(); <line20> throw new ResourceException(new Message(""FAIL_TO_START_EJB_SERVANTS"", BUNDLE).toString(), e); <line21> } <line22> } <line23> } <line24> "	 <line6>	No
public class A { <line0> public static int countSubscriptionCommerceOrderItems(long commerceOrderId) <line1> throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommerceOrderItemServiceUtil.countSubscriptionCommerceOrderItems(commerceOrderId); <line5> return returnValue; <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> protected boolean validateExpiration(SignedJWT jwtToken) { <line1> boolean valid = false; <line2> try { <line3> Date expires = jwtToken.getJWTClaimsSet().getExpirationTime(); <line4> if (expires == null || new Date().before(expires)) { <line5> if (LOGGER.isDebugEnabled()) { <line6> } <line7> valid = true; <line8> } else { <line9> } <line10> } catch (ParseException pe) { <line11> } <line12> return valid; <line13> } <line14> } <line15> 	 <line9>	Yes
public class A { <line0> @Override <line1> public void execute() { <line2> try { <line3> if (attributesChanged) { <line4> listener.attributeChanged(attributes); <line5> return; <line6> } <line7> if (backdate) listener.pointBackdated(newValue); <line8> else if (updated) { <line9> listener.pointUpdated(newValue); <line10> if (!PointValueTime.equalValues(oldValue, newValue)) <line11> listener.pointChanged(oldValue, newValue); <line12> if (set) listener.pointSet(oldValue, newValue); <line13> } <line14> if (logged) listener.pointLogged(newValue); <line15> } catch (ExceptionListWrapper e) { <line16> } <line17> } <line18> } <line19> 	 <line2>	No
public class A { <line0> private void moveDirectory(String source, String target) { <line1> if (target.contains(ProtocolType.DIR_URI.getSchema())) { <line2> target = target.substring(target.indexOf(File.separator)); <line3> } <line4> Path sourcePath = Paths.get(source); <line5> Path destinationPath = Paths.get(target); <line6> try { <line7> Files.move( <line8> sourcePath, <line9> destinationPath, <line10> StandardCopyOption.ATOMIC_MOVE, <line11> StandardCopyOption.REPLACE_EXISTING); <line12> } catch (AtomicMoveNotSupportedException e) { <line13> try { <line14> Files.move(sourcePath, destinationPath); <line15> } catch (IOException e1) { <line16> } <line17> } catch (FileSystemException fse) { <line18> deleteDestinationAndMoveFolder(sourcePath, destinationPath); <line19> } catch (Exception e) { <line20> } <line21> } <line22> } <line23> 	 <line22>	No
public class A { <line0> private void updateConnectorTasks(String connName) { <line1> if (!worker.isRunning(connName)) { <line2> return; <line3> } <line4> List<Map<String, String>> newTaskConfigs = recomputeTaskConfigs(connName); <line5> List<Map<String, String>> oldTaskConfigs = configState.allTaskConfigs(connName); <line6> if (!newTaskConfigs.equals(oldTaskConfigs)) { <line7> removeConnectorTasks(connName); <line8> List<Map<String, String>> rawTaskConfigs = <line9> reverseTransform(connName, configState, newTaskConfigs); <line10> configBackingStore.putTaskConfigs(connName, rawTaskConfigs); <line11> createConnectorTasks(connName, configState.targetState(connName)); <line12> } <line13> } <line14> } <line15> 	 <line2>	Yes
"public class A { <line0> void doActualLog( <line1> final org.gradle.api.logging.Logger log, <line2> final Level level, <line3> final String message, <line4> final Throwable thrown) { <line5> StringBuilder buffer = new StringBuilder(); <line6> buffer.append(""["").append(name).append(""]"").append("" "").append(message); <line7> if (thrown != null) { <line8> switch (level) { <line9> case FATAL: <line10> case ERROR: <line11> break; <line12> case WARN: <line13> break; <line14> case INFO: <line15> break; <line16> default: <line17> break; <line18> } <line19> } else { <line20> switch (level) { <line21> case FATAL: <line22> case ERROR: <line23> break; <line24> case WARN: <line25> break; <line26> case INFO: <line27> break; <line28> default: <line29> break; <line30> } <line31> } <line32> } <line33> } <line34> "	 <line33>	No
public class A { <line0> public void run() { <line1> do { <line2> try { <line3> if (isPropertiesFileModified()) { <line4> initializeServantsFromProperties(loadProperties(propsFile.toURI().toURL())); <line5> } <line6> Thread.sleep(pollIntervalSeconds * 1000L); <line7> } catch (Exception e) { <line8> } <line9> } while (continuing); <line10> } <line11> } <line12> 	 <line4>	Yes
"public class A { <line0> @Test <line1> public void errorDuringRun() throws Exception { <line2> BasicTask<Void> t = <line3> new BasicTask<Void>( <line4> new Callable<Void>() { <line5> public Void call() throws Exception { <line6> throw new IllegalStateException(""Simulating failure in errorDuringRun""); <line7> } <line8> }); <line9> em.submit(MutableMap.of(""tag"", ""A""), t); <line10> try { <line11> t.get(); <line12> fail(""get should have failed due to error""); <line13> } catch (Exception eo) { <line14> Throwable e = Throwables.getRootCause(eo); <line15> assertEquals(""Simulating failure in errorDuringRun"", e.getMessage()); <line16> } <line17> assertFalse(t.isCancelled()); <line18> assertTrue(t.isError()); <line19> assertTrue(t.isDone()); <line20> assertTrue( <line21> t.getStatusDetail(false).contains(""Simulating failure in errorDuringRun""), <line22> ""details="" + t.getStatusDetail(false)); <line23> } <line24> } <line25> "	 <line11>	No
"public class A { <line0> private void loadStoppableInstance() { <line1> try { <line2> Method getInstanceMethod = <line3> injectorClassInstance.getClass().getMethod(""getInstance"", Class.class); <line4> Class stoppableClass = <line5> deploymentUnitClassLoader.loadClass(""com.flipkart.flux.client.runtime.Stoppable""); <line6> stoppableInstance = getInstanceMethod.invoke(injectorClassInstance, stoppableClass); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> "	 <line8>	Yes
"public class A { <line0> public static void deleteInterpretIfExist( <line1> String hdfsSiteConfig, <line2> String coreSiteConfig, <line3> String basePath, <line4> String datasetId, <line5> Integer attempt, <line6> Set<String> steps) { <line7> if (steps != null && !steps.isEmpty()) { <line8> String path = String.join(""/"", basePath, datasetId, attempt.toString(), DIRECTORY_NAME); <line9> if (steps.contains(ALL.name())) { <line10> boolean isDeleted = deleteIfExist(hdfsSiteConfig, coreSiteConfig, path); <line11> } else { <line12> for (String step : steps) { <line13> boolean isDeleted = <line14> deleteIfExist( <line15> hdfsSiteConfig, coreSiteConfig, String.join(""/"", path, step.toLowerCase())); <line16> } <line17> } <line18> } <line19> } <line20> } <line21> "	 <line4>	No
public class A { <line0> protected void checkResponseEntity(Response response) { <line1> if (!response.hasEntity()) { <line2> } <line3> } <line4> } <line5> 	 <line3>	No
public class A { <line0> private X509Certificate[] getCertificateLocaly(CryptoType cryptoType) { <line1> if (fallbackCrypto == null) { <line2> return null; <line3> } <line4> X509Certificate[] localCerts = null; <line5> try { <line6> localCerts = fallbackCrypto.getX509Certificates(cryptoType); <line7> } catch (Exception e) { <line8> } <line9> if (localCerts == null && cryptoType.getType() == CryptoType.TYPE.ALIAS) { <line10> CryptoType newCryptoType = new CryptoType(CryptoType.TYPE.SUBJECT_DN); <line11> newCryptoType.setSubjectDN(cryptoType.getAlias()); <line12> try { <line13> localCerts = fallbackCrypto.getX509Certificates(newCryptoType); <line14> } catch (Exception e) { <line15> } <line16> } <line17> return localCerts; <line18> } <line19> } <line20> 	 <line19>	No
public class A { <line0> @Override <line1> public void accept(Range t, Long u) { <line2> if (t.getLower() == -4.0) { <line3> Assert.assertEquals(2, u, 0.0); <line4> } <line5> if (t.getLower() == 0.0) { <line6> Assert.assertEquals(1, u, 0.0); <line7> } <line8> if (t.getLower() == 4.0) { <line9> Assert.assertEquals(2, u, 0.0); <line10> } <line11> } <line12> } <line13> 	 <line6>	No
"public class A { <line0> public IndexSchema getIndexSchema() { <line1> if (context instanceof SolrMorphlineContext) { <line2> IndexSchema schema = ((SolrMorphlineContext) context).getIndexSchema(); <line3> if (schema != null) { <line4> validateSchema(schema); <line5> return schema; <line6> } <line7> } <line8> File downloadedSolrHomeDir = null; <line9> try { <line10> String mySolrHomeDir = solrHomeDir; <line11> if (solrHomeDir == null || solrHomeDir.length() == 0) { <line12> if (zkHost == null || zkHost.length() == 0) { <line13> throw new MorphlineCompilationException( <line14> ""Downloading a Solr schema requires either parameter 'solrHomeDir' or parameters"" <line15> + "" 'zkHost' and 'collection'"", <line16> config); <line17> } <line18> if (collectionName == null || collectionName.length() == 0) { <line19> throw new MorphlineCompilationException( <line20> ""Parameter 'zkHost' requires that you also pass parameter 'collection'"", config); <line21> } <line22> ZooKeeperDownloader zki = new ZooKeeperDownloader(); <line23> SolrZkClient zkClient = <line24> zki.getZkClient(zkHost, zkClientSessionTimeout, zkClientConnectTimeout); <line25> try { <line26> String configName = zki.readConfigName(zkClient, collectionName); <line27> downloadedSolrHomeDir = Files.createTempDir(); <line28> downloadedSolrHomeDir = <line29> zki.downloadConfigDir(zkClient, configName, downloadedSolrHomeDir); <line30> mySolrHomeDir = downloadedSolrHomeDir.getAbsolutePath(); <line31> } catch (KeeperException e) { <line32> throw new MorphlineCompilationException( <line33> ""Cannot download schema.xml from ZooKeeper"", config, e); <line34> } catch (InterruptedException e) { <line35> throw new MorphlineCompilationException( <line36> ""Cannot download schema.xml from ZooKeeper"", config, e); <line37> } catch (IOException e) { <line38> throw new MorphlineCompilationException( <line39> ""Cannot download schema.xml from ZooKeeper"", config, e); <line40> } finally { <line41> zkClient.close(); <line42> } <line43> } <line44> try { <line45> SolrResourceLoader loader = new SolrResourceLoader(Paths.get(mySolrHomeDir)); <line46> SolrConfig solrConfig = new SolrConfig(loader, ""solrconfig.xml"", null); <line47> PluginInfo info = solrConfig.getPluginInfo(IndexSchemaFactory.class.getName()); <line48> IndexSchemaFactory factory = null; <line49> if (null != info) { <line50> factory = <line51> solrConfig.getResourceLoader().newInstance(info.className, IndexSchemaFactory.class); <line52> factory.init(info.initArgs); <line53> } <line54> String resourceName; <line55> if (factory != null && factory instanceof ManagedIndexSchemaFactory) { <line56> resourceName = ((ManagedIndexSchemaFactory) factory).getManagedSchemaResourceName(); <line57> } else { <line58> resourceName = IndexSchemaFactory.getResourceNameToBeUsed(null, solrConfig); <line59> } <line60> IndexSchema schema = IndexSchemaFactory.buildIndexSchema(resourceName, solrConfig); <line61> validateSchema(schema); <line62> return schema; <line63> } catch (ParserConfigurationException | IOException | SAXException e) { <line64> throw new MorphlineRuntimeException(e); <line65> } <line66> } finally { <line67> if (downloadedSolrHomeDir != null) { <line68> try { <line69> FileUtils.deleteDirectory(downloadedSolrHomeDir); <line70> } catch (IOException e) { <line71> } <line72> } <line73> } <line74> } <line75> } <line76> "	 <line44>	Yes
"public class A { <line0> public S3ObjectSummary getLatestBuildArtifact(String bucket, String key, Pattern pattern) { <line1> if (pattern == null) { <line2> throw new RuntimeException(""pattern is null!""); <line3> } <line4> S3ObjectSummary latestBuild = null; <line5> ObjectListing objBuilds = s3client.listObjects(bucket, key); <line6> int i = 0; <line7> int limit = 100; <line8> do { <line9> for (S3ObjectSummary obj : objBuilds.getObjectSummaries()) { <line10> Matcher matcher = pattern.matcher(obj.getKey()); <line11> if (matcher.find()) { <line12> if (latestBuild == null) { <line13> latestBuild = obj; <line14> } <line15> if (obj.getLastModified().after(latestBuild.getLastModified())) { <line16> latestBuild = obj; <line17> } <line18> } <line19> } <line20> objBuilds = s3client.listNextBatchOfObjects(objBuilds); <line21> } while (objBuilds.isTruncated() && ++i < limit); <line22> if (latestBuild == null) { <line23> } else { <line24> } <line25> return latestBuild; <line26> } <line27> } <line28> "	 <line10>	Yes
"public class A { <line0> void cleanUpCheckpoints() { <line1> Set<String> keep = newHashSet(); <line2> String cp = indexStats.getReferenceCheckpoint(); <line3> if (cp == null) { <line4> return; <line5> } <line6> keep.add(cp); <line7> keep.addAll(indexStats.tempCps); <line8> Map<String, String> info = store.checkpointInfo(cp); <line9> String value = info.get(""created""); <line10> if (value != null) { <line11> long current = ISO8601.parse(value).getTimeInMillis(); <line12> for (String checkpoint : store.checkpoints()) { <line13> info = store.checkpointInfo(checkpoint); <line14> String creator = info.get(""creator""); <line15> String created = info.get(""created""); <line16> String name = info.get(""name""); <line17> if (!keep.contains(checkpoint) <line18> && this.name.equals(name) <line19> && AsyncIndexUpdate.class.getSimpleName().equals(creator) <line20> && (created == null <line21> || ISO8601.parse(created).getTimeInMillis() + leaseTimeOut < current)) { <line22> if (store.release(checkpoint)) { <line23> } <line24> } <line25> } <line26> } else { <line27> } <line28> } <line29> } <line30> "	 <line8>	Yes
public class A { <line0> @Override <line1> public void doAuthenticationInformationRequestEvent( <line2> ServerS6aSession appSession, JAuthenticationInformationRequest request) <line3> throws InternalException, IllegalDiameterStateException, RouteException, OverloadException { <line4> } <line5> } <line6> 	 <line2>	No
public class A { <line0> private void openFolder(File file) { <line1> if (myCommand == null) { <line2> return; <line3> } <line4> try { <line5> ProcessBuilder pb = new ProcessBuilder(myCommand, file.getCanonicalPath()); <line6> if (myWorkingDirectory != null) { <line7> pb.directory(new File(myWorkingDirectory)); <line8> } <line9> pb.start(); <line10> } catch (final IOException e1) { <line11> } <line12> } <line13> } <line14> 	 <line8>	No
"public class A { <line0> public Credentials repeat(final PasswordCallback callback) { <line1> final long timeout = preferences.getLong(""brick.pairing.interrupt.ms""); <line2> final long start = System.currentTimeMillis(); <line3> scheduler.repeat( <line4> () -> { <line5> try { <line6> if (System.currentTimeMillis() - start > timeout) { <line7> throw new ConnectionCanceledException( <line8> String.format(""Interrupt polling for pairing key after %d"", timeout)); <line9> } <line10> this.operate(callback); <line11> } catch (ConnectionCanceledException e) { <line12> callback.close(null); <line13> this.shutdown(); <line14> } catch (BackgroundException e) { <line15> callback.close(null); <line16> this.shutdown(); <line17> } <line18> }, <line19> preferences.getLong(""brick.pairing.interval.ms""), <line20> TimeUnit.MILLISECONDS); <line21> return null; <line22> } <line23> } <line24> "	 <line12>	Yes
public class A { <line0> @Override <line1> public void init( <line2> final NetSocket socket, final ProtonConnection protonConnection, final Transport transport) { <line3> this.protonConnection = protonConnection; <line4> this.sasl = transport.sasl(); <line5> sasl.server(); <line6> sasl.allowSkip(false); <line7> sasl.setMechanisms(getSupportedMechanisms()); <line8> if (socket.isSsl()) { <line9> sslSession = socket.sslSession(); <line10> } <line11> } <line12> } <line13> 	 <line3>	Yes
public class A { <line0> private StreamingOutput getStreamOutput( <line1> final DateTime timeBucket, final TimeBucket timeBucketGran, final MediaType mediaType) { <line2> return new StreamingOutput() { <line3> @Override <line4> public void write(OutputStream outputStream) { <line5> BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outputStream)); <line6> try { <line7> if (_eventRetriever == null) { <line8> throw APIException.internalServerErrors.noEventRetriever(); <line9> } <line10> _eventRetriever.getBulkEvents(timeBucket, timeBucketGran, mediaType, out); <line11> } catch (MarshallingExcetion e) { <line12> } catch (final Exception e) { <line13> throw APIException.internalServerErrors.eventRetrieverError(e.getMessage(), e); <line14> } finally { <line15> try { <line16> out.close(); <line17> } catch (IOException e) { <line18> } <line19> } <line20> } <line21> }; <line22> } <line23> } <line24> 	 <line18>	Yes
public class A { <line0> public MSchutzbedarfkateg merge(MSchutzbedarfkateg detachedInstance) { <line1> try { <line2> MSchutzbedarfkateg result = <line3> (MSchutzbedarfkateg) sessionFactory.getCurrentSession().merge(detachedInstance); <line4> return result; <line5> } catch (RuntimeException re) { <line6> throw re; <line7> } <line8> } <line9> } <line10> 	 <line4>	Yes
public class A { <line0> public static com.liferay.commerce.product.model.CommerceChannelSoap deleteCommerceChannel( <line1> long commerceChannelId) throws RemoteException { <line2> try { <line3> com.liferay.commerce.product.model.CommerceChannel returnValue = <line4> CommerceChannelServiceUtil.deleteCommerceChannel(commerceChannelId); <line5> return com.liferay.commerce.product.model.CommerceChannelSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> public void stop() { <line2> executor.shutdown(); <line3> thread.interrupt(); <line4> try { <line5> thread.join(3000); <line6> if (thread.isAlive()) { <line7> thread.stop(); <line8> } <line9> } catch (InterruptedException e) { <line10> } <line11> } <line12> } <line13> "	 <line1>	No
public class A { <line0> @Override <line1> public void eventOccurred(RetryingEvent eventArg) { <line2> } <line3> } <line4> 	 <line1>	No
"public class A { <line0> @Override <line1> public String reorderEligibilityTestQusAns( <line2> Integer eligibilityId, int oldOrderNumber, int newOrderNumber, Integer studyId) { <line3> logger.entry(""StudyServiceImpl - reorderEligibilityTestQusAns - Starts""); <line4> String message = FdahpStudyDesignerConstants.SUCCESS; <line5> try { <line6> message = <line7> studyDAO.reorderEligibilityTestQusAns( <line8> eligibilityId, oldOrderNumber, newOrderNumber, studyId); <line9> } catch (Exception e) { <line10> } <line11> logger.exit(""StudyServiceImpl - reorderEligibilityTestQusAns - Ends""); <line12> return message; <line13> } <line14> } <line15> "	 <line2>	No
"public class A { <line0> public String getParticipantId( <line1> String applicationId, <line2> String hashedTokenValue, <line3> String studyId, <line4> Float studyVersion, <line5> AuditLogEventRequest auditRequest) { <line6> logger.entry(""Begin getParticipantId()""); <line7> HttpHeaders headers = null; <line8> EnrollmentBodyProvider bodyProvider = null; <line9> HttpEntity<EnrollmentBodyProvider> requestBody = null; <line10> ResponseEntity<?> responseEntity = null; <line11> String participantId = """"; <line12> try { <line13> headers = new HttpHeaders(); <line14> headers.setContentType(MediaType.APPLICATION_JSON); <line15> headers.set(""Authorization"", ""Bearer "" + oAuthService.getAccessToken()); <line16> AuditEventMapper.addAuditEventHeaderParams(headers, auditRequest); <line17> bodyProvider = new EnrollmentBodyProvider(); <line18> bodyProvider.setTokenIdentifier(hashedTokenValue); <line19> bodyProvider.setCustomStudyId(studyId); <line20> bodyProvider.setStudyVersion(String.valueOf(studyVersion)); <line21> requestBody = new HttpEntity<>(bodyProvider, headers); <line22> responseEntity = <line23> restTemplate.postForEntity(appConfig.getAddParticipantId(), requestBody, String.class); <line24> if (responseEntity.getStatusCode() == HttpStatus.OK) { <line25> participantId = (String) responseEntity.getBody(); <line26> auditRequest.setParticipantId(participantId); <line27> enrollAuditEventHelper.logEvent(PARTICIPANT_ID_RECEIVED, auditRequest); <line28> } <line29> } catch (Exception e) { <line30> enrollAuditEventHelper.logEvent(PARTICIPANT_ID_NOT_RECEIVED, auditRequest); <line31> throw e; <line32> } <line33> logger.exit(""getParticipantId() - Ends ""); <line34> return participantId; <line35> } <line36> } <line37> "	 <line13>	No
public class A { <line0> private HttpClientRequest requestClient() { <line1> if (CollectionUtils.isNotEmpty(interceptors)) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> return new InterceptingHttpClientRequest(requestClient, interceptors.iterator()); <line5> } <line6> return requestClient; <line7> } <line8> } <line9> 	 <line3>	Yes
"public class A { <line0> void loadSpring() { <line1> try { <line2> SpringApplicationContext.getInstance() <line3> .initializeSpring(""classpath:provenance-application-context.xml""); <line4> } catch (BeansException | IllegalStateException e) { <line5> } <line6> } <line7> } <line8> "	 <line0>	No
public class A { <line0> private OrchestratorStore saveWithPriorityCheck(final OrchestratorStore orchestratorStore) { <line1> final System consumerSystem = orchestratorStore.getConsumerSystem(); <line2> final ServiceDefinition serviceDefinition = orchestratorStore.getServiceDefinition(); <line3> final ServiceInterface serviceInterface = orchestratorStore.getServiceInterface(); <line4> final int priority = orchestratorStore.getPriority(); <line5> final List<OrchestratorStore> orchestratorStoreList = <line6> orchestratorStoreRepository.findAllByConsumerSystemAndServiceDefinitionAndServiceInterface( <line7> consumerSystem, serviceDefinition, serviceInterface); <line8> if (orchestratorStoreList.isEmpty()) { <line9> orchestratorStore.setPriority(CoreCommonConstants.TOP_PRIORITY); <line10> return orchestratorStoreRepository.saveAndFlush(orchestratorStore); <line11> } else { <line12> final Map<Long, Integer> priorityMap = getPriorityMap(orchestratorStoreList); <line13> if (priorityMap.containsValue(priority)) { <line14> orchestratorStore.setPriority(priority); <line15> return insertOrchestratorStoreWithPriority( <line16> orchestratorStoreList, orchestratorStore, priority); <line17> } else { <line18> orchestratorStore.setPriority(orchestratorStoreList.size() + 1); <line19> return orchestratorStoreRepository.saveAndFlush(orchestratorStore); <line20> } <line21> } <line22> } <line23> } <line24> 	 <line5>	No
"public class A { <line0> public void login() throws ClientConnectionException { <line1> echoConfig(); <line2> String msg = new String(""Checking connection status... ""); <line3> if (isConnected()) { <line4> try { <line5> if (ftpClient.login(username, password)) { <line6> ftpClient.setFileType(FTP.BINARY_FILE_TYPE); <line7> } else { <line8> throw new ClientConnectionException(""Login was refused.""); <line9> } <line10> } catch (IOException e) { <line11> throw new ClientConnectionException(""IOException caught trying to login.""); <line12> } <line13> } else { <line14> throw new ClientConnectionException(""Tried to login with disconnected client!""); <line15> } <line16> } <line17> } <line18> "	 <line15>	No
"public class A { <line0> @Override <line1> public String description() { <line2> try { <line3> return this.delegate.description(); <line4> } catch (Exception e) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> } <line8> return """"; <line9> } <line10> } <line11> "	 <line9>	No
public class A { <line0> protected long await(long timeout) throws InterruptedException { <line1> completionLock.lock(); <line2> try { <line3> while (timeout > 0 && scheduledOrRunning.get() > 0) { <line4> timeout = completion.awaitNanos(timeout); <line5> } <line6> } finally { <line7> if (log.isTraceEnabled()) { <line8> } <line9> completionLock.unlock(); <line10> } <line11> return timeout; <line12> } <line13> } <line14> 	 <line12>	No
public class A { <line0> protected void onIdleExpired(TimeoutException timeout) { <line1> if (notifyIdleTimeout(this, timeout)) { <line2> reset(new ResetFrame(getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP); <line3> } <line4> } <line5> } <line6> 	 <line1>	Yes
"public class A { <line0> public static void main(String[] args) { <line1> ToolDependencies.wireDeployers(); <line2> List<String> wars = new ArrayList<>(); <line3> List<String> jars = new ArrayList<>(); <line4> for (String arg : args) { <line5> if (arg.endsWith("".war"")) { <line6> wars.add(arg); <line7> } else if (arg.endsWith("".jar"")) { <line8> jars.add(arg); <line9> } <line10> } <line11> try (HookDeployer hookDeployer = new HookDeployer(wars, jars)) { <line12> } catch (IOException ioException) { <line13> if (_log.isWarnEnabled()) { <line14> } <line15> } <line16> } <line17> } <line18> "	 <line0>	No
public class A { <line0> protected void handleChannelInactive(Channel channel) throws Exception { <line1> if (connected.compareAndSet(true, false) && !closed.get()) { <line2> listener.onTransportClosed(); <line3> } <line4> } <line5> } <line6> 	 <line4>	No
public class A { <line0> @Override <line1> public ListenableFuture<Void> closeServiceInstance() { <line2> try { <line3> renderer.close(); <line4> } catch (Exception e) { <line5> } <line6> return Futures.immediateFuture(null); <line7> } <line8> } <line9> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void initialize() { <line2> updateStatus(ThingStatus.UNKNOWN); <line3> PixometerMeterConfiguration config = getConfigAs(PixometerMeterConfiguration.class); <line4> setRessourceID(config.resourceId); <line5> cache = new ExpiringCache<>(Duration.ofMinutes(60), this::refreshCache); <line6> Bridge b = this.getBridge(); <line7> if (b == null) { <line8> updateStatus( <line9> ThingStatus.OFFLINE, <line10> ThingStatusDetail.CONFIGURATION_ERROR, <line11> ""Could not find bridge (pixometer config). Did you choose one?""); <line12> return; <line13> } <line14> obtainMeterId(); <line15> int pollingPeriod = <line16> Integer.parseInt(b.getConfiguration().get(CONFIG_BRIDGE_REFRESH).toString()); <line17> pollingJob = <line18> scheduler.scheduleWithFixedDelay( <line19> () -> { <line20> try { <line21> updateMeter(cache.getValue()); <line22> } catch (RuntimeException r) { <line23> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR); <line24> } <line25> }, <line26> 2, <line27> pollingPeriod, <line28> TimeUnit.MINUTES); <line29> } <line30> } <line31> "	 <line27>	No
public class A { <line0> public String getMimeType() { <line1> return mimeType; <line2> } <line3> } <line4> 	 <line3>	No
public class A { <line0> @Override <line1> public int getSupplementalCount(int year) { <line2> try { <line3> return calendarDao.getCalendarSupplementalCount(year); <line4> } catch (DataAccessException ex) { <line5> return 0; <line6> } <line7> } <line8> } <line9> 	 <line3>	No
public class A { <line0> protected void prepareScalarElement(PWDServerKeyExchangeMessage msg) { <line1> EllipticCurve curve = CurveFactory.getCurve(selectNamedGroup(msg)); <line2> PWDComputations.PWDKeyMaterial keyMaterial = <line3> PWDComputations.generateKeyMaterial( <line4> curve, msg.getComputations().getPasswordElement(), chooser); <line5> msg.getComputations().setPrivateKeyScalar(keyMaterial.privateKeyScalar); <line6> prepareScalar(msg, keyMaterial.scalar); <line7> prepareScalarLength(msg); <line8> prepareElement(msg, keyMaterial.element); <line9> prepareElementLength(msg); <line10> } <line11> } <line12> 	 <line6>	Yes
"public class A { <line0> private final void traverseFiles(File[] files, int operation, boolean stopOnError, int report) <line1> throws LowlevelStorageException { <line2> for (File element : files) { <line3> if (element.exists()) { <line4> if (element.isDirectory()) { <line5> traverseFiles(element.listFiles(), operation, stopOnError, report); <line6> } else { <line7> String filename = element.getName(); <line8> String path = null; <line9> try { <line10> path = element.getCanonicalPath(); <line11> } catch (IOException e) { <line12> if (report != NO_REPORT) { <line13> } <line14> if (stopOnError) { <line15> throw new LowlevelStorageException(true, ""couldn't get File path"", e); <line16> } <line17> } <line18> if (path != null) { <line19> String pid = PathAlgorithm.decode(filename); <line20> if (pid == null) { <line21> if (report != NO_REPORT) { <line22> } <line23> if (stopOnError) { <line24> throw new LowlevelStorageException( <line25> true, ""unexpected file traversing object store at ["" + path + ""]""); <line26> } <line27> } else { <line28> switch (operation) { <line29> case REPORT_FILES: <line30> { <line31> if (report == FULL_REPORT) { <line32> } <line33> break; <line34> } <line35> case REBUILD: <line36> { <line37> put(pid, path); <line38> if (report == FULL_REPORT) { <line39> } <line40> break; <line41> } <line42> case AUDIT_FILES: <line43> { <line44> String rpath = null; <line45> try { <line46> rpath = get(pid); <line47> } catch (LowlevelStorageException e) { <line48> } <line49> boolean matches = rpath.equals(path); <line50> if (report == FULL_REPORT || !matches) { <line51> } <line52> } <line53> } <line54> } <line55> } <line56> } <line57> } <line58> } <line59> } <line60> } <line61> "	 <line22>	Yes
"public class A { <line0> @Override <line1> protected void decode( <line2> ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) <line3> throws Exception { <line4> byteBuf.markReaderIndex(); <line5> StringBuilder sb = new StringBuilder(); <line6> for (int i = 1; i <= byteBuf.readableBytes(); i++) { <line7> sb.append(byteBuf.readByte()).append("", ""); <line8> } <line9> byteBuf.resetReaderIndex(); <line10> } <line11> } <line12> "	 <line10>	Yes
public class A { <line0> public final void setProperty(String key, String value) { <line1> properties.setProperty(BCC.check(key), value); <line2> } <line3> } <line4> 	 <line2>	No
public class A { <line0> public boolean initDevice( <line1> boolean enableAccelerometer, boolean enableGyroscope, boolean enableMagnetometer) { <line2> boolean result = false; <line3> try { <line4> if ((read(ACC_DEVICE, WHO_AM_I_XG) & 0x000000FF) == WHO_AM_I_AG_ID <line5> && (read(MAG_DEVICE, WHO_AM_I_M) & 0x000000FF) == WHO_AM_I_M_ID) { <line6> result = true; <line7> if (enableAccelerometer) { <line8> enableAccelerometer(); <line9> } else { <line10> disableAccelerometer(); <line11> } <line12> if (enableGyroscope) { <line13> enableGyroscope(); <line14> } else { <line15> disableGyroscope(); <line16> } <line17> if (enableMagnetometer) { <line18> enableMagnetometer(); <line19> } else { <line20> disableMagnetometer(); <line21> } <line22> } <line23> } catch (KuraException e) { <line24> } <line25> return result; <line26> } <line27> } <line28> 	 <line9>	No
public class A { <line0> private void log(String msg) { <line1> } <line2> } <line3> 	 <line2>	No
"public class A { <line0> private <T extends WithId<T>> void validateNoDuplicateName( <line1> final T entity, final String ignoreSelfId) { <line2> if (entity instanceof Connection) { <line3> Connection c = (Connection) entity; <line4> Set<String> ids = fetchIdsByPropertyValue(Connection.class, ""name"", c.getName()); <line5> if (ids != null) { <line6> ids.remove(ignoreSelfId); <line7> if (!ids.isEmpty()) { <line8> throw new EntityExistsException( <line9> ""There already exists a Connection with name "" + c.getName()); <line10> } <line11> } <line12> } <line13> } <line14> } <line15> "	 <line10>	No
public class A { <line0> private void handleConsoleStartup(InternalDistributedMember theId) { <line1> for (MembershipListener listener : allMembershipListeners) { <line2> listener.memberJoined(this, theId); <line3> } <line4> } <line5> } <line6> 	 <line4>	Yes
public class A { <line0> public void destroy() { <line1> super.destroy(); <line2> try { <line3> if (!reconnectFuture.isCancelled()) { <line4> reconnectFuture.cancel(true); <line5> } <line6> } catch (Throwable t) { <line7> } <line8> registryInvoker.destroy(); <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> @Test(timeout = 60000) <line1> public void testEmptyIndexPage() throws Exception { <line2> SyncThread syncThread = bs.get(0).getBookie().syncThread; <line3> assertNotNull(""Not found SyncThread."", syncThread); <line4> syncThread.suspendSync(); <line5> LedgerHandle lh1 = bkc.createLedger(1, 1, digestType, """".getBytes()); <line6> String dummyMsg = ""NoSuchLedger""; <line7> int numMsgs = 2 * pageSize / 8; <line8> LedgerHandle lh2 = bkc.createLedger(1, 1, digestType, """".getBytes()); <line9> for (int i = 0; i < numMsgs; i++) { <line10> lh2.addEntry(dummyMsg.getBytes()); <line11> } <line12> syncThread.resumeSync(); <line13> syncThread.requestFlush().get(); <line14> syncThread.suspendSync(); <line15> LedgerHandle newLh1 = bkc.openLedger(lh1.getId(), digestType, """".getBytes()); <line16> for (int i = 0; i < 3; i++) { <line17> lh2.addEntry(dummyMsg.getBytes()); <line18> } <line19> syncThread.resumeSync(); <line20> syncThread.requestFlush().get(); <line21> restartBookies(); <line22> numMsgs += 3; <line23> Enumeration<LedgerEntry> seq = lh2.readEntries(0, numMsgs - 1); <line24> assertTrue(""Enumeration of ledger entries has no element"", seq.hasMoreElements() == true); <line25> int entryId = 0; <line26> while (seq.hasMoreElements()) { <line27> LedgerEntry e = seq.nextElement(); <line28> assertEquals(entryId, e.getEntryId()); <line29> Assert.assertArrayEquals(dummyMsg.getBytes(), e.getEntry()); <line30> ++entryId; <line31> } <line32> assertEquals(entryId, numMsgs); <line33> } <line34> } <line35> "	 <line15>	No
public class A { <line0> @Override <line1> public String getVersion() { <line2> createTable(AbstractGeoWavePersistence.METADATA_TABLE, true, true); <line3> try { <line4> final Scanner scanner = createScanner(AbstractGeoWavePersistence.METADATA_TABLE); <line5> scanner.addScanIterator(new IteratorSetting(25, VersionIterator.class)); <line6> return StringUtils.stringFromBinary(scanner.iterator().next().getValue().get()); <line7> } catch (final TableNotFoundException e) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	 <line11>	No
"public class A { <line0> @Override <line1> public void perform() throws Exception { <line2> final Random random = new Random(); <line3> final BloomType[] bloomArray = BloomType.values(); <line4> final int bloomArraySize = bloomArray.length; <line5> modifyAllTableColumns( <line6> tableName, <line7> (columnName, columnBuilder) -> { <line8> BloomType bloomType = bloomArray[random.nextInt(bloomArraySize)]; <line9> getLogger() <line10> columnBuilder.setBloomFilterType(bloomType); <line11> if (bloomType == BloomType.ROWPREFIX_FIXED_LENGTH) { <line12> columnBuilder.setConfiguration(BloomFilterUtil.PREFIX_LENGTH_KEY, ""10""); <line13> } <line14> }); <line15> } <line16> } <line17> "	 <line10>	Yes
"public class A { <line0> @AdapterDelegationEvent( <line1> beforeBuilder = RetrieveDocumentSetRequestTypeDescriptionBuilder.class, <line2> afterReturningBuilder = RetrieveDocumentSetResponseTypeDescriptionBuilder.class, <line3> serviceType = ""Retrieve Document"", <line4> version = ""LEVEL_a0"") <line5> @Override <line6> public RetrieveDocumentSetResponseType retrieveDocumentSet( <line7> RetrieveDocumentSetRequestType request, AssertionType assertion) { <line8> AdapterDocRetrieveOrchImpl oOrchestrator = new AdapterDocRetrieveOrchImpl(); <line9> RetrieveDocumentSetResponseType oResponse = <line10> oOrchestrator.respondingGatewayCrossGatewayRetrieve(request, assertion); <line11> return oResponse; <line12> } <line13> } <line14> "	 <line11>	Yes
public class A { <line0> protected MediaType getBinaryResourceMediaType(final FedoraResource resource) { <line1> try { <line2> return MediaType.valueOf(((Binary) resource).getMimeType()); <line3> } catch (final IllegalArgumentException e) { <line4> return MediaType.APPLICATION_OCTET_STREAM_TYPE; <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> @Override <line1> public void close() { <line2> if (statusThread != null) { <line3> statusThread.interrupt(); <line4> statusThread = null; <line5> } <line6> internalStopRiver(); <line7> } <line8> } <line9> 	 <line0>	No
"public class A { <line0> public String getReferenceCheckSum() { <line1> Map<String, Integer> checksumCounts = new HashMap<String, Integer>(); <line2> checksumCounts.put(adminStatus.getChecksum(), 1); <line3> for (Replica baReplica : Replica.getKnown()) { <line4> String checksum = getUniqueChecksum(baReplica); <line5> if (checksumCounts.containsKey(checksum)) { <line6> checksumCounts.put(checksum, checksumCounts.get(checksum) + 1); <line7> } else { <line8> checksumCounts.put(checksum, 1); <line9> } <line10> } <line11> int majorityCount = (Replica.getKnown().size() + 1) / 2 + 1; <line12> for (Map.Entry<String, Integer> entry : checksumCounts.entrySet()) { <line13> if (entry.getValue() >= majorityCount) { <line14> return entry.getKey(); <line15> } <line16> } <line17> return """"; <line18> } <line19> } <line20> "	 <line11>	No
public class A { <line0> @Override <line1> protected TAIResult createPrincipal( <line2> HttpServletRequest request, HttpServletResponse response, FedizResponse federationResponse) { <line3> HttpSession session = request.getSession(true); <line4> session.setAttribute(Constants.SECURITY_TOKEN_SESSION_ATTRIBUTE_KEY, federationResponse); <line5> String username = federationResponse.getUsername(); <line6> try { <line7> return TAIResult.create(HttpServletResponse.SC_FOUND); <line8> } catch (WebTrustAssociationFailedException e) { <line9> return null; <line10> } <line11> } <line12> } <line13> 	 <line3>	No
"public class A { <line0> void writeNoPasswordViolation(final String accountId, final CSVReportEntry csvReportEntry) { <line1> violationSink.put( <line2> new ViolationBuilder() <line3> .withEventId(""check-iam-user_"" + csvReportEntry.getUser()) <line4> .withAccountId(accountId) <line5> .withRegion(NO_REGION) <line6> .withPluginFullyQualifiedClassName(NoPasswordsJob.class) <line7> .withType(PASSWORD_USED) <line8> .withMetaInfo(singletonMap(""user_name"", csvReportEntry.getUser())) <line9> .build()); <line10> } <line11> } <line12> "	 <line1>	Yes
"public class A { <line0> public static String getUrl(Item item) throws XPathException { <line1> String url = null; <line2> if (item.getType() == Type.ANY_URI) { <line3> url = item.getStringValue(); <line4> } else if (item.getType() == Type.DOCUMENT || item.getType() == Type.NODE) { <line5> if (item instanceof NodeProxy) { <line6> final NodeProxy np = (NodeProxy) item; <line7> url = np.getOwnerDocument().getBaseURI(); <line8> } <line9> } <line10> if (url == null) { <line11> throw new XPathException(""Parameter should be of type xs:anyURI or document.""); <line12> } <line13> if (url.startsWith(""/"")) { <line14> url = ""xmldb:exist://"" + url; <line15> } <line16> return url; <line17> } <line18> } <line19> "	 <line3>	Yes
"public class A { <line0> @Override <line1> public String getSubEquipmentConfigXML(final SubEquipmentCacheObject subEquipmentCacheObject) { <line2> StringBuilder str = new StringBuilder(""    <SubEquipmentUnit  id=\""""); <line3> str.append(subEquipmentCacheObject.getId()); <line4> str.append(""\"" name=\""""); <line5> str.append(subEquipmentCacheObject.getName()); <line6> str.append(""\"">\n""); <line7> str.append(""      <commfault-tag-id>""); <line8> str.append(subEquipmentCacheObject.getCommFaultTagId()); <line9> str.append(""</commfault-tag-id>\n""); <line10> str.append(""      <commfault-tag-value>""); <line11> str.append(subEquipmentCacheObject.getCommFaultTagValue()); <line12> str.append(""</commfault-tag-value>\n""); <line13> str.append(""      <alive-tag-id>""); <line14> str.append(subEquipmentCacheObject.getAliveTagId()); <line15> str.append(""</alive-tag-id>\n""); <line16> str.append(""      <alive-interval>""); <line17> str.append(subEquipmentCacheObject.getAliveInterval()); <line18> str.append(""</alive-interval>\n""); <line19> str.append(""    </SubEquipmentUnit>\n""); <line20> return str.toString(); <line21> } <line22> } <line23> "	 <line2>	Yes
public class A { <line0> private void removePartitionDirsNotAttached(long pName, int type) { <line1> nativeLPSZ.of(pName); <line2> if (!isDots(nativeLPSZ) && type == Files.DT_DIR) { <line3> if (Chars.endsWith(nativeLPSZ, DETACHED_DIR_MARKER)) { <line4> return; <line5> } <line6> try { <line7> long txn = 0; <line8> int txnSep = Chars.indexOf(nativeLPSZ, '.'); <line9> if (txnSep < 0) { <line10> txnSep = nativeLPSZ.length(); <line11> } else { <line12> txn = Numbers.parseLong(nativeLPSZ, txnSep + 1, nativeLPSZ.length()); <line13> } <line14> long dirTimestamp = partitionDirFmt.parse(nativeLPSZ, 0, txnSep, null); <line15> if (txn <= txFile.txn <line16> && (txFile.attachedPartitionsContains(dirTimestamp) <line17> || txFile.isActivePartition(dirTimestamp))) { <line18> return; <line19> } <line20> } catch (NumericException ignore) { <line21> } <line22> path.trimTo(rootLen); <line23> path.concat(pName).$(); <line24> int errno; <line25> if ((errno = ff.rmdir(path)) == 0) { <line26> } else { <line27> } <line28> } <line29> } <line30> } <line31> 	 <line10>	No
public class A { <line0> private void findAndRegisterBots() throws Exception { <line1> synchronized (getMonitor()) { <line2> findBotsInContextAndInitialize(); <line3> } <line4> registerCheckWorkDoneTrigger(); <line5> } <line6> } <line7> 	 <line5>	Yes
"public class A { <line0> public String save() { <line1> try { <line2> RadiusClient tmpclient = gluuRadiusClientService.getRadiusClientByInum(inum); <line3> if (client == null) { <line4> return OxTrustConstants.RESULT_FAILURE; <line5> } <line6> if (client.getSecret() != null && !client.getSecret().isEmpty()) { <line7> String encsecret = encryptionService.encrypt(client.getSecret()); <line8> client.setSecret(encsecret); <line9> } else { <line10> client.setSecret(tmpclient.getSecret()); <line11> } <line12> client.setDn(tmpclient.getDn()); <line13> client.setInum(tmpclient.getInum()); <line14> gluuRadiusClientService.updateRadiusClient(client); <line15> facesMessages.add(FacesMessage.SEVERITY_INFO, ""#{msgs['radius.client.update.success']}""); <line16> } catch (Exception e) { <line17> facesMessages.add(FacesMessage.SEVERITY_ERROR, ""#{msgs['radius.client.update.error']}""); <line18> return OxTrustConstants.RESULT_FAILURE; <line19> } <line20> return OxTrustConstants.RESULT_SUCCESS; <line21> } <line22> } <line23> "	 <line17>	Yes
public class A { <line0> protected void setValue(ITableRow r, VALUE value, boolean updateValidDisplayText) { <line1> try { <line2> Cell cell = r.getCellForUpdate(this); <line3> cell.removeErrorStatus(ValidationFailedStatus.class); <line4> VALUE newValue = validateValue(r, value); <line5> if (!cell.hasError()) { <line6> r.setCellValue(getColumnIndex(), newValue); <line7> if (this instanceof ITableRowCustomValueContributor) { <line8> ((ITableRowCustomValueContributor) this).enrichCustomValues(r, r.getCustomValues()); <line9> } <line10> } <line11> ensureVisibileIfInvalid(r); <line12> if (updateValidDisplayText) { <line13> updateDisplayText(r, newValue); <line14> } <line15> } catch (ProcessingException e) { <line16> if (LOG.isDebugEnabled()) { <line17> } <line18> Cell cell = r.getCellForUpdate(this); <line19> cell.addErrorStatus(new ValidationFailedStatus<>(e, value)); <line20> updateDisplayText(r, value); <line21> } <line22> } <line23> } <line24> 	 <line17>	Yes
"public class A { <line0> protected Answer execute(CreateObjectCommand cmd) { <line1> DataTO data = cmd.getData(); <line2> try { <line3> if (data.getObjectType() == DataObjectType.VOLUME) { <line4> return processor.createVolume(cmd); <line5> } else if (data.getObjectType() == DataObjectType.SNAPSHOT) { <line6> return processor.createSnapshot(cmd); <line7> } <line8> return new CreateObjectAnswer(""not supported type""); <line9> } catch (Exception e) { <line10> return new CreateObjectAnswer(e.toString()); <line11> } <line12> } <line13> } <line14> "	 <line3>	No
"public class A { <line0> private String buildUrl( <line1> InetSocketAddress node, String rootPath, String username, String password) { <line2> StringBuilder s = new StringBuilder(); <line3> s.append(protocol).append(""://""); <line4> if (username != null) { <line5> try { <line6> s.append(URLEncoder.encode(username, ""UTF-8"")) <line7> .append("":"") <line8> .append(URLEncoder.encode(password, ""UTF-8"")) <line9> .append(""@""); <line10> } catch (UnsupportedEncodingException e) { <line11> throw new RuntimeException(""Could not encode the supplied username and password"", e); <line12> } <line13> } <line14> s.append(node.getHostName()).append("":"").append(node.getPort()).append(""/""); <line15> if (rootPath != null) { <line16> s.append(rootPath).append(""/""); <line17> } <line18> if (log.isTraceEnabled()) { <line19> } <line20> return s.toString(); <line21> } <line22> } <line23> "	 <line19>	Yes
"public class A { <line0> @Override <line1> public Date deserialize(JsonParser jp, DeserializationContext ctxt) <line2> throws IOException, JsonProcessingException { <line3> String date = jp.getText(); <line4> if (date != null && !date.equals("""")) { <line5> try { <line6> return dateFormat.parse(date); <line7> } catch (ParseException e) { <line8> throw new RuntimeException(e); <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> "	 <line8>	Yes
public class A { <line0> public void delete(FilterName persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> public static java.util.List<com.liferay.asset.kernel.model.AssetVocabulary> deleteVocabularies( <line1> HttpPrincipal httpPrincipal, <line2> long[] vocabularyIds, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = <line7> new MethodKey( <line8> AssetVocabularyServiceUtil.class, <line9> ""deleteVocabularies"", <line10> _deleteVocabulariesParameterTypes4); <line11> MethodHandler methodHandler = new MethodHandler(methodKey, vocabularyIds, serviceContext); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (java.util.List<com.liferay.asset.kernel.model.AssetVocabulary>) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	 <line23>	Yes
"public class A { <line0> @Override <line1> public void setServletContext(ServletContext servletContext) { <line2> if (servletContext != null) { <line3> String accessKey = servletContext.getInitParameter(""cw.user""); <line4> String secretKey = servletContext.getInitParameter(""cw.password""); <line5> String environment = servletContext.getInitParameter(""obanyc.environment""); <line6> String endPoint = <line7> _configurationService.getConfigurationValueAsString( <line8> ""aws.endPoint"", ""monitoring.us-east-1.amazonaws.com""); <line9> if (StringUtils.isNotBlank(accessKey) && StringUtils.isNotBlank(secretKey)) { <line10> AmazonCloudWatchClient cloudWatch = <line11> new AmazonCloudWatchClient(new BasicAWSCredentials(accessKey, secretKey)); <line12> cloudWatch.setEndpoint(endPoint); <line13> this.cloudWatch = cloudWatch; <line14> } else { <line15> } <line16> if (StringUtils.isNotBlank(environment)) { <line17> this.environmentName = environment; <line18> this.nameSpace = ""Obanyc:"" + environment; <line19> } <line20> } <line21> } <line22> } <line23> "	 <line8>	No
public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSession session) { <line2> FlowFile flowFile = session.get(); <line3> if (flowFile == null) { <line4> return; <line5> } <line6> final char[] passphrase = getPassphrase(context); <line7> final PGPPrivateKeyService privateKeyService = getPrivateKeyService(context); <line8> final DecryptStreamCallback callback = new DecryptStreamCallback(passphrase, privateKeyService); <line9> try { <line10> flowFile = session.write(flowFile, callback); <line11> flowFile = session.putAllAttributes(flowFile, callback.attributes); <line12> session.transfer(flowFile, SUCCESS); <line13> } catch (final RuntimeException e) { <line14> session.transfer(flowFile, FAILURE); <line15> } <line16> } <line17> } <line18> 	 <line14>	Yes
public class A { <line0> int writeEntries(@Nonnull final Channel channel, final long now) { <line1> StackedSegment segment = firstSegment; <line2> int entries = 0; <line3> while (channel.isWritable()) { <line4> final OutboundQueueEntry entry = segment.getEntry(flushOffset); <line5> if (!entry.isCommitted()) { <line6> break; <line7> } <line8> final OfHeader message = entry.takeMessage(); <line9> flushOffset++; <line10> entries++; <line11> if (message != null) { <line12> manager.writeMessage(message, now); <line13> } else { <line14> entry.complete(null); <line15> } <line16> if (flushOffset >= StackedSegment.SEGMENT_SIZE) { <line17> synchronized (unflushedSegments) { <line18> ensureSegment(segment, flushOffset); <line19> final StackedSegment oldSegment = unflushedSegments.remove(0); <line20> if (oldSegment.isComplete()) { <line21> uncompletedSegments.remove(oldSegment); <line22> oldSegment.recycle(); <line23> } <line24> segment = unflushedSegments.get(0); <line25> uncompletedSegments.add(segment); <line26> if (shutdownOffset != null) { <line27> shutdownOffset -= StackedSegment.SEGMENT_SIZE; <line28> } <line29> firstSegment = segment; <line30> flushOffset = 0; <line31> } <line32> } <line33> } <line34> return entries; <line35> } <line36> } <line37> 	 <line6>	Yes
"public class A { <line0> public void run() { <line1> if (!ReplicationTable.isOnline(client)) { <line2> return; <line3> } <line4> try (TraceScope span = Trace.startSpan(""replicationWorkMaker"")) { <line5> final Scanner s; <line6> try { <line7> s = ReplicationTable.getScanner(client); <line8> if (writer == null) { <line9> setBatchWriter(ReplicationTable.getBatchWriter(client)); <line10> } <line11> } catch (ReplicationTableOfflineException e) { <line12> writer = null; <line13> return; <line14> } <line15> StatusSection.limit(s); <line16> TableConfiguration tableConf; <line17> Text file = new Text(); <line18> for (Entry<Key, Value> entry : s) { <line19> ReplicationSchema.StatusSection.getFile(entry.getKey(), file); <line20> TableId tableId = ReplicationSchema.StatusSection.getTableId(entry.getKey()); <line21> Status status; <line22> try { <line23> status = Status.parseFrom(entry.getValue().get()); <line24> } catch (InvalidProtocolBufferException e) { <line25> continue; <line26> } <line27> if (!shouldCreateWork(status)) { <line28> continue; <line29> } <line30> tableConf = context.getTableConfiguration(tableId); <line31> if (tableConf == null) { <line32> continue; <line33> } <line34> Map<String, String> replicationTargets = getReplicationTargets(tableConf); <line35> if (replicationTargets.isEmpty()) { <line36> } else { <line37> try (TraceScope workSpan = Trace.startSpan(""createWorkMutations"")) { <line38> addWorkRecord(file, entry.getValue(), replicationTargets, tableId); <line39> } <line40> } <line41> } <line42> } <line43> } <line44> } <line45> "	 <line21>	Yes
"public class A { <line0> @Override <line1> public ModbusSlaveConnection create(ModbusSlaveEndpoint endpoint) throws Exception { <line2> return endpoint.accept( <line3> new ModbusSlaveEndpointVisitor<ModbusSlaveConnection>() { <line4> @Override <line5> public @Nullable ModbusSlaveConnection visit( <line6> ModbusSerialSlaveEndpoint modbusSerialSlavePoolingKey) { <line7> SerialConnection connection = <line8> new SerialConnection(modbusSerialSlavePoolingKey.getSerialParameters()); <line9> return connection; <line10> } <line11>  <line12> @Override <line13> public @Nullable ModbusSlaveConnection visit(ModbusTCPSlaveEndpoint key) { <line14> InetAddress address = getInetAddress(key); <line15> if (address == null) { <line16> return null; <line17> } <line18> int connectTimeoutMillis = getEndpointPoolConfiguration(key).getConnectTimeoutMillis(); <line19> TCPMasterConnection connection = <line20> new TCPMasterConnection( <line21> address, key.getPort(), connectTimeoutMillis, key.getRtuEncoded()); <line22> logger.trace(""Created connection {} for endpoint {}"", connection, key); <line23> return connection; <line24> } <line25>  <line26> @Override <line27> public @Nullable ModbusSlaveConnection visit(ModbusUDPSlaveEndpoint key) { <line28> InetAddress address = getInetAddress(key); <line29> if (address == null) { <line30> return null; <line31> } <line32> UDPMasterConnection connection = new UDPMasterConnection(address, key.getPort()); <line33> return connection; <line34> } <line35> }); <line36> } <line37> } <line38> "	 <line3>	No
public class A { <line0> @Override <line1> public synchronized Mono<Lease> addOrUpdateLease(final Lease lease) { <line2> WorkerTask workerTask = this.currentlyOwnedPartitions.get(lease.getLeaseToken()); <line3> if (workerTask != null && workerTask.isRunning()) { <line4> return this.leaseManager <line5> .updateProperties(lease) <line6> .map( <line7> updatedLease -> { <line8> return updatedLease; <line9> }); <line10> } <line11> return this.leaseManager <line12> .acquire(lease) <line13> .defaultIfEmpty(lease) <line14> .map( <line15> updatedLease -> { <line16> synchronized (lock) { <line17> WorkerTask checkTask = this.currentlyOwnedPartitions.get(lease.getLeaseToken()); <line18> if (checkTask == null) { <line19> PartitionSupervisor supervisor = <line20> this.partitionSupervisorFactory.create(updatedLease); <line21> this.currentlyOwnedPartitions.put( <line22> updatedLease.getLeaseToken(), <line23> this.processPartition(supervisor, updatedLease)); <line24> } <line25> return updatedLease; <line26> } <line27> }) <line28> .onErrorResume( <line29> throwable -> { <line30> }); <line31> } <line32> } <line33> 	 <line6>	No
"public class A { <line0> private void valueTag(Document doc, Board board, Integer nl, String tag, int startingRelay) { <line1> for (int i = startingRelay; i < nl; i++) { <line2> try { <line3> String tagName = tag + i; <line4> if (tag.equalsIgnoreCase(""led"")) { <line5> if (!(board.getRelayStatus(i) <line6> == Integer.parseInt(doc.getElementsByTagName(tagName).item(0).getTextContent()))) { <line7> sendChanges(i, board, doc.getElementsByTagName(tagName).item(0).getTextContent(), tag); <line8> board.setRelayStatus( <line9> i, Integer.parseInt(doc.getElementsByTagName(tagName).item(0).getTextContent())); <line10> } <line11> } else if (tag.equalsIgnoreCase(""btn"")) { <line12> if (!(board <line13> .getDigitalInputValue(i) <line14> .equalsIgnoreCase(doc.getElementsByTagName(tagName).item(0).getTextContent()))) { <line15> sendChanges(i, board, doc.getElementsByTagName(tagName).item(0).getTextContent(), tag); <line16> board.setDigitalInputValue( <line17> i, doc.getElementsByTagName(tagName).item(0).getTextContent()); <line18> } <line19> } else if (tag.equalsIgnoreCase(""an"") || tag.equalsIgnoreCase(""analog"")) { <line20> if (!(board.getAnalogInputValue(i) <line21> == Integer.parseInt(doc.getElementsByTagName(tagName).item(0).getTextContent()))) { <line22> sendChanges(i, board, doc.getElementsByTagName(tagName).item(0).getTextContent(), tag); <line23> board.setAnalogInputValue( <line24> i, Integer.parseInt(doc.getElementsByTagName(tagName).item(0).getTextContent())); <line25> } <line26> } <line27> } catch (DOMException domException) { <line28> } <line29> } <line30> } <line31> } <line32> "	 <line28>	Yes
public class A { <line0> @Override <line1> public List<? extends IContainer> getSourceFolders(IProject project) { <line2> List<IContainer> sourceFolders = Lists.newArrayList(); <line3> IJavaProject javaProject = JavaCore.create(project); <line4> IClasspathEntry[] classpath; <line5> if (!javaProject.exists()) { <line6> return Collections.emptyList(); <line7> } <line8> try { <line9> classpath = javaProject.getRawClasspath(); <line10> } catch (JavaModelException e) { <line11> return Collections.emptyList(); <line12> } <line13> for (IClasspathEntry entry : classpath) { <line14> if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE) { <line15> IPath path = entry.getPath(); <line16> if (path.segmentCount() == 1) { <line17> sourceFolders.add(project); <line18> } else { <line19> sourceFolders.add(project.getWorkspace().getRoot().getFolder(entry.getPath())); <line20> } <line21> } <line22> } <line23> return sourceFolders; <line24> } <line25> } <line26> 	 <line11>	Yes
public class A { <line0> public void startBlocking() throws InterruptedException { <line1> this.ws.connectBlocking(); <line2> } <line3> } <line4> 	 <line3>	No
"public class A { <line0> public void init() { <line1> InputStream inStream = this.getClass().getClassLoader().getResourceAsStream(""esindexer.xml""); <line2> XStream xStream = getXStreamObject(); <line3> if (inStream != null) { <line4> Object o = xStream.fromXML(inStream); <line5> IndexerProperties indexerProperties = (IndexerProperties) o; <line6> List<Node> nodes = indexerProperties.getNodes(); <line7> if (nodes == null || (nodes != null && nodes.isEmpty())) { <line8> throw new IndexingException(""Nodes should not be empty/null""); <line9> } else { <line10> if (client == null) { <line11> client = TransportClient.builder().build(); <line12> } <line13> for (Node node : nodes) { <line14> Properties properties = node.getProperties(); <line15> if (properties != null) { <line16> if (properties.getProperty(""host"") == null <line17> || !StringUtils.isNumeric(properties.getProperty(""port"")) <line18> || properties.getProperty(""port"").isEmpty()) { <line19> throw new IllegalArgumentException( <line20> ""Host or port should not be null / port should be numeric""); <line21> } <line22> ((TransportClient) client) <line23> .addTransportAddress( <line24> new InetSocketTransportAddress( <line25> new InetSocketAddress( <line26> properties.getProperty(""host""), <line27> Integer.parseInt(properties.getProperty(""port""))))); <line28> } <line29> } <line30> } <line31> } else { <line32> throw new IndexingException( <line33> ""No indexer setting provided, please provide valid indexer settings in esindexer.xml""); <line34> } <line35> } <line36> } <line37> "	 <line30>	No
public class A { <line0> @Override <line1> public boolean isValid( <line2> SubmissionPayload submissionPayload, ConstraintValidatorContext validatorContext) { <line3> List<TemporaryExposureKey> exposureKeys = submissionPayload.getKeysList(); <line4> validatorContext.disableDefaultConstraintViolation(); <line5> boolean isValidPayload = <line6> checkStartIntervalNumberIsAtMidNight(exposureKeys, validatorContext) <line7> && checkKeyCollectionSize(exposureKeys, validatorContext) <line8> && checkOriginCountryIsValid(submissionPayload, validatorContext) <line9> && checkVisitedCountriesAreValid(submissionPayload, validatorContext) <line10> && checkRequiredFieldsNotMissing(exposureKeys, validatorContext) <line11> && checkTransmissionRiskLevelIsAcceptable(exposureKeys, validatorContext) <line12> && checkDaysSinceOnsetOfSymptomsIsInRange(exposureKeys, validatorContext) <line13> && eventCheckinValidator.verify(submissionPayload, validatorContext); <line14> if (!isValidPayload) { <line15> PrintableSubmissionPayload printableSubmissionPayload = <line16> new PrintableSubmissionPayload(submissionPayload); <line17> } <line18> return isValidPayload; <line19> } <line20> } <line21> 	 <line17>	Yes
"public class A { <line0> private ProductCertificate createCertForProduct(Product product) <line1> throws GeneralSecurityException, IOException { <line2> KeyPair keyPair = this.pki.generateNewKeyPair(); <line3> Set<X509ExtensionWrapper> extensions = this.extensionUtil.productExtensions(product); <line4> BigInteger serial = BigInteger.valueOf(product.getId().hashCode()).abs(); <line5> Calendar future = Calendar.getInstance(); <line6> future.add(Calendar.YEAR, 10); <line7> X509Certificate x509Cert = <line8> this.pki.createX509Certificate( <line9> ""CN="" + product.getId(), <line10> extensions, <line11> null, <line12> new Date(), <line13> future.getTime(), <line14> keyPair, <line15> serial, <line16> null); <line17> ProductCertificate cert = new ProductCertificate(); <line18> cert.setKeyAsBytes(this.pki.getPemEncoded(keyPair.getPrivate())); <line19> cert.setCertAsBytes(this.pki.getPemEncoded(x509Cert)); <line20> cert.setProduct(product); <line21> return cert; <line22> } <line23> } <line24> "	 <line4>	No
"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> @Override <line2> public boolean hasPermission( <line3> Authentication authentication, Object targetDomainObject, Object permissionObject) { <line4> boolean hasPermission = false; <line5> if (authentication != null <line6> && targetDomainObject != null <line7> && targetDomainObject instanceof PersistentObject <line8> && permissionObject instanceof String) { <line9> User user = null; <line10> final Object principalObject = authentication.getPrincipal(); <line11> if (principalObject instanceof User) { <line12> final User principal = (User) principalObject; <line13> if (usePlainPrincipal) { <line14> user = principal; <line15> } else { <line16> user = userDao.findById(principal.getId()); <line17> } <line18> } <line19> final PersistentObject persistentObject = (PersistentObject) targetDomainObject; <line20> final Integer objectId = persistentObject.getId(); <line21> final String simpleClassName = targetDomainObject.getClass().getSimpleName(); <line22> final Permission permission = Permission.fromString((String) permissionObject); <line23> String accountName = (user == null) ? ""ANONYMOUS"" : user.getAccountName(); <line24> PersistentObjectPermissionEvaluator entityPermissionEvaluator = <line25> permissionEvaluatorFactory.getEntityPermissionEvaluator(persistentObject.getClass()); <line26> hasPermission = entityPermissionEvaluator.hasPermission(user, persistentObject, permission); <line27> } else { <line28> } <line29> return hasPermission; <line30> } <line31> } <line32> "	 <line6>	No
"public class A { <line0> private Map<String, String> handleMultipart( <line1> final Mailbox mb, final Message message, Multipart p, List<File> attachments) { <line2> final Map<String, String> result = new HashMap<>(); <line3> try { <line4> for (int i = 0; i < p.getCount(); i++) { <line5> final String htmlContent = <line6> result.get(""htmlContent"") != null ? result.get(""htmlContent"") : """"; <line7> final String content = result.get(""content"") != null ? result.get(""content"") : """"; <line8> BodyPart part = (BodyPart) p.getBodyPart(i); <line9> if (part.getContent() instanceof Multipart) { <line10> final Map<String, String> subResult = <line11> handleMultipart(mb, message, (Multipart) part.getContent(), attachments); <line12> if (subResult.get(""content"") != null) { <line13> result.put(""content"", content.concat(subResult.get(""content""))); <line14> } <line15> if (subResult.get(""htmlContent"") != null) { <line16> result.put(""htmlContent"", htmlContent.concat(subResult.get(""htmlContent""))); <line17> } <line18> } else if (Part.ATTACHMENT.equalsIgnoreCase(part.getDisposition()) <line19> || (part.getContentType().toLowerCase().contains(""image/"") <line20> && Part.INLINE.equalsIgnoreCase(part.getDisposition())) <line21> || part.getContentType().toLowerCase().contains(""application/pdf"")) { <line22> final File file = extractFileAttachment(mb, message, part); <line23> if (file != null) { <line24> attachments.add(file); <line25> } <line26> } else { <line27> if (part.isMimeType(""text/html"")) { <line28> result.put(""htmlContent"", htmlContent.concat(getText(part))); <line29> } else if (part.isMimeType(""text/plain"")) { <line30> result.put(""content"", content.concat(getText(part))); <line31> } else if (!part.isMimeType(""message/delivery-status"")) { <line32> } <line33> } <line34> } <line35> return result; <line36> } catch (MessagingException | IOException ex) { <line37> } <line38> return null; <line39> } <line40> } <line41> "	 <line32>	Yes
public class A { <line0> protected Object executeCQLQuery(String cqlQuery, boolean isCql3Enabled) { <line1> Cassandra.Client conn = null; <line2> Object pooledConnection = null; <line3> pooledConnection = getConnection(); <line4> conn = (org.apache.cassandra.thrift.Cassandra.Client) getConnection(pooledConnection); <line5> try { <line6> if (isCql3Enabled || isCql3Enabled()) { <line7> return execute(cqlQuery, conn); <line8> } <line9> KunderaCoreUtils.printQuery(cqlQuery, showQuery); <line10> if (log.isDebugEnabled()) { <line11> } <line12> return conn.execute_cql_query( <line13> ByteBufferUtil.bytes(cqlQuery), org.apache.cassandra.thrift.Compression.NONE); <line14> } catch (Exception ex) { <line15> if (log.isErrorEnabled()) { <line16> } <line17> throw new PersistenceException(ex); <line18> } finally { <line19> releaseConnection(pooledConnection); <line20> } <line21> } <line22> } <line23> 	 <line5>	No
public class A { <line0> public boolean takeOwnershipJobDirectory(Path jobDirectory) { <line1> boolean success = false; <line2> try { <line3> FileSystem fs = getFileSystem(srcHdfs); <line4> try { <line5> success = <line6> fs.rename( <line7> new Path(jobDirectory, COMPLETE_FILE_MARKER), <line8> new Path(jobDirectory, LOADING_FILE_MARKER)); <line9> } catch (IOException e2) { <line10> } <line11> if (!success) { <line12> if (fs.exists(new Path(jobDirectory, LOADING_FILE_MARKER))) { <line13> } else { <line14> } <line15> } else { <line16> if (!fs.exists(new Path(jobDirectory, LOADING_FILE_MARKER))) { <line17> success = false; <line18> } else if (fs.exists(new Path(jobDirectory, COMPLETE_FILE_MARKER))) { <line19> success = false; <line20> int count = 0; <line21> boolean done = false; <line22> while (!done && fs.exists(new Path(jobDirectory, COMPLETE_FILE_MARKER)) && count < 10) { <line23> count++; <line24> if (fs.rename( <line25> new Path(jobDirectory, LOADING_FILE_MARKER), <line26> new Path(jobDirectory, ATTEMPT_FILE_MARKER + '.' + count))) { <line27> done = true; <line28> } <line29> } <line30> } <line31> } <line32> } catch (IOException e) { <line33> } <line34> return success; <line35> } <line36> } <line37> 	 <line8>	No
"public class A { <line0> @Override <line1> public void execute(DelegateExecution execution) throws Exception { <line2> try { <line3> GeneralBuildingBlock outputBB = null; <line4> ExecuteBuildingBlock executeBB = this.getExecuteBBFromExecution(execution); <line5> String resourceId = executeBB.getResourceId(); <line6> String requestAction = executeBB.getRequestAction(); <line7> String vnfType = executeBB.getVnfType(); <line8> boolean aLaCarte = Boolean.TRUE.equals(executeBB.isaLaCarte()); <line9> boolean homing = Boolean.TRUE.equals(executeBB.isHoming()); <line10> Map<ResourceKey, String> lookupKeyMap = new HashMap<>(); <line11> outputBB = this.getGBB(executeBB, lookupKeyMap, requestAction, aLaCarte, resourceId, vnfType); <line12> ObjectMapper mapper = new ObjectMapper(); <line13> mapper.enable(SerializationFeature.INDENT_OUTPUT); <line14> setHomingFlag(outputBB, homing, lookupKeyMap); <line15> execution.setVariable(FLOW_VAR_NAME, executeBB.getBuildingBlock().getBpmnFlowName()); <line16> execution.setVariable(GBB_INPUT_VAR_NAME, outputBB); <line17> execution.setVariable(LOOKUP_KEY_MAP_VAR_NAME, lookupKeyMap); <line18> if (outputBB.getRequestContext().getIsHelm()) { <line19> execution.setVariable(""isHelm"", true); <line20> } else { <line21> execution.setVariable(""isHelm"", false); <line22> } <line23> BuildingBlockExecution gBuildingBlockExecution = new DelegateExecutionImpl(execution); <line24> execution.setVariable(""gBuildingBlockExecution"", gBuildingBlockExecution); <line25> execution.setVariable(""RetryCount"", 1); <line26> execution.setVariable(""handlingCode"", ""Success""); <line27> } catch (Exception e) { <line28> exceptionUtil.buildAndThrowWorkflowException(execution, 7000, e.getMessage()); <line29> } <line30> } <line31> } <line32> "	 <line14>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private static void writeDictCollection( <line2> InvocationParamDictCollection<InvocationParam, InvocationParam> ipdc) { <line3> String pathToWrite = (String) ipdc.getValue(); <line4> if (new File(pathToWrite).exists()) { <line5> } else { <line6> try (PrintWriter writer = new PrintWriter(pathToWrite, ""UTF-8""); ) { <line7> for (Map.Entry<InvocationParam, InvocationParam> entry : <line8> ipdc.getDictCollectionParameters().entrySet()) { <line9> InvocationParam subParam = entry.getKey(); <line10> writer.println( <line11> subParam.getType().ordinal() <line12> + "" "" <line13> + subParam.getValue() <line14> + "" "" <line15> + subParam.getContentType()); <line16> if (subParam.getType() == DataType.DICT_COLLECTION_T) { <line17> writeDictCollection( <line18> (InvocationParamDictCollection<InvocationParam, InvocationParam>) subParam); <line19> } else if (subParam.getType() == DataType.COLLECTION_T) { <line20> writeCollection((InvocationParamCollection<InvocationParam>) subParam); <line21> } <line22> subParam = entry.getValue(); <line23> writer.println( <line24> subParam.getType().ordinal() <line25> + "" "" <line26> + subParam.getValue() <line27> + "" "" <line28> + subParam.getContentType()); <line29> if (subParam.getType() == DataType.DICT_COLLECTION_T) { <line30> writeDictCollection( <line31> (InvocationParamDictCollection<InvocationParam, InvocationParam>) subParam); <line32> } else if (subParam.getType() == DataType.COLLECTION_T) { <line33> writeCollection((InvocationParamCollection<InvocationParam>) subParam); <line34> } <line35> } <line36> } catch (Exception e) { <line37> e.printStackTrace(); <line38> } <line39> } <line40> } <line41> } <line42> "	 <line2>	No
"public class A { <line0> public void returnLease(JdbcCompiledQueryLease lease) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> try { <line4> _pool.returnObject(lease); <line5> } catch (Exception e) { <line6> throw handleError(e, ""return lease""); <line7> } <line8> } <line9> } <line10> "	 <line6>	No
"public class A { <line0> @Override <line1> protected PowermaxState handleMessageInternal(PowermaxCommManager commManager) { <line2> if (commManager == null) { <line3> return null; <line4> } <line5> PowermaxState updatedState = commManager.createNewState(); <line6> byte[] message = getRawData(); <line7> byte panelTypeNr = message[7]; <line8> String panelTypeStr; <line9> PowermaxPanelType panelType = null; <line10> try { <line11> panelType = PowermaxPanelType.fromCode(panelTypeNr); <line12> panelTypeStr = panelType.toString(); <line13> } catch (IllegalArgumentException e) { <line14> panelType = null; <line15> panelTypeStr = ""UNKNOWN""; <line16> } <line17> debug(""Panel type"", panelTypeNr, panelTypeStr); <line18> updatedState.downloadMode.setValue(true); <line19> commManager.sendMessage(PowermaxSendType.DL_PANELFW); <line20> commManager.sendMessage(PowermaxSendType.DL_SERIAL); <line21> commManager.sendMessage(PowermaxSendType.DL_ZONESTR); <line22> commManager.sendSetTime(); <line23> if ((panelType != null) && panelType.isPowerMaster()) { <line24> commManager.sendMessage(PowermaxSendType.DL_MR_SIRKEYZON); <line25> } <line26> commManager.sendMessage(PowermaxSendType.START); <line27> commManager.sendMessage(PowermaxSendType.EXIT); <line28> return updatedState; <line29> } <line30> } <line31> "	 <line18>	Yes
public class A { <line0> private void readyForEventsAfterFailover(QueueConnectionImpl primary) { <line1> try { <line2> ReadyForEventsOp.execute(pool, primary); <line3> } catch (Exception e) { <line4> if (logger.isDebugEnabled()) { <line5> } <line6> primary.destroy(); <line7> } <line8> } <line9> } <line10> 	 <line6>	No
public class A { <line0> @Override <line1> public List<Variant> read(int batchSize) { <line2> if (includeSamplesR.get() != null && includeSamplesR.get().isEmpty()) { <line3> return Collections.emptyList(); <line4> } else { <line5> return super.read(batchSize); <line6> } <line7> } <line8> } <line9> 	 <line3>	Yes
"public class A { <line0> void shutdownServers(SolrServerReference ref, boolean remove) { <line1> try { <line2> shutdownServer(ref.getSolrServer()); <line3> } catch (Exception e) { <line4> } <line5> try { <line6> shutdownServer(ref.getUpdateSolrServer()); <line7> } catch (Exception e) { <line8> LOG.warn(""Error shutting down streaming solr server. This exception is ignored."", e); <line9> } <line10> try { <line11> shutdownServer(ref.getCloudSolrServer()); <line12> } catch (Exception e) { <line13> } <line14> if (remove) { <line15> SolrEndpoint key = null; <line16> for (Map.Entry<SolrEndpoint, SolrServerReference> entry : servers.entrySet()) { <line17> if (entry.getValue() == ref) { <line18> key = entry.getKey(); <line19> break; <line20> } <line21> } <line22> if (key != null) { <line23> servers.remove(key); <line24> } <line25> } <line26> } <line27> } <line28> "	 <line14>	No
"public class A { <line0> public void listen( <line1> String address, <line2> int mqttPort, <line3> int wsPort, <line4> String username, <line5> String password, <line6> boolean allow_zero_byte_client_id) { <line7> try { <line8> this.address = (address == null) ? ""0.0.0.0"" : address; <line9> this.mqttPort = mqttPort; <line10> this.wsPort = wsPort; <line11> this.username = username; <line12> this.password = password; <line13> this.allow_zero_byte_client_id = allow_zero_byte_client_id; <line14> if (listening) { <line15> info(""broker already started - stop first to start again""); <line16> return; <line17> } <line18> Properties props = new Properties(); <line19> props.setProperty(""port"", mqttPort + """"); <line20> props.setProperty(""websocket_port"", wsPort + """"); <line21> props.setProperty(""host"", address); <line22> props.setProperty(""password_file"", passwordFilePath); <line23> if (username != null && username.length() > 0) { <line24> saveIdentities(); <line25> props.setProperty(""allow_anonymous"", ""false""); <line26> } else { <line27> props.setProperty(""allow_anonymous"", ""true""); <line28> } <line29> props.setProperty( <line30> ""allow_zero_byte_client_id"", String.format(""%b"", allow_zero_byte_client_id)); <line31> props.setProperty(""netty.mqtt.message_size"", ""1048576""); <line32> MemoryConfig mc = new MemoryConfig(props); <line33> Collections.singletonList(this); <line34> mqttBroker.startServer(mc, Collections.singletonList(this)); <line35> listening = true; <line36> broadcastState(); <line37> } catch (Exception e) { <line38> error(e); <line39> } <line40> } <line41> } <line42> "	 <line4>	No
public class A { <line0> @Override <line1> public void processPreTargetExecution(AtlasInternalSession session) throws AtlasException { <line2> XmlNamespaces xmlNs = null; <line3> String template = null; <line4> for (DataSource ds : session.getMapping().getDataSource()) { <line5> if (DataSourceType.TARGET.equals(ds.getDataSourceType()) <line6> && ds instanceof XmlDataSource <line7> && (ds.getId() == null || ds.getId().equals(getDocId()))) { <line8> xmlNs = ((XmlDataSource) ds).getXmlNamespaces(); <line9> template = ((XmlDataSource) ds).getTemplate(); <line10> } <line11> } <line12> Map<String, String> nsMap = new HashMap<String, String>(); <line13> if (xmlNs != null && xmlNs.getXmlNamespace() != null && !xmlNs.getXmlNamespace().isEmpty()) { <line14> for (XmlNamespace ns : xmlNs.getXmlNamespace()) { <line15> nsMap.put(ns.getAlias(), ns.getUri()); <line16> } <line17> } <line18> XmlFieldWriter writer = new XmlFieldWriter(getClassLoader(), nsMap, template); <line19> session.setFieldWriter(getDocId(), writer); <line20> if (LOG.isDebugEnabled()) { <line21> } <line22> } <line23> } <line24> 	 <line21>	Yes
"public class A { <line0> public void initialize() { <line1> if (omitIntervals && refSeqGeneList != null) { <line2> } <line3> if (printBinEndpointsAndExit) { <line4> int[] endpoints = DepthOfCoverageStats.calculateBinEndpoints(start, stop, nBins); <line5> System.out.print(""[ ""); <line6> for (int e : endpoints) { <line7> System.out.print(e + "" ""); <line8> } <line9> System.out.println(""]""); <line10> System.exit(0); <line11> } <line12> boolean goodOutputFormat = false; <line13> for (String f : OUTPUT_FORMATS) { <line14> goodOutputFormat = goodOutputFormat || f.equals(outputFormat); <line15> } <line16> if (!goodOutputFormat) { <line17> throw new IllegalArgumentException( <line18> ""Improper output format. Can be one of table,rtable,csv. Was "" + outputFormat); <line19> } <line20> if (outputFormat.equals(""csv"")) { <line21> separator = "",""; <line22> } <line23> if (!omitDepthOutput) { <line24> PrintStream out = <line25> getCorrectStream(null, DoCOutputType.Aggregation.locus, DoCOutputType.FileType.summary); <line26> out.printf(""%s\t%s"", ""Locus"", ""Total_Depth""); <line27> for (DoCOutputType.Partition type : partitionTypes) { <line28> out.printf(""\t%s_%s"", ""Average_Depth"", type.toString()); <line29> } <line30> HashSet<String> allSamples = getSamplesFromToolKit(partitionTypes); <line31> ArrayList<String> allSampleList = new ArrayList<String>(allSamples.size()); <line32> for (String s : allSamples) { <line33> allSampleList.add(s); <line34> } <line35> Collections.sort(allSampleList); <line36> for (String s : allSampleList) { <line37> out.printf(""\t%s_%s"", ""Depth_for"", s); <line38> if (printBaseCounts) { <line39> out.printf(""\t%s_%s"", s, ""base_counts""); <line40> } <line41> } <line42> out.printf(""%n""); <line43> } else { <line44> } <line45> for (DoCOutputType.Partition type : partitionTypes) { <line46> orderCheck.put(type, new ArrayList<String>()); <line47> for (String id : getSamplesFromToolKit(type)) { <line48> orderCheck.get(type).add(id); <line49> } <line50> Collections.sort(orderCheck.get(type)); <line51> } <line52> } <line53> } <line54> "	 <line2>	Yes
public class A { <line0> public void modelReload(ISO27KModel newModel) { <line1> for (IISO27KModelListener listener : getListeners()) { <line2> listener.modelReload(newModel); <line3> if (log.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> } <line8> 	 <line6>	No
"public class A { <line0> @Override <line1> public void login(final Proxy proxy, final LoginCallback prompt, final CancelCallback cancel) <line2> throws BackgroundException { <line3> try { <line4> final IRODSAccount account = client.getIRODSAccount(); <line5> final Credentials credentials = host.getCredentials(); <line6> account.setUserName(credentials.getUsername()); <line7> account.setPassword(credentials.getPassword()); <line8> final AuthResponse response = <line9> client.getIRODSAccessObjectFactory().authenticateIRODSAccount(account); <line10> if (log.isDebugEnabled()) { <line11> } <line12> if (!response.isSuccessful()) { <line13> throw new LoginFailureException( <line14> MessageFormat.format( <line15> LocaleFactory.localizedString( <line16> ""Login {0} with username and password"", ""Credentials""), <line17> BookmarkNameProvider.toString(host))); <line18> } <line19> } catch (JargonException e) { <line20> throw new IRODSExceptionMappingService().map(e); <line21> } <line22> } <line23> } <line24> "	 <line1>	No
public class A { <line0> @Override <line1> public void removeIndex(String indexName) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> OrientGraphNoTx noTx = db.get().getTxProvider().rawNoTx(); <line5> try { <line6> noTx.dropIndex(indexName); <line7> } finally { <line8> noTx.shutdown(); <line9> } <line10> } <line11> } <line12> 	 <line3>	Yes
public class A { <line0> @Override <line1> public void collisionResolve(Meteoroid meteoroid) { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void delete(ScriptVersionKey scriptVersionKey) { <line2> String deleteStatement = deleteStatement(scriptVersionKey); <line3> getMetadataRepository().executeUpdate(deleteStatement); <line4> } <line5> } <line6> 	 <line0>	No
public class A { <line0> void rollOver() { <line1> if (datePattern == null) { <line2> return; <line3> } <line4> String datedFilename = fileName + sdf.format(now); <line5> if (scheduledFilename.equals(datedFilename)) { <line6> return; <line7> } <line8> this.closeFile(); <line9> File target = new File(scheduledFilename); <line10> if (target.exists()) { <line11> target.delete(); <line12> } <line13> File file = new File(fileName); <line14> boolean result = file.renameTo(target); <line15> if (result) { <line16> } else { <line17> } <line18> try { <line19> this.setFile(fileName, false, this.bufferedIO, this.bufferSize); <line20> } catch (IOException e) { <line21> } <line22> scheduledFilename = datedFilename; <line23> } <line24> } <line25> 	 <line21>	Yes
public class A { <line0> @Override <line1> public BackgroundTaskResult call() throws Exception { <line2> if (shouldRun()) { <line3> runCount.incrementAndGet(); <line4> try { <line5> long startTime = Time.monotonicNow(); <line6> List<BlockGroup> keyBlocksList = manager.getPendingDeletionKeys(keyLimitPerTask); <line7> if (keyBlocksList != null && !keyBlocksList.isEmpty()) { <line8> List<DeleteBlockGroupResult> results = scmClient.deleteKeyBlocks(keyBlocksList); <line9> if (results != null) { <line10> int delCount; <line11> if (isRatisEnabled()) { <line12> delCount = submitPurgeKeysRequest(results); <line13> } else { <line14> delCount = deleteAllKeys(results); <line15> } <line16> deletedKeyCount.addAndGet(delCount); <line17> } <line18> } <line19> } catch (IOException e) { <line20> } <line21> } <line22> return EmptyTaskResult.newResult(); <line23> } <line24> } <line25> 	 <line20>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> final ChannelFuture f; <line3> try { <line4> Bootstrap b = new Bootstrap(); <line5> b.group(group) <line6> .channel(datagramChannelClass) <line7> .option(ChannelOption.SO_BROADCAST, false) <line8> .handler(channelInitializer); <line9> if (startupAddress != null) { <line10> f = b.bind(startupAddress.getHostAddress(), port).sync(); <line11> } else { <line12> f = b.bind(port).sync(); <line13> } <line14> } catch (InterruptedException e) { <line15> return; <line16> } <line17> try { <line18> InetSocketAddress isa = (InetSocketAddress) f.channel().localAddress(); <line19> String address = isa.getHostString(); <line20> this.port = isa.getPort(); <line21> isOnlineFuture.set(true); <line22> f.channel().closeFuture().sync(); <line23> } catch (InterruptedException e) { <line24> } finally { <line25> shutdown(); <line26> } <line27> } <line28> } <line29> 	 <line3>	No
"public class A { <line0> @Override <line1> public int doStartTag() throws JspException { <line2> try { <line3> String keyValue = (String) super.findValue(this.getKey(), String.class); <line4> Object masterObject = this.getMasterObject(keyValue); <line5> if (null == masterObject) { <line6> return super.doStartTag(); <line7> } <line8> String propertyValue = <line9> (null != this.getProperty()) <line10> ? (String) super.findValue(this.getProperty(), String.class) <line11> : null; <line12> Object requiredObject = <line13> (null != propertyValue) <line14> ? this.getPropertyValue(masterObject, propertyValue) <line15> : masterObject; <line16> if (null == requiredObject) { <line17> return super.doStartTag(); <line18> } <line19> if (null != this.getVar()) { <line20> ValueStack stack = this.getStack(); <line21> stack.getContext().put(this.getVar(), requiredObject); <line22> stack.setValue(""#attr['"" + this.getVar() + ""']"", requiredObject, false); <line23> } else { <line24> this.pageContext.getOut().print(requiredObject); <line25> } <line26> } catch (Throwable t) { <line27> throw new JspException(""Error on doStartTag"", t); <line28> } <line29> return super.doStartTag(); <line30> } <line31> } <line32> "	 <line2>	No
"public class A { <line0> public List<T> listFiles() { <line1> postClientAction(ClientActionEvent.ClientAction.LIST_DIR); <line2> List<T> result = new ArrayList<>(); <line3> if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { <line4> String parentId; <line5> if (documentId != null) { <line6> parentId = documentId; <line7> } else { <line8> parentId = DocumentsContract.getTreeDocumentId(startUrl); <line9> } <line10> Uri childrenUri = DocumentsContract.buildChildDocumentsUriUsingTree(startUrl, documentId); <line11> Cursor childCursor = contentResolver.query(childrenUri, SAF_QUERY_COLUMNS, null, null, null); <line12> try { <line13> while (childCursor.moveToNext()) { <line14> String absPath = <line15> this.absPath.endsWith(""/"") <line16> ? this.absPath + childCursor.getString(CURSOR_INDEX_NAME) <line17> : this.absPath + ""/"" + childCursor.getString(CURSOR_INDEX_NAME); <line18> result.add(createFile(contentResolver, startUrl, childCursor, absPath, pftpdService)); <line19> } <line20> } finally { <line21> closeQuietly(childCursor); <line22> } <line23> } <line24> for (T obj : result) { <line25> if (obj instanceof AbstractFile) { <line26> } else { <line27> } <line28> } <line29> if (result.isEmpty()) { <line30> } <line31> return result; <line32> } <line33> } <line34> "	 <line24>	No
"public class A { <line0> public void filter() { <line1> int total = 0, kept = 0; <line2> for (Gene gene : genome.getGenes()) { <line3> if (gene.numChilds() > MAX_TRANSCRIPTS_PER_GENE) { <line4> System.err.println( <line5> ""Ignoring gene '"" <line6> + gene.getGeneName() <line7> + ""', too many transcripts ("" <line8> + gene.numChilds() <line9> + "")""); <line10> continue; <line11> } <line12> for (Transcript tr : gene) { <line13> total++; <line14> if (!tr.isProteinCoding()) { <line15> if (debug) System.err.println(""Ignoring transcript '"" + tr.getId() + ""', non-coding.""); <line16> continue; <line17> } <line18> if (tr.hasError()) { <line19> if (debug) System.err.println(""Ignoring transcript '"" + tr.getId() + ""', it has errors.""); <line20> continue; <line21> } <line22> transcripts.add(tr); <line23> transcriptsByChromo.getOrCreate(tr.getChromosomeName()).add(tr); <line24> kept++; <line25> } <line26> } <line27> } <line28> } <line29> "	 <line1>	Yes
"public class A { <line0> public IIdeaComment getComment(int id) { <line1> IIdeaComment comment = null; <line2> try { <line3> comment = this.getIdeaCommentManager().getComment(id); <line4> if (null != comment && comment.getStatus() != IIdea.STATUS_APPROVED) { <line5> return null; <line6> } <line7> } catch (Throwable t) { <line8> throw new RuntimeException(""Errore in caricamento commento "" + id); <line9> } <line10> return comment; <line11> } <line12> } <line13> "	 <line10>	No
"public class A { <line0> static MCRContent getMetsSource(MCRServletJob job, boolean useExistingMets, String derivate) <line1> throws Exception { <line2> MCRPath metsPath = MCRPath.getPath(derivate, ""/mets.xml""); <line3> try { <line4> job.getRequest().setAttribute(""XSL.derivateID"", derivate); <line5> String objectid = MCRLinkTableManager.instance().getSourceOf(derivate).iterator().next(); <line6> if (objectid == null || objectid.length() == 0) { <line7> MCRDerivate derObj = <line8> MCRMetadataManager.retrieveMCRDerivate(MCRObjectID.getInstance(derivate)); <line9> MCRObjectID ownerID = derObj.getOwnerID(); <line10> objectid = ownerID.toString(); <line11> } <line12> job.getRequest().setAttribute(""XSL.objectID"", objectid); <line13> } catch (Exception x) { <line14> } <line15> boolean metsExists = Files.exists(metsPath); <line16> if (metsExists && useExistingMets) { <line17> MCRContent content = new MCRPathContent(metsPath); <line18> content.setDocType(""mets""); <line19> return content; <line20> } else { <line21> Document mets = <line22> MCRMETSGeneratorFactory.create(MCRPath.getPath(derivate, ""/"")).generate().asDocument(); <line23> if (!metsExists && STORE_METS_ON_GENERATE) { <line24> MCRMetsSave.saveMets(mets, MCRObjectID.getInstance(derivate)); <line25> } <line26> return new MCRJDOMContent(mets); <line27> } <line28> } <line29> } <line30> "	 <line14>	Yes
public class A { <line0> public static void main(String[] args) throws Exception { <line1> ParamsInfo paramsInfo = ExecuteProcessHelper.parseParams(args); <line2> StreamTableEnvironment env = ExecuteProcessHelper.getStreamExecution(paramsInfo); <line3> try { <line4> env.execute(paramsInfo.getName()); <line5> } catch (TableException e) { <line6> if (e.getMessage().contains(SqlExceptionConstant.JOIN_WITH_FLINK_PLANNER)) { <line7> throw new PlannerNotMatchException(SqlParseCodeEnum.PLANNER_NOT_MATCH); <line8> } else { <line9> throw e; <line10> } <line11> } <line12> } <line13> } <line14> 	 <line12>	Yes
"public class A { <line0> protected void logError( <line1> long lineNumber, String message, String localizedMessage, String... params) { <line2> importLogs.add( <line3> new CSVImportLog( <line4> lineNumber, <line5> ERROR, <line6> String.format(message, (Object[]) params), <line7> localizedMessage, <line8> params)); <line9> String lineMessage = String.format(""Line %d"", lineNumber); <line10> String errorMessage = String.format(message, (Object[]) params); <line11> getStore() <line12> .putParameter( <line13> id, <line14> ""status"", <line15> new CSVImportStatus(CSVImportStatus.State.ERROR, docsCreatedCount, docsCreatedCount)); <line16> } <line17> } <line18> "	 <line11>	Yes
"public class A { <line0> @Override <line1> public List<MetricSchemaRecord> getUnique(MetricSchemaRecordQuery query, RecordType type) { <line2> requireNotDisposed(); <line3> SystemAssert.requireArgument(query != null, ""MetricSchemaRecordQuery cannot be null.""); <line4> long size = (long) query.getLimit() * query.getPage(); <line5> SystemAssert.requireArgument( <line6> size > 0 && size <= Integer.MAX_VALUE, <line7> ""(limit * page) must be greater than 0 and atmost Integer.MAX_VALUE""); <line8> Map<String, String> tags = new HashMap<>(); <line9> tags.put(""type"", ""REGEXP_WITH_AGGREGATION""); <line10> long start = System.currentTimeMillis(); <line11> String indexName = TAGS_INDEX_NAME; <line12> String typeName = TAGS_TYPE_NAME; <line13> if (query.isQueryOnlyOnScope() && RecordType.SCOPE.equals(type)) { <line14> indexName = SCOPE_INDEX_NAME; <line15> typeName = SCOPE_TYPE_NAME; <line16> } <line17> String requestUrl = <line18> new StringBuilder() <line19> .append(""/"") <line20> .append(indexName) <line21> .append(""/"") <line22> .append(typeName) <line23> .append(""/"") <line24> .append(""_search"") <line25> .toString(); <line26> try { <line27> String queryJson = _constructTermAggregationQuery(query, type); <line28> Request request = new Request(HttpMethod.POST.getName(), requestUrl); <line29> request.setEntity(new StringEntity(queryJson, ContentType.APPLICATION_JSON)); <line30> Response response = _esRestClient.performRequest(request); <line31> String str = extractResponse(response); <line32> List<MetricSchemaRecord> records = <line33> SchemaService.constructMetricSchemaRecordsForType( <line34> toEntity(str, new TypeReference<List<String>>() {}), type); <line35> if (query.isQueryOnlyOnScope() && RecordType.SCOPE.equals(type)) { <line36> _monitorService.modifyCounter(Counter.SCOPENAMES_QUERY_COUNT, 1, tags); <line37> _monitorService.modifyCounter( <line38> Counter.SCOPENAMES_QUERY_LATENCY, (System.currentTimeMillis() - start), tags); <line39> } else { <line40> _monitorService.modifyCounter(Counter.SCHEMARECORDS_QUERY_COUNT, 1, tags); <line41> _monitorService.modifyCounter( <line42> Counter.SCHEMARECORDS_QUERY_LATENCY, (System.currentTimeMillis() - start), tags); <line43> } <line44> int fromIndex = query.getLimit() * (query.getPage() - 1); <line45> if (records.size() <= fromIndex) { <line46> return Collections.emptyList(); <line47> } <line48> if (records.size() < query.getLimit() * query.getPage()) { <line49> return records.subList(fromIndex, records.size()); <line50> } else { <line51> return records.subList(fromIndex, query.getLimit() * query.getPage()); <line52> } <line53> } catch (IOException e) { <line54> throw new SystemException(e); <line55> } <line56> } <line57> } <line58> "	 <line28>	Yes
"public class A { <line0> @Test <line1> public void badInputZipFileFile() throws Exception { <line2> File destFile = new File(destDir, ""badInputFileFile.zip""); <line3> try { <line4> try { <line5> ZipUtil.zip((File[]) null, destFile, true, ZipUtil.NO_COMPRESSION); <line6> Assert.fail(""Zip should fail when input File array is null""); <line7> } catch (IllegalArgumentException e) { <line8> } <line9> try { <line10> ZipUtil.zip( <line11> new File[] {srcFile, null, nestedSrcFile}, destFile, true, ZipUtil.NO_COMPRESSION); <line12> Assert.fail(""Zip should fail when any input file is null""); <line13> } catch (IllegalArgumentException e) { <line14> } <line15> try { <line16> ZipUtil.zip( <line17> new File[] {srcFile, dummieFile, nestedSrcFile}, <line18> destFile, <line19> true, <line20> ZipUtil.NO_COMPRESSION); <line21> Assert.fail(""Zip should fail when any input file does not exist""); <line22> } catch (FileNotFoundException e) { <line23> } <line24> try { <line25> ZipUtil.zip(new File[] {srcFile, nestedSrcFile}, (File) null, true, ZipUtil.NO_COMPRESSION); <line26> Assert.fail(""Zip should fail when destination File is null""); <line27> } catch (IllegalArgumentException e) { <line28> } <line29> try { <line30> ZipUtil.zip(new File[] {srcFile, nestedSrcFile}, sampleZip, true, ZipUtil.NO_COMPRESSION); <line31> Assert.fail(""Zip should fail when destination File already exists""); <line32> } catch (IllegalArgumentException e) { <line33> } <line34> try { <line35> ZipUtil.zip(new File[] {srcFile, nestedSrcFile}, dummieFile, true, ZipUtil.NO_COMPRESSION); <line36> Assert.fail(""Zip should fail when the destination File does not represent a zip file""); <line37> } catch (IllegalArgumentException e) { <line38> } <line39> } catch (Exception e) { <line40> Assert.fail( <line41> ""Another exception was expected, but got "" <line42> + e.getClass().getName() <line43> + "" instead: "" <line44> + e.getMessage()); <line45> } <line46> } <line47> } <line48> "	 <line6>	Yes
"public class A { <line0> private IncompleteType readFloatParameterType(SpaceSystem spaceSystem) throws XMLStreamException { <line1> StartElement element = checkStartElementPreconditions(); <line2> FloatParameterType.Builder typeBuilder = new FloatParameterType.Builder(); <line3> IncompleteType incompleteType = new IncompleteType(spaceSystem, typeBuilder); <line4> readParameterBaseTypeAttributes(spaceSystem, element, incompleteType); <line5> String value = readAttribute(""sizeInBits"", element, null); <line6> if (value != null) { <line7> int sizeInBits = Integer.parseInt(value); <line8> if (sizeInBits != 32 && sizeInBits != 64) { <line9> throw new XMLStreamException( <line10> ""Float encoding "" <line11> + sizeInBits <line12> + "" not supported;"" <line13> + "" Only 32 and 64 bits are supported"", <line14> xmlEvent.getLocation()); <line15> } <line16> typeBuilder.setSizeInBits(sizeInBits); <line17> } <line18> value = readAttribute(""initialValue"", element, null); <line19> if (value != null) { <line20> typeBuilder.setInitialValue(value); <line21> } <line22> while (true) { <line23> xmlEvent = xmlEventReader.nextEvent(); <line24> if (readBaseTypeProperties(typeBuilder)) { <line25> continue; <line26> } else if (isStartElementWithName(XTCE_INTEGER_DATA_ENCODING)) { <line27> typeBuilder.setEncoding(readIntegerDataEncoding(spaceSystem)); <line28> } else if (isStartElementWithName(XTCE_FLOAT_DATA_ENCODING)) { <line29> typeBuilder.setEncoding(readFloatDataEncoding(spaceSystem)); <line30> } else if (isStartElementWithName(XTCE_STRING_DATA_ENCODING)) { <line31> typeBuilder.setEncoding(readStringDataEncoding(spaceSystem)); <line32> } else if (isStartElementWithName(XTCE_BINARY_DATA_ENCODING)) { <line33> throw new XMLStreamException(""Cannot use a binary data encoding for float parameter type""); <line34> } else if (isStartElementWithName(XTCE_DEFAULT_ALARM)) { <line35> typeBuilder.setDefaultAlarm(readDefaultAlarm()); <line36> } else if (isStartElementWithName(XTCE_CONTEXT_ALARM_LIST)) { <line37> typeBuilder.setContextAlarmList(readNumericContextAlarmList(spaceSystem)); <line38> } else if (isStartElementWithName(XTCE_VALID_RANGE)) { <line39> typeBuilder.setValidRange(readFloatValidRange()); <line40> } else if (isEndElementWithName(XTCE_FLOAT_PARAMETER_TYPE)) { <line41> return incompleteType; <line42> } else { <line43> logUnknown(); <line44> } <line45> } <line46> } <line47> } <line48> "	 <line1>	Yes
public class A { <line0> public static int getStructureLayoutsCount(long groupId) throws RemoteException { <line1> try { <line2> int returnValue = DDMStructureLayoutServiceUtil.getStructureLayoutsCount(groupId); <line3> return returnValue; <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> @Test <line1> public void test_05_hgvs_frameshift() { <line2> checkHgvs(""testHg19Chr19"", path(""hgvs_frameshifts_syn_chr19.vcf""), 2); <line3> } <line4> } <line5> "	 <line2>	Yes
"public class A { <line0> private static void publishGlobalAPI(String id) throws APIException { <line1> if (log.isDebugEnabled()) { <line2> } <line3> RequestProcessor requestProcessor = new RequestProcessor(); <line4> String apiPublishResponse; <line5> String apiPublishPath = <line6> restConfig.getApimBaseUrl() <line7> + Constants.Utils.PATH_PUBLISHER <line8> + restConfig.getApiVersion() <line9> + Constants.Utils.PATH_LIFECYCLE <line10> + ""apiId="" <line11> + id <line12> + ""&action=Publish""; <line13> apiPublishResponse = <line14> requestProcessor.doPost( <line15> apiPublishPath, <line16> Constants.Utils.CONTENT_TYPE_APPLICATION_JSON, <line17> Constants.Utils.CONTENT_TYPE_APPLICATION_JSON, <line18> Constants.Utils.BEARER + apimConfig.getApiToken(), <line19> Constants.Utils.EMPTY_STRING); <line20> if (apiPublishResponse == null) { <line21> throw new APIException(""Error while publishing the global API with URL: "" + apiPublishPath); <line22> } <line23> } <line24> } <line25> "	 <line2>	Yes
public class A { <line0> @Override <line1> public void create_sentry_role( <line2> CommitContext context, TCreateSentryRoleRequest request, TCreateSentryRoleResponse response) { <line3> for (NotificationHandler handler : handlers) { <line4> try { <line5> handler.create_sentry_role( <line6> context, <line7> new TCreateSentryRoleRequest(request), <line8> new TCreateSentryRoleResponse(response)); <line9> } catch (Exception ex) { <line10> } <line11> } <line12> } <line13> } <line14> 	 <line9>	No
"public class A { <line0> @SuppressWarnings(""serial"") <line1> @Test <line2> public void testResolvesListAndMapPropertiesWithoutMergeOnInheritance() throws Exception { <line3> brooklynProperties.put(""brooklyn.location.jclouds.softlayer.prop1"", ""[ a, b ]""); <line4> brooklynProperties.put(""brooklyn.location.jclouds.softlayer.prop2"", ""{ a: 1, b: 2 }""); <line5> brooklynProperties.put(""brooklyn.location.named.foo"", ""jclouds:softlayer:ams01""); <line6> brooklynProperties.put(""brooklyn.location.named.foo.prop1"", ""[ a: 1, c: \""3\"" ]""); <line7> brooklynProperties.put(""brooklyn.location.named.foo.prop2"", ""{ b: 3, c: 3 }""); <line8> brooklynProperties.put(""brooklyn.location.named.bar"", ""named:foo""); <line9> brooklynProperties.put(""brooklyn.location.named.bar.prop2"", ""{ c: 4, d: \""4\"" }""); <line10> JcloudsLocation l = resolve(""named:bar""); <line11> assertJcloudsEquals(l, ""softlayer"", ""ams01""); <line12> Set<?> prop1 = l.config().get(new SetConfigKey<String>(String.class, ""prop1"")); <line13> assertEquals(prop1, MutableSet.of(""a: 1"", ""c: \""3\"""")); <line14> prop1 = l.config().get(new SetConfigKey<>(new TypeToken<Map<String, Integer>>() {}, ""prop1"")); <line15> assertEquals(prop1, MutableSet.of(MutableMap.of(""a"", 1), MutableMap.of(""c"", 3))); <line16> prop1 = l.config().get(new SetConfigKey<>(new TypeToken<Map<Object, Object>>() {}, ""prop1"")); <line17> assertEquals(prop1, MutableSet.of(MutableMap.of(""a"", 1), MutableMap.of(""c"", ""3""))); <line18> Map<String, ?> prop2 = l.config().get(new MapConfigKey<String>(String.class, ""prop2"")); <line19> assertEquals(prop2, MutableMap.of(""c"", ""4"", ""d"", ""4"")); <line20> prop2 = l.config().get(new MapConfigKey<>(Integer.class, ""prop2"")); <line21> assertEquals(prop2, MutableMap.of(""c"", 4, ""d"", 4)); <line22> prop2 = l.config().get(new MapConfigKey<>(Object.class, ""prop2"")); <line23> assertEquals(prop2, MutableMap.of(""c"", 4, ""d"", ""4"")); <line24> Map<String, String> prop3 = l.config().get(new MapConfigKey<String>(String.class, ""prop3"")); <line25> assertEquals(prop3, null); <line26> } <line27> } <line28> "	 <line19>	Yes
public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> if (!registerPromise.isDone()) { <line3> registerPromise.setFailure(cause); <line4> } <line5> ctx.close(); <line6> } <line7> } <line8> 	 <line1>	No
"public class A { <line0> protected void createFlatHiveTable(KylinConfig config) throws IOException { <line1> final HiveCmdBuilder hiveCmdBuilder = <line2> new HiveCmdBuilder(getName() + "" "" + getCubeName() + "" "" + getId()); <line3> hiveCmdBuilder.overwriteHiveProps(config.getHiveConfigOverride()); <line4> hiveCmdBuilder.addStatement(getInitStatement()); <line5> hiveCmdBuilder.addStatement(getCreateTableStatement()); <line6> final String cmd = hiveCmdBuilder.toString(); <line7> stepLogger.log(""Create and distribute table, cmd: ""); <line8> stepLogger.log(cmd); <line9> Pair<Integer, String> response = config.getCliCommandExecutor().execute(cmd, stepLogger); <line10> Map<String, String> info = stepLogger.getInfo(); <line11> Matcher matcher = HDFS_LOCATION.matcher(cmd); <line12> if (matcher.find()) { <line13> String hiveFlatTableHdfsUrl = matcher.group(1); <line14> long size = getFileSize(hiveFlatTableHdfsUrl); <line15> info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, """" + size); <line16> } <line17> getManager().addJobInfo(getId(), info); <line18> if (response.getFirst() != 0) { <line19> throw new RuntimeException( <line20> ""Failed to create flat hive table, error code "" + response.getFirst()); <line21> } <line22> } <line23> } <line24> "	 <line16>	Yes
"public class A { <line0> private int readdirInternal(String path, long buff, long filter, long offset, FuseFileInfo fi) { <line1> final AlluxioURI uri = mPathResolverCache.getUnchecked(path); <line2> try { <line3> FuseFillDir.apply(filter, buff, ""."", null, 0); <line4> FuseFillDir.apply(filter, buff, "".."", null, 0); <line5> mFileSystem.iterateStatus( <line6> uri, <line7> file -> { <line8> FuseFillDir.apply(filter, buff, file.getName(), null, 0); <line9> }); <line10> } catch (Throwable e) { <line11> return -ErrorCodes.EIO(); <line12> } <line13> return 0; <line14> } <line15> } <line16> "	 <line11>	Yes
"public class A { <line0> public static java.util.List<com.liferay.commerce.model.CommerceAddress> <line1> getBillingCommerceAddresses( <line2> HttpPrincipal httpPrincipal, <line3> long companyId, <line4> String className, <line5> long classPK, <line6> String keywords, <line7> int start, <line8> int end, <line9> com.liferay.portal.kernel.search.Sort sort) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> CommerceAddressServiceUtil.class, <line15> ""getBillingCommerceAddresses"", <line16> _getBillingCommerceAddressesParameterTypes7); <line17> MethodHandler methodHandler = <line18> new MethodHandler(methodKey, companyId, className, classPK, keywords, start, end, sort); <line19> Object returnObj = null; <line20> try { <line21> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line22> } catch (Exception exception) { <line23> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line24> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line25> } <line26> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line27> } <line28> return (java.util.List<com.liferay.commerce.model.CommerceAddress>) returnObj; <line29> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line30> throw systemException; <line31> } <line32> } <line33> } <line34> "	 <line25>	No
public class A { <line0> private void addRemote(ThingUID bridge, String remote) { <line1> ThingTypeUID uid = LIRCBindingConstants.THING_TYPE_REMOTE; <line2> ThingUID thingUID = new ThingUID(uid, bridge, remote); <line3> Map<String, Object> properties = new HashMap<>(1); <line4> properties.put(LIRCBindingConstants.PROPERTY_REMOTE, remote); <line5> DiscoveryResult discoveryResult = <line6> DiscoveryResultBuilder.create(thingUID) <line7> .withLabel(remote) <line8> .withBridge(bridge) <line9> .withProperties(properties) <line10> .build(); <line11> thingDiscovered(discoveryResult); <line12> } <line13> } <line14> 	 <line9>	No
public class A { <line0> @Override <line1> protected Object doRead(InputStream ins) throws IOException { <line2> readLine = AbstractIoAction.readLine(ins); <line3> return readLine; <line4> } <line5> } <line6> 	 <line3>	Yes
"public class A { <line0> private void logConfiguration() { <line1> final Set<String> propertyNames = <line2> new TreeSet<>(PropertyElf.getPropertyNames(HikariConfig.class)); <line3> for (String prop : propertyNames) { <line4> try { <line5> Object value = PropertyElf.getProperty(prop, this); <line6> if (""dataSourceProperties"".equals(prop)) { <line7> Properties dsProps = PropertyElf.copyProperties(dataSourceProperties); <line8> dsProps.setProperty(""password"", ""<masked>""); <line9> value = dsProps; <line10> } <line11> if (""initializationFailTimeout"".equals(prop) <line12> && initializationFailTimeout == Long.MAX_VALUE) { <line13> value = ""infinite""; <line14> } else if (""transactionIsolation"".equals(prop) && transactionIsolationName == null) { <line15> value = ""default""; <line16> } else if (prop.matches(""scheduledExecutorService|threadFactory"") && value == null) { <line17> value = ""internal""; <line18> } else if (prop.contains(""jdbcUrl"") && value instanceof String) { <line19> value = ((String) value).replaceAll(""([?&;]password=)[^&#;]*(.*)"", ""$1<masked>$2""); <line20> } else if (prop.contains(""password"")) { <line21> value = ""<masked>""; <line22> } else if (value instanceof String) { <line23> value = ""\"""" + value + ""\""""; <line24> } else if (value == null) { <line25> value = ""none""; <line26> } <line27> } catch (Exception e) { <line28> } <line29> } <line30> } <line31> } <line32> "	 <line2>	No
public class A { <line0> protected synchronized void rollSecret() { <line1> if (!isDestroyed) { <line2> byte[] newSecret = generateNewSecret(); <line3> secrets = new byte[][] {newSecret, secrets[0]}; <line4> } <line5> } <line6> } <line7> 	 <line0>	No
public class A { <line0> @Override <line1> public boolean engineIsCertificateEntry(String alias) { <line2> return false; <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> private void validateRelayResponseDTO(final RelayResponseDTO dto) { <line1> if (dto == null) { <line2> throw new InvalidParameterException(""RelayResponseDTO"" + NULL_ERROR_MESSAGE); <line3> } <line4> if (Utilities.isEmpty(dto.getAddress())) { <line5> throw new InvalidParameterException(""Relay address"" + EMPTY_OR_NULL_ERROR_MESSAGE); <line6> } <line7> if (dto.getType() == RelayType.GATEKEEPER_RELAY) { <line8> throw new InvalidParameterException(dto.getType().name() + NOT_APPLICABLE_RELAY_TYPE); <line9> } <line10> } <line11> } <line12> "	 <line2>	No
"public class A { <line0> private void performSolrCloudRestore(SolrClient client) { <line1> printInfoMessage( <line2> String.format( <line3> ""Restoring collection [%s] from [%s] / [%s]."", coreName, backupLocation, backupName)); <line4> try { <line5> if (asyncRestore) { <line6> String requestId = restoreAsync(client, coreName, backupLocation, backupName); <line7> printInfoMessage(""Restore request Id: "" + requestId); <line8> } else { <line9> boolean isSuccess = restore(client, coreName, backupLocation, backupName); <line10> if (isSuccess) { <line11> printInfoMessage(""Restore complete.""); <line12> } <line13> } <line14> } catch (InterruptedException | InterruptedIOException ie) { <line15> printErrorMessage(""Restore was interrupted""); <line16> Thread.currentThread().interrupt(); <line17> } catch (Exception e) { <line18> printErrorMessage(""Restore failed.""); <line19> } <line20> } <line21> } <line22> "	 <line19>	Yes
public class A { <line0> @Override <line1> public void onComplete(@Nullable Result result) { <line2> if (!HttpStatus.Code.OK.equals(getCommunicationStatus().getHttpCode()) <line3> && retries++ < MAX_RETRIES) { <line4> StatusUpdateListener listener = getListener(); <line5> if (listener != null) { <line6> listener.update(getCommunicationStatus()); <line7> } <line8> handler.getWebInterface().enqueueCommand(this); <line9> } else { <line10> String json = getContentAsString(StandardCharsets.UTF_8); <line11> if (json != null && !json.isEmpty()) { <line12> DataResponse jsonObject = fromJson(json); <line13> if (jsonObject != null) { <line14> handler.updateChannelStatus(transformer.transform(jsonObject)); <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	 <line12>	Yes
"public class A { <line0> private static ShellCommandsProvider getCommandsProviderFromName(String osName) { <line1> if (osName == null) { <line2> osName = System.getProperty(""os.name""); <line3> } <line4> ShellCommandsProvider commands; <line5> if (osName.startsWith(""Linux"")) { <line6> commands = new NssShellCommands(); <line7> } else if (osName.startsWith(""Mac OS X"")) { <line8> commands = new OsxShellCommands(); <line9> } else { <line10> throw new SecurityProviderCreationException(OS_TYPE_ERROR); <line11> } <line12> return commands; <line13> } <line14> } <line15> "	 <line12>	No
public class A { <line0> public void setRequestBody(byte[] body, String contentType) { <line1> byte[] compressed = {}; <line2> try { <line3> compressed = Compressor.compress(body); <line4> } catch (IOException e) { <line5> } <line6> ByteArrayRequestEntity requestEntity = new ByteArrayRequestEntity(body, contentType); <line7> method.setRequestEntity(requestEntity); <line8> } <line9> } <line10> 	 <line5>	Yes
"public class A { <line0> private void kmsSigKill() { <line1> if (isKmsRemote) { <line2> String kmsPid = <line3> remoteKmsSshConnection.execAndWaitCommandNoBr( <line4> ""cat"", remoteKmsSshConnection.getTmpFolder() + ""/kms-pid""); <line5> remoteKmsSshConnection.runAndWaitCommand(""sh"", ""-c"", ""kill -9 "" + kmsPid); <line6> } else { <line7> Shell.runAndWait(""sh"", ""-c"", ""kill -9 `cat "" + workspace + File.separator + ""kms-pid`""); <line8> } <line9> } <line10> } <line11> "	 <line5>	No
public class A { <line0> @Override <line1> public void handleSignalInternal(EPDataFlowSignal signal) throws InvocationTargetException { <line2> try { <line3> method.invoke(target, new Object[] {streamNum, signal}); <line4> } catch (IllegalAccessException e) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
public class A { <line0> @Override <line1> public boolean isMembershipAllowed(long userId, long userGroupId) throws PortalException { <line2> try { <line3> checkMembership(new long[] {userId}, new long[] {userGroupId}, null); <line4> } catch (Exception exception) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> return false; <line8> } <line9> return true; <line10> } <line11> } <line12> 	 <line6>	Yes
"public class A { <line0> private RequestInfo buildRequestInfo(String requestId, String timeout) { <line1> RequestInfo requestInfo = new RequestInfo(); <line2> if (requestId != null) { <line3> String host = env.getProperty(""mso.workflow.message.endpoint""); <line4> String callbackUrl = <line5> host <line6> + ""/"" <line7> + UriUtils.encodePathSegment(""SNIROResponse"", ""UTF-8"") <line8> + ""/"" <line9> + UriUtils.encodePathSegment(requestId, ""UTF-8""); <line10> Duration d = Duration.parse(timeout); <line11> requestInfo.setTransactionId(requestId); <line12> requestInfo.setRequestId(requestId); <line13> requestInfo.setCallbackUrl(callbackUrl); <line14> requestInfo.setRequestType(""create""); <line15> requestInfo.setTimeout(d.getSeconds()); <line16> } else { <line17> throw new BpmnError(UNPROCESSABLE, ""Request Context does not contain: requestId""); <line18> } <line19> return requestInfo; <line20> } <line21> } <line22> "	 <line6>	No
public class A { <line0> public static PlayerAction valueOf(int actionId) { <line1> switch (actionId) { <line2> case 0: <line3> return START_BREAK; <line4> case 1: <line5> return ABORT_BREAK; <line6> case 2: <line7> return STOP_BREAK; <line8> case 3: <line9> return GET_UPDATED_BLOCK; <line10> case 4: <line11> return RELEASE_ITEM; <line12> case 5: <line13> return START_SLEEPING; <line14> case 6: <line15> return STOP_SLEEPING; <line16> case 7: <line17> return RESPAWN; <line18> case 8: <line19> return JUMP; <line20> case 9: <line21> return START_SPRINT; <line22> case 10: <line23> return STOP_SPRINT; <line24> case 11: <line25> return START_SNEAK; <line26> case 12: <line27> return STOP_SNEAK; <line28> case 13: <line29> return DIMENSION_CHANGE_REQUEST; <line30> case 14: <line31> return DIMENSION_CHANGE_ACK; <line32> case 15: <line33> return START_GLIDE; <line34> case 16: <line35> return STOP_GLIDE; <line36> case 17: <line37> return BUILD_DENIED; <line38> case 18: <line39> return CONTINUE_BREAK; <line40> case 19: <line41> return CHANGE_SKIN; <line42> case 20: <line43> return SET_ENCHANT_SEED; <line44> case 21: <line45> return START_SWIMMING; <line46> case 22: <line47> return STOP_SWIMMING; <line48> case 23: <line49> return START_SPIN_ATTACK; <line50> case 24: <line51> return STOP_SPIN_ATTACK; <line52> case 25: <line53> return INTERACT_BLOCK; <line54> } <line55> return null; <line56> } <line57> } <line58> 	 <line55>	Yes
"public class A { <line0> Optional<Map<String, String>> loadViewHashes(Schema schema) { <line1> if (!schema.tableExists(DEPLOYED_VIEWS_NAME)) { <line2> return Optional.empty(); <line3> } <line4> Map<String, String> result = Maps.newHashMap(); <line5> SelectStatement upgradeAuditSelect = <line6> select(field(""name""), field(""hash"")).from(tableRef(DEPLOYED_VIEWS_NAME)); <line7> String sql = dialect.convertStatementToSQL(upgradeAuditSelect); <line8> if (log.isDebugEnabled()) <line9> try (Connection connection = dataSource.getConnection(); <line10> java.sql.Statement statement = connection.createStatement(); <line11> ResultSet resultSet = statement.executeQuery(sql)) { <line12> while (resultSet.next()) { <line13> String dbViewName = resultSet.getString(1); <line14> String viewName = dbViewName.toUpperCase(); <line15> if (!result.containsKey(viewName) || dbViewName.equals(viewName)) { <line16> result.put(viewName, resultSet.getString(2)); <line17> } <line18> } <line19> } catch (SQLException e) { <line20> throw new RuntimeSqlException(""Failed to load deployed views. SQL: ["" + sql + ""]"", e); <line21> } <line22> return Optional.of(Collections.unmodifiableMap(result)); <line23> } <line24> } <line25> "	 <line2>	No
public class A { <line0> public void inform(String key, WalkResult newlyFoundValue) { <line1> if (verbose) { <line2> } <line3> if (this.foundValue == null) { <line4> this.foundValue = newlyFoundValue; <line5> if (verbose) { <line6> } <line7> if (interestedActions != null && !interestedActions.isEmpty()) { <line8> for (MatcherAction action : interestedActions) { <line9> action.inform(variableName, newlyFoundValue.getValue(), newlyFoundValue.getTree()); <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	 <line2>	Yes
public class A { <line0> @RestAccessControl(permission = Permission.CONTENT_EDITOR) <line1> @RequestMapping(method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE) <line2> public ResponseEntity<SimpleRestResponse<List<ContentDto>>> addContent( <line3> @Valid @RequestBody List<ContentDto> bodyRequest, BindingResult bindingResult) { <line4> if (bindingResult.hasErrors()) { <line5> throw new ValidationGenericException(bindingResult); <line6> } <line7> List<ContentDto> response = <line8> bodyRequest.stream() <line9> .map( <line10> content -> { <line11> this.getContentValidator().validate(content, bindingResult); <line12> if (bindingResult.hasErrors()) { <line13> throw new ValidationGenericException(bindingResult); <line14> } <line15> ContentDto result = <line16> this.getContentService() <line17> .addContent( <line18> content, <line19> HttpSessionHelper.extractCurrentUser(httpSession), <line20> bindingResult); <line21> if (bindingResult.hasErrors()) { <line22> throw new ValidationGenericException(bindingResult); <line23> } <line24> return result; <line25> }) <line26> .collect(Collectors.toList()); <line27> return new ResponseEntity<>(new SimpleRestResponse<>(response), HttpStatus.OK); <line28> } <line29> } <line30> 	 <line4>	Yes
public class A { <line0> @Override <line1> public boolean preHandle( <line2> HttpServletRequest request, HttpServletResponse response, Object handler) { <line3> String xid = RootContext.getXID(); <line4> String rpcXid = request.getHeader(RootContext.KEY_XID); <line5> if (LOGGER.isDebugEnabled()) { <line6> } <line7> if (xid == null && rpcXid != null) { <line8> RootContext.bind(rpcXid); <line9> if (LOGGER.isDebugEnabled()) { <line10> } <line11> } <line12> return true; <line13> } <line14> } <line15> 	 <line11>	No
"public class A { <line0> public List findByExample(StgMbDelMassn instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.StgMbDelMassn"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line2>	No
"public class A { <line0> @SuppressWarnings(""ConstantConditions"") <line1> final SQLException checkException(SQLException sqle) { <line2> boolean evict = false; <line3> SQLException nse = sqle; <line4> final SQLExceptionOverride exceptionOverride = poolEntry.getPoolBase().exceptionOverride; <line5> for (int depth = 0; <line6> delegate != ClosedConnection.CLOSED_CONNECTION && nse != null && depth < 10; <line7> depth++) { <line8> final String sqlState = nse.getSQLState(); <line9> if (sqlState != null && sqlState.startsWith(""08"") <line10> || nse instanceof SQLTimeoutException <line11> || ERROR_STATES.contains(sqlState) <line12> || ERROR_CODES.contains(nse.getErrorCode())) { <line13> if (exceptionOverride != null && exceptionOverride.adjudicate(nse) == DO_NOT_EVICT) { <line14> break; <line15> } <line16> evict = true; <line17> break; <line18> } else { <line19> nse = nse.getNextException(); <line20> } <line21> } <line22> if (evict) { <line23> SQLException exception = (nse != null) ? nse : sqle; <line24> leakTask.cancel(); <line25> poolEntry.evict(""(connection is broken)""); <line26> delegate = ClosedConnection.CLOSED_CONNECTION; <line27> } <line28> return sqle; <line29> } <line30> } <line31> "	 <line15>	No
public class A { <line0> public void updateLastTimeSMPPLinkUpdated() { <line1> lastTimeSMPPLinkUpdated = System.currentTimeMillis(); <line2> if (logger.isDebugEnabled()) <line3> } <line4> } <line5> 	 <line2>	No
public class A { <line0> @Override <line1> public boolean blockUntilEnded(Duration timeout) { <line2> Long endTime = <line3> timeout == null ? null : System.currentTimeMillis() + timeout.toMillisecondsRoundingUp(); <line4> try { <line5> boolean started = blockUntilStarted(timeout); <line6> if (!started) return false; <line7> if (timeout == null) { <line8> internalFuture.get(); <line9> } else { <line10> long remaining = endTime - System.currentTimeMillis(); <line11> if (remaining > 0) internalFuture.get(remaining, TimeUnit.MILLISECONDS); <line12> } <line13> return isDone(); <line14> } catch (Throwable t) { <line15> Exceptions.propagateIfFatal(t); <line16> if (!(t instanceof TimeoutException) && log.isDebugEnabled()) <line17> return isDone(); <line18> } <line19> } <line20> } <line21> 	 <line5>	No
public class A { <line0> @Override <line1> public void onComplete(@Nullable Result result) { <line2> if (!HttpStatus.Code.OK.equals(getCommunicationStatus().getHttpCode())) { <line3> updateListenerStatus(); <line4> if (retries++ < MAX_RETRIES) { <line5> handler.getWebInterface().enqueueCommand(this); <line6> } <line7> } else { <line8> String json = getContentAsString(StandardCharsets.UTF_8); <line9> if (json != null) { <line10> AggregateDataResponsePrivateApi jsonObject = <line11> fromJson(json, AggregateDataResponsePrivateApi.class); <line12> if (jsonObject != null) { <line13> handler.updateChannelStatus(transformer.transform(jsonObject, period)); <line14> } <line15> } <line16> } <line17> } <line18> } <line19> 	 <line17>	No
"public class A { <line0> @Override <line1> public String getSubtitle() { <line2> if (_group.isCompany()) { <line3> return StringPool.DASH; <line4> } <line5> List<Group> childSites = null; <line6> try { <line7> childSites = GroupServiceUtil.getGroups(_group.getCompanyId(), _group.getGroupId(), true); <line8> } catch (PortalException portalException) { <line9> if (_log.isDebugEnabled()) { <line10> } <line11> childSites = Collections.emptyList(); <line12> } <line13> return LanguageUtil.format(_httpServletRequest, ""x-child-sites"", childSites.size()); <line14> } <line15> } <line16> "	 <line10>	Yes
"public class A { <line0> public List<RangerConditionEvaluator> getRangerPolicyConditionEvaluator( <line1> RangerPolicy policy, RangerServiceDef serviceDef, RangerPolicyEngineOptions options) { <line2> List<RangerConditionEvaluator> conditionEvaluators = new ArrayList<>(); <line3> if (!getConditionsDisabledOption(options) <line4> && CollectionUtils.isNotEmpty(policy.getConditions())) { <line5> RangerPerfTracer perf = null; <line6> long policyId = policy.getId(); <line7> if (RangerPerfTracer.isPerfTraceEnabled(PERF_POLICY_INIT_LOG)) { <line8> perf = <line9> RangerPerfTracer.getPerfTracer( <line10> PERF_POLICY_INIT_LOG, <line11> ""RangerCustomConditionEvaluator.init(policyId="" + policyId + "")""); <line12> } <line13> for (RangerPolicy.RangerPolicyItemCondition condition : policy.getConditions()) { <line14> RangerServiceDef.RangerPolicyConditionDef conditionDef = <line15> getConditionDef(condition.getType(), serviceDef); <line16> if (conditionDef == null) { <line17> continue; <line18> } <line19> RangerConditionEvaluator conditionEvaluator = <line20> newConditionEvaluator(conditionDef.getEvaluator()); <line21> if (conditionEvaluator != null) { <line22> conditionEvaluator.setServiceDef(serviceDef); <line23> conditionEvaluator.setConditionDef(conditionDef); <line24> conditionEvaluator.setPolicyItemCondition(condition); <line25> RangerPerfTracer perfConditionInit = null; <line26> if (RangerPerfTracer.isPerfTraceEnabled(PERF_POLICYCONDITION_INIT_LOG)) { <line27> perfConditionInit = <line28> RangerPerfTracer.getPerfTracer( <line29> PERF_POLICYCONDITION_INIT_LOG, <line30> ""RangerConditionEvaluator.init(policyId="" <line31> + policyId <line32> + ""policyConditionType="" <line33> + condition.getType() <line34> + "")""); <line35> } <line36> conditionEvaluator.init(); <line37> RangerPerfTracer.log(perfConditionInit); <line38> conditionEvaluators.add(conditionEvaluator); <line39> } else { <line40> } <line41> } <line42> RangerPerfTracer.log(perf); <line43> } <line44> return conditionEvaluators; <line45> } <line46> } <line47> "	 <line24>	No
public class A { <line0> @Override <line1> public void start(StartContext startContext) throws StartException { <line2> addDeserializerAndOrphanFilter(); <line3> addRecoveryModule(); <line4> } <line5> } <line6> 	 <line5>	No
"public class A { <line0> @Test <line1> public void testAsynchronous() throws Exception { <line2> MockEndpoint mock = getMockEndpoint(""mock:result""); <line3> mock.expectedMessageCount(100); <line4> mock.expectsNoDuplicates(body()); <line5> StopWatch watch = new StopWatch(); <line6> for (int i = 0; i < 100; i++) { <line7> template.sendBody(""seda:start"", """" + i); <line8> } <line9> assertMockEndpointsSatisfied(20, TimeUnit.SECONDS); <line10> } <line11> } <line12> "	 <line3>	No
"public class A { <line0> @Override <line1> public Status update(String tableName, String key, Map<String, ByteIterator> values) { <line2> try { <line3> StatementType type = new StatementType(StatementType.Type.UPDATE, tableName, null); <line4> PreparedStatement updateStatement = cachedStatements.get(type); <line5> if (updateStatement == null) { <line6> updateStatement = createAndCacheUpdateStatement(type); <line7> } <line8> JSONObject jsonObject = new JSONObject(); <line9> for (Map.Entry<String, ByteIterator> entry : values.entrySet()) { <line10> jsonObject.put(entry.getKey(), entry.getValue().toString()); <line11> } <line12> PGobject object = new PGobject(); <line13> object.setType(""jsonb""); <line14> object.setValue(jsonObject.toJSONString()); <line15> updateStatement.setObject(1, object); <line16> updateStatement.setString(2, key); <line17> int result = updateStatement.executeUpdate(); <line18> if (result == 1) { <line19> return Status.OK; <line20> } <line21> return Status.UNEXPECTED_STATE; <line22> } catch (SQLException e) { <line23> return Status.ERROR; <line24> } <line25> } <line26> } <line27> "	 <line9>	No
public class A { <line0> public static Object object(Class<?> type, byte[] bytes) { <line1> try { <line2> if (Long.class.isAssignableFrom(type)) { <line3> return getLong(bytes); <line4> } else if (UUID.class.isAssignableFrom(type)) { <line5> return uuid(bytes); <line6> } else if (String.class.isAssignableFrom(type)) { <line7> return string(bytes); <line8> } else if (Boolean.class.isAssignableFrom(type)) { <line9> return getBoolean(bytes); <line10> } else if (Integer.class.isAssignableFrom(type)) { <line11> return getInt(bytes); <line12> } else if (Double.class.isAssignableFrom(type)) { <line13> return getDouble(bytes); <line14> } else if (Float.class.isAssignableFrom(type)) { <line15> return getFloat(bytes); <line16> } else if (byte[].class.isAssignableFrom(type)) { <line17> return bytes; <line18> } <line19> } catch (Exception e) { <line20> } <line21> return null; <line22> } <line23> } <line24> 	 <line20>	Yes
"public class A { <line0> @Override <line1> public String createID(ServiceContext<PoxPayloadIn, PoxPayloadOut> ctx, String csid) <line2> throws Exception { <line3> String newId = """"; <line4> String lastId = """"; <line5> if (csid == null || csid.equals("""")) { <line6> throw new DocumentNotFoundException(""Identifier for ID generator must not be null or empty.""); <line7> } <line8> String serializedGenerator = """"; <line9> try { <line10> IDGeneratorInstance generator = readIDGenerator(ctx, csid); <line11> serializedGenerator = generator.getGeneratorState(); <line12> } catch (DocumentNotFoundException e) { <line13> throw e; <line14> } catch (IllegalArgumentException e) { <line15> throw e; <line16> } catch (IllegalStateException e) { <line17> throw e; <line18> } <line19> if (serializedGenerator == null || serializedGenerator.equals("""")) { <line20> throw new BadRequestException(""ID generator "" + ""\'"" + csid + ""\'"" + "" could not be found.""); <line21> } <line22> SettableIDGenerator generator; <line23> try { <line24> generator = IDGeneratorSerializer.deserialize(serializedGenerator); <line25> } catch (IllegalArgumentException e) { <line26> throw e; <line27> } <line28> try { <line29> lastId = readLastID(ctx, csid); <line30> if (lastId == null || lastId.equals("""")) { <line31> newId = generator.newID(); <line32> } else { <line33> newId = generator.newID(lastId); <line34> } <line35> updateLastID(ctx, csid, newId); <line36> updateIDGenerator(ctx, csid, generator); <line37> } catch (DocumentNotFoundException e) { <line38> throw e; <line39> } catch (IllegalArgumentException e) { <line40> throw e; <line41> } catch (IllegalStateException e) { <line42> throw e; <line43> } <line44> return newId; <line45> } <line46> } <line47> "	 <line3>	Yes
public class A { <line0> private void updateInputStream() throws IOException { <line1> if (mInputStream != null <line2> && (mInputStream.mFile.isIncompleteLog() || !mInputStream.isDone(mNextSequenceNumber))) { <line3> return; <line4> } <line5> if (mInputStream != null) { <line6> mInputStream.close(); <line7> mInputStream = null; <line8> } <line9> if (mFilesToProcess.isEmpty()) { <line10> UfsJournalSnapshot snapshot = UfsJournalSnapshot.getSnapshot(mJournal); <line11> if (snapshot.getCheckpoints().isEmpty() && snapshot.getLogs().isEmpty()) { <line12> return; <line13> } <line14> int index = 0; <line15> if (!snapshot.getCheckpoints().isEmpty()) { <line16> UfsJournalFile checkpoint = snapshot.getLatestCheckpoint(); <line17> if (mNextSequenceNumber < checkpoint.getEnd()) { <line18> String location = checkpoint.getLocation().toString(); <line19> mCheckpointStream = <line20> new CheckpointInputStream( <line21> mUfs.open(location, OpenOptions.defaults().setRecoverFailedOpen(true))); <line22> mNextSequenceNumber = checkpoint.getEnd(); <line23> } <line24> for (; index < snapshot.getLogs().size(); index++) { <line25> UfsJournalFile file = snapshot.getLogs().get(index); <line26> if (file.getEnd() > checkpoint.getEnd()) { <line27> break; <line28> } <line29> } <line30> } <line31> for (; index < snapshot.getLogs().size(); index++) { <line32> UfsJournalFile file = snapshot.getLogs().get(index); <line33> if ((!mReadIncompleteLog && file.isIncompleteLog()) <line34> || mNextSequenceNumber >= file.getEnd()) { <line35> continue; <line36> } <line37> mFilesToProcess.add(snapshot.getLogs().get(index)); <line38> } <line39> } <line40> if (!mFilesToProcess.isEmpty()) { <line41> mInputStream = new JournalInputStream(mFilesToProcess.poll(), mUfs); <line42> } <line43> } <line44> } <line45> 	 <line19>	Yes
public class A { <line0> @Override <line1> public boolean isReadable( <line2> Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { <line3> initParser(); <line4> boolean isUsed = <line5> (type == TemplateParam.class) && mediaType.toString().contains(MediaType.APPLICATION_XML); <line6> return isUsed; <line7> } <line8> } <line9> 	 <line6>	Yes
public class A { <line0> private void getAllConnectionTemplates() { <line1> ResourceCollection<ConnectionTemplate> connectionTemplates = <line2> this.connectionTemplateClient.getAll(); <line3> } <line4> } <line5> 	 <line4>	No
public class A { <line0> private void ethPendingTransactionHashObservable(String x) { <line1> Exchange exchange = this.getEndpoint().createExchange(); <line2> exchange.getIn().setBody(x); <line3> processEvent(exchange); <line4> } <line5> } <line6> 	 <line5>	No
"public class A { <line0> @Override <line1> public void finish() { <line2> try { <line3> os.write(appendXmlStartTag(rootNode).getBytes()); <line4> for (String xml : xmlRecords) { <line5> os.write(appendXmlStartTag(recordNode).getBytes()); <line6> os.write(xml.getBytes()); <line7> os.write(appendXmlEndingTag(rootNode).getBytes()); <line8> } <line9> os.write(appendXmlEndingTag(rootNode).getBytes()); <line10> os.write(""\n"".getBytes()); <line11> } catch (IOException e) { <line12> } <line13> } <line14> } <line15> "	 <line1>	No
public class A { <line0> public final void persistFeedEventStatisticsToDisk() { <line1> try { <line2> boolean success = FeedEventStatistics.getInstance().backup(); <line3> if (success) { <line4> } else { <line5> } <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	 <line6>	No
public class A { <line0> public static String getDigest(File file) { <line1> String digest; <line2> try { <line3> List<String> lines = Files.readAllLines(file.toPath(), StandardCharsets.UTF_8); <line4> digest = Integer.toHexString(lines.hashCode()); <line5> } catch (IOException ioException) { <line6> if (_logger.isDebugEnabled()) { <line7> } <line8> HashValue hashValue = HashUtil.sha1(file); <line9> digest = hashValue.asHexString(); <line10> } <line11> if (_logger.isInfoEnabled()) { <line12> } <line13> return digest; <line14> } <line15> } <line16> 	 <line12>	Yes
public class A { <line0> @Override <line1> public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { <line2> if (!(msg instanceof DecodedStreamData)) { <line3> return; <line4> } <line5> DecodedStreamData decodedStreamData = (DecodedStreamData) msg; <line6> decodedStreamData.accept( <line7> new DecodedStreamData.Visitor() { <line8> @Override <line9> public void visit(Mpeg2DecodedStreamData decodedStreamData) { <line10> handleMpeg2(decodedStreamData.getListOfTypes()); <line11> } <line12>  <line13> @Override <line14> public void visit(Mpeg4DecodedStreamData decodedStreamData) { <line15> handleNALUnits(decodedStreamData.getNalUnits()); <line16> } <line17> }); <line18> } <line19> } <line20> 	 <line0>	No
public class A { <line0> private void executeResourcePoolStoreProcedures( <line1> Callable<Void>[] defineSPs, String type, String clusterName) throws InterruptedException { <line2> if (defineSPs.length == 0) { <line3> return; <line4> } <line5> NoProgressUpdateCallback callback = new NoProgressUpdateCallback(); <line6> ExecutionResult[] result = <line7> Scheduler.executeStoredProcedures( <line8> com.vmware.aurora.composition.concurrent.Priority.BACKGROUND, defineSPs, callback); <line9> if (result == null) { <line10> throw ClusteringServiceException.CREATE_RESOURCE_POOL_FAILED( <line11> Constants.NO_RESOURCE_POOL_IS_CREATED); <line12> } <line13> int total = 0; <line14> boolean success = true; <line15> String errMessage = null; <line16> for (int i = 0; i < defineSPs.length; i++) { <line17> if (result[i].finished && result[i].throwable == null) { <line18> ++total; <line19> } else if (result[i].throwable != null) { <line20> if (errMessage == null) { <line21> errMessage = result[i].throwable.getMessage(); <line22> } <line23> success = false; <line24> } <line25> } <line26> if (!success) { <line27> throw ClusteringServiceException.CREATE_RESOURCE_POOL_FAILED(errMessage); <line28> } <line29> } <line30> } <line31> 	 <line21>	No
public class A { <line0> private void afterAuthentication(final String username) { <line1> try { <line2> selfTO = client.self().getRight(); <line3> } catch (ForbiddenException e) { <line4> selfTO = new UserTO(); <line5> selfTO.setUsername(username); <line6> selfTO.setMustChangePassword(true); <line7> } <line8> this.bind(); <line9> } <line10> } <line11> 	 <line4>	Yes
"public class A { <line0> @Test <line1> public void testPlayAction() { <line2> expectLastChangeOnSetAVTransportURI(true, false, 0); <line3> handler.setCurrentURI(upnpEntryQueue.get(0).getRes(), """"); <line4> handler.play(); <line5> checkInternalState(null, null, false, true, false, false); <line6> checkControlChannel(PlayPauseType.PLAY); <line7> checkSetURI(0, null, false); <line8> checkMetadataChannels(0, true); <line9> } <line10> } <line11> "	 <line2>	Yes
"public class A { <line0> public void testSelectionRange3() throws Exception { <line1> String req = <line2> ""{\""selections\"":[{\""range\"":{\""groupid_range\"":{\""from\"":\""0\"", \""to\"":\""10\""}}}]}""; <line3> JSONObject res = TestSensei.search(new JSONObject(req)); <line4> assertEquals(""numhits is wrong"", 11, res.getInt(""numhits"")); <line5> } <line6> } <line7> "	 <line5>	No
"public class A { <line0> private StorageSummary putObject( <line1> Table table, <line2> String blobId, <line3> Supplier<? extends InputStream> in, <line4> Map<String, String> attributes) { <line5> long timestamp = _storageProvider.getCurrentTimestamp(table); <line6> int chunkSize = _storageProvider.getDefaultChunkSize(); <line7> checkArgument(chunkSize > 0); <line8> DigestInputStream md5In = new DigestInputStream(in.get(), getMessageDigest(""MD5"")); <line9> DigestInputStream sha1In = new DigestInputStream(md5In, getMessageDigest(""SHA-1"")); <line10> byte[] bytes = new byte[chunkSize]; <line11> long length = 0; <line12> int chunkCount = 0; <line13> for (; ; ) { <line14> int chunkLength; <line15> try { <line16> chunkLength = ByteStreams.read(sha1In, bytes, 0, bytes.length); <line17> } catch (IOException e) { <line18> throw Throwables.propagate(e); <line19> } <line20> if (chunkLength == 0) { <line21> break; <line22> } <line23> ByteBuffer buffer = ByteBuffer.wrap(bytes, 0, chunkLength); <line24> _storageProvider.writeChunk(table, blobId, chunkCount, buffer, timestamp); <line25> length += chunkLength; <line26> chunkCount++; <line27> } <line28> String md5 = Hex.encodeHexString(md5In.getMessageDigest().digest()); <line29> String sha1 = Hex.encodeHexString(sha1In.getMessageDigest().digest()); <line30> return new StorageSummary(length, chunkCount, chunkSize, md5, sha1, attributes, timestamp); <line31> } <line32> } <line33> "	 <line0>	No
public class A { <line0> private Pair<Boolean, Optional<ImmutableSortedSet<String>>> computeFieldsFor(String term) { <line1> if (this.unfieldedLiterals.contains(term)) { <line2> if (log.isDebugEnabled()) <line3> return ALL_FIELDS; <line4> } <line5> for (Matcher matcher : this.unfieldedMatchers) { <line6> matcher.reset(term); <line7> if (matcher.matches()) { <line8> if (log.isDebugEnabled()) <line9> return ALL_FIELDS; <line10> } <line11> } <line12> for (LiteralRange<String> range : this.unfieldedRanges) { <line13> boolean matches = range.contains(term); <line14> if (matches) { <line15> if (log.isDebugEnabled()) <line16> return ALL_FIELDS; <line17> } <line18> } <line19> ImmutableSortedSet.Builder<String> fields = ImmutableSortedSet.naturalOrder(); <line20> fields.addAll(fieldedLiterals.get(term)); <line21> for (Entry<Matcher, Collection<String>> e : fieldedMatchers.asMap().entrySet()) { <line22> Matcher m = e.getKey(); <line23> m.reset(term); <line24> if (m.matches()) { <line25> Collection<String> matcherFields = e.getValue(); <line26> if (matcherFields.isEmpty()) { <line27> if (log.isDebugEnabled()) <line28> return ALL_FIELDS; <line29> } else { <line30> fields.addAll(matcherFields); <line31> } <line32> } <line33> } <line34> for (Entry<String, Collection<LiteralRange<String>>> r : fieldedRanges.asMap().entrySet()) { <line35> for (LiteralRange<String> range : r.getValue()) { <line36> if (range.contains(term)) { <line37> fields.add(r.getKey()); <line38> break; <line39> } <line40> } <line41> } <line42> ImmutableSortedSet<String> fieldSet = fields.build(); <line43> Pair<Boolean, Optional<ImmutableSortedSet<String>>> p = <line44> Pair.with(!fieldSet.isEmpty(), Optional.of(fieldSet)); <line45> return p; <line46> } <line47> } <line48> 	 <line9>	Yes
"public class A { <line0> @Secured(ServicesData.ROLE_IMPORT_AGENCIES) <line1> @PostMapping(CommonConstants.PATH_IMPORT) <line2> public JsonNode importAgencies( <line3> @RequestParam(""fileName"") String fileName, @RequestParam(""file"") MultipartFile file) { <line4> ParameterChecker.checkParameter(""The fileName is mandatory parameter : "", fileName); <line5> SafeFileChecker.checkSafeFilePath(file.getOriginalFilename()); <line6> return agencyExternalService.importAgencies(fileName, file); <line7> } <line8> } <line9> "	 <line0>	No
public class A { <line0> private void doTouchStart(NativeEvent nativeEvent) { <line1> if (transitionOn) { <line2> momentum.cancel(); <line3> } <line4> Touch touch = nativeEvent.getTouches().get(0); <line5> if (detectScrolledElement(touch)) { <line6> nativeEvent.stopPropagation(); <line7> handlerRegistration = Event.addNativePreviewHandler(this); <line8> activeScrollDelegate = this; <line9> origY = touch.getClientY(); <line10> yPositions[0] = origY; <line11> eventTimeStamps[0] = getTimeStamp(); <line12> nextEvent = 1; <line13> origScrollTop = getScrollTop(); <line14> moved = false; <line15> } <line16> } <line17> } <line18> 	 <line16>	No
public class A { <line0> private void parseSignatureLength(CertificateVerifyMessage msg) { <line1> msg.setSignatureLength(parseIntField(HandshakeByteLength.SIGNATURE_LENGTH)); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> public URI getNodeURI() { <line2> if (this.nodeURIs == null || this.nodeURIs.isEmpty()) return null; <line3> int index = lastIndex + 1; <line4> if (index >= this.nodeURIs.size()) { <line5> index = 0; <line6> } <line7> URI nodeUri = this.nodeURIs.get(index); <line8> this.lastIndex = index; <line9> return nodeUri; <line10> } <line11> } <line12> 	 <line9>	Yes
public class A { <line0> @Override <line1> public void cacheOffer(long timestamp, Offer offer) { <line2> if (!useOfferCache.get()) { <line3> schedulerClient.decline(Collections.singletonList(offer.getId())); <line4> return; <line5> } <line6> offerCache.put(offer.getId().getValue(), new CachedOffer(offer)); <line7> } <line8> } <line9> 	 <line5>	No
"public class A { <line0> protected String getCamelEndpointId(WorkItem workItem) { <line1> String workItemCamelEndpointId = <line2> (String) workItem.getParameter(JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM); <line3> if (camelEndpointId != null && !camelEndpointId.isEmpty()) { <line4> if (workItemCamelEndpointId != null && !workItemCamelEndpointId.isEmpty()) { <line5> } else { <line6> workItemCamelEndpointId = camelEndpointId; <line7> } <line8> } <line9> if (workItemCamelEndpointId == null || workItemCamelEndpointId.isEmpty()) { <line10> throw new IllegalArgumentException( <line11> ""No Camel Endpoint ID specified. Please configure the '"" <line12> + JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM <line13> + ""' in either the constructor of this WorkItemHandler, or pass it via the "" <line14> + JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM <line15> + ""' WorkItem parameter.""); <line16> } <line17> return workItemCamelEndpointId; <line18> } <line19> } <line20> "	 <line18>	No
"public class A { <line0> @POST <line1> @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line2> @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line3> @Path(""/{id}/deactivate"") <line4> @CheckPermission( <line5> roles = {Role.TENANT_ADMIN}, <line6> acls = {ACL.OWN, ACL.ALL}) <line7> public TaskResourceRep deactivateQuotaDirectory( <line8> @PathParam(""id"") URI id, QuotaDirectoryDeleteParam param) throws InternalException { <line9> String task = UUID.randomUUID().toString(); <line10> ArgValidator.checkFieldUriType(id, QuotaDirectory.class, ""id""); <line11> QuotaDirectory quotaDirectory = queryResource(id); <line12> FileShare fs = queryFileShareResource(quotaDirectory.getParent().getURI()); <line13> ArgValidator.checkFieldNotNull(fs, ""filesystem""); <line14> if (param.getForceDelete()) { <line15> throw APIException.badRequests.quotaDirectoryDeleteNotSupported(param.getForceDelete()); <line16> } else { <line17> if (quotaDirectoryHasExportsOrShares(fs, quotaDirectory.getName())) { <line18> throw APIException.badRequests.resourceCannotBeDeleted( <line19> ""Quota directory "" + quotaDirectory.getName() + "" has exports/shares ""); <line20> } <line21> } <line22> Operation op = new Operation(); <line23> op.setResourceType(ResourceOperationTypeEnum.DELETE_FILE_SYSTEM_QUOTA_DIR); <line24> quotaDirectory.getOpStatus().createTaskStatus(task, op); <line25> fs.setOpStatus(new OpStatusMap()); <line26> fs.getOpStatus().createTaskStatus(task, op); <line27> _dbClient.persistObject(fs); <line28> _dbClient.persistObject(quotaDirectory); <line29> StorageSystem device = _dbClient.queryObject(StorageSystem.class, fs.getStorageDevice()); <line30> FileController controller = getController(FileController.class, device.getSystemType()); <line31> try { <line32> controller.deleteQuotaDirectory(device.getId(), quotaDirectory.getId(), fs.getId(), task); <line33> } catch (InternalException e) { <line34> throw e; <line35> } <line36> auditOp( <line37> OperationTypeEnum.DELETE_FILE_SYSTEM_QUOTA_DIR, <line38> true, <line39> AuditLogManager.AUDITOP_BEGIN, <line40> quotaDirectory.getLabel(), <line41> quotaDirectory.getId().toString(), <line42> fs.getId().toString()); <line43> fs = _dbClient.queryObject(FileShare.class, fs.getId()); <line44> return toTask(quotaDirectory, task, op); <line45> } <line46> } <line47> "	 <line20>	No
public class A { <line0> protected Map<NodeIDSuffix, WebViewContent> getWizardPageViewValueMapInternal( <line1> final NodeID subnodeID) { <line2> if (subnodeID == null) { <line3> return null; <line4> } <line5> final WorkflowManager manager = m_manager; <line6> assert manager.isLockedByCurrentThread(); <line7> SubNodeContainer subNC = manager.getNodeContainer(subnodeID, SubNodeContainer.class, true); <line8> WorkflowManager subWFM = subNC.getWorkflowManager(); <line9> return subWFM.findExecutedNodes(WizardNode.class, NOT_HIDDEN_FILTER).entrySet().stream() <line10> .filter( <line11> e -> !subWFM.getNodeContainer(e.getKey(), NativeNodeContainer.class, true).isInactive()) <line12> .collect( <line13> Collectors.toMap( <line14> e -> NodeID.NodeIDSuffix.create(manager.getID(), e.getKey()), <line15> e -> e.getValue().getViewValue())); <line16> } <line17> } <line18> 	 <line11>	No
public class A { <line0> private void reloadCatalogModelFromDatabasePrivate() { <line1> if (isModernizedBpCatalogLoaded()) { <line2> CatalogModel newModel = loadCatalogModel(); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> catalogModel.modelReload(newModel); <line6> catalogModel.moveListener(newModel); <line7> catalogModel = newModel; <line8> fireLoad(catalogModel); <line9> } <line10> } <line11> } <line12> 	 <line11>	No
public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> continueMultiScan_result result = new continueMultiScan_result(); <line4> if (e instanceof NoSuchScanIDException) { <line5> result.nssi = (NoSuchScanIDException) e; <line6> result.setNssiIsSet(true); <line7> msg = result; <line8> } else if (e instanceof TSampleNotPresentException) { <line9> result.tsnpe = (TSampleNotPresentException) e; <line10> result.setTsnpeIsSet(true); <line11> msg = result; <line12> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line13> fb.close(); <line14> return; <line15> } else if (e instanceof org.apache.thrift.TApplicationException) { <line16> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line17> msg = (org.apache.thrift.TApplicationException) e; <line18> } else { <line19> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line20> msg = <line21> new org.apache.thrift.TApplicationException( <line22> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line23> } <line24> try { <line25> fcall.sendResponse(fb, msg, msgType, seqid); <line26> } catch (java.lang.Exception ex) { <line27> fb.close(); <line28> } <line29> } <line30> } <line31> 	 <line27>	Yes
public class A { <line0> private synchronized void startSpeedTest() { <line1> if (speedTestSocket == null) { <line2> final SpeedTestSocket socket = new SpeedTestSocket(1500); <line3> speedTestSocket = socket; <line4> socket.addSpeedTestListener(this); <line5> updateState(CHANNEL_TEST_ISRUNNING, OnOffType.ON); <line6> updateState(CHANNEL_TEST_START, new DateTimeType()); <line7> updateState(CHANNEL_TEST_END, UnDefType.NULL); <line8> updateProgress(new QuantityType<>(0, Units.PERCENT)); <line9> socket.startDownload(configuration.getDownloadURL()); <line10> } else { <line11> } <line12> } <line13> } <line14> 	 <line2>	Yes
public class A { <line0> public static com.liferay.document.library.kernel.model.DLFileEntryTypeSoap getFileEntryType( <line1> long fileEntryTypeId) throws RemoteException { <line2> try { <line3> com.liferay.document.library.kernel.model.DLFileEntryType returnValue = <line4> DLFileEntryTypeServiceUtil.getFileEntryType(fileEntryTypeId); <line5> return com.liferay.document.library.kernel.model.DLFileEntryTypeSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line4>	No
public class A { <line0> @Override <line1> protected void executeInternal(String siteId) { <line2> long startTime = System.currentTimeMillis(); <line3> try { <line4> HierarchicalConfiguration<ImmutableNode> registrationData = <line5> studioClusterUtils.getClusterConfiguration(); <line6> if (registrationData != null && !registrationData.isEmpty()) { <line7> String localAddress = studioClusterUtils.getClusterNodeLocalAddress(); <line8> ClusterMember localNode = clusterDao.getMemberByLocalAddress(localAddress); <line9> List<ClusterMember> clusterNodes = studioClusterUtils.getClusterNodes(localAddress); <line10> SiteFeed siteFeed = siteService.getSite(siteId); <line11> List<ClusterSiteRecord> clusterSiteRecords = clusterDao.getSiteStateAcrossCluster(siteId); <line12> Optional<ClusterSiteRecord> localNodeRecord = <line13> clusterSiteRecords.stream() <line14> .filter( <line15> x -> <line16> x.getClusterNodeId() == localNode.getId() <line17> && StringUtils.equals(x.getState(), STATE_READY)) <line18> .findFirst(); <line19> if (!localNodeRecord.isPresent()) { <line20> return; <line21> } <line22> long nodesCreated = <line23> clusterSiteRecords.stream() <line24> .filter(x -> StringUtils.equals(x.getState(), STATE_READY)) <line25> .count(); <line26> if (nodesCreated < 1) { <line27> return; <line28> } <line29> boolean success = true; <line30> int publishedReposCreated = <line31> clusterSiteRecords.stream().mapToInt(ClusterSiteRecord::getPublishedRepoCreated).sum(); <line32> if (publishedReposCreated > 0 || siteFeed.getPublishedRepoCreated() > 0) { <line33> boolean siteCheck = checkIfSiteRepoExists(siteId); <line34> if (!siteCheck) { <line35> success = <line36> createSite( <line37> localNode.getId(), siteFeed.getId(), siteId, siteFeed.getSandboxBranch()); <line38> } else { <line39> clusterDao.setPublishedRepoCreated(localNode.getId(), siteFeed.getId()); <line40> } <line41> } else { <line42> success = false; <line43> } <line44> if (success) { <line45> try { <line46> addRemotes(siteId, clusterNodes); <line47> } catch (InvalidRemoteUrlException | ServiceLayerException | CryptoException e) { <line48> } <line49> try { <line50> updateContent(siteFeed.getId(), siteId, clusterNodes, clusterSiteRecords); <line51> } catch (IOException | CryptoException | ServiceLayerException e) { <line52> } <line53> } <line54> } <line55> } catch (SiteNotFoundException e) { <line56> } <line57> long duration = System.currentTimeMillis() - startTime; <line58> } <line59> } <line60> 	 <line3>	Yes
"public class A { <line0> @Override <line1> public ScimGroupExternalMember mapExternalGroup( <line2> final String groupId, final String externalGroup, final String origin, final String zoneId) <line3> throws ScimResourceNotFoundException, MemberAlreadyExistsException { <line4> ScimGroup group = scimGroupProvisioning.retrieve(groupId, zoneId); <line5> if (!StringUtils.hasText(externalGroup)) { <line6> throw new ScimResourceConstraintFailedException( <line7> ""external group must not be null when mapping an external group""); <line8> } <line9> if (!StringUtils.hasText(origin)) { <line10> throw new ScimResourceConstraintFailedException( <line11> ""origin must not be null when mapping an external group""); <line12> } <line13> if (null != group) { <line14> try { <line15> int result = <line16> jdbcTemplate.update( <line17> ADD_EXTERNAL_GROUP_MAPPING_SQL, <line18> ps -> { <line19> ps.setString(1, groupId); <line20> ps.setString(2, externalGroup); <line21> ps.setTimestamp(3, new Timestamp(System.currentTimeMillis())); <line22> ps.setString(4, origin); <line23> ps.setString(5, zoneId); <line24> }); <line25> } catch (DuplicateKeyException e) { <line26> } <line27> return getExternalGroupMap(groupId, externalGroup, origin, zoneId); <line28> } else { <line29> throw new ScimResourceNotFoundException(""Group does not exist""); <line30> } <line31> } <line32> } <line33> "	 <line26>	Yes
public class A { <line0> @Activate <line1> void activate() { <line2> enabled = getSystemPropertyOrEnvVar(FABRIC8_CONFIG_PLUGIN_ENABLED, enabled); <line3> } <line4> } <line5> 	 <line1>	No
public class A { <line0> protected void error(Throwable t) { <line1> } <line2> } <line3> 	 <line1>	Yes
"public class A { <line0> public static Class<?> undecorateClass(Class<?> clazz, ClassLoader classLoader) throws Exception { <line1> if (!clazz.isInterface()) { <line2> throw new IllegalArgumentException(""Only interface classes are supported""); <line3> } <line4> final String className = clazz.getName() + UNDECORATED_CLASS_NAME_SUFFIX; <line5> try { <line6> return classLoader.loadClass(className); <line7> } catch (ClassNotFoundException e) { <line8> Logger log = LoggerFactory.getLogger(RuntimeContextInstantiationStrategyEnhancerHelper.class); <line9> return innerUndecorateInterface(className, clazz, classLoader); <line10> } <line11> } <line12> } <line13> "	 <line8>	No
"public class A { <line0> public static void run(SamplingPipelineOptions options) throws Exception { <line1> FileSystem fs = <line2> FsUtils.getFileSystem( <line3> options.getHdfsSiteConfig(), options.getCoreSiteConfig(), options.getTargetPath()); <line4> Instant batchStart = Instant.now(); <line5> LayerCrawler lc = new LayerCrawler(); <line6> String sampleDownloadPath = getSampleDownloadPath(options); <line7> String latLngExportPath = getLatLngExportPath(options); <line8> if (!ALAFsUtils.exists(fs, latLngExportPath)) { <line9> throw new RuntimeException( <line10> ""LatLng export unavailable. Has LatLng export pipeline been ran ? Not available:"" <line11> + latLngExportPath); <line12> } <line13> Collection<String> latLngFiles = ALAFsUtils.listPaths(fs, latLngExportPath); <line14> String layerList = lc.getRequiredLayers(); <line15> for (String inputFile : latLngFiles) { <line16> lc.crawl(fs, layerList, inputFile, sampleDownloadPath); <line17> } <line18> SamplesToAvro.run(options); <line19> Instant batchFinish = Instant.now(); <line20> if (!options.getKeepLatLngExports()) { <line21> ALAFsUtils.deleteIfExist(fs, latLngExportPath); <line22> } else { <line23> } <line24> } <line25> } <line26> "	 <line22>	No
"public class A { <line0> public void appendJmsProperty( <line1> Message jmsMessage, <line2> Exchange exchange, <line3> org.apache.camel.Message in, <line4> String headerName, <line5> Object headerValue) <line6> throws JMSException { <line7> if (isStandardJMSHeader(headerName)) { <line8> if (headerName.equals(""JMSCorrelationID"") <line9> && (endpoint == null || !endpoint.isUseMessageIDAsCorrelationID())) { <line10> jmsMessage.setJMSCorrelationID( <line11> ExchangeHelper.convertToType(exchange, String.class, headerValue)); <line12> } else if (headerName.equals(""JMSReplyTo"") && headerValue != null) { <line13> if (headerValue instanceof String) { <line14> headerValue = normalizeDestinationName((String) headerValue, true); <line15> } <line16> Destination replyTo = <line17> ExchangeHelper.convertToType(exchange, Destination.class, headerValue); <line18> JmsMessageHelper.setJMSReplyTo(jmsMessage, replyTo); <line19> } else if (headerName.equals(""JMSType"")) { <line20> jmsMessage.setJMSType(ExchangeHelper.convertToType(exchange, String.class, headerValue)); <line21> } else if (headerName.equals(""JMSPriority"")) { <line22> jmsMessage.setJMSPriority( <line23> ExchangeHelper.convertToType(exchange, Integer.class, headerValue)); <line24> } else if (headerName.equals(""JMSDeliveryMode"")) { <line25> JmsMessageHelper.setJMSDeliveryMode(exchange, jmsMessage, headerValue); <line26> } else if (headerName.equals(""JMSExpiration"")) { <line27> jmsMessage.setJMSExpiration( <line28> ExchangeHelper.convertToType(exchange, Long.class, headerValue)); <line29> } else { <line30> } <line31> } else if (shouldOutputHeader(in, headerName, headerValue, exchange)) { <line32> Object value = getValidJMSHeaderValue(headerName, headerValue); <line33> if (value == null <line34> && (endpoint != null <line35> && endpoint.getConfiguration().getAllowAdditionalHeaders() != null)) { <line36> Iterator it = <line37> ObjectHelper.createIterator(endpoint.getConfiguration().getAllowAdditionalHeaders()); <line38> while (it.hasNext()) { <line39> String pattern = (String) it.next(); <line40> if (PatternHelper.matchPattern(headerName, pattern)) { <line41> value = headerValue; <line42> break; <line43> } <line44> } <line45> } <line46> if (value != null) { <line47> String key = jmsKeyFormatStrategy.encodeKey(headerName); <line48> JmsMessageHelper.setProperty(jmsMessage, key, value); <line49> } else if (LOG.isDebugEnabled()) { <line50> } <line51> } <line52> } <line53> } <line54> "	 <line41>	Yes
"public class A { <line0> @Override <line1> public List<CSResultData> getUpstreamCSResultData(String contextIDStr, String nodeName) <line2> throws CSErrorException { <line3> List<CSResultData> rsList = new ArrayList<>(); <line4> if (StringUtils.isBlank(contextIDStr) || StringUtils.isBlank(nodeName)) { <line5> return rsList; <line6> } <line7> try { <line8> ContextID contextID = SerializeHelper.deserializeContextID(contextIDStr); <line9> if (null != contextID) { <line10> rsList = <line11> searchService.searchUpstreamContext( <line12> contextID, nodeName, Integer.MAX_VALUE, CSResultData.class); <line13> } <line14> return rsList; <line15> } catch (ErrorException e) { <line16> throw new CSErrorException( <line17> ErrorCode.DESERIALIZE_ERROR, <line18> ""Deserialize contextID error. contextIDStr : "" + contextIDStr + ""e : "" + e.getDesc()); <line19> } <line20> } <line21> } <line22> "	 <line16>	Yes
"public class A { <line0> @Override <line1> public void initialize() { <line2> Bridge bridge = getBridge(); <line3> if (bridge == null) { <line4> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Bridge Not set""); <line5> return; <line6> } <line7> config = getConfigAs(AcDeviceConfig.class); <line8> initializeBridge(bridge.getHandler(), bridge.getStatus()); <line9> } <line10> } <line11> "	 <line2>	Yes
public class A { <line0> private boolean matchUserGroupRole(RangerAccessRequest request) { <line1> boolean ret = matchAnyUser; <line2> if (!ret) { <line3> if (auditPolicyItem.getUsers() != null && request.getUser() != null) { <line4> ret = auditPolicyItem.getUsers().contains(request.getUser()); <line5> if (!ret && hasResourceOwner) { <line6> String owner = <line7> request.getResource() != null ? request.getResource().getOwnerUser() : null; <line8> ret = request.getUser().equals(owner); <line9> } <line10> } <line11> if (!ret && auditPolicyItem.getGroups() != null && request.getUserGroups() != null) { <line12> ret = CollectionUtils.containsAny(auditPolicyItem.getGroups(), request.getUserGroups()); <line13> } <line14> if (!ret && auditPolicyItem.getRoles() != null) { <line15> ret = <line16> CollectionUtils.containsAny( <line17> auditPolicyItem.getRoles(), <line18> RangerAccessRequestUtil.getCurrentUserRolesFromContext(request.getContext())); <line19> } <line20> } <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> return ret; <line24> } <line25> } <line26> 	 <line19>	No
public class A { <line0> public void deleteFile(File file) { <line1> if (file.exists()) { <line2> if (file.delete()) { <line3> } else { <line4> } <line5> } else { <line6> } <line7> } <line8> } <line9> 	 <line8>	No
public class A { <line0> void initScheduler() { <line1> if (batchSize > 0) { <line2> scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); <line3> scheduledExecutor.scheduleAtFixedRate( <line4> () -> { <line5> try { <line6> flush(); <line7> } catch (Exception e) { <line8> } <line9> }, <line10> flushIntervalMs, <line11> flushIntervalMs, <line12> TimeUnit.MILLISECONDS); <line13> } <line14> } <line15> } <line16> 	 <line8>	Yes
public class A { <line0> protected boolean isScrollTimedOut(String scrollId, CursorResult<C, O> cursorResult) { <line1> if (cursorResult.timedOut()) { <line2> if (unregisterCursor(scrollId)) { <line3> } <line4> return true; <line5> } <line6> return false; <line7> } <line8> } <line9> 	 <line5>	No
public class A { <line0> @Override <line1> public void accept(Response response) { <line2> if (response == null) { <line3> context.setResponse(DEFAULT_RESPONSE); <line4> } else { <line5> context.setResponse(response); <line6> } <line7> context.resume(); <line8> } <line9> } <line10> 	 <line5>	No
"public class A { <line0> @Override <line1> public void initialize() { <line2> AirVisualNodeConfig config = getConfigAs(AirVisualNodeConfig.class); <line3> if (config.address == null) { <line4> updateStatus( <line5> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Node address must be set""); <line6> return; <line7> } <line8> this.nodeAddress = config.address; <line9> this.nodeUsername = config.username; <line10> if (config.password == null) { <line11> updateStatus( <line12> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Node password must be set""); <line13> return; <line14> } <line15> this.nodePassword = config.password; <line16> this.nodeShareName = config.share; <line17> this.refreshInterval = config.refresh * 1000L; <line18> try { <line19> var jsonData = gson.fromJson(getNodeJsonData(), Map.class); <line20> this.isProVersion = jsonData.get(""measurements"") instanceof ArrayList; <line21> } catch (IOException e) { <line22> updateStatus( <line23> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Can't get node json""); <line24> return; <line25> } <line26> if (!this.isProVersion) { <line27> removeProChannels(); <line28> } <line29> schedulePoll(); <line30> } <line31> } <line32> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public void close() { <line2> closeStream(fileReaderShp, ""ESRI Shapefile""); <line3> closeStream(fileReaderDbf, ""DBF Shapefile""); <line4> closeStream(fileReaderPrj, ""PRJ Shapefile""); <line5> try { <line6> if (dbfReader != null) { <line7> dbfReader.close(); <line8> } <line9> } catch (Exception e) { <line10> } <line11> dbfReader = null; <line12> } <line13> } <line14> "	 <line1>	No
public class A { <line0> @Override <line1> public void memoryUsageLow(final long usedMemory, final long maxMemory) { <line2> m_lock.lock(); <line3> try { <line4> m_cond.signalAll(); <line5> } finally { <line6> m_lock.unlock(); <line7> } <line8> } <line9> } <line10> 	 <line2>	Yes
"public class A { <line0> private static void compare( <line1> RegressionEnvironment env, Object[] row, int rowCount, Object theEvent) { <line2> if (row.length < 3 || row[2] == null) { <line3> env.assertListener( <line4> ""s0"", <line5> listener -> { <line6> if (listener.isInvoked()) { <line7> EventBean[] matches = listener.getLastNewData(); <line8> if (matches != null) { <line9> for (int i = 0; i < matches.length; i++) { <line10> } <line11> } <line12> } <line13> assertFalse(""For event "" + theEvent + "" row "" + rowCount, listener.isInvoked()); <line14> }); <line15> return; <line16> } <line17> String[] expected = (String[]) row[2]; <line18> env.assertListener( <line19> ""s0"", <line20> listener -> { <line21> EventBean[] matches = listener.getLastNewData(); <line22> String[] matchesText = null; <line23> if (matches != null) { <line24> matchesText = new String[matches.length]; <line25> for (int i = 0; i < matches.length; i++) { <line26> matchesText[i] = getProps(matches[i]); <line27> } <line28> } else { <line29> if (expected != null) { <line30> for (int i = 0; i < expected.length; i++) { <line31> } <line32> fail(); <line33> } <line34> } <line35> Arrays.sort(expected); <line36> Arrays.sort(matchesText); <line37> assertEquals(""For event "" + theEvent, matches.length, expected.length); <line38> for (int i = 0; i < expected.length; i++) { <line39> if (!expected[i].equals(matchesText[i])) { <line40> assertEquals( <line41> ""Sending event "" + theEvent + "" row "" + rowCount, expected[i], matchesText[i]); <line42> } <line43> } <line44> listener.reset(); <line45> }); <line46> } <line47> } <line48> "	 <line26>	No
public class A { <line0> private void sendGivenCommandAndNextInQueueIfPossible( <line1> final KafkaBasedCommandContext commandContext, <line2> final Supplier<Future<Void>> sendActionSupplier, <line3> final Promise<Void> sendActionCompletedPromise, <line4> final boolean completedPromiseJustCreated) { <line5> final Future<Void> sendActionFuture = sendActionSupplier.get(); <line6> sendActionFuture.onComplete(sendActionCompletedPromise); <line7> if (!queue.isEmpty()) { <line8> if (sendActionFuture.isComplete() && completedPromiseJustCreated) { <line9> vertxContext.runOnContext(v -> sendNextCommandInQueueIfPossible()); <line10> } else { <line11> sendNextCommandInQueueIfPossible(); <line12> } <line13> } <line14> } <line15> } <line16> 	 <line15>	No
public class A { <line0> public void pushNotification(DimeInternalNotification notification) { <line1> Long tenant = notification.getTenant(); <line2> if (mapFifoLists.containsKey(tenant)) { <line3> mapFifoLists.get(tenant).add(notification); <line4> } else { <line5> ConcurrentLinkedQueue<DimeInternalNotification> newFifo = <line6> new ConcurrentLinkedQueue<DimeInternalNotification>(); <line7> newFifo.add(notification); <line8> mapFifoLists.put(tenant, newFifo); <line9> } <line10> } <line11> } <line12> 	 <line9>	No
"public class A { <line0> @Override <line1> public AgiScript determineScript(AgiRequest request, AgiChannel channel) { <line2> AgiScript ret = null; <line3> String script = request.getScript(); <line4> if (script.indexOf(""."") != -1) { <line5> script = script.substring(0, script.indexOf(""."")); <line6> } <line7> if (script.startsWith(""/"")) { <line8> script = script.substring(1); <line9> } <line10> Iterator<String> itr = request.getParameterMap().keySet().iterator(); <line11> while (itr.hasNext()) { <line12> String key = itr.next(); <line13> String val = request.getParameter(key); <line14> if (key.compareToIgnoreCase(""cardNumber"") == 0) val = ""suppressed""; <line15> } <line16> if (handlers.containsKey(script)) { <line17> try { <line18> ret = handlers.get(script).getDeclaredConstructor().newInstance(); <line19> } catch (IllegalArgumentException <line20> | InvocationTargetException <line21> | NoSuchMethodException <line22> | SecurityException <line23> | InstantiationException <line24> | IllegalAccessException e) { <line25> } <line26> } <line27> return ret; <line28> } <line29> } <line30> "	 <line29>	No
"public class A { <line0> public void addGridSet(GridSet gridSet) { <line1> getConfigurations().stream() <line2> .filter(c -> c.canSave(gridSet)) <line3> .findFirst() <line4> .orElseThrow( <line5> () -> <line6> new UnsupportedOperationException( <line7> ""No Configuration is able to save gridset "" + gridSet.getName())) <line8> .addGridSet(gridSet); <line9> } <line10> } <line11> "	 <line2>	No
public class A { <line0> private void saveChangedElements() { <line1> int number = changedElements.size(); <line2> int i = 0; <line3> for (CnATreeElement element : changedElements) { <line4> getDao().merge(element); <line5> if (i % 50 == 0) { <line6> flushAndClearHibernateSession(); <line7> } <line8> i++; <line9> if (log.isDebugEnabled()) { <line10> } <line11> } <line12> } <line13> } <line14> 	 <line2>	No
public class A { <line0> public synchronized void startMatch() { <line1> if (table.getState() == TableState.STARTING) { <line2> try { <line3> if (table.isTournamentSubTable()) { <line4> } else { <line5> managerFactory <line6> .userManager() <line7> .getUser(userId) <line8> .ifPresent( <line9> user -> { <line10> }); <line11> } <line12> match.startMatch(); <line13> startGame(null); <line14> } catch (GameException ex) { <line15> match.endGame(); <line16> } <line17> } <line18> } <line19> } <line20> 	 <line0>	No
public class A { <line0> @Override <line1> void onComplete( <line2> boolean operationResult, <line3> IOException exception, <line4> OMMetrics omMetrics, <line5> Result result, <line6> long trxnLogIndex, <line7> AuditLogger auditLogger, <line8> Map<String, String> auditMap) { <line9> switch (result) { <line10> case SUCCESS: <line11> if (LOG.isDebugEnabled()) { <line12> if (operationResult) { <line13> } else { <line14> } <line15> } <line16> break; <line17> case FAILURE: <line18> break; <line19> default: <line20> } <line21> if (ozoneAcls != null) { <line22> auditMap.put(OzoneConsts.ACL, ozoneAcls.toString()); <line23> } <line24> auditLog( <line25> auditLogger, <line26> buildAuditMessage(OMAction.ADD_ACL, auditMap, exception, getOmRequest().getUserInfo())); <line27> } <line28> } <line29> 	 <line20>	Yes
public class A { <line0> private static String unsanitizeDn(String sanitizedDn) { <line1> if (StringUtils.isEmpty(sanitizedDn)) { <line2> return sanitizedDn; <line3> } else { <line4> String unsanitizedDn = sanitizedDn.replaceAll(ESCAPED_GT, GT).replaceAll(ESCAPED_LT, LT); <line5> if (!unsanitizedDn.equals(sanitizedDn)) { <line6> } <line7> return unsanitizedDn; <line8> } <line9> } <line10> } <line11> 	 <line6>	Yes
public class A { <line0> private void createCloudConnection() throws LoginException { <line1> SleepIQCloudConfiguration bindingConfig = getConfigAs(SleepIQCloudConfiguration.class); <line2> Configuration cloudConfig = <line3> new Configuration() <line4> .withUsername(bindingConfig.username) <line5> .withPassword(bindingConfig.password) <line6> .withLogging(logger.isDebugEnabled()); <line7> cloud = SleepIQ.create(cloudConfig); <line8> cloud.login(); <line9> } <line10> } <line11> 	 <line0>	No
"public class A { <line0> @Override <line1> public void run() { <line2> Properties props = new Properties(); <line3> props.put(""bootstrap.servers"", getBootStrapServer()); <line4> props.put(""group.id"", getGroupName()); <line5> props.put(""key.deserializer"", ""org.apache.kafka.common.serialization.StringDeserializer""); <line6> props.put(""value.deserializer"", ""org.apache.kafka.common.serialization.StringDeserializer""); <line7> props.put(""enable.auto.commit"", ""true""); <line8> props.put(""auto.commit.interval.ms"", ""1000""); <line9> consumer = new KafkaConsumer<>(props); <line10> consumer.subscribe(Arrays.asList(""USER_TOPIC"")); <line11> while (!closed.get()) { <line12> ConsumerRecords<String, String> records = consumer.poll(100); <line13> for (ConsumerRecord<String, String> record : records) { <line14> } <line15> } <line16> } <line17> } <line18> "	 <line8>	No
public class A { <line0> @Override <line1> public List<TriggerInfo> getTriggerInfos(TriggerInfoContext context) { <line2> for (Notification notification : context.getNotifications()) { <line3> if (!isSatisfied(context.getSchedule(), notification)) { <line4> continue; <line5> } <line6> Long logicalStartTime = getLogicalStartTime(notification); <line7> if (logicalStartTime == null) { <line8> continue; <line9> } <line10> TriggerInfo triggerInfo = new DefaultTimeTriggerInfo(getCronExpression(), logicalStartTime); <line11> return Collections.singletonList(triggerInfo); <line12> } <line13> return Collections.emptyList(); <line14> } <line15> } <line16> 	 <line8>	Yes
"public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public List<OrchestratorStore> createOrchestratorStores( <line2> final List<OrchestratorStoreRequestDTO> request) { <line3> if (request == null || request.isEmpty()) { <line4> throw new InvalidParameterException( <line5> ""OrchestratorStoreRequestDTOList "" + EMPTY_OR_NULL_ERROR_MESSAGE); <line6> } <line7> try { <line8> final List<OrchestratorStore> savedOrchestratorStoreEntries = new ArrayList<>(); <line9> for (final OrchestratorStoreRequestDTO orchestratorStoreRequestDTO : request) { <line10> final OrchestratorStore orchStore = saveOrchestratorStoreEntry(orchestratorStoreRequestDTO); <line11> if (orchStore != null) { <line12> savedOrchestratorStoreEntries.add(orchStore); <line13> } <line14> } <line15> return savedOrchestratorStoreEntries; <line16> } catch (final Exception ex) { <line17> throw new ArrowheadException(CoreCommonConstants.DATABASE_OPERATION_EXCEPTION_MSG); <line18> } <line19> } <line20> } <line21> "	 <line6>	No
public class A { <line0> private <T> T mutableField( <line1> final String fieldName, <line2> @Nullable final T existingValue, <line3> @Nullable final T updatedValue, <line4> final InvoicePluginApi invoicePlugin) { <line5> if (updatedValue != null) { <line6> return updatedValue; <line7> } else { <line8> return existingValue; <line9> } <line10> } <line11> } <line12> 	 <line6>	Yes
public class A { <line0> @Override <line1> protected void beforeTopologyInstalled( <line2> int topologyId, <line3> boolean startRebalance, <line4> ConsistentHash previousWriteCh, <line5> ConsistentHash newWriteCh) { <line6> for (int segment = 0; segment < newWriteCh.getNumSegments(); ++segment) { <line7> if (!newWriteCh.isSegmentLocalToNode(rpcManager.getAddress(), segment)) { <line8> cancelTransfers(IntSets.immutableSet(segment)); <line9> svm.unregisterSegment(segment); <line10> } <line11> } <line12> IntSet addedSegments = getOwnedSegments(newWriteCh); <line13> if (previousWriteCh != null && !addedSegments.isEmpty()) { <line14> addedSegments.removeAll(getOwnedSegments(previousWriteCh)); <line15> } <line16> svm.setTopologyId(topologyId); <line17> if (previousWriteCh == null || !isFetchEnabled) { <line18> svm.setOwnedSegments(addedSegments); <line19> return; <line20> } <line21> if (!addedSegments.isEmpty()) { <line22> svm.setValuesTransferTopology(topologyId); <line23> for (PrimitiveIterator.OfInt segmentIterator = addedSegments.iterator(); <line24> segmentIterator.hasNext(); ) { <line25> svm.registerSegment(segmentIterator.nextInt()); <line26> } <line27> } <line28> } <line29> } <line30> 	 <line18>	Yes
public class A { <line0> @Override <line1> public OutputStream openOutputStreamFor(String location) throws Exception { <line2> return null; <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> protected boolean isValidDate(LocalDate date) { <line1> try { <line2> if (date != null) { <line3> IsoChronology.INSTANCE.date(date); <line4> } <line5> return true; <line6> } catch (DateTimeException ex) { <line7> return false; <line8> } <line9> } <line10> } <line11> 	 <line8>	No
"public class A { <line0> private static List<Thread> listThreads(ThreadGroup group, String indent) { <line1> List<Thread> threadToReturn = new ArrayList<Thread>(); <line2> int nt = group.activeCount(); <line3> Thread[] threads = new Thread[nt * 2 + 10]; <line4> nt = group.enumerate(threads, false); <line5> for (int i = 0; i < nt; i++) { <line6> Thread t = threads[i]; <line7> threadToReturn.add(t); <line8> } <line9> int ng = group.activeGroupCount(); <line10> ThreadGroup[] groups = new ThreadGroup[ng * 2 + 10]; <line11> ng = group.enumerate(groups, false); <line12> for (int i = 0; i < ng; i++) { <line13> threadToReturn.addAll(listThreads(groups[i], indent + ""  "")); <line14> } <line15> return threadToReturn; <line16> } <line17> } <line18> "	 <line5>	No
public class A { <line0> @Override <line1> public void afterPropertiesSet() { <line2> super.afterPropertiesSet(); <line3> if (log.isInfoEnabled()) { <line4> } <line5> } <line6> } <line7> 	 <line4>	Yes
"public class A { <line0> @Test(enabled = false) <line1> public void u1SuspendU2KillProcessInstances() throws Exception { <line2> String startTime = TimeUtil.getTimeWrtSystemTime(0); <line3> String endTime = TimeUtil.addMinsToTime(startTime, 5); <line4> String midTime = TimeUtil.addMinsToTime(startTime, 2); <line5> bundles[0].setProcessValidity(startTime, endTime); <line6> bundles[0].setProcessPeriodicity(1, Frequency.TimeUnit.minutes); <line7> bundles[0].setProcessConcurrency(5); <line8> bundles[0].setInputFeedPeriodicity(1, Frequency.TimeUnit.minutes); <line9> bundles[0].setInputFeedDataPath(feedInputPath); <line10> bundles[0].setProcessInput(""now(0,0)"", ""now(0,4)""); <line11> String prefix = bundles[0].getFeedDataPathPrefix(); <line12> HadoopUtil.deleteDirIfExists(prefix.substring(1), clusterFS); <line13> List<String> dataDates = <line14> TimeUtil.getMinuteDatesOnEitherSide(TimeUtil.addMinsToTime(startTime, -2), endTime, 0); <line15> HadoopUtil.flattenAndPutDataInFolder(clusterFS, OSUtil.NORMAL_INPUT, prefix, dataDates); <line16> bundles[0].submitFeedsScheduleProcess(prism); <line17> InstanceUtil.waitTillInstanceReachState( <line18> clusterOC, <line19> bundles[0].getProcessName(), <line20> 3, <line21> CoordinatorAction.Status.RUNNING, <line22> EntityType.PROCESS); <line23> InstanceUtil.waitTillInstanceReachState( <line24> clusterOC, <line25> bundles[0].getProcessName(), <line26> 2, <line27> CoordinatorAction.Status.WAITING, <line28> EntityType.PROCESS); <line29> InstancesResult r = <line30> prism <line31> .getProcessHelper() <line32> .getProcessInstanceStatus( <line33> bundles[0].getProcessName(), ""?start="" + startTime + ""&end="" + endTime); <line34> InstanceUtil.validateResponse(r, 5, 3, 0, 2, 0); <line35> r = <line36> prism <line37> .getProcessHelper() <line38> .getProcessInstanceSuspend( <line39> bundles[0].getProcessName(), ""?start="" + startTime + ""&end="" + midTime); <line40> InstanceUtil.validateResponse(r, 3, 0, 3, 0, 0); <line41> r = <line42> prism <line43> .getProcessHelper() <line44> .getProcessInstanceKill( <line45> bundles[0].getProcessName(), <line46> ""?start="" + startTime + ""&end="" + endTime, <line47> MerlinConstants.USER2_NAME); <line48> InstanceUtil.validateResponse(r, 5, 0, 3, 2, 0); <line49> } <line50> } <line51> "	 <line4>	No
public class A { <line0> @After <line1> public void teardownTest() { <line2> try { <line3> if (configurationProvider != null) configurationProvider.close(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	 <line6>	No
public class A { <line0> public static <T> T getClassInstance(String context, String clazzName, Class<T> base) <line1> throws IOException, ReflectiveOperationException { <line2> T instance; <line3> Class<? extends T> clazz = ClassLoaderUtil.loadClass(context, clazzName, base); <line4> instance = clazz.getDeclaredConstructor().newInstance(); <line5> return instance; <line6> } <line7> } <line8> 	 <line3>	No
"public class A { <line0> @Override <line1> protected void doInit() throws Exception { <line2> super.doInit(); <line3> if (entityManagerFactory == null) { <line4> Map<String, EntityManagerFactory> map = <line5> getCamelContext().getRegistry().findByTypeWithName(EntityManagerFactory.class); <line6> if (map != null) { <line7> if (map.size() == 1) { <line8> entityManagerFactory = map.values().iterator().next(); <line9> } else { <line10> } <line11> } <line12> } else { <line13> } <line14> if (transactionManager == null) { <line15> Map<String, PlatformTransactionManager> map = <line16> getCamelContext().getRegistry().findByTypeWithName(PlatformTransactionManager.class); <line17> if (map != null) { <line18> if (map.size() == 1) { <line19> transactionManager = map.values().iterator().next(); <line20> LOG.info( <line21> ""Using TransactionManager found in registry with id [{}] {}"", <line22> map.keySet().iterator().next(), <line23> transactionManager); <line24> } else { <line25> } <line26> } <line27> } else { <line28> } <line29> if (transactionManager == null) { <line30> Map<String, TransactionTemplate> map = <line31> getCamelContext().getRegistry().findByTypeWithName(TransactionTemplate.class); <line32> if (map != null) { <line33> if (map.size() == 1) { <line34> transactionManager = map.values().iterator().next().getTransactionManager(); <line35> } else { <line36> } <line37> } <line38> } <line39> if (entityManagerFactory == null) { <line40> } <line41> if (transactionManager == null) { <line42> } <line43> } <line44> } <line45> "	 <line36>	Yes
public class A { <line0> public void run() { <line1> TLSServer.serve(); <line2> setStatus(ServerStatus.STOPPED); <line3> } <line4> } <line5> 	 <line2>	No
"public class A { <line0> @Around(""dataProcess()"") <line1> public Object around(ProceedingJoinPoint pjp) throws Throwable { <line2> Object o = null; <line3> String value = getKey(pjp); <line4> String requestId = DistributedLock.getLockUUID(); <line5> String key = this.getClass().getSimpleName() + value; <line6> try { <line7> DistributedLock.waitGetDistributedLock(key, requestId); <line8> o = pjp.proceed(); <line9> return o; <line10> } catch (Throwable e) { <line11> throw e; <line12> } finally { <line13> DistributedLock.releaseDistributedLock(requestId, key); <line14> } <line15> } <line16> } <line17> "	 <line10>	No
"public class A { <line0> private void jFreeChartExport() { <line1> try { <line2> final ExportJFreeChart exportJFreeChart = <line3> (ExportJFreeChart) scriptExecutionResult.getResult(); <line4> final StringBuilder sb = new StringBuilder(); <line5> sb.append(""pf_chart_""); <line6> sb.append(DateHelper.getTimestampAsFilenameSuffix(new Date())); <line7> final Response response = getResponse(); <line8> final String extension = exportJFreeChart.write(response.getOutputStream()); <line9> sb.append('.').append(extension); <line10> final String filename = sb.toString(); <line11> final int width = exportJFreeChart.getWidth(); <line12> final int height = exportJFreeChart.getHeight(); <line13> final JFreeChartImage image = <line14> new JFreeChartImage( <line15> ""image"", <line16> exportJFreeChart.getJFreeChart(), <line17> exportJFreeChart.getImageType(), <line18> width, <line19> height); <line20> image.add(AttributeModifier.replace(""width"", String.valueOf(width))); <line21> image.add(AttributeModifier.replace(""height"", String.valueOf(height))); <line22> imageResultContainer.removeAll(); <line23> imageResultContainer.add(image).setVisible(true); <line24> ((WebResponse) response).setAttachmentHeader(filename); <line25> ((WebResponse) response).setContentType(DownloadUtils.getContentType(filename)); <line26> response.getOutputStream().flush(); <line27> } catch (final Exception ex) { <line28> error(getLocalizedMessage(""error"", ex.getMessage())); <line29> } <line30> } <line31> } <line32> "	 <line29>	Yes
public class A { <line0> @Override <line1> public ResponseTime mapRow(Result result, int rowNum) throws Exception { <line2> if (result.isEmpty()) { <line3> return null; <line4> } <line5> final byte[] rowKey = getOriginalKey(result.getRow()); <line6> ResponseTime responseTime = createResponseTime(rowKey); <line7> for (Cell cell : result.rawCells()) { <line8> if (CellUtil.matchingFamily( <line9> cell, HbaseColumnFamily.MAP_STATISTICS_SELF_VER2_COUNTER.getName())) { <line10> recordColumn(responseTime, cell); <line11> } <line12> if (logger.isTraceEnabled()) { <line13> String columnFamily = <line14> Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength()); <line15> } <line16> } <line17> return responseTime; <line18> } <line19> } <line20> 	 <line12>	No
"public class A { <line0> protected void verifyReceivedFields(Map<Object, Object> valueMap) { <line1> _receivedFields = valueMap; <line2> for (Map.Entry<Object, Matcher<?>> entry : _fieldMatchers.entrySet()) { <line3> @SuppressWarnings(""unchecked"") <line4> Matcher<Object> matcher = (Matcher<Object>) entry.getValue(); <line5> Object field = entry.getKey(); <line6> assertThat(""Field "" + field + "" value should match"", valueMap.get(field), matcher); <line7> } <line8> } <line9> } <line10> "	 <line5>	No
public class A { <line0> @Override <line1> public void removeAppenderatorsForTask(String taskId, String dataSource) { <line2> synchronized (this) { <line3> DatasourceBundle datasourceBundle = datasourceBundles.get(dataSource); <line4> if (datasourceBundle == null) { <line5> } else { <line6> List<Appenderator> existingAppenderators = <line7> datasourceBundle.taskAppenderatorMap.remove(taskId); <line8> if (existingAppenderators == null) { <line9> } <line10> if (datasourceBundle.taskAppenderatorMap.isEmpty()) { <line11> datasourceBundles.remove(dataSource); <line12> } <line13> } <line14> } <line15> } <line16> } <line17> 	 <line5>	Yes
"public class A { <line0> public static void deleteLayoutPageTemplateCollections( <line1> HttpPrincipal httpPrincipal, long[] layoutPageTemplateCollectionIds) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> LayoutPageTemplateCollectionServiceUtil.class, <line7> ""deleteLayoutPageTemplateCollections"", <line8> _deleteLayoutPageTemplateCollectionsParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, layoutPageTemplateCollectionIds); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	 <line19>	Yes
public class A { <line0> private Iterator<StorageInputStream> createIterator(URI location) { <line1> if (!handles(location)) { <line2> return Collections.emptyIterator(); <line3> } <line4> File parent = new File(location.getSchemeSpecificPart()); <line5> Iterator<File> fileIt; <line6> if (parent.isDirectory()) { <line7> fileIt = new FileIterator(parent); <line8> } else { <line9> List<File> files = new ArrayList<>(1); <line10> files.add(parent); <line11> fileIt = files.iterator(); <line12> } <line13> return new MyIterator(fileIt); <line14> } <line15> } <line16> 	 <line7>	Yes
"public class A { <line0> @Override <line1> public void setUpClass() throws IOException, InterruptedException { <line2> try { <line3> tmpDir.create(); <line4> MiniAccumuloConfig miniCfg = new MiniAccumuloConfig(tmpDir.getRoot(), PASSWORD); <line5> miniCfg.setInstanceName(""goraTest""); <line6> miniCfg.setZooKeeperPort(56321); <line7> cluster = new MiniAccumuloCluster(miniCfg); <line8> cluster.start(); <line9> } catch (Exception e) { <line10> tearDownClass(); <line11> } <line12> } <line13> } <line14> "	 <line8>	No
public class A { <line0> public void persist(StgSysSystem transientInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().persist(transientInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> private void processThermometer(JablotronServiceDetailSegment segment) { <line1> String segmentId = segment.getSegmentId().toLowerCase(); <line2> Channel channel = getThing().getChannel(segmentId); <line3> if (channel == null) { <line4> createTempChannel(segmentId, segment.getSegmentName()); <line5> processThermometer(segment); <line6> return; <line7> } <line8> updateTemperatureChannel(channel, segment); <line9> } <line10> } <line11> 	 <line8>	No
public class A { <line0> @Override <line1> public void addListener( <line2> @Nonnull final String category, <line3> @Nonnull final String feedName, <line4> @Nonnull final CleanupListener listener) { <line5> getLogger() <line6> springService.getBean(CleanupEventConsumer.class).addListener(category, feedName, listener); <line7> } <line8> } <line9> 	 <line0>	No
public class A { <line0> @Override <line1> public void importData( <line2> ProjectImportRequest aRequest, Project aProject, ExportedProject aExProject, ZipFile aZip) { <line3> ExportedDocumentRepository[] exportedDocumentRepositories = <line4> aExProject.getArrayProperty(KEY, ExportedDocumentRepository.class); <line5> for (ExportedDocumentRepository exportedDocumentRepository : exportedDocumentRepositories) { <line6> DocumentRepository documentRepository = new DocumentRepository(); <line7> documentRepository.setName(exportedDocumentRepository.getName()); <line8> documentRepository.setProperties(exportedDocumentRepository.getProperties()); <line9> documentRepository.setType(exportedDocumentRepository.getType()); <line10> documentRepository.setProject(aProject); <line11> externalSearchService.createOrUpdateDocumentRepository(documentRepository); <line12> } <line13> int n = exportedDocumentRepositories.length; <line14> } <line15> } <line16> 	 <line9>	No
public class A { <line0> public DashboardActivityTab gotoActivityTab() { <line1> existingElement(activityTabBody); <line2> clickWhenTabEnabled(readyElement(activityTab)); <line3> return new DashboardActivityTab(getDriver()); <line4> } <line5> } <line6> 	 <line1>	Yes
public class A { <line0> private boolean performTaskFixes( <line1> JobTask task, <line2> Set<String> expectedHostsWithTask, <line3> Set<String> expectedHostsMissingTask, <line4> Set<String> unexpectedHostsWithTask) { <line5> if (expectedHostsWithTask.isEmpty()) { <line6> if (unexpectedHostsWithTask.isEmpty()) { <line7> recreateTask(task); <line8> return true; <line9> } <line10> Iterator<String> unexpectedHostsIter = unexpectedHostsWithTask.iterator(); <line11> List<JobTaskReplica> newReplicas = new ArrayList<>(); <line12> task.setHostUUID(unexpectedHostsIter.next()); <line13> while (unexpectedHostsIter.hasNext()) { <line14> newReplicas.add(new JobTaskReplica(unexpectedHostsIter.next(), task.getJobUUID(), 0, 0)); <line15> } <line16> task.setReplicas(newReplicas); <line17> return true; <line18> } else { <line19> boolean changed = false; <line20> if (!expectedHostsMissingTask.isEmpty()) { <line21> swapTask(task, expectedHostsWithTask.iterator().next(), false, 0); <line22> copyTaskToReplicas(task); <line23> changed = true; <line24> } <line25> for (String unexpectedHost : unexpectedHostsWithTask) { <line26> deleteTask(task.getJobUUID(), unexpectedHost, task.getTaskID(), false); <line27> } <line28> return changed; <line29> } <line30> } <line31> } <line32> 	 <line10>	No
"public class A { <line0> @Override <line1> protected void doStart() throws Exception { <line2> if (levelDBFile == null && persistentFileName != null) { <line3> levelDBFile = new LevelDBFile(); <line4> levelDBFile.setSync(isSync()); <line5> levelDBFile.setFileName(persistentFileName); <line6> } <line7> ObjectHelper.notNull(levelDBFile, ""Either set a persistentFileName or a levelDBFile""); <line8> ObjectHelper.notNull(repositoryName, ""repositoryName""); <line9> ServiceHelper.startService(levelDBFile); <line10> int current = size(getRepositoryName()); <line11> int completed = size(getRepositoryNameCompleted()); <line12> if (current > 0) { <line13> } else { <line14> } <line15> if (completed > 0) { <line16> } else { <line17> } <line18> } <line19> } <line20> "	 <line4>	No
"public class A { <line0> @Override <line1> public AnomalyDetectionFunction getFunction( <line2> StarTreeConfig starTreeConfig, <line3> AnomalyDatabaseConfig dbconfig, <line4> FunctionTableRow functionTableRow) <line5> throws IllegalFunctionException, ClassCastException { <line6> RuleBasedFunctionTableRow ruleBasedFunctionTableRow = <line7> (RuleBasedFunctionTableRow) functionTableRow; <line8> TimeGranularity aggregateGranularity = <line9> new TimeGranularity( <line10> ruleBasedFunctionTableRow.getAggregateSize(), <line11> ruleBasedFunctionTableRow.getAggregateUnit()); <line12> if (aggregateGranularity.getSize() <= 0) { <line13> throw new IllegalFunctionException(""aggregate size must be positive""); <line14> } <line15> TimeGranularity baselineGranularity = <line16> new TimeGranularity( <line17> ruleBasedFunctionTableRow.getBaselineSize(), <line18> ruleBasedFunctionTableRow.getBaselineUnit()); <line19> if (baselineGranularity.getSize() <= 0) { <line20> throw new IllegalFunctionException(""baseline size must be positive""); <line21> } <line22> DimensionKeyMatchTable<Double> deltaTable = null; <line23> if (ruleBasedFunctionTableRow.getDeltaTableName() != null <line24> && ruleBasedFunctionTableRow.getDeltaTableName().length() > 0) { <line25> deltaTable = <line26> DeltaTable.load(dbconfig, starTreeConfig, ruleBasedFunctionTableRow.getDeltaTableName()); <line27> } <line28> AnomalyDetectionFunction func; <line29> switch (RuleTypes.valueOf(ruleBasedFunctionTableRow.getFunctionName().toUpperCase())) { <line30> case PERCENTCHANGE: <line31> { <line32> func = <line33> new AnomalyDetectionFunctionPercentChange( <line34> baselineGranularity, <line35> aggregateGranularity, <line36> ruleBasedFunctionTableRow.getMetricName(), <line37> ruleBasedFunctionTableRow.getDelta()) <line38> .setDeltaTable(deltaTable); <line39> break; <line40> } <line41> case ABSOLUTECHANGE: <line42> { <line43> func = <line44> new AnomalyDetectionFunctionAbsoluteChange( <line45> baselineGranularity, <line46> aggregateGranularity, <line47> ruleBasedFunctionTableRow.getMetricName(), <line48> ruleBasedFunctionTableRow.getDelta()) <line49> .setDeltaTable(deltaTable); <line50> break; <line51> } <line52> default: <line53> { <line54> throw new IllegalFunctionException( <line55> ""no rule of type "" + ruleBasedFunctionTableRow.getFunctionName()); <line56> } <line57> } <line58> int consecutiveBuckets = ruleBasedFunctionTableRow.getConsecutiveBuckets(); <line59> if (consecutiveBuckets > 1) { <line60> func = new AnomalyDetectionFunctionConsecutive(func, consecutiveBuckets); <line61> } <line62> String cronDefinition = ruleBasedFunctionTableRow.getCronDefinition(); <line63> if (cronDefinition != null && cronDefinition.length() > 0) { <line64> func = new AnomalyDetectionFunctionCronDefinition(func, cronDefinition); <line65> } <line66> func.init(starTreeConfig, new FunctionProperties()); <line67> return func; <line68> } <line69> } <line70> "	 <line1>	No
public class A { <line0> @Override <line1> public void logout( <line2> HttpServletRequest request, HttpServletResponse response, Authentication authentication) { <line3> String cookie = rememberMeCookieDecoder.exctractRememberMeCookieValue(request); <line4> if (cookie != null) { <line5> String[] seriesAndToken = rememberMeCookieDecoder.extractSeriesAndToken(cookie); <line6> if (logger.isDebugEnabled()) { <line7> } <line8> cancelCookie(request, response); <line9> jdbcTemplate.update(REMOVE_TOKEN_QUERY, seriesAndToken); <line10> tokenCache.remove(seriesAndToken[0]); <line11> validateTokenCache(); <line12> } <line13> } <line14> } <line15> 	 <line7>	Yes
public class A { <line0> static HeaderExtractor addressExtractor( <line1> ThrowingFunction<Mail, String[]> addressGetter, String fallbackHeaderName) { <line2> return mail -> { <line3> try { <line4> return toAddressContents(addressGetter.apply(mail)); <line5> } catch (Exception e) { <line6> return Stream.of(mail.getMessage().getHeader(fallbackHeaderName)) <line7> .map(MimeUtil::unscrambleHeaderValue); <line8> } <line9> }; <line10> } <line11> } <line12> 	 <line6>	Yes
"public class A { <line0> public void reportFailedApiCall( <line1> ApiKey apiKey, int objectTypes, long then, String query, String stackTrace, String reason) { <line2> StringBuilder sb = <line3> new StringBuilder(""module=updateQueue component=updater action=countFailedApiCall"") <line4> .append("" connector="" + connector().getName()) <line5> .append("" objectTypes="" + objectTypes) <line6> .append("" apiKeyId="") <line7> .append(apiKey.getId()) <line8> .append("" guestId="") <line9> .append(apiKey.getGuestId()) <line10> .append("" time="") <line11> .append(ISODateTimeFormat.dateTimeNoMillis().print(then)) <line12> .append("" query="") <line13> .append(query) <line14> .append("" reason=\"""") <line15> .append(reason) <line16> .append(""\"""") <line17> .append("" stackTrace=<![CDATA["") <line18> .append(stackTrace) <line19> .append(""]]>""); <line20> } <line21> } <line22> "	 <line11>	No
"public class A { <line0> private Object resolveInterfaceAndClassLoader( <line1> OpenLService service, <line2> ServiceDescription serviceDescription, <line3> RulesInstantiationStrategy instantiationStrategy) <line4> throws RuleServiceInstantiationException, RulesInstantiationException { <line5> String serviceClassName = service.getServiceClassName(); <line6> Class<?> serviceClass; <line7> if (serviceClassName != null) { <line8> try { <line9> serviceClass = service.getClassLoader().loadClass(serviceClassName.trim()); <line10> if (serviceClass.isInterface()) { <line11> Class<?> interfaceForInstantiationStrategy = <line12> RuleServiceInstantiationFactoryHelper.buildInterfaceForInstantiationStrategy( <line13> serviceClass, <line14> instantiationStrategy.getClassLoader(), <line15> serviceDescription.isProvideRuntimeContext(), <line16> serviceDescription.isProvideVariations()); <line17> instantiationStrategy.setServiceClass(interfaceForInstantiationStrategy); <line18> service.setServiceClass(serviceClass); <line19> return instantiationStrategy.instantiate(); <line20> } <line21> throw new RuleServiceRuntimeException( <line22> String.format( <line23> ""Failed to apply service class '%s'. Interface is expected, but class is found."", <line24> serviceClass)); <line25> } catch (ClassNotFoundException | NoClassDefFoundError e) { <line26> throw new RuleServiceRuntimeException( <line27> String.format(""Failed to load a service class '%s'."", serviceClassName), e); <line28> } <line29> } <line30> Class<?> instanceClass = instantiationStrategy.getInstanceClass(); <line31> Object serviceTarget = instantiationStrategy.instantiate(); <line32> serviceClass = <line33> processGeneratedServiceClass( <line34> serviceDescription, service.getOpenClass(), instanceClass, service.getClassLoader()); <line35> service.setServiceClassName(null); <line36> service.setServiceClass(serviceClass); <line37> return serviceTarget; <line38> } <line39> } <line40> "	 <line30>	Yes
"public class A { <line0> @Override <line1> public TimeSeries getValues( <line2> String resourceId, Instant from, Instant to, DataResolution resolution, ZoneId zoneId) { <line3> final String influxGrouping = dataResolutionToInfluxGrouping(resolution); <line4> final List<Tuple<Instant, Instant>> periods = getPeriods(from, to, resolution, zoneId); <line5> final List<String> labels = new ArrayList<>(); <line6> final List<Double> values = new ArrayList<>(); <line7> final InfluxProviderConfiguration.InfluxProviderSource source = getSource(resolution); <line8> for (final Tuple<Instant, Instant> period : periods) { <line9> final Query query = <line10> BoundParameterQuery.QueryBuilder.newQuery( <line11> ""SELECT "" <line12> + source.getAggregation() <line13> + ""("" <line14> + source.getAggregationVariable() <line15> + "") FROM "" <line16> + source.getMeasurement() <line17> + "" WHERE "" <line18> + source.getResourceIdName() <line19> + ""=$resourceId AND time>=$from AND time<=$to"" <line20> + influxGrouping) <line21> .bind(""resourceId"", resourceId) <line22> .bind(""from"", period.getA()) <line23> .bind(""to"", period.getB()) <line24> .create(); <line25> try { <line26> final QueryResult results = service.getInfluxDB().query(query); <line27> final TimeSeries currentViews = queryResultToTimeSeries(results); <line28> labels.addAll(currentViews.getLabels()); <line29> values.addAll(currentViews.getValues()); <line30> } catch (InfluxDBIOException e) { <line31> if (e.getCause() instanceof ConnectException) { <line32> } else { <line33> throw e; <line34> } <line35> } <line36> } <line37> final Double total = <line38> ""SUM"".equalsIgnoreCase(source.getAggregation()) <line39> ? values.stream().mapToDouble(v -> v).sum() <line40> : null; <line41> return new TimeSeries(labels, values, total); <line42> } <line43> } <line44> "	 <line29>	No
"public class A { <line0> private List<SmallCategory> getCategoryLeaf( <line1> String nodeRootCode, String langCode, boolean completeTitle) { <line2> List<SmallCategory> categories = new ArrayList<SmallCategory>(); <line3> try { <line4> Category root = this.getCategoryManager().getCategory(nodeRootCode); <line5> this.addSmallCategory(categories, root, langCode, completeTitle); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(""Errore loading categories leafs""); <line8> } <line9> return categories; <line10> } <line11> } <line12> "	 <line7>	Yes
public class A { <line0> private void onFinish(SingularityExecutorTask task, Protos.TaskState taskState) { <line1> processKiller.cancelDestroyFuture(task.getTaskId()); <line2> tasks.remove(task.getTaskId()); <line3> processRunningTasks.remove(task.getTaskId()); <line4> processBuildingTasks.remove(task.getTaskId()); <line5> task.cleanup(taskState); <line6> ListeningExecutorService executorService = taskToShellCommandPool.remove(task.getTaskId()); <line7> if (executorService != null) { <line8> executorService.shutdownNow(); <line9> try { <line10> executorService.awaitTermination(5, TimeUnit.MILLISECONDS); <line11> } catch (InterruptedException e) { <line12> } <line13> } <line14> logging.stopTaskLogger(task.getTaskId(), task.getLogbackLog()); <line15> checkIdleExecutorShutdown(task.getDriver()); <line16> } <line17> } <line18> 	 <line8>	No
public class A { <line0> @Override <line1> public void initialize() { <line2> MeteoAlerteConfiguration config = getConfigAs(MeteoAlerteConfiguration.class); <line3> updateStatus(ThingStatus.UNKNOWN); <line4> queryUrl = String.format(URL, config.department); <line5> refreshJob = <line6> scheduler.scheduleWithFixedDelay( <line7> this::updateAndPublish, 0, config.refresh, TimeUnit.MINUTES); <line8> } <line9> } <line10> 	 <line2>	Yes
"public class A { <line0> void readLog() { <line1> byte[] buff = new byte[16]; <line2> ByteBuffer bb = ByteBuffer.wrap(buff); <line3> LogMark mark = new LogMark(); <line4> for (File dir : ledgerDirsManager.getAllLedgerDirs()) { <line5> File file = new File(dir, lastMarkFileName); <line6> try { <line7> try (FileInputStream fis = new FileInputStream(file)) { <line8> int bytesRead = fis.read(buff); <line9> if (bytesRead != 16) { <line10> throw new IOException( <line11> ""Couldn't read enough bytes from lastMark."" <line12> + "" Wanted "" <line13> + 16 <line14> + "", got "" <line15> + bytesRead); <line16> } <line17> } <line18> bb.clear(); <line19> mark.readLogMark(bb); <line20> if (curMark.compare(mark) < 0) { <line21> curMark.setLogMark(mark.getLogFileId(), mark.getLogFileOffset()); <line22> } <line23> } catch (IOException e) { <line24> } <line25> } <line26> } <line27> } <line28> "	 <line24>	Yes
public class A { <line0> @Test <line1> public void testBlockInSourceTaskStop() throws Exception { <line2> createConnectorWithBlock(BlockingSourceConnector.class, TASK_STOP); <line3> waitForConnectorStart(BLOCKING_CONNECTOR_NAME); <line4> connect.deleteConnector(BLOCKING_CONNECTOR_NAME); <line5> Block.waitForBlock(); <line6> createNormalConnector(); <line7> verifyNormalConnector(); <line8> } <line9> } <line10> 	 <line6>	No
"public class A { <line0> @POST <line1> @Path(""databases"") <line2> public APIResult createDatabase( <line3> @QueryParam(""sessionid"") LensSessionHandle sessionid, <line4> @QueryParam(""ignoreIfExisting"") @DefaultValue(""true"") boolean ignoreIfExisting, <line5> String dbName) <line6> throws LensException { <line7> checkSessionId(sessionid); <line8> getSvc().createDatabase(sessionid, dbName, ignoreIfExisting); <line9> return success(); <line10> } <line11> } <line12> "	 <line8>	Yes
"public class A { <line0> private void readContactList(String parentcsid, String itemcsid) throws Exception { <line1> final String testName = ""readContactList""; <line2> setupReadList(); <line3> PersonClient client = new PersonClient(); <line4> AbstractCommonList list = null; <line5> Response res = client.readContactList(parentcsid, itemcsid); <line6> try { <line7> assertStatusCode(res, testName); <line8> list = res.readEntity(AbstractCommonList.class); <line9> } finally { <line10> if (res != null) { <line11> res.close(); <line12> } <line13> } <line14> List<AbstractCommonList.ListItem> listitems = list.getListItem(); <line15> int nItemsReturned = listitems.size(); <line16> int nExpectedItems = MAX_CONTACTS; <line17> if (logger.isDebugEnabled()) { <line18> } <line19> Assert.assertEquals(nItemsReturned, nExpectedItems); <line20> boolean iterateThroughList = false; <line21> if (iterateThroughList && logger.isDebugEnabled()) { <line22> AbstractCommonListUtils.ListItemsInAbstractCommonList(list, logger, testName); <line23> } <line24> } <line25> } <line26> "	 <line17>	No
public class A { <line0> private CompletableFuture<?> publishSuspectedLedgersAsync( <line1> Collection<String> missingBookies, Set<Long> ledgers) { <line2> if (null == ledgers || ledgers.size() == 0) { <line3> return FutureUtils.Void(); <line4> } <line5> numUnderReplicatedLedger.registerSuccessfulValue(ledgers.size()); <line6> return FutureUtils.processList( <line7> Lists.newArrayList(ledgers), <line8> ledgerId -> <line9> ledgerUnderreplicationManager.markLedgerUnderreplicatedAsync(ledgerId, missingBookies), <line10> null); <line11> } <line12> } <line13> 	 <line2>	No
public class A { <line0> @Override <line1> public COREEnvelopeRealTimeResponse realTimeTransaction( <line2> COREEnvelopeRealTimeRequest msg, AssertionType assertion) { <line3> return new AdapterX12RealTimeOrchImpl().realTimeTransaction(msg); <line4> } <line5> } <line6> 	 <line3>	Yes
public class A { <line0> protected void startService( <line1> Service service, CamelContext camelContext, Object bean, String beanName) throws Exception { <line2> if (camelContext != null) { <line3> camelContext.deferStartService(service, true); <line4> } else { <line5> ServiceHelper.startService(service); <line6> } <line7> boolean singleton = isSingleton(bean, beanName); <line8> if (!singleton) { <line9> } <line10> } <line11> } <line12> 	 <line9>	Yes
public class A { <line0> @Override <line1> public void start(BundleContext context) throws Exception { <line2> try { <line3> BouncycastlePkcs8EncryptedPrivateKeyDecryptor privateKeyDecryptor = <line4> new BouncycastlePkcs8EncryptedPrivateKeyDecryptor(); <line5> Dictionary<String, Object> properties = new Hashtable<>(); <line6> properties.put(Constants.SERVICE_RANKING, Integer.valueOf(1000)); <line7> context.registerService(PrivateKeyDecryptor.class, privateKeyDecryptor, properties); <line8> } catch (Throwable t) { <line9> } <line10> } <line11> } <line12> 	 <line9>	Yes
public class A { <line0> private String nodeResolve(String hostname) { <line1> List<String> hosts = new ArrayList<>(1); <line2> hosts.add(hostname); <line3> List<String> resolvedHosts = dnsToSwitchMapping.resolve(hosts); <line4> if (resolvedHosts != null && !resolvedHosts.isEmpty()) { <line5> String location = resolvedHosts.get(0); <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> return location; <line9> } else { <line10> return null; <line11> } <line12> } <line13> } <line14> 	 <line5>	No
public class A { <line0> public static void connected(String chargeBoxId, WebSocketSession session) { <line1> } <line2> } <line3> 	 <line0>	No
"public class A { <line0> private void checkCacheMapEntry( <line1> CacheAtomicityMode atomicityMode, CacheMode cacheMode, Class<?> entryCls) throws Exception { <line2> CacheConfiguration cfg = cacheConfiguration(grid(0).name(), atomicityMode, cacheMode, ""Cache""); <line3> IgniteCache jcache = grid(0).getOrCreateCache(cfg); <line4> try { <line5> GridCacheAdapter<Integer, String> cache = <line6> ((IgniteKernal) grid(0)).internalCache(jcache.getName()); <line7> Integer key = primaryKey(grid(0).cache(DEFAULT_CACHE_NAME)); <line8> cache.put(key, ""val""); <line9> GridCacheEntryEx entry = cache.entryEx(key); <line10> entry.unswap(true); <line11> assertNotNull(entry); <line12> assertEquals(entryCls, entry.getClass()); <line13> } finally { <line14> jcache.destroy(); <line15> } <line16> } <line17> } <line18> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public Collection<SchemaVersionInfo> getAllVersions(String schemaName) <line2> throws SchemaNotFoundException { <line3> try { <line4> return atlasClient.getAllSchemaVersions(schemaName); <line5> } catch (AtlasUncheckedException npex) { <line6> throw new SchemaNotFoundException(""Schema not found with name "" + schemaName, npex); <line7> } <line8> } <line9> } <line10> "	 <line5>	No
"public class A { <line0> @Override <line1> protected int readCommand() throws IOException { <line2> String readLine = reader.readLine(); <line3> if (readLine != null && !readLine.isEmpty()) { <line4> String[] split = PROTOCOL_STRING_PATTERN.split(readLine, 2); <line5> split[0] = split[0].replace(""%"", """"); <line6> if (checkAcks(split)) return -1; <line7> try { <line8> int parseInt = Integer.parseInt(split[0]); <line9> if (parseInt == MessageType.LOG.code) { <line10> return -1; <line11> } <line12> return parseInt; <line13> } catch (NumberFormatException e) { <line14> e.printStackTrace(); <line15> } <line16> } else { <line17> return -1; <line18> } <line19> return -2; <line20> } <line21> } <line22> "	 <line10>	Yes
"public class A { <line0> @POST <line1> @Path(""/shutdown"") <line2> @Consumes({MediaType.APPLICATION_JSON, SmileMediaTypes.APPLICATION_JACKSON_SMILE}) <line3> @Produces({MediaType.APPLICATION_JSON, SmileMediaTypes.APPLICATION_JACKSON_SMILE}) <line4> public Response shutdown( <line5> @QueryParam(""shutoffTime"") final String shutoffTimeMillis, <line6> @Context final HttpServletRequest req) { <line7> Access accessResult = <line8> AuthorizationUtils.authorizeResourceAction( <line9> req, new ResourceAction(Resource.STATE_RESOURCE, Action.WRITE), authorizerMapper); <line10> if (!accessResult.isAllowed()) { <line11> return Response.status(403).build(); <line12> } <line13> try { <line14> DateTime shutoffAt = <line15> shutoffTimeMillis == null ? DateTimes.nowUtc() : DateTimes.of(shutoffTimeMillis); <line16> long shutoffTimeoutMillis = Math.max(shutoffAt.getMillis() - System.currentTimeMillis(), 0); <line17> requestedShutdownTimeNs = <line18> System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(shutoffTimeoutMillis); <line19> Thread delayedCloseExecutor; <line20> boolean needToInterruptDelayedCloseExecutor = true; <line21> synchronized (this) { <line22> delayedCloseExecutor = this.delayedCloseExecutor; <line23> if (delayedCloseExecutor == null) { <line24> delayedCloseExecutor = createDelayedCloseExecutor(); <line25> needToInterruptDelayedCloseExecutor = false; <line26> } <line27> } <line28> if (needToInterruptDelayedCloseExecutor) { <line29> delayedCloseExecutor.interrupt(); <line30> } <line31> return Response.ok().build(); <line32> } catch (IllegalArgumentException e) { <line33> return Response.status(Response.Status.BAD_REQUEST) <line34> .entity(ImmutableMap.<String, Object>of(""error"", e.getMessage())) <line35> .build(); <line36> } <line37> } <line38> } <line39> "	 <line9>	No
public class A { <line0> public final boolean updateOutputCondition(int newDataCount, int oldDataCount) { <line1> if (optionalVariableReader != null) { <line2> Object value = optionalVariableReader.getValue(); <line3> if (value != null) { <line4> state.setEventRate(((Number) value).longValue()); <line5> } <line6> } <line7> state.setNewEventsCount(state.getNewEventsCount() + newDataCount); <line8> state.setOldEventsCount(state.getOldEventsCount() + oldDataCount); <line9> if (isSatisfied() || state.isFirst()) { <line10> if ((ExecutionPathDebugLog.isDebugEnabled) && (log.isDebugEnabled())) { <line11> } <line12> state.setIsFirst(false); <line13> state.setNewEventsCount(0); <line14> state.setOldEventsCount(0); <line15> return true; <line16> } <line17> return false; <line18> } <line19> } <line20> 	 <line5>	No
"public class A { <line0> public void deleteFileVersion(String fileId, Integer version) { <line1> try { <line2> if (fileId == null) { <line3> throw new IllegalArgumentException(""Parameter 'fileId' can not be null""); <line4> } <line5> if (version == null) { <line6> throw new IllegalArgumentException(""Parameter 'version' can not be null""); <line7> } <line8> BoxFile file = new BoxFile(boxConnection, fileId); <line9> List<BoxFileVersion> versions = (List<BoxFileVersion>) file.getVersions(); <line10> BoxFileVersion fileVersion = versions.get(version); <line11> fileVersion.delete(); <line12> } catch (BoxAPIException e) { <line13> throw new RuntimeException( <line14> String.format( <line15> ""Box API returned the error code %d%n%n%s"", e.getResponseCode(), e.getResponse()), <line16> e); <line17> } <line18> } <line19> } <line20> "	 <line2>	Yes
public class A { <line0> public void setActionMap(Map<String, String> actions) { <line1> for (String from : actions.keySet()) { <line2> URI key; <line3> String to = actions.get(from); <line4> try { <line5> key = new URI(from); <line6> URI value = new URI(actions.get(from)); <line7> actionMap.put(key, value); <line8> } catch (URISyntaxException e) { <line9> } <line10> } <line11> } <line12> } <line13> 	 <line12>	No
public class A { <line0> @Teardown <line1> public void closeMqttClient() throws Exception { <line2> if (connection != null) { <line3> connection.disconnect(); <line4> } <line5> } <line6> } <line7> 	 <line4>	No
public class A { <line0> private static boolean copyStream(final InputStream is, final OutputStream os) { <line1> try { <line2> final byte[] buf = new byte[1024]; <line3> for (int len = is.read(buf); len > 0; len = is.read(buf)) { <line4> os.write(buf, 0, len); <line5> } <line6> is.close(); <line7> os.close(); <line8> return true; <line9> } catch (final IOException e) { <line10> } <line11> return false; <line12> } <line13> } <line14> 	 <line10>	Yes
"public class A { <line0> @Override <line1> protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) <line2> throws AuthenticationException { <line3> String credentials = (String) token.getCredentials(); <line4> String[] userpass = credentials.split("":""); <line5> if (userpass.length != 2) { <line6> throw new AuthenticationException(""Credentials were not in the correct format.""); <line7> } <line8> String user = new String(Base64.getDecoder().decode(userpass[0]), StandardCharsets.UTF_8); <line9> String pass = new String(Base64.getDecoder().decode(userpass[1]), StandardCharsets.UTF_8); <line10> Subject subject = null; <line11> for (JaasRealm jaasRealm : realmList) { <line12> try { <line13> subject = login(user, pass, jaasRealm.getName()); <line14> break; <line15> } catch (LoginException e) { <line16> } <line17> } <line18> if (subject != null) { <line19> SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(); <line20> SimplePrincipalCollection principalCollection = createPrincipalCollectionFromSubject(subject); <line21> simpleAuthenticationInfo.setPrincipals(principalCollection); <line22> simpleAuthenticationInfo.setCredentials(credentials); <line23> return simpleAuthenticationInfo; <line24> } <line25> throw new AuthenticationException(""Login failed for user: "" + user); <line26> } <line27> } <line28> "	 <line6>	No
"public class A { <line0> public FileDownloadInfo getFileDownloadInfo(String fileId) { <line1> Objects.requireNonNull(fileId, ""fileId is NULL""); <line2> FileDownloadInfo fdi = fdiCache.get(fileId); <line3> if (fdi == null) { <line4> fdi = createFileDownloadInfo(fileId); <line5> } <line6> return fdi; <line7> } <line8> } <line9> "	 <line5>	No
public class A { <line0> @Override <line1> protected void encode(ChannelHandlerContext ctx, T packet, ByteBuf byteBuf) { <line2> try { <line3> WriteBufferByteBased buffer = new WriteBufferByteBased(packet.getLengthInBytes(), !bigEndian); <line4> io.serialize(buffer, packet); <line5> byteBuf.writeBytes(buffer.getData()); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	 <line7>	Yes
public class A { <line0> @Override <line1> public void handleLastResult(Result lastResult) { <line2> if (lastResult == null) { <line3> return; <line4> } <line5> Cell[] rawCells = lastResult.rawCells(); <line6> Cell last = rawCells[rawCells.length - 1]; <line7> byte[] row = CellUtil.cloneRow(last); <line8> byte[] originalRow = traceIdRowKeyDistributor.getOriginalKey(row); <line9> long reverseStartTime = <line10> BytesUtils.bytesToLong(originalRow, PinpointConstants.APPLICATION_NAME_MAX_LEN); <line11> this.lastRowTimestamp = TimeUtils.recoveryTimeMillis(reverseStartTime); <line12> byte[] qualifier = CellUtil.cloneQualifier(last); <line13> this.lastTransactionId = <line14> TransactionIdMapper.parseVarTransactionId(qualifier, 0, qualifier.length); <line15> this.lastTransactionElapsed = BytesUtils.bytesToInt(qualifier, 0); <line16> if (logger.isDebugEnabled()) { <line17> } <line18> } <line19> } <line20> 	 <line10>	No
public class A { <line0> public static com.liferay.blogs.model.BlogsEntrySoap[] getEntriesPrevAndNext(long entryId) <line1> throws RemoteException { <line2> try { <line3> com.liferay.blogs.model.BlogsEntry[] returnValue = <line4> BlogsEntryServiceUtil.getEntriesPrevAndNext(entryId); <line5> return com.liferay.blogs.model.BlogsEntrySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> @Override <line1> public void protocolReplyReceived(ProtocolCommandEvent event) { <line2> } <line3> } <line4> 	 <line1>	No
"public class A { <line0> public static void main(String[] args) { <line1> try { <line2> ApplicationContext ctx = new GenericXmlApplicationContext(""applicationContext.xml""); <line3> SimpleMongoRepository mongoRepository = <line4> (SimpleMongoRepository) ctx.getBean(""mongoRepository""); <line5> MongoTest mongoTest = (MongoTest) ctx.getBean(MongoTest.class); <line6> String principle = ""rbloh""; <line7> String collectionName = mongoTest.getTestCollection(); <line8> mongoRepository.purge(principle, collectionName); <line9> log.info(collectionName + "" Size: "" + mongoRepository.count(collectionName)); <line10> TestEntity testEntity = new TestEntity(""Robert"", ""Bloh"", 48); <line11> mongoRepository.create(principle, collectionName, testEntity); <line12> testEntity.getBody().clear(); <line13> testEntity.getBody().put(""newAttribute"", ""newValue""); <line14> mongoRepository.update(principle, collectionName, testEntity); <line15> ModelEntity findEntity = <line16> mongoRepository.findById(collectionName, testEntity.getId().toString()); <line17> mongoRepository.delete(principle, collectionName, testEntity); <line18> } catch (Exception exception) { <line19> exception.printStackTrace(); <line20> } <line21> } <line22> } <line23> "	 <line17>	Yes
"public class A { <line0> public static Config getConfig(final Admin adminClient) { <line1> try { <line2> final Collection<Node> brokers = adminClient.describeCluster().nodes().get(); <line3> final Node broker = Iterables.getFirst(brokers, null); <line4> if (broker == null) { <line5> throw new KsqlServerException( <line6> ""AdminClient discovered an empty Kafka Cluster. "" <line7> + ""Check that Kafka is deployed and KSQL is properly configured.""); <line8> } <line9> final ConfigResource configResource = <line10> new ConfigResource(ConfigResource.Type.BROKER, broker.idString()); <line11> final Map<ConfigResource, Config> brokerConfig = <line12> ExecutorUtil.executeWithRetries( <line13> ExecutorUtil.RetryBehaviour.ON_RETRYABLE); <line14> return brokerConfig.get(configResource); <line15> } catch (final KsqlServerException e) { <line16> throw e; <line17> } catch (final ClusterAuthorizationException e) { <line18> throw new KsqlServerException( <line19> ""Could not get Kafka cluster configuration. "" <line20> + ""Please ensure the ksql principal has "" <line21> + AclOperation.DESCRIBE_CONFIGS <line22> + "" rights "" <line23> + ""on the Kafka cluster."" <line24> + System.lineSeparator() <line25> + ""See "" <line26> + DocumentationLinks.SECURITY_REQUIRED_ACLS_DOC_URL <line27> + "" for more info."", <line28> e); <line29> } catch (final Exception e) { <line30> throw new KsqlServerException(""Could not get Kafka cluster configuration!"", e); <line31> } <line32> } <line33> } <line34> "	 <line9>	No
"public class A { <line0> public static long reserveNamespace( <line1> Manager env, <line2> NamespaceId namespaceId, <line3> long id, <line4> boolean writeLock, <line5> boolean mustExist, <line6> TableOperation op) <line7> throws Exception { <line8> if (getLock(env.getContext(), namespaceId, id, writeLock).tryLock()) { <line9> if (mustExist) { <line10> ZooReaderWriter zk = env.getContext().getZooReaderWriter(); <line11> if (!zk.exists( <line12> env.getContext().getZooKeeperRoot() + Constants.ZNAMESPACES + ""/"" + namespaceId)) <line13> throw new AcceptableThriftTableOperationException( <line14> namespaceId.canonical(), <line15> """", <line16> op, <line17> TableOperationExceptionType.NAMESPACE_NOTFOUND, <line18> ""Namespace does not exist""); <line19> } <line20> return 0; <line21> } else return 100; <line22> } <line23> } <line24> "	 <line10>	No
"public class A { <line0> private static final String generateServiceBundles(File tenantConfigFile) { <line1> String result = null; <line2> ServiceConfigGeneration xsdMetadata = null; <line3> try { <line4> xsdMetadata = <line5> new ServiceConfigGeneration( <line6> serviceBundlesInfo, <line7> tenantConfigFile, <line8> CommonAPI.GENERATE_BUNDLES, <line9> SERVICE_SCHEMA_VERSION, <line10> getBundlesOutputDir(), <line11> SERVICE_BINDINGS_VERSION, <line12> getBindingsOutputDir()); <line13> serviceBundlesInfo.put(tenantConfigFile.getName(), xsdMetadata); <line14> dumpServiceArtifactMetadata(tenantConfigFile, xsdMetadata); <line15> } catch (Exception e) { <line16> result = <line17> String.format( <line18> ""Error encountered generating service bindings for '%s' tenant configuration."", <line19> tenantConfigFile.getAbsolutePath()); <line20> } <line21> return result; <line22> } <line23> } <line24> "	 <line20>	Yes
public class A { <line0> @Override <line1> protected void cancel(ConditionCode code) { <line2> if (inTxState == InTxState.RECEIVING_DATA) { <line3> if (needsFinish) { <line4> finish(code); <line5> } else { <line6> complete(code); <line7> } <line8> } else { <line9> } <line10> } <line11> } <line12> 	 <line9>	Yes
"public class A { <line0> @Test <line1> public void testEventListenerReconnect() throws Exception { <line2> Ignite client = grid(serverCount()); <line3> assertTrue(client.cluster().localNode().isClient()); <line4> Ignite srv = ignite(0); <line5> IgniteDiscoverySpi srvSpi = spi0(srv); <line6> EventListener lsnr = new EventListener(); <line7> UUID opId = client.events().remoteListen(lsnr, null, EventType.EVT_JOB_STARTED); <line8> lsnr.latch = new CountDownLatch(1); <line9> final CountDownLatch reconnectLatch = new CountDownLatch(1); <line10> client <line11> .events() <line12> .localListen( <line13> new IgnitePredicate<Event>() { <line14> @Override <line15> public boolean apply(Event evt) { <line16> if (evt.type() == EVT_CLIENT_NODE_RECONNECTED) { <line17> info(""Reconnected: "" + evt); <line18> reconnectLatch.countDown(); <line19> } <line20> return true; <line21> } <line22> }, <line23> EVT_CLIENT_NODE_RECONNECTED); <line24> srvSpi.failNode(client.cluster().localNode().id(), null); <line25> waitReconnectEvent(reconnectLatch); <line26> client.compute().run(new DummyJob()); <line27> assertTrue(lsnr.latch.await(5000, MILLISECONDS)); <line28> lsnr.latch = new CountDownLatch(1); <line29> srv.compute().run(new DummyJob()); <line30> assertTrue(lsnr.latch.await(5000, MILLISECONDS)); <line31> lsnr.latch = new CountDownLatch(1); <line32> client.events().stopRemoteListen(opId); <line33> assertFalse(lsnr.latch.await(3000, MILLISECONDS)); <line34> } <line35> } <line36> "	 <line9>	Yes
"public class A { <line0> private static NativeImageBuildRunner getNativeImageBuildRunner( <line1> NativeConfig nativeConfig, <line2> Path outputDir, <line3> String nativeImageName, <line4> String resultingExecutableName) { <line5> if (!isContainerBuild(nativeConfig)) { <line6> NativeImageBuildLocalRunner localRunner = <line7> getNativeImageBuildLocalRunner(nativeConfig, outputDir.toFile()); <line8> if (localRunner != null) { <line9> return localRunner; <line10> } <line11> String executableName = getNativeImageExecutableName(); <line12> String errorMessage = <line13> ""Cannot find the `"" <line14> + executableName <line15> + ""` in the GRAALVM_HOME, JAVA_HOME and System PATH. Install it using `gu install"" <line16> + "" native-image`""; <line17> if (!SystemUtils.IS_OS_LINUX) { <line18> throw new RuntimeException(errorMessage); <line19> } <line20> } <line21> if (nativeConfig.remoteContainerBuild) { <line22> return new NativeImageBuildRemoteContainerRunner( <line23> nativeConfig, outputDir, nativeImageName, resultingExecutableName); <line24> } <line25> return new NativeImageBuildLocalContainerRunner(nativeConfig, outputDir); <line26> } <line27> } <line28> "	 <line22>	No
"public class A { <line0> public String modifyImpl() { <line1> if (this.initialized) { <line2> return OxTrustConstants.RESULT_SUCCESS; <line3> } <line4> try { <line5> GluuConfiguration configuration = configurationService.getConfiguration(); <line6> if (configuration == null) { <line7> return OxTrustConstants.RESULT_FAILURE; <line8> } <line9> this.passportEnable = configuration.isPassportEnabled(); <line10> this.customScripts = <line11> customScriptService.findCustomScripts( <line12> Arrays.asList(CustomScriptType.PERSON_AUTHENTICATION), <line13> ""displayName"", <line14> ""oxLevel"", <line15> ""oxEnabled""); <line16> List<OxIDPAuthConf> list = getIDPAuthConfOrNull(configuration); <line17> this.sourceConfigs = new ArrayList<GluuLdapConfiguration>(); <line18> if (list != null) { <line19> for (OxIDPAuthConf oxIDPAuthConf : list) { <line20> GluuLdapConfiguration oxldapConfig = oxIDPAuthConf.getConfig(); <line21> this.sourceConfigs.add(oxldapConfig); <line22> } <line23> } <line24> getAuthenticationRecaptcha(); <line25> this.authenticationMode = configuration.getAuthenticationMode(); <line26> this.oxTrustAuthenticationMode = configuration.getOxTrustAuthenticationMode(); <line27> } catch (Exception ex) { <line28> return OxTrustConstants.RESULT_FAILURE; <line29> } <line30> this.initialized = true; <line31> return OxTrustConstants.RESULT_SUCCESS; <line32> } <line33> } <line34> "	 <line5>	No
public class A { <line0> @Override <line1> public void addSshKey(final String sshKey, final boolean async) <line2> throws EnvironmentModificationException { <line3> try { <line4> environmentManager.addSshKey(getId(), sshKey, async); <line5> } catch (EnvironmentNotFoundException e) { <line6> throw new EnvironmentModificationException(e); <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
public class A { <line0> public static ByteString serializeRawScans(List<RawScan> rawScans) { <line1> ByteString rawScanByteString; <line2> int rawScanBufferSize = BytesSerializer.SERIALIZE_BUFFER_SIZE; <line3> while (true) { <line4> try { <line5> ByteBuffer rawScanBuffer = ByteBuffer.allocate(rawScanBufferSize); <line6> BytesUtil.writeVInt(rawScans.size(), rawScanBuffer); <line7> for (RawScan rs : rawScans) { <line8> RawScan.serializer.serialize(rs, rawScanBuffer); <line9> } <line10> rawScanBuffer.flip(); <line11> rawScanByteString = <line12> HBaseZeroCopyByteString.wrap( <line13> rawScanBuffer.array(), rawScanBuffer.position(), rawScanBuffer.limit()); <line14> break; <line15> } catch (BufferOverflowException boe) { <line16> rawScanBufferSize *= 4; <line17> } <line18> } <line19> return rawScanByteString; <line20> } <line21> } <line22> 	 <line16>	Yes
public class A { <line0> private void flushBatch( <line1> OutputReceiver<KV<K, Iterable<InputT>>> receiver, <line2> K key, <line3> BagState<InputT> batch, <line4> CombiningState<Long, long[], Long> storedBatchSize, <line5> CombiningState<Long, long[], Long> storedBatchSizeBytes) { <line6> Iterable<InputT> values = batch.read(); <line7> if (!Iterables.isEmpty(values)) { <line8> receiver.output(KV.of(key, values)); <line9> } <line10> batch.clear(); <line11> storedBatchSize.clear(); <line12> storedBatchSizeBytes.clear(); <line13> } <line14> } <line15> 	 <line11>	Yes
public class A { <line0> @Override <line1> public void succeeded() { <line2> DataFrame data = new DataFrame(stream.getId(), buffer1.slice(), true); <line3> stream.data(data, NOOP); <line4> } <line5> } <line6> 	 <line3>	Yes
"public class A { <line0> @Override <line1> protected void include( <line2> String path, PortletRequest portletRequest, PortletResponse portletResponse, String lifecycle) <line3> throws IOException, PortletException { <line4> PortletContext portletContext = getPortletContext(); <line5> String servletContextName = portletContext.getPortletContextName(); <line6> String resourcePath = <line7> StringBundler.concat(servletContextName, TemplateConstants.SERVLET_SEPARATOR, path); <line8> boolean resourceExists = false; <line9> try { <line10> resourceExists = <line11> TemplateResourceLoaderUtil.hasTemplateResource( <line12> TemplateConstants.LANG_TYPE_FTL, resourcePath); <line13> } catch (TemplateException templateException) { <line14> throw new IOException(templateException); <line15> } <line16> if (!resourceExists) { <line17> } else { <line18> try { <line19> TemplateResource templateResource = <line20> TemplateResourceLoaderUtil.getTemplateResource( <line21> TemplateConstants.LANG_TYPE_FTL, resourcePath); <line22> Template template = <line23> TemplateManagerUtil.getTemplate( <line24> TemplateConstants.LANG_TYPE_FTL, templateResource, false); <line25> template.prepareTaglib( <line26> PortalUtil.getHttpServletRequest(portletRequest), <line27> PortalUtil.getHttpServletResponse(portletResponse)); <line28> template.put(""portletContext"", getPortletContext()); <line29> template.put(""userInfo"", portletRequest.getAttribute(PortletRequest.USER_INFO)); <line30> template.prepare(PortalUtil.getHttpServletRequest(portletRequest)); <line31> Writer writer = null; <line32> if (portletResponse instanceof MimeResponse) { <line33> MimeResponse mimeResponse = (MimeResponse) portletResponse; <line34> writer = UnsyncPrintWriterPool.borrow(mimeResponse.getWriter()); <line35> } else { <line36> writer = new UnsyncStringWriter(); <line37> } <line38> template.processTemplate(writer); <line39> } catch (Exception exception) { <line40> throw new PortletException(exception); <line41> } <line42> } <line43> if (clearRequestParameters && lifecycle.equals(PortletRequest.RENDER_PHASE)) { <line44> portletResponse.setProperty(""clear-request-parameters"", ""true""); <line45> } <line46> } <line47> } <line48> "	 <line23>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> final long start = System.nanoTime(); <line4> final int numRecordsCheckpointed = checkpoint(); <line5> final long end = System.nanoTime(); <line6> final long millis = TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS); <line7> } catch (final IOException e) { <line8> } <line9> } <line10> } <line11> 	 <line3>	Yes
public class A { <line0> protected StringTreeNode buildTree(Boolean bUseLowercase, String tokenBoundaryRegex) { <line1> StringTreeNode tree = new StringTreeNode(tokenBoundaryRegex, bUseLowercase); <line2> sortedSkipGramSet.stream() <line3> .parallel() <line4> .filter(entry -> !filterSet.contains(entry.toLowerCase())) <line5> .forEach(tree::insert); <line6> return tree; <line7> } <line8> } <line9> 	 <line1>	Yes
public class A { <line0> private boolean checkSkip(String cubingJobId, int level) { <line1> if (cubingJobId == null) return false; <line2> ExecutableManager execMgr = ExecutableManager.getInstance(KylinConfig.getInstanceFromEnv()); <line3> CubingJob cubingJob = (CubingJob) execMgr.getJob(cubingJobId); <line4> skipped = cubingJob.isLayerCubing() == false; <line5> if (!skipped) { <line6> skipped = (level > cuboidScheduler.getBuildLevel()); <line7> if (skipped) { <line8> } <line9> } <line10> return skipped; <line11> } <line12> } <line13> 	 <line1>	No
"public class A { <line0> @Override <line1> public void handleLine(final String fileName, final String line) { <line2> if (fileName.endsWith("".out"")) { <line3> } else { <line4> } <line5> } <line6> } <line7> "	 <line3>	Yes
public class A { <line0> @Test <line1> public void alertDetailsThreadIdMatchesLoggingThreadId() { <line2> long threadId = <line3> memberVM.invoke( <line4> () -> { <line5> return Thread.currentThread().getId(); <line6> }); <line7> managerVM.invoke( <line8> () -> { <line9> assertThat(captureAlertDetails().getTid()).isEqualTo(threadId); <line10> }); <line11> } <line12> } <line13> 	 <line8>	No
public class A { <line0> private UserFilePermission getPermissionViaSpecQueryAsGroupMember( <line1> final String userName, final ObjStat objStat, final String absPath) throws JargonException { <line2> UserFilePermission permissionViaGroup = null; <line3> if (getJargonProperties().isUsingSpecQueryForDataObjPermissionsForUserInGroup()) { <line4> permissionViaGroup = <line5> findPermissionForUserGrantedThroughUserGroup( <line6> userName, <line7> MiscIRODSUtils.getZoneInPath(absPath), <line8> objStat.determineAbsolutePathBasedOnCollTypeInObjectStat()); <line9> return permissionViaGroup; <line10> } else { <line11> return null; <line12> } <line13> } <line14> } <line15> 	 <line4>	Yes
"public class A { <line0> public int pollRequestStatus(String url) throws InsightsCustomException { <line1> JsonObject response = new JsonObject(); <line2> try { <line3> String h20url = h2oEndpoint + url; <line4> String status = ""RUNNING""; <line5> do { <line6> String httpResponse = RestApiHandler.doGet(h20url, null); <line7> response = new JsonParser().parse(httpResponse).getAsJsonObject(); <line8> JsonArray jobs = response.get(""jobs"").getAsJsonArray(); <line9> JsonObject job = jobs.get(0).getAsJsonObject(); <line10> status = job.get(""status"").getAsString(); <line11> Thread.sleep(3000); <line12> } while (status.equals(""RUNNING"")); <line13> if (status.equals(""DONE"")) { <line14> return 200; <line15> } else { <line16> return 400; <line17> } <line18> } catch (Exception e) { <line19> throw new InsightsCustomException(e.getMessage()); <line20> } <line21> } <line22> } <line23> "	 <line3>	Yes
"public class A { <line0> public String saveFido2ConfigJson() { <line1> try { <line2> if (this.fido2ConfigJson != null) { <line3> jsonConfigurationService.saveFido2Configuration(this.fido2ConfigJson); <line4> } <line5> facesMessages.add(FacesMessage.SEVERITY_INFO, ""Fido2 Configuration is updated.""); <line6> return OxTrustConstants.RESULT_SUCCESS; <line7> } catch (Exception ex) { <line8> facesMessages.add(FacesMessage.SEVERITY_ERROR, ""Failed to update Fido2 configuration in DB""); <line9> } <line10> return OxTrustConstants.RESULT_FAILURE; <line11> } <line12> } <line13> "	 <line10>	No
public class A { <line0> private void correctUsage(String group, String tenant, boolean hasTenant) { <line1> try { <line2> if (hasTenant) { <line3> capacityService.correctTenantUsage(tenant); <line4> } else { <line5> capacityService.correctGroupUsage(group); <line6> } <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	 <line7>	No
public class A { <line0> @Override <line1> public void consumeEvent(List<IEventWrapper> toProcessEvents) { <line2> for (IEventWrapper wrapper : toProcessEvents) { <line3> final VcEventWrapper eventWrapper = (VcEventWrapper) wrapper; <line4> Event event = null; <line5> try { <line6> if (eventWrapper != null) { <line7> event = eventWrapper.event; <line8> VcContext.inVcSessionDo( <line9> new VcSession<Void>() { <line10> @Override <line11> protected boolean isTaskSession() { <line12> return true; <line13> } <line14>  <line15> @Override <line16> protected Void body() throws Exception { <line17> processEvent(eventWrapper.type, eventWrapper.event, eventWrapper.external); <line18> return null; <line19> } <line20> }); <line21> } <line22> } catch (Exception e) { <line23> if (event != null) { <line24> } else { <line25> } <line26> } <line27> } <line28> } <line29> } <line30> 	 <line26>	No
"public class A { <line0> @Test <line1> public void testMultiple() throws Exception { <line2> String filename = ""data/hin/multiple.hin""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> HINReader reader = new HINReader(ins); <line5> ChemFile chemFile = (ChemFile) reader.read((ChemObject) new ChemFile()); <line6> reader.close(); <line7> Assert.assertNotNull(chemFile); <line8> Assert.assertEquals(1, chemFile.getChemSequenceCount()); <line9> org.openscience.cdk.interfaces.IChemSequence seq = chemFile.getChemSequence(0); <line10> Assert.assertNotNull(seq); <line11> Assert.assertEquals(1, seq.getChemModelCount()); <line12> org.openscience.cdk.interfaces.IChemModel model = seq.getChemModel(0); <line13> Assert.assertNotNull(model); <line14> IAtomContainerSet som = model.getMoleculeSet(); <line15> Assert.assertNotNull(som); <line16> Assert.assertEquals(3, som.getAtomContainerCount()); <line17> } <line18> } <line19> "	 <line7>	No
public class A { <line0> private void purgeAgedFiles() throws IOException { <line1> if (config.getExpireDate() == 0) { <line2> return; <line3> } <line4> long now = new Date().getTime(); <line5> long diff = now - config.getLastDelete(); <line6> long oneDayMillis = TimeUnit.DAYS.toMillis(1); <line7> if (diff > (2 * oneDayMillis)) { <line8> config.setLastDelete(now); <line9> long xDaysAgo = config.getExpireDate() * oneDayMillis; <line10> int filesDeleted = 0; <line11> for (File file : cacheFolder.listFiles()) { <line12> diff = now - file.lastModified(); <line13> if (diff > xDaysAgo) { <line14> filesDeleted++; <line15> file.delete(); <line16> } <line17> } <line18> } <line19> } <line20> } <line21> 	 <line11>	No
public class A { <line0> public Optional<Configuration> fetchConfiguration( <line1> final String resourceUuid, final String configurationUuid) { <line2> final Optional<Resource> resourceOptional = fetchResource(resourceUuid); <line3> if (!resourceOptional.isPresent()) { <line4> return Optional.empty(); <line5> } <line6> final Configuration configuration = resourceOptional.get().getConfiguration(configurationUuid); <line7> return Optional.ofNullable(configuration); <line8> } <line9> } <line10> 	 <line4>	Yes
public class A { <line0> @Override <line1> public List<SourceRecord> poll() throws InterruptedException { <line2> try { <line3> long deadline = System.currentTimeMillis() + interval.toMillis(); <line4> while (!stopping && System.currentTimeMillis() < deadline) { <line5> offsetSyncStore.update(pollTimeout); <line6> } <line7> List<SourceRecord> records = new ArrayList<>(); <line8> for (String group : consumerGroups) { <line9> records.addAll(sourceRecordsForGroup(group)); <line10> } <line11> if (records.isEmpty()) { <line12> return null; <line13> } else { <line14> return records; <line15> } <line16> } catch (Throwable e) { <line17> return null; <line18> } <line19> } <line20> } <line21> 	 <line0>	No
"public class A { <line0> private void init() throws Exception { <line1> String originalAppId = propertiesBuilder.conf.get(ORIGINAL_APP_ID); <line2> if (originalAppId == null) { <line3> throw new AssertionError(""Need original app id if launching without apa or appjar""); <line4> } <line5> Path appsBasePath = <line6> new Path(StramClientUtils.getApexDFSRootDir(fs, conf), StramClientUtils.SUBDIR_APPS); <line7> Path origAppPath = new Path(appsBasePath, originalAppId); <line8> StringWriter writer = new StringWriter(); <line9> try (FSDataInputStream in = fs.open(new Path(origAppPath, ""meta.json""))) { <line10> IOUtils.copy(in, writer); <line11> } <line12> JSONObject metaJson = new JSONObject(writer.toString()); <line13> String originalLibJars = null; <line14> try { <line15> JSONObject attributes = metaJson.getJSONObject(""attributes""); <line16> originalLibJars = attributes.getString(Context.DAGContext.LIBRARY_JARS.getSimpleName()); <line17> recoveryAppName = attributes.getString(Context.DAGContext.APPLICATION_NAME.getSimpleName()); <line18> } catch (JSONException ex) { <line19> recoveryAppName = ""Recovery App From "" + originalAppId; <line20> } <line21> LinkedHashSet<URL> clUrls = new LinkedHashSet<>(); <line22> String libjars = propertiesBuilder.conf.get(LIBJARS_CONF_KEY_NAME); <line23> if (StringUtils.isBlank(libjars)) { <line24> libjars = originalLibJars; <line25> } else if (StringUtils.isNotBlank(originalLibJars)) { <line26> libjars = libjars + "","" + originalLibJars; <line27> } <line28> propertiesBuilder.conf.set(LIBJARS_CONF_KEY_NAME, libjars); <line29> processLibJars(libjars, clUrls); <line30> for (URL baseURL : clUrls) { <line31> } <line32> this.launchDependencies = clUrls; <line33> } <line34> } <line35> "	 <line31>	Yes
"public class A { <line0> private File getDeployXML(final List<File> files) { <line1> for (final File file : files) { <line2> if (file.getName().equals(""deploy.xml"")) { <line3> return file; <line4> } <line5> } <line6> return null; <line7> } <line8> } <line9> "	 <line3>	Yes
public class A { <line0> private void doWakeup() { <line1> try { <line2> nextResync = Instant.MIN; <line3> queue.wakeup(); <line4> } catch (InterruptedException ex) { <line5> Thread.currentThread().interrupt(); <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> @Scheduled(cron = ""${scheduler.update.cron:*/30 * * * * *}"") <line1> public void update() { <line2> new MDCHelper(this.getClass()) <line3> .run( <line4> () -> { <line5> try { <line6> Set<String> repoNamesToSchedule = <line7> repo.findByType(SCHEDULED).stream().map(RepoEntry::getName).collect(toSet()); <line8> repoNamesToSchedule.forEach(this::ensureRunningRepoJob); <line9> removeJobsNotFoundInDb(repoNamesToSchedule); <line10> } catch (Exception e) { <line11> } <line12> }); <line13> } <line14> } <line15> "	 <line11>	Yes
public class A { <line0> @Override <line1> public void postSetEnabled(User user) throws Exception { <line2> RequestLifeCycle.begin(PortalContainer.getInstance()); <line3> try { <line4> IdentityManager idm = CommonsUtils.getService(IdentityManager.class); <line5> Identity identity = <line6> idm.getOrCreateIdentity(OrganizationIdentityProvider.NAME, user.getUserName(), false); <line7> if (!user.isEnabled()) { <line8> CommonsUtils.getService(IndexingService.class) <line9> .unindex(ProfileIndexingServiceConnector.TYPE, identity.getId()); <line10> } else { <line11> CommonsUtils.getService(IndexingService.class) <line12> .reindex(ProfileIndexingServiceConnector.TYPE, identity.getId()); <line13> } <line14> } finally { <line15> RequestLifeCycle.end(); <line16> } <line17> } <line18> } <line19> 	 <line7>	Yes
"public class A { <line0> @Ignore <line1> @Test <line2> public void testReadProjects() throws IOException { <line3> JiraProjectsReader jiraReader = new JiraProjectsReader(source); <line4> List<Object> entities = new ArrayList<>(); <line5> for (boolean hasNext = jiraReader.start(); hasNext; hasNext = jiraReader.advance()) { <line6> Object entity = jiraReader.getCurrent().get(0); <line7> entities.add(entity); <line8> } <line9> jiraReader.close(); <line10> assertThat(entities, hasSize(3)); <line11> assertThat(entities, containtEntityWithName(""Public Project 1"")); <line12> assertThat(entities, containtEntityWithName(""Public Project 2"")); <line13> assertThat(entities, containtEntityWithName(""Test Project"")); <line14> } <line15> } <line16> "	 <line7>	Yes
"public class A { <line0> @Override <line1> public int executeBatch() { <line2> List<JsonObject> objectsToPersist = new ArrayList<JsonObject>(); <line3> HttpResponse response = null; <line4> String databaseName = null; <line5> boolean isbulk = false; <line6> try { <line7> for (Node node : nodes) { <line8> if (node.isDirty()) { <line9> node.handlePreEvent(); <line10> if (node.isInState(RemovedState.class)) { <line11> delete(node.getData(), node.getEntityId()); <line12> } else { <line13> EntityMetadata metadata = <line14> KunderaMetadataManager.getEntityMetadata(kunderaMetadata, node.getDataClass()); <line15> databaseName = metadata.getSchema(); <line16> JsonObject asJsonObject = <line17> CouchDBObjectMapper.getJsonOfEntity( <line18> metadata, <line19> node.getData(), <line20> node.getEntityId(), <line21> getRelationHolders(node), <line22> kunderaMetadata); <line23> objectsToPersist.add(asJsonObject); <line24> isbulk = true; <line25> } <line26> node.handlePostEvent(); <line27> } <line28> } <line29> if (isbulk) { <line30> try { <line31> URI uri = <line32> new URI( <line33> CouchDBConstants.PROTOCOL, <line34> null, <line35> httpHost.getHostName(), <line36> httpHost.getPort(), <line37> CouchDBConstants.URL_SEPARATOR <line38> + databaseName.toLowerCase() <line39> + CouchDBConstants.URL_SEPARATOR <line40> + ""_bulk_docs"", <line41> null, <line42> null); <line43> HttpPost post = new HttpPost(uri); <line44> String object = <line45> String.format( <line46> ""{%s%s}"", <line47> ""\""all_or_nothing\"": true,"", ""\""docs\"": "" + gson.toJson(objectsToPersist)); <line48> StringEntity entity = new StringEntity(object, ""UTF-8""); <line49> entity.setContentType(""application/json""); <line50> post.setEntity(entity); <line51> response = httpClient.execute(httpHost, post, CouchDBUtils.getContext(httpHost)); <line52> } catch (Exception e) { <line53> throw new KunderaException(""Error while executing batch. caused by :"" + e); <line54> } <line55> } <line56> } catch (OperationNotSupportedException e) { <line57> throw new KunderaException(e.getMessage()); <line58> } finally { <line59> CouchDBUtils.closeContent(response); <line60> } <line61> return nodes.size(); <line62> } <line63> } <line64> "	 <line39>	No
public class A { <line0> private SessionRecord convert(Session session) { <line1> SimpleSession ssession = (SimpleSession) session; <line2> SessionRecord sessionRecord = new SessionRecord(); <line3> sessionRecord.setIdsession(session.getId().toString()); <line4> sessionRecord.setStarttimestamp(new Timestamp(session.getStartTimestamp().getTime())); <line5> sessionRecord.setLastaccesstime(new Timestamp(session.getLastAccessTime().getTime())); <line6> sessionRecord.setTimeout(session.getTimeout()); <line7> sessionRecord.setHost(session.getHost()); <line8> if (ssession.getAttributes() != null) { <line9> HashMap<Object, Object> attributes = (HashMap<Object, Object>) ssession.getAttributes(); <line10> sessionRecord.setAttributes(SerializationUtils.serialize(attributes)); <line11> } <line12> return sessionRecord; <line13> } <line14> } <line15> 	 <line12>	No
public class A { <line0> @Override <line1> public void start() { <line2> if (pool == null) { <line3> this.pool = <line4> IoTDBThreadPoolFactory.newCachedThreadPool(ThreadName.FLUSH_SUB_TASK_SERVICE.getName()); <line5> } <line6> } <line7> } <line8> 	 <line7>	No
public class A { <line0> @Override <line1> public String toString() { <line2> try { <line3> final long pos = m_offset * 8 + m_pos; <line4> final StringBuilder sb = new StringBuilder(); <line5> setPosition(0); <line6> for (long l = 0; l < m_length; l++) { <line7> sb.append(getBit()); <line8> } <line9> setPosition(pos); <line10> return sb.toString(); <line11> } catch (IOException e) { <line12> return (e.getMessage()); <line13> } <line14> } <line15> } <line16> 	 <line7>	No
"public class A { <line0> private static synchronized void checkIfNeeded() { <line1> if (Time.hasElapsedSince(lastSudoCheckTime, Duration.FIVE_MINUTES)) { <line2> try { <line3> lastSudoResult = <line4> new ProcessTool() <line5> .execCommands( <line6> MutableMap.<String, Object>of(), Arrays.asList(BashCommands.sudo(""date""))) <line7> == 0; <line8> } catch (Exception e) { <line9> lastSudoResult = false; <line10> } <line11> lastSudoCheckTime = System.currentTimeMillis(); <line12> } <line13> } <line14> } <line15> "	 <line1>	No
"public class A { <line0> @Bean(destroyMethod = ""stop"", name = ""wsCoreInboundDomainResponsesConnectionFactory"") <line1> public ConnectionFactory connectionFactory() { <line2> return this.jmsConfigurationFactory.getPooledConnectionFactory(); <line3> } <line4> } <line5> "	 <line0>	No
public class A { <line0> @Test <line1> public void testReuseLatch() throws Exception { <line2> final ReusableLatch latch = new ReusableLatch(5); <line3> for (int i = 0; i < 5; i++) { <line4> latch.countDown(); <line5> } <line6> latch.countUp(); <line7> class ThreadWait extends Thread { <line8> private volatile boolean waiting = false; <line9> private volatile Exception e; <line10> private final CountDownLatch readyLatch = new CountDownLatch(1); <line11>  <line12> @Override <line13> public void run() { <line14> waiting = true; <line15> readyLatch.countDown(); <line16> try { <line17> if (!latch.await(1000)) { <line18> } <line19> } catch (Exception e) { <line20> this.e = e; <line21> } <line22> waiting = false; <line23> } <line24> } <line25> ThreadWait t = new ThreadWait(); <line26> t.start(); <line27> t.readyLatch.await(); <line28> Assert.assertEquals(true, t.waiting); <line29> latch.countDown(); <line30> t.join(); <line31> Assert.assertEquals(false, t.waiting); <line32> Assert.assertNull(t.e); <line33> latch.countUp(); <line34> t = new ThreadWait(); <line35> t.start(); <line36> t.readyLatch.await(); <line37> Assert.assertEquals(true, t.waiting); <line38> latch.countDown(); <line39> t.join(); <line40> Assert.assertEquals(false, t.waiting); <line41> Assert.assertNull(t.e); <line42> Assert.assertTrue(latch.await(1000)); <line43> Assert.assertEquals(0, latch.getCount()); <line44> latch.countDown(); <line45> Assert.assertEquals(0, latch.getCount()); <line46> } <line47> } <line48> 	 <line11>	No
public class A { <line0> private void error(int count, long startTime, String sourceFile, String msg, Object... args) { <line1> if (count == 0) { <line2> final long ms = (System.nanoTime() - startTime) / 1000000; <line3> } <line4> } <line5> } <line6> 	 <line5>	No
public class A { <line0> @Override <line1> public WikiPageResource findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchPageResourceException { <line3> WikiPageResource wikiPageResource = fetchByPrimaryKey(primaryKey); <line4> if (wikiPageResource == null) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchPageResourceException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return wikiPageResource; <line10> } <line11> } <line12> 	 <line6>	Yes
public class A { <line0> private void sendDatapoint( <line1> final HmDatapoint dp, <line2> final HmDatapointConfig dpConfig, <line3> final Object newValue, <line4> final String rxMode, <line5> final boolean ignoreVirtualDatapoints) <line6> throws IOException, HomematicClientException { <line7> final HmDatapointInfo dpInfo = new HmDatapointInfo(dp); <line8> if (dp.isPressDatapoint() || (config.getGatewayInfo().isHomegear() && dp.isVariable())) { <line9> echoEvents.add(dpInfo); <line10> } <line11> if (dp.isReadOnly()) { <line12> } else if (HmValueType.ACTION == dp.getType() && MiscUtils.isFalseValue(newValue)) { <line13> } else { <line14> final VirtualGateway gateway = this; <line15> sendDelayedExecutor.start( <line16> dpInfo, <line17> dpConfig.getDelay(), <line18> new DelayedExecuterCallback() { <line19> @Override <line20> public void execute() throws IOException, HomematicClientException { <line21> VirtualDatapointHandler virtualDatapointHandler = <line22> ignoreVirtualDatapoints ? null : getVirtualDatapointHandler(dp, newValue); <line23> if (virtualDatapointHandler != null) { <line24> virtualDatapointHandler.handleCommand(gateway, dp, dpConfig, newValue); <line25> } else if (dp.isScript()) { <line26> if (MiscUtils.isTrueValue(newValue)) { <line27> executeScript(dp); <line28> } <line29> } else if (dp.isVariable()) { <line30> setVariable(dp, newValue); <line31> } else { <line32> getRpcClient(dp.getChannel().getDevice().getHmInterface()) <line33> .setDatapointValue(dp, newValue, rxMode); <line34> } <line35> dp.setValue(newValue); <line36> if (MiscUtils.isTrueValue(newValue) <line37> && (dp.isPressDatapoint() || dp.isScript() || dp.isActionType())) { <line38> disableDatapoint(dp, DEFAULT_DISABLE_DELAY); <line39> } <line40> } <line41> }); <line42> } <line43> } <line44> } <line45> 	 <line16>	No
"public class A { <line0> @VisibleForTesting <line1> void doCompactEntryLogs( <line2> final double threshold, CountDownLatch flushNotifier, CountDownLatch flushLatch) { <line3> Comparator<EntryLogMetadata> sizeComparator = <line4> new Comparator<EntryLogMetadata>() { <line5> @Override <line6> public int compare(EntryLogMetadata m1, EntryLogMetadata m2) { <line7> long unusedSize1 = m1.totalSize - m1.remainingSize; <line8> long unusedSize2 = m2.totalSize - m2.remainingSize; <line9> if (unusedSize1 > unusedSize2) { <line10> return -1; <line11> } else if (unusedSize1 < unusedSize2) { <line12> return 1; <line13> } else { <line14> return 0; <line15> } <line16> } <line17> }; <line18> Collection<EntryLogMetadata> entryLogMetadatas = <line19> entryLogger.getEntryLogMetadataManager().getEntryLogMetadatas(); <line20> List<EntryLogMetadata> logsToCompact = <line21> new ArrayList<EntryLogMetadata>(entryLogMetadatas.size()); <line22> List<EntryLogMetadata> logsToRemove = new ArrayList<EntryLogMetadata>(); <line23> logsToCompact.addAll(entryLogMetadatas); <line24> Collections.sort(logsToCompact, sizeComparator); <line25> Iterable<EntryLogMetadata> compactIterable = <line26> Iterables.filter( <line27> logsToCompact, <line28> new Predicate<EntryLogMetadata>() { <line29> @Override <line30> public boolean apply(EntryLogMetadata metadata) { <line31> return metadata.getUsage() < threshold; <line32> } <line33> }); <line34> CompactionScannerFactory scannerFactory = <line35> new CompactionScannerFactory(entryLogger, ledgerCache, throttler, statsLogger); <line36> for (EntryLogMetadata meta : compactIterable) { <line37> try { <line38> if (compactEntryLog(scannerFactory, meta)) { <line39> compactedEntryLogCounter.inc(); <line40> if (forceGarbageCollection.get()) { <line41> scannerFactory.flush(); <line42> if (removeEntryLog(entryLogger, meta.entryLogId, ""compacted"")) { <line43> deletedEntryLogCounter.inc(); <line44> } <line45> } else { <line46> logsToRemove.add(meta); <line47> } <line48> } <line49> } catch (LedgerDirsManager.NoWritableLedgerDirException nwlde) { <line50> break; <line51> } catch (IOException ioe) { <line52> } <line53> if (!running) { <line54> return; <line55> } <line56> } <line57> deletedEntryLogStats.registerSuccessfulEvent(logsToRemove.size()); <line58> if (logsToRemove.size() != 0) { <line59> if (!compacting.compareAndSet(false, true)) { <line60> return; <line61> } <line62> flushNotifier.countDown(); <line63> try { <line64> flushLatch.await(); <line65> } catch (InterruptedException e) { <line66> } <line67> try { <line68> scannerFactory.flush(); <line69> for (EntryLogMetadata metadata : logsToRemove) { <line70> if (removeEntryLog(entryLogger, metadata.entryLogId, ""compacted"")) { <line71> deletedEntryLogCounter.inc(); <line72> } <line73> } <line74> } catch (IOException e) { <line75> } finally { <line76> compacting.set(false); <line77> } <line78> } <line79> } <line80> } <line81> "	 <line59>	No
"public class A { <line0> @Override <line1> public void fail(Object messageId) { <line2> if (!isAtLeastOnceProcessing()) { <line3> return; <line4> } <line5> final KafkaSpoutMessageId msgId = (KafkaSpoutMessageId) messageId; <line6> if (!emitted.contains(msgId)) { <line7> return; <line8> } <line9> Validate.isTrue( <line10> !retryService.isScheduled(msgId), <line11> ""The message id "" <line12> + msgId <line13> + "" is queued for retry while being failed. This should never occur barring errors in"" <line14> + "" the RetryService implementation or the spout code.""); <line15> msgId.incrementNumFails(); <line16> if (!retryService.schedule(msgId)) { <line17> tupleListener.onMaxRetryReached(msgId); <line18> ack(msgId); <line19> } else { <line20> tupleListener.onRetry(msgId); <line21> emitted.remove(msgId); <line22> } <line23> } <line24> } <line25> "	 <line5>	No
public class A { <line0> @Override <line1> public Answer processRequest(Request request) { <line2> if (logger.isInfoEnabled()) { <line3> } <line4> DiameterListener listener = findListener(request); <line5> if (listener != null) { <line6> return listener.processRequest(request); <line7> } else { <line8> try { <line9> Answer answer = request.createAnswer(ResultCode.APPLICATION_UNSUPPORTED); <line10> return answer; <line11> } catch (Exception e) { <line12> } <line13> } <line14> return null; <line15> } <line16> } <line17> 	 <line9>	No
"public class A { <line0> @Override <line1> public void flush() throws IOException { <line2> if (buffer != null) { <line3> DeliveryOptions options = new DeliveryOptions(); <line4> if (deliveryOptionsHeaders != null) { <line5> options.setHeaders(deliveryOptionsHeaders); <line6> } <line7> if (TransmissionMode.send == transmissionMode) { <line8> eventBus.send( <line9> address, <line10> buffer.toString(), <line11> options, <line12> new Handler<AsyncResult<Message<JsonObject>>>() { <line13> @Override <line14> public void handle(AsyncResult<Message<JsonObject>> reply) { <line15> if (reply.succeeded() && ""ok"".equals(reply.result().body().getString(""status""))) { <line16> } else { <line17> } <line18> } <line19> }); <line20> } else { <line21> eventBus.publish(address, buffer.toString(), options); <line22> } <line23> buffer = null; <line24> } <line25> } <line26> } <line27> "	 <line14>	No
public class A { <line0> protected void exportPortletPreferences( <line1> PortletDataContext portletDataContext, <line2> long ownerId, <line3> int ownerType, <line4> boolean defaultUser, <line5> Layout layout, <line6> long plid, <line7> String portletId, <line8> Element parentElement) <line9> throws Exception { <line10> PortletPreferences portletPreferences = null; <line11> try { <line12> portletPreferences = getPortletPreferences(ownerId, ownerType, plid, portletId); <line13> } catch (NoSuchPortletPreferencesException noSuchPortletPreferencesException) { <line14> if (_log.isDebugEnabled()) { <line15> } <line16> return; <line17> } <line18> if (_hasPortletId(layout, portletId, ownerType)) { <line19> exportPortletPreference( <line20> portletDataContext, <line21> ownerId, <line22> ownerType, <line23> defaultUser, <line24> portletPreferences, <line25> portletId, <line26> plid, <line27> parentElement); <line28> } <line29> } <line30> } <line31> 	 <line15>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> protected Object resolveType(ClassLoader classLoader, Class pluginClass, Class type) { <line2> if (type.isAssignableFrom(PluginManager.class)) { <line3> return pluginManager; <line4> } else if (type.isAssignableFrom(Watcher.class)) { <line5> return pluginManager.getWatcher(); <line6> } else if (type.isAssignableFrom(Scheduler.class)) { <line7> return pluginManager.getScheduler(); <line8> } else if (type.isAssignableFrom(HotswapTransformer.class)) { <line9> return pluginManager.getHotswapTransformer(); <line10> } else if (type.isAssignableFrom(PluginConfiguration.class)) { <line11> return pluginManager.getPluginConfiguration(classLoader); <line12> } else if (type.isAssignableFrom(ClassLoader.class)) { <line13> return classLoader; <line14> } else if (type.isAssignableFrom(Instrumentation.class)) { <line15> return pluginManager.getInstrumentation(); <line16> } else { <line17> return null; <line18> } <line19> } <line20> } <line21> "	 <line14>	No
public class A { <line0> protected void onAfterLoadFromMemcached( <line1> @Nonnull final MemcachedBackupSession session, @Nullable final LockStatus lockStatus) { <line2> session.setLockStatus(lockStatus); <line3> final long start = System.currentTimeMillis(); <line4> final SessionValidityInfo info = loadSessionValidityInfo(session.getIdInternal()); <line5> if (info != null) { <line6> _stats.registerSince(NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start); <line7> session.setLastAccessedTimeInternal(info.getLastAccessedTime()); <line8> session.setThisAccessedTimeInternal(info.getThisAccessedTime()); <line9> } else { <line10> } <line11> } <line12> } <line13> 	 <line9>	No
"public class A { <line0> protected String getUserID(Credentials credentials) { <line1> String userId = null; <line2> if (credentials != null) { <line3> if (credentials instanceof GuestCredentials) { <line4> userId = anonymousId; <line5> } else if (credentials instanceof SimpleCredentials) { <line6> userId = ((SimpleCredentials) credentials).getUserID(); <line7> } else { <line8> try { <line9> NameCallback callback = new NameCallback(""User-ID: ""); <line10> callbackHandler.handle(new Callback[] {callback}); <line11> userId = callback.getName(); <line12> } catch (UnsupportedCallbackException e) { <line13> } catch (IOException e) { <line14> } <line15> } <line16> } <line17> if (userId == null && sharedState.containsKey(KEY_LOGIN_NAME)) { <line18> userId = (String) sharedState.get(KEY_LOGIN_NAME); <line19> } <line20> if (userId == null) { <line21> userId = anonymousId; <line22> } <line23> return userId; <line24> } <line25> } <line26> "	 <line5>	No
public class A { <line0> @Override <line1> public FileOutStream createFile(AlluxioURI path, CreateFilePOptions options) <line2> throws FileAlreadyExistsException, InvalidPathException, IOException, AlluxioException { <line3> checkUri(path); <line4> return rpc( <line5> client -> { <line6> CreateFilePOptions mergedOptions = <line7> FileSystemOptions.createFileDefaults(mFsContext.getPathConf(path)).toBuilder() <line8> .mergeFrom(options) <line9> .build(); <line10> URIStatus status = client.createFile(path, mergedOptions); <line11> OutStreamOptions outStreamOptions = <line12> new OutStreamOptions( <line13> mergedOptions, mFsContext.getClientContext(), mFsContext.getPathConf(path)); <line14> outStreamOptions.setUfsPath(status.getUfsPath()); <line15> outStreamOptions.setMountId(status.getMountId()); <line16> outStreamOptions.setAcl(status.getAcl()); <line17> try { <line18> return new AlluxioFileOutStream(path, outStreamOptions, mFsContext); <line19> } catch (Exception e) { <line20> delete(path); <line21> throw e; <line22> } <line23> }); <line24> } <line25> } <line26> 	 <line11>	Yes
"public class A { <line0> public String deleteUser() { <line1> String email = <line2> FacesContext.getCurrentInstance() <line3> .getExternalContext() <line4> .getRequestParameterMap() <line5> .get(""email""); <line6> UserController controller = new UserController(sessionUser); <line7> try { <line8> controller.delete(controller.retrieve(email)); <line9> } catch (Exception e) { <line10> } <line11> doSearch(); <line12> return """"; <line13> } <line14> } <line15> "	 <line10>	Yes
public class A { <line0> public boolean finished() { <line1> if (caller.isShutdown() && log.isTraceEnabled()) { <line2> } <line3> return caller.isShutdown() || (currentRange == null && lastSeenKey == null); <line4> } <line5> } <line6> 	 <line4>	No
"public class A { <line0> private void flush(Batch batch) throws IOException { <line1> if (batch == null) { <line2> return; <line3> } <line4> batch.seal(); <line5> try { <line6> emittedBatchCounter.awaitBatchEmitted( <line7> batch.batchNumber, config.getFlushTimeOut(), TimeUnit.MILLISECONDS); <line8> } catch (TimeoutException e) { <line9> String message = <line10> String.format(""Timed out after [%d] millis during flushing"", config.getFlushTimeOut()); <line11> throw new IOException(message, e); <line12> } catch (InterruptedException e) { <line13> Thread.currentThread().interrupt(); <line14> throw new IOException(""Thread Interrupted while flushing"", e); <line15> } <line16> } <line17> } <line18> "	 <line11>	No
"public class A { <line0> @Test <line1> public void testConcurrencyWithSchemaMigration() throws InterruptedException { <line2> SchemaListResponse schemas = call(() -> clientA.findSchemas()); <line3> SchemaResponse contentSchema = <line4> schemas.getData().stream().filter(s -> s.getName().equals(""content"")).findFirst().get(); <line5> String schemaUuid = contentSchema.getUuid(); <line6> String projectName = randomName(); <line7> ProjectCreateRequest request = new ProjectCreateRequest(); <line8> request.setName(projectName); <line9> request.setSchemaRef(""folder""); <line10> ProjectResponse project = call(() -> clientA.createProject(request)); <line11> call(() -> clientA.assignSchemaToProject(projectName, schemaUuid)); <line12> List<String> uuids = new ArrayList<>(); <line13> NodeCreateRequest nodeCreateRequest = new NodeCreateRequest(); <line14> nodeCreateRequest.setLanguage(""en""); <line15> nodeCreateRequest <line16> .getFields() <line17> .put(""teaser"", FieldUtil.createStringField(""some rorschach teaser"")); <line18> nodeCreateRequest <line19> .getFields() <line20> .put(""content"", FieldUtil.createStringField(""Blessed mealtime again!"")); <line21> nodeCreateRequest.setSchemaName(""content""); <line22> nodeCreateRequest.setParentNodeUuid(project.getRootNode().getUuid()); <line23> for (int i = 0; i < TEST_DATA_SIZE; i++) { <line24> nodeCreateRequest <line25> .getFields() <line26> .put(""slug"", FieldUtil.createStringField(""new-page"" + i + "".html"")); <line27> if (i % 10 == 0) { <line28> } <line29> uuids.add(call(() -> clientA.createNode(projectName, nodeCreateRequest)).getUuid()); <line30> } <line31> SchemaUpdateRequest schemaUpdateRequest = contentSchema.toUpdateRequest(); <line32> schemaUpdateRequest.addField(FieldUtil.createStringFieldSchema(""dummy"")); <line33> Completable opA = <line34> clientA.updateSchema(contentSchema.getUuid(), schemaUpdateRequest).toCompletable(); <line35> Completable opB = <line36> clientB <line37> .deleteNode(projectName, uuids.get(0)) <line38> .toCompletable() <line39> .delay(2000, TimeUnit.MILLISECONDS); <line40> Completable.merge(Arrays.asList(opA, opB)).blockingAwait(); <line41> Thread.sleep(30000); <line42> call(() -> clientA.findSchemaByUuid(contentSchema.getUuid())); <line43> call(() -> clientB.findSchemaByUuid(contentSchema.getUuid())); <line44> } <line45> } <line46> "	 <line28>	Yes
"public class A { <line0> protected void loadQrelsFile() { <line1> List<QrelsHashSet> vector = new ArrayList<QrelsHashSet>(); <line2> int linenumber = 0; <line3> String file = null; <line4> try { <line5> int qrelsCounter = 0; <line6> BufferedReader br = Files.openFileReader(file = fqrels[0].toString()); <line7> String preQueryid = ""1st""; <line8> linenumber = 0; <line9> QrelsHashSet qrelsHashSet = null; <line10> String str = null; <line11> while ((str = br.readLine()) != null || qrelsCounter != fqrels.length - 1) { <line12> if (str == null) { <line13> br.close(); <line14> br = Files.openFileReader(file = fqrels[++qrelsCounter].toString()); <line15> linenumber = 0; <line16> continue; <line17> } <line18> linenumber++; <line19> if (str.startsWith(""#"")) continue; <line20> if (str.trim().length() == 0) continue; <line21> StringTokenizer stk = new StringTokenizer(str); <line22> String queryid = parseTRECQueryNo(stk.nextToken()); <line23> stk.nextToken(); <line24> String docno = stk.nextToken(); <line25> int relGrade = Integer.parseInt(stk.nextToken()); <line26> boolean relevant = (relGrade > 0); <line27> if (!queryid.equals(preQueryid)) { <line28> if (preQueryid.equals(""1st"")) { <line29> qrelsHashSet = new QrelsHashSet(queryid); <line30> if (relevant) { <line31> qrelsHashSet.insertRelDocno(docno, relGrade); <line32> } else qrelsHashSet.insertNonRelDocno(docno); <line33> preQueryid = queryid; <line34> } else { <line35> vector.add((QrelsHashSet) qrelsHashSet.clone()); <line36> qrelsHashSet = new QrelsHashSet(queryid); <line37> if (relevant) qrelsHashSet.insertRelDocno(docno, relGrade); <line38> else qrelsHashSet.insertNonRelDocno(docno); <line39> preQueryid = queryid; <line40> } <line41> } else { <line42> if (relevant) qrelsHashSet.insertRelDocno(docno, relGrade); <line43> else qrelsHashSet.insertNonRelDocno(docno); <line44> } <line45> } <line46> vector.add((QrelsHashSet) qrelsHashSet.clone()); <line47> br.close(); <line48> } catch (Exception t) { <line49> throw new Error(t); <line50> } <line51> this.qrelsPerQuery = vector.toArray(new QrelsHashSet[vector.size()]); <line52> this.totalNumberOfRelevantDocs = 0; <line53> for (QrelsHashSet querySet : this.qrelsPerQuery) { <line54> this.qid2qrels.put(querySet.queryid, querySet); <line55> this.totalNumberOfRelevantDocs += querySet.getAllRelevantDocuments().size(); <line56> } <line57> } <line58> } <line59> "	 <line8>	No
"public class A { <line0> @Override <line1> public ObjectListing next() throws IOException { <line2> if (firstListing) { <line3> firstListing = false; <line4> } else { <line5> try { <line6> if (!objects.isTruncated()) { <line7> throw new NoSuchElementException(""No more results in listing of "" + listPath); <line8> } <line9> objects = OBSCommonUtils.continueListObjects(owner, objects); <line10> listingCount++; <line11> } catch (ObsException e) { <line12> throw OBSCommonUtils.translateException(""listObjects()"", listPath, e); <line13> } <line14> } <line15> return objects; <line16> } <line17> } <line18> "	 <line0>	No
public class A { <line0> public static Set<IdentifierExtractionResult> extractIdentifiers( <line1> UUID datasetKey, <line2> byte[] xml, <line3> OccurrenceSchemaType schemaType, <line4> boolean useTriplet, <line5> boolean useOccurrenceId) { <line6> Set<IdentifierExtractionResult> results = Sets.newHashSet(); <line7> List<RawOccurrenceRecord> records = parseRecord(xml, schemaType); <line8> if (records != null && !records.isEmpty()) { <line9> for (RawOccurrenceRecord record : records) { <line10> Set<UniqueIdentifier> ids = Sets.newHashSet(); <line11> if (useTriplet) { <line12> Triplet triplet = null; <line13> try { <line14> triplet = <line15> new Triplet( <line16> datasetKey, <line17> record.getInstitutionCode(), <line18> record.getCollectionCode(), <line19> record.getCatalogueNumber(), <line20> record.getUnitQualifier()); <line21> } catch (IllegalArgumentException e) { <line22> } <line23> if (triplet != null) { <line24> ids.add(triplet); <line25> } <line26> } <line27> if (useOccurrenceId <line28> && record.getIdentifierRecords() != null <line29> && !record.getIdentifierRecords().isEmpty()) { <line30> for (IdentifierRecord idRecord : record.getIdentifierRecords()) { <line31> if ((idRecord.getIdentifierType() == 1 || idRecord.getIdentifierType() == 7) <line32> && idRecord.getIdentifier() != null) { <line33> ids.add(new PublisherProvidedUniqueIdentifier(datasetKey, idRecord.getIdentifier())); <line34> } <line35> } <line36> } <line37> if (!ids.isEmpty()) { <line38> results.add(new IdentifierExtractionResult(ids, record.getUnitQualifier())); <line39> } <line40> } <line41> } <line42> return results; <line43> } <line44> } <line45> 	 <line23>	No
public class A { <line0> @Test <line1> public void testLinkloadingTwoScopes() throws CommandException { <line2> ItNetwork itNetwork = createNewBPOrganization(); <line3> ApplicationGroup applicationGroup = createGroup(itNetwork, ApplicationGroup.class); <line4> Application application = createElement(applicationGroup, Application.class); <line5> int baseGraph = itNetwork.getChildren().size() + 2; <line6> ItNetwork itNetwork1 = createNewBPOrganization(); <line7> ApplicationGroup applicationGroup1 = createGroup(itNetwork1, ApplicationGroup.class); <line8> Application application1 = createElement(applicationGroup1, Application.class); <line9> baseGraph += itNetwork1.getChildren().size() + 2; <line10> ItNetwork itNetwork2 = createNewBPOrganization(); <line11> ApplicationGroup applicationGroup2 = createGroup(itNetwork2, ApplicationGroup.class); <line12> Application application2 = createElement(applicationGroup2, Application.class); <line13> ItNetwork itNetwork3 = createNewBPOrganization(); <line14> ApplicationGroup applicationGroup3 = createGroup(itNetwork3, ApplicationGroup.class); <line15> Application application3 = createElement(applicationGroup3, Application.class); <line16> elementsToClear.add(itNetwork); <line17> elementsToClear.add(itNetwork1); <line18> elementsToClear.add(itNetwork2); <line19> elementsToClear.add(itNetwork3); <line20> createLink(application, application1, null); <line21> createLink(application1, application2, null); <line22> createLink(application2, application3, null); <line23> VeriniceGraph veriniceGraph = <line24> createGraphWithLoader( <line25> new FirstLinkedElementsLoader(), itNetwork.getScopeId(), itNetwork1.getScopeId()); <line26> Set<CnATreeElement> connectedSetOf = veriniceGraph.getElements(); <line27> assertTrue(connectedSetOf.contains(itNetwork)); <line28> assertTrue(connectedSetOf.contains(application1)); <line29> assertTrue(connectedSetOf.contains(application2)); <line30> assertFalse(connectedSetOf.contains(application3)); <line31> assertEquals(baseGraph + 1, connectedSetOf.size()); <line32> } <line33> } <line34> 	 <line2>	Yes
public class A { <line0> @Transactional <line1> private void importXLIFF(ImportExportedXliffStep importExportedXliffStep, String xliffContent) { <line2> IPipelineDriver driver = new PipelineDriver(); <line3> XLIFFFilter xliffFilter = new XLIFFFilter(); <line4> driver.addStep(new RawDocumentToFilterEventsStep(xliffFilter)); <line5> importExportedXliffStep.setXliffFilter(xliffFilter); <line6> driver.addStep(importExportedXliffStep); <line7> RawDocument rawDocument = new RawDocument(xliffContent, LocaleId.ENGLISH); <line8> driver.addBatchItem(rawDocument); <line9> driver.processBatch(); <line10> } <line11> } <line12> 	 <line9>	Yes
"public class A { <line0> private String selectActiveServerAddress(Client client, AtlasServerEnsemble serverEnsemble) <line1> throws AtlasServiceException { <line2> List<String> serverInstances = serverEnsemble.getMembers(); <line3> String activeServerAddress = null; <line4> for (String serverInstance : serverInstances) { <line5> activeServerAddress = getAddressIfActive(client, serverInstance); <line6> if (activeServerAddress != null) { <line7> break; <line8> } <line9> } <line10> if (activeServerAddress != null) return activeServerAddress; <line11> else <line12> throw new AtlasServiceException( <line13> API_STATUS, new RuntimeException(""Could not find any active instance"")); <line14> } <line15> } <line16> "	 <line12>	No
public class A { <line0> public List<UidMSEmail> fetch( <line1> UserDataRequest udr, <line2> CollectionId collectionId, <line3> MailboxPath path, <line4> Collection<Long> uids, <line5> List<BodyPreference> bodyPreferences, <line6> Optional<MimeSupport> mimeSupport) <line7> throws EmailViewPartsFetcherException { <line8> List<UidMSEmail> msEmails = Lists.newLinkedList(); <line9> EmailViewPartsFetcherImpl emailViewPartsFetcherImpl = <line10> new EmailViewPartsFetcherImpl( <line11> transformersFactory, mailboxService, bodyPreferences, udr, path, collectionId); <line12> for (Long uid : uids) { <line13> try { <line14> EmailView emailView = emailViewPartsFetcherImpl.fetch(uid, getMatchingPolicy(mimeSupport)); <line15> msEmails.add(msEmailConverter.convert(emailView, udr)); <line16> } catch (EmailViewBuildException e) { <line17> } catch (ItemNotFoundException e) { <line18> } <line19> } <line20> return msEmails; <line21> } <line22> } <line23> 	 <line11>	No
public class A { <line0> public void onNewMessage(ChannelHandlerContext ctx, Message message) { <line1> } <line2> } <line3> 	 <line0>	No
public class A { <line0> @Override <line1> public Authenticator<BasicCredentials, User> build(DSLContext dslContext) { <line2> LdapConnectionFactory connectionFactory = <line3> new LdapConnectionFactory( <line4> getServer(), <line5> getPort(), <line6> getUserDN(), <line7> getPassword(), <line8> getTrustStorePath(), <line9> getTrustStorePassword(), <line10> getTrustStoreType()); <line11> return new LdapAuthenticator(connectionFactory, getLookup()); <line12> } <line13> } <line14> 	 <line10>	No
public class A { <line0> @Override <line1> public void preallocateSpace(StoreChannel storeChannel, long version) { <line2> int fileDescriptor = fileSystem.getFileDescriptor(storeChannel); <line3> var result = nativeAccess.tryPreallocateSpace(fileDescriptor, rotationThreshold.get()); <line4> if (result.isError()) { <line5> } <line6> } <line7> } <line8> 	 <line6>	No
public class A { <line0> private static void testPerformance() { <line1> int limit = 1000; <line2> long t0, t1; <line3> t0 = System.currentTimeMillis(); <line4> for (int n = 0; n < limit; n++) { <line5> for (int k = 0; k <= n; k++) { <line6> fallingFactorial(n, k); <line7> } <line8> } <line9> t1 = System.currentTimeMillis(); <line10> t0 = System.currentTimeMillis(); <line11> for (int n = 0; n < limit; n++) { <line12> for (int k = 0; k <= n; k++) { <line13> byFactorials(n, k); <line14> } <line15> } <line16> t1 = System.currentTimeMillis(); <line17> t0 = System.currentTimeMillis(); <line18> for (int n = 0; n < limit; n++) { <line19> for (int k = 0; k <= n; k++) { <line20> simpleProduct(n, k); <line21> } <line22> } <line23> t1 = System.currentTimeMillis(); <line24> } <line25> } <line26> 	 <line2>	No
public class A { <line0> public int getIntProperty(String key) { <line1> String s = getProperty(key); <line2> int value = -1; <line3> if (!isBlank(s)) { <line4> try { <line5> value = Integer.parseInt(s.trim()); <line6> } catch (NumberFormatException e) { <line7> } <line8> } <line9> return value; <line10> } <line11> } <line12> 	 <line6>	No
"public class A { <line0> @Test <line1> public void testNotEqual() throws Exception { <line2> String state = ""'Missouri'""; <line3> String query = <line4> CityField.STATE.name() <line5> + NE_OP <line6> + state <line7> + AND_OP <line8> + CityField.CONTINENT.name() <line9> + RE_OP <line10> + ""'north.*'""; <line11> runCountTest(query); <line12> } <line13> } <line14> "	 <line1>	No
public class A { <line0> @Override <line1> public ResourceModel processResourceModel( <line2> ResourceModel resourceModel, Configuration configuration) { <line3> final List<Resource> resources = new ArrayList<>(); <line4> for (Resource resource : resourceModel.getResources()) { <line5> resources.add(resource); <line6> resources.addAll(findChildResources(resource)); <line7> } <line8> logResources(resources); <line9> return resourceModel; <line10> } <line11> } <line12> 	 <line8>	No
"public class A { <line0> public static void sendMessage(Address[] recipients, Session session, MimeMessage message) <line1> throws MessagingException { <line2> Transport transport = null; <line3> try { <line4> transport = session.getTransport(""smtp""); <line5> String host = session.getProperty(""mail.smtp.host""); <line6> String port = session.getProperty(""mail.smtp.port""); <line7> String user = session.getProperty(""connect.mail.user""); <line8> String pass = session.getProperty(""connect.mail.pass""); <line9> if (!StringUtils.isBlank(port)) { <line10> port = StringUtils.trim(port); <line11> } <line12> transport.connect(host, Integer.parseInt(port), user, pass); <line13> transport.sendMessage(message, recipients); <line14> logHeaders(message); <line15> } catch (AssertionError e) { <line16> throw e; <line17> } finally { <line18> if (transport != null) { <line19> try { <line20> transport.close(); <line21> } catch (MessagingException e) { <line22> } <line23> } <line24> } <line25> } <line26> } <line27> "	 <line5>	No
"public class A { <line0> private String _writeDataFile(String dat) { <line1> String fn = """"; <line2> StringReader stringReader = null; <line3> PrintWriter printWriter = null; <line4> try { <line5> String home = System.getProperty(""user.home""); <line6> home = home.replace('\\', '/'); <line7> fn = home + ""/"" + _getUniqueFileName(""dat"") + _counter; <line8> stringReader = new StringReader(dat); <line9> File dataFile = new File(fn); <line10> OutputStreamWriter w = new OutputStreamWriter(new FileOutputStream(dataFile), ""UTF-8""); <line11> printWriter = new PrintWriter(w); <line12> int c; <line13> while ((c = stringReader.read()) != -1) { <line14> printWriter.write(c); <line15> } <line16> } catch (Exception exc) { <line17> } finally { <line18> try { <line19> if (stringReader != null) { <line20> stringReader.close(); <line21> } <line22> } finally { <line23> if (printWriter != null) { <line24> printWriter.close(); <line25> } <line26> } <line27> } <line28> _counter++; <line29> return fn; <line30> } <line31> } <line32> "	 <line12>	No
"public class A { <line0> protected void populateResourceTypeAndParameterNameTableEntries(Integer tenantId) { <line1> try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) { <line2> try (Connection c = connectionPool.getConnection(); ) { <line3> String logTenantId = tenantId != null ? Integer.toString(tenantId) : ""default""; <line4> PopulateResourceTypes populateResourceTypes = <line5> new PopulateResourceTypes( <line6> schema.getAdminSchemaName(), schema.getSchemaName(), tenantId); <line7> populateResourceTypes.run(translator, c); <line8> PopulateParameterNames populateParameterNames = <line9> new PopulateParameterNames( <line10> schema.getAdminSchemaName(), schema.getSchemaName(), tenantId); <line11> populateParameterNames.run(translator, c); <line12> } catch (SQLException ex) { <line13> tx.setRollbackOnly(); <line14> throw new DataAccessException(ex); <line15> } catch (DataAccessException x) { <line16> tx.setRollbackOnly(); <line17> throw x; <line18> } <line19> } <line20> } <line21> } <line22> "	 <line7>	No
public class A { <line0> @Override <line1> public OrderInstance getInstance(Order order) throws FogbowException { <line2> try { <line3> RemoteGetInstanceRequest remoteGetInstanceRequest = new RemoteGetInstanceRequest(order); <line4> OrderInstance instance = remoteGetInstanceRequest.send(); <line5> return instance; <line6> } catch (InstanceNotFoundException e) { <line7> throw e; <line8> } catch (Exception e) { <line9> throw new FogbowException(e.getMessage()); <line10> } <line11> } <line12> } <line13> 	 <line0>	No
public class A { <line0> public void attachDirty(StgSysMapping instance) { <line1> try { <line2> sessionFactory.getCurrentSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> public void createNextYearProcess() <line1> throws ProcessGenerationException, IOException, DAOException, CommandException { <line2> final long begin = System.nanoTime(); <line3> Entry<String, IncludedStructuralElement> yearToCreate = yearsIterator.next(); <line4> String yearTitle = getYearTitle(yearToCreate.getKey()); <line5> ProcessGenerator processGenerator = new ProcessGenerator(); <line6> processGenerator.generateProcess(templateId, projectId); <line7> Process yearProcess = processGenerator.getGeneratedProcess(); <line8> yearProcess.setTitle(yearTitle); <line9> ProcessService.checkTasks(yearProcess, yearToCreate.getValue().getType()); <line10> processService.saveToDatabase(yearProcess); <line11> MetadataEditor.addLink(overallWorkpiece.getRootElement(), yearProcess.getId()); <line12> if (!yearsIterator.hasNext()) { <line13> metsService.saveWorkpiece( <line14> overallWorkpiece, fileService.getMetadataFilePath(overallProcess, false, false)); <line15> } <line16> yearProcess.setParent(overallProcess); <line17> overallProcess.getChildren().add(yearProcess); <line18> processService.saveToDatabase(yearProcess); <line19> ServiceManager.getFileService().createProcessLocation(yearProcess); <line20> createYearWorkpiece(yearToCreate, yearTitle, yearProcess); <line21> Collection<Integer> childIds = yearsChildren.get(yearToCreate.getKey()); <line22> for (Integer childId : childIds) { <line23> Process child = processService.getById(childId); <line24> child.setParent(yearProcess); <line25> yearProcess.getChildren().add(child); <line26> processService.saveToDatabase(child); <line27> } <line28> processService.saveToDatabase(yearProcess); <line29> addToBatch(yearProcess); <line30> if (logger.isTraceEnabled()) { <line31> } <line32> } <line33> } <line34> 	 <line31>	Yes
"public class A { <line0> List<UserAgentShare> userAgentDownloadShares(final StatsRequest statsRequest) { <line1> Stopwatch stopwatch = Stopwatch.createStarted(); <line2> String sql = <line3> ""SELECT\n"" <line4> + ""  user_agent,\n"" <line5> + ""  count(*)\n"" <line6> + ""FROM INDEXERNZBDOWNLOAD\n"" <line7> + ""WHERE user_agent IS NOT NULL\n"" <line8> + ""and ACCESS_SOURCE = 'API' \n"" <line9> + buildWhereFromStatsRequest(true, statsRequest) <line10> + ""GROUP BY user_agent""; <line11> Query query = entityManager.createNativeQuery(sql); <line12> List<Object> resultList = query.getResultList(); <line13> List<UserAgentShare> result = new ArrayList<>(); <line14> int countAll = 0; <line15> for (Object o : resultList) { <line16> Object[] o2 = (Object[]) o; <line17> String userAgent = (String) o2[0]; <line18> int countForUserAgent = ((BigInteger) o2[1]).intValue(); <line19> countAll += countForUserAgent; <line20> result.add(new UserAgentShare(userAgent, countForUserAgent)); <line21> } <line22> for (UserAgentShare userAgentShare : result) { <line23> userAgentShare.setPercentage(100F / ((float) countAll / userAgentShare.getCount())); <line24> } <line25> result.sort(Comparator.comparingDouble(UserAgentShare::getPercentage).reversed()); <line26> return result; <line27> } <line28> } <line29> "	 <line28>	No
public class A { <line0> public static String toJson(Object obj, Class<?> model) { <line1> ObjectWriter writer = mapper.writer(); <line2> if (null != obj) { <line3> try { <line4> if (null != model) { <line5> writer = writer.withView(model); <line6> } <line7> return writer.writeValueAsString(obj); <line8> } catch (JsonProcessingException e) { <line9> throw new RuntimeException(e); <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	 <line8>	No
public class A { <line0> @Deactivate <line1> public void deactivate() { <line2> unregisterAllServices(); <line3> if (mdnsClient != null) { <line4> mdnsClient.close(); <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
public class A { <line0> public static boolean canLoadAndInitClass(String name) { <line1> try { <line2> Class.forName(name, true, UnitHelp.class.getClassLoader()); <line3> return true; <line4> } catch (Throwable e) { <line5> return false; <line6> } <line7> } <line8> } <line9> 	 <line3>	Yes
public class A { <line0> private void pullUpItem(ParseTree ctx) { <line1> items.put(ctx, getItem(ctx.getChild(0))); <line2> } <line3> } <line4> 	 <line1>	Yes
"public class A { <line0> @Test <line1> void changeTemplate() throws Exception { <line2> final String name = ""test-ui-config-2""; <line3> assertTrue(graphql.addTemplate(emptySetting(name).type(TemplateType.DASHBOARD)).isStatus()); <line4> TimeUnit.SECONDS.sleep(2L); <line5> TemplateChangeStatus templateChangeStatus = <line6> graphql.changeTemplate(emptySetting(name).type(TemplateType.TOPOLOGY_SERVICE)); <line7> assertTrue(templateChangeStatus.isStatus()); <line8> TimeUnit.SECONDS.sleep(2L); <line9> verifyTemplates(""expected/storage/dashboardConfiguration-change.yml""); <line10> } <line11> } <line12> "	 <line3>	No
"public class A { <line0> public boolean match(final Cookie cookie, final CookieOrigin origin) { <line1> if (cookie == null) { <line2> throw new IllegalArgumentException(""Cookie may not be null""); <line3> } <line4> if (origin == null) { <line5> throw new IllegalArgumentException(""Cookie origin may not be null""); <line6> } <line7> if (cookie instanceof Cookie2) { <line8> Cookie2 cookie2 = (Cookie2) cookie; <line9> int port = origin.getPort(); <line10> if (cookie2.isPortAttributeSpecified()) { <line11> if (cookie2.getPorts() == null) { <line12> return false; <line13> } <line14> if (!portMatch(port, cookie2.getPorts())) { <line15> return false; <line16> } <line17> } <line18> return true; <line19> } else { <line20> return false; <line21> } <line22> } <line23> } <line24> "	 <line13>	No
"public class A { <line0> private void buildRedisClient(RedisSideTableInfo tableInfo) { <line1> String url = redisSideTableInfo.getUrl(); <line2> String password = <line3> Objects.isNull(redisSideTableInfo.getPassword()) ? """" : redisSideTableInfo.getPassword(); <line4> String database = redisSideTableInfo.getDatabase(); <line5> if (Objects.isNull(database)) { <line6> database = ""0""; <line7> } <line8> switch (RedisType.parse(tableInfo.getRedisType())) { <line9> case STANDALONE: <line10> RedisURI redisUri = RedisURI.create(""redis://"" + url); <line11> redisUri.setPassword(password); <line12> redisUri.setDatabase(Integer.parseInt(database)); <line13> redisClient = RedisClient.create(redisUri); <line14> connection = redisClient.connect(); <line15> async = connection.async(); <line16> break; <line17> case SENTINEL: <line18> RedisURI redisSentinelUri = RedisURI.create(""redis-sentinel://"" + url); <line19> redisSentinelUri.setPassword(password); <line20> redisSentinelUri.setDatabase(Integer.parseInt(database)); <line21> redisSentinelUri.setSentinelMasterId(redisSideTableInfo.getMasterName()); <line22> redisClient = RedisClient.create(redisSentinelUri); <line23> connection = redisClient.connect(); <line24> async = connection.async(); <line25> break; <line26> case CLUSTER: <line27> RedisURI clusterUri = RedisURI.create(""redis://"" + url); <line28> clusterUri.setPassword(password); <line29> clusterClient = RedisClusterClient.create(clusterUri); <line30> clusterConnection = clusterClient.connect(); <line31> async = clusterConnection.async(); <line32> default: <line33> break; <line34> } <line35> } <line36> } <line37> "	 <line4>	No
"public class A { <line0> @Override <line1> public MbusChannelElementsResponseDto execute( <line2> final DlmsConnectionManager conn, <line3> final DlmsDevice device, <line4> final MbusChannelElementsDto requestDto) <line5> throws ProtocolAdapterException { <line6> final List<ChannelElementValuesDto> candidateChannelElementValues = <line7> this.deviceChannelsHelper.findCandidateChannelsForDevice(conn, device, requestDto); <line8> final ChannelElementValuesDto lastChannelElementValuesRetrieved = <line9> candidateChannelElementValues.get(candidateChannelElementValues.size() - 1); <line10> if (FindMatchingChannelHelper.matches(requestDto, lastChannelElementValuesRetrieved)) { <line11> return new MbusChannelElementsResponseDto( <line12> requestDto, <line13> lastChannelElementValuesRetrieved.getChannel(), <line14> candidateChannelElementValues); <line15> } <line16> final ChannelElementValuesDto bestMatch = <line17> FindMatchingChannelHelper.bestMatch(requestDto, candidateChannelElementValues); <line18> if (bestMatch != null) { <line19> return new MbusChannelElementsResponseDto( <line20> requestDto, bestMatch.getChannel(), candidateChannelElementValues); <line21> } <line22> final ChannelElementValuesDto emptyChannelMatch = <line23> this.deviceChannelsHelper.findEmptyChannel(candidateChannelElementValues); <line24> if (emptyChannelMatch == null) { <line25> return new MbusChannelElementsResponseDto(requestDto, null, candidateChannelElementValues); <line26> } <line27> final ChannelElementValuesDto updatedChannelElementValues = <line28> this.deviceChannelsHelper.writeUpdatedMbus( <line29> conn, <line30> requestDto, <line31> emptyChannelMatch.getChannel(), <line32> Protocol.forDevice(device), <line33> ""CoupleMBusDevice""); <line34> candidateChannelElementValues.set( <line35> this.deviceChannelsHelper.correctFirstChannelOffset(emptyChannelMatch), <line36> updatedChannelElementValues); <line37> return new MbusChannelElementsResponseDto( <line38> requestDto, updatedChannelElementValues.getChannel(), candidateChannelElementValues); <line39> } <line40> } <line41> "	 <line6>	Yes
"public class A { <line0> public static void addPasswordPolicyOrganizations( <line1> HttpPrincipal httpPrincipal, long passwordPolicyId, long[] organizationIds) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> OrganizationServiceUtil.class, <line7> ""addPasswordPolicyOrganizations"", <line8> _addPasswordPolicyOrganizationsParameterTypes3); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, passwordPolicyId, organizationIds); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	 <line9>	No
public class A { <line0> public static ExpressionEngine create() { <line1> final ExpressionEngine engine = doCreate(); <line2> return engine; <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> @Override <line1> protected void runTask(BlockTask task) { <line2> try { <line3> task.run(); <line4> } catch (Moka7Exception e) { <line5> handleMoka7IOException(e); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	 <line1>	No
"public class A { <line0> @Override <line1> public void run() { <line2> for (ImageryFileSource src : mySources) { <line3> if (src.isCreateOverviews() && mySourceToDsMap.get(src) != null) { <line4> myTotalFileCount++; <line5> } <line6> } <line7> myCurrentFileCount = 0; <line8> EventQueueUtilities.runOnEDT( <line9> new Runnable() { <line10> @Override <line11> public void run() { <line12> myProcFilePB.setMaximum(myTotalFileCount); <line13> myProcFilePB.setValue(0); <line14> myProcFileNoteLB.setText(""Processing File 1 of "" + myTotalFileCount); <line15> myFileOVGenPB.setMaximum(100); <line16> myFileOVGenPB.setValue(0); <line17> myConsoleOutputTA.setText( <line18> myConsoleOutputTA.getText() + ""Beginning Overview Generation...\n""); <line19> } <line20> }); <line21> for (ImageryFileSource src : mySources) { <line22> if (src.isCreateOverviews() && mySourceToDsMap.get(src) != null) { <line23> final String fileName = src.getName(); <line24> EventQueueUtilities.runOnEDT( <line25> new Runnable() { <line26> @Override <line27> public void run() { <line28> myProcFileNoteLB.setText( <line29> ""Processing File "" + (myCurrentFileCount + 1) + "" of "" + myTotalFileCount); <line30> myProcFilePB.setMaximum(myTotalFileCount); <line31> myFileOVGenPB.setValue(0); <line32> myGenOvNoteLB.setText(""Generating Overview Files For: "" + fileName); <line33> myConsoleOutputTA.setText( <line34> myConsoleOutputTA.getText() + ""Processing File: "" + fileName + ""\n""); <line35> } <line36> }); <line37> Dataset ds = mySourceToDsMap.get(src); <line38> int[] levels = {2, 4, 8, 16, 32, 64, 128}; <line39> try { <line40> if (ds.BuildOverviews(""NEAREST"", levels, myProgressCallback) != gdalconst.CE_None) { <line41> EventQueueUtilities.runOnEDT( <line42> () -> <line43> myConsoleOutputTA.setText( <line44> myConsoleOutputTA.getText() + ""ERROR: Failed to create overview\n"")); <line45> } else { <line46> src.setHasOverviews(true); <line47> } <line48> } catch (RuntimeException e) { <line49> final Exception fExc = e; <line50> EventQueueUtilities.runOnEDT( <line51> () -> <line52> myConsoleOutputTA.setText( <line53> myConsoleOutputTA.getText() <line54> + ""ERROR: Exception while creating overview:\n"" <line55> + fExc.getMessage() <line56> + ""\n"")); <line57> } <line58> myCurrentFileCount++; <line59> EventQueueUtilities.runOnEDT( <line60> new Runnable() { <line61> @Override <line62> public void run() { <line63> myProcFilePB.setValue(myCurrentFileCount); <line64> myConsoleOutputTA.setText( <line65> myConsoleOutputTA.getText() + ""Done With File: "" + fileName + ""\n""); <line66> } <line67> }); <line68> } <line69> } <line70> finishStuff(); <line71> } <line72> } <line73> "	 <line57>	Yes
"public class A { <line0> ObjStat handleNoObjStatUnderRootOrHomeByLookingForPublicAndHome(final String irodsAbsolutePath) <line1> throws FileNotFoundException, JargonException { <line2> if (irodsAbsolutePath == null || irodsAbsolutePath.isEmpty()) { <line3> throw new IllegalArgumentException(""null or empty irodsAbsolutePath""); <line4> } <line5> ObjStat objStat = null; <line6> if (!irodsAccessObjectFactory <line7> .getJargonProperties() <line8> .isDefaultToPublicIfNothingUnderRootWhenListing()) { <line9> throw new FileNotFoundException(""the object cannot be found""); <line10> } <line11> if (irodsAbsolutePath.equals(""/"")) { <line12> objStat = new ObjStat(); <line13> objStat.setAbsolutePath(irodsAbsolutePath); <line14> objStat.setObjectType(ObjectType.COLLECTION_HEURISTIC_STANDIN); <line15> objStat.setSpecColType(SpecColType.NORMAL); <line16> objStat.setStandInGeneratedObjStat(true); <line17> objStat.setModifiedAt(new Date()); <line18> objStat.setCreatedAt(new Date()); <line19> return objStat; <line20> } <line21> List<String> components = MiscIRODSUtils.breakIRODSPathIntoComponents(irodsAbsolutePath); <line22> if (components.size() == 2) { <line23> ZoneAO zoneAO = irodsAccessObjectFactory.getZoneAO(irodsAccount); <line24> List<String> zones = zoneAO.listZoneNames(); <line25> boolean found = false; <line26> for (String zone : zones) { <line27> if (zone.equals(components.get(1))) { <line28> found = true; <line29> break; <line30> } <line31> } <line32> if (!found) { <line33> throw new FileNotFoundException(""path does not exist""); <line34> } <line35> objStat = new ObjStat(); <line36> objStat.setAbsolutePath(irodsAbsolutePath); <line37> objStat.setObjectType(ObjectType.COLLECTION_HEURISTIC_STANDIN); <line38> objStat.setSpecColType(SpecColType.NORMAL); <line39> objStat.setStandInGeneratedObjStat(true); <line40> objStat.setModifiedAt(new Date()); <line41> objStat.setCreatedAt(new Date()); <line42> return objStat; <line43> } <line44> if (components.size() == 3) { <line45> if (components.get(2).equals(""home"")) { <line46> objStat = new ObjStat(); <line47> objStat.setAbsolutePath(irodsAbsolutePath); <line48> objStat.setObjectType(ObjectType.COLLECTION_HEURISTIC_STANDIN); <line49> objStat.setSpecColType(SpecColType.NORMAL); <line50> objStat.setStandInGeneratedObjStat(true); <line51> objStat.setModifiedAt(new Date()); <line52> objStat.setCreatedAt(new Date()); <line53> return objStat; <line54> } <line55> } <line56> throw new FileNotFoundException(""unable to find file under path""); <line57> } <line58> } <line59> "	 <line22>	No
"public class A { <line0> @PreAuthorize(""hasRole('"" + IdRepoEntitlement.ANYTYPE_UPDATE + ""')"") <line1> public AnyTypeTO update(final AnyTypeTO anyTypeTO) { <line2> AnyType anyType = anyTypeDAO.find(anyTypeTO.getKey()); <line3> if (anyType == null) { <line4> throw new NotFoundException(anyTypeTO.getKey()); <line5> } <line6> binder.update(anyType, anyTypeTO); <line7> return binder.getAnyTypeTO(anyTypeDAO.save(anyType)); <line8> } <line9> } <line10> "	 <line2>	No
public class A { <line0> public void delete(StgSysExportAuswahl persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> private void sendAck(UUID nodeId, CompletableLatchUid latchUid, boolean finalAck) { <line1> try { <line2> if (discovery.alive(nodeId)) { <line3> io.sendToGridTopic( <line4> nodeId, <line5> GridTopic.TOPIC_EXCHANGE, <line6> new LatchAckMessage(latchUid.id, latchUid.topVer, finalAck), <line7> GridIoPolicy.SYSTEM_POOL); <line8> if (log.isDebugEnabled()) <line9> } <line10> } catch (IgniteCheckedException e) { <line11> if (log.isDebugEnabled()) <line12> } <line13> } <line14> } <line15> 	 <line12>	Yes
"public class A { <line0> @Override <line1> protected DataSource retrieve(String dsName) throws DBDatasourceServiceException { <line2> DataSource ds = null; <line3> requestedDatasourceName = dsName; <line4> try { <line5> IDatasourceMgmtService datasourceMgmtSvc = getDatasourceMgmtService(); <line6> IDatabaseConnection databaseConnection = datasourceMgmtSvc.getDatasourceByName(dsName); <line7> if (databaseConnection != null <line8> && !databaseConnection.getAccessType().equals(DatabaseAccessType.JNDI)) { <line9> ds = resolveDatabaseConnection(databaseConnection); <line10> } else { <line11> try { <line12> ds = getJndiDataSource(dsName); <line13> } catch (DBDatasourceServiceException e) { <line14> } <line15> } <line16> if (ds == null && databaseConnection != null) { <line17> ds = getJndiDataSource(databaseConnection.getDatabaseName()); <line18> } <line19> if (ds != null) { <line20> cacheManager.putInRegionCache(IDBDatasourceService.JDBC_DATASOURCE, dsName, ds); <line21> } <line22> } catch (DatasourceMgmtServiceException daoe) { <line23> try { <line24> return getJndiDataSource(dsName); <line25> } catch (DBDatasourceServiceException dse) { <line26> throw new DBDatasourceServiceException( <line27> Messages.getInstance() <line28> .getErrorString(""DatasourceService.ERROR_0003_UNABLE_TO_GET_JNDI_DATASOURCE""), <line29> dse); <line30> } <line31> } <line32> return ds; <line33> } <line34> } <line35> "	 <line7>	No
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (cambriaConsumer == null) { <line4> BeEcompErrorManager.getInstance() <line5> .logBeUebSystemError( <line6> DISTRIBUTION_STATUS_POLLING, ""polling task was not initialized properly""); <line7> stopTask(); <line8> return; <line9> } <line10> Either<Iterable<String>, CambriaErrorResponse> fetchResult = <line11> cambriaHandler.fetchFromTopic(cambriaConsumer); <line12> if (fetchResult.isRight()) { <line13> CambriaErrorResponse errorResponse = fetchResult.right().value(); <line14> BeEcompErrorManager.getInstance() <line15> .logBeUebSystemError( <line16> DISTRIBUTION_STATUS_POLLING, <line17> ""failed to fetch messages from topic "" + topicName + "" error: "" + errorResponse); <line18> return; <line19> } <line20> Iterable<String> messages = fetchResult.left().value(); <line21> for (String message : messages) { <line22> try { <line23> DistributionStatusNotification notification = <line24> gson.fromJson(message, DistributionStatusNotification.class); <line25> audit.startAuditFetchLog(PARTNER_NAME, DistributionEnginePollingTask.class.getName()); <line26> handleDistributionNotificationMsg(notification, audit); <line27> distributionEngineClusterHealth.setHealthCheckOkAndReportInCaseLastStateIsDown(); <line28> } catch (Exception e) { <line29> BeEcompErrorManager.getInstance() <line30> .logBeUebSystemError( <line31> DISTRIBUTION_STATUS_POLLING, <line32> ""failed to parse message "" <line33> + message <line34> + "" from topic "" <line35> + topicName <line36> + "" error: "" <line37> + fetchResult.right().value()); <line38> } <line39> } <line40> } catch (Exception e) { <line41> String methodName = Object.class.getEnclosingMethod().getName(); <line42> BeEcompErrorManager.getInstance() <line43> .logBeDistributionEngineSystemError(methodName, e.getMessage()); <line44> } <line45> } <line46> } <line47> "	 <line29>	Yes
public class A { <line0> private int processSingle( <line1> SCE_LFE scelfe, FilterBank filterBank, int channel, Profile profile, SampleFrequency sf) <line2> throws AACException { <line3> final ICStream ics = scelfe.getICStream(); <line4> final ICSInfo info = ics.getInfo(); <line5> final LTPrediction ltp = info.getLTPrediction1(); <line6> final int elementID = scelfe.getElementInstanceTag(); <line7> final float[] iqData = ics.getInvQuantData(); <line8> if (profile.equals(Profile.AAC_MAIN) && info.isICPredictionPresent()) <line9> info.getICPrediction().process(ics, iqData, sf); <line10> if (LTPrediction.isLTPProfile(profile) && info.isLTPrediction1Present()) <line11> ltp.process(ics, iqData, filterBank, sf); <line12> processDependentCoupling(false, elementID, CCE.BEFORE_TNS, iqData, null); <line13> if (ics.isTNSDataPresent()) ics.getTNS().process(ics, iqData, sf, false); <line14> processDependentCoupling(false, elementID, CCE.AFTER_TNS, iqData, null); <line15> filterBank.process( <line16> info.getWindowSequence(), <line17> info.getWindowShape(ICSInfo.CURRENT), <line18> info.getWindowShape(ICSInfo.PREVIOUS), <line19> iqData, <line20> data[channel], <line21> channel); <line22> if (LTPrediction.isLTPProfile(profile)) <line23> ltp.updateState(data[channel], filterBank.getOverlap(channel), profile); <line24> processIndependentCoupling(false, elementID, data[channel], null); <line25> if (ics.isGainControlPresent()) <line26> ics.getGainControl() <line27> .process( <line28> iqData, <line29> info.getWindowShape(ICSInfo.CURRENT), <line30> info.getWindowShape(ICSInfo.PREVIOUS), <line31> info.getWindowSequence()); <line32> int chs = 1; <line33> if (sbrPresent && config.isSBREnabled()) { <line34> if (data[channel].length == config.getFrameLength()) <line35> final SBR sbr = scelfe.getSBR(); <line36> if (sbr.isPSUsed()) { <line37> chs = 2; <line38> scelfe.getSBR()._process(data[channel], data[channel + 1], false); <line39> } else scelfe.getSBR().process(data[channel], false); <line40> } <line41> return chs; <line42> } <line43> } <line44> 	 <line23>	No
"public class A { <line0> @POST <line1> @Path(""/@merge"") <line2> @Consumes(MediaType.APPLICATION_JSON + "";charset=UTF-8"") <line3> @Produces(MediaType.APPLICATION_JSON + "";charset=UTF-8"") <line4> public Response<Resource> mergeContacts( <line5> @PathParam(""said"") String said, Request<Resource> request) { <line6> Data<Resource> returnData = null; <line7> Resource entry = request.getMessage().getData().entry.iterator().next(); <line8> ArrayList items = (ArrayList) entry.get(""items""); <line9> try { <line10> Collection<URIImpl[]> collectionUris = toUriCollection(items); <line11> returnData = new Data<Resource>(0, collectionUris.size(), collectionUris.size()); <line12> for (URIImpl[] personUri : collectionUris) { <line13> Person person = null; <line14> URI master = personUri[0]; <line15> URI[] targets = (URI[]) ArrayUtils.remove(personUri, 0); <line16> person = personManager.merge(master, targets); <line17> returnData.getEntries().add(new Resource(person, personManager.getMe().asURI())); <line18> } <line19> } catch (InfosphereException e) { <line20> return Response.badRequest(e.getMessage(), e); <line21> } catch (Exception e) { <line22> return Response.serverError(e.getMessage(), e); <line23> } <line24> return Response.ok(returnData); <line25> } <line26> } <line27> "	 <line6>	Yes
public class A { <line0> public NodeIterator execute() throws Exception { <line1> UserTransactionImpl tx = new UserTransactionImpl(getSession()); <line2> tx.begin(); <line3> NodeIterator it = op.execute(); <line4> tx.commit(); <line5> return it; <line6> } <line7> } <line8> 	 <line2>	Yes
"public class A { <line0> void remove(Suffix se) throws RemoveException { <line1> LdapConnection ld = null; <line2> String nodeDn = getDn(se); <line3> try { <line4> ld = getAdminConnection(); <line5> deleteRecursive(ld, nodeDn); <line6> } catch (CursorException e) { <line7> String error = <line8> ""remove suffix node dn ["" + nodeDn + ""] caught CursorException="" + e.getMessage(); <line9> throw new RemoveException(GlobalErrIds.SUFX_DELETE_FAILED, error, e); <line10> } catch (LdapException e) { <line11> String error = ""remove suffix node dn ["" + nodeDn + ""] caught LDAPException="" + e; <line12> throw new RemoveException(GlobalErrIds.SUFX_DELETE_FAILED, error, e); <line13> } finally { <line14> closeAdminConnection(ld); <line15> } <line16> } <line17> } <line18> "	 <line7>	No
"public class A { <line0> private void updateReportTime() { <line1> reportModulo = activityDef.getParams().getOptionalLong(""modulo"").orElse(10000000L); <line2> lastUpdate = System.currentTimeMillis() - calculateOffset(slot, activityDef); <line3> quantizedInterval = calculateInterval(activityDef); <line4> } <line5> } <line6> "	 <line3>	No
"public class A { <line0> @Override <line1> public void kill(TopologyLayout topology, String asUser) throws Exception { <line2> String stormTopologyId = getRuntimeTopologyId(topology, asUser); <line3> boolean killed = client.killTopology(stormTopologyId, asUser, DEFAULT_WAIT_TIME_SEC); <line4> if (!killed) { <line5> throw new Exception(""Topology could not be killed "" + ""successfully.""); <line6> } <line7> File artifactsDir = getArtifactsLocation(topology).toFile(); <line8> if (artifactsDir.exists() && artifactsDir.isDirectory()) { <line9> FileUtils.cleanDirectory(artifactsDir); <line10> } <line11> } <line12> } <line13> "	 <line9>	Yes
"public class A { <line0> @Override <line1> public void stop(RuntimeId runtimeId) throws RuntimeOperationException { <line2> DockerRuntime runtime = (DockerRuntime) runtimeRegistry.getRuntimeById(runtimeId.getId()); <line3> try { <line4> docker.getDockerClient(runtime.getProviderId()).stopContainer(runtime.getId(), 1); <line5> refresh(runtimeId); <line6> } catch (DockerException | InterruptedException ex) { <line7> throw new RuntimeOperationException(""Error Stopping container: "" + runtimeId.getId(), ex); <line8> } <line9> } <line10> } <line11> "	 <line1>	No
"public class A { <line0> public void initialise() throws InitialisationException { <line1> if (salt == null) { <line2> salt = <line3> new byte[] { <line4> (byte) 0xc7, <line5> (byte) 0x73, <line6> (byte) 0x21, <line7> (byte) 0x8c, <line8> (byte) 0x7e, <line9> (byte) 0xc8, <line10> (byte) 0xee, <line11> (byte) 0x99 <line12> }; <line13> } <line14> if (password == null) { <line15> throw new InitialisationException(CoreMessages.objectIsNull(""Password""), this); <line16> } <line17> super.initialise(); <line18> } <line19> } <line20> "	 <line19>	No
public class A { <line0> protected void startCommunication() { <line1> NikoHomeControlCommunication comm = nhcComm; <line2> if (comm == null) { <line3> bridgeOffline(); <line4> return; <line5> } <line6> scheduler.submit( <line7> () -> { <line8> comm.startCommunication(); <line9> if (!comm.communicationActive()) { <line10> bridgeOffline(); <line11> return; <line12> } <line13> updateProperties(); <line14> updateStatus(ThingStatus.ONLINE); <line15> int refreshInterval = config.refresh; <line16> setupRefreshTimer(refreshInterval); <line17> NikoHomeControlDiscoveryService discovery = nhcDiscovery; <line18> if (discovery != null) { <line19> discovery.discoverDevices(); <line20> } else { <line21> } <line22> }); <line23> } <line24> } <line25> 	 <line21>	Yes
"public class A { <line0> @Asynchronous <line1> public void processFilePath( <line2> String fileDir, <line3> String parentIdtf, <line4> DataverseRequest dataverseRequest, <line5> Dataverse owner, <line6> ImportUtil.ImportType importType, <line7> Boolean createDV) { <line8> PrintWriter validationLog = null; <line9> PrintWriter cleanupLog = null; <line10> try { <line11> JsonArrayBuilder status = Json.createArrayBuilder(); <line12> Date timestamp = new Date(); <line13> SimpleDateFormat formatter = new SimpleDateFormat(""yyyy-MM-dd_HH:mm:ss""); <line14> validationLog = <line15> new PrintWriter( <line16> new FileWriter(""../logs/validationLog"" + formatter.format(timestamp) + "".txt"")); <line17> cleanupLog = <line18> new PrintWriter( <line19> new FileWriter(""../logs/cleanupLog"" + formatter.format(timestamp) + "".txt"")); <line20> File dir = new File(fileDir); <line21> if (dir.isDirectory()) { <line22> for (File file : dir.listFiles()) { <line23> if (!file.isHidden()) { <line24> if (file.isDirectory()) { <line25> try { <line26> status.add( <line27> handleDirectory( <line28> dataverseRequest, file, importType, validationLog, cleanupLog, createDV)); <line29> } catch (ImportException e) { <line30> logger.log(Level.SEVERE, ""Exception in handleDirectory() for "" + file.getName(), e); <line31> } <line32> } else { <line33> try { <line34> status.add( <line35> importService.handleFile( <line36> dataverseRequest, owner, file, importType, validationLog, cleanupLog)); <line37> } catch (ImportException e) { <line38> logger.log(Level.SEVERE, ""Exception in handleFile() for "" + file.getName(), e); <line39> } <line40> } <line41> } <line42> } <line43> } else { <line44> status.add( <line45> importService.handleFile( <line46> dataverseRequest, owner, dir, importType, validationLog, cleanupLog)); <line47> } <line48> } catch (Exception e) { <line49> logger.log(Level.SEVERE, ""Exception in processFilePath()"", e); <line50> } finally { <line51> validationLog.close(); <line52> cleanupLog.close(); <line53> } <line54> } <line55> } <line56> "	 <line8>	Yes
public class A { <line0> public DataSource lookUp(String dsName) { <line1> validateInitialized(); <line2> validateDSName(dsName); <line3> if (!cachedNameList.contains(dsName)) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> return null; <line7> } <line8> if (log.isDebugEnabled()) { <line9> } <line10> InitialContext context = getCachedInitialContext(dsName); <line11> return DataSourceFinder.find(dsName, context); <line12> } <line13> } <line14> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public void onAudioFocusChange(int focusChange) { <line2> try { <line3> switch (focusChange) { <line4> case AudioManager.AUDIOFOCUS_GAIN: <line5> if (playOnFocusGain) { <line6> requestAudioFocus(); <line7> if (player != null) { <line8> player.start(); <line9> updateController(""audio focus gained""); <line10> } <line11> } <line12> playOnFocusGain = false; <line13> break; <line14> case AudioManager.AUDIOFOCUS_LOSS: <line15> if (player != null) { <line16> if (player.isPlaying()) { <line17> player.pause(); <line18> updateController(""audio focus lost""); <line19> playOnFocusGain = true; <line20> } else { <line21> playOnFocusGain = false; <line22> } <line23> } <line24> break; <line25> } <line26> } catch (Exception ex) { <line27> } <line28> } <line29> } <line30> "	 <line27>	Yes
public class A { <line0> private void close(Closeable s) { <line1> if (s != null) { <line2> try { <line3> s.close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> @Test <line1> public void testGainOffset() throws Exception { <line2> Map<String, Object> props = new HashMap<>(); <line3> try { <line4> WireTestUtil.updateWireComponentConfiguration(configurationService, UNDER_TEST_PID, props) <line5> .get(30, TimeUnit.SECONDS); <line6> } catch (InterruptedException | TimeoutException e) { <line7> throw e; <line8> } <line9> CompletableFuture<WireEnvelope> out0Recfuture = outReceiver.nextEnvelope(); <line10> Map<String, TypedValue<?>> myMap = new HashMap<>(); <line11> myMap.put(""toBeMultipliedByTwo"", TypedValues.newDoubleValue(4)); <line12> myMap.put(""toBeMultipliedBy3AndIncreasedBy1"", TypedValues.newDoubleValue(2)); <line13> inEmitter.emit(new WireRecord(myMap)); <line14> try { <line15> WireRecord receivedRecord = out0Recfuture.get(1, TimeUnit.SECONDS).getRecords().get(0); <line16> assertTrue( <line17> (double) receivedRecord.getProperties().get(""toBeMultipliedByTwo"").getValue() == 8); <line18> assertTrue( <line19> (double) receivedRecord.getProperties().get(""toBeMultipliedBy3AndIncreasedBy1"").getValue() <line20> == 7); <line21> } catch (TimeoutException e) { <line22> fail(""Timeout waiting for envelope""); <line23> } <line24> } <line25> } <line26> "	 <line7>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> Collection<SingleWMSService> workers = getTiles(job); <line3> OMGraphicList result = new OMGraphicList(); <line4> ExecutorService pool = Executors.newFixedThreadPool(Math.max(workers.size(), 4)); <line5> ExecutorCompletionService<OMGraphicList> completionService = <line6> new ExecutorCompletionService<>(pool); <line7> for (SingleWMSService w : workers) { <line8> completionService.submit(w); <line9> } <line10> boolean allSuccess = true; <line11> for (int i = 0; i < workers.size(); i++) { <line12> Future<OMGraphicList> future; <line13> try { <line14> future = completionService.poll(Math.max(100, 5000 / (i + 1)), TimeUnit.MILLISECONDS); <line15> OMGraphicList tile = future.get(); <line16> result.addAll(tile); <line17> tmpCache.putIfAbsent(getID(job), new OMGraphicList()); <line18> tmpCache.get(getID(job)).addAll(tile); <line19> fireWMSEvent(); <line20> } catch (InterruptedException | ExecutionException | NullPointerException e) { <line21> allSuccess = false; <line22> } <line23> } <line24> if (allSuccess) { <line25> tmpCache.remove(getID(job)); <line26> cache.put(getID(job), result); <line27> fireWMSEvent(); <line28> } else { <line29> queue(job); <line30> } <line31> } <line32> } <line33> 	 <line2>	No
public class A { <line0> @Override <line1> public void run() { <line2> for (Future<String> unresolvedPeer : unresolvedPeers) { <line3> try { <line4> String badAddress = unresolvedPeer.get(5, TimeUnit.SECONDS); <line5> if (badAddress != null) { <line6> } <line7> } catch (InterruptedException e) { <line8> Thread.currentThread().interrupt(); <line9> } catch (ExecutionException e) { <line10> } catch (TimeoutException ignore) { <line11> } <line12> } <line13> } <line14> } <line15> 	 <line0>	No
"public class A { <line0> @Override <line1> public void apply( <line2> @SuppressWarnings(""deprecation"") final org.apache.brooklyn.api.entity.EntityLocal entity) { <line3> final AttributeSensor<ReleaseableLatch> sensor = <line4> Sensors.newSensor(ReleaseableLatch.class, sensorName); <line5> ((EntityInternal) entity).getMutableEntityType().addSensor(sensor); <line6> final Task<ReleaseableLatch> resolveValueTask = <line7> DependentConfiguration.maxConcurrency(maxConcurrency); <line8> class SetValue implements Runnable { <line9> @Override <line10> public void run() { <line11> ReleaseableLatch releaseableLatch = resolveValueTask.getUnchecked(); <line12> entity.sensors().set(sensor, releaseableLatch); <line13> } <line14> } <line15> Task<ReleaseableLatch> setValueTask = <line16> Tasks.<ReleaseableLatch>builder() <line17> .displayName(""Setting "" + sensor + "" on "" + entity) <line18> .body(new SetValue()) <line19> .build(); <line20> Entities.submit( <line21> entity, <line22> Tasks.sequential( <line23> ""Resolving and setting "" + sensor + "" on "" + entity, resolveValueTask, setValueTask)); <line24> } <line25> } <line26> "	 <line21>	No
"public class A { <line0> private ImmutableSortedMap<String, ImmutableSet<String>> readMap(final String mapPath) { <line1> String fileContent; <line2> String actualPath = mapPath; <line3> try { <line4> if (Strings.isNullOrEmpty(mapPath)) { <line5> URL resource = this.getClass().getClassLoader().getResource(""defaultWhiteListMap.json""); <line6> actualPath = resource.getFile(); <line7> fileContent = Resources.toString(resource, Charset.defaultCharset()); <line8> } else { <line9> fileContent = Files.asCharSource(new File(mapPath), StandardCharsets.UTF_8).read(); <line10> } <line11> return mapper <line12> .readerFor(new TypeReference<ImmutableSortedMap<String, ImmutableSet<String>>>() {}) <line13> .readValue(fileContent); <line14> } catch (IOException e) { <line15> throw new ISE(e, ""Got an exception while parsing file [%s]"", actualPath); <line16> } <line17> } <line18> } <line19> "	 <line7>	Yes
public class A { <line0> private static int loadIntFromEnvironment(String envKey, int dfl) { <line1> String s = System.getenv(envKey); <line2> if (null != s) { <line3> try { <line4> return Integer.valueOf(s); <line5> } catch (NumberFormatException e) { <line6> } <line7> } else { <line8> } <line9> return dfl; <line10> } <line11> } <line12> 	 <line3>	No
public class A { <line0> private OAuthPluginException createNoAuthException( <line1> OAuthFederatedSource oauthSource, <line2> String sessionId, <line3> OIDCProviderMetadata metadata, <line4> String reason) <line5> throws StopProcessingException { <line6> String state = UUID.randomUUID().toString(); <line7> Map<String, Object> stateMap = new HashMap<>(); <line8> stateMap.put(SOURCE_ID, oauthSource.getId()); <line9> stateMap.put(CLIENT_ID, oauthSource.getOauthClientId()); <line10> stateMap.put(SECRET, oauthSource.getOauthClientSecret()); <line11> stateMap.put(DISCOVERY_URL, oauthSource.getOauthDiscoveryUrl()); <line12> stateMap.put(EXPIRES_AT, Instant.now().plus(STATE_EXP, ChronoUnit.MINUTES).getEpochSecond()); <line13> tokenStorage.getStateMap().put(state, stateMap); <line14> Map<String, String> parameters = new HashMap<>(); <line15> parameters.put(RESPONSE_TYPE, CODE_FLOW); <line16> parameters.put(CLIENT_ID_PARAM, oauthSource.getOauthClientId()); <line17> parameters.put(SCOPE, OPENID_SCOPE); <line18> parameters.put(REDIRECT_URI, OAUTH_REDIRECT_URL); <line19> parameters.put(STATE, state); <line20> String url = metadata.getAuthorizationEndpointURI().toString(); <line21> return new OAuthPluginException( <line22> oauthSource.getId(), buildUrl(url, parameters), url, parameters, NO_AUTH); <line23> } <line24> } <line25> 	 <line6>	Yes
"public class A { <line0> @Override <line1> public void start(Promise<Void> startPromise) throws Exception { <line2> try { <line3> super.start(); <line4> if (endpointObject == null) { <line5> startPromise.complete(); <line6> return; <line7> } <line8> Router mainRouter = Router.router(vertx); <line9> mountAccessLogHandler(mainRouter); <line10> mountCorsHandler(mainRouter); <line11> initDispatcher(mainRouter); <line12> mountGlobalRestFailureHandler(mainRouter); <line13> HttpServer httpServer = createHttpServer(); <line14> httpServer.requestHandler(mainRouter); <line15> httpServer.connectionHandler( <line16> connection -> { <line17> DefaultHttpServerMetrics serverMetrics = <line18> (DefaultHttpServerMetrics) ((ConnectionBase) connection).metrics(); <line19> DefaultServerEndpointMetric endpointMetric = serverMetrics.getEndpointMetric(); <line20> long connectedCount = endpointMetric.getCurrentConnectionCount(); <line21> int connectionLimit = <line22> DynamicPropertyFactory.getInstance() <line23> .getIntProperty(""servicecomb.rest.server.connection-limit"", Integer.MAX_VALUE) <line24> .get(); <line25> if (connectedCount > connectionLimit) { <line26> connection.close(); <line27> endpointMetric.onRejectByConnectionLimit(); <line28> } <line29> }); <line30> List<HttpServerExceptionHandler> httpServerExceptionHandlers = <line31> SPIServiceUtils.getAllService(HttpServerExceptionHandler.class); <line32> httpServer.exceptionHandler( <line33> e -> { <line34> if (e instanceof ClosedChannelException) { <line35> } else { <line36> } <line37> httpServerExceptionHandlers.forEach( <line38> httpServerExceptionHandler -> { <line39> httpServerExceptionHandler.handle(e); <line40> }); <line41> }); <line42> startListen(httpServer, startPromise); <line43> } catch (Throwable e) { <line44> throw e; <line45> } <line46> } <line47> } <line48> "	 <line16>	No
public class A { <line0> public RemoteObservationManager getRemoteObservationManager() { <line1> if (this.remoteObservationManager == null) { <line2> try { <line3> this.remoteObservationManager = <line4> this.componentManager.getInstance(RemoteObservationManager.class); <line5> } catch (ComponentLookupException e) { <line6> } <line7> } <line8> return this.remoteObservationManager; <line9> } <line10> } <line11> 	 <line4>	No
"public class A { <line0> private void initHttpPipeline(ChannelHandlerContext ctx) { <line1> ctx.pipeline() <line2> .addLast(letsEncryptHandler) <line3> .addLast(""HttpChunkedWrite"", new ChunkedWriteHandler()) <line4> .addLast(""HttpUrlMapper"", new UrlReWriterHandler(""/favicon.ico"", ""/static/favicon.ico"")) <line5> .addLast( <line6> ""HttpStaticFile"", <line7> new StaticFileHandler( <line8> holder.props, <line9> new StaticFile(""/static""), <line10> new StaticFileEdsWith(FileUtils.CSV_DIR, "".gz""), <line11> new StaticFileEdsWith(FileUtils.CSV_DIR, "".zip""))) <line12> .addLast(resetPasswordLogic) <line13> .addLast(httpAPILogic) <line14> .addLast(noMatchHandler) <line15> .remove(this); <line16> if (log.isTraceEnabled()) { <line17> } <line18> } <line19> } <line20> "	 <line17>	Yes
public class A { <line0> public static void log(final String message) { <line1> } <line2> } <line3> 	 <line1>	Yes
public class A { <line0> @Override <line1> public boolean lockRunningRepairsForNodes(UUID repairId, UUID segmentId, Set<String> replicas) { <line2> if (null != jdbi) { <line3> try (Handle h = jdbi.open()) { <line4> h.begin(); <line5> for (String replica : replicas) { <line6> try { <line7> getPostgresStorage(h) <line8> .insertNodeLock( <line9> repairId, <line10> replica, <line11> reaperInstanceId, <line12> AppContext.REAPER_INSTANCE_ADDRESS, <line13> segmentId); <line14> } catch (UnableToExecuteStatementException ex) { <line15> if (JdbiExceptionUtil.isDuplicateKeyError(ex)) { <line16> if (!updateLockForNode(repairId, segmentId, h, replica)) { <line17> return false; <line18> } <line19> } else { <line20> h.rollback(); <line21> return false; <line22> } <line23> } <line24> } <line25> h.commit(); <line26> return true; <line27> } <line28> } <line29> return false; <line30> } <line31> } <line32> 	 <line20>	Yes
public class A { <line0> public static Charset sniffEncodingFromHttpHeaders(final List<NameValuePair> headers) { <line1> for (final NameValuePair pair : headers) { <line2> final String name = pair.getName(); <line3> if (HttpHeader.CONTENT_TYPE_LC.equalsIgnoreCase(name)) { <line4> final Charset encoding = extractEncodingFromContentType(pair.getValue()); <line5> if (encoding != null) { <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> return encoding; <line9> } <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	 <line7>	Yes
"public class A { <line0> @POST <line1> @Path(""run/{noteId}/{paragraphId}"") <line2> @ZeppelinApi <line3> public Response runParagraphSynchronously( <line4> @PathParam(""noteId"") String noteId, <line5> @PathParam(""paragraphId"") String paragraphId, <line6> @QueryParam(""sessionId"") String sessionId, <line7> String message) <line8> throws IOException, IllegalArgumentException { <line9> Note note = notebook.getNote(noteId); <line10> checkIfNoteIsNotNull(note, noteId); <line11> Paragraph paragraph = note.getParagraph(paragraphId); <line12> checkIfParagraphIsNotNull(paragraph, paragraphId); <line13> Map<String, Object> params = new HashMap<>(); <line14> if (!StringUtils.isEmpty(message)) { <line15> ParametersRequest request = ParametersRequest.fromJson(message); <line16> params = request.getParams(); <line17> } <line18> if (notebookService.runParagraph( <line19> noteId, <line20> paragraphId, <line21> paragraph.getTitle(), <line22> paragraph.getText(), <line23> params, <line24> new HashMap<>(), <line25> sessionId, <line26> false, <line27> true, <line28> getServiceContext(), <line29> new RestServiceCallback<>())) { <line30> note = notebookService.getNote(noteId, getServiceContext(), new RestServiceCallback<>()); <line31> Paragraph p = note.getParagraph(paragraphId); <line32> InterpreterResult result = p.getReturn(); <line33> return new JsonResponse<>(Status.OK, result).build(); <line34> } else { <line35> return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, ""Fail to run paragraph"").build(); <line36> } <line37> } <line38> } <line39> "	 <line5>	No
"public class A { <line0> private void updateMailAttributes(Mail mc, Connection conn) throws IOException { <line1> String updateMessageAttrSql = sqlQueries.getSqlString(""updateMessageAttributesSQL"", false); <line2> try (PreparedStatement updateMessageAttr = conn.prepareStatement(updateMessageAttrSql); <line3> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line4> ObjectOutputStream oos = new ObjectOutputStream(baos)) { <line5> if (mc instanceof MailImpl) { <line6> oos.writeObject(((MailImpl) mc).getAttributesRaw()); <line7> } else { <line8> Map<String, Serializable> temp = <line9> mc.attributes() <line10> .collect( <line11> Guavate.toImmutableMap( <line12> attribute -> attribute.getName().asString(), <line13> attribute -> (Serializable) attribute.getValue().value())); <line14> oos.writeObject(temp); <line15> } <line16> oos.flush(); <line17> ByteArrayInputStream attrInputStream = new ByteArrayInputStream(baos.toByteArray()); <line18> updateMessageAttr.setBinaryStream(1, attrInputStream, baos.size()); <line19> updateMessageAttr.setString(2, mc.getName()); <line20> updateMessageAttr.setString(3, repositoryName); <line21> updateMessageAttr.execute(); <line22> } catch (SQLException sqle) { <line23> } <line24> } <line25> } <line26> "	 <line23>	Yes
"public class A { <line0> @Test( <line1> groups = {""Phase 2 Route""}, <line2> description = ""color contrast"", <line3> priority = 327) <line4> public void verifyTest_2_9() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""route_9"", GTFS_2_GTFS_Route_3, SEVERITY.WARNING, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 5, ""detail count""); <line10> int count = 0; <line11> for (CheckPointErrorReport detail : getDetails(context, result)) { <line12> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line13> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line14> Assert.assertEquals( <line15> detail.getSource().getFile().getFilename(), ""routes.txt"", ""detail must refer bad file""); <line16> if (count == 0) { <line17> count++; <line18> Assert.assertEquals( <line19> detail.getSource().getFile().getLineNumber(), <line20> Integer.valueOf(2), <line21> ""detail must refer bad line""); <line22> } else if (count == 1) { <line23> count++; <line24> Assert.assertEquals( <line25> detail.getSource().getFile().getLineNumber(), <line26> Integer.valueOf(3), <line27> ""detail must refer bad line""); <line28> } else if (count == 2) { <line29> count++; <line30> Assert.assertEquals( <line31> detail.getSource().getFile().getLineNumber(), <line32> Integer.valueOf(6), <line33> ""detail must refer bad line""); <line34> } else if (count == 3) { <line35> count++; <line36> Assert.assertEquals( <line37> detail.getSource().getFile().getLineNumber(), <line38> Integer.valueOf(7), <line39> ""detail must refer bad line""); <line40> } else if (count == 4) { <line41> count++; <line42> Assert.assertEquals( <line43> detail.getSource().getFile().getLineNumber(), <line44> Integer.valueOf(8), <line45> ""detail must refer bad line""); <line46> } <line47> } <line48> } <line49> } <line50> "	 <line5>	Yes
"public class A { <line0> private RestResponse<FacetField> stats() throws ClientException { <line1> SampleCommandOptions.StatsCommandOptions commandOptions = <line2> samplesCommandOptions.statsCommandOptions; <line3> ObjectMap params = new ObjectMap(); <line4> params.putIfNotEmpty(SampleDBAdaptor.QueryParams.STUDY.key(), commandOptions.study); <line5> params.putIfNotEmpty(""creationYear"", commandOptions.creationYear); <line6> params.putIfNotEmpty(""creationMonth"", commandOptions.creationMonth); <line7> params.putIfNotEmpty(""creationDay"", commandOptions.creationDay); <line8> params.putIfNotEmpty(""creationDayOfWeek"", commandOptions.creationDayOfWeek); <line9> params.putIfNotEmpty(""status"", commandOptions.status); <line10> params.putIfNotEmpty(""source"", commandOptions.source); <line11> params.putIfNotEmpty(""type"", commandOptions.type); <line12> params.putIfNotEmpty(""phenotypes"", commandOptions.phenotypes); <line13> params.putIfNotEmpty(""release"", commandOptions.release); <line14> params.putIfNotEmpty(""version"", commandOptions.version); <line15> params.putIfNotNull(""somatic"", commandOptions.somatic); <line16> params.putIfNotEmpty(Constants.ANNOTATION, commandOptions.annotation); <line17> params.put(""default"", commandOptions.defaultStats); <line18> params.putIfNotNull(""field"", commandOptions.field); <line19> return openCGAClient.getSampleClient().aggregationStats(params); <line20> } <line21> } <line22> "	 <line5>	No
public class A { <line0> private void generateInventoryPythonClass(StringBuilder sb, List<String> basePkgs) { <line1> List<String> inventoryPython = new ArrayList<>(); <line2> ClassPathScanningCandidateComponentProvider scanner = <line3> new ClassPathScanningCandidateComponentProvider(false); <line4> scanner.addIncludeFilter(new AnnotationTypeFilter(PythonClassInventory.class)); <line5> scanner.addExcludeFilter(new AnnotationTypeFilter(Component.class)); <line6> for (String pkg : basePkgs) { <line7> for (BeanDefinition bd : <line8> scanner.findCandidateComponents(pkg).stream() <line9> .sorted( <line10> (bd1, bd2) -> { <line11> return bd1.getBeanClassName().compareTo(bd2.getBeanClassName()); <line12> }) <line13> .collect(Collectors.toList())) { <line14> try { <line15> Class<?> clazz = Class.forName(bd.getBeanClassName()); <line16> if (isPythonClassGenerated(clazz)) { <line17> continue; <line18> } <line19> inventoryPython.add(classToInventoryPythonClass(clazz)); <line20> } catch (Exception e) { <line21> } <line22> } <line23> } <line24> for (String invstr : inventoryPython) { <line25> sb.append(invstr); <line26> } <line27> } <line28> } <line29> 	 <line5>	No
"public class A { <line0> private JwtClaims validateAndDecodeMessage( <line1> final String encryptedMessage, final PublicKey senderPublicKey) { <line2> final JwtConsumer jwtConsumer = <line3> new JwtConsumerBuilder() <line4> .setRequireJwtId() <line5> .setEnableRequireEncryption() <line6> .setEnableRequireIntegrity() <line7> .setDecryptionKey(privateKey) <line8> .setVerificationKey(senderPublicKey) <line9> .setJwsAlgorithmConstraints(JWS_ALG_CONSTRAINTS) <line10> .setJweAlgorithmConstraints(JWE_ALG_CONSTRAINTS) <line11> .setJweContentEncryptionAlgorithmConstraints(JWE_ENCRYPTION_CONSTRAINTS) <line12> .build(); <line13> try { <line14> return jwtConsumer.processToClaims(encryptedMessage); <line15> } catch (final InvalidJwtException ex) { <line16> throw new AuthException(""Message processing is failed"", ex); <line17> } <line18> } <line19> } <line20> "	 <line11>	No
public class A { <line0> @Override <line1> public void startStream() { <line2> executor.submit(task); <line3> running.set(true); <line4> } <line5> } <line6> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void process(Exchange exchange) throws Exception { <line2> if (connection == null) { <line3> connection = this.zkm.getConnection(); <line4> } <line5> ProductionContext context = new ProductionContext(connection, exchange); <line6> String operation = <line7> exchange.getIn().getHeader(ZooKeeperMessage.ZOOKEEPER_OPERATION, String.class); <line8> boolean isDelete = ZK_OPERATION_DELETE.equals(operation); <line9> if (ExchangeHelper.isOutCapable(exchange)) { <line10> if (isDelete) { <line11> if (LOG.isDebugEnabled()) { <line12> } <line13> OperationResult result = synchronouslyDelete(context); <line14> if (configuration.isListChildren()) { <line15> result = listChildren(context); <line16> } <line17> updateExchangeWithResult(context, result); <line18> } else { <line19> if (LOG.isDebugEnabled()) { <line20> } <line21> OperationResult result = synchronouslySetData(context); <line22> if (configuration.isListChildren()) { <line23> result = listChildren(context); <line24> } <line25> updateExchangeWithResult(context, result); <line26> } <line27> } else { <line28> if (isDelete) { <line29> asynchronouslyDeleteNode(connection, context); <line30> } else { <line31> asynchronouslySetDataOnNode(connection, context); <line32> } <line33> } <line34> } <line35> } <line36> 	 <line12>	Yes
public class A { <line0> @Override <line1> public Integer call() throws Exception { <line2> if (!forceRetrieve) { <line3> BlobCollectionType.get(blobStore).retrieve(blobStore, fs, getBatchCount()); <line4> } <line5> if (fs.getAvailableRefs().length() <= 0) { <line6> BlobCollectionType.DEFAULT.retrieve(blobStore, fs, getBatchCount()); <line7> BlobCollectionType.get(blobStore).track(blobStore, fs); <line8> } <line9> return 0; <line10> } <line11> } <line12> 	 <line7>	Yes
public class A { <line0> @Override <line1> protected RowMap evict() throws IOException { <line2> RowMap r = super.evict(); <line3> this.memorySize -= r.getApproximateSize(); <line4> this.outputStreamCacheSize += r.getApproximateSize(); <line5> if (this.outputStreamCacheSize > FlushOutputStreamBytes) { <line6> resetOutputStreamCaches(); <line7> this.outputStreamCacheSize = 0; <line8> } <line9> return r; <line10> } <line11> } <line12> 	 <line8>	No
public class A { <line0> @BeforeClass <line1> public static void setUpForJUnit() { <line2> MrGeoProperties.resetProperties(); <line3> try { <line4> DataProviderFactory.invalidateCache(); <line5> input = TestUtils.composeInputDir(WmsGeneratorTestAbstract.class); <line6> inputHdfs = TestUtils.composeInputHdfs(WmsGeneratorTestAbstract.class, true); <line7> copyInputData(); <line8> MrGeoProperties.getInstance() <line9> .setProperty(MrGeoConstants.MRGEO_HDFS_IMAGE, inputHdfs.toString()); <line10> MrGeoProperties.getInstance() <line11> .setProperty(MrGeoConstants.MRGEO_HDFS_COLORSCALE, inputHdfs.toString()); <line12> if (GEN_BASELINE_DATA_ONLY) { <line13> } <line14> } catch (final Exception e) { <line15> e.printStackTrace(); <line16> } <line17> } <line18> } <line19> 	 <line13>	Yes
"public class A { <line0> protected <K, V> boolean addNoWait(final LateralCacheNoWait<K, V> noWait) { <line1> @SuppressWarnings(""unchecked"") <line2> final LateralCacheNoWaitFacade<K, V> facade = <line3> (LateralCacheNoWaitFacade<K, V>) facades.get(noWait.getCacheName()); <line4> return addNoWait(noWait, facade); <line5> } <line6> } <line7> "	 <line2>	No
"public class A { <line0> private void configureNetworkListener() throws Exception { <line1> boolean allowPortChange = true; <line2> NetworkListener listener = this.httpServer.getListener(""grizzly""); <line3> if (listener == null) { <line4> listener = new NetworkListener(""grizzly"", rexsterServerHost, rexsterServerPort); <line5> this.httpServer.addListener(listener); <line6> allowPortChange = false; <line7> } <line8> if (allowPortChange && hasPortHostChanged()) { <line9> listener.getTransport().unbindAll(); <line10> listener.getTransport().bind(rexsterServerHost, rexsterServerPort); <line11> } <line12> if (hasThreadPoolSizeChanged()) { <line13> final ThreadPoolConfig workerThreadPoolConfig = <line14> ThreadPoolConfig.defaultConfig() <line15> .setCorePoolSize(coreWorkerThreadPoolSize) <line16> .setMaxPoolSize(maxWorkerThreadPoolSize); <line17> listener.getTransport().setWorkerThreadPoolConfig(workerThreadPoolConfig); <line18> final ThreadPoolConfig kernalThreadPoolConfig = <line19> ThreadPoolConfig.defaultConfig() <line20> .setCorePoolSize(coreKernalThreadPoolSize) <line21> .setMaxPoolSize(maxKernalThreadPoolSize); <line22> listener.getTransport().setKernelThreadPoolConfig(kernalThreadPoolConfig); <line23> if (listener.getTransport().getKernelThreadPool() != null) { <line24> ((GrizzlyExecutorService) listener.getTransport().getKernelThreadPool()) <line25> .reconfigure(kernalThreadPoolConfig); <line26> } <line27> if (listener.getTransport().getWorkerThreadPool() != null) { <line28> ((GrizzlyExecutorService) listener.getTransport().getWorkerThreadPool()) <line29> .reconfigure(workerThreadPoolConfig); <line30> } <line31> } <line32> listener.setMaxPostSize(maxPostSize); <line33> listener.setMaxHttpHeaderSize(maxHeaderSize); <line34> listener.setUploadTimeout(uploadTimeoutMillis); <line35> listener.setDisableUploadTimeout(false); <line36> if (this.hasIoStrategyChanged()) { <line37> final IOStrategy strategy = GrizzlyIoStrategyFactory.createIoStrategy(this.ioStrategy); <line38> listener.getTransport().setIOStrategy(strategy); <line39> } <line40> } <line41> } <line42> "	 <line11>	Yes
public class A { <line0> @Override <line1> public boolean execute(Context context) throws Exception { <line2> boolean result = ERROR; <line3> Monitor monitor = MonitorFactory.start(COMMAND); <line4> try { <line5> Referential referential = (Referential) context.get(REFERENTIAL); <line6> GtfsImportParameters configuration = (GtfsImportParameters) context.get(CONFIGURATION); <line7> if (referential != null) { <line8> referential.clear(true); <line9> } <line10> GtfsImporter importer = (GtfsImporter) context.get(PARSER); <line11> if (referential.getSharedStopAreas().isEmpty()) { <line12> GtfsStopParser gtfsStopParser = <line13> (GtfsStopParser) ParserFactory.create(GtfsStopParser.class.getName()); <line14> gtfsStopParser.parse(context); <line15> } <line16> if (importer.hasTransferImporter()) { <line17> if (referential.getSharedConnectionLinks().isEmpty()) { <line18> GtfsTransferParser gtfsTransferParser = <line19> (GtfsTransferParser) ParserFactory.create(GtfsTransferParser.class.getName()); <line20> gtfsTransferParser.parse(context); <line21> } <line22> } <line23> if (configuration.getMaxDistanceForCommercial() > 0) { <line24> CommercialStopGenerator commercialStopGenerator = new CommercialStopGenerator(); <line25> commercialStopGenerator.createCommercialStopPoints(context); <line26> } <line27> if (configuration.getMaxDistanceForConnectionLink() > 0) { <line28> ConnectionLinkGenerator connectionLinkGenerator = new ConnectionLinkGenerator(); <line29> connectionLinkGenerator.createConnectionLinks(context); <line30> } <line31> addStats(context, referential); <line32> result = SUCCESS; <line33> } catch (Exception e) { <line34> throw e; <line35> } finally { <line36> } <line37> return result; <line38> } <line39> } <line40> 	 <line28>	No
"public class A { <line0> @Override <line1> public boolean tableExists(String tableId) throws IOException { <line2> try (BigtableSession session = new BigtableSession(options)) { <line3> GetTableRequest getTable = <line4> GetTableRequest.newBuilder() <line5> .setName(options.getInstanceName().toTableNameStr(tableId)) <line6> .build(); <line7> session.getTableAdminClient().getTable(getTable); <line8> return true; <line9> } catch (StatusRuntimeException e) { <line10> if (e.getStatus().getCode() == Code.NOT_FOUND) { <line11> return false; <line12> } <line13> String message = <line14> String.format( <line15> ""Error checking whether table %s (BigtableOptions %s) exists"", tableId, options); <line16> throw new IOException(message, e); <line17> } <line18> } <line19> } <line20> "	 <line16>	Yes
public class A { <line0> @FinishBundle <line1> public void finishBundle(FinishBundleContext c) { <line2> if (bundleTaskContextMap == null) { <line3> return; <line4> } <line5> for (Map.Entry<KV<BoundedWindow, Integer>, TaskContext<KeyT, ValueT>> entry : <line6> bundleTaskContextMap.entrySet()) { <line7> TaskContext<KeyT, ValueT> taskContext = entry.getValue(); <line8> try { <line9> taskContext.getRecordWriter().close(taskContext.getTaskAttemptContext()); <line10> taskContext.getOutputCommitter().commitTask(taskContext.getTaskAttemptContext()); <line11> } catch (Exception e) { <line12> processTaskException(taskContext, e); <line13> } <line14> BoundedWindow window = entry.getKey().getKey(); <line15> c.output(taskContext.getTaskId(), Objects.requireNonNull(window).maxTimestamp(), window); <line16> } <line17> } <line18> } <line19> 	 <line11>	Yes
public class A { <line0> @Override <line1> public void adjustTLSExtensionContext(RenegotiationInfoExtensionMessage message) { <line2> if (message.getExtensionLength().getValue() > 65535) { <line3> } <line4> if (context.getTalkingConnectionEndType() != context.getChooser().getConnectionEndType()) { <line5> context.setRenegotiationInfo(message.getRenegotiationInfo().getValue()); <line6> } <line7> if (context.getTalkingConnectionEndType() == ConnectionEndType.SERVER) { <line8> if (message.getRenegotiationInfo().getValue().length == 1 <line9> && message.getRenegotiationInfo().getValue()[0] == 0) { <line10> context.setSecureRenegotiation(true); <line11> } <line12> } <line13> } <line14> } <line15> 	 <line6>	Yes
"public class A { <line0> @Override <line1> public void deleteUserConfig(String username) throws ApsSystemException { <line2> try { <line3> this.getUserShortcutDAO().deleteUserConfig(username); <line4> } catch (Throwable t) { <line5> throw new ApsSystemException(""Error deleting user config by user "" + username, t); <line6> } <line7> } <line8> } <line9> "	 <line7>	No
"public class A { <line0> @Override <line1> public void handleMessage(CPMSession session, CPMConsumer consumer, CPMMessage message) { <line2> try { <line3> if (log.isDebugEnabled()) { <line4> } <line5> message.acknowledge(); <line6> JobMessage jobMessage = this.mapper.readValue(message.getBody(), JobMessage.class); <line7> this.unitOfWork.begin(); <line8> AsyncJobStatus jobStatus = this.manager.executeJob(jobMessage); <line9> this.commit(session); <line10> } catch (JobExecutionException e) { <line11> this.commit(session); <line12> } catch (JobStateManagementException e) { <line13> JobState intendedState = e.getIntendedState(); <line14> if (intendedState != null && !intendedState.isTerminal()) { <line15> log.error( <line16> ""Job processing failed; rolling back job message to retry later: {}"", <line17> this.serializeMessage(message)); <line18> this.rollback(session); <line19> } else { <line20> this.commit(session); <line21> } <line22> } catch (JobMessageDispatchException e) { <line23> this.rollback(session); <line24> } catch (JobException e) { <line25> if (e.isTerminal()) { <line26> this.commit(session); <line27> } else { <line28> this.rollback(session); <line29> } <line30> } catch (Exception e) { <line31> String messageId = (message != null ? message.getMessageId() : """"); <line32> String reason = (e.getCause() == null ? e.getMessage() : e.getCause().getMessage()); <line33> this.rollback(session); <line34> } finally { <line35> this.unitOfWork.end(); <line36> } <line37> } <line38> } <line39> "	 <line7>	Yes
"public class A { <line0> private void handleStatus(final TaskStatus status) { <line1> try { <line2> if (!active) { <line3> return; <line4> } <line5> notifyStatus(task, status, ""notified status change from task""); <line6> if (status.isComplete()) { <line7> IndexTaskUtils.setTaskStatusDimensions(metricBuilder, status); <line8> emitter.emit(metricBuilder.build(""task/run/time"", status.getDuration())); <line9> if (status.isSuccess()) { <line10> Counters.incrementAndGetLong(totalSuccessfulTaskCount, task.getDataSource()); <line11> } else { <line12> Counters.incrementAndGetLong(totalFailedTaskCount, task.getDataSource()); <line13> } <line14> } <line15> } catch (Exception e) { <line16> log.makeAlert(e, ""Failed to handle task status"") <line17> .addData(""task"", task.getId()) <line18> .addData(""statusCode"", status.getStatusCode()) <line19> .emit(); <line20> } <line21> } <line22> } <line23> "	 <line9>	Yes
public class A { <line0> public static com.liferay.portal.kernel.model.UserSoap updateScreenName( <line1> long userId, String screenName) throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.User returnValue = <line4> UserServiceUtil.updateScreenName(userId, screenName); <line5> return com.liferay.portal.kernel.model.UserSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line1>	No
public class A { <line0> private void logServerInfo() { <line1> } <line2> } <line3> 	 <line2>	No
public class A { <line0> private void setOptions(Map options) throws NoSuchFieldException, IllegalAccessException { <line1> this.options = options; <line2> for (Iterator iterator = options.keySet().iterator(); iterator.hasNext(); ) { <line3> String attribute = (String) iterator.next(); <line4> Object value = options.get(attribute); <line5> try { <line6> Field field = getClass().getField(attribute); <line7> field.set(this, value); <line8> } catch (Throwable e) { <line9> } <line10> } <line11> } <line12> } <line13> 	 <line1>	No
public class A { <line0> private void releasePermit(int count) { <line1> semaphore.release(count); <line2> } <line3> } <line4> 	 <line3>	No
public class A { <line0> private void halt(String reason) { <line1> GoAwayFrame goAwayFrame = null; <line2> GoAwayFrame goAwayFrameEvent; <line3> try (AutoLock l = lock.lock()) { <line4> switch (closed) { <line5> case NOT_CLOSED: <line6> case REMOTELY_CLOSED: <line7> case LOCALLY_CLOSED: <line8> case CLOSING: <line9> { <line10> if (goAwaySent == null || goAwaySent.isGraceful()) <line11> goAwaySent = goAwayFrame = newGoAwayFrame(ErrorCode.NO_ERROR.code, reason); <line12> goAwayFrameEvent = goAwayRecv != null ? goAwayRecv : goAwaySent; <line13> closed = CloseState.CLOSED; <line14> zeroStreamsAction = null; <line15> if (failure != null) failure = toFailure(ErrorCode.NO_ERROR.code, reason); <line16> break; <line17> } <line18> default: <line19> { <line20> return; <line21> } <line22> } <line23> } <line24> failStreams(stream -> true, reason, true); <line25> if (goAwayFrame != null) sendGoAwayAndTerminate(goAwayFrame, goAwayFrameEvent); <line26> else terminate(goAwayFrameEvent); <line27> } <line28> } <line29> 	 <line1>	Yes
"public class A { <line0> @Override <line1> public byte[] call(final byte[] memento) throws Exception { <line2> final Vector model = new DenseVector(dimensions); <line3> final long time1 = System.currentTimeMillis(); <line4> final int numIters = 10; <line5> for (int i = 0; i < numIters; i++) { <line6> controlMessageBroadcaster.send(ControlMessages.ReceiveModel); <line7> modelBroadcaster.send(model); <line8> modelReceiveAckReducer.reduce(); <line9> final GroupChanges changes = communicationGroupClient.getTopologyChanges(); <line10> if (changes.exist()) { <line11> communicationGroupClient.updateTopology(); <line12> } else { <line13> } <line14> } <line15> final long time2 = System.currentTimeMillis(); <line16> LOG.log( <line17> Level.FINE, <line18> ""Broadcasting vector of dimensions {0} took {1} secs"", <line19> new Object[] {dimensions, (time2 - time1) / (numIters * 1000.0)}); <line20> controlMessageBroadcaster.send(ControlMessages.Stop); <line21> return null; <line22> } <line23> } <line24> "	 <line7>	No
"public class A { <line0> @Test <line1> public void testMultipleGatewaysProcess() throws Exception { <line2> kruntime = createKogitoProcessRuntime(""BPMN2-MultipleGatewaysProcess.bpmn2""); <line3> kruntime <line4> .getProcessEventManager() <line5> .addEventListener( <line6> new DefaultKogitoProcessEventListener() { <line7> KogitoProcessInstance pi; <line8>  <line9> @Override <line10> public void afterNodeTriggered(ProcessNodeTriggeredEvent event) { <line11> if (event.getNodeInstance().getNodeName().equals(""CreateAgent"")) { <line12> pi.signalEvent(""Signal_1"", null); <line13> } <line14> } <line15>  <line16> @Override <line17> public void beforeNodeTriggered(ProcessNodeTriggeredEvent event) { <line18> } <line19>  <line20> @Override <line21> public void beforeProcessStarted(ProcessStartedEvent event) { <line22> pi = (KogitoProcessInstance) event.getProcessInstance(); <line23> } <line24> }); <line25> Map<String, Object> params = new HashMap<>(); <line26> params.put(""action"", ""CreateAgent""); <line27> KogitoProcessInstance processInstance = kruntime.startProcess(""multiplegateways"", params); <line28> assertProcessInstanceCompleted(processInstance); <line29> } <line30> } <line31> "	 <line9>	No
public class A { <line0> @Override <line1> public Boolean get(SpeciesCheck key) { <line2> try { <line3> return sdsService.isSensitive(key); <line4> } catch (Exception ex) { <line5> throw new RuntimeException(ex); <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> protected synchronized void updateNumberOfReplicas() { <line1> if (!_replicasClusterContext.isEmbeddedOperationMode()) { <line2> return; <line3> } <line4> try { <line5> ReplicasManager replicasManager = _replicasClusterContext.getReplicasManager(); <line6> replicasManager.updateNumberOfReplicas( <line7> getNumberOfReplicas(), _replicasClusterContext.getTargetIndexNames()); <line8> } catch (Exception exception) { <line9> if (_log.isWarnEnabled()) { <line10> } <line11> } <line12> } <line13> } <line14> 	 <line10>	Yes
"public class A { <line0> @Override <line1> public GenPolynomial<GenPolynomial<C>> recursiveUnivariateGcd( <line2> GenPolynomial<GenPolynomial<C>> P, GenPolynomial<GenPolynomial<C>> S) { <line3> if (S == null || S.isZERO()) { <line4> return P; <line5> } <line6> if (P == null || P.isZERO()) { <line7> return S; <line8> } <line9> if (P.ring.nvar > 1) { <line10> throw new IllegalArgumentException(this.getClass().getName() + "" no univariate polynomial""); <line11> } <line12> long e = P.degree(0); <line13> long f = S.degree(0); <line14> GenPolynomial<GenPolynomial<C>> q; <line15> GenPolynomial<GenPolynomial<C>> r; <line16> if (f > e) { <line17> r = P; <line18> q = S; <line19> long g = f; <line20> f = e; <line21> e = g; <line22> } else { <line23> q = P; <line24> r = S; <line25> } <line26> if (debug) { <line27> } <line28> r = r.abs(); <line29> q = q.abs(); <line30> GenPolynomial<C> a = recursiveContent(r); <line31> GenPolynomial<C> b = recursiveContent(q); <line32> GenPolynomial<C> c = gcd(a, b); <line33> r = PolyUtil.<C>recursiveDivide(r, a); <line34> q = PolyUtil.<C>recursiveDivide(q, b); <line35> if (r.isONE()) { <line36> return r.multiply(c); <line37> } <line38> if (q.isONE()) { <line39> return q.multiply(c); <line40> } <line41> GenPolynomial<GenPolynomial<C>> x; <line42> while (!r.isZERO()) { <line43> x = PolyUtil.<C>recursiveSparsePseudoRemainder(q, r); <line44> if (logger.isDebugEnabled()) { <line45> } <line46> q = r; <line47> r = recursivePrimitivePart(x); <line48> } <line49> return q.abs().multiply(c); <line50> } <line51> } <line52> "	 <line27>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> final Lock lock = H2DbServiceImpl.this.rwLock.writeLock(); <line3> lock.lock(); <line4> try { <line5> shutdownDefrag(); <line6> disposeConnectionPool(); <line7> final String password = decryptPassword(this.configuration.getEncryptedPassword()); <line8> openConnectionPool(this.configuration, password); <line9> } catch (final Exception e) { <line10> } finally { <line11> lock.unlock(); <line12> } <line13> } <line14> } <line15> 	 <line13>	No
public class A { <line0> private List<File> collectMappings(File descriptorsDirectory) { <line1> final List<File> mappingDescriptors = new ArrayList<>(); <line2> try { <line3> Files.walkFileTree( <line4> Paths.get(descriptorsDirectory.toURI()), <line5> new SimpleFileVisitor<Path>() { <line6> @Override <line7> public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) <line8> throws IOException { <line9> File file = path.toFile(); <line10> if (httpServerStubAccepts(file) && isStubPerConsumerPathMatching(file)) { <line11> mappingDescriptors.add(file); <line12> } <line13> return super.visitFile(path, attrs); <line14> } <line15> }); <line16> } catch (IOException e) { <line17> } <line18> return mappingDescriptors; <line19> } <line20> } <line21> 	 <line18>	No
public class A { <line0> @Override <line1> @Nullable <line2> public InputStream getInputStream() { <line3> try { <line4> return new FilterInputStream(resourceStream.getInputStream()) { <line5> @Override <line6> public void close() throws IOException { <line7> resourceStream.close(); <line8> } <line9> }; <line10> } catch (ResourceStreamNotFoundException e) { <line11> return null; <line12> } <line13> } <line14> } <line15> 	 <line11>	Yes
public class A { <line0> private void attachXFFRuleToVirtualServerForced( <line1> ZxtmServiceStubs serviceStubs, String virtualServerName) throws RemoteException { <line2> serviceStubs <line3> .getVirtualServerBinding() <line4> .addRules( <line5> new String[] {virtualServerName}, <line6> new VirtualServerRule[][] {{ZxtmAdapterImpl.ruleXForwardedFor}}); <line7> } <line8> } <line9> 	 <line7>	Yes
public class A { <line0> @Override <line1> public Either<Throwable, T> get() { <line2> if (needsReload()) { <line3> synchronized (this) { <line4> if (needsReload()) { <line5> try { <line6> var v = getOperation().apply(value.get()); <line7> processRetrievedValue(v, value::set); <line8> return Either.right(v); <line9> } catch (Exception ex) { <line10> return Either.left(ex); <line11> } <line12> } <line13> } <line14> } <line15> return Either.right(value.get()); <line16> } <line17> } <line18> 	 <line5>	Yes
public class A { <line0> public void accessFailed(String key) { <line1> synchronized (attemptsCache) { <line2> if (key == null) { <line3> return; <line4> } <line5> int attempts = attemptsCache.getUnchecked(key); <line6> attempts++; <line7> attemptsCache.put(key, attempts); <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
"public class A { <line0> @Override <line1> public Optional<ScriptParameter> get(ScriptParameterKey scriptParameterKey) { <line2> try { <line3> String queryScriptParameter = <line4> ""select SCRIPT_ID, SCRIPT_VRS_NB, SCRIPT_PAR_NM, SCRIPT_PAR_VAL from "" <line5> + getMetadataRepository().getTableNameByLabel(""ScriptParameters"") <line6> + "" where SCRIPT_ID = "" <line7> + SQLTools.getStringForSQL(scriptParameterKey.getScriptKey().getScriptId()) <line8> + "" and SCRIPT_VRS_NB = "" <line9> + SQLTools.getStringForSQL(scriptParameterKey.getScriptKey().getScriptVersion()) <line10> + "" and SCRIPT_PAR_NM = "" <line11> + SQLTools.getStringForSQL(scriptParameterKey.getParameterName()) <line12> + "";""; <line13> CachedRowSet cachedRowSet = <line14> getMetadataRepository().executeQuery(queryScriptParameter, ""reader""); <line15> if (cachedRowSet.size() == 0) { <line16> return Optional.empty(); <line17> } else if (cachedRowSet.size() > 1) { <line18> } <line19> cachedRowSet.next(); <line20> return Optional.of( <line21> new ScriptParameter(scriptParameterKey, cachedRowSet.getString(""SCRIPT_PAR_VAL""))); <line22> } catch (SQLException e) { <line23> throw new RuntimeException(e); <line24> } <line25> } <line26> } <line27> "	 <line18>	Yes
public class A { <line0> private @NotNull MvccCoordinator pickMvccCoordinator( <line1> Collection<ClusterNode> nodes, AffinityTopologyVersion topVer) { <line2> ClusterNode crdNode = null; <line3> if (crdC != null) { <line4> crdNode = crdC.apply(nodes); <line5> if (crdNode != null && log.isInfoEnabled()) <line6> } else { <line7> for (ClusterNode node : nodes) { <line8> if (!node.isClient() && supportsMvcc(node)) { <line9> crdNode = node; <line10> break; <line11> } <line12> } <line13> } <line14> MvccCoordinator crd = <line15> crdNode != null <line16> ? new MvccCoordinator( <line17> topVer, crdNode.id(), coordinatorVersion(crdNode), crdNode.isLocal()) <line18> : MvccCoordinator.DISCONNECTED_COORDINATOR; <line19> if (crd.disconnected()) <line20> return crd; <line21> } <line22> } <line23> 	 <line20>	Yes
public class A { <line0> private void deleteWithRetriesSilent(final String s3Bucket, final String s3Path) { <line1> try { <line2> deleteWithRetries(s3Bucket, s3Path); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	 <line0>	No
public class A { <line0> @Override <line1> public void onMessage(final Message message) { <line2> try { <line3> if (message.propertyExists(Constants.SCHEDULE_TIME)) { <line4> final ScheduledTask scheduledTask = this.createScheduledTask(message); <line5> this.scheduledTaskRepository.save(scheduledTask); <line6> } else { <line7> final ProtocolRequestMessage protocolRequestMessage = <line8> this.createProtocolRequestMessage(message); <line9> this.deviceRequestMessageService.processMessage(protocolRequestMessage); <line10> } <line11> } catch (final JMSException | FunctionalException e) { <line12> } <line13> } <line14> } <line15> 	 <line3>	Yes
"public class A { <line0> private static String downloadTensorFlow(Platform platform) throws IOException { <line1> String version = platform.getVersion(); <line2> String os = platform.getOsPrefix(); <line3> String classifier = platform.getClassifier(); <line4> String cudaArch = platform.getCudaArch(); <line5> String flavor = platform.getFlavor(); <line6> if (flavor.isEmpty()) { <line7> flavor = ""cpu""; <line8> } <line9> String libName = System.mapLibraryName(LIB_NAME); <line10> Path cacheDir = Utils.getEngineCacheDir(""tensorflow""); <line11> Path dir = cacheDir.resolve(version + '-' + flavor + '-' + classifier); <line12> Path path = dir.resolve(libName); <line13> if (Files.exists(path)) { <line14> return path.toAbsolutePath().toString(); <line15> } <line16> Files.createDirectories(cacheDir); <line17> Path tmp = Files.createTempDirectory(cacheDir, ""tmp""); <line18> Matcher matcher = VERSION_PATTERN.matcher(version); <line19> if (!matcher.matches()) { <line20> throw new IllegalArgumentException(""Unexpected version: "" + version); <line21> } <line22> String link = ""https://publish.djl.ai/tensorflow-"" + matcher.group(1); <line23> try (InputStream is = new URL(link + ""/files.txt"").openStream()) { <line24> List<String> lines = Utils.readLines(is); <line25> boolean found = downloadFiles(lines, link, os, flavor, tmp); <line26> if (!found && cudaArch != null) { <line27> flavor = ""cpu""; <line28> dir = cacheDir.resolve(version + '-' + flavor + '-' + classifier); <line29> path = dir.resolve(libName); <line30> if (Files.exists(path)) { <line31> return path.toAbsolutePath().toString(); <line32> } <line33> found = downloadFiles(lines, link, os, flavor, tmp); <line34> } <line35> if (!found) { <line36> throw new UnsupportedOperationException( <line37> ""TensorFlow engine does not support this platform: "" + os); <line38> } <line39> Utils.moveQuietly(tmp, dir); <line40> return path.toAbsolutePath().toString(); <line41> } finally { <line42> if (tmp != null) { <line43> Utils.deleteQuietly(tmp); <line44> } <line45> } <line46> } <line47> } <line48> "	 <line31>	Yes
public class A { <line0> public void delete(SecProvider persistentInstance) { <line1> try { <line2> this.getHibernateTemplate().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> @Private <line1> public static Path createTezSystemStagingPath(Configuration conf, String strAppId) { <line2> Path baseStagingPath = getTezBaseStagingPath(conf); <line3> Path tezStagingDir; <line4> try { <line5> tezStagingDir = new Path(baseStagingPath, TEZ_SYSTEM_SUB_DIR); <line6> FileSystem fs = tezStagingDir.getFileSystem(conf); <line7> tezStagingDir = new Path(tezStagingDir, strAppId); <line8> if (!fs.exists(tezStagingDir)) { <line9> mkDirForAM(fs, tezStagingDir); <line10> } <line11> } catch (IOException e) { <line12> throw new TezUncheckedException(e); <line13> } <line14> return tezStagingDir; <line15> } <line16> } <line17> 	 <line10>	Yes
public class A { <line0> public org.apache.thrift.async.AsyncMethodCallback<java.lang.Boolean> getResultHandler( <line1> final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, <line2> final int seqid) { <line3> final org.apache.thrift.AsyncProcessFunction fcall = this; <line4> return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Boolean>() { <line5> public void onComplete(java.lang.Boolean o) { <line6> ping_result result = new ping_result(); <line7> result.success = o; <line8> result.setSuccessIsSet(true); <line9> try { <line10> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line11> } catch (org.apache.thrift.transport.TTransportException e) { <line12> fb.close(); <line13> } catch (java.lang.Exception e) { <line14> onError(e); <line15> } <line16> } <line17>  <line18> public void onError(java.lang.Exception e) { <line19> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line20> org.apache.thrift.TSerializable msg; <line21> ping_result result = new ping_result(); <line22> if (e instanceof InvalidOperationException) { <line23> result.e = (InvalidOperationException) e; <line24> result.setEIsSet(true); <line25> msg = result; <line26> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line27> fb.close(); <line28> return; <line29> } else if (e instanceof org.apache.thrift.TApplicationException) { <line30> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line31> msg = (org.apache.thrift.TApplicationException) e; <line32> } else { <line33> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line34> msg = <line35> new org.apache.thrift.TApplicationException( <line36> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line37> } <line38> try { <line39> fcall.sendResponse(fb, msg, msgType, seqid); <line40> } catch (java.lang.Exception ex) { <line41> fb.close(); <line42> } <line43> } <line44> }; <line45> } <line46> } <line47> 	 <line31>	No
public class A { <line0> public void handleFailedResponse(int requestId, @Nullable Throwable cause) { <line1> synchronized (lock) { <line2> if (isShutDown) { <line3> return; <line4> } <line5> PendingStatsRequest<T, V> pendingRequest = pendingRequests.remove(requestId); <line6> if (pendingRequest != null) { <line7> pendingRequest.discard(cause); <line8> rememberRecentRequestId(requestId); <line9> } <line10> } <line11> } <line12> } <line13> 	 <line1>	No
"public class A { <line0> @Override <line1> public void initActivity() { <line2> stride = activityDef.getParams().getOptionalInteger(""stride"").orElse(1); <line3> cluster = createCluster(); <line4> session = createSession(); <line5> bindTimer = ActivityMetrics.timer(activityDef, ""bind""); <line6> executeTimer = ActivityMetrics.timer(activityDef, ""execute""); <line7> resultTimer = ActivityMetrics.timer(activityDef, ""result""); <line8> triesHisto = ActivityMetrics.histogram(activityDef, ""tries""); <line9> logicalGraphOps = ActivityMetrics.timer(activityDef, ""graphops""); <line10> this.opsequence = initSequencer(); <line11> setDefaultsFromOpSequence(this.opsequence); <line12> onActivityDefUpdate(activityDef); <line13> } <line14> } <line15> "	 <line10>	No
public class A { <line0> protected Map<Address, byte[]> unserializeKeys( <line1> Address sender, byte[] buf, int offset, int length) { <line2> Map<Address, byte[]> map = new HashMap<>(); <line3> ByteArrayDataInputStream in = new ByteArrayDataInputStream(buf, offset, length); <line4> try { <line5> int num_keys = in.readInt(); <line6> for (int i = 0; i < num_keys; i++) { <line7> Address mbr = Util.readAddress(in); <line8> int len = in.readInt(); <line9> byte[] key = new byte[len]; <line10> in.readFully(key, 0, key.length); <line11> map.put(mbr, key); <line12> } <line13> } catch (Exception ex) { <line14> } <line15> return map; <line16> } <line17> } <line18> 	 <line10>	No
public class A { <line0> public void exportFeatures( <line1> DataTypeInfo dataType, <line2> GeoPackage geopackage, <line3> ProgressModel model, <line4> CancellableTaskActivity ta) { <line5> GeometryColumns geometryColumns = new GeometryColumns(); <line6> String tableName = <line7> StringUtilities.replaceSpecialCharacters(dataType.getDisplayName()).replace('-', '_'); <line8> List<Pair<FeatureColumn, String>> columns = createColumns(dataType); <line9> List<String> featureTables = geopackage.getFeatureTables(); <line10> if (!featureTables.contains(tableName)) { <line11> geometryColumns.setId(new TableColumnKey(tableName, GeoPackageColumns.GEOMETRY_COLUMN)); <line12> geometryColumns.setGeometryType(GeometryType.GEOMETRY); <line13> geometryColumns.setZ((byte) 1); <line14> geometryColumns.setM((byte) 0); <line15> BoundingBox boundingBox = new BoundingBox(); <line16> List<FeatureColumn> featureColumns = New.list(); <line17> for (Pair<FeatureColumn, String> pair : columns) { <line18> featureColumns.add(pair.getFirstObject()); <line19> } <line20> geopackage.createFeatureTableWithMetadata( <line21> geometryColumns, <line22> boundingBox, <line23> ProjectionConstants.EPSG_WORLD_GEODETIC_SYSTEM, <line24> featureColumns); <line25> } <line26> List<Long> elementIds = myDataElements.getDataElementCacheIds(dataType); <line27> if (!elementIds.isEmpty()) { <line28> try { <line29> FeatureDao dao = geopackage.getFeatureDao(tableName); <line30> List<DataElement> elements = <line31> myDataElements.getDataElements(elementIds, dataType, null, false); <line32> List<Pair<FeatureColumn, String>> columnNames = New.list(); <line33> for (Pair<FeatureColumn, String> pair : columns) { <line34> if (!GeoPackageColumns.GEOMETRY_COLUMN.equals(pair.getSecondObject()) <line35> && !GeoPackageColumns.ID_COLUMN.equals(pair.getSecondObject())) { <line36> columnNames.add(pair); <line37> } <line38> } <line39> for (DataElement element : elements) { <line40> if (element.getVisualizationState().isVisible()) { <line41> myRowExporter.exportRow(element, dao, columnNames); <line42> model.setCompletedCount(model.getCompletedCount() + 1); <line43> if (ta.isCancelled()) { <line44> break; <line45> } <line46> } <line47> } <line48> System.err.println(model.getCompletedCount()); <line49> } catch (DataElementLookupException e) { <line50> } <line51> } <line52> } <line53> } <line54> 	 <line50>	Yes
"public class A { <line0> public <O extends ObjectType> ObjectWrapper<O> createObjectWrapper( <line1> String displayName, <line2> String description, <line3> PrismObject<O> object, <line4> ContainerStatus status, <line5> AuthorizationPhaseType authorizationPhase, <line6> Task task) { <line7> if (authorizationPhase == null) { <line8> authorizationPhase = AuthorizationPhaseType.REQUEST; <line9> } <line10> try { <line11> OperationResult result = task.getResult(); <line12> PrismObjectDefinition<O> objectDefinitionForEditing = <line13> modelServiceLocator <line14> .getModelInteractionService() <line15> .getEditObjectDefinition(object, authorizationPhase, task, result); <line16> if (LOGGER.isTraceEnabled()) { <line17> } <line18> RefinedObjectClassDefinition objectClassDefinitionForEditing = null; <line19> if (isShadow(object)) { <line20> PrismReference resourceRef = object.findReference(ShadowType.F_RESOURCE_REF); <line21> PrismObject<ResourceType> resource = resourceRef.getValue().getObject(); <line22> Validate.notNull(resource, ""No resource object in the resourceRef""); <line23> objectClassDefinitionForEditing = <line24> modelServiceLocator <line25> .getModelInteractionService() <line26> .getEditObjectClassDefinition( <line27> (PrismObject<ShadowType>) object, resource, authorizationPhase); <line28> } <line29> return createObjectWrapper( <line30> displayName, <line31> description, <line32> object, <line33> objectDefinitionForEditing, <line34> objectClassDefinitionForEditing, <line35> status, <line36> result); <line37> } catch (SchemaException | ConfigurationException | ObjectNotFoundException ex) { <line38> throw new SystemException(ex); <line39> } <line40> } <line41> } <line42> "	 <line4>	No
"public class A { <line0> @Test(description = ""This test case tests converting a pem file to X509 Certificate"") <line1> public void testPemToX509Certificate() throws IOException, KeystoreException { <line2> File caCert = new File(CA_CERT_PEM); <line3> BASE64Encoder encoder = new BASE64Encoder(); <line4> byte[] caBytes = FileUtils.readFileToByteArray(caCert); <line5> X509Certificate certificate = managementService.pemToX509Certificate(encoder.encode(caBytes)); <line6> Assert.assertNotNull(certificate); <line7> Assert.assertEquals(certificate.getType(), CertificateManagementConstants.X_509); <line8> } <line9> } <line10> "	 <line8>	Yes
"public class A { <line0> @Override <line1> public void logout(final HttpServletRequest request) { <line2> if (request == null) { <line3> return; <line4> } <line5> final HttpSession session = request.getSession(); <line6> final String sid = (session == null) ? ""(null)"" : session.getId(); <line7> if (log.isDebugEnabled()) { <line8> } <line9> final Session wikiSession = Wiki.session().find(m_engine, request); <line10> final Principal originalPrincipal = wikiSession.getLoginPrincipal(); <line11> wikiSession.invalidate(); <line12> Wiki.session().remove(m_engine, request); <line13> if (session != null) { <line14> session.invalidate(); <line15> } <line16> fireEvent(WikiSecurityEvent.LOGOUT, originalPrincipal, null); <line17> } <line18> } <line19> "	 <line3>	Yes
"public class A { <line0> @Override <line1> public void dispose() { <line2> if (em != null) { <line3> try { <line4> em.getClass().getMethod(""close"", new Class[] {}).invoke(em, new Object[] {}); <line5> } catch (Exception ex) { <line6> } <line7> } <line8> } <line9> } <line10> "	 <line7>	No
public class A { <line0> public void stop() { <line1> stop(false); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> public TrueTypeFont loadSystemFont(String familyName, String fontName) { <line1> String fontFilePath = getSystemFontPath(familyName, fontName); <line2> if (fontFilePath == null) { <line3> return loadDefaultFont(); <line4> } <line5> TrueTypeFont ttf = loadExternalFont(fontFilePath, familyName, fontName); <line6> if (ttf == null) { <line7> return loadDefaultFont(); <line8> } <line9> return ttf; <line10> } <line11> } <line12> 	 <line3>	Yes
"public class A { <line0> @Test <line1> public void testGetString() { <line2> String result = PropertyUtils.getString(""alert.type""); <line3> assertEquals(""EMAIL"", result); <line4> result = PropertyUtils.getString(""mail.server.host""); <line5> assertEquals(""xxx.xxx.test"", result); <line6> result = PropertyUtils.getString(""abc""); <line7> assertNull(result); <line8> result = PropertyUtils.getString(null); <line9> assertNull(result); <line10> } <line11> } <line12> "	 <line11>	No
public class A { <line0> public void persist(MbZielobjSubtypTxt transientInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().persist(transientInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> static void householder(final float[][] matrix) { <line1> int i, j, k, kp; <line2> final int n = matrix.length; <line3> final float[] w = new float[n]; <line4> double s, r, tmp, amax; <line5> for (k = 0, kp = k + 1; k < n - 2; kp++, k++) { <line6> for (amax = 0, i = kp; i < n; amax = max(amax, abs(matrix[i][k])), i++) <line7> ; <line8> if (amax > 0) { <line9> for (s = 0, i = kp; i < n; tmp = matrix[i][k] / amax, s += tmp * tmp, i++) <line10> ; <line11> s = amax * sqrt(s); <line12> if (abs(matrix[kp][k]) > Accuracy.DEPS) { <line13> s *= signum(matrix[kp][k]); <line14> } <line15> r = (s + matrix[kp][k]) * s; <line16> w[k] = 0; <line17> w[kp] = matrix[kp][k] + (float) s; <line18> for (j = kp + 1; j < n; w[j] = matrix[j][k], j++) <line19> ; <line20> if (r != 0) { <line21> multPartial(matrix, kp, w, (float) r); <line22> } else { <line23> for (j = 0; j < n; j++) { <line24> for (k = 0; k < n; k++) { <line25> } <line26> } <line27> } <line28> } <line29> } <line30> } <line31> } <line32> 	 <line23>	Yes
"public class A { <line0> public void streamData( <line1> PID pid, <line2> String dsName, <line3> AccessGroupSet principals, <line4> boolean asAttachment, <line5> HttpServletResponse response) <line6> throws IOException { <line7> String datastream = dsName == null ? ORIGINAL_FILE.getId() : dsName; <line8> DatastreamType dsType = DatastreamType.getByIdentifier(datastream); <line9> if (dsType == null) { <line10> throw new NotFoundException(""Provided value is not the name of a known datastream type""); <line11> } <line12> if (dsType.getStoragePolicy().equals(StoragePolicy.EXTERNAL)) { <line13> throw new IllegalArgumentException(""Cannot stream external datastream "" + datastream); <line14> } <line15> accessControlService.assertHasAccess( <line16> ""Insufficient permissions to access "" + datastream + "" for object "" + pid, <line17> pid, <line18> principals, <line19> getPermissionForDatastream(datastream)); <line20> BinaryObject binObj; <line21> if (ORIGINAL_FILE.getId().equals(datastream)) { <line22> FileObject fileObj = repositoryObjectLoader.getFileObject(pid); <line23> binObj = fileObj.getOriginalFile(); <line24> } else { <line25> String dsPath = URIUtil.join(pid.getQualifiedId(), dsType.getContainer(), dsType.getId()); <line26> PID dsPid = PIDs.get(dsPath); <line27> binObj = repositoryObjectLoader.getBinaryObject(dsPid); <line28> } <line29> response.setHeader(CONTENT_LENGTH, Long.toString(binObj.getFilesize())); <line30> response.setHeader(CONTENT_TYPE, binObj.getMimetype()); <line31> String binaryName = binObj.getFilename(); <line32> String filename = binaryName == null ? pid.getId() : binaryName; <line33> if (asAttachment) { <line34> response.setHeader(CONTENT_DISPOSITION, ""attachment; filename=\"""" + filename + ""\""""); <line35> } else { <line36> response.setHeader(CONTENT_DISPOSITION, ""inline; filename=\"""" + filename + ""\""""); <line37> } <line38> try (InputStream binStream = binObj.getBinaryStream()) { <line39> OutputStream outStream = response.getOutputStream(); <line40> IOUtils.copy(binStream, outStream, BUFFER_SIZE); <line41> } <line42> } <line43> } <line44> "	 <line20>	Yes
public class A { <line0> public static JsonNode validateIfNodeIsTextual(JsonNode node) { <line1> if (node != null <line2> && !node.isNull() <line3> && node.isTextual() <line4> && StringUtils.isNotEmpty(node.asText())) { <line5> try { <line6> node = validateIfNodeIsTextual(objectMapper.readTree(node.asText())); <line7> } catch (Exception e) { <line8> } <line9> } <line10> return node; <line11> } <line12> } <line13> 	 <line11>	No
"public class A { <line0> private URL getGalleryFromImage(URL url) throws IOException { <line1> Document doc = Http.url(url).get(); <line2> for (Element link : doc.select(""a[href~=^gallery\\.php.*$]"")) { <line3> if (link.hasAttr(""href"") && link.attr(""href"").contains(""gallery.php"")) { <line4> url = new URL(""http://imagearn.com/"" + link.attr(""href"")); <line5> return url; <line6> } <line7> } <line8> throw new IOException(""Failed to find gallery at URL "" + url); <line9> } <line10> } <line11> "	 <line6>	No
"public class A { <line0> public static com.liferay.commerce.price.list.model.CommercePriceEntry updateCommercePriceEntry( <line1> HttpPrincipal httpPrincipal, <line2> long commercePriceEntryId, <line3> java.math.BigDecimal price, <line4> boolean discountDiscovery, <line5> java.math.BigDecimal discountLevel1, <line6> java.math.BigDecimal discountLevel2, <line7> java.math.BigDecimal discountLevel3, <line8> java.math.BigDecimal discountLevel4, <line9> boolean bulkPricing, <line10> int displayDateMonth, <line11> int displayDateDay, <line12> int displayDateYear, <line13> int displayDateHour, <line14> int displayDateMinute, <line15> int expirationDateMonth, <line16> int expirationDateDay, <line17> int expirationDateYear, <line18> int expirationDateHour, <line19> int expirationDateMinute, <line20> boolean neverExpire, <line21> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line22> throws com.liferay.portal.kernel.exception.PortalException { <line23> try { <line24> MethodKey methodKey = <line25> new MethodKey( <line26> CommercePriceEntryServiceUtil.class, <line27> ""updateCommercePriceEntry"", <line28> _updateCommercePriceEntryParameterTypes21); <line29> MethodHandler methodHandler = <line30> new MethodHandler( <line31> methodKey, <line32> commercePriceEntryId, <line33> price, <line34> discountDiscovery, <line35> discountLevel1, <line36> discountLevel2, <line37> discountLevel3, <line38> discountLevel4, <line39> bulkPricing, <line40> displayDateMonth, <line41> displayDateDay, <line42> displayDateYear, <line43> displayDateHour, <line44> displayDateMinute, <line45> expirationDateMonth, <line46> expirationDateDay, <line47> expirationDateYear, <line48> expirationDateHour, <line49> expirationDateMinute, <line50> neverExpire, <line51> serviceContext); <line52> Object returnObj = null; <line53> try { <line54> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line55> } catch (Exception exception) { <line56> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line57> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line58> } <line59> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line60> } <line61> return (com.liferay.commerce.price.list.model.CommercePriceEntry) returnObj; <line62> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line63> throw systemException; <line64> } <line65> } <line66> } <line67> "	 <line63>	Yes
"public class A { <line0> @Override <line1> public void render(DriverRequest originalRequest, String content, Writer outWriter) <line2> throws IOException, HttpErrorPage { <line3> if (name != null) { <line4> } <line5> this.out = outWriter; <line6> if (content == null) { <line7> return; <line8> } <line9> StringBuilder contentWithoutComments = new StringBuilder(Parameters.DEFAULT_BUFFER_SIZE); <line10> parserComments.setHttpRequest(originalRequest); <line11> parserComments.parse(content, contentWithoutComments); <line12> parser.setHttpRequest(originalRequest); <line13> parser.parse(contentWithoutComments, this); <line14> if (name != null && !this.found) { <line15> throw new HttpErrorPage( <line16> HttpStatus.SC_BAD_GATEWAY, <line17> ""Fragment "" + name + "" not found"", <line18> ""Fragment "" + name + "" not found""); <line19> } <line20> } <line21> } <line22> "	 <line14>	No
public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> cleanup(); <line3> } <line4> } <line5> 	 <line0>	No
"public class A { <line0> private List<Component> getFilteredComponentList(PortletRequest request) throws IOException { <line1> List<Component> componentList; <line2> Map<String, Set<String>> filterMap = new HashMap<>(); <line3> for (Component._Fields filteredField : componentFilteredFields) { <line4> String parameter = request.getParameter(filteredField.toString()); <line5> if (!isNullOrEmpty(parameter) <line6> && !(filteredField.equals(Component._Fields.COMPONENT_TYPE) <line7> && parameter.equals(PortalConstants.NO_FILTER))) { <line8> Set<String> values = CommonUtils.splitToSet(parameter); <line9> if (filteredField.equals(Component._Fields.NAME)) { <line10> values = values.stream().map(v -> v + ""*"").collect(Collectors.toSet()); <line11> } <line12> filterMap.put(filteredField.getFieldName(), values); <line13> } <line14> request.setAttribute(filteredField.getFieldName(), nullToEmpty(parameter)); <line15> } <line16> try { <line17> final User user = UserCacheHolder.getUserFromRequest(request); <line18> int limit = <line19> CustomFieldHelper.loadAndStoreStickyViewSize( <line20> request, user, CUSTOM_FIELD_COMPONENTS_VIEW_SIZE); <line21> ComponentService.Iface componentClient = thriftClients.makeComponentClient(); <line22> request.setAttribute( <line23> PortalConstants.TOTAL_ROWS, componentClient.getTotalComponentsCount(user)); <line24> if (filterMap.isEmpty()) { <line25> componentList = componentClient.getRecentComponentsSummary(limit, user); <line26> } else { <line27> componentList = componentClient.refineSearch(null, filterMap); <line28> } <line29> } catch (TException e) { <line30> componentList = Collections.emptyList(); <line31> } <line32> return componentList; <line33> } <line34> } <line35> "	 <line23>	No
public class A { <line0> private boolean doDeferredLoad(File file) { <line1> boolean result; <line2> try { <line3> ConfigureManager cm = InstanceManager.getNullableDefault(jmri.ConfigureManager.class); <line4> if (cm != null) { <line5> result = cm.loadDeferred(file); <line6> } else { <line7> result = false; <line8> } <line9> } catch (JmriException e) { <line10> result = false; <line11> } <line12> return result; <line13> } <line14> } <line15> 	 <line0>	No
"public class A { <line0> @Override <line1> public void uninstallFeatures( <line2> long maxWaitTime, <line3> EnumSet<FeaturesService.Option> options, <line4> String feature, <line5> String... additionalFeatures) <line6> throws InterruptedException { <line7> Set<String> featuresToUninstall = <line8> featuresFromNames(feature, additionalFeatures) <line9> .filter(featuresService::isInstalled) <line10> .map(Feature::getName) <line11> .collect(Collectors.toSet()); <line12> if (featuresToUninstall.isEmpty()) { <line13> return; <line14> } <line15> String featureNames = String.join("", "", featuresToUninstall); <line16> long startTime = System.currentTimeMillis(); <line17> try { <line18> featuresService.uninstallFeatures(featuresToUninstall, options); <line19> } catch (Exception e) { <line20> throw new SynchronizedInstallerException( <line21> ""Failed to uninstall features ["" + String.join("", "", featuresToUninstall) + ""]"", e); <line22> } <line23> waitForBundles(getRemainingTime(startTime, maxWaitTime)); <line24> } <line25> } <line26> "	 <line17>	No
public class A { <line0> protected void reply(WorkItem item, Event response, Throwable t) { <line1> if (t != null) { <line2> item.future.setException(t); <line3> return; <line4> } <line5> EventVO<Object> event = EventVO.reply(item.request); <line6> if (response != null) { <line7> EventUtils.copyTransitioning(response, event); <line8> event.setData(response.getData()); <line9> } <line10> item.future.set(event); <line11> } <line12> } <line13> 	 <line9>	No
public class A { <line0> @Override <line1> protected Control createDialogArea(Composite parent) { <line2> try { <line3> Composite container = (Composite) super.createDialogArea(parent); <line4> container.setLayout(new FillLayout()); <line5> HitroUIComposite huiComposite = new HitroUIComposite(container, false); <line6> try { <line7> if (this.entity == null) { <line8> entity = new Entity(entType.getId()); <line9> } <line10> String[] tags = Preferences.getEditorTags(); <line11> boolean strict = <line12> Activator.getDefault() <line13> .getPluginPreferences() <line14> .getBoolean(PreferenceConstants.HUI_TAGS_STRICT); <line15> huiComposite.createView( <line16> entity, <line17> true, <line18> useRules, <line19> tags, <line20> strict, <line21> new ArrayList<String>(0), <line22> Activator.getDefault() <line23> .getPreferenceStore() <line24> .getBoolean(PreferenceConstants.USE_VALIDATION_GUI_HINTS), <line25> overrides); <line26> InputHelperFactory.setInputHelpers(entType, huiComposite); <line27> return huiComposite; <line28> } catch (DBException e) { <line29> ExceptionUtil.log(e, Messages.BulkEditDialog_1); <line30> } <line31> } catch (Exception e) { <line32> } <line33> return null; <line34> } <line35> } <line36> 	 <line32>	Yes
"public class A { <line0> @Override <line1> protected ExtendedMimeMessage createMessageInternal() throws MessagingException { <line2> ExtendedMimeMessage mimeMessage; <line3> DocumentReference userReference = users.get(this.position); <line4> Object emailObject = <line5> this.documentAccessBridge.getProperty( <line6> userReference, <line7> new DocumentReference( <line8> userReference.getWikiReference().getName(), ""XWiki"", ""XWikiUsers""), <line9> ""email""); <line10> if (emailObject != null) { <line11> String email = emailObject.toString(); <line12> Map<String, Object> parameters = (Map<String, Object>) this.parameters.get(""parameters""); <line13> mimeMessage = <line14> ExtendedMimeMessage.wrap( <line15> this.factory.createMessage(this.parameters.get(""source""), parameters)); <line16> mimeMessage.addRecipient(Message.RecipientType.TO, InternetAddress.parse(email)[0]); <line17> } else { <line18> getLogger() <line19> mimeMessage = null; <line20> } <line21> return mimeMessage; <line22> } <line23> } <line24> "	 <line19>	Yes
"public class A { <line0> void addFileSet( <line1> final FileSet fileSet, <line2> final Archiver archiver, <line3> final AssemblerConfigurationSource configSource, <line4> final File archiveBaseDir) <line5> throws AssemblyFormattingException, ArchiveCreationException { <line6> checkLogger(); <line7> if (project == null) { <line8> project = configSource.getProject(); <line9> } <line10> final File basedir = project.getBasedir(); <line11> String destDirectory = fileSet.getOutputDirectory(); <line12> if (destDirectory == null) { <line13> destDirectory = fileSet.getDirectory(); <line14> } <line15> AssemblyFormatUtils.warnForPlatformSpecifics(logger, destDirectory); <line16> destDirectory = <line17> AssemblyFormatUtils.getOutputDirectory( <line18> destDirectory, <line19> configSource.getFinalName(), <line20> configSource, <line21> AssemblyFormatUtils.moduleProjectInterpolator(moduleProject), <line22> AssemblyFormatUtils.artifactProjectInterpolator(project)); <line23> if (logger.isDebugEnabled()) { <line24> } <line25> File fileSetDir = getFileSetDirectory(fileSet, basedir, archiveBaseDir); <line26> if (fileSetDir.exists()) { <line27> InputStreamTransformer fileSetTransformers = <line28> ReaderFormatter.getFileSetTransformers( <line29> configSource, fileSet.isFiltered(), fileSet.getLineEnding()); <line30> if (fileSetTransformers == null) { <line31> } <line32> if (fileSetDir.getPath().equals(File.separator)) { <line33> throw new AssemblyFormattingException( <line34> ""Your assembly descriptor specifies a directory of "" <line35> + File.separator <line36> + "", which is your *entire* file system.\n"" <line37> + ""These are not the files you are looking for""); <line38> } <line39> final AddDirectoryTask task = new AddDirectoryTask(fileSetDir, fileSetTransformers); <line40> final int dirMode = TypeConversionUtils.modeToInt(fileSet.getDirectoryMode(), logger); <line41> if (dirMode != -1) { <line42> task.setDirectoryMode(dirMode); <line43> } <line44> final int fileMode = TypeConversionUtils.modeToInt(fileSet.getFileMode(), logger); <line45> if (fileMode != -1) { <line46> task.setFileMode(fileMode); <line47> } <line48> task.setUseDefaultExcludes(fileSet.isUseDefaultExcludes()); <line49> task.setExcludes(fileSet.getExcludes()); <line50> task.setIncludes(fileSet.getIncludes()); <line51> task.setOutputDirectory(destDirectory); <line52> task.execute(archiver); <line53> } <line54> } <line55> } <line56> "	 <line31>	Yes
"public class A { <line0> @Override <line1> public void removeMulticastReceiver( <line2> final String multicastId, String subscriberParticipantId, String providerParticipantId) { <line3> multicastReceiverRegistry.unregisterMulticastReceiver(multicastId, subscriberParticipantId); <line4> if (!routingTable.containsKey(providerParticipantId)) { <line5> throw new JoynrIllegalStateException( <line6> ""The provider "" <line7> + providerParticipantId <line8> + "" is not known, multicast receiver will not be added.""); <line9> } <line10> performSubscriptionOperation( <line11> multicastId, <line12> providerParticipantId, <line13> new SubscriptionOperation() { <line14> @Override <line15> public void perform(IMessagingMulticastSubscriber messagingMulticastSubscriber) { <line16> messagingMulticastSubscriber.unregisterMulticastSubscription(multicastId); <line17> } <line18> }); <line19> } <line20> } <line21> "	 <line5>	Yes
"public class A { <line0> @Override <line1> public void onTrigger(ProcessContext context, ProcessSession session) throws ProcessException { <line2> String fileOrDirectoryName = null; <line3> FlowFile flowFile = session.get(); <line4> if (flowFile == null && context.hasIncomingConnection()) { <line5> context.yield(); <line6> return; <line7> } <line8> if (flowFile != null) { <line9> fileOrDirectoryName = <line10> context.getProperty(FILE_OR_DIRECTORY).evaluateAttributeExpressions(flowFile).getValue(); <line11> } else { <line12> fileOrDirectoryName = <line13> context.getProperty(FILE_OR_DIRECTORY).evaluateAttributeExpressions().getValue(); <line14> } <line15> final FileSystem fileSystem = getFileSystem(); <line16> try { <line17> List<Path> pathList = Lists.newArrayList(); <line18> if (GLOB_MATCHER.reset(fileOrDirectoryName).find()) { <line19> FileStatus[] fileStatuses = fileSystem.globStatus(new Path(fileOrDirectoryName)); <line20> if (fileStatuses != null) { <line21> for (FileStatus fileStatus : fileStatuses) { <line22> pathList.add(fileStatus.getPath()); <line23> } <line24> } <line25> } else { <line26> pathList.add(new Path(fileOrDirectoryName)); <line27> } <line28> Map<String, String> attributes = Maps.newHashMapWithExpectedSize(2); <line29> for (Path path : pathList) { <line30> attributes.put(""filename"", path.getName()); <line31> attributes.put(""path"", path.getParent().toString()); <line32> if (fileSystem.exists(path)) { <line33> fileSystem.delete(path, context.getProperty(RECURSIVE).asBoolean()); <line34> if (!context.hasIncomingConnection()) { <line35> flowFile = session.create(); <line36> } <line37> session.transfer(session.putAllAttributes(flowFile, attributes), REL_SUCCESS); <line38> } else { <line39> if (!context.hasIncomingConnection()) { <line40> flowFile = session.create(); <line41> } <line42> session.transfer(session.putAllAttributes(flowFile, attributes), REL_FAILURE); <line43> } <line44> } <line45> } catch (IOException e) { <line46> if (flowFile != null) { <line47> session.rollback(true); <line48> } <line49> } <line50> } <line51> } <line52> "	 <line6>	No
"public class A { <line0> public void onPageDrop(DragDropEvent event) { <line1> int toStripeIndex = getDropStripeIndex(event); <line2> if (toStripeIndex == -1 || !dragStripeIndexMatches(event)) { <line3> return; <line4> } <line5> GalleryStripe toStripe = stripes.get(toStripeIndex); <line6> List<Pair<View, IncludedStructuralElement>> viewsToBeMoved = new ArrayList<>(); <line7> for (Pair<MediaUnit, IncludedStructuralElement> selectedElement : <line8> dataEditor.getSelectedMedia()) { <line9> for (View view : selectedElement.getValue().getViews()) { <line10> if (Objects.equals(view.getMediaUnit(), selectedElement.getKey())) { <line11> viewsToBeMoved.add(new ImmutablePair<>(view, selectedElement.getValue())); <line12> } <line13> } <line14> } <line15> int toMediaIndex = getMediaIndex(event); <line16> try { <line17> updateData(toStripe, viewsToBeMoved, toMediaIndex); <line18> } catch (Exception e) { <line19> PrimeFaces.current().executeScript(""$('#loadingScreen').hide();""); <line20> PrimeFaces.current().executeScript(""PF('corruptDataWarning').show();""); <line21> } <line22> dataEditor.getStructurePanel().show(); <line23> dataEditor.getPaginationPanel().show(); <line24> updateAffectedStripes(toStripe, viewsToBeMoved); <line25> } <line26> } <line27> "	 <line12>	No
"public class A { <line0> private void connectToRing() throws IOException, InterruptedException { <line1> ringGroup.registerServer( <line2> new ConnectedServerMetadata( <line3> hostName, <line4> configurator.getServicePort(), <line5> System.currentTimeMillis(), <line6> configurator.getEnvironmentFlags())); <line7> Ring ring = null; <line8> while (!stopping) { <line9> ring = ringGroup.getRingForHost(hostAddress); <line10> if (ring != null) { <line11> host = ring.getHostByAddress(hostAddress); <line12> if (host != null) { <line13> break; <line14> } else { <line15> } <line16> } else { <line17> } <line18> Thread.sleep(HOST_RING_CONNECT_SLEEP_TIME_MS_DEFAULT); <line19> } <line20> if (Hosts.isOnline(host)) { <line21> throw new RuntimeException( <line22> ""Could not start a partition server for host "" + host + "" since it is already online.""); <line23> } <line24> host.setCommandQueueChangeListener(this); <line25> host.setCurrentCommandChangeListener(this); <line26> host.setEnvironmentFlags(configurator.getEnvironmentFlags()); <line27> updateFilesystemStatisticsRunnable = new UpdateFilesystemStatisticsRunnable(); <line28> updateFilesystemStatisticsThread = <line29> new Thread(updateFilesystemStatisticsRunnable, ""Update Filesystem Statistics""); <line30> updateFilesystemStatisticsThread.setDaemon(true); <line31> updateFilesystemStatisticsThread.start(); <line32> } <line33> } <line34> "	 <line1>	No
"public class A { <line0> void sendXExpectLastY(ByteString topic, ByteString subid, final int x, final int y) <line1> throws Exception { <line2> for (int i = 0; i < x; i++) { <line3> publisher.publish( <line4> topic, <line5> org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.Message.newBuilder() <line6> .setBody(ByteString.copyFromUtf8(String.valueOf(i))) <line7> .build()); <line8> } <line9> subscriber.subscribe( <line10> topic, <line11> subid, <line12> org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.SubscribeRequest.CreateOrAttach.ATTACH); <line13> final AtomicInteger expected = new AtomicInteger(x - y); <line14> final CountDownLatch latch = new CountDownLatch(1); <line15> subscriber.startDelivery( <line16> topic, <line17> subid, <line18> new org.apache.hw_v4_1_0.hedwig.client.api.MessageHandler() { <line19> @Override <line20> public synchronized void deliver( <line21> ByteString topic, <line22> ByteString subscriberId, <line23> org.apache.hw_v4_1_0.hedwig.protocol.PubSubProtocol.Message msg, <line24> org.apache.hw_v4_1_0.hedwig.util.Callback<Void> callback, <line25> Object context) { <line26> try { <line27> int value = Integer.valueOf(msg.getBody().toStringUtf8()); <line28> if (value == expected.get()) { <line29> expected.incrementAndGet(); <line30> } else { <line31> expected.set(0); <line32> latch.countDown(); <line33> } <line34> if (expected.get() == x) { <line35> latch.countDown(); <line36> } <line37> callback.operationFinished(context, null); <line38> } catch (Exception e) { <line39> latch.countDown(); <line40> } <line41> } <line42> }); <line43> assertTrue( <line44> ""Timed out waiting for messages Y is "" + y + "" expected is currently "" + expected.get(), <line45> latch.await(10, TimeUnit.SECONDS)); <line46> assertEquals(""Should be expected message with "" + x, x, expected.get()); <line47> subscriber.stopDelivery(topic, subid); <line48> subscriber.closeSubscription(topic, subid); <line49> } <line50> } <line51> "	 <line28>	No
public class A { <line0> @Override <line1> public void setup(ProfilerPluginSetupContext context) { <line2> final ArcusPluginConfig config = new ArcusPluginConfig(context.getConfig()); <line3> final boolean arcus = config.isArcus(); <line4> final boolean arcusAsync = config.isArcusAsync(); <line5> final boolean memcached = config.isMemcached(); <line6> final boolean memcachedAsync = config.isMemcachedAsync(); <line7> if (arcus) { <line8> addArcusClientEditor(config); <line9> addCollectionFutureEditor(arcusAsync); <line10> addFrontCacheGetFutureEditor(); <line11> addFrontCacheMemcachedClientEditor(config); <line12> addCacheManagerEditor(); <line13> addBTreeStoreGetFutureEditor(arcusAsync); <line14> addCollectionGetBulkFutureEditor(arcusAsync); <line15> addSMGetFutureFutureEditor(arcusAsync); <line16> } <line17> if (arcus || memcached) { <line18> addMemcachedClientEditor(config); <line19> addBaseOperationImplEditor(); <line20> final boolean async = arcusAsync || memcachedAsync; <line21> addGetFutureEditor(async); <line22> addOperationFutureEditor(async); <line23> addImmediateFutureEditor(async); <line24> addBulkGetFutureEditor(async); <line25> } <line26> } <line27> } <line28> 	 <line3>	Yes
"public class A { <line0> public static java.util.List<Object> getFileEntriesAndFileShortcuts( <line1> HttpPrincipal httpPrincipal, long repositoryId, long folderId, int status, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DLAppServiceUtil.class, <line7> ""getFileEntriesAndFileShortcuts"", <line8> _getFileEntriesAndFileShortcutsParameterTypes32); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, repositoryId, folderId, status, start, end); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (java.util.List<Object>) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	 <line25>	No
"public class A { <line0> @Override <line1> protected void service(HttpServletRequest req, HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> resp.setContentType(""text/plain""); <line4> resp.setCharacterEncoding(""UTF-8""); <line5> String response = <line6> String.format( <line7> ""| %s | %s | %s |"", req.getContextPath(), req.getServletPath(), req.getPathInfo()); <line8> resp.getWriter().write(response); <line9> resp.getWriter().close(); <line10> } <line11> } <line12> "	 <line3>	Yes
public class A { <line0> public void reload(String destination) { <line1> stop(destination); <line2> start(destination); <line3> } <line4> } <line5> 	 <line3>	Yes
"public class A { <line0> @Nullable <line1> private KafkaSupervisorReport fetchKafkaSupervisorReport(Table table) { <line2> final String overlordAddress = <line3> Preconditions.checkNotNull( <line4> HiveConf.getVar(getConf(), HiveConf.ConfVars.HIVE_DRUID_OVERLORD_DEFAULT_ADDRESS), <line5> ""Druid Overlord Address is null""); <line6> final String dataSourceName = <line7> Preconditions.checkNotNull( <line8> DruidStorageHandlerUtils.getTableProperty(table, Constants.DRUID_DATA_SOURCE), <line9> ""Druid Datasource name is null""); <line10> try { <line11> StringFullResponseHolder response = <line12> RetryUtils.retry( <line13> () -> <line14> DruidStorageHandlerUtils.getResponseFromCurrentLeader( <line15> getHttpClient(), <line16> new Request( <line17> HttpMethod.GET, <line18> new URL( <line19> String.format( <line20> ""http://%s/druid/indexer/v1/supervisor/%s/status"", <line21> overlordAddress, dataSourceName))), <line22> new StringFullResponseHandler(Charset.forName(""UTF-8""))), <line23> input -> input instanceof IOException, <line24> getMaxRetryCount()); <line25> if (response.getStatus().equals(HttpResponseStatus.OK)) { <line26> return DruidStorageHandlerUtils.JSON_MAPPER.readValue( <line27> response.getContent(), KafkaSupervisorReport.class); <line28> } else if (response.getStatus().equals(HttpResponseStatus.NOT_FOUND) <line29> || response.getStatus().equals(HttpResponseStatus.BAD_REQUEST)) { <line30> return null; <line31> } else { <line32> return null; <line33> } <line34> } catch (Exception e) { <line35> return null; <line36> } <line37> } <line38> } <line39> "	 <line1>	No
public class A { <line0> @Test <line1> void error() { <line2> this.deferredLog.replayTo(this.log); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> public static String createCorrelationId() { <line1> while (true) { <line2> final String correlationId = String.valueOf(System.currentTimeMillis()); <line3> try { <line4> planRepo.findByCorrelationId(correlationId); <line5> } catch (final NoResultException e) { <line6> return correlationId; <line7> } <line8> } <line9> } <line10> } <line11> 	 <line5>	Yes
public class A { <line0> public void putEntry(final String key, final Object value, final boolean persistent) { <line1> final PFUserDO user = ThreadLocalUserContext.getUser(); <line2> if (user == null || value == null) { <line3> return; <line4> } <line5> if (AccessChecker.isDemoUser(user) && value instanceof Serializable) { <line6> return; <line7> } <line8> try { <line9> userXmlPreferencesCache.putEntry(user.getId(), key, value, persistent); <line10> } catch (final Exception ex) { <line11> } <line12> } <line13> } <line14> 	 <line11>	Yes
public class A { <line0> public void init( <line1> Application application, <line2> Process<M> process, <line3> String trigger, <line4> EventConsumerFactory eventConsumerFactory, <line5> EventReceiver eventReceiver, <line6> Class<D> dataEventClass, <line7> Class<T> cloudEventClass, <line8> boolean useCloudEvents) { <line9> this.process = process; <line10> this.application = application; <line11> this.trigger = trigger; <line12> this.eventConsumer = eventConsumerFactory.get(this::eventToModel, useCloudEvents); <line13> if (useCloudEvents) { <line14> eventReceiver.subscribe( <line15> this::consumeCloud, new SubscriptionInfo<>(cloudEventClass, Optional.of(trigger))); <line16> } else { <line17> eventReceiver.subscribe( <line18> this::consume, new SubscriptionInfo<>(dataEventClass, Optional.of(trigger))); <line19> } <line20> } <line21> } <line22> 	 <line20>	Yes
public class A { <line0> private static void tryDimensionAsMeasures( <line1> Collection<FunctionDesc> unmatchedAggregations, <line2> CapabilityResult result, <line3> Set<TblColRef> dimCols) { <line4> Iterator<FunctionDesc> it = unmatchedAggregations.iterator(); <line5> while (it.hasNext()) { <line6> FunctionDesc functionDesc = it.next(); <line7> if (functionDesc.isCount()) { <line8> it.remove(); <line9> continue; <line10> } <line11> ParameterDesc parameterDesc = functionDesc.getParameter(); <line12> if (parameterDesc == null) { <line13> continue; <line14> } <line15> List<TblColRef> neededCols = <line16> functionDesc instanceof ExpressionDynamicFunctionDesc <line17> ? Lists.newArrayList( <line18> ExpressionColCollector.collectColumns( <line19> ((ExpressionDynamicFunctionDesc) functionDesc).getTupleExpression())) <line20> : parameterDesc.getColRefs(); <line21> if (neededCols.size() > 0 <line22> && dimCols.containsAll(neededCols) <line23> && FunctionDesc.BUILT_IN_AGGREGATIONS.contains(functionDesc.getExpression())) { <line24> result.influences.add(new CapabilityResult.DimensionAsMeasure(functionDesc)); <line25> it.remove(); <line26> continue; <line27> } <line28> } <line29> } <line30> } <line31> 	 <line8>	Yes
public class A { <line0> @OnWebSocketClose <line1> public void onClose(Session session, int closeCode, String closeReason) { <line2> client.shutdown(); <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> public static void warn(Logger log, Object... args) { <line1> if (log.isWarnEnabled()) { <line2> StringBuilder sb = new StringBuilder(); <line3> for (Object o : args) { <line4> sb.append(o).append("", ""); <line5> } <line6> } <line7> } <line8> } <line9> "	 <line7>	No
public class A { <line0> @Override <line1> public void log(LogLevel level, String msg, Object[] os) { <line2> if (isTerminated()) { <line3> return; <line4> } <line5> logger.log(level, msg, os); <line6> } <line7> } <line8> 	 <line3>	Yes
"public class A { <line0> private void initPersistence() { <line1> long ts1 = System.currentTimeMillis(); <line2> CassandraHostConfigurator cassandraHostConfigurator = new CassandraHostConfigurator(); <line3> cassandraHostConfigurator.setHosts(CLUSTER_URL); <line4> cassandraHostConfigurator.setMaxActive(hectorPoolSize); <line5> cassandraHostConfigurator.setCassandraThriftSocketTimeout( <line6> CMBProperties.getInstance().getCassandraThriftSocketTimeOutMS()); <line7> cassandraHostConfigurator.setAutoDiscoverHosts( <line8> CMBProperties.getInstance().isHectorAutoDiscovery()); <line9> cassandraHostConfigurator.setAutoDiscoveryDelayInSeconds( <line10> CMBProperties.getInstance().getHectorAutoDiscoveryDelaySeconds()); <line11> String dataCenter = CMBProperties.getInstance().getCassandraDataCenter(); <line12> if (dataCenter != null && !dataCenter.equals("""")) { <line13> cassandraHostConfigurator.setAutoDiscoveryDataCenter(dataCenter); <line14> } <line15> if (hectorBalancingPolicy != null) { <line16> if (hectorBalancingPolicy.equals(""LeastActiveBalancingPolicy"")) { <line17> cassandraHostConfigurator.setLoadBalancingPolicy(new LeastActiveBalancingPolicy()); <line18> } else if (hectorBalancingPolicy.equals(""RoundRobinBalancingPolicy"")) { <line19> cassandraHostConfigurator.setLoadBalancingPolicy(new RoundRobinBalancingPolicy()); <line20> } else if (hectorBalancingPolicy.equals(""DynamicLoadBalancingPolicy"")) { <line21> cassandraHostConfigurator.setLoadBalancingPolicy(new DynamicLoadBalancingPolicy()); <line22> } <line23> } <line24> cluster = <line25> HFactory.getOrCreateCluster( <line26> AbstractDurablePersistence.CLUSTER_NAME, cassandraHostConfigurator, credentials); <line27> keyspaces = new HashMap<String, Keyspace>(); <line28> List<String> keyspaceNames = new ArrayList<String>(); <line29> keyspaceNames.add(CMBProperties.getInstance().getCMBKeyspace()); <line30> keyspaceNames.add(CMBProperties.getInstance().getCNSKeyspace()); <line31> keyspaceNames.add(CMBProperties.getInstance().getCQSKeyspace()); <line32> for (String k : keyspaceNames) { <line33> Keyspace keyspace = <line34> HFactory.createKeyspace( <line35> k, <line36> cluster, <line37> new SimpleConsistencyPolicy( <line38> HConsistencyLevel.valueOf( <line39> CMBProperties.getInstance().getWriteConsistencyLevel()))); <line40> keyspaces.put(k, keyspace); <line41> } <line42> long ts2 = System.currentTimeMillis(); <line43> CMBControllerServlet.valueAccumulator.addToCounter(AccumulatorName.CassandraTime, (ts2 - ts1)); <line44> } <line45> } <line46> "	 <line2>	Yes
"public class A { <line0> @Override <line1> protected diropres NFSPROC_CREATE_2(createargs params) { <line2> final diropres ret = new diropres(); <line3> try { <line4> final NFSFile dir = pathManager.getNFSFileByHandle(params.where.dir); <line5> if (!dir.getFile().isDirectory()) { <line6> ret.status = nfsstat.NFSERR_NOENT; <line7> return ret; <line8> } <line9> String name = params.where.name.value; <line10> name = replaceColon(name, false); <line11> final File fileToCreate = makeFile(name, dir.getFile()); <line12> if (fileToCreate == null) { <line13> ret.status = nfsstat.NFSERR_IO; <line14> return ret; <line15> } <line16> if (fileToCreate.exists()) { <line17> } else { <line18> try { <line19> if (!fileToCreate.createNewFile()) { <line20> ret.status = nfsstat.NFSERR_IO; <line21> return ret; <line22> } <line23> } catch (final SecurityException e) { <line24> LOG.warn(""CREATE: got exception for "" + fileToCreate, e); <line25> ret.status = nfsstat.NFSERR_ACCES; <line26> return ret; <line27> } catch (final IOException e) { <line28> ret.status = nfsstat.NFSERR_IO; <line29> return ret; <line30> } <line31> try { <line32> } catch (final SecurityException e) { <line33> ret.status = nfsstat.NFSERR_ACCES; <line34> return ret; <line35> } <line36> } <line37> if (ret.status == 0) { <line38> ret.diropres = new diropokres(); <line39> ret.diropres.file = nfs_fh.NULL_FILE_HANDLE; <line40> ret.diropres.file = pathManager.getHandleByFile(fileToCreate); <line41> final NFSFile file = pathManager.getNFSFileByHandle(ret.diropres.file); <line42> ret.diropres.attributes = file.getAttributes(); <line43> } <line44> } catch (final StaleHandleException e) { <line45> ret.status = nfsstat.NFSERR_STALE; <line46> } catch (final FileNotFoundException e) { <line47> ret.status = nfsstat.NFSERR_NOENT; <line48> } <line49> return ret; <line50> } <line51> } <line52> "	 <line28>	Yes
"public class A { <line0> void checkSystemMergeRequest( <line1> final SystemRequestDTO request, final long systemId, final String origin) { <line2> if (systemId <= 0) { <line3> throw new BadPayloadException(ID_NOT_VALID_ERROR_MESSAGE, HttpStatus.SC_BAD_REQUEST, origin); <line4> } <line5> boolean needChange = false; <line6> if (!Utilities.isEmpty(request.getAddress())) { <line7> needChange = true; <line8> } <line9> if (!Utilities.isEmpty(request.getSystemName())) { <line10> needChange = true; <line11> for (final CoreSystem coreSysteam : CoreSystem.values()) { <line12> if (coreSysteam.name().equalsIgnoreCase(request.getSystemName().trim())) { <line13> throw new BadPayloadException( <line14> ""System name '"" <line15> + request.getSystemName() <line16> + ""' is a reserved arrowhead core system name."", <line17> HttpStatus.SC_BAD_REQUEST, <line18> origin); <line19> } <line20> } <line21> } <line22> if (request.getPort() != null) { <line23> final int validatedPort = request.getPort(); <line24> if (validatedPort < CommonConstants.SYSTEM_PORT_RANGE_MIN <line25> || validatedPort > CommonConstants.SYSTEM_PORT_RANGE_MAX) { <line26> throw new BadPayloadException( <line27> ""Port must be between "" <line28> + CommonConstants.SYSTEM_PORT_RANGE_MIN <line29> + "" and "" <line30> + CommonConstants.SYSTEM_PORT_RANGE_MAX <line31> + ""."", <line32> HttpStatus.SC_BAD_REQUEST, <line33> origin); <line34> } <line35> needChange = true; <line36> } <line37> if (request.getAuthenticationInfo() != null) { <line38> needChange = true; <line39> } <line40> if (!needChange) { <line41> throw new BadPayloadException(""Patch request is empty."", HttpStatus.SC_BAD_REQUEST, origin); <line42> } <line43> } <line44> } <line45> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public FSDataOutputStream createObject( <line2> String objName, <line3> String contentType, <line4> Map<String, String> metadata, <line5> Statistics statistics, <line6> boolean overwrite) <line7> throws IOException { <line8> final URL url = new URL(mJossAccount.getAccessURL() + ""/"" + getURLEncodedObjName(objName)); <line9> String cachedName = getObjName(container + ""/"", objName); <line10> objectCache.remove(cachedName); <line11> try { <line12> final OutputStream sos; <line13> if (nonStreamingUpload) { <line14> sos = <line15> new SwiftNoStreamingOutputStream( <line16> mJossAccount, url, contentType, metadata, swiftConnectionManager, this); <line17> } else { <line18> sos = <line19> new SwiftOutputStream(mJossAccount, url, contentType, metadata, swiftConnectionManager); <line20> } <line21> return new FSDataOutputStream(sos, statistics); <line22> } catch (IOException e) { <line23> throw e; <line24> } <line25> } <line26> } <line27> "	 <line10>	No
"public class A { <line0> public DocumentInstance getDocument(String documentId) { <line1> final Document document = documentStorageService.getDocument(documentId); <line2> if (document == null) { <line3> throw new KieServerRuntimeException(""No document found with id "" + documentId); <line4> } <line5> return convertDocument(document, true); <line6> } <line7> } <line8> "	 <line6>	No
public class A { <line0> public void delete(StgMapMsk persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line5>	No
"public class A { <line0> private static InputStream getConfigInputStream(Context context) { <line1> InputStream is = getJSONFromServletContext(context.getServletContext()); <line2> if (is == null) { <line3> String path = context.getServletContext().getInitParameter(""keycloak.config.file""); <line4> if (path == null) { <line5> is = context.getServletContext().getResourceAsStream(""/WEB-INF/keycloak.json""); <line6> } else { <line7> try { <line8> is = new FileInputStream(path); <line9> } catch (FileNotFoundException e) { <line10> log.errorv(""NOT FOUND {0}"", path); <line11> throw new RuntimeException(e); <line12> } <line13> } <line14> } <line15> return is; <line16> } <line17> } <line18> "	 <line5>	Yes
"public class A { <line0> @Override <line1> public int run(String[] args) { <line2> if (args.length == 1) { <line3> String executionId = args[0]; <line4> DirectIoTransactionEditor editor = new DirectIoTransactionEditor(repository); <line5> editor.setConf(getConf()); <line6> try { <line7> boolean aborted = editor.abort(executionId); <line8> return aborted ? 0 : 1; <line9> } catch (Exception e) { <line10> return 1; <line11> } <line12> } else { <line13> System.err.println( <line14> MessageFormat.format( <line15> ""Usage: hadoop {0} -conf <datasource-conf.xml> [execution-id]"", <line16> getClass().getName())); <line17> return 1; <line18> } <line19> } <line20> } <line21> "	 <line4>	No
public class A { <line0> @Deprecated <line1> public void saveBed(Bed bed) { <line2> if (bed == null) return; <line3> updateHistory(bed); <line4> if (bed.getId() == null || bed.getId().intValue() == 0) persist(bed); <line5> else merge(bed); <line6> } <line7> } <line8> 	 <line4>	No
"public class A { <line0> private void populateNewGaugeNameTable() throws SQLException { <line1> dataSource.syncTable(""gauge_name"", GaugeNameDao.columns); <line2> dataSource.syncIndexes(""gauge_name"", GaugeNameDao.indexes); <line3> dataSource.execute(""truncate table gauge_name""); <line4> long fixedIntervalMillis = DAYS.toMillis(1); <line5> String captureTimeSql = <line6> castUntainted( <line7> ""ceil(capture_time / "" + fixedIntervalMillis + "".0) * "" + fixedIntervalMillis); <line8> dataSource.update( <line9> ""insert into gauge_name (capture_time, gauge_name) select distinct "" <line10> + captureTimeSql <line11> + "", gauge_name from gauge_value_rollup_4, gauge_id where"" <line12> + "" gauge_value_rollup_4.gauge_id = gauge_id.gauge_id""); <line13> } <line14> } <line15> "	 <line13>	Yes
"public class A { <line0> @PUT <line1> @Path(""/{id}"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @Consumes(MediaType.TEXT_PLAIN) <line4> @PermitAll <line5> @ApiOperation(""Edit a detection pipeline using a YAML config"") <line6> public Response updateDetectionPipelineApi( <line7> @Auth ThirdEyePrincipal user, <line8> @ApiParam(""yaml config"") String payload, <line9> @ApiParam(""the detection config id to edit"") @PathParam(""id"") long id, <line10> @ApiParam(""tuning window start time for tunable components"") @QueryParam(""startTime"") <line11> long startTime, <line12> @ApiParam(""tuning window end time for tunable components"") @QueryParam(""endTime"") <line13> long endTime) { <line14> Map<String, String> responseMessage = new HashMap<>(); <line15> try { <line16> validatePayload(payload); <line17> updateDetectionConfig(user, id, payload, startTime, endTime); <line18> } catch (ConfigValidationException e) { <line19> return processValidationErrorResponse( <line20> PROP_DETECTION, YamlOperations.UPDATING.name(), payload, e); <line21> } catch (NotAuthorizedException e) { <line22> return processBadAuthorizationResponse( <line23> PROP_DETECTION, YamlOperations.UPDATING.name(), payload, e); <line24> } catch (Exception e) { <line25> return processServerErrorResponse(PROP_DETECTION, YamlOperations.UPDATING.name(), payload, e); <line26> } <line27> responseMessage.put(""message"", ""Alert was updated successfully.""); <line28> responseMessage.put(""more-info"", ""Record updated id "" + id); <line29> responseMessage.put(PROP_DETECTION_ID, String.valueOf(id)); <line30> return Response.ok().entity(responseMessage).build(); <line31> } <line32> } <line33> "	 <line17>	No
"public class A { <line0> @Test <line1> public void test2() { <line2> Integer i1 = new Integer(1); <line3> Integer i2 = new Integer(2); <line4> Integer i3 = new Integer(3); <line5> Exception e = new Exception(""This is a test exception.""); <line6> Logger logger = LoggerFactory.getLogger(""test2""); <line7> } <line8> } <line9> "	 <line7>	Yes
public class A { <line0> @Override <line1> public void configure(ResourceInfo resourceInfo, FeatureContext context) { <line2> final Class<?> resourceClass = resourceInfo.getResourceClass(); <line3> final Method resourceMethod = resourceInfo.getResourceMethod(); <line4> if (resourceMethod.isAnnotationPresent(RequiresAuthentication.class) <line5> || resourceClass.isAnnotationPresent(RequiresAuthentication.class)) { <line6> if (resourceMethod.isAnnotationPresent(RequiresGuest.class)) { <line7> } else { <line8> context.register(new ShiroAuthenticationFilter()); <line9> } <line10> } <line11> if (resourceMethod.isAnnotationPresent(RequiresPermissions.class) <line12> || resourceClass.isAnnotationPresent(RequiresPermissions.class)) { <line13> RequiresPermissions requiresPermissions = <line14> resourceClass.getAnnotation(RequiresPermissions.class); <line15> if (requiresPermissions == null) { <line16> requiresPermissions = resourceMethod.getAnnotation(RequiresPermissions.class); <line17> } <line18> context.register(new ShiroAuthorizationFilter(requiresPermissions)); <line19> } <line20> context.register( <line21> (ContainerResponseFilter) <line22> (requestContext, responseContext) -> ThreadContext.unbindSubject()); <line23> } <line24> } <line25> 	 <line16>	No
"public class A { <line0> @Override <line1> public <T> List<LicenseInfoParsingResult> getLicenseInfos( <line2> Attachment attachment, User user, T context) throws TException { <line3> AttachmentContent attachmentContent = <line4> attachmentContentProvider.getAttachmentContent(attachment); <line5> LicenseInfo licenseInfo = <line6> new LicenseInfo().setFilenames(Arrays.asList(attachmentContent.getFilename())); <line7> LicenseInfoParsingResult result = new LicenseInfoParsingResult().setLicenseInfo(licenseInfo); <line8> InputStream attachmentStream = null; <line9> try { <line10> attachmentStream = attachmentConnector.getAttachmentStream(attachmentContent, user, context); <line11> Document doc = getDocument(attachmentStream); <line12> Set<String> copyrights = getCopyrights(doc); <line13> licenseInfo.setCopyrights(copyrights); <line14> licenseInfo.setLicenseNamesWithTexts(getLicenseNameWithTexts(doc)); <line15> licenseInfo.setSha1Hash(getSha1Hash(doc)); <line16> licenseInfo.setComponentName(getComponent(doc)); <line17> result.setAttachmentContentId(attachment.getAttachmentContentId()); <line18> result.setStatus(LicenseInfoRequestStatus.SUCCESS); <line19> } catch (ParserConfigurationException <line20> | IOException <line21> | XPathExpressionException <line22> | SAXException <line23> | SW360Exception e) { <line24> result <line25> .setStatus(LicenseInfoRequestStatus.FAILURE) <line26> .setMessage(""Error while parsing CLI file: "" + e.toString()); <line27> } finally { <line28> closeQuietly(attachmentStream, log); <line29> } <line30> return Collections.singletonList(result); <line31> } <line32> } <line33> "	 <line24>	Yes
public class A { <line0> @Deprecated <line1> public static com.liferay.commerce.price.list.model.CommercePriceEntrySoap <line2> updateExternalReferenceCode( <line3> com.liferay.commerce.price.list.model.CommercePriceEntrySoap commercePriceEntry, <line4> String externalReferenceCode) <line5> throws RemoteException { <line6> try { <line7> com.liferay.commerce.price.list.model.CommercePriceEntry returnValue = <line8> CommercePriceEntryServiceUtil.updateExternalReferenceCode( <line9> com.liferay.commerce.price.list.model.impl.CommercePriceEntryModelImpl.toModel( <line10> commercePriceEntry), <line11> externalReferenceCode); <line12> return com.liferay.commerce.price.list.model.CommercePriceEntrySoap.toSoapModel(returnValue); <line13> } catch (Exception exception) { <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	 <line17>	No
public class A { <line0> @Override <line1> public void addEntitlementToRole(Role role, Entitlement entitlement) { <line2> final RoleEntity roleEntity; <line3> if (role.getId() != 0) { <line4> roleEntity = em.find(RoleEntity.class, role.getId()); <line5> } else { <line6> roleEntity = getRoleEntity(role.getName(), em); <line7> } <line8> final EntitlementEntity entitlementEntity; <line9> if (entitlement.getId() != 0) { <line10> entitlementEntity = em.find(EntitlementEntity.class, entitlement.getId()); <line11> } else { <line12> entitlementEntity = EntitlementDAOJPAImpl.getEntitlementEntity(entitlement.getName(), em); <line13> } <line14> roleEntity.getEntitlements().add(entitlementEntity); <line15> } <line16> } <line17> 	 <line15>	Yes
"public class A { <line0> @Override <line1> public void destroy() { <line2> String methodName = ""destroy""; <line3> } <line4> } <line5> "	 <line2>	No
public class A { <line0> private void readRateSet() throws Throwable { <line1> File f = new File(setup.clientExchangeRatesPath()); <line2> byte[] bytes = Files.readAllBytes(f.toPath()); <line3> rateSet = ExchangeRateSet.parseFrom(bytes); <line4> } <line5> } <line6> 	 <line3>	No
public class A { <line0> public static MavenProjectConsumer log(final Logger logger) { <line1> return new MavenProjectConsumer() { <line2> @Override <line3> public void accept(MavenProject project) { <line4> final String projectId = <line5> ArtifactUtils.versionlessKey(project.getGroupId(), project.getArtifactId()); <line6> } <line7> }; <line8> } <line9> } <line10> 	 <line6>	Yes
public class A { <line0> public void onConnectionClose(ChannelHandlerContext ctx) { <line1> } <line2> } <line3> 	 <line2>	No
public class A { <line0> protected void setParameter( <line1> final PreparedStatement stmt, <line2> final String attrName, <line3> final int parameterIndex, <line4> final String parameterValue, <line5> final int jdbcType) <line6> throws SQLException { <line7> if (parameterValue == null) { <line8> stmt.setNull(parameterIndex, jdbcType); <line9> } else { <line10> try { <line11> switch (jdbcType) { <line12> case Types.BIT: <line13> case Types.BOOLEAN: <line14> stmt.setBoolean(parameterIndex, Boolean.parseBoolean(parameterValue)); <line15> break; <line16> case Types.TINYINT: <line17> stmt.setByte(parameterIndex, Byte.parseByte(parameterValue)); <line18> break; <line19> case Types.SMALLINT: <line20> stmt.setShort(parameterIndex, Short.parseShort(parameterValue)); <line21> break; <line22> case Types.INTEGER: <line23> stmt.setInt(parameterIndex, Integer.parseInt(parameterValue)); <line24> break; <line25> case Types.BIGINT: <line26> stmt.setLong(parameterIndex, Long.parseLong(parameterValue)); <line27> break; <line28> case Types.REAL: <line29> stmt.setFloat(parameterIndex, Float.parseFloat(parameterValue)); <line30> break; <line31> case Types.FLOAT: <line32> case Types.DOUBLE: <line33> stmt.setDouble(parameterIndex, Double.parseDouble(parameterValue)); <line34> break; <line35> case Types.DECIMAL: <line36> case Types.NUMERIC: <line37> stmt.setBigDecimal(parameterIndex, new BigDecimal(parameterValue)); <line38> break; <line39> case Types.DATE: <line40> stmt.setDate(parameterIndex, new Date(Long.parseLong(parameterValue))); <line41> break; <line42> case Types.TIME: <line43> stmt.setTime(parameterIndex, new Time(Long.parseLong(parameterValue))); <line44> break; <line45> case Types.TIMESTAMP: <line46> stmt.setTimestamp(parameterIndex, new Timestamp(Long.parseLong(parameterValue))); <line47> break; <line48> case Types.CHAR: <line49> case Types.VARCHAR: <line50> case Types.LONGNVARCHAR: <line51> case Types.LONGVARCHAR: <line52> stmt.setString(parameterIndex, parameterValue); <line53> break; <line54> default: <line55> stmt.setObject(parameterIndex, parameterValue, jdbcType); <line56> break; <line57> } <line58> } catch (SQLException e) { <line59> getLogger() <line60> throw e; <line61> } <line62> } <line63> } <line64> } <line65> 	 <line60>	Yes
public class A { <line0> private void applySecurityIdentityToSubject(SecurityIdentity securityIdentity) { <line1> Roles roles = securityIdentity.getRoles(); <line2> Subject subject = obtainSubject(); <line3> if (subject != null) { <line4> if (subject.getPrincipals().size() == 0) { <line5> subject.getPrincipals().add(securityIdentity.getPrincipal()); <line6> } <line7> if (subject.getPrincipals(GroupPrincipal.class).size() == 0) { <line8> roles.forEach(role -> subject.getPrincipals().add(new GroupPrincipal(role))); <line9> } <line10> if (logger.isDebugEnabled()) { <line11> } <line12> } <line13> } <line14> } <line15> 	 <line6>	No
public class A { <line0> private void tryToLoadParams() { <line1> if (iPropsFile != null) { <line2> try { <line3> Properties p = new Properties(); <line4> InputStream is = ClassLoader.getSystemResourceAsStream(iPropsFile); <line5> if (is == null) { <line6> is = this.getClass().getClassLoader().getResourceAsStream(iPropsFile); <line7> if (is == null) { <line8> return; <line9> } <line10> } <line11> p.load(is); <line12> parseConnectionProperties(p); <line13> is.close(); <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> } <line19> 	 <line15>	Yes
public class A { <line0> void onConsumedSubpartition(int subpartitionIndex) { <line1> if (isReleased.get()) { <line2> return; <line3> } <line4> } <line5> } <line6> 	 <line4>	Yes
"public class A { <line0> @Test <line1> void sequencesToPreserveDoNotExist() { <line2> if (!databases.getDefaultDatabase().supportsSequences()) { <line3> return; <line4> } <line5> Set<DbItemIdentifier> itemsToPreserve = <line6> Stream.of( <line7> parseItemIdentifier(SEQUENCE, ""unexisting_sequence1"", databases), <line8> parseItemIdentifier(SEQUENCE, ""unexisting_sequence2"", databases)) <line9> .collect(Collectors.toSet()); <line10> assertThrows(DbMaintainException.class, () -> createDbClearer(itemsToPreserve).clearDatabase()); <line11> } <line12> } <line13> "	 <line3>	Yes
public class A { <line0> public void destroy() { <line1> try { <line2> channelPoolMap.values().forEach(ChannelPool::close); <line3> eventLoopGroup.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS).get(); <line4> executorService.shutdownNow(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
"public class A { <line0> @Test <line1> public void testDeleteWhereOptional() throws Exception { <line2> StringBuilder update = new StringBuilder(); <line3> update.append(getNamespaceDeclarations()); <line4> update.append("" DELETE { ?x foaf:name ?y; foaf:mbox ?mbox. } ""); <line5> update.append("" WHERE {?x foaf:name ?y. ""); <line6> update.append("" OPTIONAL { ?x foaf:mbox ?mbox. FILTER (str(?mbox) = \""bob@example.org\"") } }""); <line7> Update operation = con.prepareUpdate(QueryLanguage.SPARQL, update.toString()); <line8> Literal mboxBob = f.createLiteral(""bob@example.org""); <line9> Literal mboxAlice = f.createLiteral(""alice@example.org""); <line10> assertTrue(con.hasStatement(bob, FOAF.MBOX, mboxBob, true)); <line11> assertTrue(con.hasStatement(alice, FOAF.MBOX, mboxAlice, true)); <line12> assertTrue(con.hasStatement(bob, FOAF.NAME, f.createLiteral(""Bob""), true)); <line13> assertTrue(con.hasStatement(alice, FOAF.NAME, f.createLiteral(""Alice""), true)); <line14> operation.execute(); <line15> assertFalse(con.hasStatement(bob, FOAF.MBOX, mboxBob, true)); <line16> assertTrue(con.hasStatement(alice, FOAF.MBOX, mboxAlice, true)); <line17> assertFalse(con.hasStatement(bob, FOAF.NAME, f.createLiteral(""Bob""), true)); <line18> assertFalse(con.hasStatement(alice, FOAF.NAME, f.createLiteral(""Alice""), true)); <line19> } <line20> } <line21> "	 <line12>	No
"public class A { <line0> @Override <line1> public long getCheckAllLedgersCTime() throws UnavailableException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> try { <line5> byte[] data = zkc.getData(checkAllLedgersCtimeZnode, false, null); <line6> CheckAllLedgersFormat checkAllLedgersFormat = CheckAllLedgersFormat.parseFrom(data); <line7> return checkAllLedgersFormat.hasCheckAllLedgersCTime() <line8> ? checkAllLedgersFormat.getCheckAllLedgersCTime() <line9> : -1; <line10> } catch (KeeperException.NoNodeException ne) { <line11> return -1; <line12> } catch (KeeperException ke) { <line13> throw new ReplicationException.UnavailableException(""Error contacting zookeeper"", ke); <line14> } catch (InterruptedException ie) { <line15> Thread.currentThread().interrupt(); <line16> throw new ReplicationException.UnavailableException( <line17> ""Interrupted while contacting zookeeper"", ie); <line18> } catch (InvalidProtocolBufferException ipbe) { <line19> throw new ReplicationException.UnavailableException( <line20> ""Error while parsing ZK protobuf binary data"", ipbe); <line21> } <line22> } <line23> } <line24> "	 <line3>	Yes
"public class A { <line0> private FlowResponseMessage handleFlowRequest(final FlowRequestMessage request) <line1> throws ProtocolException { <line2> readLock.lock(); <line3> try { <line4> final FlowResponseMessage response = new FlowResponseMessage(); <line5> response.setDataFlow(createDataFlow()); <line6> return response; <line7> } catch (final Exception ex) { <line8> throw new ProtocolException( <line9> ""Failed serializing flow controller state for flow request due to: "" + ex, ex); <line10> } finally { <line11> readLock.unlock(); <line12> } <line13> } <line14> } <line15> "	 <line11>	No
"public class A { <line0> private void trySetupJob(JobID jobId, Configuration conf, BoundedWindow window) { <line1> try { <line2> TaskAttemptContext setupTaskContext = HadoopFormats.createSetupTaskContext(conf, jobId); <line3> OutputFormat<?, ?> jobOutputFormat = HadoopFormats.createOutputFormatFromConfig(conf); <line4> jobOutputFormat.checkOutputSpecs(setupTaskContext); <line5> jobOutputFormat.getOutputCommitter(setupTaskContext).setupJob(setupTaskContext); <line6> } catch (FileAlreadyExistsException e) { <line7> } catch (Exception e) { <line8> throw new RuntimeException(""Unable to setup job."", e); <line9> } <line10> } <line11> } <line12> "	 <line7>	Yes
public class A { <line0> @Override <line1> public void doStateTransition() { <line2> var op = txnCtx.accessor().getTxn().getFileCreate(); <line3> try { <line4> var validity = assessedValidity(op); <line5> if (validity != OK) { <line6> txnCtx.setStatus(validity); <line7> return; <line8> } <line9> var attr = asAttr(op); <line10> var sponsor = txnCtx.activePayer(); <line11> var created = hfs.create(op.getContents().toByteArray(), attr, sponsor); <line12> txnCtx.setCreated(created); <line13> txnCtx.setStatus(SUCCESS); <line14> } catch (IllegalArgumentException iae) { <line15> mapToStatus(iae, txnCtx); <line16> } catch (Exception unknown) { <line17> txnCtx.setStatus(FAIL_INVALID); <line18> } <line19> } <line20> } <line21> 	 <line20>	No
"public class A { <line0> @Override <line1> public void handle(final Callback[] callbacks) throws UnsupportedCallbackException { <line2> AuthorizeCallback ac = null; <line3> for (Callback callback : callbacks) { <line4> if (callback instanceof AuthorizeCallback) { <line5> ac = (AuthorizeCallback) callback; <line6> } else { <line7> throw new UnsupportedCallbackException(callback, ""Unrecognized SASL GSSAPI Callback""); <line8> } <line9> } <line10> if (ac != null) { <line11> final String authid = ac.getAuthenticationID(); <line12> final String authzid = ac.getAuthorizationID(); <line13> if (authid.equals(authzid)) { <line14> ac.setAuthorized(true); <line15> } else { <line16> ac.setAuthorized(false); <line17> } <line18> if (ac.isAuthorized()) { <line19> final String[] authidParts = authid.split(""@""); <line20> ac.setAuthorizedID(authidParts[0]); <line21> } <line22> } <line23> } <line24> } <line25> "	 <line18>	No
"public class A { <line0> public static void sendNationMessagePrefixed(Nation nation, String line) { <line1> for (Player player : TownyAPI.getInstance().getOnlinePlayers(nation)) <line2> player.sendMessage(Translation.of(""default_towny_prefix"") + line); <line3> } <line4> } <line5> "	 <line1>	Yes
public class A { <line0> protected void singleTagChanged(PluginTagEvent event, PluginTagListener listener) { <line1> try { <line2> listener.tagChanged(event); <line3> } catch (Exception ex) { <line4> } <line5> } <line6> } <line7> 	 <line4>	Yes
"public class A { <line0> public static InterpreterSetting fromJson(String json) { <line1> Gson gson = new GsonBuilder().setPrettyPrinting().create(); <line2> StringReader stringReader = new StringReader(json); <line3> JsonReader jsonReader = new JsonReader(stringReader); <line4> InterpreterSetting intpSetting = new InterpreterSetting(); <line5> try { <line6> jsonReader.beginObject(); <line7> while (jsonReader.hasNext()) { <line8> String tag = jsonReader.nextName(); <line9> if (tag.equals(""id"")) { <line10> String id = jsonReader.nextString(); <line11> intpSetting.setId(id); <line12> } else if (tag.equals(""name"")) { <line13> String name = jsonReader.nextString(); <line14> intpSetting.setName(name); <line15> } else if (tag.equals(""group"")) { <line16> String group = jsonReader.nextString(); <line17> intpSetting.setGroup(group); <line18> } else if (tag.equals(""dependencies"")) { <line19> String strDep = jsonReader.nextString(); <line20> List<Dependency> dependencies = <line21> gson.fromJson(strDep, new TypeToken<List<Dependency>>() {}.getType()); <line22> intpSetting.setDependencies(dependencies); <line23> } else if (tag.equals(""properties"")) { <line24> String strProp = jsonReader.nextString(); <line25> Map<String, InterpreterProperty> properties = <line26> gson.fromJson( <line27> strProp, new TypeToken<Map<String, InterpreterProperty>>() {}.getType()); <line28> intpSetting.setProperties(properties); <line29> } else if (tag.equals(""interpreterOption"")) { <line30> String strOption = jsonReader.nextString(); <line31> InterpreterOption intpOption = <line32> gson.fromJson(strOption, new TypeToken<InterpreterOption>() {}.getType()); <line33> intpSetting.setOption(intpOption); <line34> } else if (tag.equals(""interpreterGroup"")) { <line35> String strIntpInfos = jsonReader.nextString(); <line36> List<InterpreterInfo> intpInfos = <line37> gson.fromJson(strIntpInfos, new TypeToken<List<InterpreterInfo>>() {}.getType()); <line38> intpSetting.setInterpreterInfos(intpInfos); <line39> } else { <line40> } <line41> } <line42> jsonReader.endObject(); <line43> jsonReader.close(); <line44> } catch (IOException e) { <line45> } <line46> return intpSetting; <line47> } <line48> } <line49> "	 <line38>	No
public class A { <line0> public boolean checkExists(SchedulerJobHandle handle) throws LensException { <line1> try { <line2> return scheduler.checkExists(JobKey.jobKey(handle.getHandleIdString(), LENS_JOBS)); <line3> } catch (SchedulerException e) { <line4> return false; <line5> } <line6> } <line7> } <line8> 	 <line1>	No
"public class A { <line0> @Test <line1> public void testGetMapAfterWFS() throws Exception { <line2> Document doc = <line3> getAsDOM(""wfs?request=getFeature&version=1.1.0&typeName=gsml:MappedFeature&maxFeatures=1""); <line4> try (InputStream is = <line5> getBinary( <line6> ""wms?request=GetMap&SRS=EPSG:4326&layers=gsml:MappedFeature&styles=stratchart&BBOX=140,-38,150,-35&width=500&height=500&FORMAT=image/png"")) { <line7> BufferedImage imageBuffer = ImageIO.read(is); <line8> assertNotBlank(""app-schema test getmap outcrop character"", imageBuffer, Color.WHITE); <line9> ImageAssert.assertEquals( <line10> URLs.urlToFile(getClass().getResource(""/test-data/img/datareference_stratchart.png"")), <line11> imageBuffer, <line12> 250); <line13> } <line14> } <line15> } <line16> "	 <line4>	Yes
"public class A { <line0> public void convertVideo( <line1> FileItem f, StoredFile sf, ProcessResultList logs, Optional<DoubleConsumer> progress) { <line2> try { <line3> final File mp4 = f.getFile(EXTENSION_MP4); <line4> f.setType(Type.VIDEO); <line5> final String ext = sf.getExt(); <line6> String input = f.getFile(ext).getCanonicalPath(); <line7> boolean sameExt = EXTENSION_MP4.equals(ext); <line8> Path tmp = null; <line9> if (sameExt) { <line10> tmp = Files.createTempFile(""video"", "".mp4""); <line11> input = Files.move(mp4.toPath(), tmp, REPLACE_EXISTING).toFile().getCanonicalPath(); <line12> } <line13> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line14> List<String> args = new ArrayList<>(List.of(getPathToFFMPEG(), ""-y"")); <line15> if (sf.isAudio()) { <line16> args.addAll( <line17> List.of( <line18> ""-loop"", <line19> ""1"", <line20> ""-framerate"", <line21> ""24"", <line22> ""-i"", <line23> new File(getCssImagesDir(), ""audio.jpg"").getCanonicalPath())); <line24> } <line25> args.addAll( <line26> List.of( <line27> ""-i"", <line28> input, <line29> ""-c:v"", <line30> ""h264"", <line31> ""-c:a"", <line32> ""aac"", <line33> ""-pix_fmt"", <line34> ""yuv420p"", <line35> ""-vf"", <line36> ""pad=ceil(iw/2)*2:ceil(ih/2)*2"")); <line37> if (sf.isAudio()) { <line38> args.add(""-shortest""); <line39> } <line40> args.add(mp4.getCanonicalPath()); <line41> ProcessResult res = ProcessHelper.exec(""convert to MP4 :: "" + f.getHash(), args); <line42> logs.add(res); <line43> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line44> if (sameExt && tmp != null) { <line45> if (res.isOk()) { <line46> Files.delete(tmp); <line47> } else { <line48> Files.move(tmp, mp4.toPath(), REPLACE_EXISTING); <line49> } <line50> } <line51> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line52> Dimension dim = getDimension(res.getError(), new Dimension(100, 100)); <line53> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line54> f.setWidth(dim.getWidth()); <line55> f.setHeight(dim.getHeight()); <line56> convertToPng(f, mp4.getCanonicalPath(), logs); <line57> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line58> } catch (Exception err) { <line59> logs.add(new ProcessResult(""convertToMP4"", err.getMessage(), err)); <line60> } <line61> } <line62> } <line63> "	 <line59>	Yes
public class A { <line0> public org.talend.mdm.webservice.WSBoolean existsStoredProcedure( <line1> org.talend.mdm.webservice.WSExistsStoredProcedure arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSBoolean _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	 <line6>	No
"public class A { <line0> private void getAuxThreadProfileAndRespond( <line1> CentralRequest request, StreamObserver<AgentResponse> responseObserver) throws Exception { <line2> Profile profile; <line3> try { <line4> profile = <line5> liveTraceRepository.getAuxThreadProfile( <line6> """", request.getAuxThreadProfileRequest().getTraceId()); <line7> } catch (Exception e) { <line8> sendExceptionResponse(request, responseObserver); <line9> return; <line10> } <line11> AuxThreadProfileResponse response; <line12> if (profile == null) { <line13> response = AuxThreadProfileResponse.getDefaultInstance(); <line14> } else { <line15> response = AuxThreadProfileResponse.newBuilder().setProfile(profile).build(); <line16> } <line17> responseObserver.onNext( <line18> AgentResponse.newBuilder() <line19> .setRequestId(request.getRequestId()) <line20> .setAuxThreadProfileResponse(response) <line21> .build()); <line22> } <line23> } <line24> "	 <line14>	No
"public class A { <line0> @Override <line1> public void execute(JobExecutionContext jobExecutionContext) { <line2> Request request = <line3> new Request.Builder() <line4> .url(""http://localhost:8080/quartz-scheduler-2.x-scenario/case/call"") <line5> .build(); <line6> Response response = null; <line7> try { <line8> response = CLIENT.newCall(request).execute(); <line9> } catch (IOException e) { <line10> throw new RuntimeException(e); <line11> } <line12> response.body().close(); <line13> } <line14> } <line15> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public UpdateContainer doIt(Workspace workspace) throws CommandException { <line2> if (isDeprecated()) { <line3> return new UpdateContainer( <line4> new ErrorUpdate(""PublishRDFCellCommand is currently not supported"")); <line5> } <line6> Alignment alignment = <line7> AlignmentManager.Instance() <line8> .getAlignment( <line9> AlignmentManager.Instance().constructAlignmentId(workspace.getId(), worksheetId)); <line10> if (alignment == null || alignment.isEmpty()) { <line11> return new UpdateContainer(new ErrorUpdate(""Worksheet not modeled!"")); <line12> } <line13> try { <line14> return new UpdateContainer( <line15> new AbstractUpdate() { <line16> @Override <line17> public void generateJson(String prefix, PrintWriter pw, VWorkspace vWorkspace) { <line18> JSONObject outputObject = new JSONObject(); <line19> try { <line20> outputObject.put(JsonKeys.updateType.name(), ""PublishCellRDFUpdate""); <line21> String rdfCellEscapeString = StringEscapeUtils.escapeHtml(outRdf.toString()); <line22> outputObject.put( <line23> JsonKeys.cellRdf.name(), rdfCellEscapeString.replaceAll(""\\n"", ""<br />"")); <line24> outputObject.put(JsonKeys.worksheetId.name(), worksheetId); <line25> pw.println(outputObject.toString(4)); <line26> } catch (JSONException e) { <line27> } <line28> } <line29> }); <line30> } catch (Exception e) { <line31> return new UpdateContainer(new ErrorUpdate(e.getMessage())); <line32> } <line33> } <line34> } <line35> "	 <line19>	No
"public class A { <line0> @Override <line1> @Receiver <line2> public EngineStopResponse dealEngineConnStop(EngineStopRequest engineStopRequest) { <line3> EngineConn engineConn = getEngineConnByServiceInstance(engineStopRequest.getServiceInstance()); <line4> EngineStopResponse response = new EngineStopResponse(); <line5> if (null != engineConn) { <line6> if (!killEngineConnByPid(engineConn)) { <line7> response.setStopStatus(false); <line8> response.setMsg(""Kill engine "" + engineConn.getServiceInstance().toString() + "" failed.""); <line9> } else { <line10> response.setStopStatus(true); <line11> response.setMsg(""Kill engine "" + engineConn.getServiceInstance().toString() + "" succeed.""); <line12> } <line13> } else { <line14> response.setStopStatus(false); <line15> response.setMsg( <line16> ""EngineConn "" <line17> + engineStopRequest.getServiceInstance().toString() <line18> + "" was not found in this engineConnManager.""); <line19> } <line20> if (!response.getStopStatus()) { <line21> EngineSuicideRequest request = <line22> new EngineSuicideRequest( <line23> engineStopRequest.getServiceInstance(), engineStopRequest.getUser()); <line24> try { <line25> Sender.getSender(engineStopRequest.getServiceInstance()).send(request); <line26> response.setStopStatus(true); <line27> response.setMsg(response.getMsg() + "" Now send suicide request to engine.""); <line28> } catch (Exception e) { <line29> response.setMsg( <line30> response.getMsg() + "" Sended suicide request to engine error, "" + e.getMessage()); <line31> } <line32> } <line33> return response; <line34> } <line35> } <line36> "	 <line14>	Yes
"public class A { <line0> private String scanResource( <line1> Class<? extends IBaseResource> theClass, ResourceDef resourceDefinition) { <line2> boolean primaryNameProvider = true; <line3> String resourceName = resourceDefinition.name(); <line4> if (isBlank(resourceName)) { <line5> Class<?> parent = theClass.getSuperclass(); <line6> primaryNameProvider = false; <line7> while (parent.equals(Object.class) == false && isBlank(resourceName)) { <line8> ResourceDef nextDef = pullAnnotation(parent, ResourceDef.class); <line9> if (nextDef != null) { <line10> resourceName = nextDef.name(); <line11> } <line12> parent = parent.getSuperclass(); <line13> } <line14> if (isBlank(resourceName)) { <line15> throw new ConfigurationException( <line16> ""Resource type @"" <line17> + ResourceDef.class.getSimpleName() <line18> + "" annotation contains no resource name(): "" <line19> + theClass.getCanonicalName() <line20> + "" - This is only allowed for types that extend other resource types ""); <line21> } <line22> } <line23> String resourceNameLowerCase = resourceName.toLowerCase(); <line24> Class<? extends IBaseResource> builtInType = myNameToResourceType.get(resourceNameLowerCase); <line25> boolean standardType = builtInType != null && builtInType.equals(theClass) == true; <line26> if (primaryNameProvider) { <line27> if (builtInType != null && builtInType.equals(theClass) == false) { <line28> primaryNameProvider = false; <line29> } <line30> } <line31> String resourceId = resourceDefinition.id(); <line32> if (!isBlank(resourceId)) { <line33> if (myIdToResourceDefinition.containsKey(resourceId)) { <line34> throw new ConfigurationException( <line35> ""The following resource types have the same ID of '"" <line36> + resourceId <line37> + ""' - "" <line38> + theClass.getCanonicalName() <line39> + "" and "" <line40> + myIdToResourceDefinition <line41> .get(resourceId) <line42> .getImplementingClass() <line43> .getCanonicalName()); <line44> } <line45> } <line46> RuntimeResourceDefinition resourceDef = <line47> new RuntimeResourceDefinition( <line48> myContext, <line49> resourceName, <line50> theClass, <line51> resourceDefinition, <line52> standardType, <line53> myClassToElementDefinitions); <line54> myClassToElementDefinitions.put(theClass, resourceDef); <line55> if (primaryNameProvider) { <line56> if (resourceDef.getStructureVersion() == myVersion) { <line57> myNameToResourceDefinitions.put(resourceNameLowerCase, resourceDef); <line58> } <line59> } <line60> myIdToResourceDefinition.put(resourceId, resourceDef); <line61> scanResourceForSearchParams(theClass, resourceDef); <line62> resourceDef.populateScanAlso(myScanAlso); <line63> return resourceName; <line64> } <line65> } <line66> "	 <line4>	No
"public class A { <line0> private static @Nullable Field getRequestField(Class<?> clazz) { <line1> Class<?> callClass = getCallClass(clazz); <line2> if (callClass == null) { <line3> return null; <line4> } <line5> try { <line6> Field field = clazz.getDeclaredField(""originalRequest""); <line7> field.setAccessible(true); <line8> return field; <line9> } catch (NoSuchFieldException e) { <line10> Field field; <line11> try { <line12> field = clazz.getDeclaredField(""request""); <line13> field.setAccessible(true); <line14> return field; <line15> } catch (Exception f) { <line16> } <line17> } catch (Exception e) { <line18> } <line19> return null; <line20> } <line21> } <line22> "	 <line17>	No
"public class A { <line0> public void setHandshakeTimeout(final Duration time) { <line1> checkImmutable(); <line2> if (time == null || time.isNegative()) { <line3> throw new IllegalArgumentException(""Handshake timeout cannot be null or negative""); <line4> } <line5> handshakeTimeout = time; <line6> } <line7> } <line8> "	 <line5>	Yes
"public class A { <line0> @RequestMapping(method = RequestMethod.DELETE, value = ""/api/textunits/{textUnitId}"") <line1> public void deleteTMTextUnitCurrentVariant(@PathVariable Long textUnitId) { <line2> tmTextUnitCurrentVariantService.removeCurrentVariant(textUnitId); <line3> } <line4> } <line5> "	 <line3>	No
public class A { <line0> @Override <line1> public void process(Exchange exchange) throws Exception { <line2> Message in = exchange.getIn(); <line3> Object message = in.getBody(); <line4> if (message == null) { <line5> return; <line6> } <line7> if (!(message instanceof String <line8> || message instanceof byte[] <line9> || message instanceof Reader <line10> || message instanceof InputStream)) { <line11> if (LOG.isInfoEnabled()) { <line12> } <line13> message = in.getBody(String.class); <line14> } <line15> if (message instanceof Reader) { <line16> message = in.getBody(String.class); <line17> } else if (message instanceof InputStream) { <line18> message = in.getBody(byte[].class); <line19> } <line20> if (getEndpoint().isSendToAll()) { <line21> for (final WebSocket websocket : getEndpoint().getWebSocketStore().getAllWebSockets()) { <line22> sendMessage(websocket, message); <line23> } <line24> } else if (in.getHeader(WebsocketConstants.CONNECTION_KEY_LIST) != null) { <line25> List<String> connectionKeyList = <line26> in.getHeader(WebsocketConstants.CONNECTION_KEY_LIST, List.class); <line27> messageDistributor(connectionKeyList, message); <line28> } else { <line29> String connectionKey = in.getHeader(WebsocketConstants.CONNECTION_KEY, String.class); <line30> messageDistributor(Arrays.asList(connectionKey), message); <line31> } <line32> } <line33> } <line34> 	 <line20>	Yes
public class A { <line0> private ResourceResponse processPostResourcePlugins(ResourceResponse resourceResponse) <line1> throws StopProcessingException { <line2> for (PostResourcePlugin plugin : frameworkProperties.getPostResource()) { <line3> try { <line4> resourceResponse = plugin.process(resourceResponse); <line5> } catch (PluginExecutionException e) { <line6> } <line7> } <line8> return resourceResponse; <line9> } <line10> } <line11> 	 <line7>	No
public class A { <line0> @Override <line1> public void process(Message message, TestContext context) { <line2> if (supportsMessageType(message.getType())) { <line3> processMessage(message, context); <line4> } else { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
public class A { <line0> protected void setHttpResponseHeaders(HttpServletResponse resp, BinaryResource resource) { <line1> resp.setContentLength(resource.getContentLength()); <line2> String charset = resource.getCharset(); <line3> if (charset != null) { <line4> resp.setCharacterEncoding(charset); <line5> } <line6> String contentType = resource.getContentType(); <line7> if (contentType != null) { <line8> resp.setContentType(contentType); <line9> } else { <line10> } <line11> } <line12> } <line13> 	 <line10>	Yes
public class A { <line0> void printStats() { <line1> } <line2> } <line3> 	 <line2>	No
public class A { <line0> public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) { <line1> try { <line2> State current = null; <line3> if (channelData.containsKey(channelId)) { <line4> current = channelData.get(channelId); <line5> } <line6> if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) { <line7> if ((current != null) && current.getClass().isEnum() && (current.equals(newValue))) { <line8> return false; <line9> } <line10> thingHandler.publishState(channelId, newValue); <line11> if (current == null) { <line12> channelData.put(channelId, newValue); <line13> } else { <line14> channelData.replace(channelId, newValue); <line15> } <line16> return true; <line17> } <line18> } catch (IllegalArgumentException e) { <line19> } <line20> return false; <line21> } <line22> } <line23> 	 <line17>	No
"public class A { <line0> private void removeStaleProvidersOfClusterController(String gbid) { <line1> Callback<Void> callback = <line2> new Callback<Void>() { <line3> @Override <line4> public void onSuccess(Void result) { <line5> } <line6>  <line7> @Override <line8> public void onFailure(JoynrRuntimeException error) { <line9> if (!(error instanceof JoynrMessageNotSentException <line10> && error.getMessage().contains(""Address type not supported""))) { <line11> removeStaleProvidersOfClusterController(gbid); <line12> } <line13> } <line14> }; <line15> globalCapabilitiesDirectoryClient.removeStale(callback, ccStartUpDateInMs, gbid); <line16> } <line17> } <line18> "	 <line12>	No
"public class A { <line0> @Override <line1> public long process(Txn transaction) <line2> throws PermissionDeniedException, LockException, EXistException, XPathException, <line3> TriggerException { <line4> final NodeList children = content; <line5> if (children.getLength() == 0) { <line6> return 0; <line7> } <line8> int modifications = children.getLength(); <line9> try { <line10> final StoredNode ql[] = selectAndLock(transaction); <line11> final NotificationService notifier = broker.getBrokerPool().getNotificationService(); <line12> for (final StoredNode node : ql) { <line13> if (node == null) { <line14> continue; <line15> } <line16> final DocumentImpl doc = node.getOwnerDocument(); <line17> if (!doc.getPermissions().validate(broker.getCurrentSubject(), Permission.WRITE)) { <line18> throw new PermissionDeniedException( <line19> ""User '"" <line20> + broker.getCurrentSubject().getName() <line21> + ""' does not have permission to write to the document '"" <line22> + doc.getDocumentURI() <line23> + ""'!""); <line24> } <line25> switch (node.getNodeType()) { <line26> case Node.ELEMENT_NODE: <line27> if (modifications == 0) { <line28> modifications = 1; <line29> } <line30> ((ElementImpl) node).update(transaction, children); <line31> break; <line32> case Node.TEXT_NODE: <line33> final ElementImpl textParent = (ElementImpl) node.getParentNode(); <line34> final Node textTemp = children.item(0); <line35> final TextImpl text = new TextImpl(textTemp.getNodeValue()); <line36> modifications = 1; <line37> text.setOwnerDocument(doc); <line38> textParent.updateChild(transaction, node, text); <line39> break; <line40> case Node.ATTRIBUTE_NODE: <line41> final ElementImpl attrParent = (ElementImpl) ((Attr) node).getOwnerElement(); <line42> if (attrParent == null) { <line43> break; <line44> } <line45> final AttrImpl attr = (AttrImpl) node; <line46> final Node attrTemp = children.item(0); <line47> final AttrImpl attribute = <line48> new AttrImpl( <line49> attr.getQName(), attrTemp.getNodeValue(), broker.getBrokerPool().getSymbols()); <line50> attribute.setOwnerDocument(doc); <line51> attrParent.updateChild(transaction, node, attribute); <line52> break; <line53> default: <line54> throw new EXistException(""unsupported node-type""); <line55> } <line56> doc.setLastModified(System.currentTimeMillis()); <line57> modifiedDocuments.add(doc); <line58> broker.storeXMLResource(transaction, doc); <line59> notifier.notifyUpdate(doc, UpdateListener.UPDATE); <line60> } <line61> checkFragmentation(transaction, modifiedDocuments); <line62> } finally { <line63> unlockDocuments(transaction); <line64> } <line65> return modifications; <line66> } <line67> } <line68> "	 <line10>	No
"public class A { <line0> @Timed <line1> @ExceptionMetered <line2> @GET <line3> public SecretDeliveryResponse getSecret( <line4> @NotEmpty @PathParam(""secretName"") String secretName, @Auth Client client) { <line5> Optional<SanitizedSecret> sanitizedSecret = aclDAO.getSanitizedSecretFor(client, secretName); <line6> Optional<Secret> secret = secretController.getSecretByName(secretName); <line7> if (!sanitizedSecret.isPresent()) { <line8> boolean clientExists = clientDAO.getClientByName(client.getName()).isPresent(); <line9> boolean secretExists = secret.isPresent(); <line10> if (clientExists && secretExists) { <line11> throw new ForbiddenException( <line12> format( <line13> ""Access denied: %s at '%s' by '%s'"", <line14> client.getName(), ""/secret/"" + secretName, client)); <line15> } else { <line16> if (clientExists) { <line17> } <line18> throw new NotFoundException(); <line19> } <line20> } <line21> try { <line22> return SecretDeliveryResponse.fromSecret(secret.get()); <line23> } catch (IllegalArgumentException e) { <line24> throw new InternalServerErrorException(); <line25> } <line26> } <line27> } <line28> "	 <line27>	No
"public class A { <line0> private Future<Message> processAssertRequest( <line1> final Message request, <line2> final ResourceIdentifier targetAddress, <line3> final SpanContext spanContext) { <line4> final String tenantId = targetAddress.getTenantId(); <line5> final String deviceId = MessageHelper.getDeviceId(request); <line6> final String gatewayId = MessageHelper.getGatewayId(request); <line7> final Span span = <line8> TracingHelper.buildServerChildSpan( <line9> tracer, <line10> spanContext, <line11> SPAN_NAME_ASSERT_DEVICE_REGISTRATION, <line12> getClass().getSimpleName()) <line13> .start(); <line14> TracingHelper.setDeviceTags(span, tenantId, deviceId); <line15> final Future<Message> resultFuture; <line16> if (tenantId == null || deviceId == null) { <line17> TracingHelper.logError(span, ""missing tenant and/or device""); <line18> resultFuture = <line19> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST)); <line20> } else { <line21> final Future<RegistrationResult> result; <line22> if (gatewayId == null) { <line23> result = getService().assertRegistration(tenantId, deviceId, span); <line24> } else { <line25> TracingHelper.TAG_GATEWAY_ID.set(span, gatewayId); <line26> result = getService().assertRegistration(tenantId, deviceId, gatewayId, span); <line27> } <line28> resultFuture = <line29> result.map( <line30> res -> <line31> RegistrationConstants.getAmqpReply( <line32> RegistrationConstants.REGISTRATION_ENDPOINT, tenantId, request, res)); <line33> } <line34> return finishSpanOnFutureCompletion(span, resultFuture); <line35> } <line36> } <line37> "	 <line20>	No
public class A { <line0> public int getRowCount() { <line1> if (!isScrollable()) { <line2> return -1; <line3> } <line4> if (rowCount != SQLResultSet.COUNT_NEVER_OBTAINED) { <line5> return rowCount; <line6> } <line7> if (nativeResultSet == null) { <line8> return 0; <line9> } <line10> try { <line11> int curRow = nativeResultSet.getRow(); <line12> try { <line13> if (nativeResultSet.last()) { <line14> rowCount = nativeResultSet.getRow(); <line15> if (rowCount <= 0) { <line16> rowCount = 0; <line17> } <line18> } else { <line19> rowCount = 0; <line20> } <line21> } finally { <line22> if (curRow == 0) { <line23> nativeResultSet.beforeFirst(); <line24> } else { <line25> nativeResultSet.absolute(curRow); <line26> } <line27> } <line28> } catch (SQLException sqle) { <line29> rowCount = 0; <line30> } <line31> return rowCount; <line32> } <line33> } <line34> 	 <line29>	Yes
public class A { <line0> protected void serializeContextToSoapHeader( <line1> final WebServiceMessage message, final Channel channel) { <line2> if (message instanceof SoapMessage) { <line3> final SoapMessage soapMessage = (SoapMessage) message; <line4> final TraceeFilterConfiguration filterConfiguration = backend.getConfiguration(profile); <line5> if (!backend.isEmpty() && filterConfiguration.shouldProcessContext(channel)) { <line6> final SoapHeader soapHeader = soapMessage.getSoapHeader(); <line7> if (soapHeader != null) { <line8> final Map<String, String> context = <line9> filterConfiguration.filterDeniedParams(backend.copyToMap(), channel); <line10> soapHeaderTransport.renderSoapHeader(context, soapHeader.getResult()); <line11> } <line12> } <line13> } else { <line14> } <line15> } <line16> } <line17> 	 <line12>	No
"public class A { <line0> public synchronized void configure(Configuration configuration, String changeLogFile) <line1> throws ConfigurationException { <line2> AppConstants appConstants = AppConstants.getInstance(configuration.getClassLoader()); <line3> setName(""JdbcMigrator for configuration["" + configuration.getName() + ""]""); <line4> if (StringUtils.isEmpty(getDatasourceName())) { <line5> setDatasourceName(appConstants.getString(""jdbc.migrator.dataSource"", null)); <line6> } <line7> super.configure(); <line8> if (changeLogFile == null) <line9> changeLogFile = appConstants.getString(""liquibase.changeLogFile"", ""DatabaseChangelog.xml""); <line10> LiquibaseClassLoaderWrapper cl = <line11> new LiquibaseClassLoaderWrapper(configuration.getClassLoader()); <line12> if (cl.getResource(changeLogFile) == null) { <line13> String msg = ""unable to find database changelog file ["" + changeLogFile + ""]""; <line14> msg += "" classLoader ["" + ClassUtils.nameOf(configuration.getClassLoader()) + ""]""; <line15> } else { <line16> try { <line17> JdbcConnection connection = new JdbcConnection(getConnection()); <line18> instance = new LiquibaseImpl(ibisContext, connection, configuration, changeLogFile); <line19> } catch (ValidationFailedException e) { <line20> ConfigurationWarnings.add( <line21> configuration, log, ""liquibase validation failed: "" + e.getMessage(), e); <line22> } catch (LiquibaseException e) { <line23> ConfigurationWarnings.add(configuration, log, ""liquibase failed to initialize"", e); <line24> } catch (Throwable e) { <line25> ConfigurationWarnings.add( <line26> configuration, <line27> log, <line28> ""liquibase failed to initialize, error connecting to database ["" <line29> + getDatasourceName() <line30> + ""]"", <line31> e); <line32> } <line33> } <line34> } <line35> } <line36> "	 <line8>	No
