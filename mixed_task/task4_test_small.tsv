	without_logging_code_index	label
5342	public class A { <line0> public static boolean isUpdateStatement(Statement statement) { <line1> if (LOGGER.isTraceEnabled()) { <line2> } <line3> if (isSimpleStatement(statement)) { <line4> return UPDATE_PATTERN.matcher(maybeGetNormalizedQueryString(statement)).matches(); <line5> } else { <line6> return statement instanceof Update.Where || statement instanceof Update.Options; <line7> } <line8> } <line9> } <line10> 	<line2>
5343	public class A { <line0> public String resetMethodStatus() { <line1> try { <line2> String result = this.checkMethod(); <line3> if (null != result) return result; <line4> this.resetMethodStatus(this.extractMethod()); <line5> } catch (Throwable t) { <line6> return FAILURE; <line7> } <line8> return SUCCESS; <line9> } <line10> } <line11> 	<line6>
5344	public class A { <line0> private AsyncJobDispatcher findWakeupDispatcher(AsyncJob job) { <line1> if (_jobDispatchers != null) { <line2> List<AsyncJobJoinMapVO> joinRecords = _joinMapDao.listJoinRecords(job.getId()); <line3> if (joinRecords.size() > 0) { <line4> AsyncJobJoinMapVO joinRecord = joinRecords.get(0); <line5> for (AsyncJobDispatcher dispatcher : _jobDispatchers) { <line6> if (dispatcher.getName().equals(joinRecord.getWakeupDispatcher())) return dispatcher; <line7> } <line8> } else { <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	<line9>
5345	public class A { <line0> @Override <line1> public void setPlan(AnimationPlan plan) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> setPlan(plan, null); <line5> } <line6> } <line7> 	<line3>
5346	public class A { <line0> public void shutdown() { <line1> shutdownLatch.countDown(); <line2> } <line3> } <line4> 	<line1>
5347	"public class A { <line0> public static void destroyInstance() { <line1> checkState(instance != null, ""createInstance() must be called prior to destroyInstance()""); <line2> instance.stop(); <line3> instance = null; <line4> } <line5> } <line6> "	<line4>
5348	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private void invokePartitionChangeListener() { <line2> if (!triggerListeners.isEmpty()) { <line3> Map<PartitionEntry, Integer> current = <line4> (Map<PartitionEntry, Integer>) partitionCache.get(CURRENT); <line5> Map<PartitionEntry, Integer> previous = <line6> (Map<PartitionEntry, Integer>) partitionCache.get(PREVIOUS); <line7> Map<String, List<String>> partition = getNodePartition(current, currentNode); <line8> Map<String, Map<String, List<String>>> addedRemoved = <line9> getAddedRemovedPartition(previous, current, currentNode); <line10> if (log.isDebugEnabled()) { <line11> log.debugf(""Previous: %s"", previous); <line12> log.debugf(""Current: %s"", current); <line13> log.debugf(""Partition: %s"", partition); <line14> log.debugf(""Added: %s"", addedRemoved.get(""added"")); <line15> log.debugf(""Removed: %s"", addedRemoved.get(""removed"")); <line16> } <line17> triggerListeners.stream() <line18> .forEach( <line19> triggerListener -> { <line20> triggerListener.onPartitionChange( <line21> partition, addedRemoved.get(""removed""), addedRemoved.get(""added"")); <line22> }); <line23> } <line24> } <line25> } <line26> "	<line11>
5349	"public class A { <line0> private static Optional<String> getJwtUser(ServletRequest req) { <line1> String jwt = WebUtils.toHttp(req).getHeader(""Authorization""); <line2> if (null != jwt && jwt.startsWith(""Bearer "")) { <line3> try { <line4> jwt = jwt.substring(jwt.indexOf(' ') + 1); <line5> Jws<Claims> claims = <line6> Jwts.parser().setSigningKey(ShiroJwtProvider.SIGNING_KEY).parseClaimsJws(jwt); <line7> String user = claims.getBody().getSubject(); <line8> return Strings.hasText(user) ? Optional.of(user) : Optional.empty(); <line9> } catch (JwtException | IllegalArgumentException e) { <line10> } <line11> } <line12> return Optional.empty(); <line13> } <line14> } <line15> "	<line10>
5350	"public class A { <line0> private void updateTwcsDtcsGcSeconds() throws Exception { <line1> for (TableMetadata table : session.getTables()) { <line2> String compactionClass = table.getOptions().getCompaction().get(""class""); <line3> if (compactionClass == null) { <line4> continue; <line5> } <line6> if (compactionClass.equals(""org.apache.cassandra.db.compaction.TimeWindowCompactionStrategy"") <line7> || compactionClass.equals( <line8> ""org.apache.cassandra.db.compaction.DateTieredCompactionStrategy"")) { <line9> session.updateSchemaWithRetry( <line10> ""alter table "" + table.getName() + "" with gc_grace_seconds = "" + HOURS.toSeconds(4)); <line11> } <line12> } <line13> } <line14> } <line15> "	<line1>, <line13>
5351	"public class A { <line0> @Override <line1> public SocialRequest findByUUID_G(String uuid, long groupId) throws NoSuchRequestException { <line2> SocialRequest socialRequest = fetchByUUID_G(uuid, groupId); <line3> if (socialRequest == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""uuid=""); <line7> sb.append(uuid); <line8> sb.append("", groupId=""); <line9> sb.append(groupId); <line10> sb.append(""}""); <line11> if (_log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchRequestException(sb.toString()); <line14> } <line15> return socialRequest; <line16> } <line17> } <line18> "	<line12>
5352	"public class A { <line0> private Set<String> getRoleNamesForUser(String username, LdapContext ldapContext) <line1> throws NamingException { <line2> Set<String> roleNames = new LinkedHashSet<>(); <line3> SearchControls searchCtls = new SearchControls(); <line4> searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE); <line5> String userPrincipalName = username; <line6> if (this.principalSuffix != null && userPrincipalName.indexOf('@') > 1) { <line7> userPrincipalName = userPrincipalName.split(""@"")[0]; <line8> } <line9> String searchFilter = <line10> String.format( <line11> ""(&(objectClass=*)(%s=%s))"", this.getUserSearchAttributeName(), userPrincipalName); <line12> Object[] searchArguments = new Object[] {userPrincipalName}; <line13> NamingEnumeration<SearchResult> answer = <line14> ldapContext.search(searchBase, searchFilter, searchArguments, searchCtls); <line15> while (answer.hasMoreElements()) { <line16> SearchResult sr = answer.next(); <line17> Attributes attrs = sr.getAttributes(); <line18> if (attrs != null) { <line19> NamingEnumeration<? extends Attribute> ae = attrs.getAll(); <line20> while (ae.hasMore()) { <line21> Attribute attr = ae.next(); <line22> if (attr.getID().equals(""memberOf"")) { <line23> Collection<String> groupNames = LdapUtils.getAllAttributeValues(attr); <line24> roleNames.addAll(getRoleNamesForGroups(groupNames)); <line25> } <line26> } <line27> } <line28> } <line29> return roleNames; <line30> } <line31> } <line32> "	<line17>, <line24>
5353	public class A { <line0> private <T> ResponseEntity<T> getResponseEntityForPossiblyNotModifiedResult( <line1> final DataWithEtag<T> datasetWithEtag, <line2> final HttpHeaders headers, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> if (datasetWithEtag != null) { <line6> if (datasetWithEtag.isDeleted()) { <line7> return new ResponseEntity<>(headers, HttpStatus.GONE); <line8> } else if (datasetWithEtag.isNotFound()) { <line9> return new ResponseEntity<>(headers, HttpStatus.NOT_FOUND); <line10> } else if (datasetWithEtag.isForbidden()) { <line11> int statusCode = HttpStatus.FORBIDDEN.value(); <line12> Optional<AclEvalResult> accResult = <line13> WonAclRequestHelper.getWonAclEvaluationContext(request).getCombinedResults(); <line14> if (accResult.isPresent()) { <line15> WonAclRequestHelper.setAuthInfoAsResponseHeader(response, accResult.get()); <line16> statusCode = WonAclRequestHelper.getHttpStatusCodeForAclEvaluationResult(accResult.get()); <line17> } <line18> HttpStatus status = HttpStatus.valueOf(statusCode); <line19> return new ResponseEntity<>(headers, status); <line20> } else if (datasetWithEtag.isChanged()) { <line21> return new ResponseEntity<>(datasetWithEtag.getData(), headers, HttpStatus.OK); <line22> } else { <line23> return new ResponseEntity<>(headers, HttpStatus.NOT_MODIFIED); <line24> } <line25> } else { <line26> return new ResponseEntity<>(HttpStatus.NOT_FOUND); <line27> } <line28> } <line29> } <line30> 	<line7>, <line9>, <line19>, <line21>, <line23>
5354	"public class A { <line0> @BeforeClass <line1> public static void setUp() throws Exception { <line2> new File(""target/test-logs"").mkdirs(); <line3> System.setProperty(""hadoop.log.dir"", ""target/test-logs""); <line4> System.setProperty( <line5> ""javax.xml.parsers.SAXParserFactory"", <line6> ""com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl""); <line7> Configuration conf = new Configuration(); <line8> dfsCluster = new MiniDFSCluster(conf, 1, true, null); <line9> dfsCluster.getFileSystem().makeQualified(input); <line10> dfsCluster.getFileSystem().makeQualified(output); <line11> mrCluster = new MiniMRCluster(1, getFileSystem().getUri().toString(), 1); <line12> for (String filename : testWarcs) { <line13> copyFileToTestCluster(filename, ""../warc-indexer/src/test/resources/""); <line14> } <line15> } <line16> } <line17> "	<line2>, <line15>
5355	"public class A { <line0> @Override <line1> public void send(Bundle bundle) throws DataChannelError { <line2> try { <line3> AbstractOutputWriter writer = getWriter(); <line4> if (filter != null && !filter.filter(bundle)) { <line5> return; <line6> } <line7> String[] tok = new String[fileToken.length]; <line8> for (int i = 0; i < tok.length; i++) { <line9> tok[i] = fileToken[i]; <line10> } <line11> for (int i = 0; i < varToken.length; i++) { <line12> TokenIndex t = varToken[i]; <line13> ValueObject vo = bundle.getValue(bundle.getFormat().getField(t.field.getName())); <line14> if (vo == null) { <line15> throw new NullPointerException(""Null value in output path: "" + t.field.getName()); <line16> } <line17> tok[t.index] = ValueUtil.asNativeString(vo); <line18> } <line19> StringBuilder sb = new StringBuilder(); <line20> for (int i = 0; i < tok.length; i++) { <line21> sb.append(tok[i]); <line22> } <line23> writer.writeLine(sb.toString(), bundle); <line24> } catch (Exception ex) { <line25> throw DataChannelError.promote(ex); <line26> } <line27> } <line28> } <line29> "	<line23>
5356	"public class A { <line0> public ModelAndView getOntologyOwlApi(HttpServletRequest request, HttpServletResponse response) <line1> throws Exception { <line2> String syntax; <line3> OutputStream out = null; <line4> InputStream is = null; <line5> int headerBufferSize = 8096; <line6> syntax = request.getParameter(""type""); <line7> response.setHeader(""Content-Type"", ""application/rdf+xml""); <line8> response.setContentType(""application/rdf+xml""); <line9> response.setHeader(""Content-Disposition"", ""attachment;filename=eegdatabase.owl""); <line10> response.setStatus(HttpServletResponse.SC_OK); <line11> response.setBufferSize(headerBufferSize); <line12> out = response.getOutputStream(); <line13> is = semanticFactory.getOntologyOwlApi(syntax); <line14> copy(is, out); <line15> out.flush(); <line16> out.close(); <line17> return null; <line18> } <line19> } <line20> "	<line2>, <line10>, <line13>
5357	public class A { <line0> public void partition() { <line1> disableDiscovery(); <line2> installNewView(); <line3> assertPartitionFormed(); <line4> } <line5> } <line6> 	<line1>, <line4>
5358	"public class A { <line0> public CheckNetworkAnswer execute(CheckNetworkCommand cmd) { <line1> List<PhysicalNetworkSetupInfo> infoList = cmd.getPhysicalNetworkInfoList(); <line2> for (PhysicalNetworkSetupInfo info : infoList) { <line3> if (info.getGuestNetworkName() == null) { <line4> info.setGuestNetworkName(config.getAgentGuestNetworkName()); <line5> } <line6> if (info.getPublicNetworkName() == null) { <line7> info.setPublicNetworkName(config.getAgentPublicNetworkName()); <line8> } <line9> if (info.getPrivateNetworkName() == null) { <line10> info.setPrivateNetworkName(config.getAgentPrivateNetworkName()); <line11> } <line12> if (info.getStorageNetworkName() == null) { <line13> info.setStorageNetworkName(config.getAgentStorageNetworkName()); <line14> } <line15> if (!isNetworkSetupByName(info.getGuestNetworkName())) { <line16> String msg = <line17> ""Guest Physical Network id:"" <line18> + info.getPhysicalNetworkId() <line19> + "", Guest Network is not configured on the backend by name "" <line20> + info.getGuestNetworkName(); <line21> LOGGER.error(msg); <line22> return new CheckNetworkAnswer(cmd, false, msg); <line23> } <line24> if (!isNetworkSetupByName(info.getPrivateNetworkName())) { <line25> String msg = <line26> ""Private Physical Network id:"" <line27> + info.getPhysicalNetworkId() <line28> + "", Private Network is not configured on the backend by name "" <line29> + info.getPrivateNetworkName(); <line30> LOGGER.error(msg); <line31> return new CheckNetworkAnswer(cmd, false, msg); <line32> } <line33> if (!isNetworkSetupByName(info.getPublicNetworkName())) { <line34> String msg = <line35> ""Public Physical Network id:"" <line36> + info.getPhysicalNetworkId() <line37> + "", Public Network is not configured on the backend by name "" <line38> + info.getPublicNetworkName(); <line39> return new CheckNetworkAnswer(cmd, false, msg); <line40> } <line41> } <line42> return new CheckNetworkAnswer(cmd, true, ""Network Setup check by names is done""); <line43> } <line44> } <line45> "	<line1>, <line39>
5359	"public class A { <line0> @Override <line1> public PageDto updatePageStatus(String pageCode, String status) { <line2> IPage currentPage = this.getPageManager().getDraftPage(pageCode); <line3> BeanPropertyBindingResult bindingResult = new BeanPropertyBindingResult(pageCode, ""page""); <line4> if (null == currentPage) { <line5> throw new ResourceNotFoundException(ERRCODE_PAGE_NOT_FOUND, ""page"", pageCode); <line6> } <line7> if (status.equals(STATUS_DRAFT) && null == this.getPageManager().getOnlinePage(pageCode)) { <line8> return this.getDtoBuilder().convert(currentPage); <line9> } <line10> try { <line11> IPage newPage = null; <line12> if (status.equals(STATUS_ONLINE)) { <line13> IPage publicParent = this.getPageManager().getOnlinePage(currentPage.getParentCode()); <line14> if (null == publicParent) { <line15> bindingResult.reject( <line16> PageValidator.ERRCODE_PAGE_WITH_NO_PUBLIC_PARENT, <line17> new String[] {pageCode, currentPage.getParentCode()}, <line18> ""page.status.parent.unpublished""); <line19> throw new ValidationGenericException(bindingResult); <line20> } <line21> this.getPageManager().setPageOnline(pageCode); <line22> newPage = this.getPageManager().getOnlinePage(pageCode); <line23> } else if (status.equals(STATUS_DRAFT)) { <line24> String[] childCodes = currentPage.getChildrenCodes(); <line25> for (String childCode : childCodes) { <line26> IPage publicChild = this.getPageManager().getOnlinePage(childCode); <line27> if (null != publicChild) { <line28> bindingResult.reject( <line29> PageValidator.ERRCODE_PAGE_WITH_PUBLIC_CHILD, <line30> new String[] {pageCode}, <line31> ""page.status.publicChild""); <line32> throw new ValidationGenericException(bindingResult); <line33> } <line34> } <line35> Map<String, PageServiceUtilizer> beans = <line36> applicationContext.getBeansOfType(PageServiceUtilizer.class); <line37> if (null != beans) { <line38> Iterator<PageServiceUtilizer> iter = beans.values().iterator(); <line39> while (iter.hasNext()) { <line40> PageServiceUtilizer serviceUtilizer = iter.next(); <line41> List utilizer = serviceUtilizer.getPageUtilizer(pageCode); <line42> if (null != utilizer && utilizer.size() > 0) { <line43> bindingResult.reject( <line44> PageValidator.ERRCODE_REFERENCED_ONLINE_PAGE, <line45> new String[] {pageCode}, <line46> ""page.status.invalid.online.ref""); <line47> throw new ValidationGenericException(bindingResult); <line48> } <line49> } <line50> } <line51> this.getPageManager().setPageOffline(pageCode); <line52> newPage = this.getPageManager().getDraftPage(pageCode); <line53> } <line54> return this.getDtoBuilder().convert(newPage); <line55> } catch (ValidationGenericException e) { <line56> throw e; <line57> } catch (ApsSystemException e) { <line58> throw new RestServerError(""error in update page status"", e); <line59> } <line60> } <line61> } <line62> "	<line58>
5360	"public class A { <line0> @Override <line1> public Optional<ScriptParameterDesignTrace> get( <line2> ScriptParameterDesignTraceKey scriptParameterDesignTraceKey) { <line3> try { <line4> String query = <line5> ""SELECT SCRIPT_PAR_VAL FROM "" <line6> + getMetadataRepository().getTableNameByLabel(""ScriptParameterDesignTraces"") <line7> + "" WHERE "" <line8> + "" RUN_ID = "" <line9> + SQLTools.getStringForSQL(scriptParameterDesignTraceKey.getRunId()) <line10> + "" AND "" <line11> + "" PRC_ID = "" <line12> + SQLTools.getStringForSQL(scriptParameterDesignTraceKey.getProcessId()) <line13> + "";""; <line14> CachedRowSet cachedRowSet = getMetadataRepository().executeQuery(query, ""reader""); <line15> if (cachedRowSet.size() == 0) { <line16> return Optional.empty(); <line17> } else if (cachedRowSet.size() > 1) { <line18> } <line19> cachedRowSet.next(); <line20> return Optional.of( <line21> new ScriptParameterDesignTrace( <line22> scriptParameterDesignTraceKey, cachedRowSet.getString(""SCRIPT_PAR_VAL""))); <line23> } catch (SQLException e) { <line24> throw new RuntimeException(e); <line25> } <line26> } <line27> } <line28> "	<line18>
5361	"public class A { <line0> private void prepareUsername(PWDProtectExtensionMessage msg) throws CryptoException { <line1> Config config = chooser.getConfig(); <line2> EllipticCurve curve = CurveFactory.getCurve(config.getDefaultPWDProtectGroup()); <line3> Point generator = curve.getBasePoint(); <line4> Point serverPublicKey = config.getDefaultServerPWDProtectPublicKey(); <line5> HKDFAlgorithm hkdfAlgorithm; <line6> if (curve.getModulus().bitLength() <= 256) { <line7> hkdfAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA256; <line8> } else if (curve.getModulus().bitLength() <= 384) { <line9> hkdfAlgorithm = HKDFAlgorithm.TLS_HKDF_SHA384; <line10> } else { <line11> throw new CryptoException(""Missing HKDF algorithm for curves larger than 384 bits""); <line12> } <line13> BigInteger clientPublicKey = <line14> curve.mult(config.getDefaultServerPWDProtectRandomSecret(), generator).getX().getData(); <line15> BigInteger sharedSecret = <line16> curve <line17> .mult(config.getDefaultServerPWDProtectRandomSecret(), serverPublicKey) <line18> .getX() <line19> .getData(); <line20> byte[] key = <line21> HKDFunction.expand( <line22> hkdfAlgorithm, <line23> HKDFunction.extract( <line24> hkdfAlgorithm, null, ArrayConverter.bigIntegerToByteArray(sharedSecret)), <line25> new byte[0], <line26> curve.getModulus().bitLength() / Bits.IN_A_BYTE); <line27> byte[] ctrKey = Arrays.copyOfRange(key, 0, key.length / 2); <line28> byte[] macKey = Arrays.copyOfRange(key, key.length / 2, key.length); <line29> SivMode AES_SIV = new SivMode(); <line30> byte[] protectedUsername = <line31> AES_SIV.encrypt(ctrKey, macKey, chooser.getClientPWDUsername().getBytes()); <line32> msg.setUsername( <line33> ArrayConverter.concatenate( <line34> ArrayConverter.bigIntegerToByteArray( <line35> clientPublicKey, curve.getModulus().bitLength() / Bits.IN_A_BYTE, true), <line36> protectedUsername)); <line37> } <line38> } <line39> "	<line27>, <line37>
5362	"public class A { <line0> @MCRCommand( <line1> syntax = ""build google sitemap"", <line2> help = ""Creates the google sitemap(s) in webapps directory."", <line3> order = 10) <line4> public static void buildSitemap() throws Exception { <line5> final long start = System.currentTimeMillis(); <line6> File webappBaseDir = new File(MCRConfiguration2.getStringOrThrow(""MCR.WebApplication.basedir"")); <line7> MCRGoogleSitemapCommon common = new MCRGoogleSitemapCommon(webappBaseDir); <line8> common.removeSitemapFiles(); <line9> int number = common.checkSitemapFile(); <line10> if (number == 1) { <line11> String fn = common.getFileName(1, true); <line12> File xml = new File(fn); <line13> Document jdom = common.buildSingleSitemap(); <line14> LOGGER.info(""Write Google sitemap file {}."", fn); <line15> new MCRJDOMContent(jdom).sendTo(xml); <line16> } else { <line17> String fn = common.getFileName(1, true); <line18> File xml = new File(fn); <line19> Document jdom = common.buildSitemapIndex(number); <line20> new MCRJDOMContent(jdom).sendTo(xml); <line21> for (int i = 0; i < number; i++) { <line22> fn = common.getFileName(i + 2, true); <line23> xml = new File(fn); <line24> jdom = common.buildPartSitemap(i); <line25> new MCRJDOMContent(jdom).sendTo(xml); <line26> } <line27> } <line28> } <line29> } <line30> "	<line5>, <line10>, <line20>, <line25>, <line28>
5363	"public class A { <line0> private Map<Class<? extends IdentifiableObject>, List<IdentifiableObject>> parseClassListMap( <line1> String metadataVersionSnapshot) { <line2> ByteArrayInputStream byteArrayInputStream = <line3> new ByteArrayInputStream(metadataVersionSnapshot.getBytes(StandardCharsets.UTF_8)); <line4> try { <line5> return renderService.fromMetadata(byteArrayInputStream, RenderFormat.JSON); <line6> } catch (IOException ex) { <line7> String message = <line8> ""Exception occurred while trying to do JSON conversion while parsing class list map""; <line9> throw new MetadataSyncServiceException(message, ex); <line10> } catch (Exception ex) { <line11> throw new MetadataSyncServiceException(ex.getMessage(), ex); <line12> } <line13> } <line14> } <line15> "	<line9>
5364	"public class A { <line0> protected void runIngestTest( <line1> long defaultRunTime, <line2> long keysPerServerPerIter, <line3> int colsPerKey, <line4> int recordSize, <line5> int writeThreads, <line6> int readThreads) <line7> throws Exception { <line8> long start = System.currentTimeMillis(); <line9> String runtimeKey = String.format(RUN_TIME_KEY, this.getClass().getSimpleName()); <line10> long runtime = util.getConfiguration().getLong(runtimeKey, defaultRunTime); <line11> long startKey = 0; <line12> long numKeys = getNumKeys(keysPerServerPerIter); <line13> while (System.currentTimeMillis() - start < 0.9 * runtime) { <line14> int ret = -1; <line15> ret = <line16> loadTool.run( <line17> getArgsForLoadTestTool( <line18> ""-write"", <line19> String.format(""%d:%d:%d"", colsPerKey, recordSize, writeThreads), <line20> startKey, <line21> numKeys)); <line22> if (0 != ret) { <line23> String errorMsg = ""Load failed with error code "" + ret; <line24> LOG.error(errorMsg); <line25> Assert.fail(errorMsg); <line26> } <line27> ret = <line28> loadTool.run( <line29> getArgsForLoadTestTool( <line30> ""-update"", String.format(""60:%d:1"", writeThreads), startKey, numKeys)); <line31> if (0 != ret) { <line32> String errorMsg = ""Update failed with error code "" + ret; <line33> Assert.fail(errorMsg); <line34> } <line35> ret = <line36> loadTool.run( <line37> getArgsForLoadTestTool( <line38> ""-read"", String.format(""100:%d"", readThreads), startKey, numKeys)); <line39> if (0 != ret) { <line40> String errorMsg = ""Verification failed with error code "" + ret; <line41> Threads.sleep(1000 * 60); <line42> ret = <line43> loadTool.run( <line44> getArgsForLoadTestTool( <line45> ""-read"", String.format(""100:%d"", readThreads), startKey, numKeys)); <line46> if (0 != ret) { <line47> } <line48> Assert.fail(errorMsg); <line49> } <line50> startKey += numKeys; <line51> } <line52> } <line53> } <line54> "	<line8>, <line14>, <line33>, <line41>, <line47>
5365	"public class A { <line0> @XContent(""uninstall"") <line1> public void setUninstallCommands(DocumentFragment df) { <line2> try { <line3> uninstall = DOMCommandsParser.parse(df); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> "	<line5>
5366	"public class A { <line0> public void addTypeFilter(String type, String versions) { <line1> Filter filter; <line2> Filter typeFilter; <line3> if (type.contains(""*"")) { <line4> typeFilter = FILTER_FACTORY.like(FILTER_FACTORY.property(Metacard.CONTENT_TYPE), type); <line5> } else { <line6> typeFilter = <line7> FILTER_FACTORY.equals( <line8> FILTER_FACTORY.property(Metacard.CONTENT_TYPE), FILTER_FACTORY.literal(type)); <line9> } <line10> if (StringUtils.isNotEmpty(versions)) { <line11> List<Filter> typeVersionPairsFilters = new ArrayList<>(); <line12> for (String version : VERSION_PATTERN.split(versions)) { <line13> Filter versionFilter; <line14> if (version.contains(""*"")) { <line15> versionFilter = <line16> FILTER_FACTORY.like(FILTER_FACTORY.property(Metacard.CONTENT_TYPE_VERSION), version); <line17> } else { <line18> versionFilter = <line19> FILTER_FACTORY.equals( <line20> FILTER_FACTORY.property(Metacard.CONTENT_TYPE_VERSION), <line21> FILTER_FACTORY.literal(version)); <line22> } <line23> typeVersionPairsFilters.add(FILTER_FACTORY.and(typeFilter, versionFilter)); <line24> } <line25> if (CollectionUtils.isNotEmpty(typeVersionPairsFilters)) { <line26> filter = FILTER_FACTORY.or(typeVersionPairsFilters); <line27> } else { <line28> filter = typeFilter; <line29> } <line30> } else { <line31> filter = typeFilter; <line32> } <line33> if (filter != null) { <line34> filters.add(filter); <line35> } <line36> } <line37> } <line38> "	<line11>, <line34>
5367	"public class A { <line0> public InsightsContentConfig getContentConfig(int contentId) { <line1> try { <line2> Map<String, Object> parameters = new HashMap<>(); <line3> parameters.put(""contentId"", contentId); <line4> return getUniqueResult( <line5> ""FROM InsightsContentConfig CC WHERE CC.contentId = :contentId "", <line6> InsightsContentConfig.class, <line7> parameters); <line8> } catch (Exception e) { <line9> throw e; <line10> } <line11> } <line12> } <line13> "	<line9>
5368	public class A { <line0> @Override <line1> public void onMessage(ConsumerRecord<Object, Object> data) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> Message<?> message = messageConverter.toMessage(data, null, null, null); <line5> Contract dsl = this.selector.matchingContract(message); <line6> if (dsl != null <line7> && dsl.getOutputMessage() != null <line8> && dsl.getOutputMessage().getSentTo() != null) { <line9> String destination = dsl.getOutputMessage().getSentTo().getClientValue(); <line10> if (log.isDebugEnabled()) { <line11> } <line12> Message<?> transform = new StubRunnerKafkaTransformer(this.contracts).transform(dsl); <line13> String defaultTopic = kafkaTemplate().getDefaultTopic(); <line14> try { <line15> kafkaTemplate().setDefaultTopic(destination); <line16> kafkaTemplate().send(transform); <line17> } finally { <line18> kafkaTemplate().setDefaultTopic(defaultTopic); <line19> } <line20> } <line21> } <line22> } <line23> 	<line3>, <line11>
5369	public class A { <line0> public void stop() { <line1> try { <line2> try { <line3> for (final Counter counter : counters) { <line4> counter.writeToFile(); <line5> } <line6> } finally { <line7> storageLock.release(); <line8> } <line9> } catch (final IOException e) { <line10> } finally { <line11> try { <line12> for (final Counter counter : counters) { <line13> counter.clear(); <line14> } <line15> } finally { <line16> if (metricsPublishers != null) { <line17> for (final MetricsPublisher metricsPublisher : metricsPublishers) { <line18> metricsPublisher.stop(); <line19> } <line20> } <line21> } <line22> stopped = true; <line23> } <line24> } <line25> } <line26> 	<line10>
5370	public class A { <line0> @Override <line1> public void getUserListMemberships(final long cursor) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(USER_LIST_MEMBERSHIPS, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> PagableResponseList<UserList> lists = twitter.getUserListMemberships(cursor); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotUserListMemberships(lists); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	<line12>
5371	public class A { <line0> @Override <line1> public boolean matches(final ConditionContext context, final AnnotatedTypeMetadata metadata) { <line2> final boolean enabled = SQS.equals(RpcStrategy.getRpcStrategy()); <line3> return enabled; <line4> } <line5> } <line6> 	<line3>
5372	public class A { <line0> public static void truncateTable(Configuration configuration) { <line1> String kuduConfig = configuration.getString(Key.KUDU_CONFIG); <line2> String userTable = configuration.getString(Key.KUDU_TABLE_NAME); <line3> KuduClient kuduClient = KuduHelper.getKuduClient(configuration); <line4> try { <line5> if (kuduClient.tableExists(userTable)) { <line6> kuduClient.deleteTable(userTable); <line7> } <line8> } catch (KuduException e) { <line9> throw DataXException.asDataXException(KuduWriterErrorCode.DELETE_KUDU_ERROR, e); <line10> } finally { <line11> KuduHelper.closeClient(kuduClient); <line12> } <line13> } <line14> } <line15> 	<line3>, <line7>
5373	"public class A { <line0> static Index wrapIndexWithOptions(final Index index, final IndexPluginOptions options) { <line1> Index retVal = index; <line2> if ((options.basicIndexOptions.getNumPartitions() > 1) <line3> && options.basicIndexOptions.getPartitionStrategy().equals(PartitionStrategy.ROUND_ROBIN)) { <line4> retVal = <line5> new CustomNameIndex( <line6> new CompoundIndexStrategy( <line7> new RoundRobinKeyIndexStrategy(options.basicIndexOptions.getNumPartitions()), <line8> index.getIndexStrategy()), <line9> index.getIndexModel(), <line10> index.getName() <line11> + ""_"" <line12> + PartitionStrategy.ROUND_ROBIN.name() <line13> + ""_"" <line14> + options.basicIndexOptions.getNumPartitions()); <line15> } else if (options.basicIndexOptions.getNumPartitions() > 1) { <line16> if (options.basicIndexOptions.getPartitionStrategy().equals(PartitionStrategy.NONE)) { <line17> } <line18> retVal = <line19> new CustomNameIndex( <line20> new CompoundIndexStrategy( <line21> new HashKeyIndexStrategy(options.basicIndexOptions.getNumPartitions()), <line22> index.getIndexStrategy()), <line23> index.getIndexModel(), <line24> index.getName() <line25> + ""_"" <line26> + PartitionStrategy.HASH.name() <line27> + ""_"" <line28> + options.basicIndexOptions.getNumPartitions()); <line29> } <line30> if ((options.getName() != null) && (options.getName().length() > 0)) { <line31> retVal = <line32> new CustomNameIndex(retVal.getIndexStrategy(), retVal.getIndexModel(), options.getName()); <line33> } <line34> return retVal; <line35> } <line36> } <line37> "	<line17>
5374	public class A { <line0> private Calibrator readPolynomialCalibrator() throws XMLStreamException { <line1> checkStartElementPreconditions(); <line2> int maxExponent = 0; <line3> HashMap<Integer, Double> polynome = new HashMap<>(); <line4> while (true) { <line5> xmlEvent = xmlEventReader.nextEvent(); <line6> if (isStartElementWithName(XTCE_TERM)) { <line7> XtceTerm term = readTerm(); <line8> if (term.getExponent() > maxExponent) { <line9> maxExponent = term.getExponent(); <line10> } <line11> polynome.put(term.getExponent(), term.getCoefficient()); <line12> } else if (isEndElementWithName(XTCE_POLYNOMIAL_CALIBRATOR)) { <line13> double[] coefficients = new double[maxExponent + 1]; <line14> for (Map.Entry<Integer, Double> entry : polynome.entrySet()) { <line15> coefficients[entry.getKey()] = entry.getValue(); <line16> } <line17> return new PolynomialCalibrator(coefficients); <line18> } else { <line19> logUnknown(); <line20> } <line21> } <line22> } <line23> } <line24> 	<line1>
5375	public class A { <line0> public SearchResult getByQuery(String query, int limit, int offset) throws SearchException { <line1> try { <line2> return solrRequester.getByQuery(query, limit, offset); <line3> } catch (SolrServerException e) { <line4> throw new SearchException(e); <line5> } <line6> } <line7> } <line8> 	<line2>
5376	"public class A { <line0> @Override <line1> public void endRead() { <line2> queryProfile.incScanRows(scanCnt); <line3> queryProfile.incFilterRows(filterCnt); <line4> if (queryProfile.isDetailProfileEnable()) { <line5> String stepName = getQueryStepName(); <line6> StreamingQueryProfile.ProfileStep profileStep = queryProfile.finishStep(stepName); <line7> profileStep <line8> .stepInfo(""scan_count"", String.valueOf(scanCnt)) <line9> .stepInfo(""filter_count"", String.valueOf(filterCnt)); <line10> } <line11> } <line12> } <line13> "	<line10>
5377	public class A { <line0> public void attachDirty(StgMPersbezTxt instance) { <line1> try { <line2> sessionFactory.getCurrentSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
5378	"public class A { <line0> public InstancesResult getRunningInstances( <line1> String type, <line2> String entity, <line3> String colo, <line4> List<LifeCycle> lifeCycles, <line5> String filterBy, <line6> String orderBy, <line7> String sortOrder, <line8> Integer offset, <line9> Integer numResults) { <line10> checkColo(colo); <line11> checkType(type); <line12> try { <line13> lifeCycles = checkAndUpdateLifeCycle(lifeCycles, type); <line14> validateNotEmpty(""entityName"", entity); <line15> validateInstanceFilterByClause(filterBy); <line16> Entity entityObject = EntityUtil.getEntity(type, entity); <line17> AbstractWorkflowEngine wfEngine = getWorkflowEngine(entityObject); <line18> return getInstanceResultSubset( <line19> wfEngine.getRunningInstances(entityObject, lifeCycles), <line20> filterBy, <line21> orderBy, <line22> sortOrder, <line23> offset, <line24> numResults, <line25> """"); <line26> } catch (Throwable e) { <line27> throw FalconWebException.newAPIException(e); <line28> } <line29> } <line30> } <line31> "	<line27>
5379	"public class A { <line0> public static void deleteCommerceApplicationBrand( <line1> HttpPrincipal httpPrincipal, long commerceApplicationBrandId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceApplicationBrandServiceUtil.class, <line7> ""deleteCommerceApplicationBrand"", <line8> _deleteCommerceApplicationBrandParameterTypes1); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceApplicationBrandId); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>
5380	"public class A { <line0> @Ignore <line1> @Test <line2> public void offsetTest() { <line3> for (ASpotter m : new ASpotter[] {new Fox()}) { <line4> Map<String, List<Entity>> ents = m.getEntities(""Who was the wife of U.S. president Lincoln?""); <line5> System.out.println(ents); <line6> for (Entity ent : ents.get(""en"")) { <line7> Assert.assertTrue(ent.getOffset() > 0); <line8> } <line9> } <line10> } <line11> } <line12> "	<line7>, <line8>
5381	public class A { <line0> @Override <line1> public boolean getBooleanProperty(final String name) throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> return message.getBooleanProperty(name); <line5> } <line6> } <line7> 	<line3>
5382	"public class A { <line0> @Override <line1> public void render(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) <line2> throws IOException { <line3> try { <line4> RenderRequest renderRequest = <line5> (RenderRequest) httpServletRequest.getAttribute(JavaConstants.JAVAX_PORTLET_REQUEST); <line6> CommerceVirtualOrderItemEditDisplayContext commerceVirtualOrderItemEditDisplayContext = <line7> new CommerceVirtualOrderItemEditDisplayContext( <line8> _commerceOrderService, <line9> _commerceOrderItemService, <line10> getCommerceVirtualOrderItem(httpServletRequest), <line11> _dlAppService, <line12> _itemSelector, <line13> renderRequest); <line14> httpServletRequest.setAttribute( <line15> WebKeys.PORTLET_DISPLAY_CONTEXT, commerceVirtualOrderItemEditDisplayContext); <line16> } catch (PortalException portalException) { <line17> } <line18> _jspRenderer.renderJSP( <line19> _servletContext, <line20> httpServletRequest, <line21> httpServletResponse, <line22> ""/order_item/virtual_settings.jsp""); <line23> } <line24> } <line25> "	<line17>
5383	public class A { <line0> private BulkQcSaveOperation startBulkOperation( <line1> List<QC> items, ThrowingFunction<QC, QC, IOException> action) throws IOException { <line2> QcTarget qcTarget = qcTypeService.get(items.get(0).getType().getId()).getQcTarget(); <line3> BulkQcSaveOperation operation = <line4> new BulkQcSaveOperation(qcTarget, items, authorizationManager.getCurrentUser()); <line5> Authentication auth = <line6> SecurityContextHolder.getContextHolderStrategy().getContext().getAuthentication(); <line7> Thread thread = <line8> new Thread( <line9> () -> { <line10> SecurityContextHolder.getContextHolderStrategy().getContext().setAuthentication(auth); <line11> try { <line12> transactionTemplate.execute( <line13> new TransactionCallbackWithoutResult() { <line14> @Override <line15> protected void doInTransactionWithoutResult(TransactionStatus status) { <line16> while (operation.hasMore()) { <line17> try { <line18> QC item = operation.getNextItem(); <line19> QC saved = action.apply(item); <line20> operation.addSuccess(saved.getId()); <line21> } catch (ValidationException e) { <line22> operation.addFailure(e); <line23> status.setRollbackOnly(); <line24> } catch (Exception e) { <line25> operation.setFailed(e); <line26> status.setRollbackOnly(); <line27> } <line28> } <line29> } <line30> }); <line31> } catch (Exception e) { <line32> operation.setFailed(e); <line33> } <line34> if (operation.isFailed()) { <line35> Exception exception = operation.getException(); <line36> if (!(exception instanceof BulkValidationException)) { <line37> LoggerFactory.getLogger(DefaultQualityControlService.class) <line38> } <line39> } <line40> operation.setComplete(); <line41> }); <line42> thread.start(); <line43> return operation; <line44> } <line45> } <line46> 	<line38>
5384	public class A { <line0> private String convertIterationCondition(DataType iterationCondition) { <line1> if (iterationCondition == null) { <line2> return null; <line3> } else if (iterationCondition instanceof Text) { <line4> return iterationCondition.toString(); <line5> } else { <line6> return iterationCondition.toString(); <line7> } <line8> } <line9> } <line10> 	<line6>
5385	"public class A { <line0> private void bounce(Message message) { <line1> if (!JiveGlobals.getBooleanProperty(""xmpp.message.bounce"", true)) { <line2> return; <line3> } <line4> if (message.getError() != null) { <line5> return; <line6> } <line7> if (message.getFrom() == null || message.getFrom().toString().equals(serverName)) { <line8> return; <line9> } <line10> try { <line11> final Message errorResponse = message.createCopy(); <line12> errorResponse.setError(PacketError.Condition.service_unavailable); <line13> errorResponse.setFrom(message.getTo()); <line14> errorResponse.setTo(message.getFrom()); <line15> route(errorResponse); <line16> } catch (Exception e) { <line17> } <line18> } <line19> } <line20> "	<line2>, <line5>, <line8>, <line11>, <line17>
5386	public class A { <line0> static void closeQuietly(ResultSet rs) { <line1> try { <line2> if (rs != null && !rs.isClosed()) { <line3> rs.close(); <line4> } <line5> } catch (SQLException e) { <line6> log.debug(e.getMessage(), e); <line7> } catch (RuntimeException e) { <line8> } <line9> } <line10> } <line11> 	<line4>, <line8>
5387	"public class A { <line0> public static boolean isProcessRunning(int pid) throws IOException { <line1> boolean isRunning = false; <line2> SafeProcess proc = null; <line3> BufferedReader br = null; <line4> try { <line5> if (isUsingBusyBox()) { <line6> proc = ProcessUtil.exec(""ps""); <line7> } else { <line8> proc = ProcessUtil.exec(PS_COMMAND); <line9> } <line10> proc.waitFor(); <line11> br = new BufferedReader(new InputStreamReader(proc.getInputStream())); <line12> String line = br.readLine(); <line13> while ((line = br.readLine()) != null) { <line14> if (parsePid(line) == pid) { <line15> isRunning = true; <line16> break; <line17> } <line18> } <line19> return isRunning; <line20> } catch (InterruptedException e) { <line21> Thread.currentThread().interrupt(); <line22> throw new IOException(e); <line23> } finally { <line24> if (br != null) { <line25> br.close(); <line26> } <line27> if (proc != null) { <line28> ProcessUtil.destroy(proc); <line29> } <line30> } <line31> } <line32> } <line33> "	<line5>
5388	public class A { <line0> private void prepareCompleteResultingMessage(UnknownMessage msg) { <line1> if (msg.getDataConfig() != null) { <line2> msg.setCompleteResultingMessage(msg.getDataConfig()); <line3> } else { <line4> msg.setCompleteResultingMessage(new byte[0]); <line5> } <line6> } <line7> } <line8> 	<line6>
5389	"public class A { <line0> public static java.util.List<com.liferay.commerce.discount.model.CommerceDiscountRel> <line1> getCPDefinitionsByCommerceDiscountId( <line2> HttpPrincipal httpPrincipal, <line3> long commerceDiscountId, <line4> String name, <line5> String languageId, <line6> int start, <line7> int end) { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> CommerceDiscountRelServiceUtil.class, <line12> ""getCPDefinitionsByCommerceDiscountId"", <line13> _getCPDefinitionsByCommerceDiscountIdParameterTypes12); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, commerceDiscountId, name, languageId, start, end); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (java.util.List<com.liferay.commerce.discount.model.CommerceDiscountRel>) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	<line24>
5390	"public class A { <line0> @Override <line1> public GenPolynomial<C> baseGcd(final GenPolynomial<C> P, final GenPolynomial<C> S) { <line2> if (debug) { <line3> if (ComputerThreads.NO_THREADS) { <line4> throw new RuntimeException(""this should not happen""); <line5> } <line6> } <line7> if (S == null || S.isZERO()) { <line8> return P; <line9> } <line10> if (P == null || P.isZERO()) { <line11> return S; <line12> } <line13> GenPolynomial<C> g = null; <line14> List<Callable<GenPolynomial<C>>> cs = new ArrayList<Callable<GenPolynomial<C>>>(2); <line15> cs.add( <line16> new Callable<GenPolynomial<C>>() { <line17> public GenPolynomial<C> call() { <line18> try { <line19> GenPolynomial<C> g = e1.baseGcd(P, S); <line20> if (debug) { <line21> } <line22> return g; <line23> } catch (PreemptingException e) { <line24> throw new RuntimeException(""GCDProxy e1 pre "" + e); <line25> } catch (Exception e) { <line26> logger.info(""GCDProxy P = "" + P); <line27> logger.info(""GCDProxy S = "" + S); <line28> throw new RuntimeException(""GCDProxy e1 "" + e); <line29> } <line30> } <line31> }); <line32> cs.add( <line33> new Callable<GenPolynomial<C>>() { <line34> public GenPolynomial<C> call() { <line35> try { <line36> GenPolynomial<C> g = e2.baseGcd(P, S); <line37> if (debug) { <line38> } <line39> return g; <line40> } catch (PreemptingException e) { <line41> throw new RuntimeException(""GCDProxy e2 pre "" + e); <line42> } catch (Exception e) { <line43> throw new RuntimeException(""GCDProxy e2 "" + e); <line44> } <line45> } <line46> }); <line47> try { <line48> g = pool.invokeAny(cs); <line49> } catch (InterruptedException ignored) { <line50> Thread.currentThread().interrupt(); <line51> } catch (ExecutionException e) { <line52> Thread.currentThread().interrupt(); <line53> } <line54> return g; <line55> } <line56> } <line57> "	<line21>, <line26>, <line38>, <line43>, <line50>, <line52>
5391	public class A { <line0> public boolean isPublishKaleoDefinitionVersionButtonVisible( <line1> PermissionChecker permissionChecker, KaleoDefinitionVersion kaleoDefinitionVersion) { <line2> if (!canPublishWorkflowDefinition()) { <line3> return false; <line4> } <line5> if (kaleoDefinitionVersion != null) { <line6> try { <line7> return KaleoDefinitionVersionPermission.contains( <line8> permissionChecker, kaleoDefinitionVersion, ActionKeys.UPDATE); <line9> } catch (PortalException portalException) { <line10> if (_log.isDebugEnabled()) { <line11> } <line12> } <line13> } <line14> return KaleoDesignerPermission.contains( <line15> permissionChecker, <line16> _themeDisplay.getCompanyGroupId(), <line17> KaleoDesignerActionKeys.ADD_NEW_WORKFLOW); <line18> } <line19> } <line20> 	<line11>
5392	"public class A { <line0> @Override <line1> public int read(final ByteBuffer dst) throws IOException { <line2> try { <line3> final String stringValue = getConvertedPropertyValue(securityContext, graphObject, key); <line4> final byte[] bytes = stringValue.getBytes(Charset.forName(""utf-8"")); <line5> dst.put(bytes); <line6> return bytes.length; <line7> } catch (FrameworkException fex) { <line8> } <line9> return 0; <line10> } <line11> } <line12> "	<line8>
5393	"public class A { <line0> @Test <line1> public void testMovingTarget() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> Map<String, Object> properties = <line5> new LinkedHashMap<String, Object>() { <line6> { <line7> put(""username"", ""edanuff""); <line8> put(""email"", ""ed@anuff.com""); <line9> put( <line10> ""location"", <line11> new LinkedHashMap<String, Object>() { <line12> { <line13> put(""latitude"", 37.776753); <line14> put(""longitude"", -122.407846); <line15> } <line16> }); <line17> } <line18> }; <line19> Entity user = em.create(""user"", properties); <line20> assertNotNull(user); <line21> app.waitForQueueDrainAndRefreshIndex(); <line22> final double lat = 37.776753; <line23> final double lon = -122.407846; <line24> Query query = Query.fromQL(""select * where location within 100 of "" + lat + "","" + lon); <line25> Results listResults = em.searchCollection(em.getApplicationRef(), ""users"", query); <line26> assertEquals(1, listResults.size()); <line27> updatePos(em, user, 37.428526, -122.140916); <line28> listResults = em.searchCollection(em.getApplicationRef(), ""users"", query); <line29> assertEquals(0, listResults.size()); <line30> em.delete(user); <line31> } <line32> } <line33> "	<line2>
5394	public class A { <line0> @Override <line1> public PersistableMap<String, String> loadProperties(Group group) { <line2> String name = group.getName(); <line3> PersistableMap<String, String> result = new DefaultGroupPropertyMap<>(group); <line4> Connection con = null; <line5> PreparedStatement pstmt = null; <line6> ResultSet rs = null; <line7> try { <line8> con = DbConnectionManager.getConnection(); <line9> pstmt = con.prepareStatement(LOAD_PROPERTIES); <line10> pstmt.setString(1, name); <line11> rs = pstmt.executeQuery(); <line12> while (rs.next()) { <line13> String key = rs.getString(1); <line14> String value = rs.getString(2); <line15> if (key != null) { <line16> if (value == null) { <line17> result.remove(key); <line18> } else { <line19> result.put(key, value, false); <line20> } <line21> } else { <line22> } <line23> } <line24> } catch (SQLException sqle) { <line25> } finally { <line26> DbConnectionManager.closeConnection(rs, pstmt, con); <line27> } <line28> return result; <line29> } <line30> } <line31> 	<line18>, <line22>, <line25>
5395	"public class A { <line0> @Override <line1> public void run() { <line2> int count = 0; <line3> long start = System.currentTimeMillis(); <line4> running = true; <line5> while (running) { <line6> if (!enabled) { <line7> try { <line8> Thread.sleep(10); <line9> } catch (InterruptedException e) { <line10> } <line11> continue; <line12> } <line13> if (lastImage != null) { <line14> try { <line15> count++; <line16> lastResult = dl4j.classifyImageMiniEXCEPTION(lastImage, confidence); <line17> if (count % 100 == 0) { <line18> double rate = 1000.0 * count / (System.currentTimeMillis() - start); <line19> } <line20> invoke(""publishClassification"", lastResult); <line21> } catch (IOException e) { <line22> } <line23> lastImage = null; <line24> } else { <line25> } <line26> try { <line27> Thread.sleep(1); <line28> } catch (InterruptedException e) { <line29> e.printStackTrace(); <line30> } <line31> } <line32> } <line33> } <line34> "	<line4>, <line10>, <line19>, <line21>, <line22>
5396	public class A { <line0> public void handle(PortletContainerException e) { <line1> } <line2> } <line3> 	<line1>
5397	public class A { <line0> @Override <line1> protected void decode( <line2> final ChannelHandlerContext context, final ByteBuf in, final List<Object> out) { <line3> if (RntbdFramer.canDecodeHead(in)) { <line4> final RntbdResponse response = RntbdResponse.decode(in); <line5> if (response != null) { <line6> in.discardReadBytes(); <line7> out.add(response.retain()); <line8> } <line9> } <line10> } <line11> } <line12> 	<line6>
5398	public class A { <line0> @Test <line1> public void retrievePutConcurrent() throws Exception { <line2> final File f = createFile(0, loader, cache, folder); <line3> File f2 = copyToFile(randomStream(1, 4 * 1024), folder.newFile()); <line4> ListeningExecutorService executorService = <line5> MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(2)); <line6> closer.register(new ExecutorCloser(executorService, 5, TimeUnit.MILLISECONDS)); <line7> CountDownLatch thread1Start = new CountDownLatch(1); <line8> SettableFuture<File> future1 = <line9> retrieveThread(executorService, ID_PREFIX + 0, cache, thread1Start); <line10> CountDownLatch thread2Start = new CountDownLatch(1); <line11> SettableFuture<Boolean> future2 = putThread(executorService, 1, f2, cache, thread2Start); <line12> thread1Start.countDown(); <line13> thread2Start.countDown(); <line14> future1.get(); <line15> future2.get(); <line16> assertCacheIfPresent(0, cache, f); <line17> assertCacheIfPresent(1, cache, copyToFile(randomStream(1, 4 * 1024), folder.newFile())); <line18> assertCacheStats(cache, 2, 8 * 1024, 1, 1); <line19> } <line20> } <line21> 	<line2>, <line16>, <line19>
5399	public class A { <line0> @Override <line1> public boolean initMethod(final PluginAnnotation<T> pluginAnnotation) { <line2> ClassLoader classLoader = <line3> pluginManager.getPluginRegistry().getAppClassLoader(pluginAnnotation.getPlugin()); <line4> try { <line5> registerResources(pluginAnnotation, classLoader); <line6> } catch (IOException e) { <line7> return false; <line8> } <line9> return true; <line10> } <line11> } <line12> 	<line2>, <line7>
5400	"public class A { <line0> @Override <line1> public List<CatalogEntity> getCatalogs() { <line2> try { <line3> return catalogsCache.get( <line4> """", <line5> () -> { <line6> return delegate.getCatalogs(); <line7> }); <line8> } catch (ExecutionException executionException) { <line9> return delegate.getCatalogs(); <line10> } <line11> } <line12> } <line13> "	<line9>
5401	"public class A { <line0> protected String getPosterImageFileUrl(String posterimageUrlOpt) { <line1> if (StringUtils.isBlank(posterimageUrlOpt)) { <line2> return null; <line3> } <line4> URL url = null; <line5> try { <line6> url = new URL(posterimageUrlOpt); <line7> } catch (Exception e) { <line8> } <line9> if (url == null) { <line10> return null; <line11> } <line12> if (""file"".equals(url.getProtocol())) { <line13> return url.toExternalForm(); <line14> } <line15> try { <line16> File coverImageFile = getWorkspace().get(url.toURI()); <line17> return coverImageFile.getPath(); <line18> } catch (NotFoundException e) { <line19> return null; <line20> } catch (IOException e) { <line21> return null; <line22> } catch (URISyntaxException e) { <line23> return null; <line24> } <line25> } <line26> } <line27> "	<line8>, <line19>, <line21>, <line23>
5402	"public class A { <line0> public static int getPendingCommerceOrdersCount( <line1> HttpPrincipal httpPrincipal, long groupId, long commerceAccountId, String keywords) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceOrderServiceUtil.class, <line7> ""getPendingCommerceOrdersCount"", <line8> _getPendingCommerceOrdersCountParameterTypes21); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, groupId, commerceAccountId, keywords); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return ((Integer) returnObj).intValue(); <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line22>
5403	"public class A { <line0> @Override <line1> protected void doProcessAction(ActionRequest actionRequest, ActionResponse actionResponse) <line2> throws Exception { <line3> try { <line4> long layoutPrototypeId = ParamUtil.getLong(actionRequest, ""layoutPrototypeId""); <line5> Map<Locale, String> nameMap = <line6> HashMapBuilder.put(actionRequest.getLocale(), ParamUtil.getString(actionRequest, ""name"")) <line7> .build(); <line8> ServiceContext serviceContext = <line9> ServiceContextFactory.getInstance(LayoutPrototype.class.getName(), actionRequest); <line10> _layoutPrototypeService.updateLayoutPrototype( <line11> layoutPrototypeId, nameMap, new HashMap<>(), true, serviceContext); <line12> String redirect = ParamUtil.getString(actionRequest, ""redirect""); <line13> JSONPortletResponseUtil.writeJSON( <line14> actionRequest, actionResponse, JSONUtil.put(""redirectURL"", redirect)); <line15> } catch (Throwable throwable) { <line16> if (_log.isDebugEnabled()) { <line17> } <line18> if (throwable instanceof LayoutPageTemplateEntryNameException) { <line19> LayoutPageTemplateEntryNameException layoutPageTemplateEntryNameException = <line20> (LayoutPageTemplateEntryNameException) throwable; <line21> _layoutPageTemplateEntryExceptionRequestHandler.handlePortalException( <line22> actionRequest, actionResponse, layoutPageTemplateEntryNameException); <line23> } else { <line24> ThemeDisplay themeDisplay = <line25> (ThemeDisplay) actionRequest.getAttribute(WebKeys.THEME_DISPLAY); <line26> JSONPortletResponseUtil.writeJSON( <line27> actionRequest, <line28> actionResponse, <line29> JSONUtil.put( <line30> ""error"", <line31> LanguageUtil.get(themeDisplay.getRequest(), ""an-unexpected-error-occurred""))); <line32> } <line33> } <line34> } <line35> } <line36> "	<line17>
5404	public class A { <line0> @Override <line1> public boolean hasTgpp2MEID() { <line2> Avp terminalInfoAvp = super.message.getAvps().getAvp(Avp.TERMINAL_INFORMATION); <line3> if (terminalInfoAvp != null) { <line4> try { <line5> return terminalInfoAvp.getGrouped().getAvp(Avp.TGPP2_MEID) != null; <line6> } catch (AvpDataException ex) { <line7> } <line8> } <line9> return false; <line10> } <line11> } <line12> 	<line7>
5405	"public class A { <line0> private Class<?> createLinkToInterface(final Class<?> controller, String interfaceName) { <line1> try { <line2> return Class.forName(interfaceName); <line3> } catch (ClassNotFoundException e1) { <line4> } <line5> final Set<CtMethod> used = new HashSet<>(); <line6> ClassPool pool = ClassPool.getDefault(); <line7> CtClass inter = pool.makeInterface(interfaceName); <line8> try { <line9> CtClass returnType = pool.get(String.class.getName()); <line10> CtClass objectType = pool.get(Object.class.getName()); <line11> for (Method m : getMethods(controller)) { <line12> String name = m.getName(); <line13> CtClass[] params = createParameters(objectType, m.getParameterTypes().length); <line14> CtClass[] empty = new CtClass[0]; <line15> for (int length = params.length; length >= 0; length--) { <line16> CtMethod method = <line17> abstractMethod(returnType, m.getName(), Arrays.copyOf(params, length), empty, inter); <line18> if (used.add(method)) { <line19> inter.addMethod(method); <line20> } <line21> } <line22> CtMethod getter = <line23> abstractMethod( <line24> returnType, String.format(""get%s"", capitalize(name)), empty, empty, inter); <line25> if (used.add(getter)) { <line26> inter.addMethod(getter); <line27> } <line28> } <line29> return inter.toClass(); <line30> } catch (CannotCompileException | NotFoundException e) { <line31> throw new ProxyCreationException(e); <line32> } <line33> } <line34> } <line35> "	<line4>, <line20>, <line27>
5406	public class A { <line0> private String getConfigAttributeValue(Element element, String attributeName) { <line1> String value = null; <line2> if (element != null && attributeName != null) { <line3> final String property = getAttributeSystemPropertyName(element, attributeName); <line4> value = System.getProperty(property); <line5> if (value != null) { <line6> } else { <line7> value = element.getAttribute(attributeName); <line8> } <line9> } <line10> return (value); <line11> } <line12> } <line13> 	<line6>
5407	public class A { <line0> @Override <line1> public void synchronize() throws PortalException { <line2> if (_log.isDebugEnabled()) { <line3> } <line4> updateFolders(); <line5> String key = AccountLock.getKey(user.getUserId(), account.getAccountId()); <line6> if (AccountLock.acquireLock(key)) { <line7> List<Folder> folders = FolderLocalServiceUtil.getFolders(account.getAccountId()); <line8> try { <line9> for (Folder folder : folders) { <line10> _imapAccessor.storeEnvelopes(folder.getFolderId(), true); <line11> } <line12> } finally { <line13> AccountLock.releaseLock(key); <line14> } <line15> } <line16> } <line17> } <line18> 	<line3>
5408	"public class A { <line0> private ReportResult generateReport(Path userCsvFolder, Profile profile, DashBoard dash, long now) <line1> throws Exception { <line2> int fetchCount = (int) report.reportType.getFetchCount(report.granularityType); <line3> long startFrom = now - TimeUnit.DAYS.toMillis(report.reportType.getDuration()); <line4> startFrom = (startFrom / report.granularityType.period) * report.granularityType.period; <line5> Path output = Paths.get(userCsvFolder.toString() + "".zip""); <line6> boolean hasData = generateReport(output, profile, dash, fetchCount, startFrom); <line7> if (hasData) { <line8> sendEmail(output); <line9> return ReportResult.OK; <line10> } <line11> return ReportResult.NO_DATA; <line12> } <line13> } <line14> "	<line11>
5409	"public class A { <line0> public static boolean copyDirectory(File source, File destination, boolean copySubDirectories) { <line1> if (source == null || destination == null) { <line2> throw new IllegalArgumentException(""The source and destination directories can not be null.""); <line3> } <line4> if (source.isFile()) { <line5> try { <line6> return FileUtilities.copyfile(source, destination); <line7> } catch (final IOException e) { <line8> } <line9> } <line10> if (!createDirectories(destination)) { <line11> return false; <line12> } <line13> final File[] fileList = source.listFiles(); <line14> if (fileList == null) { <line15> return true; <line16> } <line17> boolean result = true; <line18> for (final File child : fileList) { <line19> if (child != null && child.isDirectory()) { <line20> if (copySubDirectories) { <line21> final File destDir = new File(destination, child.getName()); <line22> copyDirectory(child, destDir, copySubDirectories); <line23> } <line24> } else if (child != null) { <line25> try { <line26> final File destFile = new File(destination, child.getName()); <line27> result &= FileUtilities.copyfile(child, destFile); <line28> } catch (final IOException e) { <line29> } <line30> } <line31> } <line32> return result; <line33> } <line34> } <line35> "	<line8>, <line11>, <line29>
5410	"public class A { <line0> private synchronized void log(String when, String eventCode, String message, Throwable t) { <line1> long logTime = System.currentTimeMillis(); <line2> try { <line3> StringBuilder sb = new StringBuilder(); <line4> appendToLine(sb, Long.toString(context.getEvaluationId())); <line5> appendToLine(sb, DateUtil.formatDate(new Date(logTime), ""yyyy-MM-dd HH:mm:ss.S"")); <line6> appendToLine(sb, StringUtils.repeat("">"", context.getEvaluationLevel())); <line7> appendToLine(sb, when); <line8> appendToLine(sb, eventCode); <line9> if (AFTER.equals(when)) { <line10> appendToLine(sb, DateUtil.getTimeElapsed(logTime - lastStartTime)); <line11> appendToLine(sb, DateUtil.getTimeElapsed(logTime - overallStartTime)); <line12> } else { <line13> if (BEFORE.equals(when)) { <line14> lastStartTime = logTime; <line15> } <line16> appendToLine(sb, """"); <line17> appendToLine(sb, """"); <line18> } <line19> sb.append(message); <line20> if (ERROR.equals(when) && log.isErrorEnabled()) { <line21> } else if (log.isTraceEnabled()) { <line22> } <line23> if (ReportingConstants.GLOBAL_PROPERTY_EVALUATION_LOGGER_ENABLED()) { <line24> PrintWriter out = null; <line25> try { <line26> out = new PrintWriter(new BufferedWriter(new FileWriter(logFile, true))); <line27> out.println(sb.toString()); <line28> } catch (Exception e) { <line29> } finally { <line30> IOUtils.closeQuietly(out); <line31> } <line32> } <line33> } catch (Exception e) { <line34> } <line35> } <line36> } <line37> "	<line21>, <line22>, <line29>, <line34>
5411	"public class A { <line0> private static String[] expandFileNames(String fileName) throws IOException { <line1> if (fileName.matches(""^[a-zA-Z]+:.*"")) { <line2> return new String[] {fileName}; <line3> } <line4> if (fileName.startsWith(""~"" + File.separator)) { <line5> fileName = System.getProperty(""user.home"") + fileName.substring(1); <line6> } <line7> fileName = new File(fileName).getCanonicalPath(); <line8> DirectoryScanner scanner = new DirectoryScanner(); <line9> scanner.setIncludes(new String[] {fileName}); <line10> scanner.scan(); <line11> return scanner.getIncludedFiles(); <line12> } <line13> } <line14> "	<line8>
5412	public class A { <line0> public void action(KrbSafeContainer krbSafeContainer) throws DecoderException { <line1> TLV tlv = krbSafeContainer.getCurrentTLV(); <line2> if (tlv.getLength() == 0) { <line3> throw new DecoderException(I18n.err(I18n.ERR_01309_EMPTY_TLV)); <line4> } <line5> KrbSafe krbSafe = new KrbSafe(); <line6> krbSafeContainer.setKrbSafe(krbSafe); <line7> if (IS_DEBUG) { <line8> } <line9> } <line10> } <line11> 	<line3>, <line8>
5413	"public class A { <line0> @Test <line1> public void test() throws Exception { <line2> LocalMode lma = LocalMode.newInstance(); <line3> StreamingApplication app = <line4> new StreamingApplication() { <line5> @Override <line6> public void populateDAG(DAG dag, Configuration conf) {} <line7> }; <line8> DAG dag = lma.getDAG(); <line9> MyGenerator generator = dag.addOperator(OPERATOR.GENERATOR.name(), MyGenerator.class); <line10> generator.setTupleNum(TUPLE_NUM); <line11> hbaseOutputOperator = dag.addOperator(OPERATOR.HBASEOUTPUT.name(), hbaseOutputOperator); <line12> hbaseInputOperator = dag.addOperator(OPERATOR.HBASEINPUT.name(), hbaseInputOperator); <line13> dag.setOutputPortAttribute( <line14> hbaseInputOperator.outputPort, Context.PortContext.TUPLE_CLASS, TestPOJO.class); <line15> TupleCacheOutputOperator output = <line16> dag.addOperator(OPERATOR.OUTPUT.name(), TupleCacheOutputOperator.class); <line17> dag.addStream(""queue1"", generator.outputPort, hbaseOutputOperator.input) <line18> .setLocality(DAG.Locality.NODE_LOCAL); <line19> dag.addStream(""queue2"", hbaseInputOperator.outputPort, output.inputPort) <line20> .setLocality(DAG.Locality.NODE_LOCAL); <line21> Configuration conf = new Configuration(false); <line22> lma.prepareDAG(app, conf); <line23> final LocalMode.Controller lc = lma.getController(); <line24> lc.runAsync(); <line25> long start = System.currentTimeMillis(); <line26> while (true) { <line27> Thread.sleep(1000); <line28> if (output.getReceivedTuples() != null && output.getReceivedTuples().size() == TUPLE_NUM) { <line29> break; <line30> } <line31> if (System.currentTimeMillis() - start > RUN_DURATION) { <line32> throw new RuntimeException(""Testcase taking too long""); <line33> } <line34> } <line35> lc.shutdown(); <line36> validate(generator.getTuples(), output.getReceivedTuples()); <line37> } <line38> } <line39> "	<line28>
5414	"public class A { <line0> public void testOrFilter2() throws Exception { <line1> String req = <line2> ""{\""filter\"":{\""or\"":[{\""term\"":{\""color\"":\""blue\"",\""_noOptimize\"":false}},{\""term\"":{\""color\"":\""red\"",\""_noOptimize\"":false}}]}}""; <line3> JSONObject res = search(new JSONObject(req)); <line4> assertEquals(""numhits is wrong"", 3264, res.getInt(""numhits"")); <line5> } <line6> } <line7> "	<line1>
5415	public class A { <line0> public void setAuthenticationEndAndSessionReauthenticationTimes(long nowNanos) { <line1> authenticationEndNanos = nowNanos; <line2> long sessionLifetimeMsToUse = 0; <line3> if (positiveSessionLifetimeMs != null) { <line4> double pctWindowFactorToTakeNetworkLatencyAndClockDriftIntoAccount = 0.85; <line5> double pctWindowJitterToAvoidReauthenticationStormAcrossManyChannelsSimultaneously = 0.10; <line6> double pctToUse = <line7> pctWindowFactorToTakeNetworkLatencyAndClockDriftIntoAccount <line8> + RNG.nextDouble() <line9> * pctWindowJitterToAvoidReauthenticationStormAcrossManyChannelsSimultaneously; <line10> sessionLifetimeMsToUse = (long) (positiveSessionLifetimeMs * pctToUse); <line11> clientSessionReauthenticationTimeNanos = <line12> authenticationEndNanos + 1000 * 1000 * sessionLifetimeMsToUse; <line13> } else <line14> } <line15> } <line16> 	<line13>, <line14>
5416	"public class A { <line0> @Override <line1> public void rip() throws IOException { <line2> Document doc = Http.url(url).get(); <line3> Element iframe = doc.select(""iframe"").first(); <line4> String iframeSrc = iframe.attr(""src""); <line5> if (iframeSrc != null) { <line6> doc = Http.url(""http://www.yuvutu.com"" + iframeSrc).get(); <line7> } else { <line8> throw new IOException(""Could not find iframe code at "" + url); <line9> } <line10> Elements script = doc.select(""script""); <line11> if (script.isEmpty()) { <line12> throw new IOException(""Could not find script code at "" + url); <line13> } <line14> Pattern p = Pattern.compile(""file: \""(.*?)\""""); <line15> for (Element element : script) { <line16> Matcher m = p.matcher(element.data()); <line17> if (m.find()) { <line18> String vidUrl = m.group(1); <line19> addURLToDownload(new URL(vidUrl), HOST + ""_"" + getGID(this.url)); <line20> } <line21> } <line22> waitForThreads(); <line23> } <line24> } <line25> "	<line2>
5417	public class A { <line0> static Map<Object, Integer> parseHotItems(List<ParamFlowItem> items) { <line1> if (items == null || items.isEmpty()) { <line2> return new HashMap<>(); <line3> } <line4> Map<Object, Integer> itemMap = new HashMap<>(items.size()); <line5> for (ParamFlowItem item : items) { <line6> Object value; <line7> try { <line8> value = parseItemValue(item.getObject(), item.getClassType()); <line9> } catch (Exception ex) { <line10> continue; <line11> } <line12> if (item.getCount() == null || item.getCount() < 0 || value == null) { <line13> continue; <line14> } <line15> itemMap.put(value, item.getCount()); <line16> } <line17> return itemMap; <line18> } <line19> } <line20> 	<line10>, <line13>
5418	public class A { <line0> public boolean addCacheRegion(String region, Properties cacheProperties) { <line1> boolean returnValue = false; <line2> if (cacheEnabled) { <line3> if (!cacheEnabled(region)) { <line4> Cache cache = buildCache(region, cacheProperties); <line5> if (cache == null) { <line6> } else { <line7> regionCache.put(region, cache); <line8> returnValue = true; <line9> } <line10> } else { <line11> } <line12> } else { <line13> } <line14> return returnValue; <line15> } <line16> } <line17> 	<line6>, <line11>, <line13>
5419	"public class A { <line0> @Override <line1> public void addIP(LogicalDevice logicalDevice, IPProtocolEndpoint ip) throws CapabilityException { <line2> if ((ip.getIPv4Address() != null) <line3> && (ip.getSubnetMask() != null) <line4> && !(ip.getIPv4Address().isEmpty()) <line5> && !(ip.getSubnetMask().isEmpty())) addIPv4(logicalDevice, ip); <line6> else if (ip.getIPv6Address() != null && !ip.getIPv6Address().isEmpty()) <line7> addIPv6(logicalDevice, ip); <line8> else throw new CapabilityException(""IP address not set.""); <line9> } <line10> } <line11> "	<line2>, <line9>
5420	"public class A { <line0> protected boolean skip() { <line1> List<CompilationUnit> cUnits = tcCtx.getTestCase().getCompilationUnit(); <line2> for (CompilationUnit cUnit : cUnits) { <line3> List<TestFileContext> testFileCtxs = tcCtx.getTestFiles(cUnit); <line4> for (TestFileContext ctx : testFileCtxs) { <line5> if (ctx.getType().equals(EXTERNAL_LIBRARY_TEST_GROUP)) { <line6> return true; <line7> } <line8> } <line9> } <line10> for (TestGroup group : tcCtx.getTestGroups()) { <line11> if (group != null && ""api"".equals(group.getName())) { <line12> return true; <line13> } <line14> } <line15> return false; <line16> } <line17> } <line18> "	<line12>
5421	public class A { <line0> @Override <line1> public void dataGroupsChanged() { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> rebuildTree(); <line5> } <line6> } <line7> 	<line3>
5422	public class A { <line0> public void shutdown(final long txnId, final boolean checkpoint) { <line1> if (!initialised) { <line2> return; <line3> } <line4> if (currentBuffer == null) { <line5> return; <line6> } <line7> if (!BrokerPool.FORCE_CORRUPTION) { <line8> if (checkpoint) { <line9> try { <line10> writeToLog(new Checkpoint(txnId)); <line11> } catch (final JournalException e) { <line12> } <line13> } <line14> flushBuffer(); <line15> } <line16> try { <line17> channel.close(); <line18> } catch (final IOException e) { <line19> } <line20> channel = null; <line21> fileLock.release(); <line22> currentBuffer = null; <line23> } <line24> } <line25> 	<line9>, <line12>, <line19>
5423	"public class A { <line0> private void initCompletedTasks() { <line1> File completedTaskDir = getCompletedTaskDir(); <line2> completedTaskDir.mkdirs(); <line3> if (!completedTaskDir.isDirectory()) { <line4> throw new ISE(""Completed Tasks Dir [%s] does not exist/not-a-directory."", completedTaskDir); <line5> } <line6> for (File taskFile : completedTaskDir.listFiles()) { <line7> try { <line8> String taskId = taskFile.getName(); <line9> TaskAnnouncement taskAnnouncement = jsonMapper.readValue(taskFile, TaskAnnouncement.class); <line10> if (taskId.equals(taskAnnouncement.getTaskId())) { <line11> completedTasks.put(taskId, taskAnnouncement); <line12> } else { <line13> throw new ISE(""Corrupted completed task on disk[%s]."", taskFile.getAbsoluteFile()); <line14> } <line15> } catch (IOException ex) { <line16> } <line17> } <line18> if (!completedTasks.isEmpty()) { <line19> } <line20> } <line21> } <line22> "	<line2>, <line16>, <line19>
5424	public class A { <line0> private void checkNodes0(final int expCnt) throws Exception { <line1> boolean wait = <line2> GridTestUtils.waitForCondition( <line3> new GridAbsPredicate() { <line4> @Override <line5> public boolean apply() { <line6> try { <line7> checkNodes(expCnt); <line8> return true; <line9> } catch (AssertionError e) { <line10> } <line11> return false; <line12> } <line13> }, <line14> 10_000); <line15> if (!wait) checkNodes(expCnt); <line16> } <line17> } <line18> 	<line10>
5425	"public class A { <line0> public static void deleteFileEntry(HttpPrincipal httpPrincipal, long fileEntryId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> DLFileEntryServiceUtil.class, ""deleteFileEntry"", _deleteFileEntryParameterTypes8); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, fileEntryId); <line7> try { <line8> TunnelUtil.invoke(httpPrincipal, methodHandler); <line9> } catch (Exception exception) { <line10> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line11> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line12> } <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	<line16>
5426	public class A { <line0> @Test <line1> public void testClientService() throws Exception { <line2> UUID clientNodeId = grid(CLIENT_IDX).cluster().localNode().id(); <line3> for (int i = 0; i < NODES_CNT; i++) { <line4> final Ignite ignite = grid(i); <line5> ignite <line6> .services(ignite.cluster().forClients()) <line7> .deployNodeSingleton(SINGLETON_NAME, new TestService()); <line8> final ClusterGroup grp = ignite.cluster(); <line9> assertEquals(NODES_CNT, grp.nodes().size()); <line10> GridTestUtils.waitForCondition( <line11> new GridAbsPredicate() { <line12> @Override <line13> public boolean apply() { <line14> return ignite.services(grp).serviceDescriptors().size() == 1; <line15> } <line16> }, <line17> 5000); <line18> Collection<ServiceDescriptor> srvDscs = ignite.services(grp).serviceDescriptors(); <line19> assertEquals(1, srvDscs.size()); <line20> Map<UUID, Integer> nodesMap = F.first(srvDscs).topologySnapshot(); <line21> assertEquals(1, nodesMap.size()); <line22> for (Map.Entry<UUID, Integer> nodeInfo : nodesMap.entrySet()) { <line23> assertEquals(clientNodeId, nodeInfo.getKey()); <line24> assertEquals(1, nodeInfo.getValue().intValue()); <line25> } <line26> ignite.services().cancelAll(); <line27> } <line28> } <line29> } <line30> 	<line4>
5427	public class A { <line0> @Override <line1> public void stop() { <line2> try { <line3> server.stop(); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	<line5>
5428	public class A { <line0> public static List<CoordinatorAction> getProcessInstanceListFromAllBundles( <line1> OozieClient oozieClient, String processName, EntityType entityType) <line2> throws OozieClientException { <line3> List<CoordinatorAction> list = new ArrayList<>(); <line4> final List<String> bundleIds = OozieUtil.getBundles(oozieClient, processName, entityType); <line5> for (String bundleId : bundleIds) { <line6> BundleJob bundleInfo = oozieClient.getBundleJobInfo(bundleId); <line7> List<CoordinatorJob> coordJobs = bundleInfo.getCoordinators(); <line8> for (CoordinatorJob coordJob : coordJobs) { <line9> List<CoordinatorAction> actions = <line10> oozieClient.getCoordJobInfo(coordJob.getId()).getActions(); <line11> list.addAll(actions); <line12> } <line13> } <line14> String coordId = OozieUtil.getLatestCoordinatorID(oozieClient, processName, entityType); <line15> return list; <line16> } <line17> } <line18> 	<line5>, <line8>, <line11>, <line15>
5429	public class A { <line0> @Override <line1> public Option<String> apply(InputStream is) { <line2> try { <line3> return some(IOUtils.toString(is)); <line4> } catch (Exception e) { <line5> return none(); <line6> } <line7> } <line8> } <line9> 	<line5>
5430	public class A { <line0> private STypeIR getFieldType( <line1> IRInfo info, String fieldName, String fieldModule, SObjectDesignatorIR obj) { <line2> if (fieldModule != null) { <line3> return info.getTypeAssistant().getFieldType(info.getClasses(), fieldModule, fieldName); <line4> } else { <line5> try { <line6> ObjectDesignatorToExpIR converter = new ObjectDesignatorToExpIR(info); <line7> SExpIR objExp = obj.apply(converter); <line8> if (objExp.getType() instanceof ARecordTypeIR) { <line9> STypeIR fieldExpType = <line10> info.getTypeAssistant() <line11> .getFieldType(info.getClasses(), (ARecordTypeIR) objExp.getType(), fieldName); <line12> if (fieldExpType == null) { <line13> } <line14> return fieldExpType; <line15> } <line16> } catch (org.overture.codegen.ir.analysis.AnalysisException e) { <line17> } <line18> } <line19> return new AUnknownTypeIR(); <line20> } <line21> } <line22> 	<line13>, <line19>
5431	"public class A { <line0> private FolderAndFile handle( <line1> final Path root, final Path relativePath, final Path path, final boolean create) <line2> throws FrameworkException { <line3> final PropertyKey<String> mountTargetKey = StructrApp.key(Folder.class, ""mountTarget""); <line4> final Folder folder = <line5> StructrApp.getInstance() <line6> .nodeQuery(Folder.class) <line7> .and(mountTargetKey, root.toString()) <line8> .getFirst(); <line9> if (folder != null) { <line10> Class<? extends File> targetFileType = null; <line11> Class<? extends Folder> targetFolderType = null; <line12> try { <line13> if (folder.getMountTargetFileType() != null) { <line14> final Class clazz = <line15> StructrApp.getConfiguration().getNodeEntityClass(folder.getMountTargetFileType()); <line16> if (clazz != null && clazz != GenericNode.class && File.class.isAssignableFrom(clazz)) { <line17> targetFileType = clazz; <line18> } <line19> } <line20> if (folder.getMountTargetFolderType() != null) { <line21> final Class clazz = <line22> StructrApp.getConfiguration().getNodeEntityClass(folder.getMountTargetFolderType()); <line23> if (clazz != null && clazz != GenericNode.class && Folder.class.isAssignableFrom(clazz)) { <line24> targetFolderType = clazz; <line25> } <line26> } <line27> } catch (ClassCastException ex) { <line28> } <line29> final String mountFolderPath = folder.getProperty(StructrApp.key(Folder.class, ""path"")); <line30> if (mountFolderPath != null) { <line31> final Path relativePathParent = relativePath.getParent(); <line32> if (relativePathParent == null) { <line33> return new FolderAndFile( <line34> folder, <line35> getOrCreate(folder, path, relativePath, create, targetFolderType, targetFileType)); <line36> } else { <line37> final String pathRelativeToRoot = folder.getPath() + ""/"" + relativePathParent.toString(); <line38> final Folder parentFolder = <line39> FileHelper.createFolderPath( <line40> SecurityContext.getSuperUserInstance(), pathRelativeToRoot); <line41> final AbstractFile file = <line42> getOrCreate( <line43> parentFolder, path, relativePath, create, targetFolderType, targetFileType); <line44> return new FolderAndFile(folder, file); <line45> } <line46> } else { <line47> } <line48> } <line49> return null; <line50> } <line51> } <line52> "	<line28>, <line47>
5432	public class A { <line0> public void process(WatchedEvent event) { <line1> if (!closed) { <line2> try { <line3> if (event.getType() != EventType.NodeDeleted) { <line4> Stat s = zooKeeper.exists(nodePath, this); <line5> if (s != null) { <line6> zookeeper.getChildren(nodePath, this); <line7> } <line8> } <line9> } catch (Exception e) { <line10> LoggerFactory.getLogger() <line11> } <line12> nodeListener.processEvent(event.getPath(), event.getType().name(), null); <line13> } <line14> } <line15> } <line16> 	<line11>
5433	"public class A { <line0> private Publisher getOrCreatePublisher(String topic) { <line1> if (publisherMap.containsKey(topic)) { <line2> return publisherMap.get(topic); <line3> } else { <line4> try { <line5> admin.createTopicIfNotExists(topic); <line6> ProjectTopicName topicName = ProjectTopicName.of(pubSubSettings.getProjectId(), topic); <line7> Publisher publisher = <line8> Publisher.newBuilder(topicName) <line9> .setCredentialsProvider(pubSubSettings.getCredentialsProvider()) <line10> .build(); <line11> publisherMap.put(topic, publisher); <line12> return publisher; <line13> } catch (IOException e) { <line14> throw new RuntimeException(""Failed to create Publisher for the topic."", e); <line15> } <line16> } <line17> } <line18> } <line19> "	<line14>
5434	public class A { <line0> @Override <line1> public void start() { <line2> try { <line3> if (configuration.isUseJTA()) { <line4> jtaTransactionLifecycleService.registerListener( <line5> new IDMTransactionSyncListener(idmService_)); <line6> } <line7> acceptComponentRequestCall = true; <line8> RequestLifeCycle.begin(this); <line9> super.start(); <line10> } catch (Exception e) { <line11> } finally { <line12> RequestLifeCycle.end(); <line13> } <line14> } <line15> } <line16> 	<line11>
5435	public class A { <line0> @Override <line1> public void connectComplete(boolean reconnect, String serverURI) { <line2> if (reconnect) { <line3> if (config.isCleanSession() == true) { <line4> Iterator<Entry<String, Integer>> iterator = subscriptions.entrySet().iterator(); <line5> while (iterator.hasNext()) { <line6> Entry<String, Integer> pairs = iterator.next(); <line7> String topic = pairs.getKey(); <line8> Integer qos = pairs.getValue(); <line9> try { <line10> mqttAsyncClient.subscribe(topic, qos.intValue()); <line11> } catch (NumberFormatException | MqttException e1) { <line12> e1.printStackTrace(); <line13> } <line14> } <line15> } <line16> } <line17> } <line18> } <line19> 	<line3>, <line9>
5436	"public class A { <line0> @Ignore <line1> @Test(timeout = 90 * 1000) <line2> public void testPacketIdGeneratorCleanSession() throws Exception { <line3> final String[] cleanClientIds = new String[] {"""", ""clean-packetid"", null}; <line4> final Map<Short, PUBLISH> publishMap = new ConcurrentHashMap<>(); <line5> MQTT[] mqtts = new MQTT[cleanClientIds.length]; <line6> for (int i = 0; i < cleanClientIds.length; i++) { <line7> mqtts[i] = createMQTTConnection("""", true); <line8> mqtts[i].setKeepAlive((short) 15); <line9> mqtts[i].setTracer( <line10> new Tracer() { <line11> @Override <line12> public void onReceive(MQTTFrame frame) { <line13> if (frame.messageType() == PUBLISH.TYPE) { <line14> PUBLISH publish = new PUBLISH(); <line15> try { <line16> publish.decode(frame); <line17> } catch (ProtocolException e) { <line18> fail(""Error decoding publish "" + e.getMessage()); <line19> } <line20> if (publishMap.get(publish.messageId()) != null) { <line21> assertTrue(publish.dup()); <line22> } <line23> publishMap.put(publish.messageId(), publish); <line24> } <line25> } <line26>  <line27> @Override <line28> public void onSend(MQTTFrame frame) { <line29> } <line30> }); <line31> } <line32> final Random random = new Random(); <line33> for (short i = 0; i < 10; i++) { <line34> BlockingConnection connection = <line35> mqtts[random.nextInt(cleanClientIds.length)].blockingConnection(); <line36> connection.connect(); <line37> final String TOPIC = ""TopicA/""; <line38> connection.subscribe(new Topic[] {new Topic(TOPIC, QoS.EXACTLY_ONCE)}); <line39> connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false); <line40> Message msg = connection.receive(1000, TimeUnit.MILLISECONDS); <line41> assertNotNull(msg); <line42> assertEquals(TOPIC, new String(msg.getPayload())); <line43> msg.ack(); <line44> assertEquals(1, publishMap.size()); <line45> final short id = (short) (i + 1); <line46> assertNotNull(""No message for id "" + id, publishMap.get(id)); <line47> publishMap.clear(); <line48> connection.disconnect(); <line49> } <line50> } <line51> } <line52> "	<line13>, <line17>, <line29>
5437	public class A { <line0> private void shutdownGracefully() { <line1> if (Boolean.TRUE.equals(getAttribute(BrooklynNode.WEB_CONSOLE_ACCESSIBLE))) { <line2> queueShutdownTask(); <line3> queueWaitExitTask(); <line4> } else { <line5> } <line6> } <line7> } <line8> 	<line5>
5438	"public class A { <line0> private void _importPortletSettings(ServiceContext serviceContext) throws Exception { <line1> if (_log.isInfoEnabled()) { <line2> } <line3> Company company = _companyLocalService.getCompany(serviceContext.getCompanyId()); <line4> _portletSettingsImporter.importPortletSettings( <line5> _getJSONArray(""portlet-settings.json""), <line6> _siteInitializerDependencyResolver.getDisplayTemplatesClassLoader(), <line7> _siteInitializerDependencyResolver.getDisplayTemplatesDependencyPath(), <line8> serviceContext.getScopeGroupId(), <line9> company.getGroupId(), <line10> serviceContext.getUserId()); <line11> if (_log.isInfoEnabled()) { <line12> } <line13> } <line14> } <line15> "	<line2>, <line12>
5439	"public class A { <line0> public String[] optimize(String appModel, String suitableCloudOffer, String benchmarkPlatforms) { <line1> String[] outputPlans = new String[NUMBER_OF_PLANS_GENERATED]; <line2> outputPlans[0] = ""Plan generation was not possible""; <line3> if (previousPlans == null) { <line4> OptimizerInitialDeployment initialOptimizer = new OptimizerInitialDeployment(searchName); <line5> try { <line6> outputPlans = <line7> initialOptimizer.optimize( <line8> appModel, <line9> MMtoOptModelTransformer.transformModel(suitableCloudOffer), <line10> benchmarkPlatforms, <line11> NUMBER_OF_PLANS_GENERATED, <line12> HYSTERESIS_PROPORTION); <line13> previousPlans = outputPlans; <line14> } catch (Exception exc) { <line15> outputPlans = <line16> initialOptimizer.optimize( <line17> appModel, <line18> suitableCloudOffer, <line19> benchmarkPlatforms, <line20> NUMBER_OF_PLANS_GENERATED, <line21> HYSTERESIS_PROPORTION); <line22> previousPlans = outputPlans; <line23> } catch (Error E) { <line24> E.printStackTrace(); <line25> } <line26> } else { <line27> } <line28> return outputPlans; <line29> } <line30> } <line31> "	<line15>, <line24>
5440	public class A { <line0> public void method(String string) { <line1> } <line2> } <line3> 	<line1>
5441	public class A { <line0> @Override <line1> public void elementOpened(OpenAction action) { <line2> } <line3> } <line4> 	<line2>
5442	public class A { <line0> private void doAck(final ClientMessageInternal message) throws ActiveMQException { <line1> ackBytes = 0; <line2> lastAckedMessage = null; <line3> if (logger.isTraceEnabled()) { <line4> } <line5> session.acknowledge(this, message); <line6> } <line7> } <line8> 	<line4>
5443	public class A { <line0> @Override <line1> public InputStream getResourceAsStream(String name) { <line2> for (ClassLoader delegate : delegates) { <line3> InputStream is = delegate.getResourceAsStream(name); <line4> if (is != null) { <line5> return is; <line6> } <line7> if (log.isTraceEnabled()) { <line8> } <line9> } <line10> return null; <line11> } <line12> } <line13> 	<line8>
5444	public class A { <line0> public void setProxyRequests(String trueFalse) { <line1> this.proxyRequests = Boolean.parseBoolean(trueFalse); <line2> if (this.proxyRequests) { <line3> } else { <line4> } <line5> } <line6> } <line7> 	<line3>, <line4>
5445	public class A { <line0> private Sizeof getSizeof(Class<?> type, Type genericType) { <line1> Sizeof sizeof = sizeofByType.get(type); <line2> if (sizeof != null) { <line3> if (sizeof == SIZE_RECURSIVE_MARKER) { <line4> return Sizeof.constant(objectHeaderSize); <line5> } <line6> return sizeof; <line7> } <line8> try { <line9> sizeofByType.putIfAbsent(genericType, SIZE_RECURSIVE_MARKER); <line10> Sizeof newSizeof = computeSizeof(type, genericType); <line11> return sizeofByType.compute( <line12> genericType, <line13> (key, value) -> value == null || value == SIZE_RECURSIVE_MARKER ? newSizeof : value); <line14> } catch (Exception | StackOverflowError t) { <line15> return Sizeof.constant(objectHeaderSize); <line16> } <line17> } <line18> } <line19> 	<line15>
5446	public class A { <line0> private OrgDisambiguatedEntity createDisambiguatedOrg(RDFOrganization organization) { <line1> String orgType = getOrgType(organization); <line2> Iso3166Country country = <line3> StringUtils.isNotBlank(organization.country) <line4> ? Iso3166Country.fromValue(organization.country) <line5> : null; <line6> OrgDisambiguatedEntity orgDisambiguatedEntity = new OrgDisambiguatedEntity(); <line7> orgDisambiguatedEntity.setName(organization.name); <line8> orgDisambiguatedEntity.setCountry(country == null ? null : country.name()); <line9> orgDisambiguatedEntity.setCity(organization.city); <line10> orgDisambiguatedEntity.setRegion(organization.stateCode); <line11> orgDisambiguatedEntity.setOrgType(orgType); <line12> orgDisambiguatedEntity.setSourceId(organization.doi); <line13> orgDisambiguatedEntity.setSourceUrl(organization.doi); <line14> if (!PojoUtil.isEmpty(organization.status)) { <line15> orgDisambiguatedEntity.setStatus(OrganizationStatus.DEPRECATED.name()); <line16> } <line17> if (!PojoUtil.isEmpty(organization.isReplacedBy)) { <line18> orgDisambiguatedEntity.setSourceParentId(organization.isReplacedBy); <line19> orgDisambiguatedEntity.setStatus(OrganizationStatus.DEPRECATED.name()); <line20> } <line21> orgDisambiguatedEntity.setSourceType(OrgDisambiguatedSourceType.FUNDREF.name()); <line22> orgDisambiguatedManager.createOrgDisambiguated(orgDisambiguatedEntity); <line23> return orgDisambiguatedEntity; <line24> } <line25> } <line26> 	<line1>
5447	public class A { <line0> @Override <line1> public void addLongField(String fieldName, long value) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> fieldList.add(new JSONFieldHolder(fieldName, value, FieldType.LONG)); <line5> } <line6> } <line7> 	<line3>
5448	"public class A { <line0> public boolean lock(CairoSecurityContext securityContext, CharSequence tableName) { <line1> securityContext.checkWritePermission(); <line2> if (writerPool.lock(tableName)) { <line3> boolean locked = readerPool.lock(tableName); <line4> if (locked) { <line5> .$(""locked [table=`"") <line6> .$(tableName) <line7> .$(""`, thread="") <line8> .$(Thread.currentThread().getId()) <line9> .$(']') <line10> .$(); <line11> return true; <line12> } <line13> writerPool.unlock(tableName); <line14> } <line15> return false; <line16> } <line17> } <line18> "	<line5>
5449	public class A { <line0> private ClassLoader getPluginClassLoader() { <line1> Properties props = getEPDProperties(); <line2> String pathsValue = props.getProperty(CLASSPATH_PROPERTY); <line3> if (pathsValue == null || pathsValue.isEmpty()) { <line4> return null; <line5> } <line6> String[] pathNames = pathsValue.split(File.pathSeparator); <line7> List<URL> paths = new ArrayList<>(); <line8> for (String pathName : pathNames) { <line9> File pathElement = new File(pathName); <line10> if (!pathElement.isAbsolute()) { <line11> pathElement = getHomePath().resolve(pathName).toFile(); <line12> } <line13> if (!pathElement.exists()) { <line14> continue; <line15> } <line16> try { <line17> paths.add(pathElement.toURI().toURL()); <line18> } catch (MalformedURLException e) { <line19> } <line20> } <line21> return new URLClassLoader( <line22> paths.toArray(new URL[paths.size()]), PluginLoader.class.getClassLoader()); <line23> } <line24> } <line25> 	<line19>
5450	public class A { <line0> private void stopConnectionCheck() { <line1> if (connectionCheckTask != null) { <line2> connectionCheckTask.cancel(true); <line3> connectionCheckTask = null; <line4> } <line5> } <line6> } <line7> 	<line2>
5451	public class A { <line0> public Stats getStats(String cacheName) { <line1> try { <line2> Cache<Object, Object> cache = cacheManager.getCache(cacheName); <line3> if (cache.getCacheConfiguration().jmxStatistics().enabled()) { <line4> return cache.getAdvancedCache().getStats(); <line5> } else { <line6> return new UnavailableStats(-1); <line7> } <line8> } catch (Exception e) { <line9> return new UnavailableStats(-2); <line10> } <line11> } <line12> } <line13> 	<line1>, <line6>, <line9>
5452	"public class A { <line0> @Override <line1> public void process(Channel channel, Command command) { <line2> Preconditions.checkArgument( <line3> CommandType.TASK_EXECUTE_ACK == command.getType(), <line4> String.format(""invalid command type : %s"", command.getType())); <line5> TaskExecuteAckCommand taskAckCommand = <line6> JSONUtils.parseObject(command.getBody(), TaskExecuteAckCommand.class); <line7> taskInstanceCacheManager.cacheTaskInstance(taskAckCommand); <line8> String workerAddress = ChannelUtils.toAddress(channel).getAddress(); <line9> ExecutionStatus ackStatus = ExecutionStatus.of(taskAckCommand.getStatus()); <line10> TaskResponseEvent taskResponseEvent = <line11> TaskResponseEvent.newAck( <line12> ackStatus, <line13> taskAckCommand.getStartTime(), <line14> workerAddress, <line15> taskAckCommand.getExecutePath(), <line16> taskAckCommand.getLogPath(), <line17> taskAckCommand.getTaskInstanceId(), <line18> channel); <line19> taskResponseService.addResponse(taskResponseEvent); <line20> } <line21> } <line22> "	<line7>
5453	public class A { <line0> protected boolean recoverConnection(BackOffTimer.Task task) throws Exception { <line1> try { <line2> refreshConnection(); <line3> initConsumers(); <line4> return false; <line5> } catch (Exception e) { <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> return true; <line9> } <line10> } <line11> } <line12> 	<line1>, <line4>, <line7>
5454	"public class A { <line0> @Override <line1> public String exportAsLdif(@NonNull Account account) { <line2> ConnectionConfig connConfig = new ConnectionConfig(this.ldapUrl); <line3> connConfig.setConnectionInitializer( <line4> new BindConnectionInitializer(this.ldapUserName, new Credential(this.ldapPassword))); <line5> ConnectionFactory cf = new DefaultConnectionFactory(connConfig); <line6> SearchResult result; <line7> final String filter = String.format(""(uid=%s)"", account.getUid()); <line8> try { <line9> SearchExecutor executor = new SearchExecutor(); <line10> executor.setBaseDn(this.userSearchBaseDn); <line11> result = executor.search(cf, filter).getResult(); <line12> } catch (LdapException e) { <line13> throw new IllegalStateException(e); <line14> } <line15> StringWriter writer = new StringWriter(); <line16> try { <line17> new LdifWriter(writer).write(result); <line18> } catch (IOException e) { <line19> throw new IllegalStateException(e); <line20> } <line21> String ldifContents = writer.toString(); <line22> return ldifContents; <line23> } <line24> } <line25> "	<line2>, <line11>, <line12>, <line13>, <line19>, <line22>
5455	public class A { <line0> @Override <line1> public void initialize(InputSplit split, final TaskAttemptContext context) throws IOException { <line2> List<WindowedDataSegment> segments = ((DatasourceInputSplit) split).getSegments(); <line3> String dataSource = <line4> Iterators.getOnlyElement( <line5> segments.stream().map(s -> s.getSegment().getDataSource()).distinct().iterator()); <line6> spec = DatasourceInputFormat.getIngestionSpec(context.getConfiguration(), dataSource); <line7> List<WindowedStorageAdapter> adapters = <line8> Lists.transform( <line9> segments, <line10> new Function<WindowedDataSegment, WindowedStorageAdapter>() { <line11> @Override <line12> public WindowedStorageAdapter apply(WindowedDataSegment segment) { <line13> try { <line14> Path path = new Path(JobHelper.getURIFromSegment(segment.getSegment())); <line15> File dir = FileUtils.createTempDir(); <line16> tmpSegmentDirs.add(dir); <line17> JobHelper.unzipNoGuava(path, context.getConfiguration(), dir, context, null); <line18> QueryableIndex index = HadoopDruidIndexerConfig.INDEX_IO.loadIndex(dir); <line19> indexes.add(index); <line20> numRows += index.getNumRows(); <line21> return new WindowedStorageAdapter( <line22> new QueryableIndexStorageAdapter(index), segment.getInterval()); <line23> } catch (IOException ex) { <line24> throw new RuntimeException(ex); <line25> } <line26> } <line27> }); <line28> firehose = <line29> new IngestSegmentFirehose( <line30> adapters, <line31> spec.getTransformSpec(), <line32> spec.getDimensions(), <line33> spec.getMetrics(), <line34> spec.getFilter()); <line35> } <line36> } <line37> 	<line7>, <line14>, <line15>, <line17>, <line18>
5456	"public class A { <line0> @Override <line1> @SecurityCheck <line2> public boolean isUserExist(AuthzToken authzToken, String username) <line3> throws IamAdminServicesException, AuthorizationException, TException { <line4> TenantManagementKeycloakImpl keycloakclient = new TenantManagementKeycloakImpl(); <line5> String gatewayId = authzToken.getClaimsMap().get(Constants.GATEWAY_ID); <line6> try { <line7> return keycloakclient.isUserExist(authzToken.getAccessToken(), gatewayId, username); <line8> } catch (Exception ex) { <line9> String msg = ""Error while checking if user account exists, reason: "" + ex.getMessage(); <line10> throw new IamAdminServicesException(msg); <line11> } <line12> } <line13> } <line14> "	<line10>
5457	"public class A { <line0> @Override <line1> public void service( <line2> HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { <line3> int status = HttpServletResponse.SC_PRECONDITION_FAILED; <line4> String userAgent = httpServletRequest.getHeader(HttpHeaders.USER_AGENT); <line5> if (_log.isDebugEnabled()) { <line6> } <line7> try { <line8> if (isIgnoredResource(httpServletRequest)) { <line9> status = HttpServletResponse.SC_NOT_FOUND; <line10> return; <line11> } <line12> WebDAVStorage storage = getStorage(httpServletRequest); <line13> if (storage == null) { <line14> if (_log.isDebugEnabled()) { <line15> } <line16> return; <line17> } <line18> if (storage.getRootPath() == null) { <line19> storage.setRootPath(getRootPath(httpServletRequest)); <line20> } <line21> PermissionChecker permissionChecker = null; <line22> String remoteUser = httpServletRequest.getRemoteUser(); <line23> if (remoteUser != null) { <line24> PrincipalThreadLocal.setName(remoteUser); <line25> long userId = GetterUtil.getLong(remoteUser); <line26> User user = UserLocalServiceUtil.getUserById(userId); <line27> permissionChecker = PermissionCheckerFactoryUtil.create(user); <line28> PermissionThreadLocal.setPermissionChecker(permissionChecker); <line29> } <line30> MethodFactory methodFactory = storage.getMethodFactory(); <line31> Method method = methodFactory.create(httpServletRequest); <line32> try { <line33> WebDAVRequest webDAVRequest = <line34> new WebDAVRequestImpl( <line35> storage, httpServletRequest, httpServletResponse, userAgent, permissionChecker); <line36> status = method.process(webDAVRequest); <line37> } catch (WebDAVException webDAVException) { <line38> boolean logError = false; <line39> Throwable throwable = webDAVException; <line40> while (throwable != null) { <line41> if (throwable instanceof PrincipalException) { <line42> logError = true; <line43> } <line44> throwable = throwable.getCause(); <line45> } <line46> if (logError) { <line47> } else if (_log.isWarnEnabled()) { <line48> } <line49> status = HttpServletResponse.SC_PRECONDITION_FAILED; <line50> } <line51> } catch (Exception exception) { <line52> } finally { <line53> httpServletResponse.setStatus(status); <line54> if (_log.isInfoEnabled()) { <line55> String xLitmus = GetterUtil.getString(httpServletRequest.getHeader(""X-Litmus"")); <line56> if (Validator.isNotNull(xLitmus)) { <line57> xLitmus += "" ""; <line58> } <line59> } <line60> } <line61> } <line62> } <line63> "	<line6>, <line15>, <line47>, <line48>, <line52>, <line59>
5458	"public class A { <line0> public void setTargetFramework(String dotnetFramework) { <line1> if (!frameworks.containsKey(dotnetFramework)) { <line2> throw new IllegalArgumentException( <line3> ""Invalid .NET framework version: "" <line4> + dotnetFramework <line5> + "". List of supported versions: "" <line6> + frameworkStrategies.stream().map(p -> p.name).collect(Collectors.joining("", ""))); <line7> } else { <line8> this.targetFramework = dotnetFramework; <line9> } <line10> } <line11> } <line12> "	<line10>
5459	public class A { <line0> @Override <line1> public void connectionClosed(final IOException e) { <line2> this.iec60870ConnectionRegistry.unregisterConnection(this.connection); <line3> } <line4> } <line5> 	<line2>
5460	public class A { <line0> public void addPermission(UmaPermission permission, String clientDn) { <line1> try { <line2> addBranchIfNeeded(clientDn); <line3> permission.setDn(getDn(clientDn, permission.getTicket())); <line4> ldapEntryManager.persist(permission); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	<line6>
5461	public class A { <line0> public boolean processResponse(Response response, MessageChannel messageChannel) { <line1> try { <line2> SipProvider p = null; <line3> Boolean isIpv6 = false; <line4> InetAddress address = InetAddress.getByName(messageChannel.getHost()); <line5> if (address instanceof Inet6Address) { <line6> isIpv6 = true; <line7> p = balancerRunner.balancerContext.externalIpv6SipProvider; <line8> if (messageChannel.getPort() <line9> != balancerRunner.balancerContext.getExternalPortByTransport( <line10> messageChannel.getTransport(), isIpv6)) { <line11> if (balancerRunner.balancerContext.isTwoEntrypoints()) <line12> p = balancerRunner.balancerContext.internalIpv6SipProvider; <line13> } <line14> } else { <line15> p = balancerRunner.balancerContext.externalSipProvider; <line16> if (messageChannel.getPort() <line17> != balancerRunner.balancerContext.getExternalPortByTransport( <line18> messageChannel.getTransport(), isIpv6)) { <line19> if (balancerRunner.balancerContext.isTwoEntrypoints()) <line20> p = balancerRunner.balancerContext.internalSipProvider; <line21> } <line22> } <line23> ResponseEvent event = <line24> new ResponseEvent(new BalancerAppContent(p, isIpv6), null, null, response); <line25> balancerRunner.balancerContext.forwarder.processResponse(event); <line26> } catch (Exception e) { <line27> return false; <line28> } <line29> return false; <line30> } <line31> } <line32> 	<line27>
5462	public class A { <line0> public void enforce(IAgreement agreement, Date since, boolean isLastExecution) { <line1> final Date now = new Date(); <line2> checkInitialized(true); <line3> Map<IGuaranteeTerm, IMetricsRetrieverV2.RetrievalItem> retrievalItems = <line4> buildRetrievalItems(agreement, since, now, isLastExecution); <line5> Map<IGuaranteeTerm, List<IMonitoringMetric>> metricsMap; <line6> if (retriever instanceof IMetricsRetrieverV2) { <line7> metricsMap = getMetrics((IMetricsRetrieverV2) retriever, agreement, retrievalItems); <line8> } else { <line9> metricsMap = getMetrics(retriever, agreement, retrievalItems); <line10> } <line11> enforce(agreement, metricsMap); <line12> } <line13> } <line14> 	<line1>
5463	"public class A { <line0> Maybe<String> getHostnameAws( <line1> NodeMetadata node, <line2> Optional<HostAndPort> sshHostAndPort, <line3> Supplier<? extends LoginCredentials> userCredentials, <line4> ConfigBag setup) { <line5> HostAndPort inferredHostAndPort = null; <line6> boolean waitForSshable = !""false"".equalsIgnoreCase(setup.get(WAIT_FOR_SSHABLE)); <line7> if (!waitForSshable) { <line8> return Maybe.absent(); <line9> } <line10> if (!sshHostAndPort.isPresent()) { <line11> try { <line12> String vmIp = getFirstReachableAddress(node, setup); <line13> int port = node.getLoginPort(); <line14> inferredHostAndPort = HostAndPort.fromParts(vmIp, port); <line15> } catch (Exception e) { <line16> } <line17> } <line18> if (sshHostAndPort.isPresent() || inferredHostAndPort != null) { <line19> if (isWindows(node, setup)) { <line20> } else { <line21> HostAndPort hostAndPortToUse = <line22> sshHostAndPort.isPresent() ? sshHostAndPort.get() : inferredHostAndPort; <line23> try { <line24> return Maybe.of(getHostnameAws(hostAndPortToUse, userCredentials.get(), setup)); <line25> } catch (Exception e) { <line26> } <line27> } <line28> } <line29> return Maybe.absent(); <line30> } <line31> } <line32> "	<line16>, <line20>, <line26>
5464	"public class A { <line0> @BeforeClass <line1> public static void setUpBeforeClass() { <line2> junitHelper = JunitHelper.getInstance(); <line3> port = junitHelper.findAvailablePort(); <line4> try { <line5> application = new AccessInternalMain(ACCESS_CONF, AccessInternalResourceImplTest.class, null); <line6> application.start(); <line7> RestAssured.port = port; <line8> RestAssured.basePath = ACCESS_RESOURCE_URI; <line9> } catch (final VitamApplicationServerException e) { <line10> throw new IllegalStateException(""Cannot start the Access Application Server"", e); <line11> } <line12> } <line13> } <line14> "	<line9>, <line10>
5465	"public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntry checkOutFileEntry( <line1> HttpPrincipal httpPrincipal, <line2> long fileEntryId, <line3> String owner, <line4> long expirationTime, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey( <line10> DLAppServiceUtil.class, ""checkOutFileEntry"", _checkOutFileEntryParameterTypes14); <line11> MethodHandler methodHandler = <line12> new MethodHandler(methodKey, fileEntryId, owner, expirationTime, serviceContext); <line13> Object returnObj = null; <line14> try { <line15> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line18> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line19> } <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (com.liferay.portal.kernel.repository.model.FileEntry) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	<line24>
5466	public class A { <line0> @Override <line1> protected void internalLogFormatted(final String msg, final LogRecord record) { <line2> final Level level = record.getLevel(); <line3> final Throwable t = record.getThrown(); <line4> if (Level.FINE.equals(level) || Level.FINER.equals(level) || Level.CONFIG.equals(level)) { <line5> if (t == null) { <line6> } else { <line7> } <line8> } else if (Level.INFO.equals(level)) { <line9> if (t == null) { <line10> } else { <line11> } <line12> } else if (Level.WARNING.equals(level)) { <line13> if (t == null) { <line14> } else { <line15> } <line16> } else if (Level.ALL.equals(level) || Level.SEVERE.equals(level)) { <line17> if (t == null) { <line18> } else { <line19> } <line20> } <line21> } <line22> } <line23> 	<line6>, <line7>, <line10>, <line11>, <line14>, <line15>, <line18>, <line19>
5467	public class A { <line0> @Override <line1> public void disposeModel() { <line2> model = null; <line3> } <line4> } <line5> 	<line2>
5468	"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> protected String determineSelector( <line2> boolean legacyMapping, <line3> String legacyId, <line4> String selector, <line5> ServiceReference<S> serviceReference) { <line6> if (selector != null && legacyId != null) { <line7> legacyId = null; <line8> } <line9> if (!legacyMapping && selector == null && legacyId != null) { <line10> selector = <line11> String.format(""(%s=%s)"", HttpWhiteboardConstants.HTTP_SERVICE_CONTEXT_PROPERTY, legacyId); <line12> } <line13> if (!legacyMapping && selector == null) { <line14> selector = <line15> String.format( <line16> ""(%s=%s)"", <line17> HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_NAME, <line18> HttpWhiteboardConstants.HTTP_WHITEBOARD_DEFAULT_CONTEXT_NAME); <line19> } <line20> return selector; <line21> } <line22> } <line23> "	<line7>
5469	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> processor.processTimeout(entry); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	<line5>
5470	public class A { <line0> public Set<String> getTargetNodes( <line1> Collection<String> allowedGroups, ITreeNodeBaseActionHelper helper) { <line2> Set<String> targets = this.convertCollection(this.getTreeNodesToOpen()); <line3> try { <line4> String targetNode = this.getTargetNode(); <line5> Boolean open = this.getOpen(); <line6> if (open != null && !open) { <line7> targets = helper.checkTargetNodesOnClosing(targetNode, targets, allowedGroups); <line8> } else { <line9> targets = helper.checkTargetNodes(targetNode, targets, allowedGroups); <line10> } <line11> } catch (Throwable t) { <line12> } <line13> return targets; <line14> } <line15> } <line16> 	<line12>
5471	"public class A { <line0> @Deprecated <line1> public void remove(ConfigScope scope, List<String> keys) { <line2> if (scope == null || scope.getScope() == null) { <line3> return; <line4> } <line5> String clusterName = scope.getClusterName(); <line6> if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) { <line7> throw new HelixException(""cluster "" + clusterName + "" is not setup yet""); <line8> } <line9> String scopeStr = scope.getScopeStr(); <line10> String[] splits = scopeStr.split(""\\|""); <line11> String id = splits[0].substring(splits[0].lastIndexOf('/') + 1); <line12> ZNRecord update = new ZNRecord(id); <line13> if (splits.length == 1) { <line14> for (String key : keys) { <line15> update.setSimpleField(key, """"); <line16> } <line17> } else if (splits.length == 2) { <line18> if (update.getMapField(splits[1]) == null) { <line19> update.setMapField(splits[1], new TreeMap<String, String>()); <line20> } <line21> for (String key : keys) { <line22> update.getMapField(splits[1]).put(key, """"); <line23> } <line24> } <line25> ZKUtil.subtract(_zkClient, splits[0], update); <line26> } <line27> } <line28> "	<line3>
5472	public class A { <line0> public static void inoutdemo(int in1, int[] inout1, int[] out1) { <line1> inout1[0] = 1; <line2> out1[0] = 2; <line3> } <line4> } <line5> 	<line1>
5473	"public class A { <line0> @Test <line1> public void testInsertEmptyWhere() throws Exception { <line2> StringBuilder update = new StringBuilder(); <line3> update.append(getNamespaceDeclarations()); <line4> update.append(""INSERT { <"" + bob + ""> rdfs:label \""Bob\"" . } WHERE { }""); <line5> Update operation = con.prepareUpdate(QueryLanguage.SPARQL, update.toString()); <line6> assertFalse(con.hasStatement(bob, RDFS.LABEL, f.createLiteral(""Bob""), true)); <line7> operation.execute(); <line8> assertTrue(con.hasStatement(bob, RDFS.LABEL, f.createLiteral(""Bob""), true)); <line9> } <line10> } <line11> "	<line2>
5474	"public class A { <line0> @Test <line1> @Atomic <line2> public void test09() { <line3> TxIntrospector txIntrospector = FenixFramework.getTransaction().getTxIntrospector(); <line4> printTest( <line5> ""Create a new book and modify its 1-* relation with '"" <line6> + LITTLE <line7> + ""' twice\n\t"" <line8> + ""(New: [ '"" <line9> + ECLIPSE <line10> + ""']; DM: []; M: ['"" <line11> + LITTLE <line12> + ""']; RCL: ['PublisherWithBooks'])""); <line13> VampireBook eclipse = createEclipse(txIntrospector); <line14> Publisher little = getPublisherByName(LITTLE); <line15> eclipse.setPublisher(little); <line16> little.addPublishedBook(eclipse); <line17> assertFalse(txIntrospector.getModifiedObjects().contains(eclipse)); <line18> assertFalse(txIntrospector.getDirectlyModifiedObjects().contains(eclipse)); <line19> assertTrue(txIntrospector.getModifiedObjects().contains(little)); <line20> assertFalse(txIntrospector.getDirectlyModifiedObjects().contains(little)); <line21> } <line22> } <line23> "	<line21>
5475	public class A { <line0> @Override <line1> public void setAllHealthy() { <line2> enabledPorts.forEach( <line3> x -> { <line4> setHealthy(x); <line5> }); <line6> } <line7> } <line8> 	<line5>
5476	public class A { <line0> private static Scan getConfiguredScanForJob(Configuration conf, String[] args) <line1> throws IOException { <line2> Scan s = new Scan(); <line3> s.setMaxVersions(Integer.MAX_VALUE); <line4> s.setCacheBlocks(false); <line5> if (conf.get(TableInputFormat.SCAN_COLUMN_FAMILY) != null) { <line6> s.addFamily(Bytes.toBytes(conf.get(TableInputFormat.SCAN_COLUMN_FAMILY))); <line7> } <line8> Filter rowFilter = getRowFilter(args); <line9> if (rowFilter != null) { <line10> s.setFilter(rowFilter); <line11> } <line12> long timeRange[] = getTimeRange(args); <line13> if (timeRange != null) { <line14> s.setTimeRange(timeRange[0], timeRange[1]); <line15> } <line16> return s; <line17> } <line18> } <line19> 	<line10>, <line14>, <line16>
5477	"public class A { <line0> @Test(groups = {""multiCluster""}) <line1> public void scheduleProcessParallel() throws Exception { <line2> bundles[0].submitBundle(prism); <line3> for (int i = 1; i <= brothers.length; i++) { <line4> brothers[i - 1] = <line5> new Brother( <line6> ""brother"" + i, <line7> ""schedule"", <line8> EntityType.PROCESS, <line9> brotherGrimm, <line10> bundles[0], <line11> prism, <line12> URLS.SCHEDULE_URL); <line13> } <line14> for (Brother brother : brothers) { <line15> brother.start(); <line16> } <line17> for (Brother brother : brothers) { <line18> brother.join(); <line19> } <line20> for (Brother brother : brothers) { <line21> AssertUtil.assertSucceeded(brother.getOutput()); <line22> } <line23> } <line24> } <line25> "	<line21>
5478	public class A { <line0> @Override <line1> public void afterSecondary(int bucketId) { <line2> dm.getExecutors() <line3> .getWaitingThreadPool() <line4> .execute( <line5> () -> { <line6> try { <line7> lucenePartitionRepositoryManager.computeRepository(bucketId); <line8> } catch (PrimaryBucketException | AlreadyClosedException e) { <line9> } <line10> }); <line11> } <line12> } <line13> 	<line9>
5479	"public class A { <line0> @ModelAttribute(""researchGroupTitle"") <line1> private String fillResearchGroupTitleForExperiment( <line2> @RequestParam(""experimentId"") String idString) { <line3> int experimentId = Integer.parseInt(idString); <line4> Experiment experiment = (Experiment) experimentDao.read(experimentId); <line5> return experiment.getResearchGroup().getTitle(); <line6> } <line7> } <line8> "	<line3>
5480	"public class A { <line0> @Override <line1> public Entry findByU_EA(long userId, String emailAddress) throws NoSuchEntryException { <line2> Entry entry = fetchByU_EA(userId, emailAddress); <line3> if (entry == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""userId=""); <line7> sb.append(userId); <line8> sb.append("", emailAddress=""); <line9> sb.append(emailAddress); <line10> sb.append(""}""); <line11> if (_log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchEntryException(sb.toString()); <line14> } <line15> return entry; <line16> } <line17> } <line18> "	<line12>
5481	"public class A { <line0> public static com.liferay.commerce.currency.model.CommerceCurrency setActive( <line1> HttpPrincipal httpPrincipal, long commerceCurrencyId, boolean active) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(CommerceCurrencyServiceUtil.class, ""setActive"", _setActiveParameterTypes9); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, commerceCurrencyId, active); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.commerce.currency.model.CommerceCurrency) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>
5482	public class A { <line0> private void allocateRedundantTaskManagers(int number) { <line1> int allocatedNumber = allocateWorkers(number); <line2> if (number != allocatedNumber) { <line3> } <line4> } <line5> } <line6> 	<line1>, <line3>
5483	"public class A { <line0> @ResponseStatus(HttpStatus.OK) <line1> @RequestMapping(value = ""/bundles/{bundleId}/uninstallconfig"", method = RequestMethod.POST) <line2> public void uninstallBundleWithConfig(@PathVariable long bundleId) throws BundleException { <line3> moduleAdminService.uninstallBundle(bundleId, true); <line4> } <line5> } <line6> "	<line4>
5484	"public class A { <line0> private Map<String, ConfigProvider> instantiateConfigProviders( <line1> Map<String, String> indirectConfigs, Map<String, ?> providerConfigProperties) { <line2> final String configProviders = indirectConfigs.get(CONFIG_PROVIDERS_CONFIG); <line3> if (configProviders == null || configProviders.isEmpty()) { <line4> return Collections.emptyMap(); <line5> } <line6> Map<String, String> providerMap = new HashMap<>(); <line7> for (String provider : configProviders.split("","")) { <line8> String providerClass = CONFIG_PROVIDERS_CONFIG + ""."" + provider + "".class""; <line9> if (indirectConfigs.containsKey(providerClass)) <line10> providerMap.put(provider, indirectConfigs.get(providerClass)); <line11> } <line12> Map<String, ConfigProvider> configProviderInstances = new HashMap<>(); <line13> for (Map.Entry<String, String> entry : providerMap.entrySet()) { <line14> try { <line15> String prefix = CONFIG_PROVIDERS_CONFIG + ""."" + entry.getKey() + CONFIG_PROVIDERS_PARAM; <line16> Map<String, ?> configProperties = <line17> configProviderProperties(prefix, providerConfigProperties); <line18> ConfigProvider provider = Utils.newInstance(entry.getValue(), ConfigProvider.class); <line19> provider.configure(configProperties); <line20> configProviderInstances.put(entry.getKey(), provider); <line21> } catch (ClassNotFoundException e) { <line22> throw new ConfigException( <line23> ""Invalid config:"" + entry.getValue() + "" ClassNotFoundException exception occurred"", e); <line24> } <line25> } <line26> return configProviderInstances; <line27> } <line28> } <line29> "	<line22>
5485	public class A { <line0> public static void reset() { <line1> freemarkerConfig = null; <line2> freemarkerConfig = new Configuration(); <line3> freemarkerConfig.setObjectWrapper(new DefaultObjectWrapper()); <line4> freemarkerConfig.clearTemplateCache(); <line5> } <line6> } <line7> 	<line5>
5486	"public class A { <line0> private void processAttachment(Mail mail, Map<String, byte[]> attachments) <line1> throws MailetException { <line2> MimeMessage message; <line3> try { <line4> message = mail.getMessage(); <line5> } catch (MessagingException e) { <line6> throw new MailetException(""Could not retrieve message from Mail object"", e); <line7> } <line8> Iterator<byte[]> i = attachments.values().iterator(); <line9> try { <line10> while (i.hasNext()) { <line11> byte[] bytes = i.next(); <line12> InputStream is = new BufferedInputStream(new ByteArrayInputStream(bytes)); <line13> MimeBodyPart p = new MimeBodyPart(is); <line14> if (!(message.isMimeType(""multipart/*"") <line15> && (message.getContent() instanceof MimeMultipart))) { <line16> Object content = message.getContent(); <line17> String contentType = message.getContentType(); <line18> MimeMultipart mimeMultipart = new MimeMultipart(); <line19> message.setContent(mimeMultipart); <line20> message.saveChanges(); <line21> mimeMultipart.setParent(message); <line22> MimeBodyPart bodyPart = new MimeBodyPart(); <line23> mimeMultipart.addBodyPart(bodyPart); <line24> bodyPart.setContent(content, contentType); <line25> } <line26> ((MimeMultipart) message.getContent()).addBodyPart(p); <line27> } <line28> message.saveChanges(); <line29> } catch (MessagingException e) { <line30> } catch (IOException e) { <line31> } <line32> } <line33> } <line34> "	<line30>, <line31>
5487	public class A { <line0> public static void separateVcUnreachableNodes( <line1> List<BaseNode> existingNodes, <line2> List<BaseNode> deletedNodes, <line3> Map<String, Set<String>> occupiedIpSets, <line4> IClusterEntityManager entityMgr, <line5> ClusterCreate cluster) { <line6> ClusterEntity clusterEntity = entityMgr.findByName(cluster.getName()); <line7> for (NodeGroupCreate group : cluster.getNodeGroups()) { <line8> NodeGroupEntity groupEntity = entityMgr.findByName(clusterEntity, group.getName()); <line9> Set<NodeEntity> nodeEntities = groupEntity.getNodes(); <line10> if (nodeEntities == null) { <line11> continue; <line12> } <line13> for (NodeEntity nodeEntity : nodeEntities) { <line14> BaseNode node = convertNode(cluster, group, nodeEntity); <line15> VcVirtualMachine vm = ClusterUtil.getVcVm(entityMgr, nodeEntity); <line16> if (vm == null) { <line17> vm = ClusterUtil.findAndUpdateNodeVmByName(entityMgr, nodeEntity); <line18> if (vm == null) { <line19> } else { <line20> node.setVmMobId(vm.getId()); <line21> } <line22> } <line23> if (!checkVcVmReachable(node, vm)) { <line24> deletedNodes.add(node); <line25> continue; <line26> } <line27> String haFlag = node.getNodeGroup().getHaFlag(); <line28> if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) { <line29> if (!VcVmUtil.verifyFTState(vm)) { <line30> deletedNodes.add(node); <line31> continue; <line32> } <line33> } <line34> existingNodes.add(node); <line35> adjustOccupiedIpSets(occupiedIpSets, node, true); <line36> } <line37> } <line38> } <line39> } <line40> 	<line17>, <line19>, <line30>
5488	"public class A { <line0> @Test(expected = FullTableScansDisallowedException.class) <line1> public void testSingleValueAndMultiFieldNoParens() throws Exception { <line2> for (final TestCities city : TestCities.values()) { <line3> String query = <line4> CityField.CITY.name() <line5> + LTE_OP <line6> + ""'"" <line7> + city.name() <line8> + ""'"" <line9> + AND_OP <line10> + CityField.CITY.name() <line11> + GTE_OP <line12> + ""'"" <line13> + city.name() <line14> + ""'"" <line15> + AND_OP <line16> + CityField.NUM.name() <line17> + LTE_OP <line18> + ""20"" <line19> + AND_OP <line20> + CityField.NUM.name() <line21> + GTE_OP <line22> + ""20""; <line23> try { <line24> String plan = getPlan(query, true, true); <line25> Assert.fail(""Expected FullTableScansDisallowedException but got "" + plan); <line26> } catch (FullTableScansDisallowedException e) { <line27> } <line28> String expected = <line29> CityField.CITY.name() <line30> + LTE_OP <line31> + ""'"" <line32> + city.name() <line33> + ""'"" <line34> + AND_OP <line35> + CityField.CITY.name() <line36> + GTE_OP <line37> + ""'"" <line38> + city.name() <line39> + ""'"" <line40> + AND_OP <line41> + CityField.NUM.name() <line42> + LTE_OP <line43> + ""'+bE2'"" <line44> + AND_OP <line45> + CityField.NUM.name() <line46> + GTE_OP <line47> + ""'+bE2'""; <line48> String plan = getPlan(query, true, false); <line49> assertPlanEquals(expected, plan); <line50> plan = getPlan(query, false, true); <line51> assertPlanEquals(expected, plan); <line52> expected = query; <line53> runTest(query, expected); <line54> } <line55> } <line56> } <line57> "	<line2>
5489	public class A { <line0> private void updateServiceContexts(Object propertyMap) { <line1> if (propertyMap instanceof Map) { <line2> String excludePrefix = ServiceHelper.getContext().getPrefix(); <line3> Map<String, Object> properties = (Map<String, Object>) propertyMap; <line4> Map<String, Object> filtered = <line5> properties.entrySet().stream() <line6> .filter(p -> !(p == null || p.getKey().startsWith(excludePrefix))) <line7> .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue())); <line8> ServiceHelper.getContext().addProperties((Map) propertyMap); <line9> } else { <line10> } <line11> } <line12> } <line13> 	<line10>
5490	"public class A { <line0> private void performDbCleanup(Connection conn) { <line1> try { <line2> PreparedStatement pstmt = conn.prepareStatement(""SELECT domain_id FROM account_vlan_map""); <line3> try { <line4> pstmt.executeQuery(); <line5> } catch (SQLException e) { <line6> return; <line7> } <line8> pstmt = <line9> conn.prepareStatement( <line10> ""ALTER TABLE `cloud`.`account_vlan_map` DROP FOREIGN KEY"" <line11> + "" `fk_account_vlan_map__domain_id`""); <line12> pstmt.executeUpdate(); <line13> pstmt = <line14> conn.prepareStatement(""ALTER TABLE `cloud`.`account_vlan_map` DROP COLUMN `domain_id`""); <line15> pstmt.executeUpdate(); <line16> pstmt = <line17> conn.prepareStatement(""DELETE FROM `cloud`.`account_vlan_map` WHERE account_id IS NULL""); <line18> pstmt.executeUpdate(); <line19> pstmt.close(); <line20> } catch (SQLException e) { <line21> throw new CloudRuntimeException( <line22> ""Unable to delete domain_id field from account_vlan_map table due to:"", e); <line23> } <line24> } <line25> } <line26> "	<line6>
5491	public class A { <line0> public org.apache.thrift.async.AsyncMethodCallback<java.lang.Short> getResultHandler( <line1> final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, <line2> final int seqid) { <line3> final org.apache.thrift.AsyncProcessFunction fcall = this; <line4> return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Short>() { <line5> public void onComplete(java.lang.Short o) { <line6> echoI16_result result = new echoI16_result(); <line7> result.success = o; <line8> result.setSuccessIsSet(true); <line9> try { <line10> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line11> } catch (org.apache.thrift.transport.TTransportException e) { <line12> fb.close(); <line13> } catch (java.lang.Exception e) { <line14> onError(e); <line15> } <line16> } <line17>  <line18> public void onError(java.lang.Exception e) { <line19> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line20> org.apache.thrift.TSerializable msg; <line21> echoI16_result result = new echoI16_result(); <line22> if (e instanceof org.apache.thrift.transport.TTransportException) { <line23> fb.close(); <line24> return; <line25> } else if (e instanceof org.apache.thrift.TApplicationException) { <line26> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line27> msg = (org.apache.thrift.TApplicationException) e; <line28> } else { <line29> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line30> msg = <line31> new org.apache.thrift.TApplicationException( <line32> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line33> } <line34> try { <line35> fcall.sendResponse(fb, msg, msgType, seqid); <line36> } catch (java.lang.Exception ex) { <line37> fb.close(); <line38> } <line39> } <line40> }; <line41> } <line42> } <line43> 	<line12>, <line14>, <line23>, <line26>, <line29>, <line37>
5492	public class A { <line0> private void prepareDistinguishedNames(CertificateRequestMessage msg) { <line1> msg.setDistinguishedNames(chooser.getConfig().getDistinguishedNames()); <line2> } <line3> } <line4> 	<line2>
5493	public class A { <line0> private static X509ExtendedKeyManager getX509KeyManager(KeyManager keyManager) <line1> throws StartException { <line2> if (keyManager == null) { <line3> return null; <line4> } <line5> if (keyManager instanceof X509ExtendedKeyManager) { <line6> X509ExtendedKeyManager x509KeyManager = (X509ExtendedKeyManager) keyManager; <line7> if (x509KeyManager instanceof DelegatingKeyManager && IS_FIPS.getAsBoolean()) { <line8> x509KeyManager = ((DelegatingKeyManager) x509KeyManager).delegating.get(); <line9> } <line10> return x509KeyManager; <line11> } <line12> throw ROOT_LOGGER.invalidTypeInjected(X509ExtendedKeyManager.class.getSimpleName()); <line13> } <line14> } <line15> 	<line8>
5494	"public class A { <line0> @Produces <line1> @ServerPath <line2> public String getServerPath() { <line3> String configuredValue = databaseBackedConfig.getServerHost(); <line4> if (configuredValue != null) { <line5> return configuredValue; <line6> } else { <line7> String defaultServerPath = HttpRequestAndSessionHolder.getDefaultServerPath(); <line8> if (defaultServerPath == null) { <line9> return """"; <line10> } <line11> return defaultServerPath; <line12> } <line13> } <line14> } <line15> "	<line9>
5495	public class A { <line0> @PostConstruct <line1> public void init() { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> fessConfig = ComponentUtil.getFessConfig(); <line5> } <line6> } <line7> 	<line3>
5496	"public class A { <line0> private boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException { <line1> if (!FourLetterCommands.isKnown(len)) { <line2> return false; <line3> } <line4> String cmd = FourLetterCommands.getCommandString(len); <line5> packetReceived(4); <line6> if (k != null) { <line7> try { <line8> k.cancel(); <line9> } catch (Exception e) { <line10> } <line11> } <line12> final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter())); <line13> if (!FourLetterCommands.isEnabled(cmd)) { <line14> NopCommand nopCmd = <line15> new NopCommand( <line16> pwriter, this, cmd + "" is not executed because it is not in the whitelist.""); <line17> nopCmd.start(); <line18> return true; <line19> } <line20> if (len == FourLetterCommands.setTraceMaskCmd) { <line21> incomingBuffer = ByteBuffer.allocate(8); <line22> int rc = sock.read(incomingBuffer); <line23> if (rc < 0) { <line24> throw new IOException(""Read error""); <line25> } <line26> incomingBuffer.flip(); <line27> long traceMask = incomingBuffer.getLong(); <line28> ZooTrace.setTextTraceLevel(traceMask); <line29> SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask); <line30> setMask.start(); <line31> return true; <line32> } else { <line33> CommandExecutor commandExecutor = new CommandExecutor(); <line34> return commandExecutor.execute(this, pwriter, len, zkServer, factory); <line35> } <line36> } <line37> } <line38> "	<line10>, <line14>, <line20>
5497	"public class A { <line0> @AfterGroups(groups = ""sharedHBase"") <line1> public void afterGroups(ITestContext context) throws Exception { <line2> if (hbaseCluster != null) { <line3> hBaseUtils.shutdownMiniCluster(); <line4> } <line5> getClient(context).close().get(); <line6> getTSO(context).stopAndWait(); <line7> TestUtils.waitForSocketNotListening(""localhost"", 1234, 1000); <line8> } <line9> } <line10> "	<line2>
5498	public class A { <line0> public void dataSource(DataSource dataSource) { <line1> ConnectionDataSourceConfig connectionConfig = new ConnectionDataSourceConfig(dataSource); <line2> connectionConfig.setDbName(dbName); <line3> connectionConfig.setEnvironment(environment); <line4> connectionConfig.setTesting(testing); <line5> DBConfiguration.addConnectionConfig(connectionConfig); <line6> } <line7> } <line8> 	<line6>
5499	"public class A { <line0> @Override <line1> public boolean isValid(int timeout) throws SQLException { <line2> if (timeout < 0) { <line3> throw new SQLException(""Timeout value mustn't be less 0""); <line4> } <line5> if (isClosed()) { <line6> return false; <line7> } <line8> boolean isAnotherHttpClient = false; <line9> CloseableHttpClient closeableHttpClient = null; <line10> try { <line11> if (timeout == 0) { <line12> closeableHttpClient = this.httpclient; <line13> } else { <line14> ClickHouseProperties properties = new ClickHouseProperties(this.properties); <line15> int timeoutMs = (int) TimeUnit.SECONDS.toMillis(timeout); <line16> properties.setConnectionTimeout(timeoutMs); <line17> properties.setMaxExecutionTime(timeout); <line18> properties.setSocketTimeout(timeoutMs); <line19> closeableHttpClient = new ClickHouseHttpClientBuilder(properties).buildClient(); <line20> isAnotherHttpClient = true; <line21> } <line22> Statement statement = createClickHouseStatement(closeableHttpClient); <line23> statement.execute(""SELECT 1""); <line24> statement.close(); <line25> return true; <line26> } catch (Exception e) { <line27> boolean isFailOnConnectionTimeout = <line28> e instanceof ConnectTimeoutException || e.getCause() instanceof ConnectTimeoutException; <line29> if (!isFailOnConnectionTimeout) { <line30> } <line31> return false; <line32> } finally { <line33> if (isAnotherHttpClient) { <line34> try { <line35> closeableHttpClient.close(); <line36> } catch (IOException e) { <line37> } <line38> } <line39> } <line40> } <line41> } <line42> "	<line30>, <line37>
5500	public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSession session) { <line2> List<FlowFile> flowFiles = session.get(1); <line3> if (flowFiles.isEmpty()) { <line4> return; <line5> } <line6> final FlowFile firstFlowFile = flowFiles.get(0); <line7> final String queueUrl = <line8> context.getProperty(QUEUE_URL).evaluateAttributeExpressions(firstFlowFile).getValue(); <line9> final AmazonSQSClient client = getClient(); <line10> final DeleteMessageBatchRequest request = new DeleteMessageBatchRequest(); <line11> request.setQueueUrl(queueUrl); <line12> final List<DeleteMessageBatchRequestEntry> entries = new ArrayList<>(flowFiles.size()); <line13> for (final FlowFile flowFile : flowFiles) { <line14> final DeleteMessageBatchRequestEntry entry = new DeleteMessageBatchRequestEntry(); <line15> entry.setReceiptHandle( <line16> context.getProperty(RECEIPT_HANDLE).evaluateAttributeExpressions(flowFile).getValue()); <line17> entries.add(entry); <line18> } <line19> request.setEntries(entries); <line20> try { <line21> client.deleteMessageBatch(request); <line22> session.transfer(flowFiles, REL_SUCCESS); <line23> } catch (final Exception e) { <line24> getLogger() <line25> final List<FlowFile> penalizedFlowFiles = new ArrayList<>(); <line26> for (final FlowFile flowFile : flowFiles) { <line27> penalizedFlowFiles.add(session.penalize(flowFile)); <line28> } <line29> session.transfer(penalizedFlowFiles, REL_FAILURE); <line30> } <line31> } <line32> } <line33> 	<line22>, <line25>
5501	public class A { <line0> private void startReader(ConnectionTable connTable) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> Assert.assertTrue(!isRunning); <line4> stopped = false; <line5> isRunning = true; <line6> connTable.executeCommand(this); <line7> } <line8> } <line9> 	<line2>
5502	"public class A { <line0> @ApiOperation(value = ""Starts a new case instance for a specified case definition."") <line1> @ApiResponses( <line2> value = { <line3> @ApiResponse(code = 500, message = ""Unexpected error""), <line4> @ApiResponse(code = 404, message = ""Case definition or Container Id not found""), <line5> @ApiResponse( <line6> code = 201, <line7> response = String.class, <line8> message = ""Successful response"", <line9> examples = @Example(value = {@ExampleProperty(mediaType = JSON, value = CASE_ID_JSON)})) <line10> }) <line11> @POST <line12> @Path(START_CASE_POST_URI) <line13> @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line14> @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line15> public Response startCase( <line16> @javax.ws.rs.core.Context HttpHeaders headers, <line17> @ApiParam( <line18> value = ""container id where the case definition resides"", <line19> required = true, <line20> example = ""evaluation_1.0.0-SNAPSHOT"") <line21> @PathParam(CONTAINER_ID) <line22> String containerId, <line23> @ApiParam( <line24> value = ""case definition id that new instance should be created from"", <line25> required = true, <line26> example = ""CASE-0000000001"") <line27> @PathParam(CASE_DEF_ID) <line28> String caseDefId, <line29> @ApiParam( <line30> value = ""optional CaseFile with variables and/or case role assignments"", <line31> required = false, <line32> examples = <line33> @Example( <line34> value = { <line35> @ExampleProperty(mediaType = JSON, value = CASE_FILE_JSON), <line36> @ExampleProperty(mediaType = XML, value = CASE_FILE_XML) <line37> })) <line38> String payload) { <line39> return invokeCaseOperation( <line40> headers, <line41> containerId, <line42> null, <line43> (Variant v, String type, Header... customHeaders) -> { <line44> try { <line45> String response = <line46> caseManagementServiceBase.startCase(containerId, caseDefId, payload, type); <line47> return createResponse(response, v, Response.Status.CREATED, customHeaders); <line48> } catch (CaseDefinitionNotFoundException e) { <line49> return notFound( <line50> MessageFormat.format(CASE_DEFINITION_NOT_FOUND, caseDefId, containerId), <line51> v, <line52> customHeaders); <line53> } <line54> }); <line55> } <line56> } <line57> "	<line47>
5503	public class A { <line0> private static synchronized MarshallerBuilder getMarshallerBuilder() { <line1> ServiceLoader<MarshallerBuilder> builders = ServiceLoader.load(MarshallerBuilder.class); <line2> Iterator<MarshallerBuilder> it = builders.iterator(); <line3> if (it.hasNext()) { <line4> MarshallerBuilder marshallerBuilder = it.next(); <line5> return marshallerBuilder; <line6> } <line7> return new BaseMarshallerBuilder(); <line8> } <line9> } <line10> 	<line5>
5504	public class A { <line0> @Override <line1> public Position addEntry(byte[] data, int offset, int length) <line2> throws InterruptedException, ManagedLedgerException { <line3> final CountDownLatch counter = new CountDownLatch(1); <line4> class Result { <line5> ManagedLedgerException status = null; <line6> Position position = null; <line7> } <line8> final Result result = new Result(); <line9> asyncAddEntry( <line10> data, <line11> offset, <line12> length, <line13> new AddEntryCallback() { <line14> @Override <line15> public void addComplete(Position position, ByteBuf entryData, Object ctx) { <line16> result.position = position; <line17> counter.countDown(); <line18> } <line19>  <line20> @Override <line21> public void addFailed(ManagedLedgerException exception, Object ctx) { <line22> result.status = exception; <line23> counter.countDown(); <line24> } <line25> }, <line26> null); <line27> counter.await(); <line28> if (result.status != null) { <line29> throw result.status; <line30> } <line31> return result.position; <line32> } <line33> } <line34> 	<line29>
5505	"public class A { <line0> @Test <line1> public void testTokenToConfFromUser() throws Exception { <line2> UserGroupInformation ugi = Mockito.mock(UserGroupInformation.class); <line3> JobConf jobConf = new JobConf(); <line4> ArrayList<Token<?>> tokens = new ArrayList<>(); <line5> Text service = new Text(""service""); <line6> Token<?> token = Mockito.mock(Token.class); <line7> tokens.add(token); <line8> Mockito.when(ugi.getTokens()).thenReturn(tokens); <line9> Mockito.when(token.getKind()).thenReturn(HiveAccumuloHelper.ACCUMULO_SERVICE); <line10> Mockito.when(token.getService()).thenReturn(service); <line11> try { <line12> helper.addTokenFromUserToJobConf(ugi, jobConf); <line13> } catch (IOException e) { <line14> return; <line15> } <line16> Collection<Token<?>> credTokens = jobConf.getCredentials().getAllTokens(); <line17> assertEquals(1, credTokens.size()); <line18> assertEquals(service, credTokens.iterator().next().getService()); <line19> } <line20> } <line21> "	<line14>
5506	"public class A { <line0> private void initHttpConnectionManager() throws ServletException { <line1> httpConnectionManager = new MultiThreadedHttpConnectionManager(); <line2> int max_per_host = <line3> Integer.parseInt( <line4> _odeConfig.getProperty( <line5> HttpConnectionManagerParams.MAX_HOST_CONNECTIONS, <line6> """" + _odeConfig.getPoolMaxSize())); <line7> int max_total = <line8> Integer.parseInt( <line9> _odeConfig.getProperty( <line10> HttpConnectionManagerParams.MAX_TOTAL_CONNECTIONS, <line11> """" + _odeConfig.getPoolMaxSize())); <line12> if (__log.isDebugEnabled()) { <line13> } <line14> if (max_per_host < 1 || max_total < 1) { <line15> String errmsg = <line16> HttpConnectionManagerParams.MAX_HOST_CONNECTIONS <line17> + "" and "" <line18> + HttpConnectionManagerParams.MAX_TOTAL_CONNECTIONS <line19> + "" must be positive integers!""; <line20> throw new ServletException(errmsg); <line21> } <line22> httpConnectionManager.getParams().setDefaultMaxConnectionsPerHost(max_per_host); <line23> httpConnectionManager.getParams().setMaxTotalConnections(max_total); <line24> idleConnectionTimeoutThread = new IdleConnectionTimeoutThread(); <line25> idleConnectionTimeoutThread.setName(""Http_Idle_Connection_Timeout_Thread""); <line26> long idleConnectionTimeout = <line27> Long.parseLong(_odeConfig.getProperty(""http.idle.connection.timeout"", ""30000"")); <line28> long idleConnectionCheckInterval = <line29> Long.parseLong(_odeConfig.getProperty(""http.idle.connection.check.interval"", ""30000"")); <line30> if (__log.isDebugEnabled()) { <line31> } <line32> idleConnectionTimeoutThread.setConnectionTimeout(idleConnectionTimeout); <line33> idleConnectionTimeoutThread.setTimeoutInterval(idleConnectionCheckInterval); <line34> idleConnectionTimeoutThread.addConnectionManager(httpConnectionManager); <line35> idleConnectionTimeoutThread.start(); <line36> } <line37> } <line38> "	<line13>, <line20>, <line31>
5507	public class A { <line0> @Override <line1> public void onSuccess(@Nullable Collection<String> keys) { <line2> try { <line3> logTimeseriesDeleted(user, entityId, new ArrayList<>(keys), null); <line4> } catch (ThingsboardException e) { <line5> } <line6> resultFuture.set(null); <line7> } <line8> } <line9> 	<line5>
5508	public class A { <line0> public void setCardinalityConfiguration(CardinalityConfiguration cardinalityConfiguration) { <line1> this.cardinalityConfiguration = cardinalityConfiguration; <line2> try { <line3> if (cardinalityConfiguration != null) { <line4> resultCardinalityDocumentDate = <line5> new CardinalityRecord( <line6> cardinalityConfiguration.getCardinalityFields(), <line7> CardinalityRecord.DateType.DOCUMENT); <line8> resultCardinalityQueryDate = <line9> new CardinalityRecord( <line10> cardinalityConfiguration.getCardinalityFields(), <line11> CardinalityRecord.DateType.CURRENT); <line12> } <line13> } catch (Exception e) { <line14> } <line15> } <line16> } <line17> 	<line14>
5509	public class A { <line0> void deleteUser(MongoUser user) { <line1> WriteResult result = delete(q().field(MongoTrack.USER).equal(key(user))); <line2> if (result.wasAcknowledged()) { <line3> } else { <line4> } <line5> } <line6> } <line7> 	<line3>, <line4>
5510	public class A { <line0> @Override <line1> public Pair<DataBuffer, DataBuffer> getTADOnlyShapeInfo(INDArray array, int[] dimension) { <line2> if (dimension != null && dimension.length > 1) Arrays.sort(dimension); <line3> Integer deviceId = AtomicAllocator.getInstance().getDeviceId(); <line4> TadDescriptor descriptor = new TadDescriptor(array, dimension); <line5> if (!tadCache.get(deviceId).containsKey(descriptor)) { <line6> Pair<DataBuffer, DataBuffer> buffers = super.getTADOnlyShapeInfo(array, dimension); <line7> if (buffers.getFirst() != array.shapeInfoDataBuffer()) <line8> AtomicAllocator.getInstance().moveToConstant(buffers.getFirst()); <line9> if (buffers.getSecond() != null) <line10> AtomicAllocator.getInstance().moveToConstant(buffers.getSecond()); <line11> tadCache.get(deviceId).put(descriptor, buffers); <line12> bytes.addAndGet((buffers.getFirst().length() * 4)); <line13> if (buffers.getSecond() != null) bytes.addAndGet(buffers.getSecond().length() * 8); <line14> } <line15> return tadCache.get(deviceId).get(descriptor); <line16> } <line17> } <line18> 	<line6>, <line14>
5511	public class A { <line0> private boolean prefillConnection() { <line1> if (shuttingDown.get()) { <line2> return false; <line3> } <line4> if (connectionAccounting.tryPrefill()) { <line5> PooledConnection connection = null; <line6> try { <line7> connection = createPooledConnection(); <line8> if (connection == null) { <line9> return false; <line10> } <line11> getPoolStats().incPrefillConnect(); <line12> availableConnectionManager.addLast(connection, false); <line13> if (logger.isDebugEnabled()) { <line14> } <line15> return true; <line16> } catch (ServerConnectivityException ex) { <line17> return false; <line18> } finally { <line19> if (connection == null) { <line20> connectionAccounting.cancelTryPrefill(); <line21> if (logger.isDebugEnabled()) { <line22> } <line23> } <line24> } <line25> } <line26> return false; <line27> } <line28> } <line29> 	<line14>, <line17>, <line22>
5512	"public class A { <line0> private void deleteByQuery(String index, QueryBuilder query) { <line1> DeleteByQueryRequest request = new DeleteByQueryRequest(index); <line2> request.setQuery(query); <line3> try { <line4> BulkByScrollResponse bulkResponse = client.deleteByQuery(request, RequestOptions.DEFAULT); <line5> } catch (IOException e) { <line6> throw new IndexingException( <line7> String.format(""Error deleting all models in the '%s' index."", index), e); <line8> } <line9> } <line10> } <line11> "	<line1>, <line5>
5513	"public class A { <line0> private String getNextFileName() throws IOException { <line1> try { <line2> String filePath = <line3> base <line4> + ""_"" <line5> + WorkerContext.get().getWorkerAttemptId() <line6> + ""_"" <line7> + taskIndex <line8> + ""_"" <line9> + currentWriteFileIndex++; <line10> Path newPath = <line11> lDirAlloc.getLocalPathForWrite(filePath, maxSizePerFile, WorkerContext.get().getConf()); <line12> return newPath.toUri().toString(); <line13> } catch (Exception e) { <line14> throw new IOException(""task UnInitializtionException"", e); <line15> } <line16> } <line17> } <line18> "	<line12>
5514	"public class A { <line0> @Test <line1> public void testStringResult() throws ServiceFailureException { <line2> ObservationDao doa = service.observations(); <line3> Observation b1 = new Observation(""fourty two"", DATASTREAMS.get(0)); <line4> doa.create(b1); <line5> OBSERVATIONS.add(b1); <line6> Observation found; <line7> found = doa.find(b1.getId()); <line8> String message = ""Expected result to be a String.""; <line9> Assert.assertEquals(message, b1.getResult(), found.getResult()); <line10> } <line11> } <line12> "	<line2>
5515	"public class A { <line0> protected int maxNumPartitions(final Cluster metadata, final Set<String> topics) { <line1> int maxNumPartitions = 0; <line2> for (final String topic : topics) { <line3> final List<PartitionInfo> partitions = metadata.partitionsForTopic(topic); <line4> if (partitions.isEmpty()) { <line5> throw new RuntimeException(""Empty partitions for topic "" + topic); <line6> } <line7> final int numPartitions = partitions.size(); <line8> if (numPartitions > maxNumPartitions) { <line9> maxNumPartitions = numPartitions; <line10> } <line11> } <line12> return maxNumPartitions; <line13> } <line14> } <line15> "	<line5>
5516	"public class A { <line0> @Test <line1> public void callSubscribeBroadcastWithSingleByteBufferParameter() { <line2> final Semaphore resultsAvailable = new Semaphore(0); <line3> Future<String> subscriptionIdFuture; <line4> String subscriptionId; <line5> boolean result; <line6> final Byte[] expectedByteBuffer = {-128, 0, 127}; <line7> try { <line8> subscriptionIdFuture = <line9> testInterfaceProxy.subscribeToBroadcastWithSingleByteBufferParameterBroadcast( <line10> new BroadcastWithSingleByteBufferParameterBroadcastAdapter() { <line11> @Override <line12> public void onReceive(Byte[] byteBufferOut) { <line13> if (!java.util.Objects.deepEquals(byteBufferOut, expectedByteBuffer)) { <line14> subscribeBroadcastWithSingleByteBufferParameterCallbackResult = false; <line15> } else { <line16> subscribeBroadcastWithSingleByteBufferParameterCallbackResult = true; <line17> } <line18> resultsAvailable.release(); <line19> } <line20>  <line21> @Override <line22> public void onError(SubscriptionException error) { <line23> subscribeBroadcastWithSingleByteBufferParameterCallbackResult = false; <line24> resultsAvailable.release(); <line25> } <line26> }, <line27> new MulticastSubscriptionQos(), <line28> partitions); <line29> subscriptionId = subscriptionIdFuture.get(10000); <line30> testInterfaceProxy.methodToFireBroadcastWithSingleByteBufferParameter( <line31> expectedByteBuffer, partitions); <line32> Assert.assertTrue( <line33> name.getMethodName() + "" - FAILED - callback was not received in time"", <line34> resultsAvailable.tryAcquire(2, TimeUnit.SECONDS)); <line35> Assert.assertTrue( <line36> name.getMethodName() <line37> + "" - FAILED - callback got called but received unexpected error or publication"" <line38> + "" event"", <line39> subscribeBroadcastWithSingleByteBufferParameterCallbackResult); <line40> try { <line41> testInterfaceProxy.unsubscribeFromBroadcastWithSingleByteBufferParameterBroadcast( <line42> subscriptionId); <line43> } catch (Exception e) { <line44> fail( <line45> name.getMethodName() <line46> + "" - FAILED - caught unexpected exception on unsubscribe: "" <line47> + e.getMessage()); <line48> } <line49> } catch (Exception e) { <line50> fail(name.getMethodName() + "" - FAILED - caught unexpected exception: "" + e.getMessage()); <line51> } <line52> } <line53> } <line54> "	<line7>, <line13>, <line14>, <line16>, <line23>, <line30>, <line32>, <line35>, <line43>
5517	"public class A { <line0> @Before <line1> public void before() { <line2> Mockito.when(workerConfig.getWorkerGroups()).thenReturn(workerGroups); <line3> Mockito.when(zookeeperRegistryCenter.getWorkerPath()) <line4> .thenReturn(""/dolphinscheduler/nodes/worker""); <line5> Mockito.when(zookeeperRegistryCenter.getRegisterOperator()).thenReturn(registerOperator); <line6> Mockito.when(zookeeperRegistryCenter.getRegisterOperator().getZkClient()).thenReturn(zkClient); <line7> Mockito.when( <line8> zookeeperRegistryCenter <line9> .getRegisterOperator() <line10> .getZkClient() <line11> .getConnectionStateListenable()) <line12> .thenReturn( <line13> new Listenable<ConnectionStateListener>() { <line14> @Override <line15> public void addListener(ConnectionStateListener connectionStateListener) { <line16> } <line17>  <line18> @Override <line19> public void addListener( <line20> ConnectionStateListener connectionStateListener, Executor executor) { <line21> } <line22>  <line23> @Override <line24> public void removeListener(ConnectionStateListener connectionStateListener) { <line25> } <line26> }); <line27> Mockito.when(workerConfig.getWorkerHeartbeatInterval()).thenReturn(10); <line28> Mockito.when(workerConfig.getWorkerReservedMemory()).thenReturn(1.1); <line29> Mockito.when(workerConfig.getWorkerMaxCpuloadAvg()).thenReturn(1); <line30> } <line31> } <line32> "	<line16>, <line21>, <line25>
5518	"public class A { <line0> public static ValidationReport validatePreservationBinary(Binary binary, boolean failIfNoSchema) { <line1> ValidationReport report = new ValidationReport(); <line2> Optional<Schema> xmlSchema = RodaCoreFactory.getRodaSchema(""premis-v2-0"", null); <line3> if (xmlSchema.isPresent()) { <line4> try (InputStream inputStream = binary.getContent().createInputStream()) { <line5> Source xmlFile = new StreamSource(inputStream); <line6> Validator validator = xmlSchema.get().newValidator(); <line7> RodaErrorHandler errorHandler = new RodaErrorHandler(); <line8> validator.setErrorHandler(errorHandler); <line9> try { <line10> validator.validate(xmlFile); <line11> report.setValid(errorHandler.getErrors().isEmpty()); <line12> for (SAXParseException saxParseException : errorHandler.getErrors()) { <line13> report.addIssue(convertSAXParseException(saxParseException)); <line14> } <line15> } catch (SAXException e) { <line16> report.setValid(false); <line17> for (SAXParseException saxParseException : errorHandler.getErrors()) { <line18> report.addIssue(convertSAXParseException(saxParseException)); <line19> } <line20> } <line21> } catch (IOException e) { <line22> report.setValid(false); <line23> report.setMessage(e.getMessage()); <line24> } <line25> } else if (failIfNoSchema) { <line26> report.setValid(false); <line27> report.setMessage(""No schema to validate PREMIS""); <line28> } <line29> return report; <line30> } <line31> } <line32> "	<line16>
5519	"public class A { <line0> @Override <line1> public void registerContribution( <line2> Object contribution, String extensionPoint, ComponentInstance contributor) { <line3> if (extensionPoint.equals(""deployments"")) { <line4> DeploymentDescriptor deployment = (DeploymentDescriptor) contribution; <line5> deployments.put(deployment.src, deployment); <line6> RuntimeContext ctx = contributor.getContext(); <line7> if (ctx instanceof OSGiRuntimeContext) { <line8> Bundle bundle = ctx.getBundle(); <line9> String location = bundle.getLocation(); <line10> File root = null; <line11> try { <line12> root = new File(new URI(location)); <line13> if (root.isFile()) { <line14> root = root.getParentFile(); <line15> } <line16> } catch (Exception e) { <line17> } <line18> File srcFile = new File(root, deployment.src); <line19> File[] files; <line20> if (srcFile.isDirectory()) { <line21> files = srcFile.listFiles(); <line22> } else { <line23> files = new File[] {srcFile}; <line24> } <line25> for (File file : files) { <line26> try { <line27> URL url = file.toURI().toURL(); <line28> deployment.urls = new ArrayList<URL>(); <line29> ctx.deploy(url); <line30> deployment.urls.add(url); <line31> } catch (Exception e) { <line32> } <line33> } <line34> } <line35> } <line36> } <line37> } <line38> "	<line17>, <line28>, <line32>
5520	public class A { <line0> @JsonIgnore <line1> @Override <line2> public List<JsonNode> getObjectMetadataList() { <line3> String objectList = mapParameters.get(WorkerParameterName.objectMetadataList); <line4> if (objectList == null) { <line5> return null; <line6> } <line7> try { <line8> return JsonHandler.getFromString(objectList, List.class, JsonNode.class); <line9> } catch (InvalidParseOperationException e) { <line10> throw new IllegalArgumentException(e); <line11> } <line12> } <line13> } <line14> 	<line10>
5521	"public class A { <line0> @Override <line1> public <ClusterID> ClusterClientFactory<ClusterID> getClusterClientFactory( <line2> final Configuration configuration) { <line3> checkNotNull(configuration); <line4> final ServiceLoader<ClusterClientFactory> loader = <line5> ServiceLoader.load(ClusterClientFactory.class); <line6> final List<ClusterClientFactory> compatibleFactories = new ArrayList<>(); <line7> final Iterator<ClusterClientFactory> factories = loader.iterator(); <line8> while (factories.hasNext()) { <line9> try { <line10> final ClusterClientFactory factory = factories.next(); <line11> if (factory != null && factory.isCompatibleWith(configuration)) { <line12> compatibleFactories.add(factory); <line13> } <line14> } catch (Throwable e) { <line15> if (e.getCause() instanceof NoClassDefFoundError) { <line16> } else { <line17> throw e; <line18> } <line19> } <line20> } <line21> if (compatibleFactories.size() > 1) { <line22> final List<String> configStr = <line23> configuration.toMap().entrySet().stream() <line24> .map(e -> e.getKey() + ""="" + e.getValue()) <line25> .collect(Collectors.toList()); <line26> throw new IllegalStateException( <line27> ""Multiple compatible client factories found for:\n"" + String.join(""\n"", configStr) + "".""); <line28> } <line29> if (compatibleFactories.isEmpty()) { <line30> throw new IllegalStateException( <line31> ""No ClusterClientFactory found. If you were targeting a Yarn cluster, please make sure to"" <line32> + "" export the HADOOP_CLASSPATH environment variable or have hadoop in your"" <line33> + "" classpath. For more information refer to the \""Deployment\"" section of the"" <line34> + "" official Apache Flink documentation.""); <line35> } <line36> return (ClusterClientFactory<ClusterID>) compatibleFactories.get(0); <line37> } <line38> } <line39> "	<line16>
5522	"public class A { <line0> @Override <line1> public void start() { <line2> Status status = MongoDBRiverHelper.getRiverStatus(esClient, riverName.getName()); <line3> if (status == Status.IMPORT_FAILED <line4> || status == Status.INITIAL_IMPORT_FAILED <line5> || status == Status.SCRIPT_IMPORT_FAILED <line6> || status == Status.START_FAILED) { <line7> return; <line8> } <line9> if (status == Status.STOPPED) { <line10> context.setStatus(Status.STOPPED); <line11> } else { <line12> context.setStatus(Status.START_PENDING); <line13> MongoDBRiverHelper.setRiverStatus(esClient, riverName.getName(), Status.RUNNING); <line14> } <line15> statusThread = <line16> EsExecutors.daemonThreadFactory( <line17> settings.globalSettings(), ""mongodb_river_status:"" + definition.getIndexName()) <line18> .newThread(new StatusChecker(this, definition, context)); <line19> statusThread.start(); <line20> } <line21> } <line22> "	<line2>, <line7>, <line11>, <line14>
5523	"public class A { <line0> @Override <line1> public void flush() throws IOException, JournalClosedException { <line2> if (mClosed) { <line3> throw new JournalClosedException(""Cannot flush. Journal writer has been closed""); <line4> } <line5> if (mJournalEntryBuilder != null) { <line6> long flushSN = mNextSequenceNumberToWrite.get() - 1; <line7> try { <line8> JournalEntry entry = mJournalEntryBuilder.build(); <line9> Message message = RaftJournalSystem.toRaftMessage(entry); <line10> mLastSubmittedSequenceNumber.set(flushSN); <line11> RaftClientReply reply = <line12> mClient <line13> .sendAsync(message, TimeDuration.valueOf(mWriteTimeoutMs, TimeUnit.MILLISECONDS)) <line14> .get(mWriteTimeoutMs, TimeUnit.MILLISECONDS); <line15> mLastCommittedSequenceNumber.set(flushSN); <line16> if (reply.getException() != null) { <line17> throw reply.getException(); <line18> } <line19> } catch (InterruptedException e) { <line20> Thread.currentThread().interrupt(); <line21> throw new IOException(e); <line22> } catch (ExecutionException e) { <line23> throw new IOException(e.getCause()); <line24> } catch (TimeoutException e) { <line25> throw new IOException( <line26> String.format( <line27> ""Timed out after waiting %s milliseconds for journal entries to be processed"", <line28> mWriteTimeoutMs), <line29> e); <line30> } <line31> mJournalEntryBuilder = null; <line32> } <line33> } <line34> } <line35> "	<line11>
5524	public class A { <line0> @Override <line1> public TryResult call() { <line2> TryResult r; <line3> try { <line4> j.outputObject.started(); <line5> String code = j.codeToBeExecuted; <line6> r = <line7> symjaEvaluator.executeTask( <line8> new SymjaMMACodeRunner(symjaEvaluator, code, j.outputObject), <line9> j.getExecutionOptions()); <line10> } catch (Throwable e) { <line11> if (e instanceof SymjaMMANotFoundException) { <line12> r = TryResult.createError(e.getLocalizedMessage()); <line13> } else { <line14> e.printStackTrace(); <line15> r = TryResult.createError(e.getLocalizedMessage()); <line16> } <line17> } <line18> return r; <line19> } <line20> } <line21> 	<line12>
5525	"public class A { <line0> private void startZookeeper() { <line1> client = CuratorUtils.newCuratorFrameworkClient(connectString, logger); <line2> client.start(); <line3> int startupTimeOutMs = <line4> Integer.parseInt(System.getProperty(Constants.Properties.ZK_STARTUP_TIMEOUT, ""30000"")); <line5> try { <line6> client.blockUntilConnected(startupTimeOutMs, TimeUnit.MILLISECONDS); <line7> } catch (InterruptedException ex) { <line8> } <line9> if (!client.getZookeeperClient().isConnected()) { <line10> throw new IllegalStateException(""Could not connect to ZooKeeper : "" + connectString); <line11> } <line12> } <line13> } <line14> "	<line3>, <line6>, <line8>, <line12>
5526	public class A { <line0> @Override <line1> public int execute(StratosCommandContext context, String[] args, Option[] alreadyParsedOpts) <line2> throws CommandException { <line3> if (log.isDebugEnabled()) { <line4> } <line5> if (args != null && args.length == 1) { <line6> String deploymentPolicyId = args[0]; <line7> if (log.isDebugEnabled()) { <line8> } <line9> RestCommandLineService.getInstance().describeDeploymentPolicy(deploymentPolicyId); <line10> return CliConstants.COMMAND_SUCCESSFULL; <line11> } else { <line12> context.getStratosApplication().printUsage(getName()); <line13> return CliConstants.COMMAND_FAILED; <line14> } <line15> } <line16> } <line17> 	<line4>, <line8>
5527	"public class A { <line0> protected List<NodeRef> processNodes( <line1> final Long batchSize, <line2> Long maxNodeId, <line3> final Pair<Long, QName> recordAspectPair, <line4> Long totalNumberOfRecordsToProcess, <line5> final BufferedWriter out, <line6> final boolean attach) { <line7> final Long maxRecordsToProcess = totalNumberOfRecordsToProcess; <line8> final List<NodeRef> processedNodes = new ArrayList<>(); <line9> for (Long i = 0L; i < maxNodeId; i += batchSize) { <line10> if (maxRecordsToProcess != 0 && processedNodes.size() >= maxRecordsToProcess) { <line11> break; <line12> } <line13> final Long currentIndex = i; <line14> transactionService <line15> .getRetryingTransactionHelper() <line16> .doInTransaction( <line17> new RetryingTransactionCallback<Void>() { <line18> public Void execute() throws Throwable { <line19> List<Long> nodeIds = <line20> patchDAO.getNodesByAspectQNameId( <line21> recordAspectPair.getFirst(), currentIndex, currentIndex + batchSize); <line22> for (Long nodeId : nodeIds) { <line23> if (maxRecordsToProcess != 0 && processedNodes.size() >= maxRecordsToProcess) { <line24> break; <line25> } <line26> NodeRef record = nodeDAO.getNodePair(nodeId).getSecond(); <line27> String recordName = <line28> (String) nodeService.getProperty(record, ContentModel.PROP_NAME); <line29> processNode(record); <line30> processedNodes.add(record); <line31> if (attach) { <line32> out.write(recordName); <line33> out.write("",""); <line34> out.write(record.toString()); <line35> out.write(""\n""); <line36> } <line37> } <line38> return null; <line39> } <line40> }, <line41> false, <line42> true); <line43> } <line44> return processedNodes; <line45> } <line46> } <line47> "	<line9>, <line29>, <line30>, <line44>
5528	public class A { <line0> @Override <line1> public boolean open(String offset) { <line2> try { <line3> if ((offset == null || offset.equals(FieldConstants.DefaultStartingOffset)) <line4> && spoutConfig.getEnqueueTimeFilter() != 0) { <line5> receiver.open(new EventHubFilter(Instant.ofEpochMilli(spoutConfig.getEnqueueTimeFilter()))); <line6> } else { <line7> receiver.open(new EventHubFilter(offset)); <line8> } <line9> lastOffset = offset; <line10> return true; <line11> } catch (EventHubException ex) { <line12> return false; <line13> } <line14> } <line15> } <line16> 	<line12>
5529	public class A { <line0> protected static void bdd_default_reshandler(int oldsize, int newsize) { <line1> int verbose = 1; <line2> if (verbose > 0) { <line3> } <line4> } <line5> } <line6> 	<line3>
5530	"public class A { <line0> public static String extractId(Response res) { <line1> MultivaluedMap<String, Object> mvm = res.getMetadata(); <line2> String uri = (String) ((ArrayList<Object>) mvm.get(""Location"")).get(0); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> String[] segments = uri.split(""/""); <line6> String id = segments[segments.length - 1]; <line7> if (logger.isDebugEnabled()) { <line8> } <line9> return id; <line10> } <line11> } <line12> "	<line4>, <line8>
5531	public class A { <line0> private boolean updateWebrootPathInfo( <line1> Node node, <line2> GraphFieldContainerEdge edge, <line3> String languageTag, <line4> String branchUuid, <line5> String segmentFieldName, <line6> String conflictI18n, <line7> ContainerType type) { <line8> NodeDaoWrapper nodeDao = Tx.get().nodeDao(); <line9> ContentDaoWrapper contentDao = Tx.get().contentDao(); <line10> String segment = contentDao.getPathSegment(node, branchUuid, type, getLanguageTag()); <line11> if (segment != null) { <line12> HibNode parentNode = nodeDao.getParentNode(node, branchUuid); <line13> String segmentInfo = GraphFieldContainerEdgeImpl.composeSegmentInfo(parentNode, segment); <line14> Object webRootIndexKey = <line15> GraphFieldContainerEdgeImpl.composeWebrootIndexKey(db(), segmentInfo, branchUuid, type); <line16> GraphFieldContainerEdge conflictingEdge = <line17> db().index().checkIndexUniqueness(WEBROOT_INDEX_NAME, edge, webRootIndexKey); <line18> if (conflictingEdge != null) { <line19> Node conflictingNode = conflictingEdge.getNode(); <line20> NodeGraphFieldContainer conflictingContainer = conflictingEdge.getNodeContainer(); <line21> if (log.isDebugEnabled()) { <line22> } <line23> throw nodeConflict( <line24> conflictingNode.getUuid(), <line25> conflictingContainer.getDisplayFieldValue(), <line26> conflictingContainer.getLanguageTag(), <line27> conflictI18n, <line28> segmentFieldName, <line29> segment); <line30> } else { <line31> edge.setSegmentInfo(segmentInfo); <line32> return true; <line33> } <line34> } else { <line35> edge.setSegmentInfo(null); <line36> return true; <line37> } <line38> } <line39> } <line40> 	<line22>
5532	"public class A { <line0> @GET <line1> @Timed <line2> @Produces(APPLICATION_JSON_WITH_CHARSET) <line3> public String get( <line4> @Context GraphManager manager, <line5> @PathParam(""graph"") String graph, <line6> @QueryParam(""source"") String sourceV, <line7> @QueryParam(""direction"") String direction, <line8> @QueryParam(""label"") String edgeLabel, <line9> @QueryParam(""max_depth"") int depth, <line10> @QueryParam(""max_degree"") @DefaultValue(DEFAULT_MAX_DEGREE) long maxDegree, <line11> @QueryParam(""capacity"") @DefaultValue(DEFAULT_CAPACITY) long capacity, <line12> @QueryParam(""limit"") @DefaultValue(DEFAULT_PATHS_LIMIT) long limit) { <line13> Id source = VertexAPI.checkAndParseVertexId(sourceV); <line14> Directions dir = Directions.convert(EdgeAPI.parseDirection(direction)); <line15> HugeGraph g = graph(manager, graph); <line16> SubGraphTraverser traverser = new SubGraphTraverser(g); <line17> HugeTraverser.PathSet paths = <line18> traverser.rays(source, dir, edgeLabel, depth, maxDegree, capacity, limit); <line19> return manager.serializer(g).writePaths(""rays"", paths, false); <line20> } <line21> } <line22> "	<line13>
5533	public class A { <line0> @Override <line1> public void geoServerGetStyleCommand( <line2> final org.locationtech.geowave.service.grpc.protobuf.GeoServerGetStyleCommandParametersProtos <line3> request, <line4> final StreamObserver< <line5> org.locationtech.geowave.service.grpc.protobuf.GeoWaveReturnTypesProtos <line6> .StringResponseProtos> <line7> responseObserver) { <line8> final GeoServerGetStyleCommand cmd = new GeoServerGetStyleCommand(); <line9> final Map<FieldDescriptor, Object> m = request.getAllFields(); <line10> GeoWaveGrpcServiceCommandUtil.setGrpcToCommandFields(m, cmd); <line11> final File configFile = GeoWaveGrpcServiceOptions.geowaveConfigFile; <line12> final OperationParams params = new ManualOperationParams(); <line13> params.getContext().put(ConfigOptions.PROPERTIES_FILE_CONTEXT, configFile); <line14> cmd.prepare(params); <line15> try { <line16> final String result = cmd.computeResults(params); <line17> final StringResponseProtos resp = <line18> StringResponseProtos.newBuilder().setResponseValue(result).build(); <line19> responseObserver.onNext(resp); <line20> responseObserver.onCompleted(); <line21> } catch (final Exception e) { <line22> responseObserver.onError(e); <line23> } <line24> } <line25> } <line26> 	<line15>, <line22>
5534	"public class A { <line0> public static com.liferay.mobile.device.rules.model.MDRAction updateAction( <line1> HttpPrincipal httpPrincipal, <line2> long actionId, <line3> java.util.Map<java.util.Locale, String> nameMap, <line4> java.util.Map<java.util.Locale, String> descriptionMap, <line5> String type, <line6> com.liferay.portal.kernel.util.UnicodeProperties typeSettingsUnicodeProperties, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey(MDRActionServiceUtil.class, ""updateAction"", _updateActionParameterTypes6); <line12> MethodHandler methodHandler = <line13> new MethodHandler( <line14> methodKey, <line15> actionId, <line16> nameMap, <line17> descriptionMap, <line18> type, <line19> typeSettingsUnicodeProperties, <line20> serviceContext); <line21> Object returnObj = null; <line22> try { <line23> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line24> } catch (Exception exception) { <line25> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line26> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line27> } <line28> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line29> } <line30> return (com.liferay.mobile.device.rules.model.MDRAction) returnObj; <line31> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line32> throw systemException; <line33> } <line34> } <line35> } <line36> "	<line32>
5535	public class A { <line0> private void deployQueuesFromListQueueConfiguration(List<QueueConfiguration> queues) <line1> throws Exception { <line2> for (QueueConfiguration config : queues) { <line3> try { <line4> QueueConfigurationUtils.applyDynamicQueueDefaults( <line5> config, addressSettingsRepository.getMatch(config.getAddress().toString())); <line6> config.setAutoCreateAddress(true); <line7> ActiveMQServerLogger.LOGGER.deployQueue( <line8> config.getName().toString(), <line9> config.getAddress().toString(), <line10> config.getRoutingType().toString()); <line11> if (locateQueue(config.getName()) != null <line12> && locateQueue(config.getName()).getAddress().equals(config.getAddress())) { <line13> config.setConfigurationManaged(true); <line14> setUnsetQueueParamsToDefaults(config); <line15> updateQueue(config, true); <line16> } else { <line17> try { <line18> createQueue( <line19> config <line20> .setTemporary(false) <line21> .setTransient(false) <line22> .setAutoCreated(false) <line23> .setConfigurationManaged(true) <line24> .setAutoCreateAddress(true), <line25> false); <line26> } catch (ActiveMQQueueExistsException e) { <line27> } <line28> } <line29> } catch (Exception e) { <line30> ActiveMQServerLogger.LOGGER.problemDeployingQueue( <line31> config.getName().toString(), e.getMessage()); <line32> } <line33> } <line34> } <line35> } <line36> 	<line27>
5536	"public class A { <line0> @Test <line1> public void testSendEndReceive() throws Exception { <line2> int nbMessages = 50; <line3> int failedMessages = 0; <line4> for (int i = 0; i < nbMessages; i++) { <line5> try { <line6> directProducer.sendBodyAndHeader(""Message #"" + i, RabbitMQConstants.ROUTING_KEY, ""rk3""); <line7> } catch (CamelExecutionException e) { <line8> failedMessages++; <line9> } <line10> Thread.sleep(500L); <line11> } <line12> producingMockEndpoint.expectedMessageCount(nbMessages - failedMessages); <line13> consumingMockEndpoint.expectedMessageCount(nbMessages - failedMessages); <line14> assertMockEndpointsSatisfied(5, TimeUnit.SECONDS); <line15> } <line16> } <line17> "	<line8>
5537	public class A { <line0> public void lock() { <line1> if (_locked) { <line2> return; <line3> } <line4> if (_log.isInfoEnabled()) { <line5> } <line6> _locked = true; <line7> } <line8> } <line9> 	<line5>
5538	public class A { <line0> List<Address> getAddressesFromOSMId(String url) { <line1> List<Address> addresses; <line2> try { <line3> addresses = <line4> singletonList( <line5> nominatimRestClient.exchange(url, GET, getHttpEntity(), Address.class).getBody()); <line6> } catch (RestClientException e) { <line7> addresses = null; <line8> } <line9> return addresses; <line10> } <line11> } <line12> 	<line6>
5539	"public class A { <line0> @Override <line1> public void insertIdeaInstance(IdeaInstance ideainstance) { <line2> PreparedStatement stat = null; <line3> Connection conn = null; <line4> try { <line5> conn = this.getConnection(); <line6> conn.setAutoCommit(false); <line7> this.insertIdeaInstance(ideainstance, conn); <line8> this.insertIdeaInstanceGroups(ideainstance.getCode(), ideainstance.getGroups(), conn); <line9> conn.commit(); <line10> } catch (Throwable t) { <line11> this.executeRollback(conn); <line12> throw new RuntimeException(""Error creating ideainstance"", t); <line13> } finally { <line14> this.closeDaoResources(null, stat, conn); <line15> } <line16> } <line17> } <line18> "	<line12>
5540	"public class A { <line0> @Override <line1> public void configure() { <line2> from(""natsBasicAuth:test"").routeId(""basic-auth"").bean(natsResource, ""storeMessage""); <line3> from(""natsNoAuth:test"").routeId(""no-auth"").bean(natsResource, ""storeMessage""); <line4> from(""natsTokenAuth:test"").routeId(""token-auth"").bean(natsResource, ""storeMessage""); <line5> if (tlsTestsEnabled) { <line6> final String uri = ""natsTlsAuth:test?sslContextParameters=#ssl&secure=true""; <line7> from(uri).routeId(""tls-auth"").bean(natsResource, ""storeMessage""); <line8> } else { <line9> } <line10> from(""natsNoAuth:max?maxMessages=2"").routeId(""2-msg-max"").bean(natsResource, ""storeMessage""); <line11> String maxMsgUriPattern = ""natsNoAuth:qmax?maxMessages=%s&queueName=q""; <line12> fromF(maxMsgUriPattern, 3).routeId(""3-qmsg-max"").bean(natsResource, ""storeMessage""); <line13> fromF(maxMsgUriPattern, 8).routeId(""8-qmsg-max"").bean(natsResource, ""storeMessage""); <line14> from(""natsNoAuth:request-reply"").setBody().simple(""${body} => Reply""); <line15> from(""natsNoAuth:reply"").routeId(""reply"").bean(natsResource, ""storeMessage""); <line16> } <line17> } <line18> "	<line6>, <line9>
5541	"public class A { <line0> @Test <line1> public void testNoDeadlock() throws Exception { <line2> for (int i = 2; i <= 10; i++) { <line3> final int threads = i; <line4> final AtomicInteger threadCnt = new AtomicInteger(); <line5> final AtomicBoolean deadlock = new AtomicBoolean(); <line6> final AtomicBoolean timedOut = new AtomicBoolean(); <line7> final CyclicBarrier barrier = new CyclicBarrier(threads); <line8> final long timeout = 500; <line9> IgniteInternalFuture<Long> fut = <line10> GridTestUtils.runMultiThreadedAsync( <line11> new Runnable() { <line12> @Override <line13> public void run() { <line14> int threadNum = threadCnt.incrementAndGet(); <line15> Ignite ignite = ignite(threadNum % NODES_CNT); <line16> IgniteCache<Integer, Integer> cache = ignite.cache(CACHE); <line17> try (Transaction tx = <line18> ignite.transactions().txStart(PESSIMISTIC, REPEATABLE_READ, timeout, 0)) { <line19> int key1 = threadNum; <line20> cache.put(key1, 0); <line21> barrier.await(); <line22> if (threadNum == threads) { <line23> U.sleep(timeout * 3); <line24> } else { <line25> int key2 = threadNum + 1; <line26> cache.put(key2, 1); <line27> } <line28> tx.commit(); <line29> } catch (Exception e) { <line30> if (hasCause(e, TransactionTimeoutException.class)) timedOut.set(true); <line31> if (hasCause(e, TransactionDeadlockException.class)) deadlock.set(true); <line32> } <line33> } <line34> }, <line35> threads, <line36> ""tx-thread""); <line37> fut.get(); <line38> assertTrue(timedOut.get()); <line39> assertFalse(deadlock.get()); <line40> checkDetectionFuts(); <line41> } <line42> } <line43> } <line44> "	<line4>, <line20>, <line23>, <line26>
5542	"public class A { <line0> private String validatePostLogoutRedirectUri( <line1> String postLogoutRedirectUri, Pair<SessionId, AuthorizationGrant> pair) { <line2> try { <line3> if (StringUtils.isBlank(postLogoutRedirectUri)) { <line4> return """"; <line5> } <line6> if (appConfiguration.getAllowPostLogoutRedirectWithoutValidation()) { <line7> return postLogoutRedirectUri; <line8> } <line9> final String result; <line10> if (pair.getSecond() == null) { <line11> result = <line12> redirectionUriService.validatePostLogoutRedirectUri( <line13> pair.getFirst(), postLogoutRedirectUri); <line14> } else { <line15> result = <line16> redirectionUriService.validatePostLogoutRedirectUri( <line17> pair.getSecond().getClient().getClientId(), postLogoutRedirectUri); <line18> } <line19> if (StringUtils.isBlank(result)) { <line20> throw new WebApplicationException( <line21> createErrorResponse( <line22> postLogoutRedirectUri, <line23> EndSessionErrorResponseType.POST_LOGOUT_URI_NOT_ASSOCIATED_WITH_CLIENT, <line24> """")); <line25> } <line26> if (StringUtils.isNotBlank(result)) { <line27> return result; <line28> } <line29> throw new WebApplicationException( <line30> createErrorResponse( <line31> postLogoutRedirectUri, <line32> EndSessionErrorResponseType.POST_LOGOUT_URI_NOT_ASSOCIATED_WITH_CLIENT, <line33> """")); <line34> } catch (WebApplicationException e) { <line35> if (pair.getFirst() != null) { <line36> throw new WebApplicationException( <line37> createErrorResponse( <line38> postLogoutRedirectUri, <line39> EndSessionErrorResponseType.POST_LOGOUT_URI_NOT_ASSOCIATED_WITH_CLIENT, <line40> """")); <line41> } else { <line42> throw e; <line43> } <line44> } <line45> } <line46> } <line47> "	<line7>, <line20>, <line29>, <line36>
5543	public class A { <line0> @Override <line1> public int getAcknowledgeMode() throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> getSessionInternal(); <line5> return cri.getAcknowledgeMode(); <line6> } <line7> } <line8> 	<line3>
5544	"public class A { <line0> public static com.liferay.bookmarks.model.BookmarksEntry getEntry( <line1> HttpPrincipal httpPrincipal, long entryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(BookmarksEntryServiceUtil.class, ""getEntry"", _getEntryParameterTypes6); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, entryId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.bookmarks.model.BookmarksEntry) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>
5545	"public class A { <line0> public int registerNewPURL(String purl, String target, String type, String maintainers) { <line1> int response = 0; <line2> HttpURLConnection conn = null; <line3> try { <line4> URL url = new URL(purlServerBaseURL + PURL_PATH + purl); <line5> String data = ""target="" + URLEncoder.encode(target, StandardCharsets.UTF_8); <line6> data += ""&maintainers="" + maintainers; <line7> data += ""&type="" + type; <line8> conn = (HttpURLConnection) url.openConnection(); <line9> conn.setRequestProperty(COOKIE_HEADER_PARAM, cookie); <line10> conn.setRequestMethod(""POST""); <line11> conn.setDoOutput(true); <line12> try (OutputStreamWriter wr = <line13> new OutputStreamWriter(conn.getOutputStream(), StandardCharsets.UTF_8)) { <line14> wr.write(data); <line15> wr.flush(); <line16> } <line17> response = conn.getResponseCode(); <line18> if (response != 200 && conn.getErrorStream() != null && LOGGER.isErrorEnabled()) { <line19> try (BufferedReader rd = <line20> new BufferedReader( <line21> new InputStreamReader(conn.getErrorStream(), StandardCharsets.UTF_8))) { <line22> String line; <line23> while ((line = rd.readLine()) != null) { <line24> } <line25> } <line26> } <line27> } catch (Exception e) { <line28> } finally { <line29> if (conn != null) { <line30> conn.disconnect(); <line31> } <line32> } <line33> return response; <line34> } <line35> } <line36> "	<line5>, <line8>, <line24>, <line28>
5546	public class A { <line0> @Override <line1> public void onCommunicationFailure(BinaryLogClient client, Exception ex) { <line2> logReaderState(); <line3> try { <line4> client.disconnect(); <line5> } catch (final Exception e) { <line6> } <line7> BinlogReader.this.failed(ex); <line8> } <line9> } <line10> 	<line2>, <line6>
5547	"public class A { <line0> private void postUnbindVirtLimit( <line1> PoolManager poolManager, <line2> Entitlement entitlement, <line3> Pool pool, <line4> Consumer consumer, <line5> Map<String, String> attributes) { <line6> ConsumerType ctype = this.consumerTypeCurator.getConsumerType(consumer); <line7> boolean hostLimited = ""true"".equals(attributes.get(Product.Attributes.HOST_LIMITED)); <line8> if (!config.getBoolean(ConfigProperties.STANDALONE) && !hostLimited && ctype.isManifest()) { <line9> String virtLimit = attributes.get(Product.Attributes.VIRT_LIMIT); <line10> if (!""unlimited"".equals(virtLimit)) { <line11> int virtQuantity = Integer.parseInt(virtLimit) * entitlement.getQuantity(); <line12> if (virtQuantity > 0) { <line13> List<Pool> pools = <line14> poolManager.getBySubscriptionId(pool.getOwner(), pool.getSubscriptionId()); <line15> for (int idex = 0; idex < pools.size(); idex++) { <line16> Pool derivedPool = pools.get(idex); <line17> if (derivedPool.getAttributeValue(Pool.Attributes.DERIVED_POOL) != null) { <line18> poolManager.setPoolQuantity(derivedPool, derivedPool.adjustQuantity(virtQuantity)); <line19> } <line20> } <line21> } <line22> } else { <line23> List<Pool> pools = <line24> poolManager.getBySubscriptionId(pool.getOwner(), pool.getSubscriptionId()); <line25> for (int idex = 0; idex < pools.size(); idex++) { <line26> Pool derivedPool = pools.get(idex); <line27> if (derivedPool.getAttributeValue(Pool.Attributes.DERIVED_POOL) != null <line28> && derivedPool.getQuantity() == 0) { <line29> poolManager.setPoolQuantity(derivedPool, -1); <line30> } <line31> } <line32> } <line33> } <line34> } <line35> } <line36> "	<line6>
5548	"public class A { <line0> private ITupleIterator transformToTupleIterator( <line1> final StreamingTupleConverter tupleConverter, <line2> final IStreamingSearchResult searchResult, <line3> final TupleInfo returnTupleInfo) { <line4> final Tuple tuple = new Tuple(returnTupleInfo); <line5> final Iterator<Record> recordIterator = searchResult.iterator(); <line6> return new ITupleIterator() { <line7> @Override <line8> public void close() { <line9> try { <line10> searchResult.close(); <line11> } catch (IOException e) { <line12> } <line13> } <line14>  <line15> @Override <line16> public boolean hasNext() { <line17> return recordIterator.hasNext(); <line18> } <line19>  <line20> @Override <line21> public ITuple next() { <line22> tupleConverter.translateResult(recordIterator.next(), tuple); <line23> return tuple; <line24> } <line25>  <line26> @Override <line27> public void remove() { <line28> throw new UnsupportedOperationException(""not support""); <line29> } <line30> }; <line31> } <line32> } <line33> "	<line12>
5549	"public class A { <line0> @Test <line1> public void testApiHTML() throws Exception { <line2> MockHttpServletResponse response = <line3> getAsMockHttpServletResponse(""ogc/images/api?f=text/html"", 200); <line4> assertEquals(""text/html"", response.getContentType()); <line5> String html = response.getContentAsString(); <line6> assertThat( <line7> html, <line8> containsString( <line9> ""<link rel=\""icon\"" type=\""image/png\"""" <line10> + "" href=\""http://localhost:8080/geoserver/swagger-ui/favicon-32x32.png\"""" <line11> + "" sizes=\""32x32\"" />"")); <line12> assertThat( <line13> html, <line14> containsString( <line15> ""<link rel=\""icon\"" type=\""image/png\"""" <line16> + "" href=\""http://localhost:8080/geoserver/swagger-ui/favicon-16x16.png\"""" <line17> + "" sizes=\""16x16\"" />"")); <line18> assertThat( <line19> html, <line20> containsString( <line21> ""<script src=\""http://localhost:8080/geoserver/swagger-ui/swagger-ui-bundle.js\"">"")); <line22> assertThat( <line23> html, <line24> containsString( <line25> ""<script"" <line26> + "" src=\""http://localhost:8080/geoserver/swagger-ui/swagger-ui-standalone-preset.js\"">"")); <line27> assertThat( <line28> html, <line29> containsString( <line30> ""url: \""http://localhost:8080/geoserver/ogc/images/api?f=application%2Fvnd.oai.openapi%2Bjson%3Bversion%3D3.0\"""")); <line31> } <line32> } <line33> "	<line6>
5550	public class A { <line0> private <T> int removeByFilter( <line1> final String key, <line2> final Class<T> deserializeClass, <line3> final Filter<T> filter, <line4> final Object... params) { <line5> try { <line6> Map<byte[], byte[]> dataAll = jedisClient.hgetAll(key.getBytes()); <line7> if (Objects.isNull(dataAll)) { <line8> return HmilyRepository.FAIL_ROWS; <line9> } <line10> int count = 0; <line11> for (Entry<byte[], byte[]> entry : dataAll.entrySet()) { <line12> byte[] data = entry.getValue(); <line13> if (data == null) { <line14> continue; <line15> } <line16> T t = hmilySerializer.deSerialize(data, deserializeClass); <line17> if (filter.filter(t, params)) { <line18> jedisClient.hdel(rootPathPrefix, key); <line19> count++; <line20> } <line21> return count; <line22> } <line23> } catch (JedisException e) { <line24> } <line25> return HmilyRepository.FAIL_ROWS; <line26> } <line27> } <line28> 	<line24>
5551	public class A { <line0> protected MetacardMapper lookupMetacardAttributeToFeaturePropertyMapper( <line1> QName featureType, List<MetacardMapper> metacardMapperList) { <line2> final Predicate<MetacardMapper> matchesFeatureType = <line3> mapper -> mapper.getFeatureType().equals(featureType.toString()); <line4> return metacardMapperList.stream() <line5> .filter(matchesFeatureType) <line6> .findAny() <line7> .orElseGet( <line8> () -> { <line9> return null; <line10> }); <line11> } <line12> } <line13> 	<line9>
5552	public class A { <line0> @Override <line1> public void add(Entry entry) throws LdapException { <line2> Dn dn = entry.getDn(); <line3> Dn parentDn = dn.getParent(); <line4> checkParent(parentDn, schemaManager, SchemaConstants.SYNTAX_CHECKER); <line5> checkOidIsUniqueForSyntaxChecker(entry); <line6> String schemaName = getSchemaName(dn); <line7> SyntaxChecker syntaxChecker = <line8> factory.getSyntaxChecker(schemaManager, entry, schemaManager.getRegistries(), schemaName); <line9> Schema schema = schemaManager.getLoadedSchema(schemaName); <line10> if (schema.isEnabled() && syntaxChecker.isEnabled()) { <line11> if (schemaManager.add(syntaxChecker)) { <line12> } else { <line13> String msg = <line14> I18n.err( <line15> I18n.ERR_386, <line16> entry.getDn().getName(), <line17> Strings.listToString(schemaManager.getErrors())); <line18> throw new LdapUnwillingToPerformException(ResultCodeEnum.UNWILLING_TO_PERFORM, msg); <line19> } <line20> } else { <line21> } <line22> } <line23> } <line24> 	<line12>, <line18>, <line21>
5553	public class A { <line0> private boolean allVolumeSizesMatch(List<Long> currentVolumeSizes) { <line1> List<Long> currentVolumeSizesCopy = new ArrayList<Long>(); <line2> currentVolumeSizesCopy.addAll(currentVolumeSizes); <line3> for (Long currentSize : currentVolumeSizes) { <line4> for (Long compareSize : currentVolumeSizesCopy) { <line5> if (currentSize.longValue() != compareSize.longValue()) { <line6> return false; <line7> } <line8> } <line9> } <line10> return true; <line11> } <line12> } <line13> 	<line10>
5554	public class A { <line0> @Override <line1> public void onParentStatusEvent(final MonitorStatusEvent statusEvent) { <line2> Runnable monitoringRunnable = <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> String instanceId = statusEvent.getInstanceId(); <line7> if (statusEvent.getStatus() == GroupStatus.Terminating <line8> || statusEvent.getStatus() == ApplicationStatus.Terminating) { <line9> if (log.isInfoEnabled()) { <line10> } <line11> ClusterStatusEventPublisher.sendClusterStatusClusterTerminatingEvent( <line12> getAppId(), getServiceId(), getClusterId(), instanceId); <line13> } <line14> } <line15> }; <line16> executorService.execute(monitoringRunnable); <line17> } <line18> } <line19> 	<line10>
5555	"public class A { <line0> protected void sendSubscribe(String destination) { <line1> StringBuilder sb = new StringBuilder(); <line2> sb.append(STOMP.ClientVerb.SUBSCRIBE.name()) <line3> .append(""\n"") <line4> .append(""destination: "") <line5> .append(destination) <line6> .append(""\n\n""); <line7> try { <line8> synchronized (this) { <line9> out.write(sb.toString().getBytes()); <line10> out.write(STOMP.NULL_BYTE); <line11> out.flush(); <line12> } <line13> } catch (IOException ex) { <line14> } <line15> } <line16> } <line17> "	<line14>
5556	"public class A { <line0> @Override <line1> public synchronized BlobSupportDataRow next() { <line2> if (!hasNext()) { <line3> throw new NoSuchElementException(""Iterator at end""); <line4> } <line5> final BlockableDCObjectInputVersion2 inStream = m_inStream; <line6> int colCount = m_tableFormatReader.getTableSpec().getNumColumns(); <line7> if (inStream == null) { <line8> if (m_missingCellsForClosedTable == null) { <line9> m_missingCellsForClosedTable = new DataCell[colCount]; <line10> Arrays.fill(m_missingCellsForClosedTable, DataType.getMissingCell()); <line11> } <line12> RowKey key = new RowKey(""INVALID_ROW (table is closed) - (Row "" + m_pointer + "")""); <line13> m_pointer++; <line14> return new BlobSupportDataRow(key, m_missingCellsForClosedTable); <line15> } <line16> RowKey key; <line17> try { <line18> key = readRowKeyAndEndBlock(inStream); <line19> } catch (Exception throwable) { <line20> handleReadThrowable(throwable); <line21> String keyS = ""Read_failed__auto_generated_key_"" + m_pointer; <line22> key = new RowKey(keyS); <line23> } <line24> DataCell[] cells = new DataCell[colCount]; <line25> for (int i = 0; i < colCount; i++) { <line26> DataCell nextCell; <line27> try { <line28> try { <line29> nextCell = m_dataCellStreamReader.readDataCell(m_inStream); <line30> } finally { <line31> m_inStream.endBlock(); <line32> } <line33> } catch (final Exception e) { <line34> handleReadThrowable(e); <line35> nextCell = DataType.getMissingCell(); <line36> } <line37> cells[i] = nextCell; <line38> } <line39> try { <line40> byte eoRow = inStream.readControlByte(); <line41> if (eoRow != BYTE_ROW_SEPARATOR) { <line42> throw new IOException( <line43> ""Expected end of row byte, got '"" + eoRow + ""', (byte "" + (int) eoRow + "")""); <line44> } <line45> } catch (IOException ioe) { <line46> handleReadThrowable(ioe); <line47> } finally { <line48> m_pointer++; <line49> } <line50> return new BlobSupportDataRow(key, cells); <line51> } <line52> } <line53> "	<line11>
5557	"public class A { <line0> @Override <line1> public String getURL(PortletRequest portletRequest, PortletResponse portletResponse) { <line2> try { <line3> LiferayPortletURL portletURL = <line4> PortletURLFactoryUtil.create( <line5> portletRequest, <line6> PortletConfigurationSharingPortletKeys.PORTLET_CONFIGURATION_SHARING, <line7> PortletRequest.RENDER_PHASE); <line8> portletURL.setParameter(""netvibesURL"", getWidgetURL(portletRequest)); <line9> portletURL.setWindowState(LiferayWindowState.POP_UP); <line10> return portletURL.toString(); <line11> } catch (Exception exception) { <line12> return StringPool.BLANK; <line13> } <line14> } <line15> } <line16> "	<line12>
5558	public class A { <line0> public List<InternetRadioSource> getInternetRadioSources(InternetRadio radio) { <line1> List<InternetRadioSource> sources; <line2> if (cachedSources.containsKey(radio.getId())) { <line3> sources = cachedSources.get(radio.getId()); <line4> } else { <line5> try { <line6> sources = retrieveInternetRadioSources(radio); <line7> if (sources.isEmpty()) { <line8> } else { <line9> } <line10> } catch (Exception e) { <line11> sources = new ArrayList<>(); <line12> } <line13> cachedSources.put(radio.getId(), sources); <line14> } <line15> return sources; <line16> } <line17> } <line18> 	<line3>, <line5>, <line8>, <line9>, <line11>
5559	"public class A { <line0> private void testDeleteByQueryFields(DataStore<String, WebPage> store) throws Exception { <line1> int NUM_KEYS = 4; <line2> Query<String, WebPage> query; <line3> WebPageDataCreator.createWebPageData(store); <line4> query = store.newQuery(); <line5> query.setFields(""outlinks"", ""parsedContent"", ""content""); <line6> DataStoreTestUtil.assertNumResults(store.newQuery(), URLS.length); <line7> store.deleteByQuery(query); <line8> store.flush(); <line9> DataStoreTestUtil.assertNumResults(store.newQuery(), URLS.length); <line10> for (String SORTED_URL : SORTED_URLS) { <line11> WebPage page = store.get(SORTED_URL); <line12> assertNotNull(page); <line13> assertNotNull(page.getUrl()); <line14> assertEquals(page.getUrl().toString(), SORTED_URL); <line15> assertEquals( <line16> ""Map of Outlinks should have a size of '0' as the deleteByQuery "" <line17> + ""not only removes the data but also the data structure."", <line18> 0, <line19> page.getOutlinks().size()); <line20> assertEquals(0, page.getParsedContent().size()); <line21> if (page.getContent() != null) { <line22> } else { <line23> assertNull(page.getContent()); <line24> } <line25> } <line26> WebPageDataCreator.createWebPageData(store); <line27> query = store.newQuery(); <line28> query.setFields(""url""); <line29> String startKey = SORTED_URLS[NUM_KEYS]; <line30> String endKey = SORTED_URLS[SORTED_URLS.length - NUM_KEYS]; <line31> query.setStartKey(startKey); <line32> query.setEndKey(endKey); <line33> DataStoreTestUtil.assertNumResults(store.newQuery(), URLS.length); <line34> store.deleteByQuery(query); <line35> store.flush(); <line36> DataStoreTestUtil.assertNumResults(store.newQuery(), URLS.length - 3); <line37> for (int i = 0; i < URLS.length; i++) { <line38> WebPage page = store.get(URLS[i]); <line39> if (URLS[i].compareTo(startKey) < 0 || URLS[i].compareTo(endKey) > 0) { <line40> DataStoreTestUtil.assertWebPage(page, i); <line41> } else { <line42> assertNull(page); <line43> } <line44> } <line45> } <line46> } <line47> "	<line22>
5560	public class A { <line0> @Override <line1> public void frameworkMessage(ExecutorDriver executorDriver, byte[] bytes) { <line2> try { <line3> messageHandler.handleMessage(bytes); <line4> } catch (Throwable t) { <line5> } <line6> } <line7> } <line8> 	<line5>
5561	public class A { <line0> @Test <line1> public void checkSubscribeToEntityUpdatePATCH() { <line2> deleteCreatedEntities(); <line3> createEntities(); <line4> waitMillis(WAIT_AFTER_CLEANUP); <line5> ENTITY_TYPES_FOR_CREATE.stream() <line6> .forEach( <line7> (entityType) -> { <line8> MqttBatchResult<JSONObject> result = <line9> mqttHelper.executeRequests( <line10> getUpdatePatchEntityAction(entityType), <line11> mqttHelper.getTopic(entityType, IDS.get(entityType))); <line12> assertJsonEqualsWithLinkResolving( <line13> result.getActionResult(), <line14> result.getMessages().values().iterator().next(), <line15> mqttHelper.getTopic(entityType, IDS.get(entityType))); <line16> }); <line17> } <line18> } <line19> 	<line2>, <line8>
5562	"public class A { <line0> protected final int getStreamPortFromAnswer(String answer) throws ConnectException { <line1> int port = -1; <line2> if (answer != null && answer.startsWith(STREAM_PORT_STRING)) { <line3> String portSubstring = answer.substring(STREAM_PORT_STRING.length()); <line4> try { <line5> port = Integer.parseInt(portSubstring); <line6> } catch (NumberFormatException nfe) { <line7> } <line8> } <line9> if (port <= 0) { <line10> throw new ConnectException(""\""PORT nn\"" expected - unable to parse: "" + ""\"""" + answer + ""\""""); <line11> } <line12> return port; <line13> } <line14> } <line15> "	<line7>
5563	"public class A { <line0> @SuppressWarnings(""squid:S1126"") <line1> private boolean checkSystemIfUniqueValidationNeeded( <line2> final System system, <line3> final String validatedSystemName, <line4> final String validatedAddress, <line5> final Integer validatedPort) { <line6> final String actualSystemName = system.getSystemName(); <line7> final String actualAddress = system.getAddress(); <line8> final int actualPort = system.getPort(); <line9> if (validatedSystemName != null && !actualSystemName.equalsIgnoreCase(validatedSystemName)) { <line10> return true; <line11> } else if (validatedAddress != null && !actualAddress.equalsIgnoreCase(validatedAddress)) { <line12> return true; <line13> } else { <line14> return validatedPort != null && actualPort != validatedPort; <line15> } <line16> } <line17> } <line18> "	<line6>
5564	public class A { <line0> private void postProcessRemoveRec( <line1> ITreeNode node, ITree formerTree, boolean includeSubtree, boolean dispose) { <line2> if (includeSubtree) { <line3> for (ITreeNode ch : node.getChildNodes()) { <line4> postProcessRemoveRec(ch, formerTree, includeSubtree, dispose); <line5> } <line6> } <line7> if (formerTree != null) { <line8> try { <line9> node.nodeRemovedNotify(); <line10> if (dispose) { <line11> node.dispose(); <line12> } <line13> } catch (Exception t) { <line14> } <line15> } <line16> } <line17> } <line18> 	<line14>
5565	"public class A { <line0> public static TopicMetadata getTopicMetadata(Set<String> brokerSet, String topic) { <line1> SimpleConsumer mdConsumer = null; <line2> if (brokerSet == null || brokerSet == null || brokerSet.size() == 0) { <line3> return null; <line4> } <line5> try { <line6> for (Iterator<String> iterator = brokerSet.iterator(); iterator.hasNext(); ) { <line7> String broker = iterator.next(); <line8> try { <line9> mdConsumer = <line10> new SimpleConsumer( <line11> broker.split("":"")[0], <line12> Integer.parseInt(broker.split("":"")[1]), <line13> timeout, <line14> bufferSize, <line15> mdClientId); <line16> List<String> topics = new ArrayList<String>(1); <line17> topics.add(topic); <line18> kafka.javaapi.TopicMetadataRequest req = new kafka.javaapi.TopicMetadataRequest(topics); <line19> TopicMetadataResponse resp = mdConsumer.send(req); <line20> List<TopicMetadata> metaData = resp.topicsMetadata(); <line21> for (TopicMetadata item : metaData) { <line22> return item; <line23> } <line24> } catch (NumberFormatException e) { <line25> throw new IllegalArgumentException( <line26> ""Wrong format for broker url, should be \""broker1:port1\""""); <line27> } catch (Exception e) { <line28> } <line29> } <line30> return null; <line31> } finally { <line32> if (mdConsumer != null) { <line33> mdConsumer.close(); <line34> } <line35> } <line36> } <line37> } <line38> "	<line8>, <line28>
5566	public class A { <line0> List<VirtualAssetTextUnit> getLocalizedTextUnitsForTargetLocale( <line1> Asset asset, RepositoryLocale repositoryLocale, InheritanceMode inheritanceMode) { <line2> List<VirtualAssetTextUnit> virtualAssetTextUnits = new ArrayList<>(); <line3> Long lastSuccessfulAssetExtractionId = asset.getLastSuccessfulAssetExtraction().getId(); <line4> List<AssetTextUnitDTO> findByAssetExtractionAssetId = <line5> findByAssetExtractionIdAndDoNotTranslateFilter(lastSuccessfulAssetExtractionId, null); <line6> TranslatorWithInheritance translatorWithInheritance = <line7> new TranslatorWithInheritance(asset, repositoryLocale, inheritanceMode); <line8> for (AssetTextUnitDTO assetTextUnit : findByAssetExtractionAssetId) { <line9> String translation = <line10> translatorWithInheritance.getTranslation( <line11> assetTextUnit.getContent(), assetTextUnit.getMd5()); <line12> if (translation == null && InheritanceMode.REMOVE_UNTRANSLATED.equals(inheritanceMode)) { <line13> } else { <line14> VirtualAssetTextUnit virtualAssetTextUnit = <line15> convertAssetTextUnitDTOToVirtualAssetTextUnit(assetTextUnit); <line16> virtualAssetTextUnit.setContent(translation); <line17> virtualAssetTextUnits.add(virtualAssetTextUnit); <line18> } <line19> } <line20> return virtualAssetTextUnits; <line21> } <line22> } <line23> 	<line2>, <line13>, <line14>
5567	"public class A { <line0> @GET <line1> @Timed <line2> @Compress <line3> @Produces(APPLICATION_JSON_WITH_CHARSET) <line4> @RolesAllowed({""admin"", ""$owner=$graph $action=vertex_read""}) <line5> public String list( <line6> @Context GraphManager manager, <line7> @PathParam(""graph"") String graph, <line8> @QueryParam(""label"") String label, <line9> @QueryParam(""properties"") String properties, <line10> @QueryParam(""keep_start_p"") @DefaultValue(""false"") boolean keepStartP, <line11> @QueryParam(""offset"") @DefaultValue(""0"") long offset, <line12> @QueryParam(""page"") String page, <line13> @QueryParam(""limit"") @DefaultValue(""100"") long limit) { <line14> Map<String, Object> props = parseProperties(properties); <line15> if (page != null) { <line16> E.checkArgument( <line17> offset == 0, ""Not support querying vertices based on paging "" + ""and offset together""); <line18> } <line19> HugeGraph g = graph(manager, graph); <line20> GraphTraversal<Vertex, Vertex> traversal = g.traversal().V(); <line21> if (label != null) { <line22> traversal = traversal.hasLabel(label); <line23> } <line24> for (Map.Entry<String, Object> prop : props.entrySet()) { <line25> Object value = prop.getValue(); <line26> if (!keepStartP <line27> && value instanceof String <line28> && ((String) value).startsWith(TraversalUtil.P_CALL)) { <line29> prop.setValue(TraversalUtil.parsePredicate((String) value)); <line30> } <line31> } <line32> for (Map.Entry<String, Object> entry : props.entrySet()) { <line33> traversal = traversal.has(entry.getKey(), entry.getValue()); <line34> } <line35> if (page == null) { <line36> traversal = traversal.range(offset, offset + limit); <line37> } else { <line38> traversal = traversal.has(QueryHolder.SYSPROP_PAGE, page).limit(limit); <line39> } <line40> try { <line41> return manager.serializer(g).writeVertices(traversal, page != null); <line42> } finally { <line43> if (g.tx().isOpen()) { <line44> g.tx().close(); <line45> } <line46> } <line47> } <line48> } <line49> "	<line14>
5568	public class A { <line0> public void initializeSession() { <line1> SessionId sessionId = sessionIdService.getSessionId(); <line2> Map<String, String> sessionAttributes = new HashMap<>(); <line3> if (StringUtils.isNotBlank(userCode)) { <line4> sessionAttributes.put(SESSION_USER_CODE, userCode); <line5> } <line6> if (sessionId == null) { <line7> SessionId deviceAuthzSession = <line8> sessionIdService.generateUnauthenticatedSessionId( <line9> null, new Date(), SessionIdState.UNAUTHENTICATED, sessionAttributes, false); <line10> sessionIdService.persistSessionId(deviceAuthzSession); <line11> cookieService.createSessionIdCookie(deviceAuthzSession, false); <line12> } else { <line13> if (StringUtils.isNotBlank(sessionId.getSessionAttributes().get(SESSION_LAST_ATTEMPT)) <line14> && StringUtils.isNotBlank(sessionId.getSessionAttributes().get(SESSION_ATTEMPTS))) { <line15> lastAttempt = Long.parseLong(sessionId.getSessionAttributes().get(SESSION_LAST_ATTEMPT)); <line16> attempts = Byte.parseByte(sessionId.getSessionAttributes().get(SESSION_ATTEMPTS)); <line17> } <line18> sessionAttributes.put(SESSION_LAST_ATTEMPT, String.valueOf(lastAttempt)); <line19> sessionAttributes.put(SESSION_ATTEMPTS, String.valueOf(attempts)); <line20> sessionId.setSessionAttributes(sessionAttributes); <line21> sessionIdService.updateSessionId(sessionId); <line22> } <line23> } <line24> } <line25> 	<line12>
5569	"public class A { <line0> @Override <line1> public List<Long> listPodIdsHavingVmsforAccount(long zoneId, long accountId) { <line2> TransactionLegacy txn = TransactionLegacy.currentTxn(); <line3> List<Long> result = new ArrayList<Long>(); <line4> String sql = LIST_PODS_HAVING_VMS_FOR_ACCOUNT; <line5> try (PreparedStatement pstmt = txn.prepareStatement(sql)) { <line6> pstmt.setLong(1, zoneId); <line7> pstmt.setLong(2, accountId); <line8> try (ResultSet rs = pstmt.executeQuery(); ) { <line9> while (rs.next()) { <line10> result.add(rs.getLong(1)); <line11> } <line12> } catch (Exception e) { <line13> throw new CloudRuntimeException( <line14> ""listPodIdsHavingVmsforAccount:Exception: "" + e.getMessage(), e); <line15> } <line16> txn.commit(); <line17> return result; <line18> } catch (Exception e) { <line19> throw new CloudRuntimeException( <line20> ""listPodIdsHavingVmsforAccount:Exception: "" + e.getMessage(), e); <line21> } finally { <line22> try { <line23> if (txn != null) { <line24> txn.close(); <line25> } <line26> } catch (Exception e) { <line27> } <line28> } <line29> } <line30> } <line31> "	<line13>, <line19>, <line27>
5570	"public class A { <line0> @Test <line1> public void testDeepWalk() throws Exception { <line2> Heartbeat.getInstance().disableHeartbeat(); <line3> AbstractCache<Blogger> vocabCache = new AbstractCache.Builder<Blogger>().build(); <line4> Graph<Blogger, Double> graph = buildGraph(); <line5> GraphWalker<Blogger> walker = <line6> new PopularityWalker.Builder<>(graph) <line7> .setNoEdgeHandling(NoEdgeHandling.RESTART_ON_DISCONNECTED) <line8> .setWalkLength(40) <line9> .setWalkDirection(WalkDirection.FORWARD_UNIQUE) <line10> .setRestartProbability(0.05) <line11> .setPopularitySpread(10) <line12> .setPopularityMode(PopularityMode.MAXIMUM) <line13> .setSpreadSpectrum(SpreadSpectrum.PROPORTIONAL) <line14> .build(); <line15> GraphTransformer<Blogger> graphTransformer = <line16> new GraphTransformer.Builder<>(graph) <line17> .setGraphWalker(walker) <line18> .shuffleOnReset(true) <line19> .setVocabCache(vocabCache) <line20> .build(); <line21> Blogger blogger = graph.getVertex(0).getValue(); <line22> assertEquals(119, blogger.getElementFrequency(), 0.001); <line23> AbstractSequenceIterator<Blogger> sequenceIterator = <line24> new AbstractSequenceIterator.Builder<>(graphTransformer).build(); <line25> WeightLookupTable<Blogger> lookupTable = <line26> new InMemoryLookupTable.Builder<Blogger>() <line27> .lr(0.025) <line28> .vectorLength(150) <line29> .useAdaGrad(false) <line30> .cache(vocabCache) <line31> .seed(42) <line32> .build(); <line33> lookupTable.resetWeights(true); <line34> SequenceVectors<Blogger> vectors = <line35> new SequenceVectors.Builder<Blogger>(new VectorsConfiguration()) <line36> .lookupTable(lookupTable) <line37> .iterate(sequenceIterator) <line38> .vocabCache(vocabCache) <line39> .batchSize(1000) <line40> .iterations(1) <line41> .epochs(10) <line42> .resetModel(false) <line43> .trainElementsRepresentation(true) <line44> .trainSequencesRepresentation(false) <line45> .elementsLearningAlgorithm(new SkipGram<Blogger>()) <line46> .learningRate(0.025) <line47> .layerSize(150) <line48> .sampling(0) <line49> .negativeSample(0) <line50> .windowSize(4) <line51> .workers(6) <line52> .seed(42) <line53> .build(); <line54> vectors.fit(); <line55> vectors.setModelUtils(new FlatModelUtils()); <line56> double sim = vectors.similarity(""12"", ""72""); <line57> Collection<String> list = vectors.wordsNearest(""12"", 20); <line58> printWords(""12"", list, vectors); <line59> assertTrue(sim > 0.10); <line60> assertFalse(Double.isNaN(sim)); <line61> } <line62> } <line63> "	<line23>, <line58>
5571	"public class A { <line0> private boolean isArtifactOnlyResourceInstanceArtifact( <line1> ArtifactDefinition foundArtifact, Component parent, String instanceId) { <line2> Optional<ComponentInstance> componentInstanceOpt = parent.getComponentInstanceById(instanceId); <line3> if (!componentInstanceOpt.isPresent()) { <line4> throw new ByActionStatusComponentException( <line5> ActionStatus.COMPONENT_INSTANCE_NOT_FOUND_ON_CONTAINER, <line6> instanceId, <line7> """", <line8> """", <line9> parent.getName()); <line10> } <line11> ComponentInstance foundInstance = componentInstanceOpt.get(); <line12> String componentUid = foundInstance.getComponentUid(); <line13> Either<Component, StorageOperationStatus> getContainerRes = <line14> toscaOperationFacade.getToscaElement(componentUid); <line15> if (getContainerRes.isRight()) { <line16> throw new StorageException(getContainerRes.right().value()); <line17> } <line18> Component origComponent = getContainerRes.left().value(); <line19> Map<String, ArtifactDefinition> deploymentArtifacts = origComponent.getDeploymentArtifacts(); <line20> if (MapUtils.isNotEmpty(deploymentArtifacts)) { <line21> Optional<String> op = <line22> deploymentArtifacts.keySet().stream() <line23> .filter(a -> a.equals(foundArtifact.getArtifactLabel())) <line24> .findAny(); <line25> if (op.isPresent()) { <line26> return false; <line27> } <line28> } <line29> Map<String, ArtifactDefinition> artifacts = origComponent.getArtifacts(); <line30> if (MapUtils.isNotEmpty(artifacts)) { <line31> Optional<String> op = <line32> artifacts.keySet().stream() <line33> .filter(a -> a.equals(foundArtifact.getArtifactLabel())) <line34> .findAny(); <line35> if (op.isPresent()) { <line36> return false; <line37> } <line38> } <line39> return true; <line40> } <line41> } <line42> "	<line16>
5572	public class A { <line0> public static TestSuite getInstance() { <line1> if (instance == null) { <line2> instance = new TestSuite(); <line3> try { <line4> setUpClass(); <line5> } catch (RuntimeException | IOException | InterruptedException ex) { <line6> } <line7> } <line8> return instance; <line9> } <line10> } <line11> 	<line6>
5573	"public class A { <line0> @Override <line1> public String execute(final String command) { <line2> final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); <line3> final PrintStream out = new PrintStream(outputStream); <line4> try { <line5> zigBeeGateway.processInputLine(command, out); <line6> } catch (final Exception e) { <line7> out.println(""Error: "" + e.getMessage()); <line8> } <line9> return outputStream.toString(); <line10> } <line11> } <line12> "	<line7>
5574	"public class A { <line0> private String tryFindPrivateKeyFromExternal() { <line1> if (!this.rsaKeyFile.exists()) { <line2> return null; <line3> } <line4> try (FileInputStream input = new FileInputStream(rsaKeyFile)) { <line5> return readInputStream(input); <line6> } catch (IOException e) { <line7> String msg = <line8> String.format(""Failed to read private key {%s}."", this.rsaKeyFile.getAbsolutePath()); <line9> throw new EncryptionException(msg, e); <line10> } <line11> } <line12> } <line13> "	<line2>, <line7>
5575	"public class A { <line0> public void createCatalog(CatalogInfo catalogInfo, CatalogFileInputStream configFiles) <line1> throws IOException { <line2> String catalogName = catalogInfo.getCatalogName(); <line3> CatalogFilePath catalogPath = new CatalogFilePath(baseDirectory, catalogName); <line4> Path globalBasePath = catalogPath.getGlobalDirPath(); <line5> if (!fileSystemClient.exists(globalBasePath)) { <line6> fileSystemClient.createDirectories(globalBasePath); <line7> } <line8> Path catalogBasePath = catalogPath.getCatalogDirPath(); <line9> if (!fileSystemClient.exists(catalogBasePath)) { <line10> fileSystemClient.createDirectories(catalogBasePath); <line11> } <line12> try (OutputStream propertiesOutputStream = <line13> fileSystemClient.newOutputStream(catalogPath.getPropertiesPath()); <line14> OutputStream metadataOutputStream = <line15> fileSystemClient.newOutputStream(catalogPath.getMetadataPath())) { <line16> Map<String, CatalogFileInputStream.InputStreamWithType> inputStreams = <line17> configFiles.getInputStreams(); <line18> for (Map.Entry<String, CatalogFileInputStream.InputStreamWithType> entry : <line19> inputStreams.entrySet()) { <line20> String fileName = entry.getKey(); <line21> CatalogFileInputStream.InputStreamWithType inputStream = entry.getValue(); <line22> Path filePath; <line23> if (inputStream.getFileType() == CatalogFileInputStream.CatalogFileType.CATALOG_FILE) { <line24> filePath = Paths.get(catalogPath.getCatalogDirPath().toString(), fileName); <line25> } else { <line26> filePath = Paths.get(catalogPath.getGlobalDirPath().toString(), fileName); <line27> } <line28> try (OutputStream outputStream = fileSystemClient.newOutputStream(filePath)) { <line29> ByteStreams.copy(inputStream.getInputStream(), outputStream); <line30> } <line31> } <line32> Properties metadata = new Properties(); <line33> metadata.put(""createdTime"", String.valueOf(catalogInfo.getCreatedTime())); <line34> metadata.put(""version"", String.valueOf(catalogInfo.getVersion())); <line35> metadata.put(""catalogFiles"", LIST_CODEC.toJson(configFiles.getCatalogFileNames())); <line36> metadata.put(""globalFiles"", LIST_CODEC.toJson(configFiles.getGlobalFileNames())); <line37> metadata.store(metadataOutputStream, ""The metadata of dynamic catalog""); <line38> Map<String, String> catalogProperties = <line39> rewriteFilePathProperties( <line40> catalogName, <line41> catalogInfo.getProperties(), <line42> configFiles.getCatalogFileNames(), <line43> configFiles.getGlobalFileNames()); <line44> Properties properties = new Properties(); <line45> properties.putAll(catalogProperties); <line46> properties.put(CATALOG_NAME_PROPERTY, catalogInfo.getConnectorName()); <line47> properties.store(propertiesOutputStream, ""The properties of dynamic catalog""); <line48> } catch (IOException ex) { <line49> deleteCatalog(catalogName, false); <line50> throw ex; <line51> } <line52> } <line53> } <line54> "	<line31>, <line49>
5576	public class A { <line0> public void close(Socket s) { <line1> SafeClose.close(s); <line2> } <line3> } <line4> 	<line1>
5577	"public class A { <line0> public Document getDocument() { <line1> InputStream in = null; <line2> if (currentStream != null) { <line3> try { <line4> currentStream.close(); <line5> currentStream = null; <line6> } catch (IOException ioe) { <line7> } <line8> } <line9> if (thisFilename == null) { <line10> return null; <line11> } <line12> String filename = null; <line13> try { <line14> in = Files.openFileStream(thisFilename); <line15> filename = thisFilename.replaceAll(""\\.gz$"", """"); <line16> } catch (IOException ioe) { <line17> } <line18> currentStream = in; <line19> return makeDocument(filename, in); <line20> } <line21> } <line22> "	<line7>, <line17>
5578	public class A { <line0> @Override <line1> public void mapPort( <line2> final int port, <line3> final String address, <line4> final PortMapProtocol protocol, <line5> final String mappingDescription) { <line6> final Protocol resolvedProtocol = resolveProtocol(protocol); <line7> final PortMapping portMapping = <line8> new PortMapping(port, address, resolvedProtocol, mappingDescription); <line9> mappingServicesRegistrar.registerPortMapping(portMapping); <line10> } <line11> } <line12> 	<line6>, <line10>
5579	"public class A { <line0> public static void main(String[] args) { <line1> if (args.length != 0) { <line2> System.err.println( <line3> ""Usage: java -Dconfig=<secor_properties> "" <line4> + ""-Dlog4j.configuration=<log4j_properties> ConsumerMain""); <line5> return; <line6> } <line7> try { <line8> SecorConfig config = SecorConfig.load(); <line9> String stagingDirectoryPath = config.getLocalPath() + '/' + IdUtil.getLocalMessageDir(); <line10> ShutdownHookRegistry.registerHook(10, new StagingDirectoryCleaner(stagingDirectoryPath)); <line11> MetricCollector metricCollector = <line12> ReflectionUtil.createMetricCollector(config.getMetricsCollectorClass()); <line13> metricCollector.initialize(config); <line14> OstrichAdminService ostrichService = new OstrichAdminService(config); <line15> ostrichService.start(); <line16> FileUtil.configure(config); <line17> LogFileDeleter logFileDeleter = new LogFileDeleter(config); <line18> logFileDeleter.deleteOldLogs(); <line19> RateLimitUtil.configure(config); <line20> LinkedList<Consumer> consumers = new LinkedList<Consumer>(); <line21> for (int i = 0; i < config.getConsumerThreads(); ++i) { <line22> Consumer consumer = new Consumer(config, metricCollector); <line23> consumers.add(consumer); <line24> consumer.start(); <line25> } <line26> for (Consumer consumer : consumers) { <line27> consumer.join(); <line28> } <line29> } catch (Throwable t) { <line30> System.exit(1); <line31> } <line32> } <line33> } <line34> "	<line20>, <line30>
5580	public class A { <line0> @Override <line1> public final void initEntity() { <line2> if (isInitialized()) { <line3> return; <line4> } <line5> try { <line6> interceptInitEntity(); <line7> } catch (RuntimeException ex) { <line8> } <line9> for (IDataModelAttribute a : getAttributes()) { <line10> try { <line11> a.initAttribute(); <line12> } catch (RuntimeException ex) { <line13> } <line14> } <line15> setInitialized(); <line16> for (IDataModelEntity e : getEntities()) { <line17> try { <line18> e.initEntity(); <line19> } catch (RuntimeException ex) { <line20> } <line21> } <line22> } <line23> } <line24> 	<line8>, <line13>, <line20>
5581	public class A { <line0> @Nullable <line1> public static BranchType unbindBranchType() { <line2> BranchType unbindBranchType = (BranchType) CONTEXT_HOLDER.remove(KEY_BRANCH_TYPE); <line3> if (LOGGER.isDebugEnabled()) { <line4> } <line5> return unbindBranchType; <line6> } <line7> } <line8> 	<line4>
5582	"public class A { <line0> @Override <line1> public void createShare(final String irodsAbsolutePath, final String shareName) <line2> throws ShareAlreadyExistsException, FileNotFoundException, JargonException { <line3> if (irodsAbsolutePath == null || irodsAbsolutePath.isEmpty()) { <line4> throw new IllegalArgumentException(""null or empty iRODSAbsolutePath""); <line5> } <line6> if (shareName == null || shareName.isEmpty()) { <line7> throw new IllegalArgumentException(""null or empty iRODSAbsolutePath""); <line8> } <line9> ObjStat objStat = getObjStatForAbsolutePath(irodsAbsolutePath); <line10> IRODSSharedFileOrCollection currentSharedFile = <line11> findSharedGivenObjStat(irodsAbsolutePath, objStat); <line12> if (currentSharedFile != null) { <line13> throw new ShareAlreadyExistsException(""share already exists""); <line14> } <line15> MetadataDomain metadataDomain; <line16> if (objStat.isSomeTypeOfCollection()) { <line17> metadataDomain = MetadataDomain.COLLECTION; <line18> } else { <line19> metadataDomain = MetadataDomain.DATA; <line20> } <line21> IRODSSharedFileOrCollection irodsSharedFileOrCollection = <line22> new IRODSSharedFileOrCollection( <line23> metadataDomain, <line24> irodsAbsolutePath, <line25> shareName, <line26> irodsAccount.getUserName(), <line27> irodsAccount.getZone(), <line28> new ArrayList<ShareUser>()); <line29> AvuData avuData = buildAVUBasedOnShare(irodsSharedFileOrCollection); <line30> if (objStat.isSomeTypeOfCollection()) { <line31> setPermissionsForCollection(irodsSharedFileOrCollection, objStat, avuData); <line32> } else { <line33> setPermissionsForDataObject(irodsSharedFileOrCollection, objStat, avuData); <line34> } <line35> } <line36> } <line37> "	<line3>, <line9>, <line10>, <line29>, <line30>, <line35>
5583	public class A { <line0> private synchronized void stopTask() { <line1> this.isRunning = false; <line2> this.notify(); <line3> } <line4> } <line5> 	<line1>
5584	"public class A { <line0> @Override <line1> public void setLinks( <line2> MCRCategLinkReference objectReference, Collection<MCRCategoryID> categories) { <line3> EntityManager entityManager = MCREntityManagerProvider.getCurrentEntityManager(); <line4> categories.stream() <line5> .distinct() <line6> .forEach( <line7> categID -> { <line8> final MCRCategory category = getMCRCategory(entityManager, categID); <line9> if (category == null) { <line10> throw new MCRPersistenceException(""Could not link to unknown category "" + categID); <line11> } <line12> MCRCategoryLinkImpl link = new MCRCategoryLinkImpl(category, objectReference); <line13> if (LOGGER.isDebugEnabled()) { <line14> MCRCategory linkedCategory = link.getCategory(); <line15> StringBuilder debugMessage = <line16> new StringBuilder(""Adding Link from "").append(linkedCategory.getId()); <line17> if (linkedCategory instanceof MCRCategoryImpl) { <line18> debugMessage <line19> .append(""("") <line20> .append(((MCRCategoryImpl) linkedCategory).getInternalID()) <line21> .append("") ""); <line22> } <line23> debugMessage.append(""to "").append(objectReference); <line24> } <line25> entityManager.persist(link); <line26> }); <line27> } <line28> } <line29> "	<line24>, <line26>
5585	public class A { <line0> @Override <line1> public QueryResult execute(String query, String language) throws RepositoryException { <line2> final Query jcrQuery = <line3> getLocalSession() <line4> .getSession() <line5> .getWorkspace() <line6> .getQueryManager() <line7> .createQuery(query, language); <line8> return jcrQuery.execute(); <line9> } <line10> } <line11> 	<line2>
5586	"public class A { <line0> private void setupSpringSecurity() { <line1> ClassPathXmlApplicationContext appContext = <line2> new ClassPathXmlApplicationContext(new String[] {SPRING_SECURITY_METADATA}); <line3> System.setProperty(""spring-beans-config"", SPRING_SECURITY_METADATA); <line4> AuthZ authZ = AuthZ.get(); <line5> txManager = <line6> (org.springframework.jdbc.datasource.DataSourceTransactionManager) <line7> appContext.getBean(""transactionManager""); <line8> if (logger.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> "	<line9>
5587	"public class A { <line0> @POST <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/spaces/{spaceName}/projects/{projectName}/branches/{branchName}/maven/install"") <line3> @RolesAllowed({REST_ROLE, REST_PROJECT_ROLE}) <line4> public Response installProject( <line5> @PathParam(""spaceName"") String spaceName, <line6> @PathParam(""projectName"") String projectName, <line7> @PathParam(""branchName"") String branchName) { <line8> PortablePreconditions.checkNotNull(""spaceName"", spaceName); <line9> PortablePreconditions.checkNotNull(""projectName"", projectName); <line10> final String id = newId(); <line11> final InstallProjectRequest jobRequest = new InstallProjectRequest(); <line12> jobRequest.setStatus(JobStatus.ACCEPTED); <line13> jobRequest.setJobId(id); <line14> jobRequest.setSpaceName(spaceName); <line15> jobRequest.setProjectName(projectName); <line16> jobRequest.setBranchName(branchName); <line17> addAcceptedJobResult(id); <line18> jobRequestObserver.installProjectRequest(jobRequest); <line19> return createAcceptedStatusResponse(jobRequest); <line20> } <line21> } <line22> "	<line8>
5588	public class A { <line0> private void report() { <line1> final long deviceConnectionDuration = <line2> noOfDeviceConnections.get() <line3> * Duration.between(startInstant.getAndSet(Instant.now()), Instant.now()).toMillis(); <line4> recorder.accept(deviceConnectionDuration); <line5> } <line6> } <line7> 	<line5>
5589	public class A { <line0> public ProvenanceEventJmsWriter getProvenanceEventActiveMqWriter() { <line1> ProvenanceEventJmsWriter provenanceEventJmsWriter = <line2> SpringApplicationContext.getInstance().getBean(ProvenanceEventJmsWriter.class); <line3> if (provenanceEventJmsWriter == null) { <line4> } <line5> return provenanceEventJmsWriter; <line6> } <line7> } <line8> 	<line4>
5590	"public class A { <line0> @Override <line1> @Transactional <line2> public void monitor() { <line3> if (!parseBoolean(getProperty(""score.poll.use.large.message.query"", ""true""))) { <line4> return; <line5> } <line6> int noRetries = getNoRetries(); <line7> long time = System.currentTimeMillis() - getMessageExpirationTime() * 1000; <line8> List<ExecutionMessage> messages = executionQueueRepository.findOldMessages(time); <line9> Map<Long, List<ExecutionMessage>> execStateMap = <line10> messages.stream().collect(groupingBy(ExecutionMessage::getExecStateId)); <line11> Set<Long> toCancel = new HashSet<>(); <line12> List<ExecutionMessage> toRetry = new ArrayList<>(); <line13> for (Map.Entry<Long, List<ExecutionMessage>> entry : execStateMap.entrySet()) { <line14> long execStateId = entry.getKey(); <line15> List<ExecutionMessage> msgs = entry.getValue(); <line16> Collections.sort(msgs, comparingInt(ExecutionMessage::getMsgSeqId).reversed()); <line17> if (countRetries(msgs) >= noRetries) { <line18> toCancel.add(execStateId); <line19> } else { <line20> ExecutionMessage firstMsg = msgs.get(0); <line21> firstMsg.setWorkerId(ExecutionMessage.EMPTY_WORKER); <line22> firstMsg.setStatus(ExecStatus.PENDING); <line23> toRetry.add(firstMsg); <line24> } <line25> } <line26> if (toRetry.size() > 0) { <line27> execQueue.enqueue(toRetry); <line28> } <line29> if (toCancel.size() > 0) { <line30> Set<Long> execIds = executionQueueRepository.getExecutionIdsForExecutionStateIds(toCancel); <line31> for (Long executionId : execIds) { <line32> ExecutionActionResult result = cancelExecutionService.requestCancelExecution(executionId); <line33> } <line34> } <line35> } <line36> } <line37> "	<line27>, <line31>, <line33>
5591	public class A { <line0> private void processSchemaValidationErrors( <line1> final Collection<BaseArtifactType> derivedArtifacts, <line2> final BaseArtifactType schemaArtifact, <line3> final Element modelElement, <line4> final XPath xpath) <line5> throws Exception { <line6> final NodeList errors = <line7> (NodeList) <line8> query( <line9> modelElement, <line10> Utils.getElementQueryString(VdbManifest.ManifestId.VALIDATION_ERROR), <line11> XPathConstants.NODESET); <line12> if (errors.getLength() != 0) { <line13> for (int i = 0, numErrors = errors.getLength(); i < numErrors; ++i) { <line14> final Element errorElement = (Element) errors.item(i); <line15> final BaseArtifactType errorArtifact = <line16> VdbManifestArtifactBuilder.create(VdbValidationError.ARTIFACT_TYPE); <line17> derivedArtifacts.add(errorArtifact); <line18> { <line19> String path = errorElement.getAttribute(VdbValidationError.ManifestId.PATH); <line20> if (Utils.isEmpty(path)) { <line21> path = VdbValidationError.ROOT_PATH; <line22> } <line23> errorArtifact.setName(path); <line24> } <line25> { <line26> final String severity = errorElement.getAttribute(VdbValidationError.ManifestId.SEVERITY); <line27> ArtificerModelUtils.setCustomProperty( <line28> errorArtifact, VdbValidationError.PropertyId.SEVERITY, severity); <line29> } <line30> { <line31> final String message = errorElement.getTextContent(); <line32> ArtificerModelUtils.setCustomProperty( <line33> errorArtifact, VdbValidationError.PropertyId.MESSAGE, message); <line34> } <line35> if (LOGGER.isDebugEnabled()) { <line36> } <line37> Utils.addTwoWayRelationship( <line38> schemaArtifact, <line39> errorArtifact, <line40> VdbSchema.VALIDATION_ERRORS_RELATIONSHIP, <line41> VdbValidationError.SOURCE_RELATIONSHIP); <line42> } <line43> } <line44> } <line45> } <line46> 	<line13>, <line36>
5592	public class A { <line0> protected void deployDefaultDefinitionLink( <line1> User defaultUser, <line2> long companyId, <line3> Group companyGroup, <line4> String assetClassName, <line5> String workflowDefinitionName) <line6> throws PortalException { <line7> WorkflowDefinitionLink workflowDefinitionLink = <line8> workflowDefinitionLinkLocalService.fetchDefaultWorkflowDefinitionLink( <line9> companyId, assetClassName, 0, 0); <line10> if (workflowDefinitionLink != null) { <line11> return; <line12> } <line13> List<WorkflowDefinition> workflowDefinitions = <line14> _workflowDefinitionManager.getActiveWorkflowDefinitions( <line15> companyId, <line16> workflowDefinitionName, <line17> 0, <line18> 20, <line19> workflowComparatorFactory.getDefinitionNameComparator(false)); <line20> if (workflowDefinitions.isEmpty()) { <line21> if (_log.isWarnEnabled()) { <line22> } <line23> return; <line24> } <line25> WorkflowDefinition workflowDefinition = workflowDefinitions.get(0); <line26> workflowDefinitionLinkLocalService.addWorkflowDefinitionLink( <line27> defaultUser.getUserId(), <line28> companyId, <line29> companyGroup.getGroupId(), <line30> assetClassName, <line31> 0, <line32> 0, <line33> workflowDefinition.getName(), <line34> workflowDefinition.getVersion()); <line35> } <line36> } <line37> 	<line22>
5593	public class A { <line0> @Override <line1> public void next() throws IOException { <line2> boolean yielded = false; <line3> yieldNextKey.set(!yieldNextKey.get()); <line4> if (yield.isPresent() && yieldNextKey.get()) { <line5> yielded = true; <line6> yieldNexts.incrementAndGet(); <line7> yield.get().yield(getTopKey().followingKey(PartialKey.ROW_COLFAM_COLQUAL_COLVIS_TIME)); <line8> } <line9> if (!yielded) { <line10> super.next(); <line11> } <line12> } <line13> } <line14> 	<line2>, <line8>, <line11>
5594	public class A { <line0> @Override <line1> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <line2> throws IOException, ServletException { <line3> if (request instanceof HttpServletRequest) { <line4> HttpServletRequest httpServletRequest = (HttpServletRequest) request; <line5> final String username = SecurityHeaders.decode(httpServletRequest.getHeader(SEC_USERNAME)); <line6> if (username != null) { <line7> SecurityContext context = SecurityContextHolder.getContext(); <line8> Authentication authentication = createAuthentication(httpServletRequest); <line9> context.setAuthentication(authentication); <line10> if (logger.isDebugEnabled()) { <line11> } <line12> } else { <line13> if (logger.isDebugEnabled()) { <line14> } <line15> } <line16> } <line17> chain.doFilter(request, response); <line18> } <line19> } <line20> 	<line10>, <line11>, <line13>, <line14>
5595	"public class A { <line0> @Override <line1> public void destroy(KieServerImpl kieServer, KieServerRegistry registry) { <line2> ServiceRegistry.get().remove(""GlobalCamelService""); <line3> if (this.managedCamel && this.camelContext != null) { <line4> try { <line5> this.camelContext.stop(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> "	<line7>
5596	public class A { <line0> public void start() { <line1> if (isActive) { <line2> return; <line3> } <line4> if (timerJobRunnable == null) { <line5> timerJobRunnable = <line6> new AcquireTimerJobsRunnable(this, processEngineConfiguration.getJobManager()); <line7> } <line8> if (resetExpiredJobsRunnable == null) { <line9> resetExpiredJobsRunnable = new ResetExpiredJobsRunnable(this); <line10> } <line11> if (!isMessageQueueMode && asyncJobsDueRunnable == null) { <line12> asyncJobsDueRunnable = new AcquireAsyncJobsDueRunnable(this); <line13> } <line14> if (!isMessageQueueMode) { <line15> initAsyncJobExecutionThreadPool(); <line16> startJobAcquisitionThread(); <line17> } <line18> startTimerAcquisitionThread(); <line19> startResetExpiredJobsThread(); <line20> isActive = true; <line21> executeTemporaryJobs(); <line22> } <line23> } <line24> 	<line4>
5597	"public class A { <line0> public String checkDataSubTag(Element datasubtag) { <line1> Element[] children = datasubtag.getChildren(""text"").toArray(Element[]::new); <line2> int textCount = children.length; <line3> for (int i = 0; i < children.length; i++) { <line4> Element child = children[i]; <line5> String text = child.getTextTrim(); <line6> if (text == null || text.length() == 0) { <line7> child.detach(); <line8> textCount--; <line9> continue; <line10> } <line11> if (child.getAttribute(""lang"") != null) { <line12> child.getAttribute(""lang"").setNamespace(XML_NAMESPACE); <line13> } <line14> } <line15> if (textCount == 0) { <line16> return ""history date is empty""; <line17> } <line18> return checkMetaObjectWithLang(datasubtag, MCRMetaHistoryDate.class); <line19> } <line20> } <line21> "	<line13>
5598	"public class A { <line0> @Override <line1> public DDMTemplateVersion findByT_V(long templateId, String version) <line2> throws NoSuchTemplateVersionException { <line3> DDMTemplateVersion ddmTemplateVersion = fetchByT_V(templateId, version); <line4> if (ddmTemplateVersion == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""templateId=""); <line8> sb.append(templateId); <line9> sb.append("", version=""); <line10> sb.append(version); <line11> sb.append(""}""); <line12> if (_log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchTemplateVersionException(sb.toString()); <line15> } <line16> return ddmTemplateVersion; <line17> } <line18> } <line19> "	<line13>
5599	public class A { <line0> public static String readAnyLayout(final String roleKey) { <line1> try { <line2> return IOUtils.toString( <line3> InputStream.class.cast(getService(RoleService.class).getAnyLayout(roleKey).getEntity()), <line4> StandardCharsets.UTF_8); <line5> } catch (Exception e) { <line6> return StringUtils.EMPTY; <line7> } <line8> } <line9> } <line10> 	<line6>
5600	"public class A { <line0> public List<String> getFileSamples( <line1> File.Bioformat bioformat, Map<String, Object> attributes, Map<String, String> sampleMap) <line2> throws CatalogException { <line3> if (attributes == null) { <line4> return new LinkedList<>(); <line5> } <line6> List<String> sortedSampleNames = null; <line7> switch (bioformat) { <line8> case VARIANT: <line9> { <line10> if (attributes.containsKey(VARIANT_FILE_METADATA)) { <line11> Object variantSourceObj = attributes.get(VARIANT_FILE_METADATA); <line12> if (variantSourceObj instanceof VariantFileMetadata) { <line13> sortedSampleNames = ((VariantFileMetadata) variantSourceObj).getSampleIds(); <line14> } else if (variantSourceObj instanceof Map) { <line15> sortedSampleNames = <line16> new ObjectMap((Map) variantSourceObj).getAsStringList(""sampleIds""); <line17> } else { <line18> } <line19> } <line20> break; <line21> } <line22> case ALIGNMENT: <line23> { <line24> if (attributes.containsKey(""alignmentHeader"")) { <line25> Object alignmentHeaderObj = attributes.get(""alignmentHeader""); <line26> if (alignmentHeaderObj instanceof Map) { <line27> sortedSampleNames = getSampleFromAlignmentHeader((Map) alignmentHeaderObj); <line28> } else { <line29> } <line30> } <line31> break; <line32> } <line33> default: <line34> return new LinkedList<>(); <line35> } <line36> if (sortedSampleNames == null || sortedSampleNames.isEmpty()) { <line37> return new LinkedList<>(); <line38> } <line39> if (sampleMap != null && !sampleMap.isEmpty()) { <line40> List<String> tmpSampleNames = new ArrayList<>(sortedSampleNames.size()); <line41> for (String sampleName : sortedSampleNames) { <line42> if (!sampleMap.containsKey(sampleName)) { <line43> throw new CatalogException(""Missing sample map for id "" + sampleName); <line44> } else { <line45> tmpSampleNames.add(sampleMap.get(sampleName)); <line46> } <line47> } <line48> sortedSampleNames = tmpSampleNames; <line49> } <line50> return sortedSampleNames; <line51> } <line52> } <line53> "	<line18>, <line29>
5601	"public class A { <line0> public static JobInstance run(int jobInstanceId) { <line1> DbConn cnx = Helpers.getNewDbSession(); <line2> com.enioka.jqm.model.JobInstance jr = <line3> com.enioka.jqm.model.JobInstance.select_id(cnx, jobInstanceId); <line4> cnx.close(); <line5> if (jr == null) { <line6> throw new IllegalArgumentException(""There is no JobRequest by ID "" + jobInstanceId); <line7> } <line8> return run(jr); <line9> } <line10> } <line11> "	<line1>
5602	public class A { <line0> public void testStateTransfer() throws Exception { <line1> CyclicBarrier barrier = new CyclicBarrier(2); <line2> blockDataContainerIteration(cache(0), barrier); <line3> Set<Object> keys = new HashSet<>(); <line4> for (int i = 0; i < NUM_KEYS; i++) { <line5> Object key = getKeyForCache(0); <line6> if (!keys.add(key)) continue; <line7> cache(0).put(key, key); <line8> } <line9> addClusterEnabledCacheManager(TestDataSCI.INSTANCE, dccc); <line10> waitForClusterToForm(); <line11> barrier.await(10, TimeUnit.SECONDS); <line12> for (Object key : keys) { <line13> assertEquals(1, checkKey(key, cache(0))); <line14> } <line15> barrier.await(10, TimeUnit.SECONDS); <line16> cache(0) <line17> .getAdvancedCache() <line18> .getAsyncInterceptorChain() <line19> .removeInterceptor(BlockingInterceptor.class); <line20> for (Object key : keys) { <line21> eventuallyEquals(1, () -> checkKey(key, cache(0), cache(1), cache(2))); <line22> } <line23> } <line24> } <line25> 	<line9>, <line12>
5603	"public class A { <line0> public String deleteElement() { <line1> AProjectArtefact artefact = repositoryTreeState.getSelectedNode().getData(); <line2> String childName = WebStudioUtils.getRequestParameter(""element""); <line3> AProjectArtefact childArtefact = <line4> ((TreeNode) <line5> repositoryTreeState <line6> .getSelectedNode() <line7> .getChild( <line8> RepositoryUtils.getTreeNodeId(artefact.getRepository().getId(), childName))) <line9> .getData(); <line10> try { <line11> studio.getModel().clearModuleInfo(); <line12> unregisterArtifactInProjectDescriptor(childArtefact); <line13> childArtefact.delete(); <line14> repositoryTreeState.refreshSelectedNode(); <line15> resetStudioModel(); <line16> WebStudioUtils.addInfoMessage(""Element was deleted successfully.""); <line17> } catch (Exception e) { <line18> WebStudioUtils.addErrorMessage(""Error deleting."", e.getMessage()); <line19> } <line20> return null; <line21> } <line22> } <line23> "	<line18>
5604	public class A { <line0> @Override <line1> public void prepareHandshakeMessageContents() { <line2> setDheParams(); <line3> preparePublicKey(msg); <line4> prepareDheParams(); <line5> selectedSignatureHashAlgo = chooser.getSelectedSigHashAlgorithm(); <line6> prepareSignatureAndHashAlgorithm(msg); <line7> signature = new byte[0]; <line8> try { <line9> signature = generateSignature(selectedSignatureHashAlgo); <line10> } catch (CryptoException E) { <line11> } <line12> prepareSignature(msg); <line13> prepareSignatureLength(msg); <line14> } <line15> } <line16> 	<line11>
5605	public class A { <line0> @GraphTransaction <line1> public List<AtlasClassification> retrieveClassifications(String guid) throws AtlasBaseException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> AtlasEntityHeader entityHeader = entityRetriever.toAtlasEntityHeaderWithClassifications(guid); <line5> return entityHeader.getClassifications(); <line6> } <line7> } <line8> 	<line3>
5606	public class A { <line0> @Override <line1> public void perform() throws Exception { <line2> if (sleepTime > 0) { <line3> Thread.sleep(sleepTime); <line4> } <line5> HBaseTestingUtility util = context.getHBaseIntegrationTestingUtility(); <line6> Admin admin = util.getAdmin(); <line7> List<RegionInfo> regions = admin.getRegions(tableName); <line8> if (regions == null || regions.isEmpty()) { <line9> return; <line10> } <line11> RegionInfo region = PolicyBasedChaosMonkey.selectRandomItem(regions.toArray(new RegionInfo[0])); <line12> MoveRegionsOfTableAction.moveRegion( <line13> admin, MoveRegionsOfTableAction.getServers(admin), region, getLogger()); <line14> if (sleepTime > 0) { <line15> Thread.sleep(sleepTime); <line16> } <line17> } <line18> } <line19> 	<line7>, <line9>, <line12>
5607	"public class A { <line0> private void emitTaskExitState() { <line1> if (emitTaskState) { <line2> try { <line3> TaskExitState exitState = new TaskExitState(); <line4> exitState.setInput(inputMeter.count()); <line5> exitState.setTotalEmitted(outputMeter.count()); <line6> exitState.setMeanRate(outputMeter.meanRate()); <line7> Files.write(CodecJSON.INSTANCE.encode(exitState), new File(""job.exit"")); <line8> } catch (Exception ex) { <line9> } <line10> } <line11> } <line12> } <line13> "	<line9>
5608	"public class A { <line0> private Map<String, String> prepareResponseMap(CloseableHttpResponse response) { <line1> try { <line2> InputStreamReader inputStreamReader = <line3> new InputStreamReader(response.getEntity().getContent()); <line4> BufferedReader reader = new BufferedReader(inputStreamReader); <line5> ObjectMapper objectMapper = new ObjectMapper(); <line6> Map<String, Map<String, Object>> responseMap = null; <line7> try { <line8> responseMap = <line9> objectMapper.readValue( <line10> reader.readLine(), new TypeReference<Map<String, Map<String, Object>>>() {}); <line11> } finally { <line12> reader.close(); <line13> inputStreamReader.close(); <line14> } <line15> if (responseMap == null || responseMap.isEmpty()) { <line16> throw new ApplicationRuntimeException(""SBIMOPS reconciliation response is null or empty""); <line17> } else { <line18> Map<String, Object> responseParameterMap = <line19> (Map<String, Object>) responseMap.get(SBIMOPS_RECORDSET).get(SBIMOPS_ROW); <line20> final Map<String, String> responseSbimopsMap = new LinkedHashMap<>(); <line21> responseParameterMap.forEach((key, value) -> responseSbimopsMap.put(key, value.toString())); <line22> return responseSbimopsMap; <line23> } <line24> } catch (JsonParseException e) { <line25> } catch (IOException e) { <line26> } <line27> return null; <line28> } <line29> } <line30> "	<line16>, <line18>, <line25>, <line26>
5609	"public class A { <line0> public static AddressSpace waitForAddressSpaceConnectorsReady( <line1> AddressSpace addressSpace, TimeoutBudget budget) throws Exception { <line2> waitForAddressSpaceReady(addressSpace); <line3> boolean isReady = false; <line4> var client = <line5> Kubernetes.getInstance().getAddressSpaceClient(addressSpace.getMetadata().getNamespace()); <line6> String name = addressSpace.getMetadata().getName(); <line7> AddressSpace clientAddressSpace = addressSpace; <line8> while (budget.timeLeft() >= 0 && !isReady) { <line9> clientAddressSpace = client.withName(name).get(); <line10> isReady = areAddressSpaceConnectorsReady(clientAddressSpace); <line11> if (!isReady) { <line12> Thread.sleep(10000); <line13> } <line14> if (verboseLogs) { <line15> } <line16> } <line17> clientAddressSpace = client.withName(name).get(); <line18> isReady = areAddressSpaceConnectorsReady(clientAddressSpace); <line19> if (!isReady) { <line20> throw new IllegalStateException( <line21> String.format( <line22> ""Connectors of Address Space %s are not in Ready state within timeout: %s"", <line23> name, getConnectorStatuses(clientAddressSpace))); <line24> } <line25> return clientAddressSpace; <line26> } <line27> } <line28> "	<line15>, <line25>
5610	"public class A { <line0> @Override <line1> public Optional<ScriptVersionTrace> get(ScriptVersionTraceKey scriptVersionTraceKey) { <line2> try { <line3> String query = <line4> ""SELECT SCRIPT_VRS_NB, SCRIPT_VRS_DSC FROM "" <line5> + getMetadataRepository().getTableNameByLabel(""ScriptVersionTraces"") <line6> + "" WHERE "" <line7> + "" RUN_ID = "" <line8> + SQLTools.getStringForSQL(scriptVersionTraceKey.getRunId()) <line9> + "" AND "" <line10> + "" PRC_ID = "" <line11> + SQLTools.getStringForSQL(scriptVersionTraceKey.getProcessId()) <line12> + "";""; <line13> CachedRowSet cachedRowSet = getMetadataRepository().executeQuery(query, ""reader""); <line14> if (cachedRowSet.size() == 0) { <line15> return Optional.empty(); <line16> } else if (cachedRowSet.size() > 1) { <line17> } <line18> cachedRowSet.next(); <line19> return Optional.of( <line20> new ScriptVersionTrace( <line21> scriptVersionTraceKey, <line22> cachedRowSet.getLong(""SCRIPT_VRS_NB""), <line23> cachedRowSet.getString(""SCRIPT_VRS_DSC""))); <line24> } catch (SQLException e) { <line25> throw new RuntimeException(e); <line26> } <line27> } <line28> } <line29> "	<line17>
5611	"public class A { <line0> void verifyMessage(Message message) { <line1> if (!message.getMsgType().toString().equalsIgnoreCase(MessageType.TASK_REPLY.name())) { <line2> String errorMsg = <line3> ""Unexpected msg type for message "" <line4> + message.getMsgId() <line5> + "" type:"" <line6> + message.getMsgType() <line7> + "" Expected : "" <line8> + MessageType.TASK_REPLY; <line9> _logger.error(errorMsg); <line10> throw new HelixException(errorMsg); <line11> } <line12> String correlationId = message.getCorrelationId(); <line13> if (correlationId == null) { <line14> String errorMsg = ""Message "" + message.getMsgId() + "" does not have correlation id""; <line15> _logger.error(errorMsg); <line16> throw new HelixException(errorMsg); <line17> } <line18> if (!_callbackMap.containsKey(correlationId)) { <line19> String errorMsg = <line20> ""Message "" <line21> + message.getMsgId() <line22> + "" does not have correponding callback. Probably timed out already. Correlation id: "" <line23> + correlationId; <line24> throw new HelixException(errorMsg, false); <line25> } <line26> } <line27> } <line28> "	<line24>, <line26>
5612	public class A { <line0> Optional<Identities> resolveUsername(final Long entityId, final String username) <line1> throws FidoException { <line2> List<Identity> identities; <line3> if (nonNull(entityId)) { <line4> try { <line5> identities = identityResolver.getIdentitiesForEntity(new EntityParam(entityId)); <line6> } catch (IllegalIdentityValueException e) { <line7> return Optional.empty(); <line8> } <line9> } else { <line10> identities = getIdentitiesByUsername(username); <line11> } <line12> if (identities.isEmpty()) return Optional.empty(); <line13> try { <line14> return Optional.of(Identities.builder().identities(identities).build()); <line15> } catch (IllegalArgumentException | NoSuchElementException e) { <line16> return Optional.empty(); <line17> } <line18> } <line19> } <line20> 	<line16>
5613	"public class A { <line0> @Override <line1> public WorkflowRun getWorkflowRunWithWorkflow(String workflowRunAccession) { <line2> try { <line3> WorkflowRun wr = ll.findWorkflowRun(""/"" + workflowRunAccession); <line4> Workflow w = ll.findWorkflowByWorkflowRun(workflowRunAccession); <line5> wr.setWorkflow(w); <line6> return (wr); <line7> } catch (IOException | JAXBException ex) { <line8> } <line9> return null; <line10> } <line11> } <line12> "	<line8>
5614	public class A { <line0> protected Layout getProductLayout(long groupId, boolean privateLayout, long cpDefinitionId) <line1> throws PortalException { <line2> String layoutUuid = _cpDefinitionLocalService.getLayoutUuid(groupId, cpDefinitionId); <line3> if (Validator.isNotNull(layoutUuid)) { <line4> return _layoutLocalService.getLayoutByUuidAndGroupId(layoutUuid, groupId, privateLayout); <line5> } <line6> long plid = _getPlidFromPortletId(groupId, privateLayout, CPPortletKeys.CP_CONTENT_WEB); <line7> try { <line8> return _layoutLocalService.getLayout(plid); <line9> } catch (PortalException portalException) { <line10> if (_log.isDebugEnabled()) { <line11> } <line12> throw portalException; <line13> } <line14> } <line15> } <line16> 	<line11>
5615	public class A { <line0> protected int throttlingQueueSize() { <line1> RequestThrottler requestThrottler = context.getRequestThrottler(); <line2> if (requestThrottler instanceof ConcurrencyLimitingRequestThrottler) { <line3> return ((ConcurrencyLimitingRequestThrottler) requestThrottler).getQueueSize(); <line4> } <line5> if (requestThrottler instanceof RateLimitingRequestThrottler) { <line6> return ((RateLimitingRequestThrottler) requestThrottler).getQueueSize(); <line7> } <line8> return 0; <line9> } <line10> } <line11> 	<line8>
5616	"public class A { <line0> @Test <line1> public void test1() throws Exception { <line2> myTestExecution(DatesPage1.class, ""DatesPage1_ExpectedResult.html""); <line3> } <line4> } <line5> "	<line2>
5617	public class A { <line0> protected long sweep(GarbageCollectorFileState fs, long markStart, boolean forceBlobRetrieve) <line1> throws Exception { <line2> long earliestRefAvailTime; <line3> earliestRefAvailTime = <line4> GarbageCollectionType.get(blobStore) <line5> .mergeAllMarkedReferences( <line6> blobStore, fs, clock, maxLastModifiedInterval, sweepIfRefsPastRetention); <line7> earliestRefAvailTime = (earliestRefAvailTime < markStart ? earliestRefAvailTime : markStart); <line8> (new BlobIdRetriever(fs, forceBlobRetrieve)).call(); <line9> difference(fs); <line10> long count = 0; <line11> long deleted = 0; <line12> long maxModifiedTime = getMaxModifiedTime(earliestRefAvailTime); <line13> BufferedWriter removesWriter = null; <line14> LineIterator iterator = null; <line15> long deletedSize = 0; <line16> int numDeletedSizeAvailable = 0; <line17> try { <line18> removesWriter = Files.newWriter(fs.getGarbage(), Charsets.UTF_8); <line19> ArrayDeque<String> removesQueue = new ArrayDeque<String>(); <line20> iterator = FileUtils.lineIterator(fs.getGcCandidates(), Charsets.UTF_8.name()); <line21> Iterator<List<String>> partitions = Iterators.partition(iterator, getBatchCount()); <line22> while (partitions.hasNext()) { <line23> List<String> ids = partitions.next(); <line24> count += ids.size(); <line25> deleted += <line26> BlobCollectionType.get(blobStore) <line27> .sweepInternal(blobStore, ids, removesQueue, maxModifiedTime); <line28> saveBatchToFile(newArrayList(removesQueue), removesWriter); <line29> for (String deletedId : removesQueue) { <line30> long length = DataStoreBlobStore.BlobId.of(deletedId).getLength(); <line31> if (length != -1) { <line32> deletedSize += length; <line33> numDeletedSizeAvailable += 1; <line34> } <line35> } <line36> removesQueue.clear(); <line37> } <line38> } finally { <line39> LineIterator.closeQuietly(iterator); <line40> closeQuietly(removesWriter); <line41> } <line42> if (checkConsistencyAfterGc) { <line43> BlobCollectionType.get(blobStore) <line44> .checkConsistencyAfterGC(blobStore, fs, consistencyStatsCollector, new File(root)); <line45> } <line46> BlobCollectionType.get(blobStore).handleRemoves(blobStore, fs.getGarbage(), fs.getMarkedRefs()); <line47> if (count != deleted) { <line48> } <line49> if (deletedSize > 0) { <line50> } <line51> statsCollector.updateNumCandidates(count); <line52> statsCollector.updateNumDeleted(deleted); <line53> statsCollector.updateTotalSizeDeleted(deletedSize); <line54> GarbageCollectionType.get(blobStore).removeAllMarkedReferences(blobStore); <line55> return deleted; <line56> } <line57> } <line58> 	<line7>, <line13>, <line48>, <line50>, <line55>
5618	"public class A { <line0> public List<SmallCategory> getIdeaTags(boolean completeTitle) { <line1> List<SmallCategory> categories = new ArrayList<SmallCategory>(); <line2> try { <line3> String langCode = this.getCurrentLang().getCode(); <line4> String nodeRootCode = this.getIdeaManager().getCategoryRoot(); <line5> categories = this.getCategoryLeaf(nodeRootCode, langCode, completeTitle); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(""Error loading categories""); <line8> } <line9> return categories; <line10> } <line11> } <line12> "	<line7>
5619	public class A { <line0> @Test <line1> public void testTypes() throws Exception { <line2> SampleEntity entity = new SampleEntity(); <line3> } <line4> } <line5> 	<line2>, <line3>
5620	"public class A { <line0> protected void addUserGroupsAttribute( <line1> User user, <line2> AttributeResolverSAMLContext attributeResolverSAMLContext, <line3> AttributePublisher attributePublisher, <line4> String attributeName, <line5> boolean namespaceEnabled) { <line6> try { <line7> List<UserGroup> userGroups = user.getUserGroups(); <line8> if (userGroups.isEmpty()) { <line9> return; <line10> } <line11> String name = null; <line12> String nameFormat = null; <line13> if (namespaceEnabled) { <line14> name = ""urn:liferay:userGroups""; <line15> nameFormat = Attribute.URI_REFERENCE; <line16> } else { <line17> name = ""userGroups""; <line18> nameFormat = Attribute.UNSPECIFIED; <line19> } <line20> Stream<UserGroup> userGroupsStream = userGroups.stream(); <line21> attributePublisher.publish( <line22> name, <line23> nameFormat, <line24> userGroupsStream <line25> .map(UserGroup::getName) <line26> .map(attributePublisher::buildString) <line27> .toArray(AttributePublisher.AttributeValue[]::new)); <line28> } catch (Exception exception) { <line29> String message = <line30> StringBundler.concat( <line31> ""Unable to get user groups for user "", <line32> user.getUserId(), <line33> "": "", <line34> exception.getMessage()); <line35> if (_log.isDebugEnabled()) { <line36> } else { <line37> } <line38> } <line39> } <line40> } <line41> "	<line36>, <line37>
5621	public class A { <line0> public boolean verify(DefaultAuthToken token) { <line1> try { <line2> return token != null <line3> && verifyUser(token) <line4> && verifyValidUntil(token) <line5> && verifySignature(token); <line6> } catch (RuntimeException e) { <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> return false; <line10> } <line11> } <line12> } <line13> 	<line8>
5622	public class A { <line0> @Override <line1> public Integer insert(Registration registration, SequencerRun sequencerRun) { <line2> if (registration == null) { <line3> } else if (registration.isLIMSAdmin() || sequencerRun.givesPermission(registration)) { <line4> insert(sequencerRun); <line5> return (sequencerRun.getSwAccession()); <line6> } else { <line7> } <line8> return null; <line9> } <line10> } <line11> 	<line3>, <line4>, <line7>
5623	"public class A { <line0> public static void showCheckoutConflictsAlert(List<String> conflictingPaths) { <line1> String conflictList = """"; <line2> for (String pathName : conflictingPaths) { <line3> conflictList += ""\n"" + pathName; <line4> } <line5> Alert alert = new Alert(Alert.AlertType.ERROR); <line6> alert.setTitle(""Conflicting files""); <line7> alert.setHeaderText(""Can't checkout that branch""); <line8> alert.setContentText( <line9> ""You can't switch to that branch because of the following conflicting files between that"" <line10> + "" branch and your current branch: "" <line11> + conflictList); <line12> alert.showAndWait(); <line13> } <line14> } <line15> "	<line1>
5624	public class A { <line0> @Override <line1> public Address findByPrimaryKey(Serializable primaryKey) throws NoSuchAddressException { <line2> Address address = fetchByPrimaryKey(primaryKey); <line3> if (address == null) { <line4> if (_log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchAddressException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return address; <line9> } <line10> } <line11> 	<line5>
5625	"public class A { <line0> public void addReferenceLink(String from, String to, String type, String attr) { <line1> from = MCRUtils.filterTrimmedNotEmpty(from).orElse(null); <line2> if (from == null) { <line3> return; <line4> } <line5> to = MCRUtils.filterTrimmedNotEmpty(to).orElse(null); <line6> if (to == null) { <line7> return; <line8> } <line9> type = MCRUtils.filterTrimmedNotEmpty(type).orElse(null); <line10> if (type == null) { <line11> return; <line12> } <line13> attr = MCRUtils.filterTrimmedNotEmpty(attr).orElse(""""); <line14> try { <line15> linkTableInstance.create(from, to, type, attr); <line16> } catch (Exception e) { <line17> } <line18> } <line19> } <line20> "	<line3>, <line7>, <line11>, <line14>, <line17>
5626	public class A { <line0> @Override <line1> public boolean lock(String lockPath, long timeout) { <line2> if (lock(lockPath)) return true; <line3> if (timeout <= 0) timeout = Long.MAX_VALUE; <line4> long waitStart = System.currentTimeMillis(); <line5> long sleep = 10 * 1000L; <line6> while (System.currentTimeMillis() - waitStart <= timeout) { <line7> try { <line8> Thread.sleep((long) (1000 + sleep * random.nextDouble())); <line9> } catch (InterruptedException e) { <line10> Thread.currentThread().interrupt(); <line11> return false; <line12> } <line13> if (lock(lockPath)) { <line14> return true; <line15> } <line16> } <line17> return false; <line18> } <line19> } <line20> 	<line4>, <line14>
5627	public class A { <line0> private void setConfAndGetFS() { <line1> Configuration conf = HDFSConfUtil.setConf(new Configuration()); <line2> try { <line3> fs = hdfsPath.getFileSystem(conf); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	<line5>
5628	"public class A { <line0> @Test <line1> public void testDateFolderDistributor() throws Exception { <line2> File f = setUpFlagDir(); <line3> createTestFiles(5, 5); <line4> createBogusTestFiles(5, 5); <line5> createCopyingTestFiles(5, 5); <line6> fmc.setDistributorType(""folderdate""); <line7> FlagMaker instance = new TestWrappedFlagMaker(fmc); <line8> instance.processFlags(); <line9> File[] flags = f.listFiles(pathname -> pathname.toString().endsWith(""flag"")); <line10> assertEquals(""Incorrect number of flags: "" + Arrays.toString(flags), 5, flags.length); <line11> HashSet<Long> buckets = new HashSet<>(); <line12> DateUtils du = new DateUtils(); <line13> for (File file : flags) { <line14> try (BufferedReader r = new BufferedReader(new FileReader(file))) { <line15> String[] files = r.readLine().split("" "")[1].split("",""); <line16> assertEquals(""Incorrect number of files: "" + Arrays.toString(files), 10, files.length); <line17> Map<String, Integer> folderCounts = new HashMap<>(); <line18> Map<String, Integer> dateCounts = new HashMap<>(); <line19> for (String string : files) { <line20> assertTrue(string.startsWith(""target/test/BulkIngest/flagged"")); <line21> String folder = string.substring(31, 34); <line22> folderCounts.put( <line23> folder, (folderCounts.containsKey(folder) ? folderCounts.get(folder) : 0) + 1); <line24> String date = string.substring(35, 45); <line25> dateCounts.put(date, (dateCounts.containsKey(date) ? dateCounts.get(date) : 0) + 1); <line26> buckets.add(DateUtils.getBucket(""day"", string)); <line27> } <line28> assertEquals(2, folderCounts.size()); <line29> for (String folder : folderCounts.keySet()) { <line30> assertEquals(5, folderCounts.get(folder).intValue()); <line31> } <line32> assertEquals(5, dateCounts.size()); <line33> for (String date : dateCounts.keySet()) { <line34> assertEquals(2, dateCounts.get(date).intValue()); <line35> } <line36> assertEquals(""Incorrect number of buckets: "" + buckets, 5, buckets.size()); <line37> buckets.clear(); <line38> } <line39> } <line40> } <line41> } <line42> "	<line2>
5629	"public class A { <line0> @RequestMapping(path = ""/v1/vulnerabilities/summarybyapplication"", method = RequestMethod.GET) <line1> public ResponseEntity<Object> getVulnerabilityByApplications( <line2> @RequestParam(""ag"") String assetGroup) { <line3> if (Strings.isNullOrEmpty(assetGroup)) { <line4> return ResponseUtils.buildFailureResponse(new Exception(ASSET_MANDATORY)); <line5> } <line6> ResponseData response; <line7> try { <line8> response = <line9> new ResponseData( <line10> vulnerabilityService.getVulnerabilityByAppAndEnv( <line11> assetGroup, ""tags.Application.keyword"", """")); <line12> } catch (Exception e) { <line13> return ResponseUtils.buildFailureResponse(e); <line14> } <line15> return ResponseUtils.buildSucessResponse(response); <line16> } <line17> } <line18> "	<line13>
5630	"public class A { <line0> public void testNotValuesForSimpleFacetHandler() throws Exception { <line1> BrowseRequest br = new BrowseRequest(); <line2> br.setCount(20); <line3> br.setOffset(0); <line4> BrowseSelection colorSel = new BrowseSelection(""color""); <line5> colorSel.addValue(""red""); <line6> br.addSelection(colorSel); <line7> BrowseSelection idSel = new BrowseSelection(""id""); <line8> idSel.addNotValue(""0""); <line9> br.addSelection(idSel); <line10> BrowseResult result = null; <line11> BoboBrowser boboBrowser = null; <line12> int expectedHitNum = (_documentSize / 2) - 1; <line13> try { <line14> Directory ramIndexDir = createIndex(); <line15> DirectoryReader srcReader = DirectoryReader.open(ramIndexDir); <line16> boboBrowser = new BoboBrowser(BoboMultiReader.getInstance(srcReader, _facetHandlers)); <line17> result = boboBrowser.browse(br); <line18> assertEquals(expectedHitNum, result.getNumHits()); <line19> StringBuilder buffer = new StringBuilder(); <line20> BrowseHit[] hits = result.getHits(); <line21> for (int i = 0; i < hits.length; ++i) { <line22> int expectedID = (i + 1) * 2; <line23> assertEquals(expectedID, Integer.parseInt(hits[i].getField(""id""))); <line24> if (i != 0) { <line25> buffer.append('\n'); <line26> } <line27> buffer.append(""id="" + hits[i].getField(""id"") + "","" + ""color="" + hits[i].getField(""color"")); <line28> } <line29> } catch (BrowseException e) { <line30> e.printStackTrace(); <line31> fail(e.getMessage()); <line32> } catch (IOException ioe) { <line33> fail(ioe.getMessage()); <line34> } finally { <line35> if (boboBrowser != null) { <line36> try { <line37> if (result != null) result.close(); <line38> boboBrowser.close(); <line39> } catch (IOException e) { <line40> fail(e.getMessage()); <line41> } <line42> } <line43> } <line44> } <line45> } <line46> "	<line29>
5631	public class A { <line0> protected boolean isAuth(UserDetails user, Set<String> groupCodes) throws ApsSystemException { <line1> if (null == user) { <line2> return false; <line3> } <line4> return this.getAuthorizationManager().isAuth(user, groupCodes); <line5> } <line6> } <line7> 	<line2>
5632	"public class A { <line0> public boolean isGCSAvailable() { <line1> if (gcsAvailable == null) { <line2> gcsAvailable = ClassUtils.isPresent(""com.google.cloud.storage.Storage"", classLoader); <line3> } <line4> return gcsAvailable; <line5> } <line6> } <line7> "	<line3>
5633	"public class A { <line0> @Produces <line1> @ApplicationScoped <line2> public AbstractCryptoProvider getCryptoProvider() throws Exception { <line3> WebKeyStorage webKeyStorage = appConfiguration.getWebKeysStorage(); <line4> if (webKeyStorage == null) { <line5> throw new RuntimeException( <line6> ""Failed to initialize cryptoProvider, cryptoProviderType is not specified!""); <line7> } <line8> AbstractCryptoProvider cryptoProvider = <line9> org.gluu.oxauth.model.crypto.CryptoProviderFactory.getCryptoProvider(appConfiguration); <line10> if (cryptoProvider == null) { <line11> throw new RuntimeException( <line12> ""Failed to initialize cryptoProvider, cryptoProviderType is unsupported: "" <line13> + webKeyStorage); <line14> } <line15> return cryptoProvider; <line16> } <line17> } <line18> "	<line3>
5634	public class A { <line0> @Override <line1> public void createPages() { <line2> Stopwatch stopwatch = Stopwatch.createStarted(); <line3> createModel(); <line4> Display display = getSite().getShell().getDisplay(); <line5> if (!getEditingDomain().getResourceSet().getResources().isEmpty()) { <line6> createTree(); <line7> display.asyncExec(() -> setActivePage(0)); <line8> } <line9> getContainer() <line10> .addControlListener( <line11> new ControlAdapter() { <line12> boolean guard = false; <line13>  <line14> @Override <line15> public void controlResized(ControlEvent event) { <line16> if (!guard) { <line17> guard = true; <line18> hideTabs(); <line19> guard = false; <line20> } <line21> } <line22> }); <line23> display.asyncExec(this::updateProblemIndication); <line24> } <line25> } <line26> 	<line24>
5635	"public class A { <line0> public void open() { <line1> if (isConnected()) { <line2> } else { <line3> sslContextFactory.setTrustAll(true); <line4> sslContextFactory.setEndpointIdentificationAlgorithm(null); <line5> WebSocketClient client = this.client; <line6> if (client == null) { <line7> client = new WebSocketClient(sslContextFactory, websocketExecutor); <line8> client.setMaxIdleTimeout(600 * 1000); <line9> this.client = client; <line10> } <line11> TibberWebSocketListener socket = this.socket; <line12> if (socket == null) { <line13> socket = new TibberWebSocketListener(); <line14> this.socket = socket; <line15> } <line16> ClientUpgradeRequest newRequest = new ClientUpgradeRequest(); <line17> newRequest.setHeader(""Authorization"", ""Bearer "" + tibberConfig.getToken()); <line18> newRequest.setSubProtocols(""graphql-subscriptions""); <line19> try { <line20> client.start(); <line21> } catch (Exception e) { <line22> } <line23> try { <line24> sessionFuture = client.connect(socket, new URI(SUBSCRIPTION_URL), newRequest); <line25> } catch (IOException e) { <line26> } catch (URISyntaxException e) { <line27> } <line28> } <line29> } <line30> } <line31> "	<line2>, <line20>, <line22>, <line24>, <line26>, <line27>
5636	"public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSession session) { <line2> FlowFile flowFile = session.get(); <line3> if (flowFile == null) { <line4> return; <line5> } <line6> final Map<String, Pattern> patterns = regexMapRef.get(); <line7> final ComponentLog logger = getLogger(); <line8> final SortedMap<String, String> attributes = getRelevantAttributes(flowFile, patterns); <line9> if (attributes.size() != patterns.size()) { <line10> final Set<String> wantedKeys = patterns.keySet(); <line11> final Set<String> foundKeys = attributes.keySet(); <line12> final StringBuilder missingKeys = new StringBuilder(); <line13> for (final String wantedKey : wantedKeys) { <line14> if (!foundKeys.contains(wantedKey)) { <line15> missingKeys.append(wantedKey).append("" ""); <line16> } <line17> } <line18> session.transfer(flowFile, REL_FAILURE); <line19> } else { <line20> final StringBuilder hashableValue = new StringBuilder(); <line21> for (final Map.Entry<String, String> entry : attributes.entrySet()) { <line22> hashableValue.append(entry.getKey()); <line23> if (StringUtils.isBlank(entry.getValue())) { <line24> hashableValue.append(""EMPTY""); <line25> } else { <line26> hashableValue.append(entry.getValue()); <line27> } <line28> } <line29> final String hashValue = DigestUtils.md5Hex(hashableValue.toString()); <line30> flowFile = <line31> session.putAttribute( <line32> flowFile, context.getProperty(HASH_VALUE_ATTRIBUTE).getValue(), hashValue); <line33> session.getProvenanceReporter().modifyAttributes(flowFile); <line34> session.transfer(flowFile, REL_SUCCESS); <line35> } <line36> } <line37> } <line38> "	<line18>, <line30>
5637	public class A { <line0> @Override <line1> public void executeUnit(Person unit) { <line2> executed.add(unit.getId()); <line3> } <line4> } <line5> 	<line2>
5638	public class A { <line0> @Override <line1> public void dispose() { <line2> if (refreshingActuals) { <line3> refreshActualsRestore(); <line4> } <line5> if (refreshActualsJob != null && !refreshActualsJob.isCancelled()) { <line6> refreshActualsJob.cancel(true); <line7> refreshActualsJob = null; <line8> } <line9> if (bridgeHandler != null) { <line10> bridgeHandler.clearDeviceList(); <line11> bridgeHandler.unregisterDeviceStatusListener(this); <line12> bridgeHandler = null; <line13> } <line14> super.dispose(); <line15> } <line16> } <line17> 	<line2>, <line10>, <line14>
5639	"public class A { <line0> protected Boolean canPrescribe(Drug d) { <line1> if (d == null) { <line2> return false; <line3> } <line4> if (d.getProviderNo() == null || d.getProviderNo().equals("""")) { <line5> return false; <line6> } <line7> if (d.getDemographicId() == null || d.getDemographicId() < 0) { <line8> return false; <line9> } <line10> if (d.getRxDate() == null) { <line11> return false; <line12> } <line13> if (d.getEndDate() == null || d.getRxDate().after(d.getEndDate())) { <line14> return false; <line15> } <line16> if (d.getSpecial() == null || d.getSpecial().equals("""")) { <line17> return false; <line18> } <line19> return true; <line20> } <line21> } <line22> "	<line2>, <line5>, <line8>, <line11>, <line14>, <line17>
5640	"public class A { <line0> @Test <line1> public void testMarkerFiltering() throws Exception { <line2> Slf4jLogger log = new Slf4jLogger(LoggerFactory.getLogger(Slf4jLoggerMarkerTest.class)); <line3> log.warning(""IGNORE_ME"", ""Ignored warning"", null); <line4> log.warning(""ACCEPT_ME"", ""Accepted warning"", null); <line5> File allFile = U.resolveIgnitePath(LOG_ALL); <line6> assertNotNull(allFile); <line7> String all = U.readFileToString(allFile.getPath(), ""UTF-8""); <line8> assertTrue(all.contains(""[IGNORE_ME] Ignored error"")); <line9> assertTrue(all.contains(""[IGNORE_ME] Ignored warning"")); <line10> assertTrue(all.contains(""[IGNORE_ME] Ignored info"")); <line11> assertTrue(all.contains(""[IGNORE_ME] Ignored debug"")); <line12> assertTrue(all.contains(""[IGNORE_ME] Ignored trace"")); <line13> assertTrue(all.contains(""[ACCEPT_ME] Accepted error"")); <line14> assertTrue(all.contains(""[ACCEPT_ME] Accepted warning"")); <line15> assertTrue(all.contains(""[ACCEPT_ME] Accepted info"")); <line16> assertTrue(all.contains(""[ACCEPT_ME] Accepted debug"")); <line17> assertTrue(all.contains(""[ACCEPT_ME] Accepted trace"")); <line18> File filteredFile = U.resolveIgnitePath(LOG_FILTERED); <line19> assertNotNull(filteredFile); <line20> String filtered = U.readFileToString(filteredFile.getPath(), ""UTF-8""); <line21> assertFalse(filtered.contains(""[IGNORE_ME] Ignored error"")); <line22> assertFalse(filtered.contains(""[IGNORE_ME] Ignored warning"")); <line23> assertFalse(filtered.contains(""[IGNORE_ME] Ignored info"")); <line24> assertFalse(filtered.contains(""[IGNORE_ME] Ignored debug"")); <line25> assertFalse(filtered.contains(""[IGNORE_ME] Ignored trace"")); <line26> assertTrue(filtered.contains(""[ACCEPT_ME] Accepted error"")); <line27> assertTrue(filtered.contains(""[ACCEPT_ME] Accepted warning"")); <line28> assertTrue(filtered.contains(""[ACCEPT_ME] Accepted info"")); <line29> assertTrue(filtered.contains(""[ACCEPT_ME] Accepted debug"")); <line30> assertTrue(filtered.contains(""[ACCEPT_ME] Accepted trace"")); <line31> } <line32> } <line33> "	<line3>, <line4>, <line5>
5641	public class A { <line0> public static int getCategoriesByCommerceDiscountIdCount(long commerceDiscountId, String name) <line1> throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommerceDiscountRelServiceUtil.getCategoriesByCommerceDiscountIdCount( <line5> commerceDiscountId, name); <line6> return returnValue; <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>
5642	public class A { <line0> public static String toCanonicalPath(File file) { <line1> try { <line2> return file.getCanonicalPath(); <line3> } catch (IOException e) { <line4> return file.getAbsolutePath(); <line5> } <line6> } <line7> } <line8> 	<line4>
5643	"public class A { <line0> @Override <line1> public void execute() throws Exception { <line2> String subCommandString = getParsedSubCommand(samplesCommandOptions.jCommander); <line3> RestResponse queryResponse = null; <line4> switch (subCommandString) { <line5> case ""create"": <line6> queryResponse = create(); <line7> break; <line8> case ""load"": <line9> queryResponse = load(); <line10> break; <line11> case ""info"": <line12> queryResponse = info(); <line13> break; <line14> case ""search"": <line15> queryResponse = search(); <line16> break; <line17> case ""update"": <line18> queryResponse = update(); <line19> break; <line20> case ""delete"": <line21> queryResponse = delete(); <line22> break; <line23> case ""stats"": <line24> queryResponse = stats(); <line25> break; <line26> case ""acl"": <line27> queryResponse = acl(); <line28> break; <line29> case ""acl-update"": <line30> queryResponse = updateAcl(); <line31> break; <line32> case ""annotation-sets-update"": <line33> queryResponse = updateAnnotations(); <line34> break; <line35> default: <line36> break; <line37> } <line38> createOutput(queryResponse); <line39> } <line40> } <line41> "	<line2>, <line36>
5644	public class A { <line0> @Override <line1> public void run(SourceContext<WindowedValue<byte[]>> ctx) { <line2> int subtaskCount = messageCount / getRuntimeContext().getNumberOfParallelSubtasks(); <line3> if (getRuntimeContext().getIndexOfThisSubtask() <line4> < (messageCount % getRuntimeContext().getNumberOfParallelSubtasks())) { <line5> subtaskCount++; <line6> } <line7> while (running && (messageCount == 0 || count < subtaskCount)) { <line8> synchronized (ctx.getCheckpointLock()) { <line9> ctx.collect( <line10> WindowedValue.valueInGlobalWindow(String.valueOf(count).getBytes(Charsets.UTF_8))); <line11> count++; <line12> } <line13> try { <line14> if (intervalMillis > 0) { <line15> Thread.sleep(intervalMillis); <line16> } <line17> } catch (InterruptedException e) { <line18> } <line19> } <line20> } <line21> } <line22> 	<line18>
5645	public class A { <line0> public static JobRequest getJobRequest(HttpServletRequest request) { <line1> JobRequest jobRequest = (JobRequest) request.getSession().getAttribute(JOB_REQUEST_ATTR); <line2> if (jobRequest != null && jobRequest.getRequestor() != null) { <line3> return jobRequest; <line4> } else { <line5> jobRequest = new JobRequest(getJobUser(request)); <line6> request.getSession().setAttribute(JOB_REQUEST_ATTR, jobRequest); <line7> return jobRequest; <line8> } <line9> } <line10> } <line11> 	<line3>, <line5>
5646	"public class A { <line0> @Test <line1> public void testReadEntity() throws Exception { <line2> final TestOlingo4ResponseHandler<ClientEntity> responseHandler = <line3> new TestOlingo4ResponseHandler<>(); <line4> olingoApp.read(edm, TEST_AIRLINE, null, null, responseHandler); <line5> ClientEntity entity = responseHandler.await(); <line6> assertEquals(""Shanghai Airline"", entity.getProperty(""Name"").getValue().toString()); <line7> responseHandler.reset(); <line8> olingoApp.read(edm, TEST_PEOPLE, null, null, responseHandler); <line9> entity = responseHandler.await(); <line10> assertEquals(""Russell"", entity.getProperty(""FirstName"").getValue().toString()); <line11> responseHandler.reset(); <line12> final Map<String, String> queryParams = new HashMap<>(); <line13> queryParams.put(SystemQueryOptionKind.EXPAND.toString(), TRIPS); <line14> olingoApp.read(edm, TEST_PEOPLE, queryParams, null, responseHandler); <line15> ClientEntity entityExpanded = responseHandler.await(); <line16> } <line17> } <line18> "	<line7>, <line11>, <line16>
5647	"public class A { <line0> @Override <line1> public void deleteBuildGroup() throws RepositoryManagerException { <line2> StopWatch stopWatch = StopWatch.createStarted(); <line3> try { <line4> StoreKey key = new StoreKey(packageType, StoreType.group, buildContentId); <line5> serviceAccountIndy <line6> .stores() <line7> .delete(key, ""[Post-Build] Removing build aggregation group: "" + buildContentId); <line8> } catch (IndyClientException e) { <line9> throw new RepositoryManagerException( <line10> ""Failed to retrieve Indy stores module. Reason: %s"", e, e.getMessage()); <line11> } <line12> stopWatch.reset(); <line13> } <line14> } <line15> "	<line2>, <line12>
5648	"public class A { <line0> public static ResponseEntity<Object> respondIdsMessageFailed(final Exception exception) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> return new ResponseEntity<>( <line4> ""Ids message handling failed. "" + exception.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); <line5> } <line6> } <line7> "	<line2>
5649	public class A { <line0> @Override <line1> public void run() { <line2> synchronized (isOpen) { <line3> while (isOpen.get() || !buffer.isEmpty()) { <line4> try { <line5> Result result = buffer.pollLast(waitTime.get(), TimeUnit.MILLISECONDS); <line6> if (result != null) { <line7> resultCount.incrementAndGet(); <line8> jgen.writeObject(result); <line9> } <line10> } catch (InterruptedException e) { <line11> } catch (JsonProcessingException e) { <line12> } catch (IOException e) { <line13> } <line14> } <line15> isOpen.notifyAll(); <line16> } <line17> } <line18> } <line19> 	<line11>, <line12>, <line13>
5650	"public class A { <line0> public void joinTournament(String engineEndpoint, int numOfPlayers) { <line1> this.getStatus().setState(PlayerStatus.State.Requesting); <line2> Client client = ClientBuilder.newClient(new ClientConfig().register(LoggingFeature.class)); <line3> WebTarget webTarget = client.target(engineEndpoint).path(""api/v0.1/tournament/join""); <line4> Invocation.Builder invocationBuilder = webTarget.request(MediaType.APPLICATION_JSON); <line5> GameTicket ticket = new GameTicket(this, numOfPlayers); <line6> Response response = invocationBuilder.put(Entity.entity(ticket, MediaType.APPLICATION_JSON)); <line7> GameStatusResponse status = response.readEntity(GameStatusResponse.class); <line8> if (status.getState() == GameStatus.State.WaitingForPlayers <line9> || status.getState() == GameStatus.State.Starting) { <line10> this.getStatus().setState(PlayerStatus.State.Waiting); <line11> } <line12> } <line13> } <line14> "	<line12>
5651	"public class A { <line0> @Override <line1> public ListenableFuture<Boolean> executeFilterAsync(TbMsg msg) { <line2> ListenableFuture<JsonNode> result = executeScriptAsync(msg); <line3> return Futures.transformAsync( <line4> result, <line5> json -> { <line6> if (!json.isBoolean()) { <line7> return Futures.immediateFailedFuture( <line8> new ScriptException(""Wrong result type: "" + json.getNodeType())); <line9> } else { <line10> return Futures.immediateFuture(json.asBoolean()); <line11> } <line12> }, <line13> MoreExecutors.directExecutor()); <line14> } <line15> } <line16> "	<line7>
5652	public class A { <line0> public static void close(ResultSet x) { <line1> if (x == null) { <line2> return; <line3> } <line4> try { <line5> x.close(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	<line7>
5653	"public class A { <line0> @Override <line1> public String renderHTML(FileVersion fileVersion, HttpServletRequest httpServletRequest) { <line2> DLVideoExternalShortcut dlVideoExternalShortcut = <line3> _dlVideoExternalShortcutResolver.resolve(fileVersion); <line4> if (dlVideoExternalShortcut != null) { <line5> return dlVideoExternalShortcut.renderHTML(httpServletRequest); <line6> } <line7> try { <line8> ThemeDisplay themeDisplay = <line9> (ThemeDisplay) httpServletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line10> return StringBundler.concat( <line11> ""<iframe data-video-liferay height=\""315\"" frameborder=\""0\"" "", <line12> ""src=\"""", <line13> _dlURLHelper.getPreviewURL( <line14> fileVersion.getFileEntry(), <line15> fileVersion, <line16> themeDisplay, <line17> ""&videoEmbed=true"", <line18> true, <line19> false), <line20> ""\"" width=\""560\""></iframe>""); <line21> } catch (PortalException portalException) { <line22> return null; <line23> } <line24> } <line25> } <line26> "	<line22>
5654	"public class A { <line0> @Override <line1> public final void close() { <line2> Connection conn = null; <line3> try { <line4> conn = DriverManager.getConnection(""jdbc:derby:;shutdown=true""); <line5> } catch (SQLException se) { <line6> if ((se.getErrorCode() == 50000) && (se.getSQLState().equals(""XJ015""))) { <line7> } else { <line8> } <line9> } finally { <line10> CatalogUtil.closeQuietly(conn); <line11> } <line12> } <line13> } <line14> "	<line7>, <line8>, <line12>
5655	"public class A { <line0> private Operation executeSynchronously( <line1> ComputeRequest<Operation> request, String projectName, String zoneName, String opName) { <line2> Operation asyncOp = executeWithRetries(request::execute, opName); <line3> String logId = format(""Operation [%s:%s]"", asyncOp.getOperationType(), asyncOp.getName()); <line4> while (RUNNING_STATUS.equals(operationStatus(asyncOp.getName(), zoneName))) { <line5> try { <line6> Thread.sleep(1000); <line7> } catch (InterruptedException ie) { <line8> Thread.currentThread().interrupt(); <line9> } <line10> } <line11> return executeWithRetries( <line12> () -> compute.zoneOperations().get(projectName, zoneName, asyncOp.getName()).execute(), <line13> GET_ZONE_OPERATIONS); <line14> } <line15> } <line16> "	<line4>, <line5>
5656	public class A { <line0> public static int getSiteNavigationMenusCount(long[] groupIds) throws RemoteException { <line1> try { <line2> int returnValue = SiteNavigationMenuServiceUtil.getSiteNavigationMenusCount(groupIds); <line3> return returnValue; <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>
5657	"public class A { <line0> protected void addDefaultVRProvider(Connection conn, long physicalNetworkId, long zoneId) { <line1> PreparedStatement pstmtUpdate = null, pstmt2 = null; <line2> try { <line3> String insertPNSP = <line4> ""INSERT INTO `cloud`.`physical_network_service_providers` (`uuid`, `physical_network_id`"" <line5> + "" , `provider_name`, `state` ,`destination_physical_network_id`,"" <line6> + "" `vpn_service_provided`, `dhcp_service_provided`, `dns_service_provided`,"" <line7> + "" `gateway_service_provided`,`firewall_service_provided`,"" <line8> + "" `source_nat_service_provided`, `load_balance_service_provided`,"" <line9> + "" `static_nat_service_provided`,`port_forwarding_service_provided`,"" <line10> + "" `user_data_service_provided`, `security_group_service_provided`) VALUES"" <line11> + "" (?,?,?,?,0,1,1,1,1,1,1,1,1,1,1,0)""; <line12> String routerUUID = UUID.randomUUID().toString(); <line13> pstmtUpdate = conn.prepareStatement(insertPNSP); <line14> pstmtUpdate.setString(1, routerUUID); <line15> pstmtUpdate.setLong(2, physicalNetworkId); <line16> pstmtUpdate.setString(3, ""VirtualRouter""); <line17> pstmtUpdate.setString(4, ""Enabled""); <line18> pstmtUpdate.executeUpdate(); <line19> pstmtUpdate.close(); <line20> String fetchNSPid = <line21> ""SELECT id from `cloud`.`physical_network_service_providers` where physical_network_id="" <line22> + physicalNetworkId <line23> + "" AND provider_name = 'VirtualRouter' AND uuid = ?""; <line24> pstmt2 = conn.prepareStatement(fetchNSPid); <line25> pstmt2.setString(1, routerUUID); <line26> ResultSet rsNSPid = pstmt2.executeQuery(); <line27> rsNSPid.next(); <line28> long nspId = rsNSPid.getLong(1); <line29> pstmt2.close(); <line30> String insertRouter = <line31> ""INSERT INTO `cloud`.`virtual_router_providers` (`nsp_id`, `uuid` , `type` , `enabled`) "" <line32> + ""VALUES (?,?,?,?)""; <line33> pstmtUpdate = conn.prepareStatement(insertRouter); <line34> pstmtUpdate.setLong(1, nspId); <line35> pstmtUpdate.setString(2, UUID.randomUUID().toString()); <line36> pstmtUpdate.setString(3, ""VirtualRouter""); <line37> pstmtUpdate.setInt(4, 1); <line38> pstmtUpdate.executeUpdate(); <line39> pstmtUpdate.close(); <line40> } catch (SQLException e) { <line41> throw new CloudRuntimeException(""Exception while adding PhysicalNetworks"", e); <line42> } finally { <line43> closeAutoCloseable(pstmt2); <line44> closeAutoCloseable(pstmtUpdate); <line45> } <line46> } <line47> } <line48> "	<line3>
5658	"public class A { <line0> public static void configure(ConfigThingy config) { <line1> String formatOption = ""roman""; <line2> String nameOption = ""Abdruck""; <line3> for (PrintBlockSignature pbName : PrintBlockSignature.values()) { <line4> highlightColors.put(pbName, null); <line5> } <line6> try { <line7> if (config != null) { <line8> ConfigThingy conf = config.query(""SachleitendeVerfuegungen""); <line9> if (conf.count() > 0) { <line10> conf = conf.getLastChild(); <line11> for (ConfigThingy child : conf) { <line12> switch (child.getName()) { <line13> case ""NUMBERS"": <line14> formatOption = child.toString(); <line15> break; <line16> case ""ABDRUCK_NAME"": <line17> nameOption = child.toString(); <line18> break; <line19> case ""ALL_VERSIONS_HIGHLIGHT_COLOR"": <line20> highlightColors.put( <line21> PrintBlockSignature.ALL_VERSIONS, checkHighlightColor(child.toString())); <line22> break; <line23> case ""DRAFT_ONLY_HIGHLIGHT_COLOR"": <line24> highlightColors.put( <line25> PrintBlockSignature.DRAFT_ONLY, checkHighlightColor(child.toString())); <line26> break; <line27> case ""NOT_IN_ORIGINAL_HIGHLIGHT_COLOR"": <line28> highlightColors.put( <line29> PrintBlockSignature.NOT_IN_ORIGINAL, checkHighlightColor(child.toString())); <line30> break; <line31> case ""ORIGINAL_ONLY_HIGHLIGHT_COLOR"": <line32> highlightColors.put( <line33> PrintBlockSignature.ORIGINAL_ONLY, checkHighlightColor(child.toString())); <line34> break; <line35> case ""COPY_ONLY_HIGHLIGHT_COLOR"": <line36> highlightColors.put( <line37> PrintBlockSignature.COPY_ONLY, checkHighlightColor(child.toString())); <line38> break; <line39> default: <line40> } <line41> } <line42> } <line43> } <line44> } catch (NodeNotFoundException e) { <line45> } finally { <line46> format = NumberFormat.valueOf(formatOption.toUpperCase()); <line47> copyName = nameOption; <line48> } <line49> } <line50> } <line51> "	<line40>, <line45>, <line47>, <line48>
5659	"public class A { <line0> @Override <line1> public List<String> getSupportedTypes() { <line2> final List<String> types = new ArrayList<>(); <line3> for (final String type : ManagementBusInvocationPluginRest.TYPES.split(""[,;]"")) { <line4> types.add(type.trim()); <line5> } <line6> return types; <line7> } <line8> } <line9> "	<line2>
5660	"public class A { <line0> @Override <line1> public List<ConfidenceData> getDataByCrisisAttributeLabelGranularity( <line2> String crisisCode, String attributeCode, String labelCode, Long granularity) { <line3> Criteria criteria = getCurrentSession().createCriteria(ConfidenceData.class); <line4> Criterion criterion = <line5> Restrictions.conjunction() <line6> .add(Restrictions.eq(""crisisCode"", crisisCode)) <line7> .add(Restrictions.eq(""attributeCode"", attributeCode)) <line8> .add(Restrictions.eq(""labelCode"", labelCode)) <line9> .add(Restrictions.eq(""granularity"", granularity)); <line10> criteria.add(criterion); <line11> try { <line12> List<ConfidenceData> objList = (List<ConfidenceData>) criteria.list(); <line13> return objList; <line14> } catch (HibernateException e) { <line15> e.printStackTrace(); <line16> } <line17> return null; <line18> } <line19> } <line20> "	<line15>
5661	public class A { <line0> @Override <line1> protected Map<String, String> modifyIniFile( <line2> String commaSeparatedFilePaths, String commaSeparatedParentAccessions) { <line3> Map<String, String> iniFileMap = new TreeMap<>(); <line4> iniFileMap.put(ReservedIniKeys.INPUT_FILE.getKey(), commaSeparatedFilePaths); <line5> return iniFileMap; <line6> } <line7> } <line8> 	<line3>
5662	public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> try { <line3> handleCommandInternal(channelUID, command); <line4> updateModuleStatus(); <line5> } catch (SmartherIllegalPropertyValueException e) { <line6> } catch (SmartherGatewayException e) { <line7> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line6>
5663	"public class A { <line0> public void scp(String origFile, String targetFile) { <line1> OverthereFile motd = connection.getFile(targetFile); <line2> OutputStream w = motd.getOutputStream(); <line3> try { <line4> byte[] origBytes = Files.readAllBytes(Paths.get(origFile)); <line5> w.write(origBytes); <line6> w.close(); <line7> } catch (IOException e) { <line8> throw new KurentoException(""Exception in SCP "" + origFile + "" "" + targetFile, e); <line9> } <line10> } <line11> } <line12> "	<line1>
5664	public class A { <line0> @Override <line1> public boolean isVisible(User user, CommerceInventoryWarehouse commerceInventoryWarehouse) { <line2> boolean hasCustomAttributesAvailable = false; <line3> try { <line4> long classPK = 0; <line5> if (commerceInventoryWarehouse != null) { <line6> classPK = commerceInventoryWarehouse.getCommerceInventoryWarehouseId(); <line7> } <line8> hasCustomAttributesAvailable = <line9> CustomAttributesUtil.hasCustomAttributes( <line10> user.getCompanyId(), CommerceInventoryWarehouse.class.getName(), classPK, null); <line11> } catch (Exception exception) { <line12> if (_log.isDebugEnabled()) { <line13> } <line14> } <line15> return hasCustomAttributesAvailable; <line16> } <line17> } <line18> 	<line13>
5665	public class A { <line0> private void closeAllConnections() { <line1> try { <line2> executors.execute( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> for (RedisSession session : sessions.values()) { <line7> session.closeConnection(); <line8> } <line9> } <line10> }); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> 	<line12>
5666	"public class A { <line0> @Test <line1> public void testSearchWithOwnerAndEnum() { <line2> final Class testUserType = createTestUserType(); <line3> try { <line4> final List<Principal> users = createTestNodes(testUserType, 3); <line5> final List<TestThree> testThrees = new LinkedList<>(); <line6> final Random random = new Random(); <line7> String uuid = null; <line8> int count = 0; <line9> try (final Tx tx = app.tx()) { <line10> for (final Principal user : users) { <line11> for (int i = 0; i < 20; i++) { <line12> testThrees.add( <line13> app.create( <line14> TestThree.class, <line15> new NodeAttribute(AbstractNode.name, ""test"" + count++), <line16> new NodeAttribute(AbstractNode.owner, user), <line17> new NodeAttribute( <line18> TestThree.enumProperty, <line19> TestEnum.values()[random.nextInt(TestEnum.values().length)]))); <line20> } <line21> } <line22> uuid = users.get(0).getUuid(); <line23> tx.success(); <line24> } <line25> try (final Tx tx = app.tx()) { <line26> for (final Principal user : users) { <line27> for (final TestThree test : <line28> app.nodeQuery(TestThree.class) <line29> .and(AbstractNode.owner, user) <line30> .and(TestThree.enumProperty, TestEnum.Status1) <line31> .getAsList()) { <line32> assertEquals( <line33> ""Invalid enum query result"", <line34> TestEnum.Status1, <line35> test.getProperty(TestThree.enumProperty)); <line36> } <line37> } <line38> tx.success(); <line39> } <line40> RestAssured.given() <line41> .contentType(""application/json; charset=UTF-8"") <line42> .filter(ResponseLoggingFilter.logResponseIfStatusCodeIs(500)) <line43> .expect() <line44> .statusCode(200) <line45> .when() <line46> .get( <line47> concat( <line48> ""/test_threes?sort=createdDate&owner="" <line49> + uuid <line50> + ""&enumProperty="" <line51> + TestEnum.Status1)); <line52> } catch (FrameworkException ex) { <line53> ex.printStackTrace(); <line54> fail(""Unexpected exception""); <line55> } <line56> } <line57> } <line58> "	<line54>
5667	public class A { <line0> @Override <line1> public void startElement(final QName qname, final AttrList attribs) throws SAXException { <line2> if (qname.getNamespaceURI() != null && qname.getNamespaceURI().equals(Namespaces.XINCLUDE_NS)) { <line3> if (qname.getLocalPart().equals(XI_INCLUDE)) { <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> final Optional<ResourceError> maybeResourceError = <line7> processXInclude(attribs.getValue(HREF_ATTRIB), attribs.getValue(XPOINTER_ATTRIB)); <line8> if (maybeResourceError.isPresent()) { <line9> final ResourceError resourceError = maybeResourceError.get(); <line10> if (LOG.isDebugEnabled()) { <line11> } <line12> error = resourceError; <line13> } <line14> } else if (qname.getLocalPart().equals(XI_FALLBACK)) { <line15> inFallback = true; <line16> } <line17> } else if (!inFallback || error != null) { <line18> receiver.startElement(qname, attribs); <line19> } <line20> } <line21> } <line22> 	<line5>, <line11>
5668	"public class A { <line0> protected void setupClientMatrix(WebClient client, Exchange exchange) throws Exception { <line1> org.apache.cxf.message.Message cxfMessage = <line2> (org.apache.cxf.message.Message) exchange.getIn().getHeader(""CamelCxfMessage""); <line3> if (cxfMessage != null) { <line4> String requestURL = (String) cxfMessage.get(""org.apache.cxf.request.uri""); <line5> String matrixParam = null; <line6> int matrixStart = requestURL.indexOf(';'); <line7> int matrixEnd = requestURL.indexOf('?') > -1 ? requestURL.indexOf('?') : requestURL.length(); <line8> Map<String, String> maps = null; <line9> if (requestURL != null && matrixStart > 0) { <line10> matrixParam = requestURL.substring(matrixStart + 1, matrixEnd); <line11> if (matrixParam != null) { <line12> maps = <line13> getMatrixParametersFromMatrixString( <line14> matrixParam, ExchangeHelper.getCharsetName(exchange)); <line15> } <line16> } <line17> if (maps != null) { <line18> for (Map.Entry<String, String> entry : maps.entrySet()) { <line19> client.matrix(entry.getKey(), entry.getValue()); <line20> } <line21> } <line22> } <line23> } <line24> } <line25> "	<line20>
5669	public class A { <line0> private PoxPayloadOut createUocInstance(String referenceNumber, String title) throws Exception { <line1> UocCommon uocCommon = new UocCommon(); <line2> uocCommon.setTitle(title); <line3> uocCommon.setReferenceNumber(referenceNumber); <line4> PoxPayloadOut multipart = new PoxPayloadOut(this.getServicePathComponent()); <line5> PayloadOutputPart commonPart = <line6> multipart.addPart(new UocClient().getCommonPartName(), uocCommon); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> return multipart; <line10> } <line11> } <line12> 	<line8>
5670	"public class A { <line0> public synchronized void restartSearch() { <line1> if (!started) { <line2> throw new IllegalStateException(""Runner is stopped""); <line3> } <line4> try { <line5> if (!syncReplClient.isComplete()) { <line6> syncReplClient.cancel(); <line7> } <line8> } catch (Exception e) { <line9> } <line10> try { <line11> syncReplClient.send(searchRequest, cookieManager); <line12> } catch (LdapException e) { <line13> throw new IllegalStateException(""Could not send sync repl request"", e); <line14> } <line15> } <line16> } <line17> "	<line9>
5671	"public class A { <line0> public void runGenomeInfo() throws IOException, InterruptedException { <line1> String outputFolder = <line2> downloadFolder.getParent().toAbsolutePath().toString() + ""/generated_json/""; <line3> if (""true"".equals(System.getenv(""CELLBASE_BUILD_DOCKER""))) { <line4> String outputLog = downloadLogFolder + ""/genome_info.log""; <line5> EtlCommons.runCommandLineProcess( <line6> null, ""/opt/cellbase/genome_info.pl"", Arrays.asList(""--outdir"", outputFolder), outputLog); <line7> } else { <line8> String dockerImage = ""opencb/cellbase-builder:"" + configuration.getApiVersion(); <line9> AbstractMap.SimpleEntry<String, String> outputBinding = <line10> new AbstractMap.SimpleEntry(outputFolder, ""/ensembl-data""); <line11> String ensemblScriptParams = ""/opt/cellbase/genome_info.pl""; <line12> DockerUtils.run(dockerImage, null, outputBinding, ensemblScriptParams, null); <line13> } <line14> } <line15> } <line16> "	<line1>
5672	"public class A { <line0> @Test <line1> public void resolveOfEmailWithTagsReturnsEntity() throws Exception { <line2> idsMan.addEntity( <line3> new IdentityParam(EmailIdentity.ID, ""a+zzz@ex.com""), ""cr-pass"", EntityState.valid); <line4> HttpClient client = getClient(); <line5> HttpHost host = new HttpHost(""localhost"", 53456, ""https""); <line6> HttpContext localcontext = getClientContext(host); <line7> HttpGet resolve = new HttpGet(""/restadm/v1/resolve/email/a+foo@ex.com""); <line8> HttpResponse response = client.execute(host, resolve, localcontext); <line9> String contents = EntityUtils.toString(response.getEntity()); <line10> assertEquals(contents, Status.OK.getStatusCode(), response.getStatusLine().getStatusCode()); <line11> } <line12> } <line13> "	<line11>
5673	"public class A { <line0> public IRODSMidLevelProtocol currentConnectionCheckRenewalOfSocket( <line1> final IRODSAccount irodsAccount) throws AuthenticationException, JargonException { <line2> if (irodsAccount == null) { <line3> throw new IllegalArgumentException(""null irodsAccount""); <line4> } <line5> IRODSMidLevelProtocol irodsMidLevelProtocol = currentConnection(irodsAccount); <line6> boolean shutdown = evaluateConnectionForRenewal(irodsMidLevelProtocol); <line7> if (!shutdown) { <line8> return irodsMidLevelProtocol; <line9> } else { <line10> return currentConnection(irodsAccount); <line11> } <line12> } <line13> } <line14> "	<line2>, <line6>, <line10>
5674	public class A { <line0> @Override <line1> public void onClick(AjaxRequestTarget aTarget) { <line2> try { <line3> action.accept(aTarget); <line4> } catch (Exception e) { <line5> Page page = (Page) PageRequestHandlerTracker.getLastHandler(RequestCycle.get()).getPage(); <line6> aTarget.addChildren(page, IFeedback.class); <line7> } <line8> } <line9> } <line10> 	<line6>
5675	public class A { <line0> public void disconnect() { <line1> if (client != null) { <line2> try { <line3> client.close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>
5676	"public class A { <line0> private static boolean isLog4jJmxEnabled() { <line1> boolean enabled = false; <line2> if (Boolean.getBoolean(""zookeeper.jmx.log4j.disable"")) { <line3> } else { <line4> try { <line5> Class.forName(""org.apache.log4j.jmx.HierarchyDynamicMBean""); <line6> enabled = true; <line7> } catch (ClassNotFoundException e) { <line8> } <line9> } <line10> return enabled; <line11> } <line12> } <line13> "	<line3>, <line7>, <line8>
5677	public class A { <line0> protected void applyMCTS(final Game game, final NextAction action) { <line1> int thinkTime = calculateThinkTime(game, action); <line2> if (thinkTime > 0) { <line3> if (USE_MULTIPLE_THREADS) { <line4> ExecutorService pool = Executors.newFixedThreadPool(poolSize); <line5> List<MCTSExecutor> tasks = new ArrayList<>(); <line6> for (int i = 0; i < poolSize; i++) { <line7> Game sim = createMCTSGame(game); <line8> MCTSPlayer player = (MCTSPlayer) sim.getPlayer(playerId); <line9> player.setNextAction(action); <line10> MCTSExecutor exec = new MCTSExecutor(sim, playerId, thinkTime); <line11> tasks.add(exec); <line12> } <line13> try { <line14> pool.invokeAll(tasks, thinkTime, TimeUnit.SECONDS); <line15> pool.awaitTermination(1, TimeUnit.SECONDS); <line16> pool.shutdownNow(); <line17> } catch (InterruptedException | RejectedExecutionException ex) { <line18> } <line19> int simCount = 0; <line20> for (MCTSExecutor task : tasks) { <line21> simCount += task.getSimCount(); <line22> root.merge(task.getRoot()); <line23> task.clear(); <line24> } <line25> tasks.clear(); <line26> totalThinkTime += thinkTime; <line27> totalSimulations += simCount; <line28> MCTSNode.logHitMiss(); <line29> } else { <line30> long startTime = System.nanoTime(); <line31> long endTime = startTime + (thinkTime * 1000000000l); <line32> MCTSNode current; <line33> int simCount = 0; <line34> while (true) { <line35> long currentTime = System.nanoTime(); <line36> if (currentTime > endTime) break; <line37> current = root; <line38> while (!current.isLeaf()) { <line39> current = current.select(this.playerId); <line40> } <line41> int result; <line42> if (!current.isTerminal()) { <line43> current.expand(); <line44> current = current.select(this.playerId); <line45> result = current.simulate(this.playerId); <line46> simCount++; <line47> } else { <line48> result = current.isWinner(this.playerId) ? 1 : -1; <line49> } <line50> current.backpropagate(result); <line51> } <line52> } <line53> } <line54> } <line55> } <line56> 	<line18>, <line28>, <line52>
5678	public class A { <line0> void enrichTextUnitsWithUsages(List<GitBlameWithUsage> gitBlameWithUsages) { <line1> Map<Long, GitBlameWithUsage> assetTextUnitIdToGitBlameWithUsage = new HashMap<>(); <line2> for (GitBlameWithUsage textUnitWithUsage : gitBlameWithUsages) { <line3> if (textUnitWithUsage.getAssetTextUnitId() != null) { <line4> assetTextUnitIdToGitBlameWithUsage.put( <line5> textUnitWithUsage.getAssetTextUnitId(), textUnitWithUsage); <line6> } <line7> } <line8> List<AssetTextUnit> assetTextUnits = <line9> assetTextUnitRepository.findByIdIn( <line10> new ArrayList<Long>(assetTextUnitIdToGitBlameWithUsage.keySet())); <line11> for (AssetTextUnit assetTextUnit : assetTextUnits) { <line12> GitBlameWithUsage gitBlameWithUsage = <line13> assetTextUnitIdToGitBlameWithUsage.get(assetTextUnit.getId()); <line14> gitBlameWithUsage.setUsages(assetTextUnit.getUsages()); <line15> gitBlameWithUsage.setBranch(assetTextUnit.getBranch()); <line16> } <line17> } <line18> } <line19> 	<line1>, <line8>, <line17>
5679	"public class A { <line0> @OperationMethod <line1> public Blob run(DocumentModelList docs) throws IOException { <line2> DownloadService downloadService = Framework.getService(DownloadService.class); <line3> List<Blob> blobs = <line4> docs.stream() <line5> .map( <line6> doc -> { <line7> Blob blob = downloadService.resolveBlob(doc); <line8> if (blob == null) { <line9> return null; <line10> } <line11> if (!downloadService.checkPermission( <line12> doc, null, blob, DOWNLOAD_REASON, Collections.emptyMap())) { <line13> return null; <line14> } <line15> downloadService.logDownload( <line16> null, doc, null, blob.getFilename(), DOWNLOAD_REASON, null); <line17> return blob; <line18> }) <line19> .filter(Objects::nonNull) <line20> .collect(Collectors.toList()); <line21> if (blobs.isEmpty()) { <line22> return null; <line23> } <line24> String filename = <line25> StringUtils.isNotBlank(this.fileName) <line26> ? this.fileName <line27> : String.format( <line28> ""BlobListZip-%s-%s"", UUID.randomUUID(), session.getPrincipal().getName()); <line29> return BlobUtils.zip(blobs, filename); <line30> } <line31> } <line32> "	<line9>, <line13>, <line22>
5680	public class A { <line0> public static void deleteCalendarBookingInstance( <line1> long calendarBookingId, long startTime, boolean allFollowing) throws RemoteException { <line2> try { <line3> CalendarBookingServiceUtil.deleteCalendarBookingInstance( <line4> calendarBookingId, startTime, allFollowing); <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>
5681	"public class A { <line0> public JSONObject createErrorJSONObject( <line1> ActionRequest actionRequest, PortalException portalException) { <line2> if (_log.isDebugEnabled()) { <line3> } <line4> ThemeDisplay themeDisplay = (ThemeDisplay) actionRequest.getAttribute(WebKeys.THEME_DISPLAY); <line5> ResourceBundle resourceBundle = <line6> ResourceBundleUtil.getBundle( <line7> themeDisplay.getLocale(), LayoutPageTemplateEntryExceptionRequestHandler.class); <line8> String errorMessage = null; <line9> if (portalException instanceof LayoutPageTemplateEntryNameException.MustNotBeDuplicate) { <line10> errorMessage = <line11> LanguageUtil.get(resourceBundle, ""a-page-template-entry-with-that-name-already-exists""); <line12> } else if (portalException instanceof LayoutPageTemplateEntryNameException.MustNotBeNull) { <line13> errorMessage = LanguageUtil.get(resourceBundle, ""name-must-not-be-empty""); <line14> } else if (portalException <line15> instanceof LayoutPageTemplateEntryNameException.MustNotContainInvalidCharacters) { <line16> LayoutPageTemplateEntryNameException.MustNotContainInvalidCharacters lptene = <line17> (LayoutPageTemplateEntryNameException.MustNotContainInvalidCharacters) portalException; <line18> errorMessage = <line19> LanguageUtil.format( <line20> resourceBundle, <line21> ""name-cannot-contain-the-following-invalid-character-x"", <line22> lptene.character); <line23> } else if (portalException <line24> instanceof LayoutPageTemplateEntryNameException.MustNotExceedMaximumSize) { <line25> int nameMaxLength = <line26> ModelHintsUtil.getMaxLength(LayoutPageTemplateEntry.class.getName(), ""name""); <line27> errorMessage = <line28> LanguageUtil.format( <line29> resourceBundle, ""please-enter-a-name-with-fewer-than-x-characters"", nameMaxLength); <line30> } <line31> if (Validator.isNull(errorMessage)) { <line32> errorMessage = LanguageUtil.get(resourceBundle, ""an-unexpected-error-occurred""); <line33> } <line34> return JSONUtil.put(""error"", errorMessage); <line35> } <line36> } <line37> "	<line3>, <line33>
5682	public class A { <line0> public CheckPolicyRequestType transformPatientDiscoveryEntityToCheckPolicy( <line1> RespondingGatewayPRPAIN201305UV02RequestType event) { <line2> if (event == null) { <line3> return null; <line4> } <line5> CheckPolicyRequestType checkPolicyRequest = <line6> transformPRPAIN201305UV02ToCheckPolicy(event.getPRPAIN201305UV02(), event.getAssertion()); <line7> return checkPolicyRequest; <line8> } <line9> } <line10> 	<line2>, <line3>, <line7>
5683	"public class A { <line0> @Test <line1> public void testRedefineTerms() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> Map<String, Object> properties = new LinkedHashMap<String, Object>(); <line5> properties.put(""username"", ""edanuff""); <line6> properties.put(""email"", ""ed@anuff.com""); <line7> em.create(""user"", properties); <line8> app.waitForQueueDrainAndRefreshIndex(); <line9> String s = ""select {name: username, email: email} where username = 'edanuff'""; <line10> Query query = Query.fromQL(s); <line11> Results r = em.searchCollection(em.getApplicationRef(), ""users"", query); <line12> assertTrue(r.size() == 1); <line13> } <line14> } <line15> "	<line2>
5684	"public class A { <line0> @VisibleForTesting <line1> @SuppressWarnings(""unchecked"") <line2> Map<String, Predicate> minimizeFor(StorageKey key) { <line3> Map<String, Predicate> unsatisfied = Maps.newHashMap(constraints); <line4> PartitionStrategy strategy = key.getPartitionStrategy(); <line5> Set<String> timeFields = Sets.newHashSet(); <line6> int i = 0; <line7> for (FieldPartitioner fp : Accessor.getDefault().getFieldPartitioners(strategy)) { <line8> String partition = fp.getName(); <line9> Predicate partitionPredicate = unsatisfied.get(partition); <line10> if (partitionPredicate != null && partitionPredicate.apply(key.get(i))) { <line11> unsatisfied.remove(partition); <line12> } <line13> String source = fp.getSourceName(); <line14> if (fp instanceof CalendarFieldPartitioner) { <line15> timeFields.add(source); <line16> } <line17> Predicate original = unsatisfied.get(source); <line18> if (original != null) { <line19> Predicate isSatisfiedBy = fp.projectStrict(original); <line20> LOG.debug(""original: "" + original + "", strict: "" + isSatisfiedBy); <line21> if ((isSatisfiedBy != null) && isSatisfiedBy.apply(key.get(i))) { <line22> unsatisfied.remove(source); <line23> } <line24> } <line25> i += 1; <line26> } <line27> for (String timeField : timeFields) { <line28> Predicate<Long> original = unsatisfied.get(timeField); <line29> if (original != null) { <line30> Predicate<Marker> isSatisfiedBy = <line31> TimeDomain.get(strategy, timeField).projectStrict(original); <line32> if ((isSatisfiedBy != null) && isSatisfiedBy.apply(key)) { <line33> unsatisfied.remove(timeField); <line34> } <line35> } <line36> } <line37> return ImmutableMap.copyOf(unsatisfied); <line38> } <line39> } <line40> "	<line12>, <line22>, <line32>, <line33>
5685	public class A { <line0> public org.talend.mdm.webservice.WSBoolean isItemModifiedByOther( <line1> org.talend.mdm.webservice.WSIsItemModifiedByOther arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSBoolean _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	<line2>
5686	public class A { <line0> @Override <line1> public int getNumberOfResources() { <line2> return ResourceManager.getTotalNumberOfWorkers(); <line3> } <line4> } <line5> 	<line2>
5687	public class A { <line0> private void checkSeedNodesStatus() <line1> throws ConfigInconsistentException, StartUpCheckFailureException { <line2> if (getAllNodes().size() == 1) { <line3> return; <line4> } <line5> boolean canEstablishCluster = false; <line6> long startTime = System.currentTimeMillis(); <line7> AtomicInteger consistentNum = new AtomicInteger(1); <line8> AtomicInteger inconsistentNum = new AtomicInteger(0); <line9> while (!canEstablishCluster) { <line10> consistentNum.set(1); <line11> inconsistentNum.set(0); <line12> checkSeedNodesStatusOnce(consistentNum, inconsistentNum); <line13> canEstablishCluster = <line14> analyseStartUpCheckResult( <line15> consistentNum.get(), inconsistentNum.get(), getAllNodes().size()); <line16> if (System.currentTimeMillis() - startTime > ClusterUtils.START_UP_TIME_THRESHOLD_MS) { <line17> throw new StartUpCheckFailureException(); <line18> } else if (!canEstablishCluster) { <line19> try { <line20> Thread.sleep(ClusterUtils.START_UP_CHECK_TIME_INTERVAL_MS); <line21> } catch (InterruptedException e) { <line22> Thread.currentThread().interrupt(); <line23> } <line24> } <line25> } <line26> } <line27> } <line28> 	<line23>
5688	public class A { <line0> @PostConstruct <line1> public void start() { <line2> if (!isSlave) { <line3> cleanupUnusedSlavesExecutorService.scheduleWithFixedDelay( <line4> this::cleanupUnusedSlaves, 0, CLEANUP_SLAVES_INTERVAL_IN_MINUTES, TimeUnit.MINUTES); <line5> } <line6> if (isSlave && isStarted.compareAndSet(false, true)) { <line7> claimSlaveEnvironments(); <line8> keepaliveExecutorService.scheduleWithFixedDelay( <line9> this::keepAlive, <line10> 0, <line11> apolloConfiguration.getSlave().getKeepaliveIntervalSeconds(), <line12> TimeUnit.SECONDS); <line13> } <line14> } <line15> } <line16> 	<line2>
5689	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> report.lastReportAt = generateReport(); <line4> if (ctx.channel().isWritable()) { <line5> ctx.writeAndFlush( <line6> makeUTF8StringMessage(EXPORT_REPORT, message.id, report.toString()), ctx.voidPromise()); <line7> } <line8> } catch (Exception e) { <line9> ctx.writeAndFlush(illegalCommand(message.id), ctx.voidPromise()); <line10> } <line11> } <line12> } <line13> 	<line9>
5690	"public class A { <line0> @Override <line1> public State convertToOpenHab( <line2> @Nullable String acceptedChannelType, SmartthingsStateData dataFromSmartthings) { <line3> String deviceType = dataFromSmartthings.capabilityAttribute; <line4> Object deviceValue = dataFromSmartthings.value; <line5> if (deviceValue == null) { <line6> return UnDefType.UNDEF; <line7> } <line8> if (acceptedChannelType != null && ""Number"".contentEquals(acceptedChannelType)) { <line9> if (deviceValue instanceof String) { <line10> double d = Double.parseDouble((String) deviceValue); <line11> d *= 3.6; <line12> return new DecimalType(d); <line13> } else if (deviceValue instanceof Long) { <line14> double d = ((Long) deviceValue).longValue(); <line15> d *= 3.6; <line16> return new DecimalType(d); <line17> } else if (deviceValue instanceof BigDecimal) { <line18> double d = ((BigDecimal) deviceValue).doubleValue(); <line19> d *= 3.6; <line20> return new DecimalType(d); <line21> } else if (deviceValue instanceof Number) { <line22> double d = ((Number) deviceValue).doubleValue(); <line23> d *= 3.6; <line24> return new DecimalType(d); <line25> } else { <line26> return UnDefType.UNDEF; <line27> } <line28> } else { <line29> return defaultConvertToOpenHab(acceptedChannelType, dataFromSmartthings); <line30> } <line31> } <line32> } <line33> "	<line6>, <line26>
5691	public class A { <line0> @Override <line1> public List<String> findAllGroupMembers(final String groupName) { <line2> final String name = escapeSearchAttribute(ensureCase(groupName)); <line3> final List<String> groupMembers = new ArrayList<>(); <line4> if (!checkGroupRestrictionList(name)) { <line5> return groupMembers; <line6> } <line7> LdapContext ctx = null; <line8> try { <line9> ctx = getContext(getSecurityManager().getCurrentSubject()); <line10> SearchResult searchResult = findGroupByGroupName(ctx, removeDomainPostfix(name)); <line11> if (searchResult == null) { <line12> return groupMembers; <line13> } <line14> final LDAPSearchContext search = ensureContextFactory().getSearch(); <line15> final String dnGroup = <line16> (String) <line17> searchResult <line18> .getAttributes() <line19> .get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.DN)) <line20> .get(); <line21> final SearchAttribute sa = <line22> new SearchAttribute( <line23> search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.MEMBER_OF), <line24> escapeSearchAttribute(dnGroup)); <line25> final String searchFilter = <line26> buildSearchFilter(search.getSearchAccount().getSearchFilterPrefix(), sa); <line27> final SearchControls searchControls = new SearchControls(); <line28> searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE); <line29> searchControls.setReturningAttributes( <line30> new String[] {search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME)}); <line31> final NamingEnumeration<SearchResult> results = <line32> ctx.search(search.getBase(), searchFilter, searchControls); <line33> while (results.hasMoreElements()) { <line34> searchResult = results.nextElement(); <line35> final String member = <line36> ensureCase( <line37> addDomainPostfix( <line38> (String) <line39> searchResult <line40> .getAttributes() <line41> .get( <line42> search <line43> .getSearchAccount() <line44> .getSearchAttribute(LDAPSearchAttributeKey.NAME)) <line45> .get())); <line46> if (checkAccountRestrictionList(member)) { <line47> groupMembers.add(member); <line48> } <line49> } <line50> } catch (final NamingException ne) { <line51> } finally { <line52> if (ctx != null) { <line53> LdapUtils.closeContext(ctx); <line54> } <line55> } <line56> return groupMembers; <line57> } <line58> } <line59> 	<line51>
5692	public class A { <line0> public static void createTopic(String topic, String addr) { <line1> TopicConfig topicConfig = new TopicConfig(); <line2> topicConfig.setTopicName(topic); <line3> topicConfig.setReadQueueNums(4); <line4> topicConfig.setWriteQueueNums(4); <line5> try { <line6> defaultMQAdminExt.createAndUpdateTopicConfig(addr, topicConfig); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	<line8>
5693	public class A { <line0> @Override <line1> public void onJointAngles(Map<String, Double> angleMap) { <line2> for (String name : angleMap.keySet()) { <line3> ServiceInterface si = Runtime.getService(name); <line4> if (si instanceof Servo) { <line5> ((Servo) si).moveTo(angleMap.get(name)); <line6> } <line7> } <line8> } <line9> } <line10> 	<line2>
5694	"public class A { <line0> private com.liferay.portal.kernel.model.User _fetchOrCreateBuyerUser(User user, long groupId) <line1> throws Exception { <line2> if (Validator.isBlank(user.getEmail())) { <line3> throw new BadRequestException(""Buyer user email is required""); <line4> } <line5> com.liferay.portal.kernel.model.User liferayUser = <line6> _userLocalService.fetchUserByEmailAddress(contextCompany.getCompanyId(), user.getEmail()); <line7> if (liferayUser != null) { <line8> return liferayUser; <line9> } <line10> return _addBuyerUser( <line11> contextCompany.getCompanyId(), <line12> groupId, <line13> user.getEmail(), <line14> user.getFirstName(), <line15> user.getMiddleName(), <line16> user.getLastName()); <line17> } <line18> } <line19> "	<line3>
5695	"public class A { <line0> public boolean matches(IAtomContainer atomContainer, boolean initializeTarget) <line1> throws CDKException { <line2> if (!GeometryUtil.has3DCoordinates(atomContainer)) <line3> throw new CDKException(""Molecule must have 3D coordinates""); <line4> if (pharmacophoreQuery == null) <line5> throw new CDKException(""Must set the query pharmacophore before matching""); <line6> if (!checkQuery(pharmacophoreQuery)) <line7> throw new CDKException( <line8> ""A problem in the query. Make sure all pharmacophore groups of the same symbol have the"" <line9> + "" same same SMARTS""); <line10> String title = (String) atomContainer.getTitle(); <line11> if (initializeTarget) pharmacophoreMolecule = getPharmacophoreMolecule(atomContainer); <line12> else { <line13> for (IAtom iAtom : pharmacophoreMolecule.atoms()) { <line14> PharmacophoreAtom patom = PharmacophoreAtom.get(iAtom); <line15> List<Integer> tmpList = new ArrayList<Integer>(); <line16> for (int idx : patom.getMatchingAtoms()) tmpList.add(idx); <line17> Point3d coords = getEffectiveCoordinates(atomContainer, tmpList); <line18> patom.setPoint3d(coords); <line19> } <line20> } <line21> if (pharmacophoreMolecule.getAtomCount() < pharmacophoreQuery.getAtomCount()) { <line22> return false; <line23> } <line24> mappings = Pattern.findSubstructure(pharmacophoreQuery).matchAll(pharmacophoreMolecule); <line25> return mappings.atLeast(1); <line26> } <line27> } <line28> "	<line22>
5696	"public class A { <line0> @Override <line1> public List<T> query(String filter, String sortBy, boolean ascending, String zoneId) { <line2> validateOrderBy(queryConverter.map(sortBy)); <line3> SearchQueryConverter.ProcessedFilter where = <line4> queryConverter.convert(filter, sortBy, ascending, zoneId); <line5> List<T> result; <line6> try { <line7> String completeSql = getQuerySQL(where); <line8> if (pageSize > 0 && pageSize < Integer.MAX_VALUE) { <line9> result = <line10> pagingListFactory.createJdbcPagingList( <line11> completeSql, where.getParams(), rowMapper, pageSize); <line12> } else { <line13> result = namedParameterJdbcTemplate.query(completeSql, where.getParams(), rowMapper); <line14> } <line15> return result; <line16> } catch (DataAccessException e) { <line17> throw new IllegalArgumentException(""Invalid filter: "" + filter); <line18> } <line19> } <line20> } <line21> "	<line5>, <line8>, <line17>
5697	public class A { <line0> public static String[] getStringPropertyArray( <line1> ResourceBundle bundle, String key, String[] defaultValue) { <line2> try { <line3> bundle.getString(key); <line4> return getStringPropertyArray(bundle, key); <line5> } catch (MissingResourceException e) { <line6> printOutArrayProperty(key, defaultValue, true); <line7> return defaultValue; <line8> } <line9> } <line10> } <line11> 	<line6>
5698	"public class A { <line0> public HTTPRequest filterLogAndConvertRe(HttpRequest request) { <line1> for (HttpRequestFilter filter : request.getFilters()) { <line2> request = filter.filter(request); <line3> } <line4> checkRequestHasContentLengthOrChunkedEncoding( <line5> request, <line6> ""After filtering, the request has neither chunked encoding nor content length: "" + request); <line7> wirePayloadIfEnabled(wire, request); <line8> HTTPRequest nativeRequest = convertToGaeRequest.apply(request); <line9> utils.logRequest(headerLog, request, "">>""); <line10> return nativeRequest; <line11> } <line12> } <line13> "	<line7>
5699	public class A { <line0> void handleBookieFailure(final Map<Integer, BookieSocketAddress> failedBookies) { <line1> int curBlockAddCompletions = blockAddCompletions.incrementAndGet(); <line2> if (bk.disableEnsembleChangeFeature.isAvailable()) { <line3> blockAddCompletions.decrementAndGet(); <line4> unsetSuccessAndSendWriteRequest(failedBookies.keySet()); <line5> return; <line6> } <line7> int curNumEnsembleChanges = numEnsembleChanges.incrementAndGet(); <line8> synchronized (metadata) { <line9> try { <line10> EnsembleInfo ensembleInfo = replaceBookieInMetadata(failedBookies, curNumEnsembleChanges); <line11> if (ensembleInfo.replacedBookies.isEmpty()) { <line12> blockAddCompletions.decrementAndGet(); <line13> return; <line14> } <line15> writeLedgerConfig( <line16> new ChangeEnsembleCb(ensembleInfo, curBlockAddCompletions, curNumEnsembleChanges)); <line17> } catch (BKException.BKNotEnoughBookiesException e) { <line18> handleUnrecoverableErrorDuringAdd(e.getCode()); <line19> return; <line20> } <line21> } <line22> } <line23> } <line24> 	<line4>, <line15>, <line18>
5700	"public class A { <line0> public String asString() throws FacebookException { <line1> if (null == responseAsString) { <line2> BufferedReader br = null; <line3> InputStream stream = null; <line4> try { <line5> stream = asStream(); <line6> if (null == stream) { <line7> return null; <line8> } <line9> br = new BufferedReader(new InputStreamReader(stream, ""UTF-8"")); <line10> StringBuilder buf = new StringBuilder(); <line11> String line; <line12> while ((line = br.readLine()) != null) { <line13> buf.append(line).append(""\n""); <line14> } <line15> this.responseAsString = buf.toString(); <line16> stream.close(); <line17> streamConsumed = true; <line18> } catch (IOException ioe) { <line19> throw new FacebookException(ioe.getMessage(), ioe); <line20> } finally { <line21> if (stream != null) { <line22> try { <line23> stream.close(); <line24> } catch (IOException ignore) { <line25> } <line26> } <line27> if (br != null) { <line28> try { <line29> br.close(); <line30> } catch (IOException ignore) { <line31> } <line32> } <line33> disconnectForcibly(); <line34> } <line35> } <line36> return responseAsString; <line37> } <line38> } <line39> "	<line16>
5701	public class A { <line0> private VisualizationStyle maybeInstall( <line1> Class<? extends VisualizationStyle> cl, VisualizationStyle vs, Object src) { <line2> if (vs != null) { <line3> return vs; <line4> } <line5> if (myStyleRegistry.installStyle(cl, src)) { <line6> return myStyleRegistry.getDefaultStyleInstanceForStyleClass(cl); <line7> } <line8> return null; <line9> } <line10> } <line11> 	<line8>
5702	public class A { <line0> public TLSRecord readFromClient() throws IOException { <line1> TLSRecord record = read(client); <line2> return record; <line3> } <line4> } <line5> 	<line2>
5703	public class A { <line0> public static final boolean existsInBackend(Application _app) { <line1> boolean exists = false; <line2> try { <line3> exists = <line4> BackendConnector.getInstance() <line5> .isAppExisting(CoreConfiguration.buildGoalContextFromGlobalConfiguration(), _app); <line6> } catch (BackendConnectionException e) { <line7> } <line8> return exists; <line9> } <line10> } <line11> 	<line7>
5704	public class A { <line0> public static BiConsumer<ExtendedRecord, LocationRecord> verifyLocationInfo( <line1> CentrePoints countryCentrePoints, <line2> CentrePoints stateProvinceCentrePoints, <line3> StateProvinceParser stateProvinceParser) { <line4> return (er, lr) -> { <line5> if (lr.getDecimalLongitude() != null && lr.getDecimalLatitude() != null) { <line6> if (!Strings.isNullOrEmpty(lr.getCountryCode()) <line7> && countryCentrePoints.coordinatesMatchCentre( <line8> lr.getCountry(), lr.getDecimalLatitude(), lr.getDecimalLongitude())) { <line9> addIssue(lr, ALAOccurrenceIssue.COORDINATES_CENTRE_OF_COUNTRY.name()); <line10> } <line11> if (!Strings.isNullOrEmpty(lr.getStateProvince())) { <line12> ParseResult<String> formalStateName = stateProvinceParser.parse(lr.getStateProvince()); <line13> lr.setStateProvince(formalStateName.getPayload()); <line14> String suppliedStateProvince = extractNullAwareValue(er, DwcTerm.stateProvince); <line15> if (!Strings.isNullOrEmpty(suppliedStateProvince)) { <line16> ParseResult<String> formalSuppliedName = <line17> stateProvinceParser.parse(suppliedStateProvince); <line18> if (formalSuppliedName.getPayload() != null) { <line19> suppliedStateProvince = formalSuppliedName.getPayload(); <line20> } <line21> if (!suppliedStateProvince.equalsIgnoreCase(lr.getStateProvince())) <line22> addIssue(lr, ALAOccurrenceIssue.STATE_COORDINATE_MISMATCH.name()); <line23> } <line24> if (lr.getStateProvince() != null <line25> && stateProvinceCentrePoints.coordinatesMatchCentre( <line26> lr.getStateProvince(), lr.getDecimalLatitude(), lr.getDecimalLongitude())) { <line27> addIssue(lr, ALAOccurrenceIssue.COORDINATES_CENTRE_OF_STATEPROVINCE.name()); <line28> } else if (log.isTraceEnabled()) { <line29> } <line30> } <line31> } <line32> }; <line33> } <line34> } <line35> 	<line29>
5705	public class A { <line0> @Override <line1> public BasisFunctionFactory getFactory(final DataTableSpec spec) { <line2> return new FuzzyBasisFunctionFactory(m_norm, m_shrink, spec, getTargetColumns(), getDistance()); <line3> } <line4> } <line5> 	<line2>
5706	public class A { <line0> @Override <line1> public void onPSubscribe(String pattern, int subscribedChannels) { <line2> subscribedLatch.countDown(); <line3> if (log.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> 	<line4>
5707	"public class A { <line0> @Test <line1> public void testTaskMatrixClock() throws ServiceException { <line2> try { <line3> AngelApplicationMaster angelAppMaster = LocalClusterContext.get().getMaster().getAppMaster(); <line4> assertTrue(angelAppMaster != null); <line5> AMTaskManager taskManager = angelAppMaster.getAppContext().getTaskManager(); <line6> Worker worker = LocalClusterContext.get().getWorker(worker0Attempt0Id).getWorker(); <line7> PSAgentMatrixMetaManager matrixMetaManager = worker.getPSAgent().getMatrixMetaManager(); <line8> int w1Id = matrixMetaManager.getMatrixId(""w1""); <line9> int w2Id = matrixMetaManager.getMatrixId(""w2""); <line10> MasterClient masterClient = worker.getPSAgent().getMasterClient(); <line11> AMTask task0 = taskManager.getTask(task0Id); <line12> AMTask task1 = taskManager.getTask(task1Id); <line13> masterClient.updateClock(task0Id.getIndex(), w1Id, 1); <line14> masterClient.updateClock(task0Id.getIndex(), w2Id, 1); <line15> Int2IntOpenHashMap matrixClocks = task0.getMatrixClocks(); <line16> assertEquals(matrixClocks.size(), 2); <line17> assertEquals(matrixClocks.get(w1Id), 1); <line18> assertEquals(matrixClocks.get(w2Id), 1); <line19> masterClient.updateClock(task0Id.getIndex(), w1Id, 2); <line20> assertEquals(task0.getMatrixClock(w1Id), 2); <line21> assertEquals(task0.getMatrixClock(w2Id), 1); <line22> masterClient.updateClock(task1Id.getIndex(), w1Id, 1); <line23> masterClient.updateClock(task1Id.getIndex(), w2Id, 1); <line24> matrixClocks = task1.getMatrixClocks(); <line25> assertEquals(matrixClocks.size(), 2); <line26> assertEquals(matrixClocks.get(w1Id), 1); <line27> assertEquals(matrixClocks.get(w2Id), 1); <line28> masterClient.updateClock(task1Id.getIndex(), w1Id, 2); <line29> assertEquals(task1.getMatrixClock(w1Id), 2); <line30> assertEquals(task1.getMatrixClock(w2Id), 1); <line31> } catch (Exception x) { <line32> throw x; <line33> } <line34> } <line35> } <line36> "	<line3>, <line32>
5708	"public class A { <line0> private void testLoginFromConfig() { <line1> if (ccm.loginFromConfig() == null) throw new AssertionError(""loginFromConfig returned null.""); <line2> if (!ccm.logout()) throw new AssertionError(""logout returned false.""); <line3> } <line4> } <line5> "	<line1>, <line3>
5709	"public class A { <line0> @Override <line1> public CypressTestResults gatherTestResults() throws IOException { <line2> CypressTestResults results = new CypressTestResults(); <line3> objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); <line4> try (DirectoryStream<Path> paths = Files.newDirectoryStream(jsonReportsPath, ""*.json"")) { <line5> for (Path path : paths) { <line6> try { <line7> MochawesomeSpecRunReport specRunReport = <line8> objectMapper.readValue(path.toFile(), MochawesomeSpecRunReport.class); <line9> specRunReport.fillInTestResults(results); <line10> } catch (JsonMappingException e) { <line11> } <line12> } <line13> return results; <line14> } <line15> } <line16> } <line17> "	<line11>
5710	public class A { <line0> public void setBaud(int baudRate) throws Exception { <line1> state = STATE_SINGLE_SCAN; <line2> LIDARbaudRate = baudRate; <line3> index = 0; <line4> buffer.reset(); <line5> if (baudRate == 9600) { <line6> serial.write(new byte[] {0x02, 0x00, 0x02, 0x00, 0x20, 0x42, 0x52, 0x08}); <line7> } else if (baudRate == 19200) { <line8> serial.write(new byte[] {0x02, 0x00, 0x02, 0x00, 0x20, 0x41, 0x52, 0x08}); <line9> } else if (baudRate == 38400) { <line10> serial.write(new byte[] {0x02, 0x00, 0x02, 0x00, 0x20, 0x40, 0x52, 0x08}); <line11> } else { <line12> } <line13> } <line14> } <line15> 	<line12>
5711	"public class A { <line0> @Nullable <line1> private OnOffType getValveOpenType(Appliance appliance) { <line2> OndusService service = getOndusService(); <line3> if (service == null) { <line4> return null; <line5> } <line6> Optional<BaseApplianceCommand> commandOptional; <line7> try { <line8> commandOptional = service.applianceCommand(appliance); <line9> } catch (IOException e) { <line10> return null; <line11> } <line12> if (!commandOptional.isPresent()) { <line13> return null; <line14> } <line15> if (commandOptional.get().getType() != Appliance.TYPE) { <line16> updateStatus( <line17> ThingStatus.OFFLINE, <line18> ThingStatusDetail.CONFIGURATION_ERROR, <line19> ""Thing is not a GROHE SENSE Guard device.""); <line20> return null; <line21> } <line22> return ((ApplianceCommand) commandOptional.get()).getCommand().getValveOpen() <line23> ? OnOffType.ON <line24> : OnOffType.OFF; <line25> } <line26> } <line27> "	<line10>
5712	"public class A { <line0> @Override <line1> public void updateUserInfo(final String userName, final String userInfo) <line2> throws DataNotFoundException, JargonException { <line3> if (userName == null || userName.isEmpty()) { <line4> throw new IllegalArgumentException(""null or empty userName""); <line5> } <line6> if (userInfo == null) { <line7> throw new IllegalArgumentException(""null userInfo""); <line8> } <line9> User user = findByName(userName); <line10> user.setInfo(userInfo); <line11> this.updateUserInfo(user); <line12> } <line13> } <line14> "	<line3>, <line9>, <line10>, <line12>
5713	"public class A { <line0> private static boolean validateInput(String[] args) { <line1> if (args.length < 2) { <line2> return false; <line3> } <line4> int lastIndex = args[0].lastIndexOf(File.separatorChar); <line5> if (lastIndex <= 0) { <line6> return false; <line7> } <line8> modulePath = args[0]; <line9> moduleName = modulePath.substring(lastIndex + 1); <line10> if (!moduleName.matches(""^[a-zA-Z_]*$"")) { <line11> return false; <line12> } <line13> moduleParentPath = modulePath.substring(0, lastIndex); <line14> determineVersion(args[1]); <line15> String majorVersion = ""v"" + version.getMajor(); <line16> String serviceClientGroupId = System.getProperty(SERVICE_CLIENT_GROUP_ID_KEY); <line17> if (serviceClientGroupId == null || serviceClientGroupId.isEmpty()) { <line18> serviceClientGroupId = DEFAULT_SERVICE_CLIENT_GROUP_ID; <line19> } <line20> validateServiceClientGroupId(serviceClientGroupId); <line21> packageName = serviceClientGroupId + ""."" + moduleName + ""."" + majorVersion; <line22> if (args.length > 2) { <line23> pojoOrdering = args[2].split("",""); <line24> } <line25> return true; <line26> } <line27> } <line28> "	<line6>, <line11>
5714	"public class A { <line0> public static com.liferay.redirect.model.RedirectEntry deleteRedirectEntry( <line1> HttpPrincipal httpPrincipal, long redirectEntryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> RedirectEntryServiceUtil.class, <line7> ""deleteRedirectEntry"", <line8> _deleteRedirectEntryParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, redirectEntryId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.redirect.model.RedirectEntry) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
5715	"public class A { <line0> @Test <line1> public void testReadWriteAsyncLength() throws IOException { <line2> try { <line3> lh = bkc.createLedger(digestType, ledgerPassword); <line4> ledgerId = lh.getId(); <line5> for (int i = 0; i < numEntriesToWrite; i++) { <line6> ByteBuffer entry = ByteBuffer.allocate(4); <line7> entry.putInt(rng.nextInt(maxInt)); <line8> entry.position(0); <line9> entries.add(entry.array()); <line10> entriesSize.add(entry.array().length); <line11> lh.asyncAddEntry(entry.array(), this, sync); <line12> } <line13> synchronized (sync) { <line14> while (sync.counter < numEntriesToWrite) { <line15> sync.wait(); <line16> } <line17> } <line18> long length = numEntriesToWrite * 4; <line19> assertTrue(""Ledger length before closing: "" + lh.getLength(), lh.getLength() == length); <line20> lh.close(); <line21> lh = bkc.openLedger(ledgerId, digestType, ledgerPassword); <line22> assertTrue(""Ledger length after opening: "" + lh.getLength(), lh.getLength() == length); <line23> lh.close(); <line24> } catch (BKException e) { <line25> LOG.error(""Test failed"", e); <line26> fail(""Test failed due to BookKeeper exception""); <line27> } catch (InterruptedException e) { <line28> fail(""Test failed due to interruption""); <line29> } <line30> } <line31> } <line32> "	<line5>, <line15>, <line20>, <line28>
5716	"public class A { <line0> protected void runReadLoop() throws Exception { <line1> try (Closeable scope = context.enterProcess()) { <line2> Receiver receiver = receivers[0]; <line3> if (receiver == null) { <line4> return; <line5> } <line6> if (abortRead.get()) { <line7> throw new InterruptedException(""Read loop was aborted.""); <line8> } <line9> NativeReader.NativeReaderIterator<?> iterator = reader.iterator(); <line10> synchronized (initializationStateLock) { <line11> readerIterator = new SynchronizedReaderIterator<>(iterator, progress); <line12> if (abortRead.get()) { <line13> readerIterator.asyncAbort(); <line14> } <line15> } <line16> Runnable setProgressFromIterator = <line17> new Runnable() { <line18> @Override <line19> public void run() { <line20> readerIterator.setProgressFromIterator(); <line21> } <line22> }; <line23> try (AutoCloseable updater = <line24> schedulePeriodicActivity(scheduler, setProgressFromIterator, progressUpdatePeriodMs)) { <line25> readerIterator.setProgressFromIterator(); <line26> for (boolean more = readerIterator.start(); more; more = readerIterator.advance()) { <line27> if (abortRead.get()) { <line28> throw new InterruptedException(""Read loop was aborted.""); <line29> } <line30> if (progressUpdatePeriodMs == UPDATE_ON_EACH_ITERATION) { <line31> readerIterator.setProgressFromIterator(); <line32> } <line33> receiver.process(readerIterator.getCurrent()); <line34> } <line35> readerIterator.setProgressFromIterator(); <line36> } finally { <line37> scheduler.shutdown(); <line38> scheduler.awaitTermination(1, TimeUnit.MINUTES); <line39> if (!scheduler.isTerminated()) { <line40> scheduler.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS); <line41> } <line42> } <line43> } <line44> } <line45> } <line46> "	<line40>, <line41>
5717	public class A { <line0> @Override <line1> public void onDisconnect(InternalDistributedSystem sys) { <line2> disconnect(); <line3> } <line4> } <line5> 	<line2>, <line3>
5718	public class A { <line0> private void stopConnector(String connName) { <line1> try (LoggingContext loggingContext = LoggingContext.forConnector(connName)) { <line2> WorkerConnector workerConnector = connectors.get(connName); <line3> if (workerConnector == null) { <line4> return; <line5> } <line6> ClassLoader savedLoader = plugins.currentThreadLoader(); <line7> try { <line8> savedLoader = Plugins.compareAndSwapLoaders(workerConnector.loader()); <line9> workerConnector.shutdown(); <line10> } finally { <line11> Plugins.compareAndSwapLoaders(savedLoader); <line12> } <line13> } <line14> } <line15> } <line16> 	<line3>, <line4>
5719	"public class A { <line0> public MarketoRecordResult executeGetRequest(Schema schema) throws MarketoException { <line1> try { <line2> URL url = new URL(current_uri.toString()); <line3> HttpsURLConnection urlConn = (HttpsURLConnection) url.openConnection(); <line4> urlConn.setRequestMethod(""GET""); <line5> urlConn.setDoOutput(true); <line6> urlConn.setRequestProperty(REQUEST_PROPERTY_ACCEPT, REQUEST_VALUE_TEXT_JSON); <line7> return fillMarketoRecordResultFromReader(getReaderFromHttpResponse(urlConn), schema); <line8> } catch (IOException e) { <line9> throw new MarketoException(REST, e.getMessage()); <line10> } <line11> } <line12> } <line13> "	<line9>
5720	"public class A { <line0> private void execInContainer(String containerId, String execCommand, boolean logout) <line1> throws DockerException, InterruptedException { <line2> final String[] command = {""sh"", ""-c"", execCommand}; <line3> final ExecCreation execCreation = <line4> docker.execCreate( <line5> containerId, <line6> command, <line7> DockerClient.ExecCreateParam.attachStdout(), <line8> DockerClient.ExecCreateParam.attachStderr()); <line9> LogStream logStream = docker.execStart(execCreation.id()); <line10> while (logStream.hasNext() && logout) { <line11> final String log = UTF_8.decode(logStream.next().content()).toString(); <line12> } <line13> } <line14> } <line15> "	<line2>, <line12>
5721	"public class A { <line0> @Test(timeOut = 10_000) <line1> public void testCleanupWithDeleteRow(ITestContext context) throws Exception { <line2> TransactionManager tm = newTransactionManager(context); <line3> TTable tt = new TTable(hbaseConf, TEST_TABLE); <line4> Transaction t1 = tm.begin(); <line5> int rowcount = 10; <line6> int count = 0; <line7> byte[] fam = Bytes.toBytes(TEST_FAMILY); <line8> byte[] col = Bytes.toBytes(""testdata""); <line9> byte[] data1 = Bytes.toBytes(""testWrite-1""); <line10> byte[] data2 = Bytes.toBytes(""testWrite-2""); <line11> byte[] modrow = Bytes.toBytes(""test-del"" + 3); <line12> for (int i = 0; i < rowcount; i++) { <line13> byte[] row = Bytes.toBytes(""test-del"" + i); <line14> Put p = new Put(row); <line15> p.add(fam, col, data1); <line16> tt.put(t1, p); <line17> } <line18> tm.commit(t1); <line19> Transaction t2 = tm.begin(); <line20> Delete d = new Delete(modrow); <line21> tt.delete(t2, d); <line22> ResultScanner rs = tt.getScanner(t2, new Scan()); <line23> Result r = rs.next(); <line24> count = 0; <line25> while (r != null) { <line26> count++; <line27> r = rs.next(); <line28> } <line29> assertEquals(count, rowcount - 1, ""Wrong count""); <line30> Transaction t3 = tm.begin(); <line31> Put p = new Put(modrow); <line32> p.add(fam, col, data2); <line33> tt.put(t3, p); <line34> tm.commit(t3); <line35> boolean aborted = false; <line36> try { <line37> tm.commit(t2); <line38> fail(""Didn't abort""); <line39> } catch (RollbackException e) { <line40> aborted = true; <line41> } <line42> assertTrue(aborted, ""Didn't raise exception""); <line43> Transaction tscan = tm.begin(); <line44> rs = tt.getScanner(tscan, new Scan()); <line45> r = rs.next(); <line46> count = 0; <line47> while (r != null) { <line48> count++; <line49> r = rs.next(); <line50> } <line51> assertEquals(count, rowcount, ""Wrong count""); <line52> } <line53> } <line54> "	<line5>, <line20>, <line27>, <line31>
5722	"public class A { <line0> @Override <line1> public void run() throws Exception { <line2> if (StringUtils.isNotBlank(getOpts().getProject())) { <line3> } <line4> File glossaryFile = getOpts().getFile(); <line5> if (glossaryFile == null) { <line6> throw new RuntimeException(""Option '--file' is required.""); <line7> } <line8> if (!glossaryFile.exists()) { <line9> throw new RuntimeException( <line10> ""File '"" + glossaryFile + ""' does not exist. Check '--file' option""); <line11> } <line12> if (getOpts().getBatchSize() <= 0) { <line13> throw new RuntimeException(""Option '--batch-size' needs to be 1 or more.""); <line14> } <line15> String fileExtension = validateFileExtensionWithTransLang(); <line16> String project = getOpts().getProject(); <line17> String qualifiedName; <line18> try { <line19> qualifiedName = <line20> StringUtils.isBlank(project) <line21> ? client.getGlobalQualifiedName() <line22> : client.getProjectQualifiedName(project); <line23> } catch (ResponseProcessingException rpe) { <line24> if (rpe.getResponse().getStatus() == 404) { <line25> return; <line26> } else { <line27> throw rpe; <line28> } <line29> } <line30> AbstractGlossaryPushReader reader = getReader(fileExtension); <line31> Reader inputStreamReader = new InputStreamReader(new FileInputStream(glossaryFile), ""UTF-8""); <line32> BufferedReader br = new BufferedReader(inputStreamReader); <line33> Map<LocaleId, List<GlossaryEntry>> glossaries = reader.extractGlossary(br, qualifiedName); <line34> int totalEntries = 0; <line35> for (Map.Entry<LocaleId, List<GlossaryEntry>> entries : glossaries.entrySet()) { <line36> totalEntries = totalEntries + entries.getValue().size(); <line37> } <line38> int totalDone = 0; <line39> for (Map.Entry<LocaleId, List<GlossaryEntry>> entry : glossaries.entrySet()) { <line40> List<List<GlossaryEntry>> batches = <line41> Lists.partition(entry.getValue(), getOpts().getBatchSize()); <line42> for (List<GlossaryEntry> batch : batches) { <line43> client.post(batch, entry.getKey(), qualifiedName); <line44> totalDone = totalDone + batch.size(); <line45> } <line46> } <line47> } <line48> } <line49> "	<line2>, <line3>, <line4>, <line25>, <line31>, <line37>, <line45>
5723	"public class A { <line0> @Override <line1> public void setAccessPermissionReadInAdminMode( <line2> final String zone, final String absolutePath, final String userName) throws JargonException { <line3> if (zone == null) { <line4> throw new IllegalArgumentException(""null zone""); <line5> } <line6> if (absolutePath == null || absolutePath.isEmpty()) { <line7> throw new IllegalArgumentException(""null or empty absolutePath""); <line8> } <line9> if (userName == null || userName.isEmpty()) { <line10> throw new IllegalArgumentException(""null or empty userName""); <line11> } <line12> ObjStat objStat = this.retrieveObjStat(absolutePath); <line13> if (objStat.getSpecColType() == SpecColType.MOUNTED_COLL) { <line14> throw new OperationNotSupportedForCollectionTypeException( <line15> ""The special collection type does not support this operation""); <line16> } <line17> String absPath = resolveAbsolutePathGivenObjStat(objStat); <line18> ModAccessControlInp modAccessControlInp = <line19> ModAccessControlInp.instanceForSetPermissionInAdminMode( <line20> false, zone, absPath, userName, ModAccessControlInp.READ_PERMISSION); <line21> getIRODSProtocol().irodsFunction(modAccessControlInp); <line22> } <line23> } <line24> "	<line14>
5724	"public class A { <line0> public void testReceiveTwoThenRollback() throws Exception { <line1> Message[] outbound = <line2> new Message[] { <line3> session.createTextMessage(""First Message""), session.createTextMessage(""Second Message"") <line4> }; <line5> beginTx(); <line6> while (consumer.receive(1000) != null) {} <line7> commitTx(); <line8> beginTx(); <line9> producer.send(outbound[0]); <line10> producer.send(outbound[1]); <line11> commitTx(); <line12> ArrayList<Message> messages = new ArrayList<>(); <line13> beginTx(); <line14> Message message = consumer.receive(1000); <line15> assertEquals(outbound[0], message); <line16> message = consumer.receive(1000); <line17> assertNotNull(message); <line18> assertEquals(outbound[1], message); <line19> rollbackTx(); <line20> beginTx(); <line21> message = consumer.receive(5000); <line22> assertNotNull(""Should have re-received the first message again!"", message); <line23> messages.add(message); <line24> assertEquals(outbound[0], message); <line25> message = consumer.receive(5000); <line26> assertNotNull(""Should have re-received the second message again!"", message); <line27> messages.add(message); <line28> assertEquals(outbound[1], message); <line29> assertNull(consumer.receiveNoWait()); <line30> commitTx(); <line31> Message inbound[] = new Message[messages.size()]; <line32> messages.toArray(inbound); <line33> assertTextMessagesEqual(""Rollback did not work"", outbound, inbound); <line34> } <line35> } <line36> "	<line12>
5725	public class A { <line0> private void configure(Configuration conf) { <line1> MAX_MEM_USAGE = QUEUE_SIZE; <line2> if (conf == null) { <line3> return; <line4> } <line5> String limit = conf.get(CHUNK_QUEUE_LIMIT); <line6> if (limit != null) { <line7> try { <line8> MAX_MEM_USAGE = Integer.parseInt(limit); <line9> } catch (NumberFormatException nfe) { <line10> } <line11> } <line12> } <line13> } <line14> 	<line10>, <line12>
5726	public class A { <line0> private Reader getReader(String dataFileName) throws IOException { <line1> Reader ret = null; <line2> File f = new File(dataFileName); <line3> if (f.exists() && f.canRead()) { <line4> ret = new FileReader(dataFileName); <line5> } else { <line6> InputStream inStr = this.getClass().getResourceAsStream(dataFileName); <line7> if (inStr != null) { <line8> ret = new InputStreamReader(inStr); <line9> } <line10> } <line11> if (ret == null) { <line12> throw new FileNotFoundException(dataFileName); <line13> } <line14> return ret; <line15> } <line16> } <line17> 	<line4>, <line8>
5727	public class A { <line0> private void updateRuleLastCheckTime(List<AlertRule> validAlertRuleList) { <line1> try { <line2> List<Integer> ruleIdList = <line3> validAlertRuleList.stream().map(AlertRule::getRuleId).collect(Collectors.toList()); <line4> alertRuleService.updateAlertRuleLastCheckTime(ruleIdList); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	<line6>
5728	"public class A { <line0> public void init() throws DBException { <line1> try { <line2> String hosts = getProperties().getProperty(""hosts""); <line3> if (hosts == null) { <line4> throw new DBException(""Required property \""hosts\"" missing for CassandraClient""); <line5> } <line6> column_family = getProperties().getProperty(COLUMN_FAMILY_PROPERTY); <line7> parent = new ColumnParent(column_family); <line8> _table = getProperties().getProperty(""schema""); <line9> ConnectionRetries = <line10> Integer.parseInt( <line11> getProperties() <line12> .getProperty(CONNECTION_RETRY_PROPERTY, CONNECTION_RETRY_PROPERTY_DEFAULT)); <line13> String username = getProperties().getProperty(USERNAME_PROPERTY); <line14> String password = getProperties().getProperty(PASSWORD_PROPERTY); <line15> readConsistencyLevel = <line16> ConsistencyLevel.valueOf( <line17> getProperties() <line18> .getProperty( <line19> READ_CONSISTENCY_LEVEL_PROPERTY, READ_CONSISTENCY_LEVEL_PROPERTY_DEFAULT)); <line20> writeConsistencyLevel = <line21> ConsistencyLevel.valueOf( <line22> getProperties() <line23> .getProperty( <line24> WRITE_CONSISTENCY_LEVEL_PROPERTY, WRITE_CONSISTENCY_LEVEL_PROPERTY_DEFAULT)); <line25> scanConsistencyLevel = <line26> ConsistencyLevel.valueOf( <line27> getProperties() <line28> .getProperty( <line29> SCAN_CONSISTENCY_LEVEL_PROPERTY, SCAN_CONSISTENCY_LEVEL_PROPERTY_DEFAULT)); <line30> deleteConsistencyLevel = <line31> ConsistencyLevel.valueOf( <line32> getProperties() <line33> .getProperty( <line34> DELETE_CONSISTENCY_LEVEL_PROPERTY, <line35> DELETE_CONSISTENCY_LEVEL_PROPERTY_DEFAULT)); <line36> _debug = Boolean.parseBoolean(getProperties().getProperty(""debug"", ""false"")); <line37> String[] allhosts = hosts.split("",""); <line38> String myhost = allhosts[random.nextInt(allhosts.length)]; <line39> Exception connectexception = null; <line40> if (tr == null || client == null) { <line41> for (int retry = 0; retry < ConnectionRetries; retry++) { <line42> tr = new TFramedTransport(new TSocket(myhost, 9160)); <line43> TProtocol proto = new TBinaryProtocol(tr); <line44> client = new Cassandra.Client(proto); <line45> try { <line46> tr.open(); <line47> connectexception = null; <line48> break; <line49> } catch (Exception e) { <line50> connectexception = e; <line51> logger.error(e); <line52> } <line53> try { <line54> Thread.sleep(1000); <line55> } catch (InterruptedException e) { <line56> } <line57> } <line58> } <line59> if (connectexception != null) { <line60> throw new DBException(connectexception); <line61> } <line62> if (username != null && password != null) { <line63> Map<String, String> cred = new HashMap<String, String>(); <line64> cred.put(""username"", username); <line65> cred.put(""password"", password); <line66> AuthenticationRequest req = new AuthenticationRequest(cred); <line67> try { <line68> client.login(req); <line69> } catch (Exception e) { <line70> e.printStackTrace(); <line71> throw new DBException(e); <line72> } <line73> } <line74> client.set_keyspace(_table); <line75> } catch (Exception e) { <line76> } <line77> } <line78> } <line79> "	<line56>, <line60>, <line71>, <line76>
5729	public class A { <line0> public static void logExecution(RecipeExecutionResult execution) { <line1> for (TestStepResult result : execution.getTestStepResults()) { <line2> if (result.getHarEntry() != null && result.getHarEntry().getResponse() != null) { <line3> HarResponse response = result.getHarEntry().getResponse(); <line4> } else { <line5> } <line6> } <line7> } <line8> } <line9> 	<line4>, <line5>
5730	public class A { <line0> @Override <line1> public void fireDisconnected() { <line2> channelHandlerContext.pipeline().fireUserEventTriggered(new DisconnectedEvent()); <line3> } <line4> } <line5> 	<line2>
5731	public class A { <line0> @Override <line1> public String getSiteName(HttpServletRequest request) { <line2> String siteName = request.getParameter(paramOrCookieName); <line3> if (StringUtils.isEmpty(siteName)) { <line4> siteName = HttpUtils.getCookieValue(paramOrCookieName, request); <line5> if (StringUtils.isEmpty(siteName) && logger.isDebugEnabled()) { <line6> } <line7> } <line8> return siteName; <line9> } <line10> } <line11> 	<line6>
5732	public class A { <line0> private void mainMenuPerformed(MainMenuItem menu) { <line1> if (menu.getParams() == null) { <line2> setResponsePage(menu.getPageClass()); <line3> } else { <line4> setResponsePage(menu.getPageClass(), menu.getParams()); <line5> } <line6> } <line7> } <line8> 	<line1>
5733	public class A { <line0> private void _init(Properties properties) { <line1> if (properties != null) { <line2> try { <line3> verifyProperties(properties); <line4> } catch (IOException e) { <line5> StartupListener.properties = null; <line6> } <line7> StartupListener.properties = properties; <line8> } else { <line9> } <line10> } <line11> } <line12> 	<line5>, <line9>
5734	"public class A { <line0> protected TypedQuery<ENTITY> typedQueryForSelectInternal( <line1> RegularStatement regularStatement, Object... encodedBoundValues) { <line2> if (LOGGER.isTraceEnabled()) { <line3> } <line4> validateTrue( <line5> isSelectStatement(regularStatement), <line6> ""Statement provided for typed query should be an SELECT statement""); <line7> final PreparedStatement preparedStatement = rte.prepareDynamicQuery(regularStatement); <line8> final BoundStatement boundStatement = <line9> ArrayUtils.isEmpty(encodedBoundValues) <line10> ? preparedStatement.bind() <line11> : preparedStatement.bind(encodedBoundValues); <line12> if (regularStatement.getConsistencyLevel() != null) <line13> boundStatement.setConsistencyLevel(regularStatement.getConsistencyLevel()); <line14> if (regularStatement.getSerialConsistencyLevel() != null) <line15> boundStatement.setSerialConsistencyLevel(regularStatement.getSerialConsistencyLevel()); <line16> if (regularStatement.isTracing()) boundStatement.enableTracing(); <line17> if (regularStatement.getRetryPolicy() != null) <line18> boundStatement.setRetryPolicy(regularStatement.getRetryPolicy()); <line19> if (regularStatement.getOutgoingPayload() != null) <line20> boundStatement.setOutgoingPayload(regularStatement.getOutgoingPayload()); <line21> if (regularStatement.isIdempotent() != null) { <line22> boundStatement.setIdempotent(regularStatement.isIdempotent()); <line23> } <line24> boundStatement.setFetchSize(regularStatement.getFetchSize()); <line25> return new TypedQuery<>(rte, meta_internal, boundStatement, encodedBoundValues); <line26> } <line27> } <line28> "	<line3>
5735	public class A { <line0> public static void checkPackages( <line1> SBase sbase, List<String> packageNamespaces, boolean silent, boolean fix) { <line2> if (sbase == null) { <line3> return; <line4> } <line5> if (packageNamespaces == null) { <line6> packageNamespaces = new ArrayList<String>(); <line7> } <line8> Map<String, PackageInfo> prefixMap = new HashMap<String, PackageInfo>(); <line9> Map<String, PackageInfo> namespaceMap = new HashMap<String, PackageInfo>(); <line10> for (String namespace : packageNamespaces) { <line11> PackageParser packageParser = ParserManager.getManager().getPackageParser(namespace); <line12> if (packageParser != null) { <line13> PackageInfo pi = new PackageInfo(); <line14> pi.prefix = packageParser.getPackageName(); <line15> pi.namespace = namespace; <line16> pi.version = extractPackageVersion(namespace); <line17> prefixMap.put(pi.prefix, pi); <line18> namespaceMap.put(namespace, pi); <line19> if (logger.isDebugEnabled()) { <line20> } <line21> } else { <line22> } <line23> } <line24> checkPackages(sbase, prefixMap, namespaceMap, silent, fix); <line25> } <line26> } <line27> 	<line20>, <line22>
5736	"public class A { <line0> public static void main(String[] args) { <line1> BasicConfigurator.configure(new ConsoleAppender(new PatternLayout(""%d [%-25t] %-5p: %m%n""))); <line2> CmdLineParser parser = new CmdLineParser(); <line3> CmdLineParser.Option help = parser.addBooleanOption('h', ""help""); <line4> CmdLineParser.Option port = parser.addIntegerOption('p', ""port""); <line5> try { <line6> parser.parse(args); <line7> } catch (CmdLineParser.OptionException oe) { <line8> System.err.println(oe.getMessage()); <line9> usage(System.err); <line10> System.exit(1); <line11> } <line12> if (Boolean.TRUE.equals((Boolean) parser.getOptionValue(help))) { <line13> usage(System.out); <line14> System.exit(0); <line15> } <line16> Integer portValue = <line17> (Integer) parser.getOptionValue(port, Integer.valueOf(Tracker.DEFAULT_TRACKER_PORT)); <line18> String[] otherArgs = parser.getRemainingArgs(); <line19> if (otherArgs.length > 1) { <line20> usage(System.err); <line21> System.exit(1); <line22> } <line23> String directory = otherArgs.length > 0 ? otherArgs[0] : "".""; <line24> FilenameFilter filter = <line25> new FilenameFilter() { <line26> @Override <line27> public boolean accept(File dir, String name) { <line28> return name.endsWith("".torrent""); <line29> } <line30> }; <line31> try { <line32> Tracker t = new Tracker(portValue); <line33> File parent = new File(directory); <line34> for (File f : parent.listFiles(filter)) { <line35> t.announce(TrackedTorrent.load(f)); <line36> } <line37> t.start(true); <line38> } catch (Exception e) { <line39> System.exit(2); <line40> } <line41> } <line42> } <line43> "	<line35>, <line37>, <line39>
5737	"public class A { <line0> @Override <line1> protected PoxPayloadOut createNonExistenceItemInstance(String commonPartName, String identifier) { <line2> String commonPartXML = createCommonPartXMLForItem(""nonExShortId"", ""nonExItem""); <line3> try { <line4> PoxPayloadOut result = <line5> ConceptAuthorityClientUtils.createConceptInstance(commonPartXML, commonPartName); <line6> return result; <line7> } catch (DocumentException de) { <line8> } <line9> return null; <line10> } <line11> } <line12> "	<line8>
5738	"public class A { <line0> private void setEncodingParams( <line1> GeoTiffWriterHelper helper, Map<String, Object> encodingParameters) { <line2> if (encodingParameters != null && !encodingParameters.isEmpty()) { <line3> for (String encodingParam : encodingParameters.keySet()) { <line4> if (!SUPPORTED_PARAMS.contains(encodingParam)) { <line5> if (LOGGER.isLoggable(Level.WARNING)) { <line6> LOGGER.warning( <line7> ""The specified parameter will be ignored: "" <line8> + encodingParam <line9> + "" Supported parameters are in the list: "" <line10> + SUPPORTED_PARAMS_LIST); <line11> } <line12> } <line13> } <line14> GeoTiffWriteParams writeParams = helper.getImageIoWriteParams(); <line15> if (writeParams != null) { <line16> if (encodingParameters.containsKey(TILE_WIDTH_KEY) <line17> && encodingParameters.containsKey(TILE_HEIGHT_KEY)) { <line18> String tileWidth = (String) encodingParameters.get(TILE_WIDTH_KEY); <line19> String tileHeight = (String) encodingParameters.get(TILE_HEIGHT_KEY); <line20> try { <line21> int tw = Integer.parseInt(tileWidth); <line22> int th = Integer.parseInt(tileHeight); <line23> writeParams.setTilingMode(ImageWriteParam.MODE_EXPLICIT); <line24> writeParams.setTiling(tw, th); <line25> } catch (NumberFormatException nfe) { <line26> if (LOGGER.isLoggable(Level.INFO)) { <line27> } <line28> } <line29> } <line30> if (encodingParameters.containsKey(COMPRESSION_KEY)) { <line31> String compressionType = (String) encodingParameters.get(COMPRESSION_KEY); <line32> writeParams.setCompressionMode(ImageWriteParam.MODE_EXPLICIT); <line33> writeParams.setCompressionType(compressionType); <line34> if (encodingParameters.containsKey(QUALITY_KEY)) { <line35> String compressionQuality = (String) encodingParameters.get(QUALITY_KEY); <line36> try { <line37> writeParams.setCompressionQuality(Float.parseFloat(compressionQuality)); <line38> } catch (NumberFormatException nfe) { <line39> if (LOGGER.isLoggable(Level.INFO)) { <line40> } <line41> } <line42> } <line43> } <line44> } <line45> ParameterValueGroup geotoolsWriteParams = helper.getGeotoolsWriteParams(); <line46> if (geotoolsWriteParams != null && encodingParameters.containsKey(WRITENODATA_KEY)) { <line47> geotoolsWriteParams <line48> .parameter(GeoTiffFormat.WRITE_NODATA.getName().toString()) <line49> .setValue(Boolean.parseBoolean((String) encodingParameters.get(WRITENODATA_KEY))); <line50> } <line51> } <line52> } <line53> } <line54> "	<line27>, <line40>
5739	public class A { <line0> public boolean changePassword(SysUser user) throws Exception { <line1> try (SqlSession sqlSession = MyBatisUtil.getSqlSession()) { <line2> SysUserMapper userMapper = sqlSession.getMapper(SysUserMapper.class); <line3> userMapper.changePassword(user); <line4> sqlSession.commit(); <line5> } catch (Exception e) { <line6> throw new Exception(e); <line7> } <line8> return true; <line9> } <line10> } <line11> 	<line1>, <line6>
5740	public class A { <line0> @Override <line1> public void logTransactionSwallowException(String type, String name, Task task) { <line2> Transaction transaction = Cat.newTransaction(type, name); <line3> try { <line4> task.go(); <line5> transaction.setStatus(Transaction.SUCCESS); <line6> } catch (Throwable th) { <line7> transaction.setStatus(th); <line8> } finally { <line9> transaction.complete(); <line10> } <line11> } <line12> } <line13> 	<line8>
5741	"public class A { <line0> @Override <line1> public void processFile(String path) throws ConsumerException { <line2> Path checksumFile = this.repositoryDir.resolve(path); <line3> try { <line4> ChecksumReference cf = ChecksummedFile.getFromChecksumFile(checksumFile); <line5> if (!cf.getFile().isValidChecksum(cf.getAlgorithm(), true)) { <line6> triggerConsumerWarning( <line7> NOT_VALID_CHECKSUM, ""The checksum for "" + checksumFile + "" is invalid.""); <line8> } <line9> } catch (ChecksumValidationException e) { <line10> if (e.getErrorType() == READ_ERROR) { <line11> triggerConsumerError( <line12> CHECKSUM_IO_ERROR, ""Checksum I/O error during validation on "" + checksumFile); <line13> } else if (e.getErrorType() == INVALID_FORMAT || e.getErrorType() == DIGEST_ERROR) { <line14> triggerConsumerError( <line15> CHECKSUM_DIGESTER_FAILURE, <line16> ""Digester failure during checksum validation on "" + checksumFile); <line17> } else if (e.getErrorType() == FILE_NOT_FOUND) { <line18> triggerConsumerError( <line19> CHECKSUM_NOT_FOUND, ""File not found during checksum validation: "" + e.getMessage()); <line20> } <line21> } <line22> } <line23> } <line24> "	<line6>, <line11>, <line14>, <line18>
5742	public class A { <line0> @Override <line1> protected void doProcessRequest( <line2> UnsubscribeRequest request, ImapSession session, Responder responder) { <line3> final String mailboxName = request.getMailboxName(); <line4> final MailboxSession mailboxSession = session.getMailboxSession(); <line5> try { <line6> getSubscriptionManager().unsubscribe(mailboxSession, mailboxName); <line7> unsolicitedResponses(session, responder, false); <line8> okComplete(request, responder); <line9> } catch (SubscriptionException e) { <line10> unsolicitedResponses(session, responder, false); <line11> no(request, responder, HumanReadableText.GENERIC_SUBSCRIPTION_FAILURE); <line12> } <line13> } <line14> } <line15> 	<line10>
5743	public class A { <line0> protected void cleanOutput( <line1> IBuildContext ctx, <line2> OutputConfiguration config, <line3> EclipseResourceFileSystemAccess2 access, <line4> IProgressMonitor monitor) <line5> throws CoreException { <line6> final IProject project = ctx.getBuiltProject(); <line7> for (IContainer container : getOutputs(project, config)) { <line8> if (!container.exists()) { <line9> return; <line10> } <line11> if (canClean(container, config)) { <line12> for (IResource resource : container.members()) { <line13> try { <line14> if (!config.isKeepLocalHistory()) { <line15> resource.delete(IResource.FORCE, monitor); <line16> } else if (access == null) { <line17> resource.delete(IResource.FORCE | IResource.KEEP_HISTORY, monitor); <line18> } else { <line19> delete(resource, config, access, monitor); <line20> } <line21> } catch (ResourceException e) { <line22> } <line23> } <line24> } else if (config.isCleanUpDerivedResources()) { <line25> List<IFile> resources = derivedResourceMarkers.findDerivedResources(container, null); <line26> for (IFile iFile : resources) { <line27> if (monitor.isCanceled()) { <line28> throw new OperationCanceledException(); <line29> } <line30> try { <line31> if (access != null) { <line32> access.deleteFile(iFile, config.getName(), monitor); <line33> } else { <line34> iFile.delete(true, config.isKeepLocalHistory(), monitor); <line35> } <line36> } catch (ResourceException e) { <line37> } <line38> } <line39> } <line40> } <line41> } <line42> } <line43> 	<line22>, <line37>
5744	"public class A { <line0> private void insertRemoteToDb( <line1> String siteId, <line2> String remoteName, <line3> String remoteUrl, <line4> String authenticationType, <line5> String remoteUsername, <line6> String remotePassword, <line7> String remoteToken, <line8> String remotePrivateKey) <line9> throws CryptoException { <line10> Map<String, String> params = new HashMap<String, String>(); <line11> params.put(""siteId"", siteId); <line12> params.put(""remoteName"", remoteName); <line13> params.put(""remoteUrl"", remoteUrl); <line14> params.put(""authenticationType"", authenticationType); <line15> params.put(""remoteUsername"", remoteUsername); <line16> if (StringUtils.isNotEmpty(remotePassword)) { <line17> String hashedPassword = encryptor.encrypt(remotePassword); <line18> params.put(""remotePassword"", hashedPassword); <line19> } else { <line20> params.put(""remotePassword"", remotePassword); <line21> } <line22> if (StringUtils.isNotEmpty(remoteToken)) { <line23> String hashedToken = encryptor.encrypt(remoteToken); <line24> params.put(""remoteToken"", hashedToken); <line25> } else { <line26> params.put(""remoteToken"", remoteToken); <line27> } <line28> if (StringUtils.isNotEmpty(remotePrivateKey)) { <line29> String hashedPrivateKey = encryptor.encrypt(remotePrivateKey); <line30> params.put(""remotePrivateKey"", hashedPrivateKey); <line31> } else { <line32> params.put(""remotePrivateKey"", remotePrivateKey); <line33> } <line34> remoteRepositoryDAO.insertRemoteRepository(params); <line35> params = new HashMap<String, String>(); <line36> params.put(""siteId"", siteId); <line37> params.put(""remoteName"", remoteName); <line38> RemoteRepository remoteRepository = remoteRepositoryDAO.getRemoteRepository(params); <line39> if (remoteRepository != null) { <line40> insertClusterRemoteRepository(remoteRepository); <line41> } <line42> } <line43> } <line44> "	<line10>, <line17>, <line23>, <line29>, <line34>
5745	"public class A { <line0> public boolean flowUpdatePreStatusNone(String networkId, BasicFlow flow) { <line1> List<String> fedFlowIds = conversionTable.getFlow(networkId, flow.getFlowId()); <line2> if (fedFlowIds == null || fedFlowIds.size() == 0) { <line3> return false; <line4> } <line5> String[] fedFlowId = fedFlowIds.get(0).split(""::""); <line6> List<String> fedOrgIds = conversionTable.getFlow(fedFlowId[0], fedFlowId[1]); <line7> for (String orgFlowId : fedOrgIds) { <line8> String[] flowId = orgFlowId.split(""::""); <line9> if (flowId[1].equals(flow.getFlowId())) { <line10> continue; <line11> } <line12> NetworkInterface orgNwIf = networkInterfaces.get(flowId[0]); <line13> Flow orgFlow = orgNwIf.getFlow(flowId[1]); <line14> if (orgFlow == null) { <line15> continue; <line16> } <line17> if (!FlowObject.FlowStatus.NONE.toString().equalsIgnoreCase(orgFlow.getStatus())) { <line18> return false; <line19> } <line20> } <line21> return true; <line22> } <line23> } <line24> "	<line1>, <line3>, <line15>, <line18>, <line21>
5746	"public class A { <line0> public void waitForScanFinishing() { <line1> try { <line2> waitForInstallModeFinished(DISCOVER_TIMEOUT_SECONDS * 1000); <line3> waitForLoadDevicesFinished(); <line4> } catch (ExecutionException | InterruptedException ex) { <line5> } catch (Exception ex) { <line6> } <line7> String gatewayId = <line8> bridgeHandler != null && bridgeHandler.getGateway() != null <line9> ? bridgeHandler.getGateway().getId() <line10> : ""UNKNOWN""; <line11> } <line12> } <line13> "	<line1>, <line6>, <line11>
5747	"public class A { <line0> public static DataSource initDataSource(Config config) throws Exception { <line1> DruidDataSource dataSource = new DruidDataSource(); <line2> dataSource.setDriverClassName(""com.mysql.cj.jdbc.Driver""); <line3> dataSource.setUrl( <line4> ""jdbc:mysql://"" <line5> + config.getDbUrl() <line6> + "":"" <line7> + config.getDbPort() <line8> + ""?useSSL=true&verifyServerCertificate=false&serverTimezone=GMT%2B8&characterEncoding=utf8""); <line9> dataSource.setUsername(config.getDbUsername()); <line10> dataSource.setPassword(config.getDbPassword()); <line11> dataSource.setInitialSize(1); <line12> dataSource.setMaxActive(2); <line13> dataSource.setMaxWait(60000); <line14> dataSource.setTimeBetweenEvictionRunsMillis(60000); <line15> dataSource.setConnectionErrorRetryAttempts(2); <line16> dataSource.setBreakAfterAcquireFailure(true); <line17> dataSource.setMinEvictableIdleTimeMillis(300000); <line18> dataSource.setValidationQuery(""SELECT 1 FROM DUAL""); <line19> dataSource.setTestWhileIdle(true); <line20> return dataSource; <line21> } <line22> } <line23> "	<line20>
5748	"public class A { <line0> @GetMapping(path = ""/testvoidInRPC"") <line1> public void testvoidInRPC() { <line2> testvoidInRPCSuccess = true; <line3> } <line4> } <line5> "	<line2>
5749	"public class A { <line0> @POST <line1> @Path(""/{dashboardId}/widgets/reorder"") <line2> @ApiOperation( <line3> value = ""Change the order of widgets in a dashboard"", <line4> response = DashboardModel.class, <line5> responseContainer = ""Array"") <line6> @Produces({MediaType.APPLICATION_JSON}) <line7> public Response setWidgetsOrder( <line8> @PathParam(""dashboardId"") long dashboardId, @FormParam(""widgetNames"") String widgetNames) <line9> throws UnsupportedEncodingException { <line10> long guestId = AuthHelper.getGuestId(); <line11> try { <line12> final String[] wNames = StringUtils.split(widgetNames, "",""); <line13> dashboardsService.setWidgetsOrder(guestId, dashboardId, wNames); <line14> return getDashboards(); <line15> } catch (Exception e) { <line16> StringBuilder sb = <line17> new StringBuilder(""module=API component=dashboardStore action=setWidgetOrder"") <line18> .append("" guestId="") <line19> .append(guestId) <line20> .append("" stackTrace=<![CDATA["") <line21> .append(Utils.stackTrace(e)) <line22> .append(""]]>""); <line23> return Response.serverError().entity(""Failed to set widget order: "" + e.getMessage()).build(); <line24> } <line25> } <line26> } <line27> "	<line23>
5750	public class A { <line0> private RestResponse<User> create() throws ClientException { <line1> UserCommandOptions.CreateCommandOptions c = usersCommandOptions.createCommandOptions; <line2> UserCreateParams createParams = <line3> new UserCreateParams() <line4> .setId(c.user) <line5> .setName(c.name) <line6> .setEmail(c.email) <line7> .setOrganization(c.organization) <line8> .setPassword(c.password); <line9> return openCGAClient.getUserClient().create(createParams); <line10> } <line11> } <line12> 	<line1>
5751	"public class A { <line0> @Post(subscribeToken = ""csrf"") <line1> public Boundary save() { <line2> String expires = getParam(""expires""); <line3> if (StringUtils.isEmpty(expires)) { <line4> expires = ""9999-12-31""; <line5> } <line6> Date date; <line7> try { <line8> date = gateDayFormat().parse(expires); <line9> } catch (ParseException e) { <line10> return sendError(HttpStatus.SC_400_BAD_REQUEST, ""BAD_REQUEST""); <line11> } <line12> TokensEntity entity = TokensDao.get().selectOnUserId(getLoginUserId()); <line13> if (entity == null) { <line14> entity = new TokensEntity(); <line15> entity.setToken(RandomUtil.randamGen(64)); <line16> entity.setUserId(getLoginUserId()); <line17> } <line18> entity.setExpires(new Timestamp(date.getTime())); <line19> TokensDao.get().save(entity); <line20> addMsgSuccess(""message.success.save""); <line21> return index(); <line22> } <line23> } <line24> "	<line2>
5752	public class A { <line0> static void initPlatformMBeanServer() { <line1> try { <line2> ManagementFactory.getPlatformMBeanServer(); <line3> } catch (Throwable t) { <line4> } <line5> } <line6> } <line7> 	<line4>
5753	public class A { <line0> private Runnable createScanner() { <line1> return () -> { <line2> long timestampOfLastScan = getTimestampOfLastScan(); <line3> for (InetAddress broadcastAddress : getBroadcastAddresses()) { <line4> try (DatagramSocket socket = IdentProtocol.sendRequest(broadcastAddress)) { <line5> DatagramPacket incomingPacket; <line6> while ((incomingPacket = receivePacket(socket)) != null) { <line7> discover(incomingPacket); <line8> } <line9> } catch (IOException e) { <line10> } <line11> } <line12> removeOlderResults(timestampOfLastScan); <line13> }; <line14> } <line15> } <line16> 	<line4>, <line10>
5754	public class A { <line0> public int executeUpdate(String s) throws SQLException { <line1> return getSql().executeUpdate(s); <line2> } <line3> } <line4> 	<line1>
5755	public class A { <line0> @Override <line1> public void lockInterruptibly() throws InterruptedException { <line2> while (!this.tryLock(PgLock.DEFAULT_WAIT_SEC, TimeUnit.SECONDS)) { <line3> if (Logger.isDebugEnabled(this)) { <line4> } <line5> } <line6> } <line7> } <line8> 	<line4>
5756	public class A { <line0> @Override <line1> protected void runInternal() throws Exception { <line2> if (!this.configuration.isEventStoreEnabled() <line3> || StringUtils.isEmpty(this.configuration.getEventStore())) { <line4> return; <line5> } <line6> try { <line7> this.eventStore = <line8> this.componentManager.getInstance(EventStore.class, this.configuration.getEventStore()); <line9> } catch (ComponentLookupException e) { <line10> return; <line11> } <line12> long legacyEventCount = this.eventStream.countEvents(); <line13> int stepCount = (int) (legacyEventCount / BATCH_SIZE); <line14> if (legacyEventCount % BATCH_SIZE != 0) { <line15> stepCount++; <line16> } <line17> this.progressManager.pushLevelProgress(stepCount, this); <line18> try { <line19> Query query = prepareQuery(); <line20> List<Event> events; <line21> int offset = 0; <line22> do { <line23> this.progressManager.startStep(this); <line24> events = this.eventStream.searchEvents(query); <line25> if (getRequest().isVerbose()) { <line26> } <line27> if (!events.isEmpty()) { <line28> migrate(events); <line29> offset += BATCH_SIZE; <line30> query.setOffset(offset); <line31> } <line32> this.progressManager.endStep(this); <line33> } while (events.size() == BATCH_SIZE); <line34> } finally { <line35> this.progressManager.popLevelProgress(this); <line36> } <line37> } <line38> } <line39> 	<line4>, <line10>, <line26>
5757	public class A { <line0> private Model initSubModels(CompModelPlugin compModelPlugin) { <line1> ListOf<Submodel> subModelListOf = compModelPlugin.getListOfSubmodels().clone(); <line2> replaceElementsInModelDefinition(compModelPlugin, null); <line3> ListOf<Port> listOfPorts = compModelPlugin.getListOfPorts(); <line4> handlePorts(compModelPlugin, listOfPorts); <line5> for (Submodel submodel : subModelListOf) { <line6> this.listOfSubmodelsToFlatten.add(submodel); <line7> ModelDefinition modelDefinition = this.modelDefinitionListOf.get(submodel.getModelRef()); <line8> if (modelDefinition == null) { <line9> ExternalModelDefinition externalModelDefinition = <line10> this.externalModelDefinitionListOf.get(submodel.getModelRef()); <line11> try { <line12> SBMLDocument externalDocument = <line13> SBMLReader.read(new File(externalModelDefinition.getSource())); <line14> Model flattendExternalModel = flatten(externalDocument).getModel(); <line15> this.flattenedModel = mergeModels(this.flattenedModel, flattendExternalModel); <line16> } catch (XMLStreamException | IOException e) { <line17> e.printStackTrace(); <line18> } <line19> } <line20> if (modelDefinition != null <line21> && modelDefinition.getExtension(CompConstants.shortLabel) != null) { <line22> initSubModels((CompModelPlugin) modelDefinition.getExtension(CompConstants.shortLabel)); <line23> } else { <line24> } <line25> } <line26> return flattenAndMergeModels(this.listOfSubmodelsToFlatten); <line27> } <line28> } <line29> 	<line24>
5758	"public class A { <line0> @ApiOperation(value = ""Patch entity"") <line1> @PatchMapping(CommonConstants.PATH_ID) <line2> @ResponseStatus(HttpStatus.OK) <line3> public SecurityProfileDto patch( <line4> final @PathVariable(""id"") String id, @RequestBody final Map<String, Object> partialDto) { <line5> ParameterChecker.checkParameter( <line6> ""The Identifier, the partialEntity are mandatory parameters: "", id, partialDto); <line7> Assert.isTrue( <line8> StringUtils.equals(id, (String) partialDto.get(""id"")), <line9> ""Unable to patch securityProfile : the DTO id must match the path id.""); <line10> return service.patch(buildUiHttpContext(), partialDto, id); <line11> } <line12> } <line13> "	<line5>
5759	"public class A { <line0> @Test <line1> public void testOneGroupMessage() throws Exception { <line2> String message = <line3> ""8=FIX 4.19=2034=135=049=INVMGR56=BRKR"" <line4> + ""1=BE.CHM.00111=CHM0001-0158=this is a camel - bindy test"" <line5> + ""22=448=BE000124567854=1"" <line6> + ""10=220"" <line7> + ""777=22-06-2013 12:21:11""; <line8> List<String> data = Arrays.asList(message.split(""\\u0001"")); <line9> CamelContext camelContext = new DefaultCamelContext(); <line10> factory.bind(camelContext, data, model, counter); <line11> assertNotNull(model); <line12> } <line13> } <line14> "	<line11>
5760	public class A { <line0> public T convertOrientDocToAvroBean(final ODocument obj, final String[] fields) <line1> throws GoraException { <line2> T persistent = newPersistent(); <line3> String[] dbFields = getFieldsToQuery(fields); <line4> for (String f : dbFields) { <line5> String docf = orientDBMapping.getDocumentField(f); <line6> if (docf == null || !obj.containsField(docf)) continue; <line7> OrientDBMapping.DocumentFieldType storeType = orientDBMapping.getDocumentFieldType(docf); <line8> Schema.Field field = fieldMap.get(f); <line9> Schema fieldSchema = field.schema(); <line10> Object result = convertDocFieldToAvroField(fieldSchema, storeType, field, docf, obj); <line11> persistent.put(field.pos(), result); <line12> } <line13> persistent.clearDirty(); <line14> return persistent; <line15> } <line16> } <line17> 	<line10>
5761	public class A { <line0> private static URL correctLocalUrl(String hostname, String tmpUrl) throws MalformedURLException { <line1> URL tmp = new URL(tmpUrl); <line2> if (hostname != null && hostname.length() > 0 && localAddresses.contains(tmp.getHost())) { <line3> URL endpointUrl = null; <line4> try { <line5> endpointUrl = new URL(tmp.getProtocol(), hostname, tmp.getPort(), tmp.getFile()); <line6> } catch (MalformedURLException e) { <line7> return tmp; <line8> } <line9> return endpointUrl; <line10> } <line11> return tmp; <line12> } <line13> } <line14> 	<line7>
5762	public class A { <line0> public void execute() { <line1> final long[] resendDelays = this.calculateResendDelays(this.resendNotificationMaximum); <line2> for (int notificationsResent = this.resendNotificationMaximum - 1; <line3> notificationsResent > -1; <line4> notificationsResent--) { <line5> final long delay = resendDelays[notificationsResent]; <line6> final DateTime createdBefore = DateTime.now(DateTimeZone.UTC).minus(delay); <line7> try { <line8> this.resendNotifications((short) notificationsResent, createdBefore); <line9> } catch (final CircuitBreakerOpenException exc) { <line10> break; <line11> } <line12> } <line13> } <line14> } <line15> 	<line10>
5763	public class A { <line0> List<T> errorAndReturnEmpty() { <line1> return emptyList(); <line2> } <line3> } <line4> 	<line1>
5764	"public class A { <line0> private boolean doRemoteWorkAndHandleErrors(RemotingTask remoting) { <line1> lastRemotingTask = remoting; <line2> try { <line3> return remoting.doWork(); <line4> } catch (InterruptedException | CancellationException t) { <line5> } catch (MalformedURLException ex) { <line6> showMessageToUser(ex.getMessage()); <line7> } catch (UndeclaredThrowableException ex) { <line8> String addMessage = """"; <line9> Throwable cause = ex.getCause(); <line10> if (cause instanceof InvocationFailureException) { <line11> InvocationFailureException exep = (InvocationFailureException) cause; <line12> if (exep.getCause() instanceof IOException) { <line13> if ((exep.getCause().getMessage() != null) <line14> && (exep.getCause() <line15> .getMessage() <line16> .startsWith(""Field hash null is not available on current"") <line17> || exep.getCause().getMessage().endsWith(""end of file""))) { <line18> addMessage = ""Probably the server version is not compatible with the client. ""; <line19> } <line20> } else { <line21> } <line22> } else if (cause instanceof NoSuchMethodException) { <line23> addMessage = <line24> ""The following method is not available in the server, probably the "" <line25> + ""server version is not compatible with the client: "" <line26> + cause.getMessage(); <line27> } <line28> if (addMessage.isEmpty()) { <line29> } <line30> showMessageToUser(addMessage + (ex.getMessage() != null ? ex.getMessage() : """")); <line31> } catch (IOException ex) { <line32> String addMessage = """"; <line33> if (ex.getMessage() != null && ex.getMessage().startsWith(""Unable to perform invocation"")) { <line34> addMessage = ""Maybe the server version is not compatible. ""; <line35> } <line36> showMessageToUser(addMessage + (ex.getMessage() != null ? ex.getMessage() : """")); <line37> } catch (MageVersionException ex) { <line38> disconnect(false); <line39> if (!canceled) { <line40> showMessageToUser(ex.getMessage()); <line41> } <line42> } catch (CannotConnectException ex) { <line43> if (!canceled) { <line44> handleCannotConnectException(ex); <line45> } <line46> } catch (Throwable t) { <line47> disconnect(false); <line48> if (!canceled) { <line49> showMessageToUser(t.getMessage()); <line50> } <line51> } finally { <line52> lastRemotingTask = null; <line53> } <line54> return false; <line55> } <line56> } <line57> "	<line6>, <line21>, <line29>, <line32>, <line38>, <line47>
5765	public class A { <line0> static int parseParamIdx(String paramNodeValue) { <line1> if (!StringUtils.isEmpty(paramNodeValue)) { <line2> try { <line3> Matcher m = PARAM_PATTERN.matcher(paramNodeValue); <line4> if (m.matches()) { <line5> return Integer.parseInt(m.group(1)); <line6> } <line7> } catch (Throwable e) { <line8> } <line9> } <line10> return -1; <line11> } <line12> } <line13> 	<line8>
5766	"public class A { <line0> @Override <line1> public void log(int type, Timestamp timestamp, String txt) throws DoneException { <line2> final String toMatch; <line3> if (logBuffer != null) { <line4> logBuffer.append(txt).append(""\n""); <line5> toMatch = logBuffer.toString(); <line6> } else { <line7> toMatch = txt; <line8> } <line9> if (pattern.matcher(toMatch).find()) { <line10> callback.matched(); <line11> throw new DoneException(); <line12> } <line13> } <line14> } <line15> "	<line2>, <line10>
5767	"public class A { <line0> private JSONObject compress(JSONObject params) throws ServletException { <line1> try { <line2> JSONArray paths = ((JSONArray) params.get(""items"")); <line3> String paramDest = (String) params.get(""destination""); <line4> final Path dest = Paths.get(REPOSITORY_BASE_PATH, paramDest); <line5> Path zip = dest.resolve((String) params.get(""compressedFilename"")); <line6> if (Files.exists(zip)) { <line7> return error(zip.toString() + "" already exits!""); <line8> } <line9> Map<String, String> env = new HashMap<>(); <line10> env.put(""create"", ""true""); <line11> boolean zipped = false; <line12> try (FileSystem zipfs = <line13> FileSystems.newFileSystem(URI.create(""jar:file:"" + zip.toString()), env)) { <line14> for (int i = 0; i < paths.length(); i++) { <line15> JSONObject path = paths.getJSONObject(i); <line16> Path realPath = Paths.get(REPOSITORY_BASE_PATH, path.toString()); <line17> if (Files.isDirectory(realPath)) { <line18> Files.walkFileTree( <line19> Paths.get(REPOSITORY_BASE_PATH, path.toString()), <line20> new SimpleFileVisitor<Path>() { <line21> @Override <line22> public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) <line23> throws IOException { <line24> Files.createDirectories( <line25> zipfs.getPath(dir.toString().substring(dest.toString().length()))); <line26> return FileVisitResult.CONTINUE; <line27> } <line28>  <line29> @Override <line30> public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) <line31> throws IOException { <line32> Path pathInZipFile = <line33> zipfs.getPath(file.toString().substring(dest.toString().length())); <line34> Files.copy(file, pathInZipFile, StandardCopyOption.REPLACE_EXISTING); <line35> return FileVisitResult.CONTINUE; <line36> } <line37> }); <line38> } else { <line39> Path pathInZipFile = <line40> zipfs.getPath( <line41> ""/"", <line42> realPath <line43> .toString() <line44> .substring(REPOSITORY_BASE_PATH.length() + paramDest.length())); <line45> Path pathInZipFolder = pathInZipFile.getParent(); <line46> if (!Files.isDirectory(pathInZipFolder)) { <line47> Files.createDirectories(pathInZipFolder); <line48> } <line49> Files.copy(realPath, pathInZipFile, StandardCopyOption.REPLACE_EXISTING); <line50> } <line51> } <line52> zipped = true; <line53> } finally { <line54> if (!zipped) { <line55> Files.deleteIfExists(zip); <line56> } <line57> } <line58> return success(params); <line59> } catch (IOException e) { <line60> return error(e.getClass().getSimpleName() + "":"" + e.getMessage()); <line61> } <line62> } <line63> } <line64> "	<line34>, <line49>, <line60>
5768	public class A { <line0> @Override <line1> public TqlElement visitFieldIsNull(TqlParser.FieldIsNullContext ctx) { <line2> TqlElement fieldName = ctx.getChild(0).accept(this); <line3> FieldIsNullExpression isNullExpression = new FieldIsNullExpression(fieldName); <line4> return isNullExpression; <line5> } <line6> } <line7> 	<line2>, <line4>
5769	public class A { <line0> @Initialize <line1> public void init() { <line2> final ClassLoader parent = getClass().getClassLoader(); <line3> _groovyClassLoader = new GroovyClassLoader(parent); <line4> final Class<?> groovyClass = _groovyClassLoader.parseClass(code); <line5> _groovyObject = (GroovyObject) ReflectionUtils.newInstance(groovyClass); <line6> } <line7> } <line8> 	<line4>
5770	public class A { <line0> @Override <line1> public void onRegistrationSuccess( <line2> ServerIdentity server, RegisterRequest request, String registrationID) { <line3> } <line4> } <line5> 	<line3>
5771	public class A { <line0> @Override <line1> public void onNodeJoined(String nodeName) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> if (isVertxReady()) { <line5> getEventBus().publish(CLUSTER_NODE_JOINED.address, nodeName); <line6> } <line7> } <line8> } <line9> 	<line3>
5772	public class A { <line0> protected BookieNode replaceFromRack( <line1> BookieNode bookieNodeToReplace, <line2> Set<Node> excludeBookies, <line3> Predicate<BookieNode> predicate, <line4> Ensemble<BookieNode> ensemble, <line5> boolean enforceDurability) <line6> throws BKException.BKNotEnoughBookiesException { <line7> Set<String> availableRegions = new HashSet<String>(); <line8> for (String region : perRegionPlacement.keySet()) { <line9> if ((null == disallowBookiePlacementInRegionFeatureName) <line10> || !featureProvider <line11> .scope(region) <line12> .getFeature(disallowBookiePlacementInRegionFeatureName) <line13> .isAvailable()) { <line14> availableRegions.add(region); <line15> } <line16> } <line17> String regionForBookieToReplace = getLocalRegion(bookieNodeToReplace); <line18> if (availableRegions.contains(regionForBookieToReplace)) { <line19> TopologyAwareEnsemblePlacementPolicy regionPolicy = <line20> perRegionPlacement.get(regionForBookieToReplace); <line21> if (null != regionPolicy) { <line22> try { <line23> return regionPolicy.selectFromNetworkLocation( <line24> bookieNodeToReplace.getNetworkLocation(), <line25> excludeBookies, <line26> TruePredicate.INSTANCE, <line27> EnsembleForReplacementWithNoConstraints.INSTANCE, <line28> true); <line29> } catch (BKException.BKNotEnoughBookiesException e) { <line30> } <line31> } <line32> } <line33> return selectRandomFromRegions( <line34> availableRegions, <line35> 1, <line36> excludeBookies, <line37> enforceDurability ? predicate : TruePredicate.INSTANCE, <line38> enforceDurability ? ensemble : EnsembleForReplacementWithNoConstraints.INSTANCE) <line39> .get(0); <line40> } <line41> } <line42> 	<line30>
5773	"public class A { <line0> public void update(UpnpControlBindingConfiguration newConfig) { <line1> String newPath = newConfig.path; <line2> if (newPath.isEmpty()) { <line3> path = DEFAULT_PATH; <line4> } else { <line5> File file = new File(newPath); <line6> if (!file.isDirectory()) { <line7> file = file.getParentFile(); <line8> } <line9> if (file.exists()) { <line10> if (!(newPath.endsWith(File.separator) || newPath.endsWith(""/""))) { <line11> newPath = newPath + File.separator; <line12> } <line13> path = newPath; <line14> } else { <line15> path = DEFAULT_PATH; <line16> } <line17> } <line18> UpnpControlUtil.bindingConfigurationChanged(path); <line19> } <line20> } <line21> "	<line18>
5774	public class A { <line0> VertexStatus getVertexStatusViaAM(String vertexName, Set<StatusGetOpts> statusOptions) <line1> throws TezException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> GetVertexStatusRequestProto.Builder requestProtoBuilder = <line5> GetVertexStatusRequestProto.newBuilder().setDagId(dagId).setVertexName(vertexName); <line6> if (statusOptions != null) { <line7> requestProtoBuilder.addAllStatusOptions( <line8> DagTypeConverters.convertStatusGetOptsToProto(statusOptions)); <line9> } <line10> try { <line11> return new VertexStatus( <line12> proxy.getVertexStatus(null, requestProtoBuilder.build()).getVertexStatus()); <line13> } catch (ServiceException e) { <line14> throw new TezException(e); <line15> } <line16> } <line17> } <line18> 	<line3>
5775	public class A { <line0> private void collectPointX(JSONSaxPrimitiveValue value) { <line1> myCurrentLon = value.getDouble(); <line2> if (LOGGER.isTraceEnabled()) { <line3> } <line4> myState = ArcSaxState.SEEK_POINT_Y_TAG; <line5> } <line6> } <line7> 	<line3>
5776	public class A { <line0> public void warn(Throwable t, String message, Object... formatArgs) { <line1> } <line2> } <line3> 	<line1>
5777	"public class A { <line0> protected void doTestStore(IPageStore pageStore) { <line1> this.pageStore = new AsynchronousPageStore(pageStore, 100); <line2> generateSessionsAndPages(); <line3> long start = System.currentTimeMillis(); <line4> for (int i = 0; i < THREAD_COUNT; ++i) { <line5> new Thread(new Read1Runnable()).start(); <line6> } <line7> for (int i = 0; i < THREAD_COUNT; ++i) { <line8> new Thread(new Read2Runnable()).start(); <line9> } <line10> for (int i = 0; i < THREAD_COUNT; ++i) { <line11> new Thread(new SaveRunnable()).start(); <line12> } <line13> while (!(read1Done.get() && read2Done.get() && saveDone.get())) { <line14> try { <line15> Thread.sleep(50); <line16> } catch (InterruptedException e) { <line17> } <line18> } <line19> if (exceptionThrownByThread != null) { <line20> throw new RuntimeException(""One of the worker threads failed."", exceptionThrownByThread); <line21> } <line22> long duration = System.currentTimeMillis() - start; <line23> assertEquals(0, failures.get()); <line24> for (String s : sessionCounter.keySet()) { <line25> pageStore.removeAllPages(getContext(s)); <line26> } <line27> } <line28> } <line29> "	<line3>, <line17>, <line23>
5778	public class A { <line0> public void stopService() { <line1> running.set(false); <line2> try { <line3> serverSocket.close(); <line4> } catch (IOException e) { <line5> } <line6> clientHandler.interrupt(); <line7> } <line8> } <line9> 	<line1>, <line5>, <line7>
5779	"public class A { <line0> @Test <line1> public void shouldNotStartWithInvalidConfiguration() { <line2> config = <line3> Configuration.create() <line4> .with(MySqlConnectorConfig.SERVER_NAME, ""myserver"") <line5> .with(KafkaDatabaseHistory.TOPIC, ""myserver"") <line6> .with(MySqlConnectorConfig.DATABASE_HISTORY, FileDatabaseHistory.class) <line7> .with(FileDatabaseHistory.FILE_PATH, DB_HISTORY_PATH) <line8> .build(); <line9> start( <line10> MySqlConnector.class, <line11> config, <line12> (success, msg, error) -> { <line13> assertThat(success).isFalse(); <line14> assertThat(error).isNotNull(); <line15> }); <line16> assertConnectorNotRunning(); <line17> } <line18> } <line19> "	<line9>
5780	"public class A { <line0> @Test <line1> public void testCleanupOnDelete() throws Exception { <line2> System.setProperty(EVENTS_DISABLED, ""true""); <line3> final EntityManager em = app.getEntityManager(); <line4> final int numEntities = 5; <line5> final int numUpdates = 5; <line6> final List<Entity> things = new ArrayList<Entity>(numEntities); <line7> for (int i = 0; i < numEntities; i++) { <line8> final String thingName = ""thing"" + i; <line9> things.add( <line10> em.create( <line11> ""thing"", <line12> new HashMap<String, Object>() { <line13> { <line14> put(""name"", thingName); <line15> } <line16> })); <line17> Thread.sleep(writeDelayMs); <line18> } <line19> app.waitForQueueDrainAndRefreshIndex(); <line20> CandidateResults crs = queryCollectionCp(""things"", ""thing"", ""select *""); <line21> Assert.assertEquals(""Expect no stale candidates yet"", numEntities, crs.size()); <line22> int count = 0; <line23> List<Entity> maxVersions = new ArrayList<>(numEntities); <line24> for (Entity thing : things) { <line25> Entity toUpdate = null; <line26> for (int j = 0; j < numUpdates; j++) { <line27> toUpdate = em.get(thing.getUuid()); <line28> toUpdate.setProperty(""property"" + j, UUID.randomUUID().toString()); <line29> em.update(toUpdate); <line30> count++; <line31> if (count % 100 == 0) { <line32> } <line33> } <line34> maxVersions.add(toUpdate); <line35> } <line36> em.refreshIndex(); <line37> for (int i = 0; i < 10; i++) { <line38> crs = queryCollectionCp(""things"", ""thing"", ""select *""); <line39> if (numEntities * (numUpdates + 1) == crs.size()) { <line40> break; <line41> } else { <line42> Thread.sleep(1100); <line43> } <line44> } <line45> System.setProperty(EVENTS_DISABLED, ""false""); <line46> Thread.sleep(250); <line47> app.waitForQueueDrainAndRefreshIndex(); <line48> Thread.sleep(250); <line49> Results results = null; <line50> count = 0; <line51> do { <line52> results = queryCollectionEm(""things"", ""select *""); <line53> results.getEntities().stream() <line54> .forEach( <line55> entity -> { <line56> try { <line57> em.delete(entity); <line58> } catch (Exception e) { <line59> } <line60> }); <line61> app.waitForQueueDrainAndRefreshIndex(); <line62> crs = queryCollectionCp(""things"", ""thing"", ""select *""); <line63> } while (crs.size() > 0 && count++ < 2000); <line64> Assert.assertEquals(""Expect no candidates"", 0, crs.size()); <line65> } <line66> } <line67> "	<line2>, <line32>
5781	"public class A { <line0> private StringBuilder buildTargetTableArg(StringBuilder builder, CatalogTable catalog) <line1> throws FalconException { <line2> builder.append(""--skip-dist-cache"").append(ImportExportCommon.ARG_SEPARATOR); <line3> Iterator<String> itr = Splitter.on(""#"").split(catalog.getUri()).iterator(); <line4> String dbTable = itr.next(); <line5> String partitions = itr.next(); <line6> Iterator<String> itrDbTable = Splitter.on("":"").split(dbTable).iterator(); <line7> itrDbTable.next(); <line8> String db = itrDbTable.next(); <line9> String table = itrDbTable.next(); <line10> builder <line11> .append(""--hcatalog-database"") <line12> .append(ImportExportCommon.ARG_SEPARATOR) <line13> .append( <line14> String.format( <line15> ""${coord:databaseOut('%s')}"", FeedImportCoordinatorBuilder.IMPORT_DATAOUT_NAME)) <line16> .append(ImportExportCommon.ARG_SEPARATOR); <line17> builder <line18> .append(""--hcatalog-table"") <line19> .append(ImportExportCommon.ARG_SEPARATOR) <line20> .append( <line21> String.format( <line22> ""${coord:tableOut('%s')}"", FeedImportCoordinatorBuilder.IMPORT_DATAOUT_NAME)) <line23> .append(ImportExportCommon.ARG_SEPARATOR); <line24> Map<String, String> partitionsMap = ImportExportCommon.getPartitionKeyValues(partitions); <line25> if (partitionsMap.size() > 0) { <line26> StringBuilder partitionKeys = new StringBuilder(); <line27> StringBuilder partitionValues = new StringBuilder(); <line28> for (Map.Entry<String, String> e : partitionsMap.entrySet()) { <line29> partitionKeys.append(e.getKey()); <line30> partitionKeys.append(','); <line31> partitionValues.append( <line32> String.format( <line33> ""${coord:dataOutPartitionValue('%s','%s')}"", <line34> FeedImportCoordinatorBuilder.IMPORT_DATAOUT_NAME, e.getKey())); <line35> partitionValues.append(','); <line36> } <line37> if (partitionsMap.size() > 0) { <line38> partitionKeys.setLength(partitionKeys.length() - 1); <line39> partitionValues.setLength(partitionValues.length() - 1); <line40> } <line41> builder <line42> .append(""--hcatalog-partition-keys"") <line43> .append(ImportExportCommon.ARG_SEPARATOR) <line44> .append(partitionKeys.toString()) <line45> .append(ImportExportCommon.ARG_SEPARATOR); <line46> builder <line47> .append(""--hcatalog-partition-values"") <line48> .append(ImportExportCommon.ARG_SEPARATOR) <line49> .append(partitionValues.toString()) <line50> .append(ImportExportCommon.ARG_SEPARATOR); <line51> } <line52> return builder; <line53> } <line54> } <line55> "	<line2>, <line10>, <line41>
5782	public class A { <line0> public Templates getStylesheet(Source stylesheet) { <line1> try { <line2> return saxFactory.newTemplates(stylesheet); <line3> } catch (TransformerConfigurationException tcx) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	<line4>
5783	"public class A { <line0> @Test <line1> public void test() throws Exception { <line2> String publicWebappURL = OneRecordingServer.getPublicWebappUrl(); <line3> File fileToUpload = new File(""test-files/logo.png""); <line4> uploadFileWithCURL(publicWebappURL + ""repository_servlet/video-upload"", fileToUpload); <line5> Thread.sleep(10 * 1000); <line6> File downloadedFile = new File(""test-files/sampleDownload.txt""); <line7> downloadFromURL(publicWebappURL + ""repository_servlet/video-download"", downloadedFile); <line8> boolean equalFiles = TestUtils.equalFiles(fileToUpload, downloadedFile); <line9> if (equalFiles) { <line10> } else { <line11> } <line12> assertTrue(""The uploadad and downloaded files are different"", equalFiles); <line13> } <line14> } <line15> "	<line3>, <line5>, <line7>, <line10>, <line11>
5784	public class A { <line0> public void writeConfiguration(SolrConfig solrConfig) throws ApsSystemException { <line1> try { <line2> String marshalInfo = SolrConfigDOM.marshalConfig(solrConfig); <line3> this.getConfigManager() <line4> .updateConfigItem( <line5> SolrConnectorSystemConstants.JPSOLRCLIENT_SYSTEM_CONFIG_NAME, marshalInfo); <line6> } catch (ApsSystemException e) { <line7> throw e; <line8> } <line9> } <line10> } <line11> 	<line7>
5785	public class A { <line0> @Override <line1> public void update(AccountAsset accountAsset) { <line2> AccountService.checkBalance( <line3> accountAsset.getAccountId(), <line4> accountAsset.getQuantityATU(), <line5> accountAsset.getUnconfirmedQuantityATU()); <line6> if (accountAsset.getQuantityATU() > 0 || accountAsset.getUnconfirmedQuantityATU() > 0) { <line7> accountAssetTable.insert(accountAsset); <line8> } else { <line9> int height = blockChainInfoService.getHeight(); <line10> accountAssetTable.deleteAtHeight(accountAsset, height); <line11> } <line12> } <line13> } <line14> 	<line2>, <line8>, <line11>
5786	"public class A { <line0> protected Entity addCluster(Location location) { <line1> String locationName = elvis(location.getDisplayName(), location.getDisplayName(), null); <line2> Map creation = Maps.newLinkedHashMap(); <line3> creation.putAll(getCustomChildFlags()); <line4> if (groovyTruth(getDisplayNamePrefix()) || groovyTruth(getDisplayNameSuffix())) { <line5> String displayName = <line6> """" <line7> + elvis(getDisplayNamePrefix(), """") <line8> + elvis(locationName, ""unnamed"") <line9> + elvis(getDisplayNameSuffix(), """"); <line10> creation.put(""displayName"", displayName); <line11> } <line12> Entity entity = createCluster(location, creation); <line13> if (locationName != null) { <line14> if (entity.getDisplayName() == null) <line15> entity.setDisplayName(entity.getEntityType().getSimpleName() + "" ("" + locationName + "")""); <line16> else if (!entity.getDisplayName().contains(locationName)) <line17> entity.setDisplayName(entity.getDisplayName() + "" ("" + locationName + "")""); <line18> } <line19> if (entity.getParent() == null) entity.setParent(this); <line20> Entities.manage(entity); <line21> addMember(entity); <line22> return entity; <line23> } <line24> } <line25> "	<line12>
5787	public class A { <line0> static ByteBuffer concatBuffers(List<DataBuffer> buffers) { <line1> int partSize = 0; <line2> for (DataBuffer b : buffers) { <line3> partSize += b.readableByteCount(); <line4> } <line5> ByteBuffer partData = ByteBuffer.allocate(partSize); <line6> buffers.forEach( <line7> (buffer) -> { <line8> partData.put(buffer.asByteBuffer()); <line9> }); <line10> partData.rewind(); <line11> return partData; <line12> } <line13> } <line14> 	<line1>, <line11>
5788	public class A { <line0> public Object doInConnection(Connection conn) throws SQLException, DataAccessException { <line1> try { <line2> conn.setAutoCommit(false); <line3> Statement statement = conn.createStatement(); <line4> int counter = 0; <line5> for (Map<String, List<String>> columnNameOldNewValuesMap : <line6> rowsToEncryptColumnNameOldNewValuesMap) { <line7> statement.addBatch(getUpdateBackupTableColumnsSql(tableName, columnNameOldNewValuesMap)); <line8> counter++; <line9> } <line10> statement.executeBatch(); <line11> conn.commit(); <line12> } catch (Exception e) { <line13> conn.rollback(); <line14> return false; <line15> } <line16> return true; <line17> } <line18> } <line19> 	<line12>, <line13>
5789	public class A { <line0> @Override <line1> public void handle(Event event) { <line2> ContentCacheUpdate update = createUpdate(event); <line3> try { <line4> this.controller.update(update); <line5> } catch (OwsExceptionReport ex) { <line6> } <line7> } <line8> } <line9> 	<line3>, <line6>
5790	public class A { <line0> public void useOrderManager(OrderManager manager) { <line1> if (myOrderManager != null && !Utilities.sameInstance(myOrderManager, manager)) { <line2> myOrderManager.removeParticipantChangeListener(myOrderListener); <line3> } <line4> myOrderManager = manager; <line5> myOrderManager.addParticipantChangeListener(myOrderListener); <line6> } <line7> } <line8> 	<line2>
5791	"public class A { <line0> public static java.util.List<com.liferay.commerce.inventory.model.CommerceInventoryWarehouse> <line1> getCommerceInventoryWarehouses( <line2> HttpPrincipal httpPrincipal, long companyId, long groupId, boolean active) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> new MethodKey( <line7> CommerceInventoryWarehouseServiceUtil.class, <line8> ""getCommerceInventoryWarehouses"", <line9> _getCommerceInventoryWarehousesParameterTypes10); <line10> MethodHandler methodHandler = new MethodHandler(methodKey, companyId, groupId, active); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (java.util.List<com.liferay.commerce.inventory.model.CommerceInventoryWarehouse>) <line21> returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>
5792	"public class A { <line0> public static void updateStatus( <line1> HttpPrincipal httpPrincipal, <line2> long membershipRequestId, <line3> String reviewComments, <line4> long statusId, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey( <line10> MembershipRequestServiceUtil.class, ""updateStatus"", _updateStatusParameterTypes3); <line11> MethodHandler methodHandler = <line12> new MethodHandler( <line13> methodKey, membershipRequestId, reviewComments, statusId, serviceContext); <line14> try { <line15> TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line18> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line19> } <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>
5793	"public class A { <line0> private <T extends AbstractProfileObject> T resolveConfiguration(Realm realm, T profileObject) { <line1> String hostname = realm != null ? realm.getConnectionDescriptor().getHostname() : null; <line2> String baseDN = realm != null ? realm.getConnectionDescriptor().getBaseDN() : null; <line3> if (hostname == null || hostname.length() == 0) { <line4> } <line5> if (baseDN == null || baseDN.length() == 0) { <line6> } <line7> if (profileObject instanceof Client) { <line8> Client client = (Client) profileObject; <line9> if (client.getHardwareType() != null) { <line10> mergeConfiguration(client, client.getHardwareType().getConfiguration()); <line11> client.setHardwareType(null); <line12> } <line13> if (client.getLocation() != null) { <line14> mergeConfiguration(client, client.getLocation().getConfiguration()); <line15> client.setLocation(null); <line16> } <line17> } <line18> if (hostname != null && (hostname.equals(""localhost"") || hostname.equals(""127.0.0.1""))) { <line19> Optional<InetAddress> externalIp = determineExternalIp(); <line20> if (externalIp.isPresent()) { <line21> hostname = externalIp.get().getHostAddress(); <line22> } else { <line23> } <line24> } <line25> final String host = hostname; <line26> Map<String, Object> additionalProperties = <line27> profileObject.getConfiguration().getAdditionalProperties(); <line28> Set<Map.Entry<String, Object>> entries = additionalProperties.entrySet(); <line29> entries.forEach( <line30> entry -> { <line31> if (entry.getValue() != null <line32> && entry.getValue().toString().contains(""${myip}"") <line33> && host != null) { <line34> entry.setValue(entry.getValue().toString().replaceAll(""\\$\\{myip\\}"", host)); <line35> } <line36> if (entry.getValue() != null <line37> && entry.getValue().toString().contains(""${urlencoded:basedn}"") <line38> && baseDN != null) { <line39> try { <line40> entry.setValue( <line41> entry <line42> .getValue() <line43> .toString() <line44> .replaceAll( <line45> ""\\$\\{urlencoded\\:basedn\\}"", URLEncoder.encode(baseDN, ""UTF-8""))); <line46> } catch (UnsupportedEncodingException e) { <line47> } <line48> } <line49> if (entry.getValue() != null <line50> && entry.getValue().toString().contains(""${basedn}"") <line51> && baseDN != null) { <line52> entry.setValue(entry.getValue().toString().replaceAll(""\\$\\{basedn\\}"", baseDN)); <line53> } <line54> }); <line55> return profileObject; <line56> } <line57> } <line58> "	<line4>, <line6>, <line22>, <line23>, <line47>
5794	public class A { <line0> @Override <line1> public void dispose() { <line2> List<RoleHint<?>> keys = new ArrayList<>(this.componentEntries.size() * 2); <line3> for (Map<String, ComponentEntry<?>> entries : this.componentEntries.values()) { <line4> for (ComponentEntry<?> entry : entries.values()) { <line5> addForDisposalReversedOrder(entry, keys); <line6> } <line7> } <line8> Collections.reverse(keys); <line9> RoleHint<ComponentManager> cmRoleHint = new RoleHint<>(ComponentManager.class); <line10> ComponentEntry<?> cmEntry = getComponentEntry(cmRoleHint.getRoleType(), cmRoleHint.getHint()); <line11> if (cmEntry != null && cmEntry.instance == this) { <line12> cmEntry.disposing = false; <line13> keys.remove(cmRoleHint); <line14> } <line15> Collections.sort( <line16> keys, <line17> new Comparator<RoleHint<?>>() { <line18> @Override <line19> public int compare(RoleHint<?> rh1, RoleHint<?> rh2) { <line20> return getPriority(rh1) - getPriority(rh2); <line21> } <line22>  <line23> private int getPriority(RoleHint<?> rh) { <line24> Object instance = getComponentEntry(rh.getRoleType(), rh.getHint()).instance; <line25> if (instance == null) { <line26> return DisposePriority.DEFAULT_PRIORITY; <line27> } else { <line28> DisposePriority priorityAnnotation = <line29> instance.getClass().getAnnotation(DisposePriority.class); <line30> return (priorityAnnotation == null) <line31> ? DisposePriority.DEFAULT_PRIORITY <line32> : priorityAnnotation.value(); <line33> } <line34> } <line35> }); <line36> for (RoleHint<?> key : keys) { <line37> ComponentEntry<?> componentEntry = getComponentEntry(key.getRoleType(), key.getHint()); <line38> synchronized (componentEntry) { <line39> Object instance = componentEntry.instance; <line40> if (instance instanceof Disposable && componentEntry.instance != this) { <line41> try { <line42> ((Disposable) instance).dispose(); <line43> } catch (ComponentLifecycleException e) { <line44> } <line45> } <line46> } <line47> } <line48> for (RoleHint<?> key : keys) { <line49> this.componentEntries.get(key.getRoleType()).remove(key.getHint()); <line50> } <line51> } <line52> } <line53> 	<line42>, <line43>, <line44>
5795	"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""org.nd4j.linalg.BaseNd4jTestWithBackends#configs"") <line2> public void testGradientAutoBroadcast1(Nd4jBackend backend) { <line3> Nd4j.getRandom().setSeed(12345); <line4> List<String> failed = new ArrayList<>(); <line5> for (int dim_sz1 : new int[] {0, 1, 2}) { <line6> int[] in2Shape = {3, 4, 5}; <line7> in2Shape[dim_sz1] = 1; <line8> for (int i = 0; i < 8; i++) { <line9> SameDiff sd = SameDiff.create(); <line10> SDVariable in3 = sd.var(""in3"", Nd4j.rand(new int[] {3, 4, 5})); <line11> SDVariable in2 = sd.var(""in2"", in2Shape); <line12> SDVariable bcOp; <line13> String name; <line14> switch (i) { <line15> case 0: <line16> bcOp = in3.add(in2); <line17> name = ""add""; <line18> break; <line19> case 1: <line20> bcOp = in3.sub(in2); <line21> name = ""sub""; <line22> break; <line23> case 2: <line24> bcOp = in3.mul(in2); <line25> name = ""mul""; <line26> break; <line27> case 3: <line28> bcOp = in3.div(in2); <line29> name = ""div""; <line30> break; <line31> case 4: <line32> bcOp = in3.rsub(in2); <line33> name = ""rsub""; <line34> break; <line35> case 5: <line36> bcOp = in3.rdiv(in2); <line37> name = ""rdiv""; <line38> break; <line39> case 6: <line40> bcOp = new FloorDivOp(sd, in3, in2).outputVariable(); <line41> name = ""floordiv""; <line42> break; <line43> case 7: <line44> bcOp = new FloorModOp(sd, in3, in2).outputVariable(); <line45> name = ""floormod""; <line46> if (OpValidationSuite.IGNORE_FAILING) { <line47> continue; <line48> } <line49> break; <line50> default: <line51> throw new RuntimeException(); <line52> } <line53> SDVariable outVar = sd.sum(bcOp); <line54> String msg = ""(test "" + i + "": "" + name + "", dimension="" + dim_sz1 + "")""; <line55> INDArray in3Arr = Nd4j.randn(new int[] {3, 4, 5}).muli(100); <line56> INDArray in2Arr = Nd4j.randn(in2Shape).muli(100); <line57> sd.associateArrayWithVariable(in3Arr, in3); <line58> sd.associateArrayWithVariable(in2Arr, in2); <line59> TestCase tc = new TestCase(sd); <line60> String error = OpValidation.validate(tc); <line61> if (error != null) { <line62> failed.add(name); <line63> } <line64> } <line65> } <line66> assertEquals(0, failed.size(), ""Failed: "" + failed); <line67> } <line68> } <line69> "	<line55>
5796	"public class A { <line0> public boolean refreshOvenConnection(Helper message, String thingUID) { <line1> if (config.hostIP == null || config.hostPIN == null) { <line2> message.setStatusDescription(""Error in configuration. Please recreate Thing.""); <line3> return false; <line4> } <line5> HaasSohnpelletstoveJsonDataDTO result = null; <line6> boolean resultOk = false; <line7> String error = """", errorDetail = """", statusDescr = """"; <line8> String urlStr = ""http://"" + config.hostIP + ""/status.cgi""; <line9> String response = null; <line10> try { <line11> response = HttpUtil.executeUrl(""GET"", urlStr, 10000); <line12> result = gson.fromJson(response, HaasSohnpelletstoveJsonDataDTO.class); <line13> resultOk = true; <line14> } catch (IOException e) { <line15> statusDescr = <line16> ""Timeout error with"" <line17> + config.hostIP <line18> + "". Cannot find service on give IP. Please verify the IP-Address!""; <line19> errorDetail = e.getMessage(); <line20> resultOk = false; <line21> } catch (Exception e) { <line22> errorDetail = e.getMessage(); <line23> resultOk = false; <line24> } <line25> if (resultOk) { <line26> ovenData = result; <line27> xhspin = getValidXHSPIN(ovenData); <line28> } else { <line29> ovenData = new HaasSohnpelletstoveJsonDataDTO(); <line30> } <line31> message.setStatusDescription(statusDescr); <line32> return resultOk; <line33> } <line34> } <line35> "	<line12>, <line15>, <line22>, <line29>
5797	public class A { <line0> private static CuratorFramework provideInitializedZookeeperClient(String zkConnection) <line1> throws Exception { <line2> RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3); <line3> CuratorFramework zkClient = <line4> CuratorFrameworkFactory.builder() <line5> .namespace(NAMESPACE) <line6> .connectString(zkConnection) <line7> .retryPolicy(retryPolicy) <line8> .build(); <line9> zkClient.start(); <line10> zkClient.blockUntilConnected(); <line11> return zkClient; <line12> } <line13> } <line14> 	<line2>, <line9>, <line11>
5798	public class A { <line0> private static boolean defineActivePowerControl( <line1> Network network, <line2> String id, <line3> PsseTransformerWinding winding, <line4> PhaseTapChanger ptc, <line5> boolean regulatingForcedToOff) { <line6> if (Math.abs(winding.getCod()) != 3) { <line7> return false; <line8> } <line9> Terminal regulatingTerminal = defineRegulatingTerminal(network, id, winding); <line10> if (regulatingTerminal == null) { <line11> return false; <line12> } <line13> double activePowerMin = winding.getVmi(); <line14> double activePowerMax = winding.getVma(); <line15> double targetValue = 0.5 * (activePowerMin + activePowerMax); <line16> double targetDeadBand = activePowerMax - activePowerMin; <line17> boolean regulating = true; <line18> if (targetDeadBand < 0.0) { <line19> regulating = false; <line20> } <line21> if (regulating && regulatingForcedToOff) { <line22> regulating = false; <line23> } <line24> ptc.setRegulationValue(targetValue) <line25> .setTargetDeadband(targetDeadBand) <line26> .setRegulationTerminal(regulatingTerminal) <line27> .setRegulationMode(PhaseTapChanger.RegulationMode.ACTIVE_POWER_CONTROL) <line28> .setRegulating(regulating); <line29> return regulating; <line30> } <line31> } <line32> 	<line22>
5799	public class A { <line0> public void startService(String serviceName) throws ServiceAdminException, RemoteException { <line1> serviceAdminStub.startService(serviceName); <line2> } <line3> } <line4> 	<line2>
5800	"public class A { <line0> @Override <line1> public void beforeRuntimeStop(ComponentManager mgr, boolean isStandby) { <line2> List<WorkQueueDescriptor> descriptors = getRegistryContributions(QUEUES_EP); <line3> for (WorkQueueDescriptor descriptor : descriptors) { <line4> deactivateQueue(descriptor); <line5> } <line6> try { <line7> if (!shutdown(10, TimeUnit.SECONDS)) { <line8> } <line9> } catch (InterruptedException e) { <line10> Thread.currentThread().interrupt(); <line11> throw new NuxeoException(""Interrupted while stopping work manager thread pools"", e); <line12> } <line13> } <line14> } <line15> "	<line8>
5801	public class A { <line0> public void failJob(String message, String details) { <line1> throw new JobFailedException(message, details); <line2> } <line3> } <line4> 	<line1>
5802	public class A { <line0> private static void registerListenerForRemoteCommits() { <line1> ITopic<RemoteCommit> topic = getHazelcastInstance().getTopic(FF_COMMIT_TOPIC_NAME); <line2> topic.addMessageListener( <line3> new MessageListener<RemoteCommit>() { <line4> @Override <line5> public void onMessage(Message<RemoteCommit> message) { <line6> RemoteCommit remoteCommit = message.getMessageObject(); <line7> if (remoteCommit.getServerId() == DomainClassInfo.getServerId()) { <line8> } else { <line9> REMOTE_COMMITS.offer(remoteCommit); <line10> } <line11> } <line12> }); <line13> } <line14> } <line15> 	<line8>, <line9>
5803	public class A { <line0> public void attachCellEditors() { <line1> String[] properties = new String[columns.size()]; <line2> CellEditor[] cellEditors = new CellEditor[columns.size()]; <line3> int size = columns.size(); <line4> for (int i = 0; i < size; i++) { <line5> TableViewerCreatorColumnNotModifiable column = columns.get(i); <line6> properties[i] = column.getId(); <line7> cellEditors[i] = column.getCellEditor(); <line8> if (column.getCellEditor() != null && column.getBeanPropertyAccessors() == null) { <line9> } <line10> } <line11> tableViewer.setColumnProperties(properties); <line12> tableViewer.setCellEditors(cellEditors); <line13> } <line14> } <line15> 	<line9>
5804	public class A { <line0> @Override <line1> public int getProductCount() { <line2> return super.getProductCount(); <line3> } <line4> } <line5> 	<line2>
5805	public class A { <line0> public void run() { <line1> try { <line2> while (!stopped && !acceptSocket.socket().isClosed()) { <line3> try { <line4> select(); <line5> } catch (RuntimeException e) { <line6> } catch (Exception e) { <line7> } <line8> } <line9> } finally { <line10> closeSelector(); <line11> if (!reconfiguring) { <line12> NIOServerCnxnFactory.this.stop(); <line13> } <line14> } <line15> } <line16> } <line17> 	<line6>, <line7>, <line14>
5806	public class A { <line0> @Override <line1> public Aggregation<P, R, T> createAggregation( <line2> final DataTypeAdapter<T> adapter, final Index index) { <line3> GeotoolsFeatureDataAdapter gtAdapter; <line4> if (adapter instanceof GeotoolsFeatureDataAdapter) { <line5> gtAdapter = (GeotoolsFeatureDataAdapter) adapter; <line6> } else if ((adapter instanceof InternalDataAdapter) <line7> && (((InternalDataAdapter) adapter).getAdapter() instanceof GeotoolsFeatureDataAdapter)) { <line8> gtAdapter = (GeotoolsFeatureDataAdapter) ((InternalDataAdapter) adapter).getAdapter(); <line9> } else { <line10> return null; <line11> } <line12> if ((fieldNameParam == null) || isCommonIndex(index, gtAdapter)) { <line13> return createCommonIndexAggregation(); <line14> } <line15> return createAggregation(); <line16> } <line17> } <line18> 	<line10>
5807	"public class A { <line0> protected static void clearReferences() { <line1> Enumeration<Driver> drivers = DriverManager.getDrivers(); <line2> while (drivers.hasMoreElements()) { <line3> Driver driver = drivers.nextElement(); <line4> if (driver.getClass().getClassLoader() == getInstance()) { <line5> try { <line6> DriverManager.deregisterDriver(driver); <line7> } catch (SQLException e) { <line8> } <line9> } <line10> } <line11> for (WeakReference<Class<?>> refClazz : getInstance().cachedClasses.values()) { <line12> if (refClazz == null) { <line13> continue; <line14> } <line15> Class<?> clazz = refClazz.get(); <line16> if (clazz != null && clazz.getName().contains(""openmrs"")) { <line17> try { <line18> Field[] fields = clazz.getDeclaredFields(); <line19> for (Field field : fields) { <line20> int mods = field.getModifiers(); <line21> if (field.getType().isPrimitive() || (field.getName().contains(""$""))) { <line22> continue; <line23> } <line24> if (Modifier.isStatic(mods)) { <line25> try { <line26> if (clazz.equals(OpenmrsClassLoader.class) && ""log"".equals(field.getName())) { <line27> continue; <line28> } <line29> field.setAccessible(true); <line30> if (Modifier.isFinal(mods)) { <line31> if (!(field.getType().getName().startsWith(""javax.""))) { <line32> nullInstance(field.get(null)); <line33> } <line34> } else { <line35> field.set(null, null); <line36> } <line37> } catch (Exception t) { <line38> } <line39> } <line40> } <line41> } catch (Exception t) { <line42> } <line43> } <line44> } <line45> OpenmrsClassLoader.log = null; <line46> getInstance().cachedClasses.clear(); <line47> } <line48> } <line49> "	<line8>, <line36>, <line38>, <line42>
5808	"public class A { <line0> @Override <line1> public int getSignalStrength() throws KuraException { <line2> int signalStrength = -115; <line3> synchronized (this.atLock) { <line4> String atPort = getAtPort(); <line5> byte[] reply; <line6> CommConnection commAtConnection = openSerialPort(atPort); <line7> if (!isAtReachable(commAtConnection)) { <line8> closeSerialPort(commAtConnection); <line9> throw new KuraException( <line10> KuraErrorCode.NOT_CONNECTED, <line11> MODEM_NOT_AVAILABLE_FOR_AT_CMDS_MSG + SimTechSim7000.class.getName()); <line12> } <line13> try { <line14> reply = <line15> commAtConnection.sendCommand( <line16> SimTechSim7000AtCommands.getSignalStrength.getCommand().getBytes(), 1000, 100); <line17> } catch (IOException e) { <line18> closeSerialPort(commAtConnection); <line19> throw new KuraException(KuraErrorCode.CONNECTION_FAILED, e); <line20> } <line21> closeSerialPort(commAtConnection); <line22> if (reply != null) { <line23> String[] asCsq; <line24> String sCsq = this.getResponseString(reply).toUpperCase(); <line25> if (sCsq.startsWith(""+CSQ:"")) { <line26> sCsq = sCsq.substring(""+CSQ:"".length()).trim(); <line27> asCsq = sCsq.split("",""); <line28> if (asCsq.length == 2) { <line29> int rssiVal = Integer.parseInt(asCsq[0]); <line30> if (rssiVal == 0) { <line31> signalStrength = -115; <line32> } else if (rssiVal == 1) { <line33> signalStrength = -111; <line34> } else if (rssiVal < 99) { <line35> signalStrength = -110 + (2 * (rssiVal - 2)); <line36> } <line37> } <line38> } <line39> } <line40> } <line41> this.rssi = signalStrength; <line42> return signalStrength; <line43> } <line44> } <line45> "	<line5>, <line27>, <line37>
5809	public class A { <line0> public void delete(StgMUmsetzStat persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
5810	"public class A { <line0> private void loadPlugin(URLClassLoader pluginClassLoader) { <line1> ServiceLoader<DolphinSchedulerPlugin> serviceLoader = <line2> ServiceLoader.load(DolphinSchedulerPlugin.class, pluginClassLoader); <line3> List<DolphinSchedulerPlugin> plugins = ImmutableList.copyOf(serviceLoader); <line4> Preconditions.checkState( <line5> !plugins.isEmpty(), <line6> ""No service providers the plugin {}"", <line7> DolphinSchedulerPlugin.class.getName()); <line8> for (DolphinSchedulerPlugin plugin : plugins) { <line9> for (AbstractDolphinPluginManager dolphinPluginManager : dolphinPluginManagerList) { <line10> dolphinPluginManager.installPlugin(plugin); <line11> } <line12> } <line13> } <line14> } <line15> "	<line9>
5811	"public class A { <line0> @Override <line1> public void deleteByQuery(TypeDescriptor typeDescriptor, Object query) throws ClientException { <line2> JsonNode queryJsonNode = getModelConverter().convertQuery(query); <line3> String json = writeRequestFromJsonNode(queryJsonNode); <line4> Response deleteResponse = <line5> restCallTimeoutHandler( <line6> () -> <line7> getClient() <line8> .performRequest( <line9> ElasticsearchKeywords.ACTION_POST, <line10> ElasticsearchResourcePaths.deleteByQuery(typeDescriptor), <line11> Collections.emptyMap(), <line12> ApplicationJsonEntityBuilder.buildFrom(json), <line13> new ContentTypeApplicationJsonHeader()), <line14> typeDescriptor.getIndex(), <line15> ""DELETE BY QUERY""); <line16> if (!isRequestSuccessful(deleteResponse) <line17> && !isRequestNotFound(deleteResponse) <line18> && !isRequestBadRequest(deleteResponse)) { <line19> throw buildExceptionFromUnsuccessfulResponse(""Delete by query"", deleteResponse); <line20> } <line21> } <line22> } <line23> "	<line3>
5812	"public class A { <line0> private static X509Certificate generateCert(ZonedDateTime now, X509CertificateHolder certHolder) <line1> throws Exception { <line2> final X509Certificate certificate = <line3> new JcaX509CertificateConverter().getCertificate(certHolder); <line4> certificate.checkValidity(Date.from(now.toInstant())); <line5> certificate.verify(certificate.getPublicKey()); <line6> final String fingerprint = <line7> BaseEncoding.base16() <line8> .withSeparator("":"", 2) <line9> .encode(MessageDigest.getInstance(""SHA-256"").digest(certificate.getEncoded())); <line10> return certificate; <line11> } <line12> } <line13> "	<line10>
5813	public class A { <line0> @Override <line1> public boolean checkParameters( <line2> AbstractParameter abstractParameter, ValidationParameters validationParameters) { <line3> if (!(abstractParameter instanceof NeptuneValidateParameters)) { <line4> return false; <line5> } <line6> return super.checkParameters(abstractParameter, validationParameters); <line7> } <line8> } <line9> 	<line4>
5814	public class A { <line0> public void updateContents( <line1> OmUrlFragment f, IPartialPageRequestHandler handler, boolean updateFragment) { <line2> BasePanel npanel = getPanel(f.getArea(), f.getType()); <line3> if (npanel != null) { <line4> if (getClient() != null) { <line5> updateContents(npanel, handler); <line6> } else { <line7> this.panel = npanel; <line8> } <line9> if (updateFragment) { <line10> UrlFragment uf = new UrlFragment(handler); <line11> uf.set(f.getArea().name(), f.getType()); <line12> } <line13> } <line14> } <line15> } <line16> 	<line3>
5815	"public class A { <line0> @Override <line1> public AsyncJobStatusDTO exportDataAsync( <line2> @Verify(Consumer.class) String consumerUuid, <line3> String cdnLabel, <line4> String webAppPrefix, <line5> String apiUrl) { <line6> HttpServletResponse response = ResteasyContext.getContextData(HttpServletResponse.class); <line7> Consumer consumer = consumerCurator.verifyAndLookupConsumer(consumerUuid); <line8> ConsumerType ctype = this.consumerTypeCurator.getConsumerType(consumer); <line9> Owner owner = ownerCurator.findOwnerById(consumer.getOwnerId()); <line10> JobConfig config = <line11> manifestManager.generateManifestAsync(consumerUuid, owner, cdnLabel, webAppPrefix, apiUrl); <line12> AsyncJobStatus job = null; <line13> try { <line14> job = this.jobManager.queueJob(config); <line15> } catch (JobException e) { <line16> String errmsg = <line17> this.i18n.tr( <line18> ""An unexpected exception occurred "" + ""while scheduling job \""{0}\"""", <line19> config.getJobKey()); <line20> throw new IseException(errmsg, e); <line21> } <line22> return this.translator.translate(job, AsyncJobStatusDTO.class); <line23> } <line24> } <line25> "	<line20>
5816	"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> public PackageId getId() { <line2> String group = get(PN_GROUP); <line3> String name = get(PN_NAME); <line4> String version = get(PN_VERSION); <line5> if (group == null || name == null || name.length() == 0) { <line6> String path = getInstallationPath(); <line7> if (path == null) { <line8> path = ""unknown""; <line9> } <line10> return new PackageId(path, version); <line11> } else { <line12> return new PackageId(group, name, version); <line13> } <line14> } <line15> } <line16> "	<line8>
5817	"public class A { <line0> public static void assertVerticesPresenceMinOccur( <line1> final VerticesResult verticesResult, <line2> final Vertex.VERTEX_TYPE vertexType, <line3> final int minOccurrence) { <line4> int occurrence = 0; <line5> for (Vertex vertex : verticesResult.getResults()) { <line6> if (vertex.getType() == vertexType) { <line7> occurrence++; <line8> if (occurrence >= minOccurrence) { <line9> return; <line10> } <line11> } <line12> } <line13> Assert.fail( <line14> String.format( <line15> ""Expected at least %d vertices of type %s. But found only %d"", <line16> minOccurrence, vertexType, occurrence)); <line17> } <line18> } <line19> "	<line7>
5818	"public class A { <line0> private void createHeader(String additionalHeader) { <line1> if (additionalHeader.isEmpty()) { <line2> return; <line3> } <line4> String[] nameValuePairs = additionalHeader.trim().split(""-H\\s+""); <line5> for (String nameValuePair : nameValuePairs) { <line6> if (nameValuePair.isEmpty()) { <line7> continue; <line8> } <line9> String[] pair = nameValuePair.trim().split(""\\s+""); <line10> if (pair.length != 2) { <line11> continue; <line12> } <line13> this.getAdditionalHeader().add(new BasicHeader(pair[0], pair[1])); <line14> } <line15> } <line16> } <line17> "	<line11>, <line14>
5819	"public class A { <line0> private static void loadLocalProps() { <line1> if (null == localProps) { <line2> localProps = new Properties(); <line3> } <line4> try { <line5> InputStream resourceAsStream; <line6> final String localPropsEnv = System.getenv(""LATKE_LOCAL_PROPS""); <line7> if (StringUtils.isNotBlank(localPropsEnv)) { <line8> resourceAsStream = new FileInputStream(localPropsEnv); <line9> } else { <line10> resourceAsStream = Latkes.class.getResourceAsStream(""/local.properties""); <line11> } <line12> if (null != resourceAsStream) { <line13> localProps.load(resourceAsStream); <line14> } <line15> } catch (final Exception e) { <line16> LOGGER.log(Level.DEBUG, ""Loads local.properties failed, ignored""); <line17> } <line18> } <line19> } <line20> "	<line8>, <line10>, <line14>
5820	public class A { <line0> @Override <line1> protected long convert(Path inputPath, SyncDataFileWriter<ExtendedRecord> dataFileWriter) <line2> throws IOException { <line3> DwcaReader reader = DwcaReader.fromLocation(inputPath.toString()); <line4> while (reader.advance()) { <line5> ExtendedRecord record = reader.getCurrent(); <line6> if (!record.getId().equals(ExtendedRecordConverter.getRecordIdError())) { <line7> dataFileWriter.append(record); <line8> } <line9> } <line10> reader.close(); <line11> return reader.getRecordsReturned(); <line12> } <line13> } <line14> 	<line4>
5821	"public class A { <line0> private void doClassification(HttpServletRequest request, HttpServletResponse response) { <line1> try { <line2> SLDClassifier c = <line3> new SLDClassifier( <line4> credentials, new ClassifierCommand(getBodyFromRequest(request)), factory); <line5> SLDDocService service = new SLDDocService(this.docTempDir, this.connectionPool); <line6> String fileName = <line7> service.saveData(c.getSLD(), SecurityHeaders.decode(request.getHeader(SEC_USERNAME))); <line8> PrintWriter out = response.getWriter(); <line9> out.println(""{\""success\"":true,\"""" + FILEPATH_VARNAME + ""\"":\"""" + SLD_URL + fileName + ""\""}""); <line10> } catch (DocServiceException e) { <line11> sendErrorToClient(response, e.getErrorCode(), e.getMessage()); <line12> } catch (IOException e) { <line13> } <line14> } <line15> } <line16> "	<line12>, <line13>
5822	public class A { <line0> @Override <line1> public void registerContribution( <line2> Object contribution, String extensionPoint, ComponentInstance contributor) throws Exception { <line3> if (CONVERTER_EP.equals(extensionPoint)) { <line4> ConverterDescriptor desc = (ConverterDescriptor) contribution; <line5> registerConverter(desc); <line6> } else if (CONFIG_EP.equals(extensionPoint)) { <line7> GlobalConfigDescriptor desc = (GlobalConfigDescriptor) contribution; <line8> config.update(desc); <line9> } else { <line10> } <line11> } <line12> } <line13> 	<line10>
5823	public class A { <line0> private TextMessage createWebSocketTextMessage(AgentActiveThreadCountList activeThreadCountList) { <line1> Map<String, Object> resultMap = <line2> createResultMap(activeThreadCountList, System.currentTimeMillis()); <line3> try { <line4> String response = <line5> messageConverter.getResponseTextMessage( <line6> ActiveThreadCountHandler.API_ACTIVE_THREAD_COUNT, resultMap); <line7> TextMessage responseTextMessage = new TextMessage(response); <line8> return responseTextMessage; <line9> } catch (JsonProcessingException e) { <line10> } <line11> return null; <line12> } <line13> } <line14> 	<line10>
5824	public class A { <line0> private long processUpload( <line1> final MultipartRequest multipartRequest, <line2> final HttpServletResponse response, <line3> final String filename, <line4> final boolean logo, <line5> final Integer resizeTo) <line6> throws StatusServletException, IOException, FileUploadException { <line7> final long[] size = {0L}; <line8> multipartRequest.parse( <line9> new MultipartRequestCallback() { <line10> @Override <line11> public void onInputStream(InputStream inputStream, String itemName, String mimeType) <line12> throws IOException { <line13> final String name = StringUtils.isNotBlank(filename) ? filename : itemName; <line14> try (final InputStream stream = inputStream) { <line15> if (logo) { <line16> size[0] = logoManager.updateLogo(stream, name); <line17> } else if (resizeTo == null) { <line18> size[0] = <line19> fileStorageProvider.copy(stream, name, StandardCopyOption.REPLACE_EXISTING); <line20> } else { <line21> try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) { <line22> imageMinimizer.resizeImage(inputStream, byteArrayOutputStream, resizeTo); <line23> try (ByteArrayInputStream byteArrayInputStream = <line24> new ByteArrayInputStream(byteArrayOutputStream.toByteArray())) { <line25> size[0] = <line26> fileStorageProvider.copy( <line27> byteArrayInputStream, name, StandardCopyOption.REPLACE_EXISTING); <line28> } <line29> } <line30> } <line31> response.setStatus(Response.SC_ACCEPTED); <line32> } <line33> } <line34> }); <line35> return size[0]; <line36> } <line37> } <line38> 	<line7>, <line15>, <line32>
5825	"public class A { <line0> ListenableFuture<RpcResult<Void>> removeRedundantMeters( <line1> final NodeId nodeId, <line2> final InstanceIdentifier<FlowCapableNode> nodeIdent, <line3> final ItemSyncBox<Meter> meterRemovalPlan, <line4> final SyncCrudCounters counters) { <line5> if (meterRemovalPlan.isEmpty()) { <line6> return RpcResultBuilder.<Void>success().buildFuture(); <line7> } <line8> final CrudCounts meterCrudCounts = counters.getMeterCrudCounts(); <line9> final List<ListenableFuture<RpcResult<RemoveMeterOutput>>> allResults = new ArrayList<>(); <line10> for (Meter meter : meterRemovalPlan.getItemsToPush()) { <line11> final KeyedInstanceIdentifier<Meter, MeterKey> meterIdent = <line12> nodeIdent.child(Meter.class, meter.key()); <line13> allResults.add(meterForwarder.remove(meterIdent, meter, nodeIdent)); <line14> meterCrudCounts.incRemoved(); <line15> } <line16> return Futures.transform( <line17> Futures.allAsList(allResults), <line18> ReconcileUtil.createRpcResultCondenser(""meter remove""), <line19> MoreExecutors.directExecutor()); <line20> } <line21> } <line22> "	<line6>, <line11>
5826	public class A { <line0> private void configureTablesIfNecessary( <line1> String[] tableNames, TableOperations tops, Configuration conf, Logger log) <line2> throws AccumuloSecurityException, AccumuloException, TableNotFoundException { <line3> Map<String, TableConfigHelper> tableConfigs = getTableConfigs(log, conf, tableNames); <line4> for (String table : tableNames) { <line5> TableConfigHelper tableHelper = tableConfigs.get(table); <line6> if (tableHelper != null) { <line7> tableHelper.configure(tops); <line8> } else { <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>
5827	public class A { <line0> public void setRetryInterval(final Long retryInterval) { <line1> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line2> } <line3> hasBeenUpdated = true; <line4> this.retryInterval = retryInterval; <line5> } <line6> } <line7> 	<line2>
5828	"public class A { <line0> private String getSubdomain(String hostname) { <line1> String lowerHostName = hostname.toLowerCase(); <line2> if (defaultZoneHostnames.contains(lowerHostName)) { <line3> return """"; <line4> } <line5> for (String internalHostname : defaultZoneHostnames) { <line6> if (lowerHostName.endsWith(""."" + internalHostname)) { <line7> return lowerHostName.substring(0, lowerHostName.length() - internalHostname.length() - 1); <line8> } <line9> } <line10> if (defaultZoneHostnames.size() == 1 && defaultZoneHostnames.contains(""localhost"")) { <line11> return """"; <line12> } <line13> return null; <line14> } <line15> } <line16> "	<line11>, <line13>
5829	public class A { <line0> private void checkRelations(MassnahmenUmsetzung massnahme) { <line1> Set<CnALink> linkedPersons = new HashSet<CnALink>(); <line2> try { <line3> List<Person> personenUmsetzungDurch = getPersonsbyProperty(massnahme); <line4> Set<Property> rolesToSearch = findRole(massnahme); <line5> if (personenUmsetzungDurch != null && !personenUmsetzungDurch.isEmpty()) { <line6> for (Person person : personenUmsetzungDurch) { <line7> controlExistsLinks(massnahme, linkedPersons, rolesToSearch, person); <line8> } <line9> } else { <line10> Set<Person> linkedPersonsWithRole = new HashSet<Person>(); <line11> findLinkedPersonsUpTree(massnahme, linkedPersonsWithRole, rolesToSearch); <line12> if (!linkedPersonsWithRole.isEmpty() && linkedPersonsWithRole != null) { <line13> for (Person person : linkedPersonsWithRole) { <line14> createLinkCommand(massnahme, person, MassnahmenUmsetzung.MNUMS_RELATION_ID); <line15> } <line16> } <line17> } <line18> } catch (CommandException ce) { <line19> } <line20> } <line21> } <line22> 	<line19>
5830	public class A { <line0> @Override <line1> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <line2> throws IOException, ServletException { <line3> if (SecurityContextHolder.getContext().getAuthentication() == null) { <line4> Optional<String> authToken = <line5> BearerTokenFilterUtils.getBearerToken((HttpServletRequest) request); <line6> if (authToken.isPresent()) { <line7> try { <line8> Authentication authentication = <line9> registery <line10> .getByToken(authToken.get()) <line11> .authenticate((HttpServletRequest) request, authToken.get()); <line12> SecurityContextHolder.getContext().setAuthentication(authentication); <line13> chain.doFilter(request, response); <line14> SecurityContextHolder.getContext().setAuthentication(null); <line15> return; <line16> } catch (OAuthAuthenticationException e) { <line17> ((HttpServletResponse) response) <line18> .sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage()); <line19> return; <line20> } catch (Exception e) { <line21> ((HttpServletResponse) response) <line22> .sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage()); <line23> return; <line24> } <line25> } <line26> } <line27> chain.doFilter(request, response); <line28> } <line29> } <line30> 	<line17>, <line21>
5831	public class A { <line0> private static Properties loadFromPathIfExists(Path propertiesFilePath) { <line1> if (Files.exists(propertiesFilePath)) { <line2> try (InputStream in = Files.newInputStream(propertiesFilePath)) { <line3> Properties props = new Properties(); <line4> props.load(in); <line5> return props; <line6> } catch (Exception e) { <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	<line5>, <line7>
5832	public class A { <line0> @Override <line1> public ListType findByPrimaryKey(Serializable primaryKey) throws NoSuchListTypeException { <line2> ListType listType = fetchByPrimaryKey(primaryKey); <line3> if (listType == null) { <line4> if (_log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchListTypeException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return listType; <line9> } <line10> } <line11> 	<line5>
5833	public class A { <line0> @Override <line1> public ApiRequest deleteHost(String clusterName, String fqdn) throws AmbariApiException { <line2> Response response = null; <line3> try { <line4> response = <line5> apiResourceRootV1.getClustersResource().getHostsResource(clusterName).deleteHost(fqdn); <line6> } catch (Exception e) { <line7> throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e); <line8> } <line9> String deleteHostJson = handleAmbariResponse(response); <line10> return ApiUtils.jsonToObject(ApiRequest.class, deleteHostJson); <line11> } <line12> } <line13> 	<line2>
5834	"public class A { <line0> private MCRDerivate createDerivate( <line1> MCRObjectID objectID, List<MCRMetaClassification> classifications) <line2> throws MCRPersistenceException, MCRAccessException { <line3> MCRObjectID derivateID = getNewCreateDerivateID(objectID); <line4> MCRDerivate derivate = new MCRDerivate(); <line5> derivate.setId(derivateID); <line6> derivate.getDerivate().getClassifications().addAll(classifications); <line7> String schema = <line8> MCRConfiguration2.getString(""MCR.Metadata.Config.derivate"") <line9> .orElse(""datamodel-derivate.xml"") <line10> .replaceAll("".xml"", "".xsd""); <line11> derivate.setSchema(schema); <line12> MCRMetaLinkID linkId = new MCRMetaLinkID(); <line13> linkId.setSubTag(""linkmeta""); <line14> linkId.setReference(objectID, null, null); <line15> derivate.getDerivate().setLinkMeta(linkId); <line16> MCRMetaIFS ifs = new MCRMetaIFS(); <line17> ifs.setSubTag(""internal""); <line18> ifs.setSourcePath(null); <line19> derivate.getDerivate().setInternals(ifs); <line20> MCRMetadataManager.create(derivate); <line21> setDefaultPermissions(derivateID); <line22> return derivate; <line23> } <line24> } <line25> "	<line20>
5835	public class A { <line0> @Override <line1> @Transactional <line2> public boolean pruneData(OrganisationUnit organisationUnit) { <line3> User user = currentUserService.getCurrentUser(); <line4> if (user == null || !user.isSuper()) { <line5> return false; <line6> } <line7> dataApprovalService.deleteDataApprovals(organisationUnit); <line8> dataApprovalAuditService.deleteDataApprovalAudits(organisationUnit); <line9> completeRegistrationService.deleteCompleteDataSetRegistrations(organisationUnit); <line10> dataValueAuditService.deleteDataValueAudits(organisationUnit); <line11> dataValueService.deleteDataValues(organisationUnit); <line12> return true; <line13> } <line14> } <line15> 	<line12>
5836	public class A { <line0> @Override <line1> public boolean canImport(URL url, DropLocation dropLocation) { <line2> ServerProvider<HttpServer> provider = <line3> myController.getToolbox().getServerProviderRegistry().getProvider(HttpServer.class); <line4> ResponseValues response = new ResponseValues(); <line5> try (InputStream inputStream = provider.getServer(url).sendGet(url, response)) { <line6> if (response.getResponseCode() != HttpURLConnection.HTTP_OK) { <line7> return false; <line8> } <line9> int in = 0; <line10> int total = 0; <line11> DataInputStream dataStream = new DataInputStream(inputStream); <line12> try { <line13> for (int i = 0; i < 10000; ++i) { <line14> ++total; <line15> if (isOrdinaryCharacter(dataStream.readByte())) { <line16> ++in; <line17> } <line18> } <line19> } catch (EOFException e) { <line20> } <line21> double tolerance = (10 - .5) / 10; <line22> return in / (double) total > tolerance; <line23> } catch (IOException | URISyntaxException e) { <line24> } <line25> return false; <line26> } <line27> } <line28> 	<line20>, <line24>
5837	"public class A { <line0> public synchronized String waitWarrantBlockChange(@Nonnull Warrant warrant) { <line1> if (!inThread) { <line2> } <line3> if (log.isDebugEnabled()) { <line4> } <line5> if (warrant.getRunMode() != Warrant.MODE_RUN) { <line6> return null; <line7> } <line8> blockName = null; <line9> blockChanged = false; <line10> PropertyChangeListener listener; <line11> warrant.addPropertyChangeListener( <line12> listener = <line13> (PropertyChangeEvent e) -> { <line14> if (e.getPropertyName().equals(""blockChange"")) { <line15> blockChanged = true; <line16> blockName = ((OBlock) e.getNewValue()).getDisplayName(); <line17> } <line18> if (e.getPropertyName().equals(""runMode"") <line19> && !Integer.valueOf(Warrant.MODE_RUN).equals(e.getNewValue())) { <line20> blockName = null; <line21> blockChanged = true; <line22> } <line23> synchronized (self) { <line24> self.notifyAll(); <line25> } <line26> }); <line27> while (!blockChanged) { <line28> wait(-1); <line29> } <line30> warrant.removePropertyChangeListener(listener); <line31> return blockName; <line32> } <line33> } <line34> "	<line2>, <line4>, <line6>, <line24>
5838	public class A { <line0> private Observable<ResourceResponse<Permission>> upsertPermissionInternal( <line1> String userLink, <line2> Permission permission, <line3> RequestOptions options, <line4> IDocumentClientRetryPolicy retryPolicyInstance) { <line5> try { <line6> RxDocumentServiceRequest request = <line7> getPermissionRequest(userLink, permission, options, OperationType.Upsert); <line8> if (retryPolicyInstance != null) { <line9> retryPolicyInstance.onBeforeSendRequest(request); <line10> } <line11> return this.upsert(request).map(response -> toResourceResponse(response, Permission.class)); <line12> } catch (Exception e) { <line13> } <line14> } <line15> } <line16> 	<line6>, <line13>
5839	public class A { <line0> protected void deleteFinishedUnreleasedSqlFile(List<File> unreleasedSqlFileList) { <line1> for (File unreleasedSqlFile : unreleasedSqlFileList) { <line2> if (unreleasedSqlFile.exists()) { <line3> unreleasedSqlFile.delete(); <line4> } <line5> } <line6> } <line7> } <line8> 	<line1>
5840	public class A { <line0> @Override <line1> public UUID fromBytes(Class targetClass, byte[] bytes) throws PropertyAccessException { <line2> try { <line3> if (bytes == null) { <line4> return null; <line5> } <line6> long msb = 0; <line7> long lsb = 0; <line8> for (int i = 0; i < 8; i++) msb = (msb << 8) | (bytes[i] & 0xff); <line9> for (int i = 8; i < 16; i++) lsb = (lsb << 8) | (bytes[i] & 0xff); <line10> return new UUID(msb, lsb); <line11> } catch (Exception e) { <line12> throw new PropertyAccessException(e); <line13> } <line14> } <line15> } <line16> 	<line12>
5841	"public class A { <line0> public DataSource getTargetDataSource( <line1> AugmentedRow augmentedRow, Put put, String table, List<String> updatedColumns) { <line2> Object targetDataSource = <line3> configuration.getOrDefault( <line4> ValidationService.Configuration.VALIDATION_TARGET_DATA_SOURCE, null); <line5> String row = null; <line6> String cf = null; <line7> try { <line8> row = URLEncoder.encode(Bytes.toStringBinary(put.getRow()), UTF8); <line9> cf = URLEncoder.encode(Bytes.toString(CF), UTF8); <line10> } catch (UnsupportedEncodingException e) { <line11> } <line12> return targetDataSource == null <line13> || row == null <line14> || cf == null <line15> || put.has(CF, Bytes.toBytes(""row_status""), Bytes.toBytes(""D"")) <line16> || updatedColumns.isEmpty() <line17> ? null <line18> : new DataSource( <line19> (String) targetDataSource, <line20> new BigtableQueryOptions(table, row, cf, getTargetTransformations(updatedColumns))); <line21> } <line22> } <line23> "	<line11>
5842	public class A { <line0> private SyntheticRunResult runJavaInternal( <line1> Constructor<?> defaultConstructor, Method testMethod, Object testArg, long startTick) <line2> throws Exception { <line3> long captureTime; <line4> long durationNanos; <line5> try { <line6> testMethod.invoke(defaultConstructor.newInstance(), testArg); <line7> captureTime = clock.currentTimeMillis(); <line8> durationNanos = ticker.read() - startTick; <line9> } catch (InvocationTargetException e) { <line10> Throwable throwable = e.getTargetException(); <line11> if (throwable instanceof InterruptedException) { <line12> throw (InterruptedException) throwable; <line13> } <line14> return ImmutableSyntheticRunResult.builder() <line15> .captureTime(clock.currentTimeMillis()) <line16> .durationNanos(ticker.read() - startTick) <line17> .throwable(throwable) <line18> .build(); <line19> } finally { <line20> if (testArg instanceof JBrowserDriver) { <line21> ((JBrowserDriver) testArg).kill(); <line22> } <line23> } <line24> return ImmutableSyntheticRunResult.builder() <line25> .captureTime(captureTime) <line26> .durationNanos(durationNanos) <line27> .build(); <line28> } <line29> } <line30> 	<line10>
5843	public class A { <line0> protected synchronized boolean channelExist(String channel) { <line1> connect(redisServerAddress.getHost(), redisServerAddress.getPort()); <line2> pubsubNumsub(channel.getBytes()); <line3> boolean exist = false; <line4> try { <line5> exist = (readPubsubNumsubReply(channel) > 0) ? true : false; <line6> } catch (ProtocolException e) { <line7> } <line8> return exist; <line9> } <line10> } <line11> 	<line7>
5844	"public class A { <line0> private String getFileContents(String file) { <line1> InputStream is = RequireJsSupport.class.getResourceAsStream(file); <line2> if (is != null) { <line3> try { <line4> return IOUtils.toString(is); <line5> } catch (IOException e) { <line6> } <line7> return """"; <line8> } <line9> } <line10> "	<line6>, <line7>
5845	"public class A { <line0> protected Document createDocument(Account owner, Document srcDocument, String fileName) <line1> throws BusinessException { <line2> boolean createIt = false; <line3> Document document = null; <line4> List<Document> documents = documentRepository.findBySha256Sum(srcDocument.getSha256sum()); <line5> if (documents.isEmpty() || !deduplication) { <line6> createIt = true; <line7> } else { <line8> document = documents.get(0); <line9> if (!fileDataStore.exists(new FileMetaData(FileMetaDataKind.DATA, document))) { <line10> createIt = true; <line11> } <line12> } <line13> if (createIt) { <line14> FileMetaData metadataSrc = new FileMetaData(FileMetaDataKind.DATA, srcDocument); <line15> FileMetaData metadata = <line16> new FileMetaData( <line17> FileMetaDataKind.DATA, srcDocument.getType(), srcDocument.getSize(), fileName); <line18> ByteSource byteSource = fileDataStore.get(metadataSrc); <line19> try { <line20> metadata = fileDataStore.add(byteSource, metadata); <line21> } catch (IOException e1) { <line22> throw new BusinessException(""Can not create a copy of existing document.""); <line23> } <line24> Map<ThumbnailType, FileMetaData> fileMetaDataThumbnail = <line25> copyThumbnail(srcDocument, owner, metadata); <line26> try { <line27> document = new Document(metadata); <line28> document.setSha256sum(srcDocument.getSha256sum()); <line29> document.setSha1sum(srcDocument.getSha1sum()); <line30> document.setHasThumbnail(false); <line31> Map<ThumbnailType, Thumbnail> fileThumbnails = <line32> toFileThumbnail(document, fileMetaDataThumbnail); <line33> if (!fileThumbnails.isEmpty()) { <line34> document.setHasThumbnail(true); <line35> document.setThumbnails(fileThumbnails); <line36> } <line37> document = documentRepository.create(document); <line38> } catch (BusinessException e) { <line39> if (metadata != null) fileDataStore.remove(metadata); <line40> if (!fileMetaDataThumbnail.isEmpty()) { <line41> for (Map.Entry<ThumbnailType, FileMetaData> entry : fileMetaDataThumbnail.entrySet()) { <line42> if (entry.getValue() != null) { <line43> removeMetadata(entry.getValue()); <line44> } <line45> } <line46> } <line47> } <line48> } <line49> return document; <line50> } <line51> } <line52> "	<line22>
5846	public class A { <line0> private boolean checkCertificateSan(X509Certificate cert, String hostName) { <line1> boolean valid = false; <line2> Collection<List<?>> sanRecords; <line3> try { <line4> sanRecords = cert.getSubjectAlternativeNames(); <line5> } catch (CertificateParsingException ex) { <line6> sanRecords = null; <line7> } <line8> if (sanRecords != null) { <line9> valid = <line10> sanRecords.stream() <line11> .filter(record -> ((Integer) record.get(0)) == 2 || ((Integer) record.get(0)) == 7) <line12> .anyMatch(record -> hostName.equals((String) record.get(1))); <line13> } <line14> if (!valid) { <line15> AuditLogable event = new AuditLogableImpl(); <line16> event.setVdsName(hostName); <line17> auditLogDirector.log(event, AuditLogType.HOST_CERTIFICATE_HAS_INVALID_SAN); <line18> } <line19> return valid; <line20> } <line21> } <line22> 	<line6>
5847	public class A { <line0> private void log( <line1> final LogMessage.Stream stream, <line2> final String containerId, <line3> final JobId jobId, <line4> final StringBuilder stringBuilder) { <line5> stringBuilder.setLength(0); <line6> } <line7> } <line8> 	<line5>
5848	public class A { <line0> private static MemorySize capToMinMax( <line1> String memoryDescription, MemorySize relative, RangeFraction rangeFraction) { <line2> long size = relative.getBytes(); <line3> if (size > rangeFraction.getMaxSize().getBytes()) { <line4> size = rangeFraction.getMaxSize().getBytes(); <line5> } else if (size < rangeFraction.getMinSize().getBytes()) { <line6> size = rangeFraction.getMinSize().getBytes(); <line7> } <line8> return new MemorySize(size); <line9> } <line10> } <line11> 	<line4>, <line6>
5849	public class A { <line0> @Override <line1> public boolean isVisible(User user, CommerceBOMFolder commerceBOMFolder) { <line2> PermissionChecker permissionChecker = PermissionThreadLocal.getPermissionChecker(); <line3> try { <line4> if (commerceBOMFolder == null) { <line5> PortletResourcePermission portletResourcePermission = <line6> _commerceBOMFolderModelResourcePermission.getPortletResourcePermission(); <line7> return portletResourcePermission.contains( <line8> permissionChecker, null, CommerceBOMActionKeys.ADD_COMMERCE_BOM_FOLDER); <line9> } <line10> return _commerceBOMFolderModelResourcePermission.contains( <line11> permissionChecker, commerceBOMFolder, ActionKeys.UPDATE); <line12> } catch (PortalException portalException) { <line13> } <line14> return false; <line15> } <line16> } <line17> 	<line13>
5850	public class A { <line0> public void moveTo(double topStom, double midStom, double lowStom) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> this.topStom.moveTo(topStom); <line4> this.midStom.moveTo(midStom); <line5> this.lowStom.moveTo(lowStom); <line6> } <line7> } <line8> 	<line2>
5851	public class A { <line0> @Override <line1> public void tagStyleChanged(TagStyleEvent e) { <line2> try { <line3> PluginTagStyleEvent event = createTagStyleEvent(e); <line4> for (PluginTagStyleListener listener : tagStyleListeners) { <line5> try { <line6> listener.tagStyleChanged(event); <line7> } catch (Exception ex) { <line8> } <line9> } <line10> } catch (Exception ex) { <line11> } <line12> } <line13> } <line14> 	<line8>, <line11>
5852	public class A { <line0> @Override <line1> public void onNext(ResT response) { <line2> if (retryScheduler.isSuccess(response)) { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> } else { <line6> if (logger.isInfoEnabled()) { <line7> } <line8> retryScheduler.scheduleNextRetry(message, nextRetryCount()); <line9> } <line10> } <line11> } <line12> 	<line4>, <line7>
5853	"public class A { <line0> private boolean shouldRetryImmediately( <line1> SingularityRequest request, <line2> SingularityDeployStatistics deployStatistics, <line3> Optional<SingularityTask> task) { <line4> if (!request.getNumRetriesOnFailure().isPresent()) { <line5> return false; <line6> } <line7> if (task.isPresent()) { <line8> if (task.get().getTaskRequest().getPendingTask().getPendingTaskId().getPendingType() <line9> == PendingType.IMMEDIATE <line10> && request.getRequestType() == RequestType.SCHEDULED) { <line11> return false; <line12> } <line13> Optional<SingularityTaskHistoryUpdate> taskHistoryUpdate = <line14> taskManager.getTaskHistoryUpdate(task.get().getTaskId(), ExtendedTaskState.TASK_CLEANING); <line15> if (taskHistoryUpdate.isPresent() <line16> && request.getRequestType() == RequestType.ON_DEMAND <line17> && Stream.of(""USER_REQUESTED"", ""PAUSE"") <line18> .anyMatch( <line19> cleaningReason -> <line20> taskHistoryUpdate <line21> .get() <line22> .getStatusMessage() <line23> .orElse("""") <line24> .contains(cleaningReason))) { <line25> return false; <line26> } <line27> } <line28> final int numRetriesInARow = deployStatistics.getNumSequentialRetries(); <line29> if (numRetriesInARow >= request.getNumRetriesOnFailure().get()) { <line30> return false; <line31> } <line32> return true; <line33> } <line34> } <line35> "	<line30>, <line32>
5854	public class A { <line0> private void warnFragmented( <line1> ByteBuffer buffer, int iterations, AtomicInteger counter, String operation) { <line2> int total = counter.incrementAndGet(); <line3> } <line4> } <line5> 	<line3>
5855	public class A { <line0> public PreparedCommand buildCommand( <line1> MetaCommand mc, List<ArgumentAssignment> argAssignmentList, String origin, int seq, User user) <line2> throws ErrorInCommand, YamcsException { <line3> CommandBuildResult cbr = metaCommandProcessor.buildCommand(mc, argAssignmentList); <line4> CommandId cmdId = <line5> CommandId.newBuilder() <line6> .setCommandName(mc.getQualifiedName()) <line7> .setOrigin(origin) <line8> .setSequenceNumber(seq) <line9> .setGenerationTime(processor.getCurrentTime()) <line10> .build(); <line11> PreparedCommand pc = new PreparedCommand(cmdId); <line12> pc.setMetaCommand(mc); <line13> pc.setBinary(cbr.getCmdPacket()); <line14> pc.setUsername(user.getName()); <line15> Set<String> userAssignedArgumentNames = <line16> argAssignmentList.stream().map(a -> a.getArgumentName()).collect(Collectors.toSet()); <line17> pc.setArgAssignment(cbr.getArgs(), userAssignedArgumentNames); <line18> return pc; <line19> } <line20> } <line21> 	<line3>
5856	"public class A { <line0> public void init() { <line1> String methodName = ""init""; <line2> } <line3> } <line4> "	<line2>
5857	public class A { <line0> private void scheduleClockSyncJob() { <line1> cancelClockSyncJob(); <line2> clockSyncJob = <line3> scheduler.scheduleWithFixedDelay( <line4> () -> { <line5> if (this.isGConcerto) { <line6> try { <line7> connector.sendCommand( <line8> NuvoCommand.CFGTIME.getValue() + DATE_FORMAT.format(new Date())); <line9> } catch (NuvoException e) { <line10> } <line11> } else { <line12> this.cancelClockSyncJob(); <line13> } <line14> }, <line15> INITIAL_CLOCK_SYNC_DELAY_SEC, <line16> CLOCK_SYNC_INTERVAL_SEC, <line17> TimeUnit.SECONDS); <line18> } <line19> } <line20> 	<line1>, <line10>
5858	"public class A { <line0> @Override <line1> public List<WeatherInfo> getWeatherInfo(double latitude, double longitude, String date) { <line2> City closestCity = getClosestCity(latitude, longitude); <line3> List<WeatherInfo> weather = <line4> JPAUtils.find( <line5> em, WeatherInfo.class, ""weather.byDateAndCity.between"", closestCity.geo_name, date); <line6> if (weather != null && weather.size() > 0) { <line7> addIcons(weather); <line8> return weather; <line9> } else { <line10> try { <line11> fetchWeatherInfo(latitude, longitude, closestCity.geo_name, date); <line12> } catch (Exception e) { <line13> } <line14> weather = <line15> JPAUtils.find( <line16> em, WeatherInfo.class, ""weather.byDateAndCity.between"", closestCity.geo_name, date); <line17> addIcons(weather); <line18> } <line19> return weather; <line20> } <line21> } <line22> "	<line13>
5859	public class A { <line0> @Override <line1> protected void onEvent(org.apache.stratos.messaging.event.Event event) { <line2> AverageMemoryConsumptionEvent averageMemoryConsumptionEvent = <line3> (AverageMemoryConsumptionEvent) event; <line4> String clusterId = averageMemoryConsumptionEvent.getClusterId(); <line5> AutoscalerContext asCtx = AutoscalerContext.getInstance(); <line6> ClusterMonitor monitor; <line7> monitor = asCtx.getClusterMonitor(clusterId); <line8> if (null == monitor) { <line9> if (log.isDebugEnabled()) { <line10> } <line11> return; <line12> } <line13> monitor.handleAverageMemoryConsumptionEvent(averageMemoryConsumptionEvent); <line14> } <line15> } <line16> 	<line10>
5860	public class A { <line0> @Override <line1> public void channelActive(ChannelHandlerContext ctx) throws Exception { <line2> if (debugEnabled) { <line3> } <line4> setState(LifecycleState.CONNECTED); <line5> tracedEndpoint = clientResources.tracing().createEndpoint(ctx.channel().remoteAddress()); <line6> endpoint.notifyChannelActive(ctx.channel()); <line7> super.channelActive(ctx); <line8> if (debugEnabled) { <line9> } <line10> } <line11> } <line12> 	<line3>, <line9>
5861	"public class A { <line0> protected Response getPort(String nodeId, String portId) { <line1> Port port = topology.getPort(nodeId, portId); <line2> if (port == null) { <line3> return createErrorResponse(Response.NOT_FOUND, null, ""node_id not found""); <line4> } <line5> return new Response(Response.OK, port); <line6> } <line7> } <line8> "	<line1>
5862	"public class A { <line0> public <T extends TBase> RequestStatus update(T element) { <line1> if (element == null) { <line2> return RequestStatus.FAILURE; <line3> } <line4> try { <line5> if (Vulnerability.class.isAssignableFrom(element.getClass())) { <line6> vulRepo.update(VulnerabilityMapper.setLastUpdate((Vulnerability) element)); <line7> } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass())) { <line8> relationRepo.update((ReleaseVulnerabilityRelation) element); <line9> } else { <line10> throw new IllegalArgumentException(""unknown type "" + element.getClass().getSimpleName()); <line11> } <line12> return RequestStatus.SUCCESS; <line13> } catch (Exception e) { <line14> return RequestStatus.FAILURE; <line15> } <line16> } <line17> } <line18> "	<line2>, <line14>
5863	public class A { <line0> public static <T> String asId(String prefix, Class<T> clazz, String suffix) { <line1> String id; <line2> if (clazz == null) { <line3> id = DOM.createUniqueId(); <line4> return id; <line5> } else { <line6> id = clazz.getName(); <line7> int lastDot = id.lastIndexOf('.'); <line8> if (lastDot != -1 && lastDot != id.length() - 1) { <line9> id = id.substring(lastDot + 1); <line10> } <line11> id = id.replace('$', '_'); <line12> } <line13> id = prefix != null ? prefix + id : id; <line14> return suffix != null ? id + suffix : id; <line15> } <line16> } <line17> 	<line4>
5864	"public class A { <line0> private boolean isRequiredTimeZone(String actualTZ, String expextedTZ) { <line1> boolean res = actualTZ.equals(expextedTZ); <line2> if (!res) { <line3> String[] actTZ = actualTZ.split(""/""); <line4> String lastActTZ = actTZ[actTZ.length - 1]; <line5> String[] timeZoneTZ = expextedTZ.split(""/""); <line6> String lastTimeZoneTZ = timeZoneTZ[timeZoneTZ.length - 1]; <line7> res = lastActTZ.equals(lastTimeZoneTZ); <line8> } <line9> return res; <line10> } <line11> } <line12> "	<line7>
5865	public class A { <line0> @Override <line1> public ConnectionStatus deviceConnected(final ConnectionContext connectionContext) { <line2> final DeviceInfo deviceInfo = connectionContext.getDeviceInfo(); <line3> final ContextChain contextChain = contextChainMap.get(deviceInfo); <line4> final FeaturesReply featuresReply = connectionContext.getFeatures(); <line5> final Uint8 auxiliaryId = featuresReply != null ? featuresReply.getAuxiliaryId() : null; <line6> if (auxiliaryId != null && auxiliaryId.toJava() != 0) { <line7> if (contextChain == null) { <line8> return ConnectionStatus.REFUSING_AUXILIARY_CONNECTION; <line9> } else { <line10> if (contextChain.addAuxiliaryConnection(connectionContext)) { <line11> return ConnectionStatus.MAY_CONTINUE; <line12> } else { <line13> return ConnectionStatus.REFUSING_AUXILIARY_CONNECTION; <line14> } <line15> } <line16> } else { <line17> final boolean contextExists = contextChain != null; <line18> final boolean isClosing = contextExists && contextChain.isClosing(); <line19> if (!isClosing && connectingDevices.putIfAbsent(deviceInfo, connectionContext) != null) { <line20> return ConnectionStatus.ALREADY_CONNECTED; <line21> } <line22> if (contextExists) { <line23> if (isClosing) { <line24> return ConnectionStatus.CLOSING; <line25> } <line26> destroyContextChain(deviceInfo); <line27> createContextChain(connectionContext); <line28> } else { <line29> createContextChain(connectionContext); <line30> } <line31> return ConnectionStatus.MAY_CONTINUE; <line32> } <line33> } <line34> } <line35> 	<line8>, <line11>, <line13>, <line17>, <line20>, <line24>, <line26>, <line27>, <line29>
5866	public class A { <line0> @Override <line1> public boolean removeRepository(String repositoryID) <line2> throws RepositoryException, RepositoryConfigException { <line3> boolean existingRepo = hasRepositoryConfig(repositoryID); <line4> if (existingRepo) { <line5> try (RDF4JProtocolSession protocolSession = <line6> getSharedHttpClientSessionManager().createRDF4JProtocolSession(serverURL)) { <line7> protocolSession.setUsernameAndPassword(username, password); <line8> protocolSession.deleteRepository(repositoryID); <line9> } catch (IOException e) { <line10> throw new RepositoryConfigException(e); <line11> } <line12> } <line13> return existingRepo; <line14> } <line15> } <line16> 	<line10>
5867	"public class A { <line0> @Override <line1> public List<AssetEntry> getInfoList( <line2> InfoListProviderContext infoListProviderContext, Pagination pagination, Sort sort) { <line3> long assetEntryId = _getLayoutAssetEntryId(); <line4> if (assetEntryId == 0) { <line5> return Collections.emptyList(); <line6> } <line7> AssetEntryQuery assetEntryQuery = <line8> getAssetEntryQuery(infoListProviderContext, Field.MODIFIED_DATE, ""DESC"", pagination); <line9> assetEntryQuery.setLinkedAssetEntryId(assetEntryId); <line10> try { <line11> return _assetEntryService.getEntries(assetEntryQuery); <line12> } catch (Exception exception) { <line13> } <line14> return Collections.emptyList(); <line15> } <line16> } <line17> "	<line13>
5868	"public class A { <line0> @Override <line1> public Optional<Page> getGroupPage(String groupId, String pageUrl) throws IOException { <line2> String encodedUrl = URLEncoder.encode(pageUrl, CanvasConstants.URLENCODING_TYPE); <line3> String url = <line4> buildCanvasUrl(""groups/"" + groupId + ""/pages/"" + encodedUrl, Collections.emptyMap()); <line5> Response response = canvasMessenger.getSingleResponseFromCanvas(oauthToken, url); <line6> return responseParser.parseToObject(Page.class, response); <line7> } <line8> } <line9> "	<line2>
5869	"public class A { <line0> public Message getWithoutAck(int batchSize, Long timeout, TimeUnit unit) <line1> throws CanalClientException { <line2> int times = 0; <line3> while (times < retryTimes) { <line4> try { <line5> Message msg = currentConnector.getWithoutAck(batchSize, timeout, unit); <line6> return msg; <line7> } catch (Throwable t) { <line8> times++; <line9> restart(); <line10> } <line11> } <line12> throw new CanalClientException(""failed to fetch the data after "" + times + "" times retry""); <line13> } <line14> } <line15> "	<line8>, <line10>
5870	public class A { <line0> private SendStatus sendMessage(DatagramPacket msg) <line1> throws IncompatibleConnectionException, GeneralSecurityException, IOException { <line2> if (getNumberOfQueuedMessages() > 0) { <line3> spoolMessage(msg); <line4> scheduleRetry(); <line5> } else { <line6> try { <line7> activeConnection().sendMessage(msg); <line8> lastSentTimeInMillis = System.currentTimeMillis(); <line9> return SendStatus.SENT; <line10> } catch (IOException e) { <line11> lastException = e; <line12> if (retryInterval > 0) { <line13> spoolMessage(msg); <line14> scheduleRetry(); <line15> } else { <line16> throw e; <line17> } <line18> } <line19> } <line20> return SendStatus.QUEUED; <line21> } <line22> } <line23> 	<line13>
5871	public class A { <line0> @Override <line1> public synchronized void init(HiveConf hiveConf) { <line2> ml = new LensMLImpl(hiveConf); <line3> ml.init(hiveConf); <line4> super.init(hiveConf); <line5> serviceProviderFactory = getServiceProviderFactory(hiveConf); <line6> } <line7> } <line8> 	<line6>
5872	public class A { <line0> @Override <line1> public void onMode(String string, IRCUser ircUser, IRCModeParser ircModeParser) { <line2> super.onMode(string, ircUser, ircModeParser); <line3> } <line4> } <line5> 	<line3>
5873	public class A { <line0> @Override <line1> public ClientCQ[] getCqs() { <line2> preOp(); <line3> ClientCQ[] cqs = null; <line4> try { <line5> ArrayList<InternalCqQuery> cqList = new ArrayList<InternalCqQuery>(); <line6> for (String name : this.cqNames) { <line7> cqList.add(((DefaultQueryService) realQueryService).getCqService().getCq(name)); <line8> } <line9> cqs = new ClientCQ[cqList.size()]; <line10> cqList.toArray(cqs); <line11> } catch (CqException cqe) { <line12> if (logger.isDebugEnabled()) { <line13> } <line14> } <line15> return cqs; <line16> } <line17> } <line18> 	<line13>
5874	"public class A { <line0> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <line1> throws IOException, ServletException { <line2> HttpSession session = ((HttpServletRequest) request).getSession(true); <line3> if (session != null) { <line4> session.setAttribute(""user"", ""999998""); <line5> } else { <line6> } <line7> chain.doFilter(request, response); <line8> } <line9> } <line10> "	<line6>
5875	public class A { <line0> @Nonnull <line1> private List<StdArrangementMatchRule> deserializeRules( <line2> @Nonnull Element element, @Nullable final Set<StdArrangementRuleAliasToken> aliases) { <line3> if (aliases != null && myMixin instanceof MutableMixin) { <line4> ((MutableMixin) myMixin).setMyRuleAliases(aliases); <line5> } <line6> final List<StdArrangementMatchRule> rules = new ArrayList<StdArrangementMatchRule>(); <line7> for (Object o : element.getChildren(RULE_ELEMENT_NAME)) { <line8> Element ruleElement = (Element) o; <line9> Element matcherElement = ruleElement.getChild(MATCHER_ELEMENT_NAME); <line10> if (matcherElement == null) { <line11> continue; <line12> } <line13> StdArrangementEntryMatcher matcher = null; <line14> for (Object c : matcherElement.getChildren()) { <line15> matcher = myMatcherSerializer.deserialize((Element) c); <line16> if (matcher != null) { <line17> break; <line18> } <line19> } <line20> if (matcher == null) { <line21> return ContainerUtil.newSmartList(); <line22> } <line23> Element orderTypeElement = ruleElement.getChild(ORDER_TYPE_ELEMENT_NAME); <line24> ArrangementSettingsToken orderType = null; <line25> if (orderTypeElement != null) { <line26> String orderTypeId = orderTypeElement.getText(); <line27> orderType = StdArrangementTokens.byId(orderTypeId); <line28> if (orderType == null) { <line29> orderType = myMixin.deserializeToken(orderTypeId); <line30> } <line31> if (orderType == null) { <line32> } <line33> } <line34> if (orderType == null) { <line35> orderType = ArrangementMatchRule.DEFAULT_ORDER_TYPE; <line36> } <line37> rules.add(new StdArrangementMatchRule(matcher, orderType)); <line38> } <line39> return rules; <line40> } <line41> } <line42> 	<line32>
5876	public class A { <line0> public void requestHostsUpdate() { <line1> try { <line2> spawnMQ.sendControlMessage(new HostState(HostMessage.ALL_HOSTS)); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	<line4>
5877	"public class A { <line0> private void initiateLocalAbortForTest(final DistributionManager dm) { <line1> if (!dm.getSystem().isDisconnecting()) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> Thread disconnectThread = <line5> new LoggingThread( <line6> ""InitialImageOperation abortTest Thread"", () -> dm.getSystem().disconnect()); <line7> disconnectThread.start(); <line8> } <line9> } <line10> } <line11> "	<line3>
5878	public class A { <line0> private void complete( <line1> TableName tableName, LocateRequest req, RegionLocations locs, Throwable error) { <line2> if (error != null) { <line3> } <line4> Optional<LocateRequest> toSend = Optional.empty(); <line5> TableCache tableCache = getTableCache(tableName); <line6> if (locs != null) { <line7> RegionLocations addedLocs = addToCache(tableCache, locs); <line8> synchronized (tableCache) { <line9> tableCache.pendingRequests.remove(req); <line10> tableCache.clearCompletedRequests(addedLocs); <line11> toSend = tableCache.getCandidate(); <line12> toSend.ifPresent(r -> tableCache.send(r)); <line13> } <line14> toSend.ifPresent(r -> locateInMeta(tableName, r)); <line15> } else { <line16> assert error != null; <line17> synchronized (tableCache) { <line18> tableCache.pendingRequests.remove(req); <line19> CompletableFuture<?> future = tableCache.allRequests.remove(req); <line20> if (future != null) { <line21> future.completeExceptionally(error); <line22> } <line23> tableCache.clearCompletedRequests(null); <line24> toSend = tableCache.getCandidate(); <line25> toSend.ifPresent(r -> tableCache.send(r)); <line26> } <line27> toSend.ifPresent(r -> locateInMeta(tableName, r)); <line28> } <line29> } <line30> } <line31> 	<line3>
5879	public class A { <line0> public static int getCommerceNotificationQueueEntriesCount(long groupId) throws RemoteException { <line1> try { <line2> int returnValue = <line3> CommerceNotificationQueueEntryServiceUtil.getCommerceNotificationQueueEntriesCount( <line4> groupId); <line5> return returnValue; <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>
5880	public class A { <line0> @Override <line1> public void receivedAsynchronousCommand(ZToolPacket packet) { <line2> if (packet.isError()) { <line3> return; <line4> } <line5> if (packet.getCMD().get16BitValue() == ZToolCMD.AF_INCOMING_MSG) { <line6> AF_INCOMING_MSG msg = (AF_INCOMING_MSG) packet; <line7> if (listeners.isEmpty()) { <line8> } else { <line9> } <line10> ArrayList<ApplicationFrameworkMessageListener> localCopy; <line11> synchronized (listeners) { <line12> localCopy = new ArrayList<ApplicationFrameworkMessageListener>(listeners); <line13> } <line14> for (ApplicationFrameworkMessageListener listener : localCopy) { <line15> try { <line16> listener.notify(msg); <line17> } catch (final Exception e) { <line18> } <line19> } <line20> } <line21> } <line22> } <line23> 	<line8>, <line9>, <line18>
5881	"public class A { <line0> public String search() { <line1> if (this.oldSearchPattern != null <line2> && StringUtils.equals(this.searchPattern, this.oldSearchPattern)) <line3> return OxTrustConstants.RESULT_SUCCESS; <line4> try { <line5> List<RadiusClient> radiusclients = null; <line6> if (searchPattern == null || searchPattern.isEmpty()) { <line7> radiusclients = gluuRadiusClientService.getAllClients(100); <line8> } else { <line9> radiusclients = gluuRadiusClientService.searchClients(searchPattern, 100); <line10> } <line11> radiusclients.sort(Comparator.comparing(RadiusClient::getName)); <line12> this.results.clear(); <line13> for (RadiusClient radiusclient : radiusclients) { <line14> this.results.add(new SelectableEntity<RadiusClient>(radiusclient)); <line15> } <line16> this.oldSearchPattern = this.searchPattern; <line17> this.searchPattern = """"; <line18> } catch (Exception e) { <line19> facesMessages.add(FacesMessage.SEVERITY_ERROR, ""#{msgs['radius.clients.search.error']}""); <line20> conversationService.endConversation(); <line21> return OxTrustConstants.RESULT_FAILURE; <line22> } <line23> return OxTrustConstants.RESULT_SUCCESS; <line24> } <line25> } <line26> "	<line19>
5882	public class A { <line0> @Override <line1> public void getOAuthAccessTokenAsync(final String screenName, final String password) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(OAUTH_ACCESS_TOKEN, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> AccessToken token = twitter.getOAuthAccessToken(screenName, password); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotOAuthAccessToken(token); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	<line12>
5883	public class A { <line0> @Override <line1> public boolean isSupportedMethod(IMethodContext dataObject) { <line2> IModel<?> model = dataObject.getDisplayObjectModel(); <line3> try { <line4> if (model != null && model.getObject() != null && model.getObject() instanceof ODocument) { <line5> OClass schemaClass = ((ODocument) (model.getObject())).getSchemaClass(); <line6> return schemaClass != null ? schemaClass.isSubClassOf(this.filterData) : false; <line7> } <line8> } catch (Exception e) { <line9> } <line10> return false; <line11> } <line12> } <line13> 	<line9>
5884	public class A { <line0> private WifiMode getWifiInterfaceMode(WifiInterfaceConfigImpl wifiInterfaceConfig) { <line1> WifiMode wifiMode = WifiMode.UNKNOWN; <line2> WifiInterfaceAddressConfig wifiInterfaceAddressConfig; <line3> try { <line4> wifiInterfaceAddressConfig = <line5> (WifiInterfaceAddressConfig) <line6> ((AbstractNetInterface<?>) wifiInterfaceConfig).getNetInterfaceAddressConfig(); <line7> wifiMode = wifiInterfaceAddressConfig.getMode(); <line8> } catch (KuraException e) { <line9> } <line10> return wifiMode; <line11> } <line12> } <line13> 	<line9>
5885	"public class A { <line0> public static EDLController createEDLController( <line1> EDocLiteAssociation edlAssociation, EDLGlobalConfig edlGlobalConfig) { <line2> EDLController edlController = new EDLController(); <line3> edlController.setEdocLiteAssociation(edlAssociation); <line4> edlController.setEdlContext(getPreEDLContext(edlController)); <line5> try { <line6> edlController.setEdlGlobalConfig(edlGlobalConfig); <line7> edlController.setDefaultDOM(getDefaultDOM(edlAssociation)); <line8> loadConfigProcessors(edlController, edlGlobalConfig); <line9> loadPreProcessors(edlController, edlGlobalConfig); <line10> loadPostProcessor(edlController, edlGlobalConfig); <line11> loadStateComponents(edlController, edlGlobalConfig); <line12> loadStyle(edlController); <line13> } catch (Exception e) { <line14> String edl = null; <line15> if (edlAssociation != null) { <line16> edl = edlAssociation.getEdlName(); <line17> } <line18> String message = ""Error creating controller for EDL"" + (edl == null ? """" : "": "" + edl); <line19> throw new WorkflowRuntimeException(""Problems creating controller for EDL: "" + edl, e); <line20> } <line21> return edlController; <line22> } <line23> } <line24> "	<line19>
5886	public class A { <line0> public void setPassivator(final ConnectionPassivator p) { <line1> passivator = p; <line2> } <line3> } <line4> 	<line1>
5887	"public class A { <line0> @Override <line1> public void addMeta(final int typeId, final BinaryType newMeta, boolean failIfUnregistered) <line2> throws BinaryObjectException { <line3> assert newMeta != null; <line4> assert newMeta instanceof BinaryTypeImpl; <line5> BinaryMetadata newMeta0 = ((BinaryTypeImpl) newMeta).metadata(); <line6> if (failIfUnregistered) { <line7> failIfUnregistered(typeId, newMeta0); <line8> return; <line9> } <line10> try { <line11> GridFutureAdapter<MetadataUpdateResult> fut = transport.requestMetadataUpdate(newMeta0); <line12> if (fut == null) { <line13> if (log.isDebugEnabled()) { <line14> } <line15> return; <line16> } <line17> long t0 = System.nanoTime(); <line18> MetadataUpdateResult res = fut.get(); <line19> if (log.isDebugEnabled()) { <line20> IgniteInternalTx tx = ctx.cache().context().tm().tx(); <line21> } <line22> assert res != null; <line23> else if (!ctx.clientNode()) <line24> metadataFileStore.waitForWriteCompletion(typeId, res.typeVersion()); <line25> } catch (IgniteCheckedException e) { <line26> IgniteCheckedException ex = e; <line27> if (ctx.isStopping()) { <line28> ex = new NodeStoppingException(""Node is stopping.""); <line29> ex.addSuppressed(e); <line30> } <line31> throw new BinaryObjectException( <line32> ""Failed to update metadata for type: "" + newMeta.typeName(), ex); <line33> } <line34> } <line35> } <line36> "	<line14>, <line21>, <line23>
5888	"public class A { <line0> private SSLContext sslContext() { <line1> SslFactory sslFactory = new SslFactory(Mode.CLIENT, null, false); <line2> sslFactory.configure(config.sslConfigs()); <line3> try { <line4> return (SSLContext) SslFactory.class.getDeclaredMethod(""sslContext"").invoke(sslFactory); <line5> } catch (Exception e) { <line6> Object sslEngine; <line7> try { <line8> sslEngine = SslFactory.class.getDeclaredMethod(""sslEngineBuilder"").invoke(sslFactory); <line9> } catch (Exception ex) { <line10> try { <line11> sslEngine = SslFactory.class.getDeclaredMethod(""sslEngineFactory"").invoke(sslFactory); <line12> } catch (Exception exc) { <line13> throw new ConnectException(""Failed to find methods for SslFactory."", exc); <line14> } <line15> } <line16> try { <line17> return (SSLContext) sslEngine.getClass().getDeclaredMethod(""sslContext"").invoke(sslEngine); <line18> } catch (Exception ex) { <line19> throw new ConnectException(""Could not create SSLContext."", ex); <line20> } <line21> } <line22> } <line23> } <line24> "	<line4>, <line6>, <line9>, <line10>, <line12>
5889	public class A { <line0> private void handleFailedSlotRequest(SlotID slotId, AllocationID allocationId, Throwable cause) { <line1> PendingSlotRequest pendingSlotRequest = pendingSlotRequests.get(allocationId); <line2> if (null != pendingSlotRequest) { <line3> pendingSlotRequest.setRequestFuture(null); <line4> try { <line5> internalRequestSlot(pendingSlotRequest); <line6> } catch (ResourceManagerException e) { <line7> pendingSlotRequests.remove(allocationId); <line8> resourceActions.notifyAllocationFailure(pendingSlotRequest.getJobId(), allocationId, e); <line9> } <line10> } else { <line11> } <line12> } <line13> } <line14> 	<line2>, <line11>
5890	"public class A { <line0> @Override <line1> public void stopRunning() { <line2> Runnable runnable = <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> Thread.currentThread().setName(""stopping Adapter "" + getName()); <line7> try { <line8> synchronized (runState) { <line9> RunStateEnum currentRunState = getRunState(); <line10> if (currentRunState.equals(RunStateEnum.STARTING) <line11> || currentRunState.equals(RunStateEnum.STOPPING) <line12> || currentRunState.equals(RunStateEnum.STOPPED)) { <line13> String msg = <line14> ""currently in state ["" + currentRunState + ""], ignoring stop() command""; <line15> warn(msg); <line16> return; <line17> } <line18> runState.setRunState(RunStateEnum.STOPPING); <line19> } <line20> for (Receiver<?> receiver : receivers) { <line21> receiver.stopRunning(); <line22> } <line23> for (Receiver<?> receiver : receivers) { <line24> if (receiver.getRunState() == RunStateEnum.ERROR) { <line25> continue; <line26> } <line27> while (receiver.getRunState() != RunStateEnum.STOPPED) { <line28> try { <line29> Thread.sleep(1000); <line30> } catch (InterruptedException e) { <line31> } <line32> } <line33> } <line34> int currentNumOfMessagesInProcess = getNumOfMessagesInProcess(); <line35> if (currentNumOfMessagesInProcess > 0) { <line36> String msg = <line37> ""Adapter ["" <line38> + name <line39> + ""] is being stopped while still processing "" <line40> + currentNumOfMessagesInProcess <line41> + "" messages, waiting for them to finish""; <line42> warn(msg); <line43> } <line44> waitForNoMessagesInProcess(); <line45> pipeline.stop(); <line46> statsUpSince = 0; <line47> runState.setRunState(RunStateEnum.STOPPED); <line48> getMessageKeeper().add(""Adapter ["" + name + ""] stopped""); <line49> } catch (Throwable t) { <line50> addErrorMessageToMessageKeeper(""got error stopping Adapter"", t); <line51> runState.setRunState(RunStateEnum.ERROR); <line52> } finally { <line53> configuration.removeStopAdapterThread(this); <line54> } <line55> } <line56>  <line57> @Override <line58> public String toString() { <line59> return getName(); <line60> } <line61> }; <line62> configuration.addStopAdapterThread(runnable); <line63> taskExecutor.execute(runnable); <line64> } <line65> } <line66> "	<line20>, <line28>, <line31>, <line33>, <line45>
5891	public class A { <line0> public static Map<String, Object> connectionTest(String serviceName, Map<String, String> configs) <line1> throws Exception { <line2> Map<String, Object> ret = null; <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> try { <line6> ret = HBaseClient.connectionTest(serviceName, configs); <line7> } catch (HadoopException e) { <line8> throw e; <line9> } <line10> if (LOG.isDebugEnabled()) { <line11> } <line12> return ret; <line13> } <line14> } <line15> 	<line4>, <line8>, <line11>
5892	"public class A { <line0> private void readSystemScopes(JsonReader reader) throws IOException { <line1> reader.beginArray(); <line2> while (reader.hasNext()) { <line3> SystemScope scope = new SystemScope(); <line4> reader.beginObject(); <line5> while (reader.hasNext()) { <line6> switch (reader.peek()) { <line7> case END_OBJECT: <line8> continue; <line9> case NAME: <line10> String name = reader.nextName(); <line11> if (reader.peek() == JsonToken.NULL) { <line12> reader.skipValue(); <line13> } else if (name.equals(VALUE)) { <line14> scope.setValue(reader.nextString()); <line15> } else if (name.equals(DESCRIPTION)) { <line16> scope.setDescription(reader.nextString()); <line17> } else if (name.equals(RESTRICTED)) { <line18> scope.setRestricted(reader.nextBoolean()); <line19> } else if (name.equals(DEFAULT_SCOPE)) { <line20> scope.setDefaultScope(reader.nextBoolean()); <line21> } else if (name.equals(ICON)) { <line22> scope.setIcon(reader.nextString()); <line23> } else if (name.equals(STRUCTURED)) { <line24> logger.warn(""Found a structured scope, ignoring structure""); <line25> } else if (name.equals(STRUCTURED_PARAMETER)) { <line26> } else { <line27> reader.skipValue(); <line28> } <line29> break; <line30> default: <line31> reader.skipValue(); <line32> continue; <line33> } <line34> } <line35> reader.endObject(); <line36> sysScopeRepository.save(scope); <line37> } <line38> reader.endArray(); <line39> } <line40> } <line41> "	<line26>, <line27>, <line31>, <line39>
5893	public class A { <line0> private void writeCommandToDevice(RequestMessage requestMessage) throws IOException { <line1> if (connectionManager.getCommandOut() == null) { <line2> return; <line3> } <line4> byte[] deviceCommand = (requestMessage.getDeviceCommand() + '\r').getBytes(); <line5> connectionManager.getCommandOut().write(deviceCommand); <line6> connectionManager.getCommandOut().flush(); <line7> } <line8> } <line9> 	<line1>, <line2>
5894	"public class A { <line0> private void generateCoordinates( <line1> Vector2d firstBondVector, boolean isConnected, boolean isSubLayout) throws CDKException { <line2> if (firstBondVector == DEFAULT_BOND_VECTOR) firstBondVector = new Vector2d(firstBondVector); <line3> final int numAtoms = molecule.getAtomCount(); <line4> final int numBonds = molecule.getBondCount(); <line5> this.firstBondVector = firstBondVector; <line6> if (numAtoms == 0) { <line7> return; <line8> } <line9> if (numAtoms == 1) { <line10> molecule.getAtom(0).setPoint2d(new Point2d(0, 0)); <line11> return; <line12> } else if (molecule.getBondCount() == 1 && molecule.getAtomCount() == 2) { <line13> double xOffset = 0; <line14> for (IAtom atom : molecule.atoms()) { <line15> atom.setPoint2d(new Point2d(xOffset, 0)); <line16> xOffset += bondLength; <line17> } <line18> return; <line19> } <line20> if (!isConnected) { <line21> final IAtomContainerSet frags = ConnectivityChecker.partitionIntoMolecules(molecule); <line22> if (frags.getAtomContainerCount() > 1) { <line23> IAtomContainer rollback = molecule; <line24> List<IAtomContainer> fragList = toList(frags); <line25> Collections.sort(fragList, LARGEST_FIRST_COMPARATOR); <line26> generateFragmentCoordinates(molecule, fragList); <line27> this.molecule = rollback; <line28> atomPlacer.setMolecule(this.molecule); <line29> ringPlacer.setMolecule(this.molecule); <line30> macroPlacer = new MacroCycleLayout(this.molecule); <line31> return; <line32> } <line33> } <line34> seedLayout(); <line35> int iter = 0; <line36> for (; !AtomPlacer.allPlaced(molecule) && iter < numAtoms; iter++) { <line37> layoutAcyclicParts(); <line38> layoutCyclicParts(); <line39> } <line40> if (iter == numAtoms && !AtomPlacer.allPlaced(molecule)) <line41> throw new CDKException( <line42> ""Could not generate layout? If a set of 'fixed' atoms were provided"" <line43> + "" try removing these and regenerating the layout.""); <line44> if (!isSubLayout) { <line45> if (molecule.stereoElements().iterator().hasNext()) <line46> CorrectGeometricConfiguration.correct(molecule); <line47> } <line48> refinePlacement(molecule); <line49> finalizeLayout(molecule); <line50> if (!isSubLayout) assignStereochem(molecule); <line51> } <line52> } <line53> "	<line6>, <line37>
5895	public class A { <line0> public static void writePrimitiveBoolean(boolean value, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> out.writeBoolean(value); <line5> } <line6> } <line7> 	<line3>
5896	public class A { <line0> public void attachDirty(MbStatus instance) { <line1> try { <line2> getSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
5897	public class A { <line0> @Override <line1> public List<TrustBundle> getTrustBundles(boolean fetchAnchors) { <line2> List<TrustBundle> listTB = null; <line3> try { <line4> listTB = getDirectConfigProxy().getTrustBundles(fetchAnchors); <line5> } catch (Exception ex) { <line6> } <line7> return listTB; <line8> } <line9> } <line10> 	<line6>
5898	public class A { <line0> public static String decryptCloudConfigPassword(String message) { <line1> try { <line2> return CryptoUtils.decrypt(message, CLOUD_KEY); <line3> } catch (GeneralSecurityException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	<line4>
5899	"public class A { <line0> @NamespacePermission( <line1> fields = ""#emrClusterDefinitionKey?.namespace"", <line2> permissions = NamespacePermissionEnum.WRITE) <line3> @Override <line4> public EmrClusterDefinitionInformation deleteEmrClusterDefinition( <line5> EmrClusterDefinitionKey emrClusterDefinitionKey) throws Exception { <line6> emrClusterDefinitionHelper.validateEmrClusterDefinitionKey(emrClusterDefinitionKey); <line7> EmrClusterDefinitionEntity emrClusterDefinitionEntity = <line8> emrClusterDefinitionDaoHelper.getEmrClusterDefinitionEntity(emrClusterDefinitionKey); <line9> emrClusterDefinitionDao.delete(emrClusterDefinitionEntity); <line10> return createEmrClusterDefinitionFromEntity(emrClusterDefinitionEntity); <line11> } <line12> } <line13> "	<line9>
5900	public class A { <line0> void doSocketClose(Socket socket, String logMessage, boolean reset) { <line1> if (socket != null && socket.isConnected() && !socket.isClosed()) { <line2> if (logMessage != null && !logMessage.isEmpty()) { <line3> } else { <line4> } <line5> endpoint.updateLastConnectionTerminatedTicks(); <line6> if (!socket.isInputShutdown()) { <line7> try { <line8> socket.shutdownInput(); <line9> } catch (IOException ignoredEx) { <line10> } <line11> } <line12> if (!socket.isOutputShutdown()) { <line13> try { <line14> socket.shutdownOutput(); <line15> } catch (IOException ignoredEx) { <line16> } <line17> } <line18> if (reset) { <line19> final boolean on = true; <line20> final int linger = 0; <line21> try { <line22> socket.setSoLinger(on, linger); <line23> } catch (IOException ignoredEx) { <line24> } <line25> } <line26> try { <line27> socket.close(); <line28> } catch (IOException ignoredEx) { <line29> } <line30> } <line31> } <line32> } <line33> 	<line3>, <line4>, <line10>, <line16>, <line24>, <line29>
5901	"public class A { <line0> @Test <line1> public void testCreateOrder() throws Exception { <line2> Order order = new Order(); <line3> order.setAmount(1); <line4> order.setPartName(""motor""); <line5> order.setCustomerName(""honda""); <line6> String xml = context.getTypeConverter().convertTo(String.class, order); <line7> String id = template.requestBody(""http://localhost:8080/orders"", xml, String.class); <line8> assertNotNull(id); <line9> assertEquals(""3"", id); <line10> } <line11> } <line12> "	<line7>, <line9>
5902	"public class A { <line0> @Override <line1> public DataContext createDataContext(DataContextFactoryParameters params) { <line2> TableType[] tableTypes = params.getTableTypes(); <line3> if (tableTypes == null) { <line4> tableTypes = TableType.DEFAULT_TABLE_TYPES; <line5> } <line6> final DataSource dataSource = params.getDataSource(); <line7> if (dataSource == null) { <line8> final String driverClassName = getString(params.getDriverClassName(), null); <line9> if (driverClassName != null) { <line10> try { <line11> Class.forName(driverClassName); <line12> } catch (ClassNotFoundException e) { <line13> } <line14> } <line15> final String url = params.getUrl(); <line16> final Connection connection; <line17> try { <line18> if (params.getUsername() == null && params.getPassword() == null) { <line19> connection = DriverManager.getConnection(url); <line20> } else { <line21> connection = DriverManager.getConnection(url, params.getUsername(), params.getPassword()); <line22> } <line23> } catch (Exception e) { <line24> throw new IllegalStateException(""Failed to get JDBC connection"", e); <line25> } <line26> return new JdbcDataContext(connection, tableTypes, params.getCatalogName()); <line27> } <line28> return new JdbcDataContext(dataSource, tableTypes, params.getCatalogName()); <line29> } <line30> } <line31> "	<line13>, <line24>
5903	"public class A { <line0> private void setWarningLabel(PrivateKeyProvider selectedItem) { <line1> try { <line2> String message; <line3> if (selectedItem == null) { <line4> message = <line5> ""<html>No certificate selected. Please import one using the <big><font"" <line6> + "" color=\""green\"">+</font></big> button above.</html>""; <line7> myWarningLabel.setText(message); <line8> } else if (myProviderFilter != null && !myProviderFilter.isSatisfied(selectedItem)) { <line9> message = myProviderFilter.getErrorMessage(selectedItem); <line10> boolean foundAlternate = false; <line11> for (int index = 0; index < myCertificateComboBox.getItemCount(); ) { <line12> PrivateKeyProvider itemAt = myCertificateComboBox.getItemAt(index++); <line13> if (myProviderFilter.isSatisfied(itemAt)) { <line14> foundAlternate = true; <line15> break; <line16> } <line17> } <line18> if (!foundAlternate) { <line19> message = <line20> StringUtilities.concat( <line21> ""<html>"", <line22> message, <line23> ""<br/>You have no acceptable certificates loaded. Please import one using the"" <line24> + "" <big><font color=\""green\"">+</font></big> button above.</html>""); <line25> } <line26> } else { <line27> message = null; <line28> } <line29> if (message == null) { <line30> myWarningLabel.setVisible(false); <line31> myValidatorSupport.setValidationResult(ValidationStatus.VALID, ""Certificate is valid.""); <line32> } else { <line33> myWarningLabel.setText(message); <line34> myWarningLabel.setVisible(true); <line35> myValidatorSupport.setValidationResult(ValidationStatus.ERROR, message); <line36> } <line37> Window window = SwingUtilities.getWindowAncestor(this); <line38> if (window != null) { <line39> window.pack(); <line40> } <line41> } catch (PrivateKeyProviderException e) { <line42> } <line43> } <line44> } <line45> "	<line25>, <line42>
5904	public class A { <line0> private <C extends IRequestablePage> Constructor<C> constructor( <line1> final Class<C> pageClass, final Class<PageParameters> argumentType) { <line2> Constructor<C> constructor = (Constructor<C>) constructorForClass.get(pageClass); <line3> if (constructor == null) { <line4> try { <line5> constructor = pageClass.getDeclaredConstructor(new Class[] {argumentType}); <line6> Constructor<C> tmpConstructor = <line7> (Constructor<C>) constructorForClass.putIfAbsent(pageClass, constructor); <line8> if (tmpConstructor != null) { <line9> constructor = tmpConstructor; <line10> } <line11> } catch (NoSuchMethodException e) { <line12> return null; <line13> } <line14> } <line15> return constructor; <line16> } <line17> } <line18> 	<line11>, <line12>
5905	public class A { <line0> public void handleGetLightSensorStatusResponse( <line1> final LightSensorStatusDto lightSensorStatusDto, <line2> final CorrelationIds ids, <line3> final String messageType, <line4> final int messagePriority, <line5> final ResponseMessageResultType deviceResult, <line6> final OsgpException exception) { <line7> final GetLightSensorStatusResponse response = new GetLightSensorStatusResponse(); <line8> response.setOsgpException(exception); <line9> response.setResult(deviceResult); <line10> if (lightSensorStatusDto != null) { <line11> response.setLightSensorStatus( <line12> new LightSensorStatus( <line13> LightSensorStatusType.valueOf(lightSensorStatusDto.getStatus().name()))); <line14> this.updateLastCommunicationTime(ids.getDeviceIdentification()); <line15> } <line16> if (deviceResult == ResponseMessageResultType.NOT_OK || exception != null) { <line17> } <line18> final ResponseMessage responseMessage = <line19> ResponseMessage.newResponseMessageBuilder() <line20> .withIds(ids) <line21> .withResult(response.getResult()) <line22> .withOsgpException(response.getOsgpException()) <line23> .withDataObject(response.getLightSensorStatus()) <line24> .withMessagePriority(messagePriority) <line25> .build(); <line26> if (!OsgpSystemCorrelationUid.CORRELATION_UID.equals(ids.getCorrelationUid())) { <line27> this.webServiceResponseMessageSender.send(responseMessage); <line28> } else { <line29> } <line30> } <line31> } <line32> 	<line7>, <line17>, <line29>
5906	public class A { <line0> @After <line1> public void tearDown() throws Exception { <line2> try { <line3> wireGraphService.delete(); <line4> } catch (KuraException e) { <line5> throw e; <line6> } <line7> } <line8> } <line9> 	<line5>
5907	public class A { <line0> public MbB2mDel merge(MbB2mDel detachedInstance) { <line1> try { <line2> MbB2mDel result = (MbB2mDel) sessionFactory.getCurrentSession().merge(detachedInstance); <line3> return result; <line4> } catch (RuntimeException re) { <line5> throw re; <line6> } <line7> } <line8> } <line9> 	<line1>, <line3>, <line5>
5908	"public class A { <line0> public static com.liferay.layout.page.template.model.LayoutPageTemplateEntry <line1> addLayoutPageTemplateEntry( <line2> HttpPrincipal httpPrincipal, <line3> long groupId, <line4> long layoutPageTemplateCollectionId, <line5> long classNameId, <line6> long classTypeId, <line7> String name, <line8> int status, <line9> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> LayoutPageTemplateEntryServiceUtil.class, <line15> ""addLayoutPageTemplateEntry"", <line16> _addLayoutPageTemplateEntryParameterTypes0); <line17> MethodHandler methodHandler = <line18> new MethodHandler( <line19> methodKey, <line20> groupId, <line21> layoutPageTemplateCollectionId, <line22> classNameId, <line23> classTypeId, <line24> name, <line25> status, <line26> serviceContext); <line27> Object returnObj = null; <line28> try { <line29> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line30> } catch (Exception exception) { <line31> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line32> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line33> } <line34> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line35> } <line36> return (com.liferay.layout.page.template.model.LayoutPageTemplateEntry) returnObj; <line37> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line38> throw systemException; <line39> } <line40> } <line41> } <line42> "	<line38>
5909	public class A { <line0> protected void deactivate(ComponentContext componentContext) { <line1> if (this.conn != null) { <line2> try { <line3> this.conn.close(); <line4> } catch (IOException e) { <line5> e.printStackTrace(); <line6> } <line7> this.conn = null; <line8> } <line9> } <line10> } <line11> 	<line1>
5910	"public class A { <line0> protected final Set<VEvent> convertCalendarToEvents( <line1> net.fortuna.ical4j.model.Calendar calendar, Interval interval) throws CalendarException { <line2> Period period = <line3> new Period( <line4> new net.fortuna.ical4j.model.DateTime(interval.getStartMillis()), <line5> new net.fortuna.ical4j.model.DateTime(interval.getEndMillis())); <line6> Set<VEvent> events = new HashSet<VEvent>(); <line7> if (calendar == null) { <line8> return Collections.emptySet(); <line9> } <line10> for (Iterator<Component> i = calendar.getComponents().iterator(); i.hasNext(); ) { <line11> Component component = i.next(); <line12> if (component.getName().equals(""VEVENT"")) { <line13> VEvent event = (VEvent) component; <line14> if (log.isTraceEnabled()) { <line15> } <line16> PeriodList periods = event.calculateRecurrenceSet(period); <line17> for (Iterator<Period> iter = periods.iterator(); iter.hasNext(); ) { <line18> Period eventper = iter.next(); <line19> PropertyList props = event.getProperties(); <line20> PropertyList newprops = new PropertyList(); <line21> newprops.add(new DtStart(eventper.getStart())); <line22> newprops.add(new DtEnd(eventper.getEnd())); <line23> for (Iterator<Property> iter2 = props.iterator(); iter2.hasNext(); ) { <line24> Property prop = iter2.next(); <line25> if (!(prop instanceof DtStart) <line26> && !(prop instanceof DtEnd) <line27> && !(prop instanceof Duration) <line28> && !(prop instanceof RRule)) newprops.add(prop); <line29> } <line30> VEvent newevent = new VEvent(newprops); <line31> events.add(newevent); <line32> if (log.isTraceEnabled()) { <line33> } <line34> } <line35> } <line36> } <line37> return events; <line38> } <line39> } <line40> "	<line8>, <line15>, <line33>
5911	"public class A { <line0> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line1> private void initializeRegion(AbstractGatewaySender sender, CacheListener listener) { <line2> final InternalCache gemCache = sender.getCache(); <line3> this.region = gemCache.getRegion(this.regionName); <line4> if (this.region == null) { <line5> RegionShortcut regionShortcut; <line6> if (enablePersistence) { <line7> regionShortcut = RegionShortcut.REPLICATE_PERSISTENT; <line8> } else { <line9> regionShortcut = RegionShortcut.REPLICATE; <line10> } <line11> InternalRegionFactory<Long, AsyncEvent> factory = <line12> gemCache.createInternalRegionFactory(regionShortcut); <line13> if (NO_ACK) { <line14> factory.setScope(Scope.DISTRIBUTED_NO_ACK); <line15> } <line16> if (logger.isDebugEnabled()) { <line17> } <line18> if (listener != null) { <line19> factory.addCacheListener(listener); <line20> } <line21> EvictionAttributes ea = <line22> EvictionAttributes.createLIFOMemoryAttributes( <line23> this.maximumQueueMemory, EvictionAction.OVERFLOW_TO_DISK); <line24> factory.setEvictionAttributes(ea); <line25> factory.setConcurrencyChecksEnabled(false); <line26> factory.setDiskStoreName(this.diskStoreName); <line27> factory.setDiskSynchronous(this.isDiskSynchronous); <line28> if (logger.isDebugEnabled()) { <line29> } <line30> final RegionAttributes<Long, AsyncEvent> ra = factory.getCreateAttributes(); <line31> try { <line32> SerialGatewaySenderQueueMetaRegion meta = <line33> metaRegionFactory.newMetaRegion(gemCache, this.regionName, ra, sender); <line34> factory <line35> .setInternalMetaRegion(meta) <line36> .setDestroyLockFlag(true) <line37> .setSnapshotInputStream(null) <line38> .setImageTarget(null) <line39> .setIsUsedForSerialGatewaySenderQueue(true) <line40> .setInternalRegion(true) <line41> .setSerialGatewaySender(sender); <line42> region = factory.create(regionName); <line43> addOverflowStatisticsToMBean(gemCache, sender); <line44> if (logger.isDebugEnabled()) { <line45> } <line46> } catch (CacheException e) { <line47> } <line48> } else { <line49> if (listener != null) { <line50> addCacheListener(listener); <line51> } <line52> } <line53> if ((this.region != null) && this.cleanQueues) { <line54> this.region.clear(); <line55> } <line56> } <line57> } <line58> "	<line17>, <line29>, <line45>, <line47>
5912	public class A { <line0> public void revalidateCacheEntry(final String cacheKey, final RevalidationCall call) { <line1> scheduleRevalidation( <line2> cacheKey, <line3> () -> { <line4> try (ClassicHttpResponse httpResponse = call.execute()) { <line5> if (httpResponse.getCode() < HttpStatus.SC_SERVER_ERROR && !isStale(httpResponse)) { <line6> jobSuccessful(cacheKey); <line7> } else { <line8> jobFailed(cacheKey); <line9> } <line10> } catch (final IOException ex) { <line11> jobFailed(cacheKey); <line12> } catch (final HttpException ex) { <line13> jobFailed(cacheKey); <line14> } catch (final RuntimeException ex) { <line15> jobFailed(cacheKey); <line16> } <line17> }); <line18> } <line19> } <line20> 	<line12>, <line14>, <line16>
5913	public class A { <line0> public static void invokeInFxThreadAndWait(final Runnable run) { <line1> if (Platform.isFxApplicationThread()) { <line2> run.run(); <line3> return; <line4> } <line5> try { <line6> FutureTask<Void> future = new FutureTask<>(run, null); <line7> Platform.runLater(future); <line8> future.get(); <line9> } catch (ExecutionException | InterruptedException e) { <line10> } <line11> } <line12> } <line13> 	<line10>
5914	"public class A { <line0> @WithMockUser(username = USERNAME) <line1> @SuppressWarnings({""OptionalGetWithoutIsPresent""}) <line2> @Test <line3> void testCopyPackage() { <line4> String targetPackageId = ""target1""; <line5> addTargetPackage(targetPackageId); <line6> ResourceIdentifier id = ResourceIdentifier.create(ResourceType.PACKAGE, PACKAGE_A); <line7> TestProgress progress = new TestProgress(); <line8> copyService.copy(singletonList(id), targetPackageId, progress); <line9> await().atMost(5, TimeUnit.SECONDS).until(copyJobFinished(progress)); <line10> waitForWorkToBeFinished(indexService, LOG); <line11> Package targetPackage = metadataService.getPackage(targetPackageId).get(); <line12> List<Package> packages = newArrayList(targetPackage.getChildren()); <line13> assertEquals(1, packages.size()); <line14> Package packageACopy = packages.get(0); <line15> assertEquals(""Package A"", packageACopy.getLabel()); <line16> List<EntityType> entityTypesInACopy = newArrayList(packageACopy.getEntityTypes()); <line17> List<Package> packagesInACopy = newArrayList(packageACopy.getChildren()); <line18> assertEquals(1, entityTypesInACopy.size()); <line19> assertEquals(1, packagesInACopy.size()); <line20> Package packageBCopy = packagesInACopy.get(0); <line21> assertEquals(""Package B (child of A)"", packageBCopy.getLabel()); <line22> List<EntityType> entityTypesInBCopy = newArrayList(packageBCopy.getEntityTypes()); <line23> List<Package> packagesInBCopy = newArrayList(packageBCopy.getChildren()); <line24> assertEquals(1, entityTypesInBCopy.size()); <line25> assertEquals(0, packagesInBCopy.size()); <line26> EntityType entityTypeACopy = entityTypesInACopy.get(0); <line27> EntityType entityTypeBCopy = entityTypesInBCopy.get(0); <line28> assertEquals(""EntityType A"", entityTypeACopy.getLabel()); <line29> assertEquals(""EntityType B (referenced by A)"", entityTypeBCopy.getLabel()); <line30> assertEquals(ENTITY_TYPE_B, entityTypeA.getAttribute(""xref_attr"").getRefEntity().getId()); <line31> assertEquals( <line32> entityTypeBCopy.getId(), entityTypeACopy.getAttribute(""xref_attr"").getRefEntity().getId()); <line33> assertEquals(4, progress.getProgress()); <line34> List<Object> entitiesOfA = <line35> dataService.findAll(entityTypeACopy.getId()).map(Entity::getIdValue).collect(toList()); <line36> assertEquals(asList(""0"", ""1"", ""2""), entitiesOfA); <line37> List<Object> entitiesOfB = <line38> dataService.findAll(entityTypeBCopy.getId()).map(Entity::getIdValue).collect(toList()); <line39> assertEquals(asList(""0"", ""1"", ""2""), entitiesOfB); <line40> cleanupTargetPackage(targetPackageId); <line41> } <line42> } <line43> "	<line10>
5915	"public class A { <line0> public static Specifier getSpecifier(String identifier, String method, String op) <line1> throws CSWebApplicationException { <line2> Specifier result = null; <line3> if (identifier != null) { <line4> if (!identifier.startsWith(URN_PREFIX)) { <line5> result = new Specifier(SpecifierForm.CSID, identifier); <line6> } else { <line7> if (identifier.startsWith(URN_PREFIX_NAME, URN_PREFIX_LEN)) { <line8> int closeParen = identifier.indexOf(')', URN_NAME_PREFIX_LEN); <line9> if (closeParen >= 0) { <line10> result = <line11> new Specifier( <line12> SpecifierForm.URN_NAME, identifier.substring(URN_NAME_PREFIX_LEN, closeParen)); <line13> } <line14> } else if (identifier.startsWith(URN_PREFIX_ID, URN_PREFIX_LEN)) { <line15> int closeParen = identifier.indexOf(')', URN_ID_PREFIX_LEN); <line16> if (closeParen >= 0) { <line17> result = <line18> new Specifier( <line19> SpecifierForm.CSID, identifier.substring(URN_ID_PREFIX_LEN, closeParen)); <line20> } <line21> } else { <line22> Response response = <line23> Response.status(Response.Status.BAD_REQUEST) <line24> .entity(op + "" failed on bad or missing Authority specifier"") <line25> .type(""text/plain"") <line26> .build(); <line27> throw new CSWebApplicationException(response); <line28> } <line29> } <line30> } <line31> return result; <line32> } <line33> } <line34> "	<line22>
5916	public class A { <line0> public void loadHetuMetastore(FileSystemClientManager fileSystemClientManager) <line1> throws IOException { <line2> if (HETUMETASTORE_CONFIG_FILE.exists()) { <line3> Map<String, String> config = <line4> new HashMap<>(loadPropertiesFrom(HETUMETASTORE_CONFIG_FILE.getPath())); <line5> loadHetuMetastore(fileSystemClientManager, config); <line6> } <line7> } <line8> } <line9> 	<line2>
5917	"public class A { <line0> @Test <line1> @Repeat(10) <line2> @DirtiesContext <line3> public void testConcurrentRefresh() throws Exception { <line4> this.scope.setEager(false); <line5> int n = 80; <line6> TestPropertyValues.of(""message=Foo"").applyTo(this.environment); <line7> this.scope.refreshAll(); <line8> final CountDownLatch latch = new CountDownLatch(n); <line9> List<Future<String>> results = new ArrayList<>(); <line10> for (int i = 0; i < n; i++) { <line11> results.add( <line12> this.executor.submit( <line13> new Callable<String>() { <line14> @Override <line15> public String call() throws Exception { <line16> try { <line17> return RefreshScopeConfigurationScaleTests.this.service.getMessage(); <line18> } finally { <line19> latch.countDown(); <line20> } <line21> } <line22> })); <line23> this.executor.submit( <line24> new Runnable() { <line25> @Override <line26> public void run() { <line27> RefreshScopeConfigurationScaleTests.this.scope.refreshAll(); <line28> } <line29> }); <line30> } <line31> then(latch.await(15000, TimeUnit.MILLISECONDS)).isTrue(); <line32> then(this.service.getMessage()).isEqualTo(""Foo""); <line33> for (Future<String> result : results) { <line34> then(result.get()).isEqualTo(""Foo""); <line35> } <line36> } <line37> } <line38> "	<line16>, <line20>, <line27>
5918	public class A { <line0> @Override <line1> public void info(String string, Object o) { <line2> } <line3> } <line4> 	<line2>
5919	"public class A { <line0> @AllowConcurrentEvents <line1> @Subscribe <line2> public void handleKillbillEvent(final ExtBusEvent event) throws IOException, BundleException { <line3> if (event.getEventType() != ExtBusEventType.BROADCAST_SERVICE) { <line4> return; <line5> } <line6> final BroadcastMetadata metadata = <line7> objectMapper.readValue(event.getMetaData(), BroadcastMetadata.class); <line8> final SystemNodeCommandType commandType = <line9> getSystemNodeCommandTypeOrNull(metadata.getCommandType()); <line10> if (commandType == null <line11> || (commandType != SystemNodeCommandType.START_PLUGIN <line12> && commandType != SystemNodeCommandType.STOP_PLUGIN <line13> && commandType != SystemNodeCommandType.RESTART_PLUGIN)) { <line14> return; <line15> } <line16> final PluginNodeCommandMetadata nodeCommandMetadata = <line17> (PluginNodeCommandMetadata) <line18> deserializeNodeCommand(metadata.getEventJson(), metadata.getCommandType()); <line19> final String pluginName = <line20> nodeCommandMetadata.getPluginName() != null <line21> ? nodeCommandMetadata.getPluginName() <line22> : (pluginFinder.resolvePluginKey(nodeCommandMetadata.getPluginKey()) != null <line23> ? pluginFinder.resolvePluginKey(nodeCommandMetadata.getPluginKey()).getPluginName() <line24> : null); <line25> if (pluginName == null) { <line26> return; <line27> } <line28> BundleWithMetadata bundleWithMetadata = null; <line29> switch (commandType) { <line30> case STOP_PLUGIN: <line31> bundleRegistry.stopAndUninstallNewBundle( <line32> pluginName, nodeCommandMetadata.getPluginVersion()); <line33> break; <line34> case START_PLUGIN: <line35> bundleWithMetadata = <line36> bundleRegistry.installAndStartNewBundle( <line37> pluginName, nodeCommandMetadata.getPluginVersion()); <line38> break; <line39> case RESTART_PLUGIN: <line40> bundleRegistry.stopAndUninstallNewBundle( <line41> pluginName, nodeCommandMetadata.getPluginVersion()); <line42> bundleWithMetadata = <line43> bundleRegistry.installAndStartNewBundle( <line44> pluginName, nodeCommandMetadata.getPluginVersion()); <line45> break; <line46> default: <line47> throw new IllegalStateException(""Unexpected type "" + commandType); <line48> } <line49> final String defaultPluginVersion = <line50> pluginFinder.getPluginVersionSelectedForStart(nodeCommandMetadata.getPluginName()); <line51> final boolean isSelectedForStart = <line52> defaultPluginVersion != null && nodeCommandMetadata.getPluginVersion() != null <line53> ? defaultPluginVersion.equals(nodeCommandMetadata.getPluginVersion()) <line54> : true; <line55> final String symbolicName = <line56> (bundleWithMetadata != null && bundleWithMetadata.getBundle() != null) <line57> ? bundleWithMetadata.getBundle().getSymbolicName() <line58> : null; <line59> final HashMap<String, String> eventProperties = new HashMap<String, String>(); <line60> eventProperties.put(""pluginName"", pluginName); <line61> eventProperties.put(""pluginKey"", nodeCommandMetadata.getPluginKey()); <line62> eventProperties.put(""symbolicName"", symbolicName); <line63> killbillActivator.sendEvent(""org/killbill/billing/osgi/plugin/"" + commandType, eventProperties); <line64> final PluginInfo pluginInfo = <line65> new DefaultPluginInfo( <line66> nodeCommandMetadata.getPluginKey(), <line67> symbolicName, <line68> nodeCommandMetadata.getPluginName(), <line69> nodeCommandMetadata.getPluginVersion(), <line70> DefaultPluginsInfoApi.toPluginState(bundleWithMetadata), <line71> isSelectedForStart, <line72> ImmutableSet.<PluginServiceInfo>of()); <line73> nodesApi.notifyPluginChanged(pluginInfo, pluginsInfoApi.getPluginsInfo()); <line74> } <line75> } <line76> "	<line26>
5920	public class A { <line0> public void setProcessVariable( <line1> String containerId, <line2> Number processInstanceId, <line3> String varName, <line4> String variablePayload, <line5> String marshallingType) { <line6> containerId = <line7> context.getContainerId( <line8> containerId, new ByProcessInstanceIdContainerLocator(processInstanceId.longValue())); <line9> Object variable = <line10> marshallerHelper.unmarshal(containerId, variablePayload, marshallingType, Object.class); <line11> processService.setProcessVariable( <line12> containerId, processInstanceId.longValue(), varName, variable); <line13> } <line14> } <line15> 	<line9>, <line11>
5921	public class A { <line0> @Test <line1> public void testDispatchingJobsHigherMaxLoad() throws Exception { <line2> Job testJob = <line3> serviceRegistryJpaImpl.createJob( <line4> TEST_HOST, TEST_SERVICE_FAIRNESS, TEST_OPERATION, null, null, true, null, 10.0f); <line5> JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob); <line6> launchDispatcherOnce(false); <line7> assertThrows(IllegalStateException.class, () -> barrier.waitForJobs(JOB_BARRIER_TIMEOUT)); <line8> } <line9> } <line10> 	<line2>
5922	public class A { <line0> @Override <line1> public void cancel(final BackgroundAction action) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>
5923	public class A { <line0> private static void attachShutdownHook() { <line1> Runtime.getRuntime() <line2> .addShutdownHook( <line3> new Thread() { <line4> @Override <line5> public void run() { <line6> LogManager.shutdown(); <line7> } <line8> }); <line9> } <line10> } <line11> 	<line6>
5924	"public class A { <line0> @Override <line1> public List<? extends Command> getDisposeCommands(Context context, boolean withDao) { <line2> InitialContext initialContext = (InitialContext) context.get(INITIAL_CONTEXT); <line3> List<Command> commands = new ArrayList<>(); <line4> try { <line5> commands.add(CommandFactory.create(initialContext, GtfsDisposeImportCommand.class.getName())); <line6> } catch (Exception e) { <line7> throw new RuntimeException(""unable to call factories""); <line8> } <line9> return commands; <line10> } <line11> } <line12> "	<line7>
5925	"public class A { <line0> protected String createWorkDirectory(String location) { <line1> if (location == null) { <line2> location = "".""; <line3> } <line4> File f = new File(location); <line5> f.mkdirs(); <line6> return location; <line7> } <line8> } <line9> "	<line4>
5926	"public class A { <line0> @EventListener <line1> public void onApplicationEvent(ApplicationReadyEvent aEvt) { <line2> if (port != -1 <line3> && System.console() == null <line4> && !GraphicsEnvironment.isHeadless() <line5> && runningFromCommandline) { <line6> eventPublisher.publishEvent(new ShutdownDialogAvailableEvent(StandaloneShutdownDialog.this)); <line7> final int style; <line8> final String[] options; <line9> if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Action.BROWSE)) { <line10> style = JOptionPane.OK_CANCEL_OPTION; <line11> options = new String[] {ACTION_SHUTDOWN, ACTION_OPEN_BROWSER}; <line12> } else { <line13> style = JOptionPane.OK_OPTION; <line14> options = new String[] {ACTION_SHUTDOWN}; <line15> } <line16> EventQueue.invokeLater( <line17> () -> { <line18> final JOptionPane optionPane = <line19> new JOptionPane( <line20> new JLabel( <line21> ""<HTML>"" <line22> + applicationName <line23> + "" is running now and can be "" <line24> + ""accessed via <b>http://localhost:8080</b>.<br>"" <line25> + applicationName <line26> + "" works best with the browsers Google Chrome or Safari.<br>"" <line27> + ""Use this dialog to shut "" <line28> + applicationName <line29> + "" down.</HTML>""), <line30> JOptionPane.INFORMATION_MESSAGE, <line31> style, <line32> null, <line33> options); <line34> final JDialog dialog = new JDialog((JFrame) null, applicationName, false); <line35> dialog.setContentPane(optionPane); <line36> dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); <line37> dialog.addWindowListener( <line38> new WindowAdapter() { <line39> @Override <line40> public void windowClosing(WindowEvent we) {} <line41> }); <line42> optionPane.addPropertyChangeListener(this::handleCloseEvent); <line43> dialog.pack(); <line44> dialog.setVisible(true); <line45> }); <line46> } else { <line47> } <line48> } <line49> } <line50> "	<line2>, <line6>, <line47>
5927	"public class A { <line0> @ApiOperation( <line1> httpMethod = ""POST"", <line2> value = ""API to update roles details"", <line3> response = Response.class, <line4> consumes = MediaType.APPLICATION_JSON_VALUE) <line5> @RequestMapping( <line6> path = ""/update"", <line7> method = RequestMethod.POST, <line8> consumes = MediaType.APPLICATION_JSON_VALUE) <line9> public ResponseEntity<Object> updateUserRole( <line10> @AuthenticationPrincipal Principal user, <line11> @ApiParam(value = ""provide valid role details"", required = true) @RequestBody(required = true) <line12> UpdateRoleDetailsRequest roleDetailsRequest) { <line13> try { <line14> return ResponseUtils.buildSucessResponse( <line15> userRolesService.updateUserRole(roleDetailsRequest, user.getName())); <line16> } catch (Exception exception) { <line17> return ResponseUtils.buildFailureResponse( <line18> new Exception(UNEXPECTED_ERROR_OCCURRED), exception.getMessage()); <line19> } <line20> } <line21> } <line22> "	<line17>
5928	"public class A { <line0> @Override <line1> public String copyToAnotherMeta(KylinConfig srcConfig, KylinConfig dstConfig) throws IOException { <line2> if (baseDir.contains(""resources/SegmentDict"")) { <line3> return baseDir; <line4> } <line5> checkArgument( <line6> baseDir.startsWith(srcConfig.getHdfsWorkingDirectory()), <line7> ""Please check why current directory {} doesn't belong to source working directory {}"", <line8> baseDir, <line9> srcConfig.getHdfsWorkingDirectory()); <line10> final String dstBaseDir = <line11> baseDir.replaceFirst( <line12> srcConfig.getHdfsWorkingDirectory(), dstConfig.getHdfsWorkingDirectory()); <line13> Long[] versions = listAllVersions(); <line14> if (versions.length == 0) { <line15> return dstBaseDir; <line16> } <line17> Path srcVersionDir = getVersionDir(versions[versions.length - 1]); <line18> Path dstVersionDir = <line19> new Path( <line20> srcVersionDir <line21> .toString() <line22> .replaceFirst( <line23> srcConfig.getHdfsWorkingDirectory(), dstConfig.getHdfsWorkingDirectory())); <line24> FileSystem dstFS = dstVersionDir.getFileSystem(conf); <line25> if (dstFS.exists(dstVersionDir)) { <line26> dstFS.delete(dstVersionDir, true); <line27> } <line28> FileUtil.copy(fileSystem, srcVersionDir, dstFS, dstVersionDir, false, true, conf); <line29> return dstBaseDir; <line30> } <line31> } <line32> "	<line3>
5929	public class A { <line0> private @Nullable DiscoveryResult findConnectionResult( <line1> List<BluetoothDiscoveryParticipant> connectionParticipants) { <line2> try { <line3> for (BluetoothDiscoveryParticipant participant : connectionParticipants) { <line4> if (device.getConnectionState() != ConnectionState.CONNECTED) { <line5> if (device.getConnectionState() != ConnectionState.CONNECTING && !device.connect()) { <line6> return null; <line7> } <line8> if (!device.awaitConnection(1, TimeUnit.SECONDS)) { <line9> return null; <line10> } <line11> if (!device.isServicesDiscovered()) { <line12> device.discoverServices(); <line13> if (!device.awaitServiceDiscovery(10, TimeUnit.SECONDS)) { <line14> return null; <line15> } <line16> } <line17> readDeviceInformationIfMissing(); <line18> } <line19> try { <line20> DiscoveryResult result = participant.createResult(device); <line21> if (result != null) { <line22> return result; <line23> } <line24> } catch (RuntimeException e) { <line25> } <line26> } <line27> } catch (InterruptedException e) { <line28> } <line29> return null; <line30> } <line31> } <line32> 	<line6>, <line9>, <line14>, <line18>, <line25>
5930	public class A { <line0> @Override <line1> protected void loadInternals(final File nodeInternDir, final ExecutionMonitor exec) <line2> throws CanceledExecutionException { <line3> try { <line4> final File dataDir = new File(nodeInternDir, CFG_DATA_DIR_NAME); <line5> loadPieInternals(dataDir, exec); <line6> } catch (final CanceledExecutionException e) { <line7> throw e; <line8> } catch (final Exception e) { <line9> } <line10> } <line11> } <line12> 	<line9>
5931	public class A { <line0> private void purgeNodes() throws IOException, JSONException { <line1> while (nodesToPurge.peek() != null) { <line2> Long nodeId = nodesToPurge.poll(); <line3> if (nodeId != null) { <line4> this.infoSrv.deleteByNodeId(nodeId); <line5> } <line6> checkShutdown(); <line7> } <line8> } <line9> } <line10> 	<line5>
5932	"public class A { <line0> private List<DownloadFile> downloadEnsemblData(Path geneFolder) <line1> throws IOException, InterruptedException { <line2> List<String> downloadedUrls = new ArrayList<>(4); <line3> List<DownloadFile> downloadFiles = new ArrayList<>(); <line4> String ensemblHost = ensemblHostUrl + ""/"" + ensemblRelease; <line5> if (!configuration.getSpecies().getVertebrates().contains(speciesConfiguration)) { <line6> ensemblHost = ensemblHostUrl + ""/"" + ensemblRelease + ""/"" + getPhylo(speciesConfiguration); <line7> } <line8> String ensemblCollection = """"; <line9> if (configuration.getSpecies().getBacteria().contains(speciesConfiguration)) { <line10> ensemblCollection = speciesConfiguration.getAssemblies().get(0).getEnsemblCollection() + ""/""; <line11> } <line12> String version = ensemblRelease.split(""-"")[1]; <line13> String url = <line14> ensemblHost + ""/gtf/"" + ensemblCollection + speciesShortName + ""/*"" + version + "".gtf.gz""; <line15> String fileName = geneFolder.resolve(speciesShortName + "".gtf.gz"").toString(); <line16> downloadFiles.add(downloadFile(url, fileName)); <line17> downloadedUrls.add(url); <line18> url = ensemblHost + ""/fasta/"" + ensemblCollection + speciesShortName + ""/pep/*.pep.all.fa.gz""; <line19> fileName = geneFolder.resolve(speciesShortName + "".pep.all.fa.gz"").toString(); <line20> downloadFiles.add(downloadFile(url, fileName)); <line21> downloadedUrls.add(url); <line22> url = ensemblHost + ""/fasta/"" + ensemblCollection + speciesShortName + ""/cdna/*.cdna.all.fa.gz""; <line23> fileName = geneFolder.resolve(speciesShortName + "".cdna.all.fa.gz"").toString(); <line24> downloadFiles.add(downloadFile(url, fileName)); <line25> downloadedUrls.add(url); <line26> saveVersionData( <line27> EtlCommons.GENE_DATA, <line28> ENSEMBL_NAME, <line29> ensemblVersion, <line30> getTimeStamp(), <line31> downloadedUrls, <line32> geneFolder.resolve(""ensemblCoreVersion.json"")); <line33> return downloadFiles; <line34> } <line35> } <line36> "	<line2>
5933	public class A { <line0> @Override <line1> public void close() { <line2> super.close(); <line3> if (null == scannerFactory) { <line4> } else { <line5> try { <line6> int nClosed = 0; <line7> scannerFactory.lockdown(); <line8> for (ScannerBase bs : Lists.newArrayList(scannerFactory.currentScanners())) { <line9> scannerFactory.close(bs); <line10> ++nClosed; <line11> } <line12> if (log.isDebugEnabled()) { <line13> } <line14> nClosed = 0; <line15> for (ScannerSession bs : Lists.newArrayList(scannerFactory.currentSessions())) { <line16> scannerFactory.close(bs); <line17> ++nClosed; <line18> } <line19> if (log.isDebugEnabled()) { <line20> } <line21> } catch (Exception e) { <line22> } <line23> } <line24> if (null != this.planner) { <line25> try { <line26> this.planner.close(getConfig(), this.getSettings()); <line27> } catch (Exception e) { <line28> } <line29> } <line30> if (null != this.queries) { <line31> try { <line32> this.queries.close(); <line33> } catch (IOException e) { <line34> } <line35> } <line36> if (null != this.scheduler) { <line37> try { <line38> this.scheduler.close(); <line39> ScanSessionStats stats = this.scheduler.getSchedulerStats(); <line40> if (null != stats) { <line41> stats.logSummary(log); <line42> } <line43> } catch (IOException e) { <line44> } <line45> } <line46> } <line47> } <line48> 	<line3>, <line4>, <line5>, <line13>, <line20>, <line22>, <line26>, <line28>, <line32>, <line34>, <line38>, <line44>
5934	public class A { <line0> public org.talend.mdm.webservice.WSTransformerPK putTransformer( <line1> org.talend.mdm.webservice.WSPutTransformer arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSTransformerPK _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	<line2>
5935	public class A { <line0> protected void stop() { <line1> if (this.getLogger().isDebugEnabled()) { <line2> } <line3> DatabaseManager.closeDatabases(Database.CLOSEMODE_COMPACT); <line4> this.hsqlServer.stop(); <line5> if (this.getLogger().isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> 	<line2>, <line6>
5936	"public class A { <line0> @Override <line1> public void close() { <line2> if (!state.equals(ReaderWriterState.OPEN)) { <line3> return; <line4> } <line5> iterator = null; <line6> try { <line7> incoming.close(); <line8> } catch (IOException e) { <line9> throw new DatasetIOException(""Unable to close reader path:"" + path, e); <line10> } <line11> state = ReaderWriterState.CLOSED; <line12> } <line13> } <line14> "	<line5>
5937	"public class A { <line0> @Override <line1> public void postAnalyze( <line2> HiveSemanticAnalyzerHookContext context, List<Task<? extends Serializable>> rootTasks) <line3> throws SemanticException { <line4> HiveOperation stmtOperation = getCurrentHiveStmtOp(); <line5> HiveAuthzPrivileges stmtAuthObject; <line6> stmtAuthObject = HiveAuthzPrivilegesMap.getHiveAuthzPrivileges(stmtOperation); <line7> Subject subject = getCurrentSubject(context); <line8> Set<String> subjectGroups = hiveAuthzBinding.getGroups(subject); <line9> for (Task<? extends Serializable> task : rootTasks) { <line10> if (task instanceof SentryGrantRevokeTask) { <line11> SentryGrantRevokeTask sentryTask = (SentryGrantRevokeTask) task; <line12> sentryTask.setHiveAuthzBinding(hiveAuthzBinding); <line13> sentryTask.setAuthzConf(authzConf); <line14> sentryTask.setSubject(subject); <line15> sentryTask.setSubjectGroups(subjectGroups); <line16> sentryTask.setIpAddress(context.getIpAddress()); <line17> sentryTask.setOperation(stmtOperation); <line18> } <line19> } <line20> try { <line21> if (stmtAuthObject == null) { <line22> return; <line23> } <line24> for (int i = 0; i < rootTasks.size(); i++) { <line25> Task<? extends Serializable> task = rootTasks.get(i); <line26> if (task instanceof DDLTask) { <line27> SentryFilterDDLTask filterTask = <line28> new SentryFilterDDLTask(hiveAuthzBinding, subject, stmtOperation); <line29> filterTask.setWork((DDLWork) task.getWork()); <line30> rootTasks.set(i, filterTask); <line31> } <line32> } <line33> authorizeWithHiveBindings(context, stmtAuthObject, stmtOperation); <line34> } catch (AuthorizationException e) { <line35> executeOnFailureHooks(context, stmtOperation, e); <line36> StringBuilder permsBuilder = new StringBuilder(); <line37> for (String perm : hiveAuthzBinding.getLastQueryPrivilegeErrors()) { <line38> permsBuilder.append(perm); <line39> permsBuilder.append("";""); <line40> } <line41> String permsRequired = permsBuilder.toString(); <line42> SessionState.get().getConf().set(HiveAuthzConf.HIVE_SENTRY_AUTH_ERRORS, permsRequired); <line43> String msgForLog = <line44> HiveAuthzConf.HIVE_SENTRY_PRIVILEGE_ERROR_MESSAGE <line45> + ""\n Required privileges for this query: "" <line46> + permsRequired; <line47> String msgForConsole = <line48> HiveAuthzConf.HIVE_SENTRY_PRIVILEGE_ERROR_MESSAGE <line49> + ""\n "" <line50> + e.getMessage() <line51> + ""\n The required privileges: "" <line52> + permsRequired; <line53> throw new SemanticException(msgForConsole, e); <line54> } finally { <line55> hiveAuthzBinding.close(); <line56> } <line57> if (""true"" <line58> .equalsIgnoreCase(context.getConf().get(HiveAuthzConf.HIVE_SENTRY_MOCK_COMPILATION))) { <line59> throw new SemanticException( <line60> HiveAuthzConf.HIVE_SENTRY_MOCK_ERROR <line61> + "" Mock query compilation aborted. Set "" <line62> + HiveAuthzConf.HIVE_SENTRY_MOCK_COMPILATION <line63> + "" to 'false' for normal query processing""); <line64> } <line65> } <line66> } <line67> "	<line53>
5938	"public class A { <line0> public static Thread addShutdownHook(final Runnable task) { <line1> Thread t = <line2> new Thread(""shutdownHookThread"") { <line3> public void run() { <line4> try { <line5> task.run(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> }; <line10> Runtime.getRuntime().addShutdownHook(t); <line11> return t; <line12> } <line13> } <line14> "	<line7>
5939	public class A { <line0> @Override <line1> public void connect() { <line2> RPCHook rpcHook = null; <line3> if (null != accessKey <line4> && accessKey.length() > 0 <line5> && null != secretKey <line6> && secretKey.length() > 0) { <line7> SessionCredentials sessionCredentials = new SessionCredentials(); <line8> sessionCredentials.setAccessKey(accessKey); <line9> sessionCredentials.setSecretKey(secretKey); <line10> rpcHook = new AclClientRPCHook(sessionCredentials); <line11> } <line12> rocketMQConsumer = <line13> new DefaultMQPushConsumer( <line14> groupName, <line15> rpcHook, <line16> new AllocateMessageQueueAveragely(), <line17> enableMessageTrace, <line18> customizedTraceTopic); <line19> rocketMQConsumer.setVipChannelEnabled(false); <line20> if (CLOUD_ACCESS_CHANNEL.equals(this.accessChannel)) { <line21> rocketMQConsumer.setAccessChannel(AccessChannel.CLOUD); <line22> } <line23> if (!StringUtils.isEmpty(this.namespace)) { <line24> rocketMQConsumer.setNamespace(this.namespace); <line25> } <line26> if (!StringUtils.isBlank(nameServer)) { <line27> rocketMQConsumer.setNamesrvAddr(nameServer); <line28> } <line29> if (batchSize != -1) { <line30> rocketMQConsumer.setConsumeMessageBatchMaxSize(batchSize); <line31> } <line32> try { <line33> if (rocketMQConsumer == null) { <line34> this.connect(); <line35> } <line36> rocketMQConsumer.subscribe(this.topic, this.filter); <line37> rocketMQConsumer.registerMessageListener( <line38> (MessageListenerOrderly) <line39> (messageExts, context) -> { <line40> context.setAutoCommit(true); <line41> boolean isSuccess = process(messageExts); <line42> if (isSuccess) { <line43> return ConsumeOrderlyStatus.SUCCESS; <line44> } else { <line45> return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; <line46> } <line47> }); <line48> rocketMQConsumer.start(); <line49> } catch (MQClientException ex) { <line50> } <line51> } <line52> } <line53> 	<line50>
5940	"public class A { <line0> @ApiOperation(value = ""Get access contract by ID"") <line1> @GetMapping(path = RestApi.PATH_REFERENTIAL_ID) <line2> public AccessContractDto getById(final @PathVariable(""identifier"") String identifier) <line3> throws UnsupportedEncodingException { <line4> return service.getOne( <line5> buildUiHttpContext(), URLEncoder.encode(identifier, StandardCharsets.UTF_8.toString())); <line6> } <line7> } <line8> "	<line4>
5941	"public class A { <line0> private FileObject addFileToWork(WorkObject work, Resource childResc) throws DepositException { <line1> PID childPid = PIDs.get(childResc.getURI()); <line2> Resource originalResc = DepositModelHelpers.getDatastream(childResc); <line3> String storageString = <line4> originalResc != null ? getPropertyValue(originalResc, CdrDeposit.storageUri) : null; <line5> if (storageString == null) { <line6> throw new DepositException( <line7> ""No staging location provided for child ("" <line8> + childResc.getURI() <line9> + "") of Work object ("" <line10> + work.getPid().getQualifiedId() <line11> + "")""); <line12> } <line13> URI storageUri = URI.create(storageString); <line14> String mimetype = getPropertyValue(originalResc, CdrDeposit.mimetype); <line15> String sha1 = getPropertyValue(originalResc, CdrDeposit.sha1sum); <line16> String md5 = getPropertyValue(originalResc, CdrDeposit.md5sum); <line17> String label = getPropertyValue(originalResc, CdrDeposit.label); <line18> if (label == null) { <line19> label = getPropertyValue(childResc, CdrDeposit.label); <line20> } <line21> Model aipModel = ModelFactory.createDefaultModel(); <line22> Resource aResc = aipModel.getResource(childResc.getURI()); <line23> addAclProperties(childResc, aResc); <line24> populateAIPProperties(childResc, aResc); <line25> FileObject fileObj = null; <line26> for (int retryCnt = 1; retryCnt <= CHECKSUM_RETRIES; retryCnt++) { <line27> try { <line28> fileObj = work.addDataFile(childPid, storageUri, label, mimetype, sha1, md5, aipModel); <line29> break; <line30> } catch (ChecksumMismatchException e) { <line31> if ((CHECKSUM_RETRIES - retryCnt) > 0) { <line32> try { <line33> Thread.sleep(retryCnt * 1000); <line34> } catch (InterruptedException ef) { <line35> throw new JobInterruptedException(e.getMessage()); <line36> } <line37> } else { <line38> failJob(""Unable to ingest "" + childPid.getQualifiedId(), e.getMessage()); <line39> } <line40> } <line41> } <line42> if (storageUri.getScheme().equals(""file"")) { <line43> metricsClient.incrDepositFileThroughput( <line44> getDepositUUID(), Paths.get(storageUri).toFile().length()); <line45> } <line46> addFitsHistory(fileObj, childResc); <line47> addFitsReport(fileObj, childResc); <line48> return fileObj; <line49> } <line50> } <line51> "	<line1>, <line32>
5942	public class A { <line0> @Override <line1> public Object call(Context context, List args) throws FunctionCallException { <line2> try { <line3> String clazzName = (String) (args.get(0)); <line4> String methodName = (String) (args.get(1)); <line5> Class[] argTypes = new Class[args.size() - 2]; <line6> Object[] params = new Object[args.size() - 2]; <line7> for (int i = 0; i < argTypes.length; i++) { <line8> argTypes[i] = args.get(i + 2).getClass(); <line9> params[i] = args.get(i + 2); <line10> } <line11> Class clazz = ClassUtils.getClass(clazzName); <line12> Method method = MethodUtils.getMatchingAccessibleMethod(clazz, methodName, argTypes); <line13> return method.invoke(null, params); <line14> } catch (Exception ex) { <line15> return ex.getMessage(); <line16> } <line17> } <line18> } <line19> 	<line5>, <line15>
5943	"public class A { <line0> public boolean processConfigurations(Object bean) { <line1> if (bean == null) { <line2> return false; <line3> } <line4> Class<?> klass = bean.getClass(); <line5> Service serviceAnnotation = klass.getAnnotation(Service.class); <line6> if (serviceAnnotation == null) { <line7> return false; <line8> } <line9> List<Method> methods = findAnnotatedMethods(bean, Configure.class); <line10> if (methods.isEmpty()) { <line11> return false; <line12> } <line13> for (Method method : methods) { <line14> Configure configure = method.getAnnotation(Configure.class); <line15> String[] channels = configure.value(); <line16> for (String channelName : channels) { <line17> Initializer init = <line18> channel -> { <line19> if (LOGGER.isDebugEnabled()) { <line20> } <line21> invokePrivate(bean, method, channel); <line22> }; <line23> MarkedReference<ServerChannel> initializedChannel = <line24> bayeuxServer.createChannelIfAbsent(channelName, init); <line25> if (!initializedChannel.isMarked()) { <line26> if (configure.configureIfExists()) { <line27> if (LOGGER.isDebugEnabled()) { <line28> } <line29> init.configureChannel(initializedChannel.getReference()); <line30> } else if (configure.errorIfExists()) { <line31> throw new IllegalStateException(""Channel already configured: "" + channelName); <line32> } else { <line33> if (LOGGER.isDebugEnabled()) { <line34> } <line35> } <line36> } <line37> } <line38> } <line39> return true; <line40> } <line41> } <line42> "	<line20>, <line28>, <line34>
5944	"public class A { <line0> public static void dumpMessageToDebugger(AbstractMessage message) { <line1> try { <line2> String result = pipeParser.encode(message); <line3> result = result.replace(""\r"", ""\r\n""); <line4> result = result.replace(""\r\r"", ""\r""); <line5> } catch (HL7Exception e) { <line6> } <line7> } <line8> } <line9> "	<line5>, <line6>
5945	"public class A { <line0> public void removeTableFromGroup(TableName groupName, String schemaName, String tableName) { <line1> Group group = ais.getGroup(groupName); <line2> checkFound(group, ""removing join from group"", ""group"", groupName); <line3> Table table = ais.getTable(schemaName, tableName); <line4> checkFound(table, ""removing join from group"", ""table table"", concat(schemaName, tableName)); <line5> checkInGroup(group, table, ""removing join from group"", ""table table""); <line6> if (table.getParentJoin() != null || !table.getChildJoins().isEmpty()) { <line7> throw new GroupStructureException( <line8> ""Cannot remove table from a group unless "" <line9> + ""it is the only table in the group, group "" <line10> + group.getName() <line11> + "", table "" <line12> + table.getName()); <line13> } <line14> setTablesGroup(table, null); <line15> } <line16> } <line17> "	<line1>
5946	"public class A { <line0> @Override <line1> public Future<Void> deleteResource(ResourceName resourceName) { <line2> Promise<Void> handler = Promise.promise(); <line3> vertx.executeBlocking( <line4> future -> { <line5> try { <line6> if (!Boolean.TRUE.equals( <line7> operation() <line8> .inNamespace(namespace) <line9> .withName(resourceName.toString()) <line10> .withPropagationPolicy(DeletionPropagation.FOREGROUND) <line11> .delete())) { <line12> future.complete(); <line13> } else { <line14> Util.waitFor( <line15> vertx, <line16> ""sync resource deletion "" + resourceName, <line17> ""deleted"", <line18> 1000, <line19> Long.MAX_VALUE, <line20> () -> { <line21> KafkaTopic kafkaTopic = <line22> operation() <line23> .inNamespace(namespace) <line24> .withName(resourceName.toString()) <line25> .get(); <line26> boolean notExists = kafkaTopic == null; <line27> return notExists; <line28> }) <line29> .onComplete(future); <line30> } <line31> } catch (Exception e) { <line32> future.fail(e); <line33> } <line34> }, <line35> handler); <line36> return handler.future(); <line37> } <line38> } <line39> "	<line12>, <line27>
5947	"public class A { <line0> public static int getAssetListEntriesCount(HttpPrincipal httpPrincipal, long[] groupIds) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey( <line4> AssetListEntryServiceUtil.class, <line5> ""getAssetListEntriesCount"", <line6> _getAssetListEntriesCountParameterTypes20); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, groupIds); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line13> } <line14> return ((Integer) returnObj).intValue(); <line15> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	<line16>
5948	public class A { <line0> @Override <line1> public void process(IQ reqIQ) throws Exception { <line2> request = reqIQ; <line3> if (request.getType().equals(Type.get)) { <line4> this.searchGet.process(request); <line5> return; <line6> } else if (request.getType().equals(Type.set)) { <line7> this.searchSet.process(request); <line8> return; <line9> } <line10> IQ response = IQ.createResultIQ(request); <line11> response.setType(IQ.Type.error); <line12> PacketError error = new PacketError(PacketError.Condition.bad_request, PacketError.Type.modify); <line13> response.setError(error); <line14> outQueue.put(response); <line15> } <line16> } <line17> 	<line4>, <line7>
5949	public class A { <line0> private String render(String str) { <line1> String ret = str; <line2> Map<String, WeblogEntryPlugin> inPlugins = getWebsite().getInitializedPlugins(); <line3> if (str != null && inPlugins != null) { <line4> List entryPlugins = getPluginsList(); <line5> if (entryPlugins != null && !entryPlugins.isEmpty()) { <line6> for (Map.Entry<String, WeblogEntryPlugin> entry : inPlugins.entrySet()) { <line7> if (entryPlugins.contains(entry.getKey())) { <line8> WeblogEntryPlugin pagePlugin = entry.getValue(); <line9> try { <line10> ret = pagePlugin.render(this, ret); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> } <line16> } <line17> return HTMLSanitizer.conditionallySanitize(ret); <line18> } <line19> } <line20> 	<line2>, <line12>
5950	public class A { <line0> @Override <line1> public void requestInitialized(ServletRequestEvent servletRequestEvent) { <line2> Request request = ((Request) servletRequestEvent.getServletRequest()); <line3> } <line4> } <line5> 	<line3>
5951	public class A { <line0> public byte[] toJson(Object value) { <line1> byte[] result = null; <line2> if (isJsonString(value)) { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> result = ((String) value).getBytes(StandardCharsets.UTF_8); <line6> } <line7> return result; <line8> } <line9> } <line10> 	<line4>
5952	public class A { <line0> protected static Double cast(final Object dataObj) { <line1> if (dataObj == null) { <line2> return null; <line3> } <line4> if (Integer.class.equals(dataObj.getClass())) return (Integer) dataObj + 0.0; <line5> if (Double.class.equals(dataObj.getClass())) return (Double) dataObj; <line6> if (Boolean.class.equals(dataObj.getClass())) return (Boolean) dataObj ? 1.0 : 0.0; <line7> if (String.class.equals(dataObj.getClass())) { <line8> final String sdata = (String) dataObj; <line9> try { <line10> return Double.valueOf(sdata); <line11> } catch (NumberFormatException | ClassCastException e) { <line12> } <line13> try { <line14> return Integer.valueOf(sdata) + 0.0; <line15> } catch (final NumberFormatException e) { <line16> } <line17> try { <line18> return Boolean.valueOf(sdata) ? 1.0 : 0.0; <line19> } catch (final NumberFormatException e) { <line20> } <line21> } <line22> return 42.0; <line23> } <line24> } <line25> 	<line2>, <line22>
5953	public class A { <line0> public DocumentVo toDocumentVo() { <line1> DocumentVo documentVo = new DocumentVo(); <line2> if (ssrDocsType != null) { <line3> documentVo.setDocumentType(ssrDocsType.toString()); <line4> } <line5> documentVo.setDocumentNumber(travelDocNumber); <line6> documentVo.setIssuanceCountry(issueingCountryState); <line7> try { <line8> if (StringUtils.isNotBlank(travelDocumentExpirationDate)) { <line9> documentVo.setExpirationDate( <line10> ParseUtils.parseDateTime(travelDocumentExpirationDate, DOC_DATE_FORMAT)); <line11> } <line12> } catch (Exception ignored) { <line13> } <line14> return documentVo; <line15> } <line16> } <line17> 	<line13>
5954	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public List<E> getByCriteriaWithAliasByOrder( <line3> Criterion criterion, <line4> String order, <line5> String[] orderBy, <line6> Integer count, <line7> String aliasTable, <line8> Criterion aliasCriterion) { <line9> Session session = getCurrentSession(); <line10> List<E> fetchedList = new ArrayList<E>(); <line11> Criteria criteria = session.createCriteria(entityClass); <line12> criteria.add(criterion); <line13> criteria <line14> .createAlias(aliasTable, aliasTable, org.hibernate.sql.JoinType.LEFT_OUTER_JOIN) <line15> .add(aliasCriterion); <line16> if (orderBy != null) { <line17> for (int i = 0; i < orderBy.length; i++) { <line18> if (order != null && order.equalsIgnoreCase(""desc"")) { <line19> criteria.addOrder(Order.desc(orderBy[i])); <line20> } else { <line21> criteria.addOrder(Order.asc(orderBy[i])); <line22> } <line23> } <line24> } <line25> if (count != null && count > 0) { <line26> criteria.setMaxResults(count); <line27> } <line28> try { <line29> fetchedList = criteria.list(); <line30> return fetchedList; <line31> } catch (Exception e) { <line32> throw new HibernateException( <line33> ""getByCriteriaWithAliasByOrder failed, criteria = "" + criterion.toString()); <line34> } <line35> } <line36> } <line37> "	<line32>
5955	public class A { <line0> public void updateAlertDefinition(StatAlertDefinition[] defns, int actionCode) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> synchronized (alertDefinitionsMap) { <line4> if (actionCode == UpdateAlertDefinitionMessage.REMOVE_ALERT_DEFINITION) { <line5> for (int i = 0; i < defns.length; i++) { <line6> alertDefinitionsMap.remove(Integer.valueOf(defns[i].getId())); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> } <line10> } else { <line11> StatAlertDefinition[] alertDefns = this.createMemberStatAlertDefinition(dm, defns); <line12> StatAlertDefinition defn; <line13> for (int i = 0; i < alertDefns.length; i++) { <line14> defn = alertDefns[i]; <line15> alertDefinitionsMap.put(Integer.valueOf(defns[i].getId()), defn); <line16> } <line17> } <line18> } <line19> if (logger.isDebugEnabled()) { <line20> } <line21> } <line22> } <line23> 	<line2>, <line8>, <line20>
5956	public class A { <line0> public List<CosemObject> filterMeterValues(List<CosemObject> cosemObjects) { <line1> List<CosemObject> filteredValues = <line2> cosemObjects.stream() <line3> .filter( <line4> cosemObject -> <line5> supportedIdentifiers.contains( <line6> cosemObject.getObisIdentifier().getReducedOBISIdentifier())) <line7> .collect(Collectors.toList()); <line8> return filteredValues; <line9> } <line10> } <line11> 	<line1>
5957	"public class A { <line0> @Override <line1> public Answer execute( <line2> final OvsFetchInterfaceCommand command, final CitrixResourceBase citrixResourceBase) { <line3> String label = command.getLabel(); <line4> if (citrixResourceBase.isXcp()) { <line5> label = citrixResourceBase.getLabel(); <line6> } <line7> final Connection conn = citrixResourceBase.getConnection(); <line8> try { <line9> final XsLocalNetwork nw = citrixResourceBase.getNetworkByName(conn, label); <line10> if (nw == null) { <line11> throw new CloudRuntimeException( <line12> ""Unable to locate the network with name-label: "" <line13> + label <line14> + "" on host: "" <line15> + citrixResourceBase.getHost().getIp()); <line16> } <line17> final PIF pif = nw.getPif(conn); <line18> final PIF.Record pifRec = pif.getRecord(conn); <line19> return new OvsFetchInterfaceAnswer( <line20> command, <line21> true, <line22> ""Interface "" + pifRec.device + "" retrieved successfully"", <line23> pifRec.IP, <line24> pifRec.netmask, <line25> pifRec.MAC); <line26> } catch (final BadServerResponse e) { <line27> s_logger.error( <line28> ""An error occurred while fetching the interface for "" <line29> + label <line30> + "" on host "" <line31> + citrixResourceBase.getHost().getIp(), <line32> e); <line33> return new OvsFetchInterfaceAnswer(command, false, ""EXCEPTION:"" + e.getMessage()); <line34> } catch (final XenAPIException e) { <line35> s_logger.error( <line36> ""An error occurred while fetching the interface for "" <line37> + label <line38> + "" on host "" <line39> + citrixResourceBase.getHost().getIp(), <line40> e); <line41> return new OvsFetchInterfaceAnswer(command, false, ""EXCEPTION:"" + e.getMessage()); <line42> } catch (final XmlRpcException e) { <line43> return new OvsFetchInterfaceAnswer(command, false, ""EXCEPTION:"" + e.getMessage()); <line44> } <line45> } <line46> } <line47> "	<line7>, <line17>, <line19>, <line43>
5958	"public class A { <line0> @BeforeClass <line1> public static void setup() { <line2> logger.info(""========================================================""); <line3> } <line4> } <line5> "	<line3>
5959	public class A { <line0> public org.apache.thrift.async.AsyncMethodCallback< <line1> org.apache.accumulo.core.master.thrift.TabletServerStatus> <line2> getResultHandler( <line3> final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, <line4> final int seqid) { <line5> final org.apache.thrift.AsyncProcessFunction fcall = this; <line6> return new org.apache.thrift.async.AsyncMethodCallback< <line7> org.apache.accumulo.core.master.thrift.TabletServerStatus>() { <line8> public void onComplete(org.apache.accumulo.core.master.thrift.TabletServerStatus o) { <line9> getTabletServerStatus_result result = new getTabletServerStatus_result(); <line10> result.success = o; <line11> try { <line12> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line13> } catch (org.apache.thrift.transport.TTransportException e) { <line14> fb.close(); <line15> } catch (java.lang.Exception e) { <line16> onError(e); <line17> } <line18> } <line19>  <line20> public void onError(java.lang.Exception e) { <line21> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line22> org.apache.thrift.TSerializable msg; <line23> getTabletServerStatus_result result = new getTabletServerStatus_result(); <line24> if (e instanceof org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException) { <line25> result.sec = (org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException) e; <line26> result.setSecIsSet(true); <line27> msg = result; <line28> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line29> fb.close(); <line30> return; <line31> } else if (e instanceof org.apache.thrift.TApplicationException) { <line32> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line33> msg = (org.apache.thrift.TApplicationException) e; <line34> } else { <line35> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line36> msg = <line37> new org.apache.thrift.TApplicationException( <line38> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line39> } <line40> try { <line41> fcall.sendResponse(fb, msg, msgType, seqid); <line42> } catch (java.lang.Exception ex) { <line43> fb.close(); <line44> } <line45> } <line46> }; <line47> } <line48> } <line49> 	<line14>, <line16>, <line29>, <line32>, <line35>, <line43>
5960	public class A { <line0> private JRDataSource createQueryDatasource() throws JRException { <line1> if (query == null) { <line2> return null; <line3> } <line4> try { <line5> if (log.isDebugEnabled()) { <line6> } <line7> QueryExecuterFactory queryExecuterFactory = <line8> JRQueryExecuterUtils.getInstance(getJasperReportsContext()) <line9> .getExecuterFactory(query.getLanguage()); <line10> SimpleQueryExecutionContext queryExecutionContext = <line11> SimpleQueryExecutionContext.of(getJasperReportsContext(), getRepositoryContext()); <line12> queryExecuter = <line13> queryExecuterFactory.createQueryExecuter(queryExecutionContext, this, parametersMap); <line14> filler.fillContext.setRunningQueryExecuter(queryExecuter); <line15> return queryExecuter.createDatasource(); <line16> } finally { <line17> filler.fillContext.clearRunningQueryExecuter(); <line18> } <line19> } <line20> } <line21> 	<line6>
5961	public class A { <line0> @Override <line1> public void doPostRollback(IndexWriter writer) throws IOException { <line2> Path path = directory.getPath(); <line3> String name = path.getName(); <line4> fileSystem.rename(path, new Path(path.getParent(), rename(name, BADROWIDS))); <line5> } <line6> } <line7> 	<line2>
5962	public class A { <line0> protected void receive(org.jgroups.Message jgmsg, boolean fromQuorumChecker) { <line1> long startTime = services.getStatistics().startUDPDispatchRequest(); <line2> try { <line3> if (services.getManager().shutdownInProgress()) { <line4> return; <line5> } <line6> if (logger.isTraceEnabled()) { <line7> } <line8> byte[] contents = jgmsg.getBuffer(); <line9> if (contents == null) { <line10> return; <line11> } <line12> if (pingPonger.isPingMessage(contents)) { <line13> try { <line14> pingPonger.sendPongMessage(myChannel, jgAddress, jgmsg.getSrc()); <line15> } catch (Exception e) { <line16> } <line17> return; <line18> } else if (pingPonger.isPongMessage(contents)) { <line19> pongsReceived.incrementAndGet(); <line20> return; <line21> } <line22> Object o = readJGMessage(jgmsg); <line23> if (o == null) { <line24> return; <line25> } <line26> Message<ID> msg = (Message<ID>) o; <line27> if ((services.getConfig().getVmKind() == MemberIdentifier.ADMIN_ONLY_DM_TYPE) <line28> && (msg instanceof CacheOperationMessageMarker)) { <line29> return; <line30> } <line31> msg.resetTimestamp(); <line32> msg.setBytesRead(jgmsg.getLength()); <line33> try { <line34> if (logger.isTraceEnabled()) { <line35> } <line36> filterIncomingMessage(msg); <line37> MessageHandler<Message<ID>> handler = getMessageHandler(msg); <line38> if (fromQuorumChecker && (handler instanceof HealthMonitor || handler instanceof Manager)) { <line39> } else { <line40> handler.processMessage(msg); <line41> } <line42> NakAckHeader2 header = (NakAckHeader2) jgmsg.getHeader(nackack2HeaderId); <line43> if (header != null && !jgmsg.isFlagSet(Flag.OOB)) { <line44> recordScheduledSeqno(msg.getSender(), header.getSeqno()); <line45> } <line46> } catch (MemberShunnedException e) { <line47> } <line48> } finally { <line49> JGroupsMessenger.this.services.getStatistics().endUDPDispatchRequest(startTime); <line50> } <line51> } <line52> } <line53> 	<line7>, <line16>, <line35>
5963	public class A { <line0> public void buildMatcherArray() { <line1> String query = null; <line2> while ((query = getNextQueryObject()) != null) { <line3> matcherArray.add(serializeQuery(query)); <line4> } <line5> } <line6> } <line7> 	<line1>, <line3>
5964	public class A { <line0> @PreDestroy <line1> public void stop() { <line2> if (logger.isInfoEnabled()) { <line3> } <line4> if (acceptor != null) { <line5> acceptor.close(); <line6> } <line7> if (logger.isInfoEnabled()) { <line8> } <line9> } <line10> } <line11> 	<line3>, <line8>
5965	"public class A { <line0> public boolean putResponse(ResponseInfo info) { <line1> long requestID = info.getRequestID(); <line2> RsfFuture rsfFuture = this.rsfResponse.get(requestID); <line3> if (rsfFuture == null) { <line4> invLogger.warn( <line5> ""response({}) -> timeoutFailed, RsfFuture is not exist. -> maybe is timeout!"", requestID); <line6> return false; <line7> } <line8> if (info.getStatus() == ProtocolStatus.Accept) { <line9> if (!rsfFuture.getRequest().isMessage()) { <line10> return true; <line11> } <line12> } <line13> rsfFuture = this.removeRsfFuture(requestID); <line14> if (rsfFuture == null) { <line15> return false; <line16> } <line17> RsfRequest rsfRequest = rsfFuture.getRequest(); <line18> RsfResponseObject local = new RsfResponseObject(rsfRequest); <line19> local.addOptionMap(info); <line20> local.sendStatus(info.getStatus()); <line21> String serializeType = info.getSerializeType(); <line22> String bindID = local.getBindInfo().getBindID(); <line23> Method callMethod = rsfRequest.getMethod(); <line24> if (rsfRequest.isMessage()) { <line25> Class<?> returnType = rsfRequest.getMethod().getReturnType(); <line26> RsfResultDO returnObject = null; <line27> if (info.getStatus() == ProtocolStatus.Accept) { <line28> returnObject = new RsfResultDO(requestID, true); <line29> } else { <line30> returnObject = new RsfResultDO(requestID, false); <line31> returnObject.setErrorCode(info.getStatus()); <line32> returnObject.setErrorMessage(info.getOption(""message"")); <line33> } <line34> if (returnObject.isSuccess()) { <line35> if (returnType.isAssignableFrom(RsfResult.class)) { <line36> local.sendData(returnObject); <line37> return rsfFuture.completed(local); <line38> } <line39> if (returnObject.isSuccess()) { <line40> local.sendData(null); <line41> return rsfFuture.completed(local); <line42> } <line43> } <line44> String errorInfo = <line45> ""errorCode = "" <line46> + returnObject.getErrorCode() <line47> + "", errorMessage="" <line48> + returnObject.getErrorMessage(); <line49> return rsfFuture.failed(new RsfException(local.getStatus(), errorInfo)); <line50> } <line51> if (info.getStatus() == ProtocolStatus.OK) { <line52> local.sendData(info.getReturnData()); <line53> return rsfFuture.completed(local); <line54> } else { <line55> return rsfFuture.failed(new RsfException(local.getStatus(), ""status."")); <line56> } <line57> } <line58> } <line59> "	<line10>, <line15>, <line24>, <line35>, <line49>, <line55>
5966	public class A { <line0> @Async <line1> public Future<Set<ObjectClassInfo>> getObjectClassInfo(final ConnectorFacade connector) { <line2> Set<ObjectClassInfo> result = Set.of(); <line3> try { <line4> result = connector.schema().getObjectClassInfo(); <line5> } catch (Exception e) { <line6> } <line7> return new AsyncResult<>(result); <line8> } <line9> } <line10> 	<line6>
5967	"public class A { <line0> public Process start() throws ExecutorException { <line1> if (alreadyPerformed) { <line2> throw new ExecutorException(""Multiple execution attempt.""); <line3> } <line4> ProcessBuilder pb = getProcessBuilder(); <line5> try { <line6> process = pb.start(); <line7> pid = Platform.getPID(process); <line8> addToGlobalGC(process, pid); <line9> return process; <line10> } catch (Exception e) { <line11> throw new ExecutorException(e.getMessage(), e); <line12> } finally { <line13> alreadyPerformed = true; <line14> } <line15> } <line16> } <line17> "	<line5>, <line14>
5968	public class A { <line0> private void parseClientNonce(ClientEsniInner clientEsniInne) { <line1> byte[] clientNonce = parseByteArrayField(ExtensionByteLength.NONCE); <line2> clientEsniInne.setClientNonce(clientNonce); <line3> } <line4> } <line5> 	<line3>
5969	public class A { <line0> private static SubjectConfirmationData createSubjectConfirmationData( <line1> final KeyInfoBean keyInforBean, final SubjectConfirmationDataBean confirDataBean) <line2> throws SAMLComponentBuilderException { <line3> try { <line4> return SAML2ComponentBuilder.createSubjectConfirmationData(confirDataBean, keyInforBean); <line5> } catch (SecurityException | WSSecurityException e) { <line6> throw new SAMLComponentBuilderException(e.getLocalizedMessage(), e); <line7> } <line8> } <line9> } <line10> 	<line6>
5970	public class A { <line0> @Override <line1> public void run() { <line2> for (ByteString topic : top2sub2seq.keySet()) { <line3> final Map<ByteString, InMemorySubscriptionState> topicSubscriptions = top2sub2seq.get(topic); <line4> if (topicSubscriptions == null) { <line5> continue; <line6> } <line7> long minConsumedMessage = Long.MAX_VALUE; <line8> boolean hasBound = true; <line9> for (InMemorySubscriptionState curSubscription : topicSubscriptions.values()) { <line10> if (curSubscription.getLastPersistedSeqId() < minConsumedMessage) { <line11> minConsumedMessage = curSubscription.getLastPersistedSeqId(); <line12> } <line13> hasBound = hasBound && curSubscription.getSubscriptionPreferences().hasMessageBound(); <line14> } <line15> Long minConsumedFromMap = topic2MinConsumedMessagesMap.get(topic); <line16> if (topicSubscriptions.isEmpty() <line17> || (minConsumedFromMap != null && minConsumedFromMap < minConsumedMessage) <line18> || (minConsumedFromMap == null && minConsumedMessage != 0)) { <line19> topic2MinConsumedMessagesMap.put(topic, minConsumedMessage); <line20> if (logger.isDebugEnabled()) { <line21> } <line22> pm.consumedUntil(topic, minConsumedMessage); <line23> } else if (hasBound) { <line24> pm.consumeToBound(topic); <line25> } <line26> } <line27> } <line28> } <line29> 	<line21>
5971	"public class A { <line0> @RequestMapping( <line1> value = ""/deleteAttribute.action"", <line2> method = {RequestMethod.GET}) <line3> @ResponseBody <line4> public Map<String, Object> deleteAttribute(@RequestParam Integer id) { <line5> try { <line6> boolean success = taggerService.deleteAttribute(id); <line7> if (success) { <line8> return getUIWrapper(true, ""Attribute was successful deleted""); <line9> } else { <line10> return getUIWrapper(false, ""Error while deleting attribute in Tagger""); <line11> } <line12> } catch (Exception e) { <line13> return getUIWrapper(false, e.getMessage()); <line14> } <line15> } <line16> } <line17> "	<line13>
5972	public class A { <line0> @Override <line1> public void doRun() { <line2> if (!cluster.isConnected() || !cluster.isHealthy()) { <line3> return; <line4> } <line5> final Set<String> indexNames = ImmutableSet.copyOf(indexSetRegistry.getManagedIndices()); <line6> final SortedSet<IndexRange> indexRanges = indexRangeService.findAll(); <line7> final Set<String> removedIndices = new HashSet<>(); <line8> for (IndexRange indexRange : indexRanges) { <line9> if (!indexNames.contains(indexRange.indexName())) { <line10> removedIndices.add(indexRange.indexName()); <line11> } <line12> } <line13> if (!removedIndices.isEmpty()) { <line14> eventBus.post(IndicesDeletedEvent.create(removedIndices)); <line15> } <line16> } <line17> } <line18> 	<line3>, <line14>
5973	public class A { <line0> protected RestContainer assertParseRestAsJaxb(String uri) throws JAXBException { <line1> Object value = parseUri(uri); <line2> RestContainer context = assertIsInstanceOf(RestContainer.class, value); <line3> return context; <line4> } <line5> } <line6> 	<line3>
5974	"public class A { <line0> private static FileObject findDataCleanerHome() throws FileSystemException { <line1> final FileSystemManager manager = VFSUtils.getFileSystemManager(); <line2> FileObject candidate = null; <line3> String path = System.getenv(""DATACLEANER_HOME""); <line4> if (!StringUtils.isNullOrEmpty(path)) { <line5> } else { <line6> path = System.getProperty(""DATACLEANER_HOME""); <line7> if (!StringUtils.isNullOrEmpty(path)) { <line8> candidate = manager.resolveFile(path); <line9> } <line10> } <line11> if (!StringUtils.isNullOrEmpty(path)) { <line12> if (path.startsWith(""~"")) { <line13> final String userHomePath = System.getProperty(""user.home""); <line14> path = path.replace(""~"", userHomePath); <line15> } <line16> candidate = manager.resolveFile(path); <line17> } <line18> if (isUsable(candidate)) { <line19> return candidate; <line20> } else { <line21> return initializeDataCleanerHome(candidate); <line22> } <line23> } <line24> } <line25> "	<line5>, <line9>
5975	"public class A { <line0> public HiveStats getStats(final HiveReadEntry hiveReadEntry) throws IOException { <line1> Stopwatch timeGetStats = Stopwatch.createStarted(); <line2> HiveTableWithColumnCache table = hiveReadEntry.getTable(); <line3> try { <line4> if (!isPartitionedTable) { <line5> Properties properties = new Table(table).getMetadata(); <line6> HiveStats stats = HiveStats.getStatsFromProps(properties); <line7> if (stats.valid()) { <line8> return stats; <line9> } <line10> return stats.getSizeInBytes() > 0 <line11> ? estimateStatsFromBytes(stats.getSizeInBytes()) <line12> : estimateStatsFromInputSplits(getTableInputSplits()); <line13> } else { <line14> HiveStats aggStats = new HiveStats(0, 0); <line15> for (HivePartition partition : hiveReadEntry.getPartitions()) { <line16> Properties properties = HiveUtilities.getPartitionMetadata(partition, table); <line17> HiveStats stats = HiveStats.getStatsFromProps(properties); <line18> if (!stats.valid()) { <line19> stats = <line20> stats.getSizeInBytes() > 0 <line21> ? estimateStatsFromBytes(stats.getSizeInBytes()) <line22> : estimateStatsFromInputSplits(getPartitionInputSplits(partition)); <line23> } <line24> aggStats.add(stats); <line25> } <line26> return aggStats; <line27> } <line28> } catch (Exception e) { <line29> throw new IOException(""Failed to get number of rows and total size from HiveTable"", e); <line30> } finally { <line31> } <line32> } <line33> } <line34> "	<line31>
5976	"public class A { <line0> @Override <line1> public RemoteEnvironment createEnvironment(Environment environment, String workerId) <line2> throws Exception { <line3> Preconditions.checkState( <line4> environment <line5> .getUrn() <line6> .equals(BeamUrns.getUrn(RunnerApi.StandardEnvironments.Environments.PROCESS)), <line7> ""The passed environment does not contain a ProcessPayload.""); <line8> final RunnerApi.ProcessPayload processPayload = <line9> RunnerApi.ProcessPayload.parseFrom(environment.getPayload()); <line10> String executable = processPayload.getCommand(); <line11> String provisionEndpoint = provisioningServiceServer.getApiServiceDescriptor().getUrl(); <line12> String semiPersistDir = pipelineOptions.as(RemoteEnvironmentOptions.class).getSemiPersistDir(); <line13> ImmutableList.Builder<String> argsBuilder = <line14> ImmutableList.<String>builder() <line15> .add(String.format(""--id=%s"", workerId)) <line16> .add(String.format(""--provision_endpoint=%s"", provisionEndpoint)); <line17> if (semiPersistDir != null) { <line18> argsBuilder.add(String.format(""--semi_persist_dir=%s"", semiPersistDir)); <line19> } <line20> InstructionRequestHandler instructionHandler = null; <line21> try { <line22> ProcessManager.RunningProcess process = <line23> processManager.startProcess( <line24> workerId, executable, argsBuilder.build(), processPayload.getEnvMap()); <line25> while (instructionHandler == null) { <line26> try { <line27> process.isAliveOrThrow(); <line28> instructionHandler = clientSource.take(workerId, Duration.ofSeconds(5)); <line29> } catch (TimeoutException timeoutEx) { <line30> } catch (InterruptedException interruptEx) { <line31> Thread.currentThread().interrupt(); <line32> throw new RuntimeException(interruptEx); <line33> } <line34> } <line35> } catch (Exception e) { <line36> try { <line37> processManager.stopProcess(workerId); <line38> } catch (Exception processKillException) { <line39> e.addSuppressed(processKillException); <line40> } <line41> throw e; <line42> } <line43> return ProcessEnvironment.create(processManager, environment, workerId, instructionHandler); <line44> } <line45> } <line46> "	<line20>, <line30>
5977	"public class A { <line0> @Override <line1> public void beforeConfiguration(ITestResult tr, ITestNGMethod tm) { <line2> try { <line3> Field configListenersField = <line4> this.getClass().getSuperclass().getDeclaredField(""configListeners""); <line5> configListenersField.setAccessible(true); <line6> List<IConfigurationListener> listeners = <line7> (List<IConfigurationListener>) configListenersField.get(this); <line8> invokeListeners(tr, tm, listeners); <line9> } catch (NoSuchFieldException | IllegalAccessException e) { <line10> } <line11> } <line12> } <line13> "	<line10>
5978	public class A { <line0> @Override <line1> public void close() { <line2> try { <line3> if (fnWorkerService != null) { <line4> fnWorkerService.stop(); <line5> } <line6> if (broker != null) { <line7> broker.close(); <line8> } <line9> if (bkEnsemble != null) { <line10> bkEnsemble.stop(); <line11> } <line12> } catch (Exception e) { <line13> } <line14> } <line15> } <line16> 	<line13>
5979	public class A { <line0> void removeForwardingForEndpoint(RendererEndpointKey rEpKey, PolicyContext policyCtx) { <line1> AddressEndpointWithLocation rEp = <line2> policyCtx.getAddrEpByKey().get(KeyFactory.addressEndpointKey(rEpKey)); <line3> ExternalLocationCase rEpLoc = resolveAndValidateLocation(rEp); <line4> if (ConfigUtil.getInstance().isLispOverlayEnabled()) { <line5> lispStateManager.processDeleteEndpoint(rEp); <line6> if (ConfigUtil.getInstance().isL3FlatEnabled()) { <line7> flatOverlayManager.deleteStaticRoutingEntry(rEp); <line8> } <line9> } <line10> if (rEpLoc == null || Strings.isNullOrEmpty(rEpLoc.getExternalNodeConnector())) { <line11> return; <line12> } <line13> if (!Strings.isNullOrEmpty(rEpLoc.getExternalNode())) { <line14> try { <line15> ifaceManager.deleteBridgeDomainFromInterface(rEp).get(); <line16> } catch (InterruptedException | ExecutionException e) { <line17> } <line18> } else { <line19> } <line20> } <line21> } <line22> 	<line16>, <line17>, <line19>
5980	public class A { <line0> @Override <line1> public List<ParagraphInfo> getParagraphList(String user, String noteId) <line2> throws InterpreterRPCException, TException { <line3> if (user != null && noteId != null) { <line4> List<ParagraphInfo> paragraphInfos = null; <line5> try { <line6> paragraphInfos = listener.getParagraphList(user, noteId); <line7> } catch (IOException e) { <line8> throw new InterpreterRPCException(e.toString()); <line9> } <line10> return paragraphInfos; <line11> } else { <line12> return Collections.emptyList(); <line13> } <line14> } <line15> } <line16> 	<line3>, <line12>
5981	"public class A { <line0> protected Script getControllerScript( <line1> SiteContext siteContext, HttpServletRequest request, String pageUrl) { <line2> ScriptFactory scriptFactory = siteContext.getScriptFactory(); <line3> if (scriptFactory == null) { <line4> throw new IllegalStateException( <line5> ""No script factory associated to current site context '"" <line6> + siteContext.getSiteName() <line7> + ""'""); <line8> } <line9> String scriptUrl = getScriptUrl(siteContext, scriptFactory, request, pageUrl); <line10> try { <line11> if (storeService.exists(siteContext.getContext(), scriptUrl)) { <line12> if (logger.isDebugEnabled()) { <line13> } <line14> return scriptFactory.getScript(scriptUrl); <line15> } else if (logger.isDebugEnabled()) { <line16> } <line17> } catch (CrafterException e) { <line18> } <line19> return null; <line20> } <line21> } <line22> "	<line13>, <line16>, <line18>
5982	public class A { <line0> private void addAllowedHeaderIfValid(String headerName, HttpServletResponse response) { <line1> if (isValidHttpHeaderName(headerName)) { <line2> response.addHeader(ACCESS_CONTROL_ALLOW_HEADERS, headerName); <line3> } else { <line4> } <line5> } <line6> } <line7> 	<line4>
5983	"public class A { <line0> public static WorkplaceSearchClient getInstance(Path config, FsSettings settings, int version) <line1> throws ClassNotFoundException { <line2> Objects.requireNonNull(settings, ""settings can not be null""); <line3> if (settings.getWorkplaceSearch() == null) { <line4> return null; <line5> } <line6> Class<WorkplaceSearchClient> clazz = null; <line7> try { <line8> clazz = findClass(version); <line9> } catch (ClassNotFoundException e) { <line10> } <line11> if (clazz == null) { <line12> throw new ClassNotFoundException( <line13> ""Can not find any WorkplaceSearchClient in the classpath. "" <line14> + ""Did you forget to add the elasticsearch client library?""); <line15> } <line16> try { <line17> Constructor<? extends WorkplaceSearchClient> constructor = <line18> clazz.getConstructor(Path.class, FsSettings.class); <line19> return constructor.newInstance(config, settings); <line20> } catch (NoSuchMethodException e) { <line21> throw new IllegalArgumentException( <line22> ""Class "" + clazz.getName() + "" does not have the expected ctor (Path, FsSettings)."", e); <line23> } catch (IllegalAccessException | InstantiationException | InvocationTargetException e) { <line24> throw new IllegalArgumentException(""Can not create an instance of "" + clazz.getName(), e); <line25> } <line26> } <line27> } <line28> "	<line10>, <line16>
5984	"public class A { <line0> public PinData[] publishPinArray(int[] data) { <line1> int pinDataCnt = data.length / 3; <line2> PinData[] pinArray = new PinData[pinDataCnt]; <line3> for (int i = 0; i < pinArray.length; ++i) { <line4> int address = data[3 * i]; <line5> PinDefinition pinDef = getPin(address); <line6> if (pinDef == null) { <line7> continue; <line8> } <line9> int value = Serial.bytesToInt(data, (3 * i) + 1, 2); <line10> PinData pinData = new PinData(pinDef.getPinName(), value); <line11> pinDef.setValue(value); <line12> pinArray[i] = pinData; <line13> if (pinListeners.containsKey(address)) { <line14> Set<PinListener> set = pinListeners.get(address); <line15> for (PinListener pinListner : set) { <line16> if (pinListner.isLocal()) { <line17> pinListner.onPin(pinData); <line18> } else { <line19> invoke(""publishPin"", pinData); <line20> } <line21> } <line22> } <line23> } <line24> HashMap<String, PinData> pinDataMap = new HashMap<String, PinData>(); <line25> for (int i = 0; i < pinArray.length; i++) { <line26> if (pinArray[i] != null && pinArray[i].pin != null) { <line27> pinDataMap.put(pinArray[i].pin, pinArray[i]); <line28> } <line29> } <line30> for (String name : pinArrayListeners.keySet()) { <line31> PinArrayListener pal = pinArrayListeners.get(name); <line32> if (pal.getActivePins() != null && pal.getActivePins().length > 0) { <line33> int numActive = pal.getActivePins().length; <line34> PinData[] subArray = new PinData[numActive]; <line35> for (int i = 0; i < numActive; i++) { <line36> String key = pal.getActivePins()[i]; <line37> if (pinDataMap.containsKey(key)) { <line38> subArray[i] = pinDataMap.get(key); <line39> } else { <line40> subArray[i] = null; <line41> } <line42> } <line43> pal.onPinArray(subArray); <line44> } else { <line45> pal.onPinArray(pinArray); <line46> } <line47> } <line48> return pinArray; <line49> } <line50> } <line51> "	<line1>, <line7>
5985	public class A { <line0> public void disconnect() { <line1> JmsUtils.closeQuietly(connection); <line2> } <line3> } <line4> 	<line1>
5986	public class A { <line0> public VariantStudyMetadata getVariantStudyMetadata(String studyId) { <line1> if (studyId != null) { <line2> if (variantMetadata.getStudies() == null) { <line3> variantMetadata.setStudies(new ArrayList<>()); <line4> } <line5> for (VariantStudyMetadata study : variantMetadata.getStudies()) { <line6> if (studyId.equals(study.getId())) { <line7> return study; <line8> } <line9> } <line10> } else { <line11> } <line12> return null; <line13> } <line14> } <line15> 	<line11>
5987	"public class A { <line0> private void init() throws Exception { <line1> this.depResolver = <line2> new DependencyResolver(zconf.getString(ConfVars.ZEPPELIN_INTERPRETER_LOCALREPO)); <line3> InterpreterOutput.limit = zconf.getInt(ConfVars.ZEPPELIN_INTERPRETER_OUTPUT_LIMIT); <line4> HeliumApplicationFactory heliumApplicationFactory = new HeliumApplicationFactory(); <line5> HeliumVisualizationFactory heliumVisualizationFactory; <line6> if (isBinaryPackage(zconf)) { <line7> heliumVisualizationFactory = <line8> new HeliumVisualizationFactory( <line9> zconf, <line10> new File(zconf.getRelativeDir(ConfVars.ZEPPELIN_DEP_LOCALREPO)), <line11> new File(zconf.getRelativeDir(""lib/node_modules/zeppelin-tabledata"")), <line12> new File(zconf.getRelativeDir(""lib/node_modules/zeppelin-vis""))); <line13> } else { <line14> heliumVisualizationFactory = <line15> new HeliumVisualizationFactory( <line16> zconf, <line17> new File(zconf.getRelativeDir(ConfVars.ZEPPELIN_DEP_LOCALREPO)), <line18> new File(zconf.getRelativeDir(""smart-zeppelin/zeppelin-web/src/app/tabledata"")), <line19> new File(zconf.getRelativeDir(""smart-zeppelin/zeppelin-web/src/app/visualization""))); <line20> } <line21> this.helium = <line22> new Helium( <line23> zconf.getHeliumConfPath(), <line24> zconf.getHeliumDefaultLocalRegistryPath(), <line25> heliumVisualizationFactory, <line26> heliumApplicationFactory); <line27> try { <line28> heliumVisualizationFactory.bundle(helium.getVisualizationPackagesToBundle()); <line29> } catch (Exception e) { <line30> } <line31> this.schedulerFactory = new SchedulerFactory(); <line32> this.interpreterSettingManager = <line33> new InterpreterSettingManager(zconf, depResolver, new InterpreterOption(true)); <line34> this.noteSearchService = new LuceneSearch(); <line35> this.notebookAuthorization = NotebookAuthorization.init(zconf); <line36> this.credentials = new Credentials(zconf.credentialsPersist(), zconf.getCredentialsPath()); <line37> } <line38> } <line39> "	<line30>
5988	public class A { <line0> public void stop() { <line1> if (subProcess == null) { <line2> return; <line3> } <line4> subProcess.destroy(); <line5> subProcess = null; <line6> afterStop(); <line7> } <line8> } <line9> 	<line2>, <line7>
5989	public class A { <line0> @Override <line1> public CommitteeProposalComponentData getCommitteeProposal(final String id) <line2> throws DataFailureException { <line3> try { <line4> final String url = <line5> COMMITTE_PROPOSAL.replace( <line6> ID_KEY, UrlHelper.urlEncode(id, StandardCharsets.UTF_8.toString())); <line7> return ((JAXBElement<CommitteeProposalComponentData>) <line8> xmlAgent.unmarshallXml( <line9> riksdagenCommitteeProposalMarshaller, <line10> url, <line11> HTTP_UTSKOTTSFORSLAG_RIKSDAGEN_EXTERNAL_MODEL_CIA_HACK23_COM_IMPL, <line12> null, <line13> null)) <line14> .getValue(); <line15> } catch (final XmlAgentException e) { <line16> throw new DataFailureException(e); <line17> } <line18> } <line19> } <line20> 	<line16>
5990	"public class A { <line0> private static DataSource _getSlaveDataSource(Ioc ioc, PropertiesProxy conf, String prefix) { <line1> List<DataSource> slaveDataSources = new ArrayList<>(); <line2> for (String key : conf.keys()) { <line3> if (key.startsWith(prefix) && key.endsWith("".url"")) { <line4> String slaveName = key.substring(prefix.length(), key.length() - "".url"".length()); <line5> try { <line6> DataSource slaveDataSource = <line7> DataSourceStarter.createSlaveDataSource(ioc, conf, prefix + slaveName + "".""); <line8> slaveDataSources.add(slaveDataSource); <line9> slaves.add(slaveDataSource); <line10> } catch (Exception e) { <line11> throw new RuntimeException(e); <line12> } <line13> } <line14> } <line15> if (slaveDataSources.size() > 0) { <line16> if (slaveDataSources.size() == 1) { <line17> return slaveDataSources.get(0); <line18> } else { <line19> return new DynaDataSource(new DynaDataSourceSeletor(slaveDataSources)); <line20> } <line21> } <line22> return null; <line23> } <line24> } <line25> "	<line5>
5991	public class A { <line0> public static int getCommerceOrderItemsCount( <line1> long groupId, long commerceAccountId, int[] orderStatuses) throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommerceOrderItemServiceUtil.getCommerceOrderItemsCount( <line5> groupId, commerceAccountId, orderStatuses); <line6> return returnValue; <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>
5992	public class A { <line0> private static void logHadoopVersionInfo() { <line1> } <line2> } <line3> 	<line1>
5993	public class A { <line0> public void addAttributeListener(ZclAttributeListener listener) { <line1> attributeListeners.add(listener); <line2> } <line3> } <line4> 	<line1>
5994	public class A { <line0> @Override <line1> public boolean handleGraphObject(SecurityContext securityContext, AbstractRelationship rel) { <line2> if (rel.getProperty(GraphObject.id) != null) { <line3> Class type = rel.getClass(); <line4> PropertyKey destPropertyKey = <line5> StructrApp.getConfiguration().getPropertyKeyForDatabaseName(type, destKey); <line6> PropertyKey sourcePropertyKey = <line7> StructrApp.getConfiguration().getPropertyKeyForDatabaseName(type, sourceKey); <line8> try { <line9> rel.setProperty(destPropertyKey, rel.getProperty(sourcePropertyKey)); <line10> } catch (FrameworkException fex) { <line11> } <line12> } <line13> return true; <line14> } <line15> } <line16> 	<line11>
5995	public class A { <line0> @Override <line1> public void bundleChanged(BundleEvent event) { <line2> if (event.getType() == BundleEvent.STARTED) { <line3> try { <line4> tryInstallingFailedArtifacts(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> } <line10> 	<line6>
5996	public class A { <line0> void logoutSynchronousParticipants(SAMLInternalLogoutContext ctx) { <line1> Iterator<SAMLSessionParticipant> toBeLoggedOut = ctx.getToBeLoggedOut().iterator(); <line2> SAMLSessionParticipant participant = null; <line3> while (toBeLoggedOut.hasNext()) { <line4> participant = toBeLoggedOut.next(); <line5> SAMLEndpointDefinition soapLogoutEndpoint = <line6> participant.getLogoutEndpoints().get(Binding.SOAP); <line7> if (soapLogoutEndpoint == null) continue; <line8> toBeLoggedOut.remove(); <line9> try { <line10> LogoutRequest logoutRequest = createSignedLogoutRequest(participant, soapLogoutEndpoint); <line11> IClientConfiguration soapClientConfig = createSoapClientConfig(participant); <line12> SAMLLogoutClient client = <line13> new SAMLLogoutClient(soapLogoutEndpoint.getUrl(), soapClientConfig); <line14> LogoutResponseDocument resp = client.logout(logoutRequest.getXMLBeanDoc()); <line15> updateContextAfterParicipantLogout(ctx, participant, resp); <line16> } catch (Exception e) { <line17> ctx.getFailed().add(participant); <line18> } <line19> } <line20> } <line21> } <line22> 	<line10>, <line17>
5997	public class A { <line0> @Override <line1> public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) { <line2> initializeBridge( <line3> (getBridge() == null) ? null : getBridge().getHandler(), bridgeStatusInfo.getStatus()); <line4> } <line5> } <line6> 	<line2>
5998	public class A { <line0> private void proceedElement( <line1> final Object obj, <line2> final Field[] fields, <line3> final Element el, <line4> final String key, <line5> final String attrValue, <line6> final boolean isAttribute) { <line7> Field foundField = null; <line8> if (log.isDebugEnabled()) { <line9> } <line10> for (final Field field : fields) { <line11> if (log.isDebugEnabled()) { <line12> } <line13> if (XmlObjectWriter.ignoreField(field)) { <line14> continue; <line15> } <line16> final XmlField ann = <line17> field.isAnnotationPresent(XmlField.class) ? field.getAnnotation(XmlField.class) : null; <line18> if (!key.equals(field.getName()) && (ann == null || !key.equals(ann.alias()))) { <line19> continue; <line20> } <line21> foundField = field; <line22> break; <line23> } <line24> if (foundField != null) { <line25> final Class<?> type = foundField.getType(); <line26> final Object value = read(type, el, key, attrValue); <line27> setField(foundField, obj, value, el, key, attrValue); <line28> if (isAttribute) { <line29> putProcessedAttribute(el, key); <line30> } else { <line31> putProcessedElement(el); <line32> } <line33> } else { <line34> } <line35> } <line36> } <line37> 	<line9>, <line12>, <line34>
5999	public class A { <line0> private SecondaryIndex convertSecondaryIndex( <line1> String keyspaceName, String tableName, I index, List<Column> baseTableColumns) { <line2> String target = indexTarget(index); <line3> if (target == null) { <line4> return null; <line5> } <line6> Pair<String, CollectionIndexingType> result = convertTarget(target); <line7> String targetColumn = result.getValue0(); <line8> Optional<Column> col = <line9> baseTableColumns.stream().filter(c -> c.name().equals(targetColumn)).findFirst(); <line10> if (!col.isPresent()) { <line11> return null; <line12> } <line13> return SecondaryIndex.create( <line14> keyspaceName, <line15> indexName(index), <line16> col.get(), <line17> result.getValue1(), <line18> indexClass(index), <line19> indexOptions(index)); <line20> } <line21> } <line22> 	<line4>, <line11>
6000	"public class A { <line0> public void copy(final Map<DataFile, DataFile> entries) throws IOException { <line1> if (entries == null || entries.size() == 0) { <line2> return; <line3> } <line4> final Configuration conf = this.conf; <line5> final Path tmpInputDir = PathUtils.createTempPath(this.jobPath, ""distcp-in-"", """", conf); <line6> final Path tmpOutputDir = PathUtils.createTempPath(this.jobPath, ""distcp-out-"", """", conf); <line7> final FileSystem fs = tmpInputDir.getFileSystem(conf); <line8> fs.mkdirs(tmpInputDir); <line9> final List<DataFile> inFiles = Lists.newArrayList(entries.keySet()); <line10> sortInFilesByDescSize(inFiles); <line11> final NumberFormat nf = NumberFormat.getInstance(); <line12> nf.setMinimumIntegerDigits(Integer.toString(inFiles.size()).length()); <line13> nf.setGroupingUsed(false); <line14> int count = 0; <line15> for (DataFile inFile : inFiles) { <line16> count++; <line17> final DataFile outFile = entries.get(inFile); <line18> final Path f = new Path(tmpInputDir, ""distcp-"" + nf.format(count) + "".cp""); <line19> BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fs.create(f), CHARSET)); <line20> bw.write(inFile.getSource() + ""\t"" + outFile.getSource() + ""\n""); <line21> bw.close(); <line22> } <line23> final Job job = createJobConf(conf, tmpInputDir, tmpOutputDir); <line24> try { <line25> job.waitForCompletion(false); <line26> } catch (InterruptedException | ClassNotFoundException e) { <line27> throw new EoulsanRuntimeException(""Error while distcp: "" + e.getMessage(), e); <line28> } <line29> PathUtils.fullyDelete(tmpInputDir, conf); <line30> PathUtils.fullyDelete(tmpOutputDir, conf); <line31> if (!job.isSuccessful()) { <line32> throw new IOException(""Unable to copy files using DataFileDistCp.""); <line33> } <line34> } <line35> } <line36> "	<line19>
6001	"public class A { <line0> @Test(groups = ""Integration"") <line1> public void testChangeModeFailureStopsTasksButHappyUponResumption() throws Exception { <line2> DynamicCluster origServerPool = <line3> origApp.createAndManageChild( <line4> EntitySpec.create(DynamicCluster.class) <line5> .configure( <line6> DynamicCluster.MEMBER_SPEC, <line7> EntitySpec.create(TomcatServer.class).configure(""war"", getTestWar())) <line8> .configure(""initialSize"", 1)); <line9> NginxController origNginx = <line10> origApp.createAndManageChild( <line11> EntitySpec.create(NginxController.class) <line12> .configure(""serverPool"", origServerPool) <line13> .configure(""domain"", ""localhost"")); <line14> origApp.start(ImmutableList.of(loc)); <line15> Assert.assertTrue(RecordingSshjTool.connectionCount.get() > 0); <line16> Collection<Feed> origFeeds = ((EntityInternal) origNginx).feeds().getFeeds(); <line17> Assert.assertTrue(origFeeds.size() >= 1); <line18> origManagementContext.getRebindManager().forcePersistNow(); <line19> List<Task<?>> tasksBefore = <line20> ((BasicExecutionManager) origManagementContext.getExecutionManager()).getAllTasks(); <line21> Assert.assertFalse(tasksBefore.isEmpty()); <line22> origManagementContext.getHighAvailabilityManager().changeMode(HighAvailabilityMode.DISABLED); <line23> origApp = null; <line24> Repeater.create() <line25> .every(Duration.millis(20)) <line26> .backoffTo(Duration.ONE_SECOND) <line27> .limitTimeTo(Duration.THIRTY_SECONDS) <line28> .until( <line29> new Callable<Boolean>() { <line30> @Override <line31> public Boolean call() throws Exception { <line32> origManagementContext.getGarbageCollector().gcIteration(); <line33> List<Task<?>> tasksAfter = <line34> ((BasicExecutionManager) origManagementContext.getExecutionManager()) <line35> .getAllTasks(); <line36> return tasksAfter.isEmpty(); <line37> } <line38> }) <line39> .runRequiringTrue(); <line40> RecordingSshjTool.forbidden.set(true); <line41> newManagementContext = createNewManagementContext(); <line42> newApp = <line43> (TestApplication) <line44> RebindTestUtils.rebind((LocalManagementContext) newManagementContext, classLoader); <line45> NginxController newNginx = <line46> Iterables.getOnlyElement(Entities.descendants(newApp, NginxController.class)); <line47> Collection<Feed> newFeeds = ((EntityInternal) newNginx).feeds().getFeeds(); <line48> Assert.assertTrue(newFeeds.size() >= 1); <line49> EntityTestUtils.assertAttributeEqualsEventually( <line50> newNginx, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.ON_FIRE); <line51> RecordingSshjTool.forbidden.set(false); <line52> EntityTestUtils.assertAttributeEqualsEventually( <line53> newNginx, Attributes.SERVICE_STATE_ACTUAL, Lifecycle.RUNNING); <line54> } <line55> } <line56> "	<line17>, <line21>, <line36>, <line48>
6002	public class A { <line0> public List<OWLOntologyChange> getChanges() { <line1> List<OWLOntologyChange> changes = new ArrayList<>(); <line2> switchUsageOfDeprecatedEntityWithReplacement(changes); <line3> updateDeprecatedEntityLogicalDefinition(changes); <line4> updateDeprecatedEntityAnnotations(changes); <line5> addDeprecatedAnnotationAssertion(changes); <line6> addDeprecationReason(changes); <line7> addDeprecationCode(changes); <line8> relabelDeprecatedEntity(changes); <line9> prefixDeprecatedAnnotationValues(changes); <line10> addReplacedByAnnotation(changes); <line11> addAlternateEntityAnnotations(changes); <line12> reparentDeprecatedEntity(changes); <line13> return changes; <line14> } <line15> } <line16> 	<line1>, <line13>
6003	"public class A { <line0> public static java.util.List<com.liferay.commerce.account.model.CommerceAccountUserRel> <line1> getCommerceAccountUserRels( <line2> HttpPrincipal httpPrincipal, long commerceAccountId, int start, int end) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> new MethodKey( <line7> CommerceAccountUserRelServiceUtil.class, <line8> ""getCommerceAccountUserRels"", <line9> _getCommerceAccountUserRelsParameterTypes7); <line10> MethodHandler methodHandler = new MethodHandler(methodKey, commerceAccountId, start, end); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (java.util.List<com.liferay.commerce.account.model.CommerceAccountUserRel>) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line22>
6004	public class A { <line0> @Override <line1> public void onNewSnapshot(final PersistedSnapshot persistedSnapshot) { <line2> if (threadContext.isCurrentContext()) { <line3> final var index = persistedSnapshot.getIndex(); <line4> final var lastIndex = raftLog.getLastIndex(); <line5> if (lastIndex < index) { <line6> raftLog.reset(index + 1); <line7> } <line8> } else { <line9> threadContext.execute(() -> onNewSnapshot(persistedSnapshot)); <line10> } <line11> } <line12> } <line13> 	<line6>
6005	"public class A { <line0> @Override <line1> public void run() { <line2> connectDistributedSystem(); <line3> DLockService dls = (DLockService) DistributedLockService.getServiceNamed(dlsName); <line4> assertThat(dls.lock(key1, -1, -1)).isTrue(); <line5> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(1); <line6> assertThat(dls.lock(key1, -1, -1)).isTrue(); <line7> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(2); <line8> assertThat(dls.lock(key1, -1, -1)).isTrue(); <line9> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(3); <line10> DLockToken token0 = dls.getToken(key1); <line11> assertThat(token0).isNotNull(); <line12> Collection tokens = dls.getTokens(); <line13> assertThat(tokens.contains(token0)).isTrue(); <line14> assertThat(tokens.size()).isEqualTo(1); <line15> dls.unlock(key1); <line16> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(2); <line17> dls.freeResources(key1); <line18> DLockToken token1 = dls.getToken(key1); <line19> assertThat(token1).isNotNull(); <line20> assertThat(token1).isEqualTo(token0); <line21> tokens = dls.getTokens(); <line22> assertThat(tokens.contains(token1)).isTrue(); <line23> assertThat(tokens.size()).isEqualTo(1); <line24> dls.unlock(key1); <line25> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(1); <line26> dls.freeResources(key1); <line27> assertThat(dls.getToken(key1)).isNotNull(); <line28> DLockToken token2 = dls.getToken(key1); <line29> assertThat(token2).isNotNull(); <line30> assertThat(token2).isEqualTo(token0); <line31> tokens = dls.getTokens(); <line32> assertThat(tokens.contains(token2)).isTrue(); <line33> assertThat(tokens.size()).isEqualTo(1); <line34> dls.unlock(key1); <line35> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(0); <line36> dls.freeResources(key1); <line37> DLockToken token3 = dls.getToken(key1); <line38> assertThat(token3).withFailMessage(""Failed with bug 38180: "" + token3).isNull(); <line39> tokens = dls.getTokens(); <line40> assertThat(tokens.size()) <line41> .isEqualTo(0) <line42> .withFailMessage(""Failed with bug 38180: tokens="" + tokens); <line43> } <line44> } <line45> "	<line2>
6006	public class A { <line0> public long getQueueNotVisibleMessageCount(String queueUrl) { <line1> long messageCount = 0; <line2> try { <line3> messageCount = getQueueNotVisibleMessageCount(queueUrl, false); <line4> } catch (Exception ex) { <line5> } <line6> return messageCount; <line7> } <line8> } <line9> 	<line5>
6007	"public class A { <line0> public static String parameterizeUrl(String baseUrl, Properties params) { <line1> baseUrl = StringUtils.trim(baseUrl); <line2> if (StringUtils.isEmpty(baseUrl)) { <line3> throw new IllegalArgumentException(""invalid (blank) base URL""); <line4> } <line5> if (params == null) { <line6> throw new IllegalArgumentException(""invalid (null) Properties""); <line7> } <line8> StringBuffer ret = new StringBuffer(baseUrl); <line9> String delimiter = (ret.indexOf(""?"") == -1) ? ""?"" : ""&""; <line10> for (Object key : params.keySet()) { <line11> String paramName = StringUtils.trim((String) key); <line12> String paramValue = params.getProperty(paramName); <line13> ret.append(delimiter); <line14> if (StringUtils.isEmpty(paramName)) { <line15> throw new IllegalArgumentException(""invalid (blank) paramName""); <line16> } <line17> if (paramValue == null) { <line18> ret.append(paramName); <line19> ret.append(""=""); <line20> } else { <line21> try { <line22> ret.append(paramName); <line23> ret.append(""=""); <line24> ret.append(urlCodec.encode(paramValue)); <line25> } catch (EncoderException ex) { <line26> throw new RuntimeException( <line27> ""Unable to encode parameter name or value: "" + paramName + ""="" + paramValue, ex); <line28> } <line29> } <line30> delimiter = ""&""; <line31> } <line32> return ret.toString(); <line33> } <line34> } <line35> "	<line26>
6008	"public class A { <line0> @Override <line1> public AsyncAdminBuilder getAdminBuilder() { <line2> return new AsyncAdminBuilder() { <line3> @Override <line4> public AsyncAdminBuilder setStartLogErrorsCnt(int arg0) { <line5> return this; <line6> } <line7>  <line8> @Override <line9> public AsyncAdminBuilder setRpcTimeout(long arg0, TimeUnit arg1) { <line10> return this; <line11> } <line12>  <line13> @Override <line14> public AsyncAdminBuilder setRetryPause(long arg0, TimeUnit arg1) { <line15> return this; <line16> } <line17>  <line18> @Override <line19> public AsyncAdminBuilder setRetryPauseForCQTBE(long l, TimeUnit timeUnit) { <line20> return this; <line21> } <line22>  <line23> @Override <line24> public AsyncAdminBuilder setOperationTimeout(long arg0, TimeUnit arg1) { <line25> return this; <line26> } <line27>  <line28> @Override <line29> public AsyncAdminBuilder setMaxAttempts(int arg0) { <line30> return this; <line31> } <line32>  <line33> @Override <line34> public AsyncAdmin build() { <line35> try { <line36> return new BigtableAsyncAdmin(BigtableAsyncConnection.this); <line37> } catch (IOException e) { <line38> throw new UncheckedIOException(""failed to build BigtableAsyncAdmin"", e); <line39> } <line40> } <line41> }; <line42> } <line43> } <line44> "	<line38>
6009	public class A { <line0> public static void prepareRuntimeContext() { <line1> RuntimeContext.set(RuntimeContext.DEFAULT.apply(System.getenv())); <line2> RuntimeContext.get().verifyApplication(WindGate.class.getClassLoader()); <line3> } <line4> } <line5> 	<line3>
6010	"public class A { <line0> @Test <line1> public void test1() { <line2> Text colf = new Text(""a""); <line3> Text colq = new Text(""b""); <line4> TreeMap<Key, Value> tm = new TreeMap<>(); <line5> createTestData(tm, colf, colq); <line6> try { <line7> VersioningIterator it = new VersioningIterator(); <line8> IteratorSetting is = new IteratorSetting(1, VersioningIterator.class); <line9> VersioningIterator.setMaxVersions(is, 3); <line10> it.init(new SortedMapIterator(tm), is.getOptions(), null); <line11> it.seek(new Range(), EMPTY_COL_FAMS, false); <line12> TreeMap<Key, Value> tmOut = iteratorOverTestData(it); <line13> for (Entry<Key, Value> e : tmOut.entrySet()) { <line14> assertEquals(8, e.getValue().get().length); <line15> assertTrue(16 < encoder.decode(e.getValue().get())); <line16> } <line17> assertEquals(""size after keeping 3 versions was "" + tmOut.size(), 6, tmOut.size()); <line18> } catch (IOException e) { <line19> fail(); <line20> } catch (Exception e) { <line21> fail(); <line22> } <line23> } <line24> } <line25> "	<line21>
6011	public class A { <line0> @Deactivate <line1> public void stop() { <line2> } <line3> } <line4> 	<line2>
6012	"public class A { <line0> ChecksumValue computeLocalFileChecksum( <line1> final File localFile, final ChecksumEncodingEnum overrideChecksumEncoding) <line2> throws JargonException { <line3> if (localFile == null) { <line4> throw new IllegalArgumentException(""null localFile""); <line5> } <line6> if (!localFile.exists()) { <line7> throw new JargonException(""file does not exist""); <line8> } <line9> if (!localFile.isFile()) { <line10> throw new JargonException(""path is not a file""); <line11> } <line12> ChecksumEncodingEnum checksumEncoding; <line13> if (overrideChecksumEncoding == null) { <line14> checksumEncoding = checksumManager.determineChecksumEncodingForTargetServer(); <line15> } else { <line16> checksumEncoding = overrideChecksumEncoding; <line17> } <line18> AbstractChecksumComputeStrategy strategy = <line19> irodsAccessObjectFactory <line20> .getIrodsSession() <line21> .getLocalChecksumComputerFactory() <line22> .instance(checksumEncoding); <line23> try { <line24> return strategy.computeChecksumValueForLocalFile(localFile.getAbsolutePath()); <line25> } catch (FileNotFoundException e) { <line26> throw new JargonException(""cannot find local file to do the checksum"", e); <line27> } <line28> } <line29> } <line30> "	<line3>, <line6>, <line18>, <line26>
6013	public class A { <line0> private List getIndexes(String rootRegion, String bucketRegion) { <line1> List indexes = null; <line2> if (!this.partitionedRegion.isIndexed()) { <line3> return indexes; <line4> } <line5> Map indexMap = this.partitionedRegion.getIndex(); <line6> if (indexMap == null || indexMap.isEmpty()) { <line7> return indexes; <line8> } <line9> indexes = new ArrayList(); <line10> Set indexSet = indexMap.entrySet(); <line11> for (Iterator it = indexSet.iterator(); it.hasNext(); ) { <line12> try { <line13> Map.Entry indexEntry = (Map.Entry) it.next(); <line14> PartitionedIndex index = (PartitionedIndex) indexEntry.getValue(); <line15> IndexCreationData icd = new IndexCreationData(index.getName()); <line16> new QCompiler(); <line17> String imports = index.getImports(); <line18> icd.setIndexData( <line19> index.getType(), <line20> index.getCanonicalizedFromClause(), <line21> index.getCanonicalizedIndexedExpression(), <line22> index.getImports()); <line23> icd.setPartitionedIndex(index); <line24> indexes.add(icd); <line25> } catch (Exception ignor) { <line26> } <line27> } <line28> return indexes; <line29> } <line30> } <line31> 	<line26>
6014	public class A { <line0> public void reConnectToQueue() { <line1> try { <line2> if (getEndpoint().getConfiguration().isAutoCreateQueue()) { <line3> getEndpoint().createQueue(getClient()); <line4> } <line5> } catch (QueueDeletedRecentlyException qdr) { <line6> try { <line7> Thread.sleep(30000); <line8> getEndpoint().createQueue(getClient()); <line9> } catch (Exception e) { <line10> } <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> 	<line6>, <line10>, <line12>
6015	public class A { <line0> private void handleUncaughtThrowable(Throwable t) { <line1> if (errored.compareAndSet(false, true)) { <line2> Runtime.getRuntime().halt(1); <line3> } <line4> } <line5> } <line6> 	<line2>
6016	public class A { <line0> @Override <line1> public Map<String, SyncTaskStatistic> getSyncTaskStatistics() { <line2> Map<String, SyncTaskStatistic> ret = new ConcurrentHashMap<>(); <line3> synchronized (syncTasks) { <line4> for (SyncTaskQueueWrapper wrapper : syncTasks.values()) { <line5> SyncTaskStatistic statistic = <line6> new SyncTaskStatistic( <line7> wrapper.syncSignature, <line8> wrapper.maxThreadNum, <line9> wrapper.counter.intValue(), <line10> wrapper.queue.size()); <line11> ret.put(statistic.getSyncSignature(), statistic); <line12> } <line13> } <line14> return ret; <line15> } <line16> } <line17> 	<line12>
6017	public class A { <line0> public edu.indiana.extreme.wsdl.benchmark1.ReceiveMeshInterfaceObjectsResponse <line1> receiveMeshInterfaceObjects( <line2> edu.indiana.extreme.wsdl.benchmark1.ReceiveMeshInterfaceObjectsRequest input) { <line3> ReceiveMeshInterfaceObjectsResponse ret = new ReceiveMeshInterfaceObjectsResponse(); <line4> ret.setReceiveMeshInterfaceObjectsReturn(input.getInput().getItem().size()); <line5> return ret; <line6> } <line7> } <line8> 	<line3>
6018	public class A { <line0> @Override <line1> public void deleteList(String uuid) throws BusinessException { <line2> ContactList listToDelete = findByUuid(uuid); <line3> listRepository.delete(listToDelete); <line4> } <line5> } <line6> 	<line3>
6019	public class A { <line0> @Override <line1> public void getGeoDetails(final String id) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(GEO_DETAILS, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> Place place = twitter.getGeoDetails(id); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotGeoDetails(place); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	<line12>
6020	"public class A { <line0> @Test <line1> public void testKeyValue() throws Exception { <line2> User user = new User(); <line3> user.setUsername(""edanuff""); <line4> user.setEmail(""ed@anuff.com""); <line5> Activity activity = <line6> Activity.newActivity( <line7> Activity.VERB_POST, <line8> null, <line9> ""I ate another sammich"", <line10> null, <line11> user, <line12> null, <line13> ""tweet"", <line14> null, <line15> null); <line16> List<Entry<String, Object>> l = IndexUtils.getKeyValueList(activity, false); <line17> for (Entry<String, Object> e : l) { <line18> } <line19> assertEquals(7, l.size()); <line20> } <line21> } <line22> "	<line18>
6021	"public class A { <line0> public MrGeoRaster createColorScaleSwatch(String name, String format, int width, int height) <line1> throws MrsPyramidServiceException { <line2> try { <line3> ColorScale cs = getColorScaleFromName(name); <line4> return createColorScaleSwatch(cs, format, width, height); <line5> } catch (Exception e) { <line6> throw new MrsPyramidServiceException(""Error creating color scale "" + name, e); <line7> } <line8> } <line9> } <line10> "	<line6>
6022	"public class A { <line0> private void setPamProperties() { <line1> try { <line2> this.groupsFromUGI = <line3> ApplicationProperties.get() <line4> .getBoolean(""atlas.authentication.method.pam.ugi-groups"", true); <line5> Properties properties = <line6> ConfigurationConverter.getProperties( <line7> ApplicationProperties.get().subset(""atlas.authentication.method.pam"")); <line8> for (String key : properties.stringPropertyNames()) { <line9> String value = properties.getProperty(key); <line10> options.put(key, value); <line11> } <line12> if (!options.containsKey(""service"")) { <line13> options.put(""service"", ""atlas-login""); <line14> } <line15> if (LOG.isDebugEnabled()) { <line16> } <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> "	<line16>, <line18>
6023	public class A { <line0> @Override <line1> public void setHost(String host) { <line2> synchronized (clamdHost) { <line3> try { <line4> clamdHost = host; <line5> } catch (Exception e) { <line6> e.printStackTrace(); <line7> } <line8> } <line9> } <line10> } <line11> 	<line2>, <line5>, <line7>
6024	public class A { <line0> protected String getJWTFromCookie(HttpServletRequest req) { <line1> String serializedJWT = null; <line2> Cookie[] cookies = req.getCookies(); <line3> if (cookieName != null && cookies != null) { <line4> for (Cookie cookie : cookies) { <line5> if (cookieName.equals(cookie.getName())) { <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> serializedJWT = cookie.getValue(); <line9> break; <line10> } <line11> } <line12> } <line13> return serializedJWT; <line14> } <line15> } <line16> 	<line7>
6025	public class A { <line0> private static String getMessage(String key) { <line1> try { <line2> return PropertyAccessor.getInstance().getProperty(NhincConstants.MESSAGES_PROPERTY_FILE, key); <line3> } catch (PropertyAccessException ex) { <line4> } <line5> return null; <line6> } <line7> } <line8> 	<line4>
6026	public class A { <line0> public byte[] getData() { <line1> try { <line2> byte[] d = HexUtils.hexToBytes(data.toString()); <line3> return d; <line4> } catch (IllegalArgumentException e) { <line5> } <line6> return null; <line7> } <line8> } <line9> 	<line3>, <line5>
6027	"public class A { <line0> private KeyStore loadStore(File storeFile, String storeType, String storePass) <line1> throws IOException, GeneralSecurityException { <line2> InputStream fin = null; <line3> try { <line4> if (storeFile.exists()) { <line5> fin = new FileInputStream(storeFile); <line6> } else { <line7> fin = getClass().getClassLoader().getResourceAsStream(storeFile.getPath()); <line8> if (fin == null) { <line9> throw new FtpServerConfigurationException( <line10> ""Key store could not be loaded from "" + storeFile.getPath()); <line11> } <line12> } <line13> KeyStore store = KeyStore.getInstance(storeType); <line14> store.load(fin, storePass.toCharArray()); <line15> return store; <line16> } finally { <line17> IoUtils.close(fin); <line18> } <line19> } <line20> } <line21> "	<line5>, <line7>
6028	public class A { <line0> @Override <line1> protected void parseHandshakeMessageContent(HelloRetryRequestMessage msg) { <line2> parseProtocolVersion(msg); <line3> parseSelectedCiphersuite(msg); <line4> if (hasExtensionLengthField(msg)) { <line5> parseExtensionLength(msg); <line6> if (hasExtensions(msg)) { <line7> parseExtensionBytes(msg); <line8> } <line9> } <line10> } <line11> } <line12> 	<line2>
6029	"public class A { <line0> public static void main(String[] args) { <line1> CommandLineArguments commandLineArguments = new CommandLineArguments(args); <line2> initLogging(commandLineArguments); <line3> try { <line4> commandLineArguments.validate(); <line5> if (commandLineArguments.shouldPrintVersionAndExit()) { <line6> printVersion(); <line7> System.exit(0); <line8> } <line9> if (commandLineArguments.hasOperation(""help"") || commandLineArguments.shouldPrintUsage()) { <line10> printUsage(); <line11> return; <line12> } <line13> Map<String, String> envVars = ConfigUtils.environmentVariablesToPropertyMap(); <line14> Map<String, String> config = new HashMap<>(); <line15> initializeDefaults(config, commandLineArguments); <line16> loadConfigurationFromConfigFiles(config, commandLineArguments, envVars); <line17> if (commandLineArguments.isWorkingDirectorySet()) { <line18> makeRelativeLocationsBasedOnWorkingDirectory(commandLineArguments, config); <line19> } <line20> config.putAll(envVars); <line21> config = overrideConfiguration(config, commandLineArguments.getConfiguration()); <line22> ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); <line23> List<File> jarFiles = new ArrayList<>(); <line24> jarFiles.addAll(getJdbcDriverJarFiles()); <line25> jarFiles.addAll(getJavaMigrationJarFiles(config)); <line26> if (!jarFiles.isEmpty()) { <line27> classLoader = ClassUtils.addJarsOrDirectoriesToClasspath(classLoader, jarFiles); <line28> } <line29> if (!commandLineArguments.shouldSuppressPrompt()) { <line30> promptForCredentialsIfMissing(config); <line31> } <line32> ConfigUtils.dumpConfiguration(config); <line33> filterProperties(config); <line34> if (!commandLineArguments.skipCheckForUpdate()) { <line35> VersionChecker.checkForVersionUpdates(); <line36> } <line37> Flyway flyway = Flyway.configure(classLoader).configuration(config).load(); <line38> OperationResultBase result; <line39> if (commandLineArguments.getOperations().size() == 1) { <line40> String operation = commandLineArguments.getOperations().get(0); <line41> result = executeOperation(flyway, operation, commandLineArguments); <line42> } else { <line43> result = new CompositeResult(); <line44> for (String operation : commandLineArguments.getOperations()) { <line45> OperationResultBase individualResult = <line46> executeOperation(flyway, operation, commandLineArguments); <line47> ((CompositeResult) result).individualResults.add(individualResult); <line48> } <line49> } <line50> if (commandLineArguments.shouldOutputJson()) { <line51> if (commandLineArguments.shouldWarnAboutDeprecatedFlag()) { <line52> String message = ""Option -json is deprecated; use -outputType=json instead""; <line53> result.addWarning(message); <line54> } <line55> printJson(commandLineArguments, result); <line56> } <line57> } catch (Exception e) { <line58> if (commandLineArguments.shouldOutputJson()) { <line59> ErrorOutput errorOutput = ErrorOutput.fromException(e); <line60> printJson(commandLineArguments, errorOutput); <line61> } else { <line62> if (commandLineArguments.getLogLevel() == Level.DEBUG) { <line63> } else { <line64> } <line65> } <line66> System.exit(1); <line67> } <line68> } <line69> } <line70> "	<line53>, <line63>, <line64>
6030	"public class A { <line0> @Override <line1> public void contextInitialized(ServletContextEvent event) { <line2> try { <line3> cloudStackContext = new CloudStackSpringContext(); <line4> cloudStackContext.registerShutdownHook(); <line5> event <line6> .getServletContext() <line7> .setAttribute(CloudStackSpringContext.CLOUDSTACK_CONTEXT_SERVLET_KEY, cloudStackContext); <line8> } catch (IOException e) { <line9> throw new RuntimeException(""Failed to initialize CloudStack Spring modules"", e); <line10> } <line11> configuredParentName = event.getServletContext().getInitParameter(WEB_PARENT_MODULE); <line12> if (configuredParentName == null) { <line13> configuredParentName = WEB_PARENT_MODULE_DEFAULT; <line14> } <line15> super.contextInitialized(event); <line16> } <line17> } <line18> "	<line9>
6031	public class A { <line0> protected void truncate(final long length) throws IOException { <line1> fc.truncate(length); <line2> } <line3> } <line4> 	<line1>
6032	public class A { <line0> @Override <line1> protected void execute(final TraceEventRecords invalidTrace) throws Exception { <line2> if (this.logInvalidTraces) { <line3> } <line4> final TraceMetadata traceMetadata = invalidTrace.getTraceMetadata(); <line5> if (traceMetadata != null) { <line6> this.reportError(invalidTrace.getTraceMetadata().getTraceId()); <line7> } else { <line8> final AbstractTraceEvent[] events = invalidTrace.getTraceEvents(); <line9> if ((events != null) && (events.length > 0)) { <line10> this.reportError(events[0].getTraceId()); <line11> } else { <line12> this.reportError(InvalidEventRecordTraceCounter.TRACE_ID_IF_NONE); <line13> } <line14> } <line15> } <line16> } <line17> 	<line3>
6033	public class A { <line0> @Subscribe <line1> public void eventReceived(Object event) { <line2> if (eventClass == null || eventClass.isAssignableFrom(event.getClass())) { <line3> doEventReceived(event); <line4> } else { <line5> if (log.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> } <line10> 	<line6>
6034	public class A { <line0> private void logExecutionError() { <line1> if (updaterFuture.isDone()) { <line2> try { <line3> updaterFuture.get(); <line4> } catch (ExecutionException ee) { <line5> } catch (CancellationException ce) { <line6> } catch (InterruptedException ie) { <line7> Thread.currentThread().interrupt(); <line8> throw new RuntimeException(ie); <line9> } <line10> } <line11> } <line12> } <line13> 	<line5>, <line6>
6035	"public class A { <line0> @Override <line1> protected void readTimedOut(final ChannelHandlerContext ctx) throws Exception { <line2> if (first) { <line3> SwitchIdleEventBuilder builder = new SwitchIdleEventBuilder(); <line4> builder.setInfo(""Switch idle""); <line5> ctx.fireChannelRead(builder.build()); <line6> first = false; <line7> } <line8> } <line9> } <line10> "	<line3>
6036	public class A { <line0> @Override <line1> public void init(final FilterConfig filterConfig) throws ServletException { <line2> super.init(filterConfig); <line3> } <line4> } <line5> 	<line2>, <line3>
6037	public class A { <line0> private int checkConnectionLimit(final int configuredLimit) { <line1> final int recommendedLimit = strategy.getRecommendedLimit(); <line2> if (configuredLimit > recommendedLimit) { <line3> } else { <line4> } <line5> return configuredLimit; <line6> } <line7> } <line8> 	<line3>, <line4>
6038	"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Thread.sleep(TimeUnit.SECONDS.toMillis(MANAGEMENT_AGENT_SHUTDOWN_INTERNAL_SECONDS)); <line4> } catch (final InterruptedException e) { <line5> } <line6> for (final GridServiceAgent agent : agents) { <line7> try { <line8> agent.shutdown(); <line9> } catch (final Exception e) { <line10> logger.log( <line11> Level.WARNING, ""Attempt to shutdown management agent failed: "" + e.getMessage(), e); <line12> } <line13> } <line14> } <line15> } <line16> "	<line2>, <line6>, <line7>
6039	"public class A { <line0> public Message get(int batchSize, Long timeout, TimeUnit unit) throws CanalClientException { <line1> int times = 0; <line2> while (times < retryTimes) { <line3> try { <line4> Message msg = currentConnector.get(batchSize, timeout, unit); <line5> return msg; <line6> } catch (Throwable t) { <line7> times++; <line8> restart(); <line9> } <line10> } <line11> throw new CanalClientException(""failed to fetch the data after "" + times + "" times retry""); <line12> } <line13> } <line14> "	<line7>, <line9>
6040	public class A { <line0> @Override <line1> public File updateDetached(Registration registration, File file) { <line2> File dbObject = reattachFile(file); <line3> if (registration == null) { <line4> } else if (registration.isLIMSAdmin() || dbObject.givesPermission(registration)) { <line5> return updateDetached(file); <line6> } else { <line7> } <line8> return null; <line9> } <line10> } <line11> 	<line4>, <line5>, <line7>
6041	public class A { <line0> @Override <line1> public void updateEnvelopeForOffering(final String offering, final Envelope envelope) { <line2> CacheValidation.notNullOrEmpty(OFFERING, offering); <line3> Objects.requireNonNull(envelope, ENVELOPE); <line4> if (hasEnvelopeForOffering(offering)) { <line5> final ReferencedEnvelope offeringEnvelope = this.envelopeForOfferings.get(offering); <line6> offeringEnvelope.expandToInclude(envelope); <line7> } else { <line8> setEnvelopeForOffering(offering, new ReferencedEnvelope(envelope, getDefaultEPSGCode())); <line9> } <line10> } <line11> } <line12> 	<line6>
6042	public class A { <line0> @Override <line1> public void operationComplete(ChannelFuture future) throws Exception { <line2> if (!future.isSuccess()) { <line3> ctx.close(); <line4> } <line5> } <line6> } <line7> 	<line3>
6043	public class A { <line0> public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException { <line1> MagicAnnotation annotation = field.getAnnotation(MagicAnnotation.class); <line2> if (annotation != null && field.getType() == String.class) { <line3> ReflectionUtils.makeAccessible(field); <line4> field.set(bean, annotation.value()); <line5> } <line6> } <line7> } <line8> 	<line3>
6044	public class A { <line0> @Override <line1> public boolean isVisible(User user, CommerceChannel commerceChannel) { <line2> try { <line3> if (!GroupPermissionUtil.contains( <line4> PermissionThreadLocal.getPermissionChecker(), <line5> commerceChannel.getSiteGroupId(), <line6> ActionKeys.ADD_LAYOUT)) { <line7> return false; <line8> } <line9> } catch (PortalException portalException) { <line10> return false; <line11> } <line12> if (!CommerceChannelConstants.CHANNEL_TYPE_SITE.equals(commerceChannel.getType())) { <line13> return false; <line14> } <line15> return true; <line16> } <line17> } <line18> 	<line10>
6045	public class A { <line0> private void joinEnvironmentP2PSwarm(ProxyDto proxyDto) { <line1> try { <line2> ResourceHost resourceHost = peerManager.getLocalPeer().getManagementHost(); <line3> resourceHost.joinP2PSwarmDHCP( <line4> proxyDto.getP2pIfaceName(), <line5> proxyDto.getP2pHash(), <line6> proxyDto.getP2SecretKey(), <line7> proxyDto.getP2pSecretTTL()); <line8> for (final P2PConnection p2PConnection : resourceHost.getP2PConnections().getConnections()) { <line9> if (p2PConnection.getHash().equals(proxyDto.getP2pHash())) { <line10> proxyDto.setP2pIpAddr(p2PConnection.getIp()); <line11> break; <line12> } <line13> } <line14> proxyDto.setState(ProxyDto.State.READY); <line15> } catch (Exception e) { <line16> proxyDto.setState(ProxyDto.State.FAILED); <line17> proxyDto.setLogs(e.getMessage()); <line18> } <line19> } <line20> } <line21> 	<line18>
6046	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Connection connection = new ActiveMQConnectionFactory(brokerURL).createConnection(); <line4> connection.start(); <line5> Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line6> Destination destination = session.createTopic(topicName); <line7> MessageConsumer consumer = session.createConsumer(destination); <line8> try { <line9> int count = 0; <line10> for (; count < MAX_MESSAGE_COUNT; ++count) { <line11> Message message = consumer.receive(); <line12> if (message == null) { <line13> } else { <line14> receivedMessages.add((MapMessage) message); <line15> } <line16> } <line17> if (count >= MAX_MESSAGE_COUNT) { <line18> } <line19> } finally { <line20> connection.close(); <line21> } <line22> } catch (Exception e) { <line23> } <line24> } <line25> } <line26> 	<line9>, <line13>, <line14>, <line18>, <line20>, <line23>
6047	"public class A { <line0> @Override <line1> public void create(String filePath, InputStream content, boolean doPrepare) throws IOException { <line2> if (content == null) { <line3> throw new IllegalArgumentException(""Content of a file can not be null.""); <line4> } <line5> if (filePath == null) { <line6> throw new IllegalArgumentException(""Name of a file can not be null.""); <line7> } <line8> if (checkFileExists(filePath)) { <line9> throw new IllegalArgumentException(""The file already exists""); <line10> } <line11> File targetFile = new File(getAbsolutePath(filePath).toUri()); <line12> FileUtils.copyInputStreamToFile(content, targetFile); <line13> if (doPrepare && prepareScript != null) { <line14> Process p = Runtime.getRuntime().exec(prepareScript + "" "" + targetFile.getAbsolutePath()); <line15> LOGGER.warning(new String(IOUtils.toByteArray(p.getErrorStream()))); <line16> try { <line17> int e = p.waitFor(); <line18> if (e != 0) { <line19> throw new IOException(""Preparation script ended with exit code "" + e); <line20> } <line21> } catch (InterruptedException e) { <line22> } <line23> } <line24> } <line25> } <line26> "	<line15>
6048	"public class A { <line0> public void migrateNavigation(FileSystem sourceFS, FileSystem targetFS) { <line1> migrate(sourceFS, targetFS, path -> path.getFileName().toString().equals(""navtree.json"")); <line2> } <line3> } <line4> "	<line1>
6049	public class A { <line0> public static void recursiveDelete(File file) { <line1> try { <line2> Files.walk(file.toPath()) <line3> .sorted(Comparator.reverseOrder()) <line4> .map(Path::toFile) <line5> .forEach(File::delete); <line6> } catch (IOException e) { <line7> } <line8> } <line9> } <line10> 	<line7>
6050	public class A { <line0> public synchronized void activate(ComponentContext context, Map<String, Object> properties) { <line1> this.componentContext = context; <line2> this.keystoreServiceOptions = new KeystoreServiceOptions(properties, this.cryptoService); <line3> this.selfUpdaterExecutor = Executors.newSingleThreadScheduledExecutor(); <line4> if (keystoreExists(this.keystoreServiceOptions.getKeystorePath()) <line5> && this.keystoreServiceOptions.needsRandomPassword()) { <line6> changeDefaultKeystorePassword(); <line7> } <line8> } <line9> } <line10> 	<line1>, <line8>
6051	public class A { <line0> @Override <line1> public boolean savePatient(PatientType patient) throws LoadTestDataException { <line2> SavePatientRequestMessageType request = new SavePatientRequestMessageType(); <line3> request.setConfigAssertion(buildConfigAssertion()); <line4> request.setPatient(patient); <line5> try { <line6> LoadTestDataSimpleResponseMessageType response = <line7> (LoadTestDataSimpleResponseMessageType) <line8> invokeClientPort(AdminWSConstants.ADMIN_LTD_SAVEPATIENT, request); <line9> logDebug(AdminWSConstants.ADMIN_LTD_SAVEPATIENT, response.isStatus(), response.getMessage()); <line10> if (response.isStatus()) { <line11> patient.setPatientId(response.getSaveRecordId()); <line12> } <line13> return response.isStatus(); <line14> } catch (Exception e) { <line15> } <line16> return false; <line17> } <line18> } <line19> 	<line15>
6052	"public class A { <line0> @Override <line1> public void activateCallback(IStatusData iStatus) { <line2> String event = <line3> ""Receive a callback componentStatus in ASDC, for componentName: "" <line4> + iStatus.getComponentName() <line5> + "" and status of "" <line6> + iStatus.getStatus() <line7> + "" distributionID of "" <line8> + iStatus.getDistributionID(); <line9> try { <line10> if (iStatus.getStatus() == null) { <line11> return; <line12> } <line13> if (!iStatus.getStatus().equals(DistributionStatusEnum.COMPONENT_DONE_OK) <line14> && !iStatus.getStatus().equals(DistributionStatusEnum.COMPONENT_DONE_ERROR)) { <line15> return; <line16> } <line17> WatchdogDistributionStatus watchdogDistributionStatus = <line18> watchdogDistributionStatusRepository <line19> .findById(iStatus.getDistributionID()) <line20> .orElseGet(() -> null); <line21> if (watchdogDistributionStatus == null) { <line22> watchdogDistributionStatus = new WatchdogDistributionStatus(); <line23> watchdogDistributionStatus.setDistributionId(iStatus.getDistributionID()); <line24> watchdogDistributionStatusRepository.save(watchdogDistributionStatus); <line25> } <line26> toscaInstaller.installTheComponentStatus(iStatus); <line27> } catch (ArtifactInstallerException e) { <line28> } <line29> } <line30> } <line31> "	<line11>, <line15>, <line26>, <line28>
6053	public class A { <line0> @Override <line1> protected boolean bridgeDirectCommunicate( <line2> BridgeCommunicationProtocol communication, boolean useAuthentication) { <line3> return bridgeDirectCommunicate( <line4> (JsonBridgeCommunicationProtocol) communication, useAuthentication); <line5> } <line6> } <line7> 	<line3>
6054	"public class A { <line0> @Override <line1> public void generate(Model model, MolgenisOptions options) throws Exception { <line2> Template template = createTemplate(""/"" + this.getClass().getSimpleName() + "".psql.ftl""); <line3> Map<String, Object> templateArgs = createTemplateArguments(options); <line4> List<Entity> entityList = model.getEntities(); <line5> entityList = MolgenisModel.sortEntitiesByDependency(entityList, model); <line6> File target = new File(this.getSqlPath(options) + ""/create_tables.sql""); <line7> boolean created = target.getParentFile().mkdirs(); <line8> if (!created && !target.getParentFile().exists()) { <line9> throw new IOException(""could not create "" + target.getParentFile()); <line10> } <line11> templateArgs.put(""model"", model); <line12> templateArgs.put(""entities"", entityList); <line13> OutputStream targetOut = new FileOutputStream(target); <line14> template.process(templateArgs, new OutputStreamWriter(targetOut, Charset.forName(""UTF-8""))); <line15> targetOut.close(); <line16> } <line17> } <line18> "	<line16>
6055	public class A { <line0> @Override <line1> protected void onWrite( <line2> DataObjectModification<ResolvedPolicy> rootNode, <line3> InstanceIdentifier<ResolvedPolicy> rootIdentifier) { <line4> ResolvedPolicy resolvedPolicy = rootNode.getDataAfter(); <line5> Map<InstanceIdentifier<Classifier>, Classifier> classifierByIid = <line6> resolveClassifiers(resolvedPolicy, rootIdentifier); <line7> for (Entry<InstanceIdentifier<Classifier>, Classifier> classifierEntry : <line8> classifierByIid.entrySet()) { <line9> ofStatsManager.pullStatsForClassifier(classifierEntry.getKey(), classifierEntry.getValue()); <line10> } <line11> } <line12> } <line13> 	<line9>
6056	public class A { <line0> protected ValueMap loadFromLoader( <line1> final IPropertiesLoader loader, final IResourceStream resourceStream) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> BufferedInputStream in = null; <line5> try { <line6> in = new BufferedInputStream(resourceStream.getInputStream()); <line7> ValueMap data = loader.loadWicketProperties(in); <line8> if (data == null) { <line9> java.util.Properties props = loader.loadJavaProperties(in); <line10> if (props != null) { <line11> data = new ValueMap(); <line12> Enumeration<?> enumeration = props.propertyNames(); <line13> while (enumeration.hasMoreElements()) { <line14> String property = (String) enumeration.nextElement(); <line15> data.put(property, props.getProperty(property)); <line16> } <line17> } <line18> } <line19> return data; <line20> } catch (ResourceStreamNotFoundException | IOException e) { <line21> } finally { <line22> IOUtils.closeQuietly(in); <line23> IOUtils.closeQuietly(resourceStream); <line24> } <line25> return null; <line26> } <line27> } <line28> 	<line3>, <line21>
6057	public class A { <line0> @Override <line1> public RemoteClient select(List<RemoteClient> clients, StreamData streamData) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> return clients.get(0); <line5> } <line6> } <line7> 	<line3>
6058	public class A { <line0> @Override <line1> public void log(JobLogPo jobLogPo) { <line2> } <line3> } <line4> 	<line2>
6059	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void createContainer( <line3> String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) { <line4> if (!initialized) { <line5> return; <line6> } <line7> List<Message> messages = <line8> (List<Message>) parameters.get(KieServerConstants.KIE_SERVER_PARAM_MESSAGES); <line9> try { <line10> DeployedUnit deployedUnit = deploymentService.getDeployedUnit(id); <line11> if (deployedUnit != null) { <line12> String kieBaseName = <line13> ((KModuleDeploymentUnit) deployedUnit.getDeploymentUnit()).getKbaseName(); <line14> KieContainer kieContainer = kieContainerInstance.getKieContainer(); <line15> imageReferences.putIfAbsent(id, new ImageReference(kieContainer, kieBaseName)); <line16> formRendererBase.indexDeploymentForms(id); <line17> } <line18> } catch (Exception e) { <line19> messages.add( <line20> new Message( <line21> Severity.WARN, <line22> ""Unable to create image reference for container "" <line23> + id <line24> + "" by extension "" <line25> + this <line26> + "" due to "" <line27> + e.getMessage())); <line28> } <line29> } <line30> } <line31> "	<line28>
6060	public class A { <line0> @Override <line1> public BuildSetTask build( <line2> BuildConfigurationSet buildConfigurationSet, User user, BuildOptions buildOptions) { <line3> return Mockito.mock(BuildSetTask.class); <line4> } <line5> } <line6> 	<line3>
6061	public class A { <line0> public PreparedTickler loadClass(String className) { <line1> PreparedTickler pt = null; <line2> ClassLoader cl = Thread.currentThread().getContextClassLoader(); <line3> try { <line4> pt = (PreparedTickler) cl.loadClass(className).newInstance(); <line5> } catch (Exception e) { <line6> } <line7> return pt; <line8> } <line9> } <line10> 	<line6>
6062	"public class A { <line0> @Test <line1> public void findExperimentsByAttributesTest() { <line2> LOGGER.info(""FindExperiments by attributes test start................................""); <line3> Value numValue = Value.newBuilder().setNumberValue(0.6543210).build(); <line4> KeyValueQuery keyValueQuery = <line5> KeyValueQuery.newBuilder() <line6> .setKey(""attributes.attribute_1"") <line7> .setValue(numValue) <line8> .setOperator(OperatorEnum.Operator.LTE) <line9> .build(); <line10> FindExperiments findExperiments = <line11> FindExperiments.newBuilder() <line12> .setProjectId(project1.getId()) <line13> .addPredicates(keyValueQuery) <line14> .build(); <line15> FindExperiments.Response response = experimentServiceStub.findExperiments(findExperiments); <line16> assertEquals( <line17> ""Experiment count not match with expected experiment count"", <line18> 3, <line19> response.getExperimentsList().size()); <line20> assertEquals( <line21> ""Total records count not matched with expected records count"", <line22> 3, <line23> response.getTotalRecords()); <line24> for (Experiment fetchedExperiment : response.getExperimentsList()) { <line25> boolean doesAttributeExist = false; <line26> for (KeyValue fetchedAttribute : fetchedExperiment.getAttributesList()) { <line27> if (fetchedAttribute.getKey().equals(""attribute_1"")) { <line28> doesAttributeExist = true; <line29> assertTrue( <line30> ""Experiment attributes.attribute_1 not match with expected experiment"" <line31> + "" attributes.attribute_1"", <line32> fetchedAttribute.getValue().getNumberValue() <= 0.6543210); <line33> } <line34> } <line35> if (!doesAttributeExist) { <line36> fail(""Expected attribute not found in fetched attributes""); <line37> } <line38> } <line39> } <line40> } <line41> "	<line16>, <line39>
6063	public class A { <line0> public void stop() { <line1> running = false; <line2> close(); <line3> } <line4> } <line5> 	<line2>
6064	public class A { <line0> void unblockTo(Address address) { <line1> LockPair lockPair = getLockPair(address); <line2> lockPair.unblockOutgoing(); <line3> } <line4> } <line5> 	<line1>
6065	public class A { <line0> public static Serializable getSerializable(int type, String value) { <line1> if (type == BOOLEAN) { <line2> return GetterUtil.getBoolean(value); <line3> } else if (type == BOOLEAN_ARRAY) { <line4> return new Boolean[] {GetterUtil.getBoolean(value)}; <line5> } else if (type == DATE) { <line6> try { <line7> DateFormat dateFormat = DateFormatFactoryUtil.getDateTime(LocaleUtil.getDefault()); <line8> return dateFormat.parse(value); <line9> } catch (Exception exception) { <line10> if (_log.isWarnEnabled()) { <line11> } <line12> } <line13> } else if (type == DATE_ARRAY) { <line14> Serializable dateSerializable = getSerializable(DATE, value); <line15> if (dateSerializable instanceof Date) { <line16> return new Date[] {(Date) dateSerializable}; <line17> } <line18> } else if (type == DOUBLE) { <line19> return GetterUtil.getDouble(value); <line20> } else if (type == DOUBLE_ARRAY) { <line21> return new double[] {GetterUtil.getDouble(value)}; <line22> } else if (type == FLOAT) { <line23> return GetterUtil.getFloat(value); <line24> } else if (type == FLOAT_ARRAY) { <line25> return new float[] {GetterUtil.getFloat(value)}; <line26> } else if (type == INTEGER) { <line27> return GetterUtil.getInteger(value); <line28> } else if (type == INTEGER_ARRAY) { <line29> return new int[] {GetterUtil.getInteger(value)}; <line30> } else if (type == LONG) { <line31> return GetterUtil.getLong(value); <line32> } else if (type == LONG_ARRAY) { <line33> return new long[] {GetterUtil.getLong(value)}; <line34> } else if (type == NUMBER) { <line35> return GetterUtil.getNumber(value); <line36> } else if (type == NUMBER_ARRAY) { <line37> return new Number[] {GetterUtil.getNumber(value)}; <line38> } else if (type == SHORT) { <line39> return GetterUtil.getShort(value); <line40> } else if (type == SHORT_ARRAY) { <line41> return new short[] {GetterUtil.getShort(value)}; <line42> } else if (type == STRING_ARRAY) { <line43> return new String[] {value}; <line44> } <line45> return value; <line46> } <line47> } <line48> 	<line11>
6066	public class A { <line0> public String getHomePath() { <line1> try { <line2> return env.getServerHome().getCanonicalPath(); <line3> } catch (IOException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	<line4>
6067	"public class A { <line0> @Override <line1> public void doFlush( <line2> boolean xa, String name, final String flushOp, final AsyncCallback<Boolean> callback) { <line3> String parentAddress = xa ? ""xa-data-source"" : ""data-source""; <line4> AddressBinding address = poolMetaData.getAddress(); <line5> ModelNode operation = address.asResource(baseadress.getAdress(), parentAddress, name); <line6> operation.get(OP).set(flushOp); <line7> dispatcher.execute( <line8> new DMRAction(operation), <line9> new AsyncCallback<DMRResponse>() { <line10> @Override <line11> public void onFailure(Throwable caught) { <line12> callback.onFailure(caught); <line13> } <line14>  <line15> @Override <line16> public void onSuccess(DMRResponse result) { <line17> ModelNode response = result.get(); <line18> boolean failure = response.isFailure(); <line19> callback.onSuccess(!failure); <line20> } <line21> }); <line22> } <line23> } <line24> "	<line19>
6068	"public class A { <line0> @Override <line1> public void onApplicationEvent(PlatformApplicationEvent event) { <line2> if (event.getSource() instanceof PlatformEvent) { <line3> PlatformEvent platformEvent = (PlatformEvent) event.getSource(); <line4> if (""BootstrapMonitoredEvent"".equals(platformEvent.getEventType())) { <line5> if (BOOTSTRAP_START_STATE.equals(platformEvent.getEventStatus())) { <line6> registerHystrixPlugins(); <line7> startPoseidon(); <line8> } else if (BOOTSTRAP_STOP_STATE.equals(platformEvent.getEventStatus())) { <line9> stopPoseidon(); <line10> } <line11> } <line12> } <line13> } <line14> } <line15> "	<line7>
6069	public class A { <line0> @Override <line1> public void error(Marker marker, String message, Throwable t) { <line2> } <line3> } <line4> 	<line2>
6070	"public class A { <line0> @Test <line1> public void shortExample5() { <line2> String sequence = ""QIKDLLVSSSTDLDTTLVLVNAIYFKGMWKTAFNAEDTRECMPFHVTKQESKPVQMMCMNNSFNVATLPAE""; <line3> } <line4> } <line5> "	<line3>
6071	"public class A { <line0> private void initLayout() { <line1> WebMarkupContainer activationContainer = new WebMarkupContainer(ID_ACTIVATION_CONTAINER); <line2> activationContainer.setOutputMarkupId(true); <line3> add(activationContainer); <line4> activationContainer.add( <line5> new VisibleEnableBehaviour() { <line6> private static final long serialVersionUID = 1L; <line7>  <line8> @Override <line9> public boolean isVisible() { <line10> return !activated; <line11> } <line12> }); <line13> Form form = new Form<>(ID_MAIN_FORM); <line14> activationContainer.add(form); <line15> Label usernamePanel = <line16> new Label( <line17> ID_NAME, <line18> createStringResource( <line19> ""PageAccountActivation.activate.accounts.label"", <line20> new PropertyModel<>(userModel, ""name.orig""))); <line21> usernamePanel.add( <line22> new VisibleEnableBehaviour() { <line23> private static final long serialVersionUID = 1L; <line24>  <line25> @Override <line26> public boolean isEnabled() { <line27> return false; <line28> } <line29> }); <line30> form.add(usernamePanel); <line31> PasswordTextField passwordPanel = new PasswordTextField(ID_PASSWORD, Model.of(new String())); <line32> form.add(passwordPanel); <line33> AjaxSubmitButton confirmPasswrod = <line34> new AjaxSubmitButton(ID_CONFIRM) { <line35> private static final long serialVersionUID = 1L; <line36>  <line37> @Override <line38> protected void onSubmit(AjaxRequestTarget target, Form<?> form) { <line39> propagatePassword(target, form); <line40> } <line41>  <line42> @Override <line43> protected void onError(AjaxRequestTarget target, Form<?> form) { <line44> target.add(getFeedbackPanel()); <line45> } <line46> }; <line47> form.add(confirmPasswrod); <line48> WebMarkupContainer confirmationContainer = new WebMarkupContainer(ID_CONFIRMATION_CONTAINER); <line49> confirmationContainer.setOutputMarkupId(true); <line50> confirmationContainer.add( <line51> new VisibleEnableBehaviour() { <line52> private static final long serialVersionUID = 1L; <line53>  <line54> @Override <line55> public boolean isVisible() { <line56> return activated; <line57> } <line58> }); <line59> add(confirmationContainer); <line60> AjaxLink<Void> linkToLogin = <line61> new AjaxLink<Void>(ID_LINK_TO_LOGIN) { <line62> private static final long serialVersionUID = 1L; <line63>  <line64> @Override <line65> public void onClick(AjaxRequestTarget target) { <line66> setResponsePage(PageLogin.class); <line67> } <line68> }; <line69> confirmationContainer.add(linkToLogin); <line70> RepeatingView activatedShadows = new RepeatingView(ID_ACTIVATED_SHADOWS); <line71> confirmationContainer.add(activatedShadows); <line72> List<ShadowType> shadowsToActivate = getShadowsToActivate(); <line73> if (shadowsToActivate.isEmpty()) { <line74> throw new RestartResponseException(PageLogin.class); <line75> } <line76> for (ShadowType shadow : shadowsToActivate) { <line77> Label shadowDesc = <line78> new Label( <line79> activatedShadows.newChildId(), <line80> WebComponentUtil.getName(shadow) <line81> + "" on resource "" <line82> + WebComponentUtil.getName(shadow.getResourceRef())); <line83> activatedShadows.add(shadowDesc); <line84> } <line85> } <line86> } <line87> "	<line44>, <line74>
6072	"public class A { <line0> public static String getVersion() { <line1> Properties releaseProperties = new Properties(); <line2> try { <line3> InputStream in = BalancerRunner.class.getResourceAsStream(""release.properties""); <line4> if (in != null) { <line5> releaseProperties.load(in); <line6> in.close(); <line7> String releaseVersion = releaseProperties.getProperty(RELEASE_VERSION); <line8> String releaseName = releaseProperties.getProperty(RELEASE_NAME); <line9> String releaseDate = releaseProperties.getProperty(RELEASE_DATE); <line10> String releaseRevision = releaseProperties.getProperty(RELEASE_REVISION); <line11> return ""Release ID: ("" <line12> + releaseName <line13> + "") Load Balancer "" <line14> + releaseVersion <line15> + "" (build: Git Hash="" <line16> + releaseRevision <line17> + "" date="" <line18> + releaseDate <line19> + "")""; <line20> } <line21> } catch (Exception e) { <line22> } <line23> return null; <line24> } <line25> } <line26> "	<line22>
6073	"public class A { <line0> private void init(Console console) { <line1> try { <line2> checkForToken(console); <line3> setResourceLocation(tokenFile.getCanonicalPath()); <line4> salt = ""Ge0W@v3-Ro0t-K3y"".getBytes(""UTF-8""); <line5> generateRootKeyFromToken(); <line6> } catch (final Throwable t) { <line7> } <line8> } <line9> } <line10> "	<line7>
6074	public class A { <line0> private <T> T getValue(final ConfigurationKey<T> configurationKey, final Parser<T> parser) { <line1> final String value = getWithCheck(configurationKey); <line2> if (CommonUtils.isBlank(value)) { <line3> return configurationKey.getDefaultValue(); <line4> } else { <line5> } <line6> return parser.parse(value); <line7> } <line8> } <line9> 	<line3>, <line5>
6075	public class A { <line0> public static void handle(MessagePublisher publisher, PipelinesBalancerMessage message) <line1> throws IOException { <line2> ObjectMapper mapper = new ObjectMapper(); <line3> PipelinesIndexedMessage m = <line4> mapper.readValue(message.getPayload(), PipelinesIndexedMessage.class); <line5> PipelinesIndexedMessage outputMessage = <line6> new PipelinesIndexedMessage( <line7> m.getDatasetUuid(), <line8> m.getAttempt(), <line9> m.getPipelineSteps(), <line10> m.getRunner(), <line11> m.getExecutionId()); <line12> publisher.send(outputMessage); <line13> } <line14> } <line15> 	<line2>, <line13>
6076	public class A { <line0> private boolean shouldFailFast(RunState state, Optional<Integer> exitCode) { <line1> if (exitCode.isPresent() && exitCode.orElseThrow() == FAIL_FAST_EXIT_CODE) { <line2> return true; <line3> } <line4> var workflow = workflows.get().get(state.workflowInstance().workflowId()); <line5> if (workflow == null) { <line6> return false; <line7> } <line8> return workflow <line9> .configuration() <line10> .retryCondition() <line11> .map(s -> !retryConditionMet(state, exitCode, s)) <line12> .orElse(false); <line13> } <line14> } <line15> 	<line6>
6077	"public class A { <line0> private void addOperationFileAsDebug(JSONArray operations) { <line1> try { <line2> OdfPackage pkg = mTextDocument.getPackage(); <line3> int revisionNo = 0; <line4> if (pkg.contains(OPERATION_REVISON_FILE)) { <line5> byte[] revisionByteArray = pkg.getBytes(OPERATION_REVISON_FILE); <line6> if (revisionByteArray != null && revisionByteArray.length != 0) { <line7> BufferedReader reader = <line8> new BufferedReader( <line9> new InputStreamReader(new ByteArrayInputStream(revisionByteArray))); <line10> String firstLine = reader.readLine(); <line11> revisionNo = Integer.parseInt(firstLine); <line12> } <line13> } else { <line14> } <line15> revisionNo++; <line16> pkg.insert( <line17> operations.toString().getBytes(), <line18> OPERATION_TEXT_FILE_PREFIX + revisionNo + "".txt"", <line19> ""text/plain""); <line20> pkg.insert(Integer.toString(revisionNo).getBytes(), OPERATION_REVISON_FILE, ""text/plain""); <line21> } catch (Exception ex) { <line22> } <line23> } <line24> } <line25> "	<line12>, <line14>, <line22>
6078	public class A { <line0> public static void close(final ResultSet resultSet) { <line1> if (resultSet == null) { <line2> return; <line3> } <line4> try { <line5> resultSet.close(); <line6> } catch (final SQLException e) { <line7> } <line8> } <line9> } <line10> 	<line7>
6079	"public class A { <line0> @Test <line1> public void testKerbFileAccess() <line2> throws InterruptedException, LifecycleException, EventDeliveryException, IOException { <line3> final String fileName = ""FlumeData""; <line4> final long rollCount = 5; <line5> final long batchSize = 2; <line6> String newPath = testPath + ""/singleBucket""; <line7> String kerbConfPrincipal = ""user1/localhost@EXAMPLE.COM""; <line8> String kerbKeytab = ""/usr/lib/flume/nonexistkeytabfile""; <line9> Configuration conf = new Configuration(); <line10> conf.set(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION, ""kerberos""); <line11> UserGroupInformation.setConfiguration(conf); <line12> Context context = new Context(); <line13> context.put(""hdfs.path"", newPath); <line14> context.put(""hdfs.filePrefix"", fileName); <line15> context.put(""hdfs.rollCount"", String.valueOf(rollCount)); <line16> context.put(""hdfs.batchSize"", String.valueOf(batchSize)); <line17> context.put(""hdfs.kerberosPrincipal"", kerbConfPrincipal); <line18> context.put(""hdfs.kerberosKeytab"", kerbKeytab); <line19> try { <line20> Configurables.configure(sink, context); <line21> Assert.fail(""no exception thrown""); <line22> } catch (IllegalArgumentException expected) { <line23> Assert.assertTrue(expected.getMessage().contains(""Keytab is not a readable file"")); <line24> } finally { <line25> conf.set(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION, ""simple""); <line26> UserGroupInformation.setConfiguration(conf); <line27> } <line28> } <line29> } <line30> "	<line3>
6080	public class A { <line0> @Test <line1> public void get() { <line2> Run run = ESSuiteTest.runDao.get(ESSuiteTest.RUN_ID_3); <line3> assertEquals(ESSuiteTest.COMMIT_ID_3, run.getCommitId()); <line4> assertEquals(ESSuiteTest.RUNNER_HOSTNAME_1, run.getRunner()); <line5> assertEquals(ESSuiteTest.RUN_DURATION, (Long) run.getActualTime()); <line6> } <line7> } <line8> 	<line2>
6081	"public class A { <line0> private void checkForFailures() throws IOException { <line1> if (failures.isEmpty()) { <line2> return; <line3> } <line4> StringBuilder logEntry = new StringBuilder(); <line5> int i = 0; <line6> List<BigtableWriteException> suppressed = Lists.newArrayList(); <line7> for (; i < 10 && !failures.isEmpty(); ++i) { <line8> BigtableWriteException exc = failures.remove(); <line9> logEntry.append(""\n"").append(exc.getMessage()); <line10> if (exc.getCause() != null) { <line11> logEntry.append("": "").append(exc.getCause().getMessage()); <line12> } <line13> suppressed.add(exc); <line14> } <line15> String message = <line16> String.format( <line17> ""At least %d errors occurred writing to Bigtable. First %d errors: %s"", <line18> i + failures.size(), i, logEntry.toString()); <line19> IOException exception = new IOException(message); <line20> for (BigtableWriteException e : suppressed) { <line21> exception.addSuppressed(e); <line22> } <line23> throw exception; <line24> } <line25> } <line26> "	<line19>
6082	public class A { <line0> @Override <line1> public Set<OWLClassExpression> refine(OWLClassExpression concept) { <line2> ELDescriptionTree tree = new ELDescriptionTree(rs, concept); <line3> List<ELDescriptionTree> refinementTrees = refine(tree); <line4> Set<OWLClassExpression> refinements = new HashSet<>(); <line5> for (ELDescriptionTree refinementTree : refinementTrees) { <line6> refinements.add(refinementTree.transformToClassExpression()); <line7> } <line8> return refinements; <line9> } <line10> } <line11> 	<line2>
6083	public class A { <line0> private void processOldApiNotification(Notification notification) { <line1> try { <line2> int[] data = (int[]) notification.getUserData(); <line3> int repairNo = data[0]; <line4> ActiveRepairService.Status status = ActiveRepairService.Status.values()[data[1]]; <line5> String message = notification.getMessage(); <line6> if (repairStatusHandlers.containsKey(repairNo)) { <line7> repairStatusHandlers <line8> .get(repairNo) <line9> .handle(repairNo, Optional.of(status), Optional.empty(), message, this); <line10> } <line11> } catch (RuntimeException e) { <line12> } <line13> } <line14> } <line15> 	<line7>, <line12>
6084	public class A { <line0> public AbstractFeatureEntity getFeature(String identifier, Session session) { <line1> Criteria criteria = <line2> getDefaultCriteria(session) <line3> .add(Restrictions.eq(AbstractFeatureEntity.IDENTIFIER, identifier)); <line4> return (AbstractFeatureEntity) criteria.uniqueResult(); <line5> } <line6> } <line7> 	<line4>
6085	public class A { <line0> @Transactional <line1> public void step0_prepareTargetStoreForJobDatasets(@NonNull UUID jobId, @NonNull UserInfo user) { <line2> DataUploadJob job = findAndCheckPublishStatusIsRunning(jobId); <line3> backendService.prepareBackend(job, user); <line4> job.getPublishableDatasets() <line5> .forEach( <line6> dset -> { <line7> dset.setPublishStatus(JobStatus.RUNNING); <line8> if (dset.getPublishing() == null) { <line9> dset.setPublishing(new PublishSettings()); <line10> } <line11> }); <line12> save(job); <line13> } <line14> } <line15> 	<line2>
6086	"public class A { <line0> @Override <line1> public void configure() { <line2> from(from) <line3> .routeId(""testNegativeAcknowledge:myRoute"") <line4> .to(to) <line5> .process( <line6> exchange -> { <line7> if (processed.compareAndSet(false, true)) { <line8> PulsarMessageReceipt receipt = <line9> (PulsarMessageReceipt) <line10> exchange.getIn().getHeader(PulsarMessageHeaders.MESSAGE_RECEIPT); <line11> receipt.negativeAcknowledge(); <line12> } else { <line13> PulsarMessageReceipt receipt = <line14> (PulsarMessageReceipt) <line15> exchange.getIn().getHeader(PulsarMessageHeaders.MESSAGE_RECEIPT); <line16> receipt.acknowledge(); <line17> } <line18> }); <line19> } <line20> } <line21> "	<line7>
6087	public class A { <line0> private boolean contactExists(Folder folder, ServerId serverId) { <line1> try { <line2> AddressBookId addressBookId = folder.getTypedBackendId(); <line3> return getBookClient() <line4> .getContactFromId(getAccessToken(), addressBookId.getId(), serverId.getItemId()) <line5> != null; <line6> } catch (ServerFault | ContactNotFoundException e) { <line7> } <line8> return false; <line9> } <line10> } <line11> 	<line7>
6088	public class A { <line0> public static void writeLong(Long value, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> out.writeLong(value); <line5> } <line6> } <line7> 	<line3>
6089	"public class A { <line0> @Override <line1> protected void startJsonRpcServer(RomServerJsonRpcHandler jsonRpcHandler) { <line2> handler = jsonRpcHandler; <line3> Properties properties = new Properties(); <line4> String port = getPort(); <line5> properties.put(""server.port"", port); <line6> SpringApplication application = new SpringApplication(BootTestApplication.class); <line7> application.setDefaultProperties(properties); <line8> context = application.run(); <line9> } <line10> } <line11> "	<line8>
6090	public class A { <line0> public void put(StoragePath storagePath, Source source) throws AssetStoreException { <line1> final File origin = getFileFromWorkspace(source); <line2> String objectName = buildObjectName(origin, storagePath); <line3> String objectVersion = null; <line4> try { <line5> AwsUploadOperationResult result = uploadObject(origin, objectName); <line6> objectName = result.getObjectName(); <line7> objectVersion = result.getObjectVersion(); <line8> } catch (Exception e) { <line9> throw new AssetStoreException(e); <line10> } <line11> try { <line12> database.storeMapping(storagePath, objectName, objectVersion); <line13> } catch (AwsAssetDatabaseException e) { <line14> throw new AssetStoreException(e); <line15> } <line16> } <line17> } <line18> 	<line12>
6091	"public class A { <line0> @Override <line1> public CPOptionValue findByC_K(long CPOptionId, String key) throws NoSuchCPOptionValueException { <line2> CPOptionValue cpOptionValue = fetchByC_K(CPOptionId, key); <line3> if (cpOptionValue == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""CPOptionId=""); <line7> sb.append(CPOptionId); <line8> sb.append("", key=""); <line9> sb.append(key); <line10> sb.append(""}""); <line11> if (_log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchCPOptionValueException(sb.toString()); <line14> } <line15> return cpOptionValue; <line16> } <line17> } <line18> "	<line12>
6092	"public class A { <line0> private void setupDeviceManagementSchema(DataSourceConfig config) <line1> throws CertificateManagementException { <line2> CertificateMgtSchemaInitializer initializer = new CertificateMgtSchemaInitializer(config); <line3> String checkSql = ""select * from DM_DEVICE_CERTIFICATE""; <line4> try { <line5> if (!initializer.isDatabaseStructureCreated(checkSql)) { <line6> initializer.createRegistryDatabase(); <line7> } else { <line8> } <line9> } catch (Exception e) { <line10> throw new CertificateManagementException( <line11> ""Error occurred while initializing Certificate Management database schema"", e); <line12> } <line13> if (log.isDebugEnabled()) { <line14> } <line15> } <line16> } <line17> "	<line6>, <line8>, <line14>
6093	public class A { <line0> protected AuthenticationInfo queryForAuthenticationInfo( <line1> AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException { <line2> Object principal = token.getPrincipal(); <line3> Object credentials = token.getCredentials(); <line4> principal = getLdapPrincipal(token); <line5> LdapContext ctx = null; <line6> try { <line7> ctx = ldapContextFactory.getLdapContext(principal, credentials); <line8> return createAuthenticationInfo(token, principal, credentials, ctx); <line9> } finally { <line10> LdapUtils.closeContext(ctx); <line11> } <line12> } <line13> } <line14> 	<line4>
6094	public class A { <line0> @Override <line1> protected void doInTransactionWithoutResult(TransactionStatus status) { <line2> emailDao.populateEmailHash(email, correctedEmailHash); <line3> } <line4> } <line5> 	<line3>
6095	public class A { <line0> @OnStopped <line1> public void stopServer(final ProcessContext context) { <line2> if (this.server != null) { <line3> try { <line4> this.server.shutdown().awaitTermination(5, TimeUnit.SECONDS); <line5> } catch (InterruptedException e) { <line6> getLogger() <line7> this.server = null; <line8> } <line9> } <line10> } <line11> } <line12> 	<line7>
6096	"public class A { <line0> public static List<FileShortcut> getFileShortcuts(HttpServletRequest httpServletRequest) <line1> throws PortalException { <line2> long[] fileShortcutIds = ParamUtil.getLongValues(httpServletRequest, ""rowIdsDLFileShortcut""); <line3> List<FileShortcut> fileShortcuts = new ArrayList<>(); <line4> for (long fileShortcutId : fileShortcutIds) { <line5> try { <line6> fileShortcuts.add(DLAppServiceUtil.getFileShortcut(fileShortcutId)); <line7> } catch (NoSuchFileShortcutException noSuchFileShortcutException) { <line8> if (_log.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> return fileShortcuts; <line13> } <line14> } <line15> "	<line9>
6097	"public class A { <line0> public MessageResponse handleMissingRequestedArtifact( <line1> final URI requestedArtifact, <line2> final URI transferContract, <line3> final URI issuerConnector, <line4> final URI messageId) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> return ErrorResponse.withDefaultHeader( <line8> RejectionReason.BAD_PARAMETERS, <line9> ""Missing requested artifact."", <line10> connectorService.getConnectorId(), <line11> connectorService.getOutboundModelVersion()); <line12> } <line13> } <line14> "	<line6>
6098	public class A { <line0> private void fail(Long transactionId, List<Message> messages) { <line1> if (messages != null) { <line2> for (Message msg : messages) { <line3> try { <line4> } catch (JMSException e) { <line5> } <line6> } <line7> } else { <line8> } <line9> } <line10> } <line11> 	<line1>, <line4>, <line5>, <line8>
6099	public class A { <line0> private void notifyListeners( <line1> Identifiable identifiable, <line2> String attribute, <line3> String variantId, <line4> Object oldValue, <line5> Object newValue) { <line6> for (NetworkListener listener : listeners) { <line7> try { <line8> listener.onUpdate(identifiable, attribute, variantId, oldValue, newValue); <line9> } catch (Exception t) { <line10> } <line11> } <line12> } <line13> } <line14> 	<line10>
6100	public class A { <line0> public IRI getDocumentIRI(@Nonnull IRI ontologyIRI) { <line1> final URI documentURI = ontologyIRI.toURI(); <line2> try { <line3> URLConnection connection = <line4> IOUtils.getUrlConnection( <line5> documentURI, CONNECTION_ACCEPT_HTTP_COMPRESSION, CONNECTION_TIMEOUT); <line6> if (HTTP.equals(ontologyIRI.getScheme()) || HTTPS.equals(ontologyIRI.getScheme())) { <line7> HttpURLConnection httpURLConnection = (HttpURLConnection) connection; <line8> httpURLConnection.setRequestMethod(HEAD); <line9> int responseCode = httpURLConnection.getResponseCode(); <line10> if (responseCode == HttpURLConnection.HTTP_OK <line11> || responseCode == HttpURLConnection.HTTP_MOVED_TEMP <line12> || responseCode == HttpURLConnection.HTTP_MOVED_PERM <line13> || responseCode == HttpURLConnection.HTTP_SEE_OTHER) { <line14> return ontologyIRI; <line15> } <line16> } else { <line17> InputStream is = connection.getInputStream(); <line18> is.close(); <line19> return ontologyIRI; <line20> } <line21> } catch (MalformedURLException e) { <line22> } catch (FileNotFoundException e) { <line23> } catch (UnknownHostException e) { <line24> String host = e.getMessage(); <line25> } catch (IOException e) { <line26> } <line27> return null; <line28> } <line29> } <line30> 	<line22>, <line23>, <line25>, <line26>
6101	"public class A { <line0> @Test(groups = {""standalone"", ""default_provider""}) <line1> public void relativePathRedirectTest() throws Throwable { <line2> isSet.getAndSet(false); <line3> AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build(); <line4> try (AsyncHttpClient client = getAsyncHttpClient(cg)) { <line5> String redirectTarget = ""bar/test1""; <line6> String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString(); <line7> Response response = <line8> client.prepareGet(getTargetUrl()).setHeader(""X-redirect"", redirectTarget).execute().get(); <line9> assertNotNull(response); <line10> assertEquals(response.getStatusCode(), 200); <line11> assertEquals(response.getUri().toString(), destinationUrl); <line12> } <line13> } <line14> } <line15> "	<line12>
6102	public class A { <line0> public static void main(String[] args) throws Exception { <line1> Thread.setDefaultUncaughtExceptionHandler(new TajoUncaughtExceptionHandler()); <line2> StringUtils.startupShutdownMessage(TajoMaster.class, args, LOG); <line3> try { <line4> TajoMaster master = new TajoMaster(); <line5> TajoConf conf = new TajoConf(); <line6> master.init(conf); <line7> master.start(); <line8> } catch (Throwable t) { <line9> System.exit(-1); <line10> } <line11> } <line12> } <line13> 	<line9>
6103	public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntrySoap moveFileEntryToTrash( <line1> long fileEntryId) throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.repository.model.FileEntry returnValue = <line4> DLTrashServiceUtil.moveFileEntryToTrash(fileEntryId); <line5> return com.liferay.portal.kernel.repository.model.FileEntrySoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>
6104	public class A { <line0> String getMetacardIdFromReference( <line1> String referenceKey, <line2> String catalogOperation, <line3> FileSystemPersistenceProvider productToMetacardIdMap) { <line4> String ref = getShaFor(referenceKey); <line5> if (!productToMetacardIdMap.loadAllKeys().contains(ref)) { <line6> return null; <line7> } <line8> return (String) productToMetacardIdMap.loadFromPersistence(ref); <line9> } <line10> } <line11> 	<line6>
6105	public class A { <line0> @Override <line1> protected void doStop() throws Exception { <line2> super.doStop(); <line3> if (createdVertx && vertx != null) { <line4> vertx.close(); <line5> } <line6> } <line7> } <line8> 	<line4>
6106	public class A { <line0> @Override <line1> public List<EducationLevelInfo> getEducationLevelList() { <line2> List<EducationLevelInfo> infoList = new LinkedList<EducationLevelInfo>(); <line3> List<EducationLevel> levelsDb = educationLevelDao.getAllRecords(); <line4> for (EducationLevel o : levelsDb) { <line5> EducationLevelInfo i = new EducationLevelInfo(); <line6> i.setEducationLevelId(o.getEducationLevelId()); <line7> i.setTitle(o.getTitle()); <line8> i.setDefaultNumber(o.getDefaultNumber()); <line9> infoList.add(i); <line10> } <line11> return infoList; <line12> } <line13> } <line14> 	<line11>
6107	"public class A { <line0> private FedoraClient getClient(boolean validUser, boolean validPass) throws Exception { <line1> if (validUser) { <line2> if (validPass) { <line3> if (CLIENT_VALID_USER_VALID_PASS == null) { <line4> CLIENT_VALID_USER_VALID_PASS = getFedoraClient(); <line5> } <line6> return CLIENT_VALID_USER_VALID_PASS; <line7> } else { <line8> if (CLIENT_VALID_USER_BOGUS_PASS == null) { <line9> CLIENT_VALID_USER_BOGUS_PASS = getFedoraClient(getBaseURL(), getUsername(), ""bogus""); <line10> } <line11> return CLIENT_VALID_USER_BOGUS_PASS; <line12> } <line13> } else { <line14> if (CLIENT_BOGUS_USER == null) { <line15> CLIENT_BOGUS_USER = getFedoraClient(getBaseURL(), ""bogus"", ""bogus""); <line16> } <line17> return CLIENT_BOGUS_USER; <line18> } <line19> } <line20> } <line21> "	<line3>, <line8>, <line14>
6108	public class A { <line0> @Override <line1> public void run(String... args) throws Exception { <line2> if (args.length != ARGS_LENGTH) { <line3> return; <line4> } <line5> zookeeperOperator.remove(args[0]); <line6> zookeeperOperator.close(); <line7> } <line8> } <line9> 	<line3>
6109	"public class A { <line0> public void update(Map<String, Object> config) { <line1> Object cSystemId = config.get(""system.id""); <line2> if (cSystemId == null || cSystemId.toString().isEmpty()) { <line3> systemId = InstanceUUID.get(); <line4> } else { <line5> systemId = cSystemId.toString(); <line6> } <line7> Object rootUrlObj = config.get(""openhab.rootUrl""); <line8> if (rootUrlObj != null) { <line9> rootUrl = String.valueOf(rootUrlObj); <line10> if (!rootUrl.endsWith(""/"")) { <line11> rootUrl += ""/""; <line12> } <line13> } <line14> } <line15> } <line16> "	<line14>
6110	"public class A { <line0> @Test <line1> public void skimPomForExistingRepoAndAddItInGroup() throws Exception { <line2> RemoteRepository repo = new RemoteRepository(REPO, server.formatUrl(REPO)); <line3> repo.setAllowReleases(Boolean.TRUE); <line4> repo.setAllowSnapshots(Boolean.FALSE); <line5> repo = client.stores().create(repo, ""Pre stored remote repo"", RemoteRepository.class); <line6> final StoreKey remoteRepoKey = repo.getKey(); <line7> final PomRef ref = <line8> loadPom(""one-repo"", Collections.singletonMap(""one-repo.url"", server.formatUrl(REPO))); <line9> server.expect(""HEAD"", server.formatUrl(REPO, ""/""), 200, (String) null); <line10> server.expect(server.formatUrl(TEST_REPO, ref.path), 200, ref.pom); <line11> final StoreKey pubGroupKey = <line12> new StoreKey(MavenPackageTypeDescriptor.MAVEN_PKG_KEY, StoreType.group, PUBLIC); <line13> Group g = client.stores().load(pubGroupKey, Group.class); <line14> assertThat( <line15> ""Group membership should not contain implied before getting pom."", <line16> g.getConstituents().contains(remoteRepoKey), <line17> equalTo(false)); <line18> final InputStream stream = client.content().get(pubGroupKey, ref.path); <line19> final String downloaded = IOUtils.toString(stream); <line20> IOUtils.closeQuietly(stream); <line21> System.out.println(""Waiting 5s for events to run.""); <line22> Thread.sleep(5000); <line23> g = client.stores().load(pubGroupKey, Group.class); <line24> assertThat( <line25> ""Group membership does not contain implied repository"", <line26> g.getConstituents().contains(remoteRepoKey), <line27> equalTo(true)); <line28> repo = <line29> client <line30> .stores() <line31> .load( <line32> new StoreKey(MavenPackageTypeDescriptor.MAVEN_PKG_KEY, StoreType.remote, TEST_REPO), <line33> RemoteRepository.class); <line34> String metadata = repo.getMetadata(ImpliedRepoMetadataManager.IMPLIED_STORES); <line35> assertThat( <line36> ""Reference to repositories implied by POMs in this repo is missing from metadata."", <line37> metadata.contains(""remote:"" + REPO), <line38> equalTo(true)); <line39> repo = client.stores().load(remoteRepoKey, RemoteRepository.class); <line40> metadata = repo.getMetadata(ImpliedRepoMetadataManager.IMPLIED_BY_STORES); <line41> assertThat( <line42> ""Backref to repo with pom that implies this repo is missing from metadata."", <line43> metadata.contains(""remote:"" + TEST_REPO), <line44> equalTo(true)); <line45> } <line46> } <line47> "	<line18>
6111	public class A { <line0> private void maybeUpdateLastAuthenticationTimestamp(ObjectContext context, User user) { <line1> long millisNow = Clock.systemUTC().millis(); <line2> long millisStored = <line3> Optional.ofNullable(user.getLastAuthenticationTimestamp()) <line4> .map(Timestamp::getTime) <line5> .orElse(0L); <line6> if (Math.abs(millisNow - millisStored) > TimeUnit.MILLISECONDS.convert(1, TimeUnit.HOURS)) { <line7> user.setLastAuthenticationTimestamp(new java.sql.Timestamp(millisNow)); <line8> context.commitChanges(); <line9> } <line10> } <line11> } <line12> 	<line9>
6112	"public class A { <line0> @Override <line1> public String getURLString( <line2> com.agiletec.aps.system.services.url.PageURL pageUrl, RequestContext reqCtx) { <line3> try { <line4> if (!(pageUrl instanceof PageURL)) { <line5> return super.getURLString(pageUrl, reqCtx); <line6> } <line7> Lang lang = this.extractLang(pageUrl, reqCtx); <line8> IPage destPage = this.extractDestPage(pageUrl, reqCtx); <line9> String friendlyCode = ((PageURL) pageUrl).getFriendlyCode(); <line10> if (StringUtils.isBlank(friendlyCode)) { <line11> friendlyCode = this.extractFriendlyCode(destPage, lang, pageUrl); <line12> } <line13> HttpServletRequest request = (null != reqCtx) ? reqCtx.getRequest() : null; <line14> String url = null; <line15> if (StringUtils.isBlank(friendlyCode)) { <line16> url = super.createURL(destPage, lang, pageUrl.getParams(), pageUrl.isEscapeAmp(), request); <line17> } else { <line18> url = <line19> this.createFriendlyUrl( <line20> friendlyCode, lang, pageUrl.getParams(), pageUrl.isEscapeAmp(), request); <line21> } <line22> if (null != reqCtx && null != reqCtx.getResponse() && this.useJsessionId()) { <line23> HttpServletResponse resp = reqCtx.getResponse(); <line24> return resp.encodeURL(url.toString()); <line25> } else { <line26> return url; <line27> } <line28> } catch (Exception e) { <line29> throw new RuntimeException(""Error creating url"", e); <line30> } <line31> } <line32> } <line33> "	<line29>
6113	"public class A { <line0> private List<AstrixServiceRegistryEntry> getServiceProvidersForConsumer( <line1> List<AstrixServiceRegistryEntry> entries, ServiceConsumerProperties serviceConsumer) { <line2> List<AstrixServiceRegistryEntry> activeServices = new ArrayList<>(entries.size()); <line3> String consumerZone = serviceConsumer.getProperty(ServiceConsumerProperties.CONSUMER_ZONE); <line4> for (AstrixServiceRegistryEntry entry : entries) { <line5> if (""true"".equals(entry.getServiceProperties().get(ServiceProperties.PUBLISHED))) { <line6> activeServices.add(entry); <line7> continue; <line8> } <line9> if (!Objects.equals( <line10> consumerZone, entry.getServiceProperties().get(ServiceProperties.SERVICE_ZONE))) { <line11> continue; <line12> } <line13> activeServices.add(entry); <line14> } <line15> return activeServices; <line16> } <line17> } <line18> "	<line11>
6114	public class A { <line0> @Override <line1> public void start() throws Exception { <line2> if (!graphiteConfiguration.isEnabled()) { <line3> return; <line4> } <line5> final Graphite graphite = <line6> new Graphite( <line7> new InetSocketAddress( <line8> graphiteConfiguration.getHostname(), graphiteConfiguration.getPort())); <line9> final GraphiteReporter.Builder reporterBuilder = GraphiteReporter.forRegistry(registry); <line10> if (!Strings.isNullOrEmpty(graphiteConfiguration.getPrefix())) { <line11> reporterBuilder.prefixedWith(graphiteConfiguration.getPrefix()); <line12> } <line13> if (!graphiteConfiguration.getPredicates().isEmpty()) { <line14> reporterBuilder.filter( <line15> new MetricFilter() { <line16> @Override <line17> public boolean matches(String name, Metric metric) { <line18> for (String predicate : graphiteConfiguration.getPredicates()) { <line19> if (name.startsWith(predicate)) { <line20> return true; <line21> } <line22> } <line23> return false; <line24> } <line25> }); <line26> } <line27> reporter = Optional.of(reporterBuilder.build(graphite)); <line28> reporter.get().start(graphiteConfiguration.getPeriodSeconds(), TimeUnit.SECONDS); <line29> } <line30> } <line31> 	<line3>, <line5>
6115	"public class A { <line0> @Override <line1> public List<Page> listPagesInCourse(String courseId) throws IOException { <line2> String url = buildCanvasUrl(""courses/"" + courseId + ""/pages"", Collections.emptyMap()); <line3> return getListFromCanvas(url); <line4> } <line5> } <line6> "	<line2>
6116	"public class A { <line0> @Override <line1> public Set<? extends NodeMetadata> listNodesByIds(Iterable<String> ids) { <line2> checkNotNull(ids, ""ids""); <line3> Set<NodeMetadata> set = ImmutableSet.copyOf(listNodesStrategy.listNodesByIds(ids)); <line4> return set; <line5> } <line6> } <line7> "	<line3>, <line4>
6117	public class A { <line0> private void searchLocation(Request request) { <line1> try { <line2> Response response = searchLocation(request.getRequest(), request.getRequestContext()); <line3> sender().tell(response, self()); <line4> SearchDTO searchDto = Util.createSearchDto(request.getRequest()); <line5> String[] types = {ProjectUtil.EsType.location.getTypeName()}; <line6> generateSearchTelemetryEvent(searchDto, types, response.getResult(), request.getContext()); <line7> } catch (Exception ex) { <line8> sender().tell(ex, self()); <line9> } <line10> } <line11> } <line12> 	<line8>
6118	public class A { <line0> private CompletionStage<Boolean> fetchRebalancingStatusFromCoordinator(int attempts) { <line1> if (transport.isCoordinator()) { <line2> return CompletableFutures.completedTrue(); <line3> } <line4> ReplicableCommand command = new RebalanceStatusRequestCommand(); <line5> Address coordinator = transport.getCoordinator(); <line6> return helper <line7> .executeOnCoordinator(transport, command, getGlobalTimeout() / INITIAL_CONNECTION_ATTEMPTS) <line8> .handle( <line9> (rebalancingStatus, throwable) -> { <line10> if (throwable == null) <line11> return CompletableFuture.completedFuture( <line12> rebalancingStatus != RebalancingStatus.SUSPENDED); <line13> if (attempts == 1 || !(throwable instanceof TimeoutException)) { <line14> log.errorReadingRebalancingStatus(coordinator, throwable); <line15> return CompletableFutures.completedTrue(); <line16> } <line17> return fetchRebalancingStatusFromCoordinator(attempts - 1); <line18> }) <line19> .thenCompose(Function.identity()); <line20> } <line21> } <line22> 	<line17>
6119	public class A { <line0> @Override <line1> public User getUserByName(String userName) throws FtpException { <line2> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line3> org.structr.web.entity.User structrUser = getStructrUser(userName); <line4> tx.success(); <line5> if (structrUser != null) { <line6> return new StructrFtpUser(securityContext, structrUser); <line7> } else { <line8> return null; <line9> } <line10> } catch (FrameworkException fex) { <line11> } <line12> return null; <line13> } <line14> } <line15> 	<line11>
6120	public class A { <line0> private boolean executeConnect() throws IOException, HttpException { <line1> this.connectMethod = new ConnectMethod(this.hostConfiguration); <line2> this.connectMethod.getParams().setDefaults(this.hostConfiguration.getParams()); <line3> int code; <line4> for (; ; ) { <line5> if (!this.conn.isOpen()) { <line6> this.conn.open(); <line7> } <line8> if (this.params.isAuthenticationPreemptive() || this.state.isAuthenticationPreemptive()) { <line9> this.connectMethod.getProxyAuthState().setPreemptive(); <line10> this.connectMethod.getProxyAuthState().setAuthAttempted(true); <line11> } <line12> try { <line13> authenticateProxy(this.connectMethod); <line14> } catch (AuthenticationException e) { <line15> } <line16> applyConnectionParams(this.connectMethod); <line17> this.connectMethod.execute(state, this.conn); <line18> code = this.connectMethod.getStatusCode(); <line19> boolean retry = false; <line20> AuthState authstate = this.connectMethod.getProxyAuthState(); <line21> authstate.setAuthRequested(code == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED); <line22> if (authstate.isAuthRequested()) { <line23> if (processAuthenticationResponse(this.connectMethod)) { <line24> retry = true; <line25> } <line26> } <line27> if (!retry) { <line28> break; <line29> } <line30> if (this.connectMethod.getResponseBodyAsStream() != null) { <line31> this.connectMethod.getResponseBodyAsStream().close(); <line32> } <line33> } <line34> if ((code >= 200) && (code < 300)) { <line35> this.conn.tunnelCreated(); <line36> this.connectMethod = null; <line37> return true; <line38> } else { <line39> this.conn.close(); <line40> return false; <line41> } <line42> } <line43> } <line44> 	<line9>, <line15>
6121	public class A { <line0> @Override <line1> public int size() { <line2> int size = 0; <line3> for (PartitionedRegion prQ : this.userRegionNameToShadowPRMap.values()) { <line4> if (logger.isDebugEnabled()) { <line5> } <line6> size += prQ.size(); <line7> } <line8> return size + sender.getTmpQueuedEventSize(); <line9> } <line10> } <line11> 	<line5>
6122	"public class A { <line0> @Override <line1> protected List<LogEntry> queryAuditEntries( <line2> CoreSession session, <line3> SynchronizationRoots activeRoots, <line4> Set<String> collectionSyncRootMemberIds, <line5> long lowerBound, <line6> long upperBound, <line7> int limit) { <line8> List<LogEntry> entries = <line9> queryESAuditEntries( <line10> session, activeRoots, collectionSyncRootMemberIds, lowerBound, upperBound, limit); <line11> List<LogEntry> postFilteredEntries = new ArrayList<>(); <line12> String principalName = session.getPrincipal().getName(); <line13> for (LogEntry entry : entries) { <line14> ExtendedInfo impactedUserInfo = entry.getExtendedInfos().get(""impactedUserName""); <line15> if (impactedUserInfo != null <line16> && !principalName.equals(impactedUserInfo.getValue(String.class))) { <line17> continue; <line18> } <line19> postFilteredEntries.add(entry); <line20> } <line21> return postFilteredEntries; <line22> } <line23> } <line24> "	<line19>
6123	public class A { <line0> @Override <line1> protected void updatePortlet(String oldRootPortletId, String newRootPortletId) throws Exception { <line2> try { <line3> updateResourcePermission(oldRootPortletId, newRootPortletId, true); <line4> updateInstanceablePortletPreferences(oldRootPortletId, newRootPortletId); <line5> } catch (Exception exception) { <line6> if (_log.isWarnEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6124	public class A { <line0> @Override <line1> public Response toResponse(SelfManagedOnlyException exception) { <line2> return Response.status(Status.FORBIDDEN) <line3> .entity(new SelfManagedOnlyExceptionInfo(Status.FORBIDDEN, exception)) <line4> .build(); <line5> } <line6> } <line7> 	<line2>
6125	public class A { <line0> private String getPortIdentifier(final TransferDirection direction) throws IOException { <line1> final String id = this.portIdentifier; <line2> if (id != null) { <line3> return id; <line4> } <line5> final String portId; <line6> if (direction == TransferDirection.SEND) { <line7> portId = siteInfoProvider.getInputPortIdentifier(this.portName); <line8> } else { <line9> portId = siteInfoProvider.getOutputPortIdentifier(this.portName); <line10> } <line11> if (portId == null) { <line12> } else { <line13> this.portIdentifier = portId; <line14> } <line15> return portId; <line16> } <line17> } <line18> 	<line12>, <line13>
6126	public class A { <line0> @Override <line1> public void rdbBgsave(Jedis jedis, String host, String port) { <line2> Long currentTime = System.currentTimeMillis(); <line3> Long oldLastsave = jedis.lastsave(); <line4> jedis.bgsave(); <line5> boolean isCheck = true; <line6> while (isCheck) { <line7> try { <line8> Thread.sleep(5000); <line9> } catch (Exception e) { <line10> e.printStackTrace(); <line11> } <line12> Long lastsave = jedis.lastsave(); <line13> if (!lastsave.equals(oldLastsave)) { <line14> isCheck = false; <line15> } <line16> } <line17> } <line18> } <line19> 	<line4>, <line17>
6127	"public class A { <line0> static void verifyCertificateSigningRequest( <line1> CertificateSigningRequestDTO request, String requesterCN, CAProperties caProperties) { <line2> if (request == null) { <line3> throw new InvalidParameterException(""CertificateSigningRequest cannot be null""); <line4> } <line5> if (Utilities.isEmpty(request.getEncodedCSR())) { <line6> throw new InvalidParameterException(""CertificateSigningRequest cannot be empty""); <line7> } <line8> if (Utilities.isEmpty(requesterCN)) { <line9> throw new InvalidParameterException( <line10> ""CertificateSigningRequest requester common name cannot be empty""); <line11> } <line12> if (caProperties == null) { <line13> throw new InvalidParameterException(""CaProperties cannot be empty""); <line14> } <line15> final ZonedDateTime now = ZonedDateTime.now(); <line16> final ZonedDateTime validBefore = <line17> Utilities.parseUTCStringToLocalZonedDateTime(request.getValidBefore()); <line18> if (validBefore != null) { <line19> final ZonedDateTime validBeforeLimit = getValidBeforeLimit(now, caProperties); <line20> if (validBefore.compareTo(validBeforeLimit) > 0) { <line21> final String msg = <line22> ""Validity range parameter exceeds maximum validity range: validBefore (limit: "" <line23> + validBeforeLimit <line24> + "", got: "" <line25> + validBefore <line26> + "")""; <line27> logger.error(msg); <line28> throw new InvalidParameterException(msg); <line29> } <line30> } <line31> final ZonedDateTime validAfter = <line32> Utilities.parseUTCStringToLocalZonedDateTime(request.getValidAfter()); <line33> if (validAfter != null) { <line34> final ZonedDateTime validAfterLimit = getValidAfterLimit(now, caProperties); <line35> if (validAfter.compareTo(validAfterLimit) < 0) { <line36> final String msg = <line37> ""Validity range parameter exceeds maximum validity range: validAfter (limit: "" <line38> + validAfterLimit <line39> + "", got: "" <line40> + validAfter <line41> + "")""; <line42> throw new InvalidParameterException(msg); <line43> } <line44> } <line45> } <line46> } <line47> "	<line3>, <line6>, <line9>, <line13>, <line42>
6128	"public class A { <line0> @Ignore <line1> @Test <line2> public void shouldBeFasterWhenRunningProcessingInParallel() throws Exception { <line3> testMojoWithConfigurableWroManagerFactoryWithValidConfigFileSet(); <line4> final long begin = System.currentTimeMillis(); <line5> victim.setParallelProcessing(false); <line6> testMojoWithConfigurableWroManagerFactoryWithValidConfigFileSet(); <line7> final long endSerial = System.currentTimeMillis(); <line8> victim.setParallelProcessing(true); <line9> testMojoWithConfigurableWroManagerFactoryWithValidConfigFileSet(); <line10> final long endParallel = System.currentTimeMillis(); <line11> final long serial = endSerial - begin; <line12> final long parallel = endParallel - endSerial; <line13> assertTrue(String.format(""Serial (%s) > Parallel (%s)"", serial, parallel), serial > parallel); <line14> } <line15> } <line16> "	<line13>
6129	public class A { <line0> @Override <line1> public void close() throws Exception { <line2> if (coordinator != null) { <line3> coordinator.beginShutdown(false); <line4> } <line5> for (Agent agent : agents.values()) { <line6> agent.beginShutdown(); <line7> } <line8> for (Agent agent : agents.values()) { <line9> agent.waitForShutdown(); <line10> } <line11> if (coordinator != null) { <line12> coordinator.waitForShutdown(); <line13> } <line14> } <line15> } <line16> 	<line2>
6130	"public class A { <line0> void augmentCollectionEntryForSpecialCollections( <line1> final ObjStat objStat, <line2> final String effectiveAbsolutePath, <line3> final CollectionAndDataObjectListingEntry entry) { <line4> if (objStat.getSpecColType() == SpecColType.LINKED_COLL) { <line5> entry.setSpecialObjectPath(objStat.getObjectPath()); <line6> CollectionAndPath collectionAndPathForAbsPath = <line7> MiscIRODSUtils.separateCollectionAndPathFromGivenAbsolutePath(entry.getPathOrName()); <line8> if (entry.isCollection()) { <line9> entry.setPathOrName( <line10> objStat.getAbsolutePath() + ""/"" + collectionAndPathForAbsPath.getChildName()); <line11> entry.setParentPath(objStat.getAbsolutePath()); <line12> } else { <line13> entry.setParentPath(objStat.getAbsolutePath()); <line14> } <line15> } <line16> } <line17> } <line18> "	<line5>
6131	public class A { <line0> public static String format(Object jsonObj) { <line1> ObjectMapper mapper = getDefaultObjectMapper(false); <line2> String jsonText = null; <line3> try { <line4> jsonText = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonObj); <line5> } catch (IOException e) { <line6> } <line7> return jsonText; <line8> } <line9> } <line10> 	<line6>
6132	"public class A { <line0> @Test <line1> public void testFolderishCollection2() { <line2> DocumentModel collectionFolder; <line3> DocumentModel collectionSyncRoot; <line4> DocumentModel testDoc; <line5> List<FileSystemItemChange> changes; <line6> try { <line7> collectionFolder = <line8> session.createDocumentModel(FOLDER_1_PATH, COLLECTION_FOLDER, FOLDERISH_COLLECTION); <line9> collectionFolder = session.createDocument(collectionFolder); <line10> collectionManager.addToCollection(collectionFolder, folder1, session); <line11> nuxeoDriveManager.registerSynchronizationRoot(session.getPrincipal(), folder1, session); <line12> collectionSyncRoot = <line13> collectionManager.createCollection(session, COLLECTION_SYNC_ROOT, null, ""/""); <line14> nuxeoDriveManager.registerSynchronizationRoot( <line15> session.getPrincipal(), collectionSyncRoot, session); <line16> testDoc = session.createDocumentModel(""/"", TEST_DOC, ""File""); <line17> testDoc.setPropertyValue(FILE_CONTENT, new StringBlob(TEST_DOC_CONTENT)); <line18> testDoc = session.createDocument(testDoc); <line19> collectionManager.addToCollection(collectionFolder, testDoc, session); <line20> collectionManager.addToCollection(collectionSyncRoot, testDoc, session); <line21> } finally { <line22> commitAndWaitForAsyncCompletion(); <line23> } <line24> try { <line25> changes = getChanges(session.getPrincipal()); <line26> assertEquals(12, changes.size()); <line27> Set<SimpleFileSystemItemChange> expectedChanges = new HashSet<>(); <line28> expectedChanges.add(new SimpleFileSystemItemChange(testDoc.getId(), ADDED_TO_COLLECTION)); <line29> expectedChanges.add( <line30> new SimpleFileSystemItemChange(collectionSyncRoot.getId(), DOCUMENT_UPDATED)); <line31> expectedChanges.add( <line32> new SimpleFileSystemItemChange(collectionFolder.getId(), DOCUMENT_UPDATED)); <line33> expectedChanges.add(new SimpleFileSystemItemChange(testDoc.getId(), DOCUMENT_CREATED)); <line34> expectedChanges.add( <line35> new SimpleFileSystemItemChange(collectionSyncRoot.getId(), ROOT_REGISTERED)); <line36> expectedChanges.add( <line37> new SimpleFileSystemItemChange(collectionSyncRoot.getId(), DOCUMENT_CREATED)); <line38> expectedChanges.add(new SimpleFileSystemItemChange(folder1.getId(), ROOT_REGISTERED)); <line39> expectedChanges.add(new SimpleFileSystemItemChange(folder1.getId(), ADDED_TO_COLLECTION)); <line40> expectedChanges.add( <line41> new SimpleFileSystemItemChange(collectionFolder.getId(), DOCUMENT_CREATED)); <line42> expectedChanges.add(new SimpleFileSystemItemChange(folder1.getId(), DOCUMENT_CREATED)); <line43> assertTrue( <line44> CollectionUtils.isEqualCollection( <line45> expectedChanges, toSimpleFileSystemItemChanges(changes))); <line46> } finally { <line47> commitAndWaitForAsyncCompletion(); <line48> } <line49> } <line50> } <line51> "	<line7>
6133	public class A { <line0> public ClusterStatus checkStatus() { <line1> List<Result> pollResults = poll(); <line2> Set<String> partitions = new HashSet<String>(); <line3> Set<String> incompleteJoinNodes = new HashSet<String>(); <line4> Set<String> incompleteStateTransferNodes = new HashSet<String>(); <line5> int numAvailableNodes = 0; <line6> int numMembers = -1; <line7> boolean numMembersEqual = true; <line8> for (int j = 0; j < pollResults.size(); j++) { <line9> Result r = pollResults.get(j); <line10> Object[] tuple = (Object[]) r.value; <line11> if (tuple != null) { <line12> partitions.add((String) tuple[0]); <line13> if (!((Boolean) tuple[2])) { <line14> incompleteJoinNodes.add(getEndpoints().get(j).toString()); <line15> } <line16> if ((Boolean) tuple[3]) { <line17> incompleteStateTransferNodes.add(getEndpoints().get(j).toString()); <line18> } <line19> numAvailableNodes++; <line20> if (numMembers == -1) { <line21> numMembers = (Integer) tuple[1]; <line22> } else { <line23> if (numMembers != (Integer) tuple[1]) { <line24> numMembersEqual = false; <line25> } <line26> } <line27> } else { <line28> if (log.isTraceEnabled()) { <line29> if (r.connectError != null) { <line30> } <line31> if (r.pollError != null) { <line32> } <line33> } <line34> } <line35> } <line36> return new ClusterStatus( <line37> numAvailableNodes, <line38> (numMembersEqual ? numMembers : -1), <line39> partitions, <line40> incompleteJoinNodes, <line41> incompleteStateTransferNodes); <line42> } <line43> } <line44> 	<line8>, <line30>, <line32>
6134	"public class A { <line0> @Test <line1> public void findExperimentRunsNegativeTest() { <line2> FindExperimentRuns findExperimentRuns; <line3> try { <line4> findExperimentRuns = FindExperimentRuns.newBuilder().setProjectId(""12321"").build(); <line5> experimentRunServiceStub.findExperimentRuns(findExperimentRuns); <line6> fail(); <line7> } catch (StatusRuntimeException ex) { <line8> checkEqualsAssert(ex); <line9> } <line10> try { <line11> List<String> experimentRunIds = new ArrayList<>(); <line12> experimentRunIds.add(""abc""); <line13> experimentRunIds.add(""xyz""); <line14> findExperimentRuns = <line15> FindExperimentRuns.newBuilder().addAllExperimentRunIds(experimentRunIds).build(); <line16> experimentRunServiceStub.findExperimentRuns(findExperimentRuns); <line17> fail(); <line18> } catch (StatusRuntimeException exc) { <line19> Status status = Status.fromThrowable(exc); <line20> assertEquals(Status.PERMISSION_DENIED.getCode(), status.getCode()); <line21> } <line22> } <line23> } <line24> "	<line2>, <line20>, <line22>
6135	"public class A { <line0> @Override <line1> public Map<String, App> discoverInstalledApps() { <line2> Map<String, App> appMap = new HashMap<>(); <line3> List<App> appList = new ArrayList<>(); <line4> ObjectMapper mapper = new ObjectMapper(); <line5> mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); <line6> String path = getAppFolderPath(); <line7> apps.clear(); <line8> if (path == null) { <line9> return appMap; <line10> } <line11> File appFolderPath = new File(path); <line12> if (!appFolderPath.exists()) { <line13> return appMap; <line14> } <line15> if (!appFolderPath.isDirectory()) { <line16> } else { <line17> File[] listFiles = appFolderPath.listFiles(); <line18> if (listFiles == null) { <line19> } else { <line20> for (File folder : listFiles) { <line21> if (!folder.isDirectory()) { <line22> } else { <line23> File appManifest = new File(folder, ""manifest.webapp""); <line24> if (!appManifest.exists()) { <line25> } else { <line26> try { <line27> App app = mapper.readValue(appManifest, App.class); <line28> app.setFolderName(folder.getName()); <line29> app.setAppStorageSource(AppStorageSource.LOCAL); <line30> appList.add(app); <line31> } catch (IOException ex) { <line32> } <line33> } <line34> } <line35> } <line36> } <line37> } <line38> appList.forEach( <line39> app -> { <line40> String namespace = app.getActivities().getDhis().getNamespace(); <line41> if (namespace != null && !namespace.isEmpty()) { <line42> reservedNamespaces.put(namespace, app); <line43> } <line44> appMap.put(app.getUrlFriendlyName(), app); <line45> apps.put(app.getUrlFriendlyName(), app); <line46> }); <line47> if (appList.isEmpty()) { <line48> } <line49> return appMap; <line50> } <line51> } <line52> "	<line9>, <line13>, <line16>, <line19>, <line22>, <line25>, <line32>, <line46>, <line48>
6136	"public class A { <line0> private OAuthUser getAuthParams(AuthInfo authInfo, String code, OAuthServer server) <line1> throws IOException, InterruptedException { <line2> String requestInfoUrl = <line3> prepareUrl(server.getRequestInfoUrl(), getParams(server, code, authInfo)); <line4> HttpRequest.Builder builder = <line5> setNoCache(HttpRequest.newBuilder().uri(URI.create(requestInfoUrl))); <line6> if (server.getRequestInfoMethod() == RequestInfoMethod.HEADER) { <line7> builder.header(""Authorization"", ""Bearer "" + authInfo.accessToken); <line8> } else { <line9> builder.method(server.getRequestInfoMethod().name(), BodyPublishers.noBody()); <line10> } <line11> String json = doRequest(builder.build()); <line12> return new OAuthUser(json, server); <line13> } <line14> } <line15> "	<line12>
6137	"public class A { <line0> @Override <line1> public void actionPerformed(final ActionEvent event) { <line2> final AnalysisResult analysisResult = _result.get(); <line3> if (analysisResult == null) { <line4> WidgetUtils.showErrorMessage( <line5> ""Result not ready"", ""Please wait for the job to finish before saving the result""); <line6> return; <line7> } <line8> final DCFileChooser fileChooser = new DCFileChooser(_userPreferences.getAnalysisJobDirectory()); <line9> fileChooser.setFileFilter(FileFilters.HTML); <line10> final Component parent; <line11> if (event.getSource() instanceof Component) { <line12> parent = (Component) event.getSource(); <line13> } else { <line14> parent = null; <line15> } <line16> final int result = fileChooser.showSaveDialog(parent); <line17> if (result == JFileChooser.APPROVE_OPTION) { <line18> File file = fileChooser.getSelectedFile(); <line19> if (!file.getName().endsWith(FileFilters.HTML.getExtension())) { <line20> file = new File(file.getParentFile(), file.getName() + FileFilters.HTML.getExtension()); <line21> } <line22> if (file.exists()) { <line23> final int overwrite = <line24> JOptionPane.showConfirmDialog( <line25> parent, <line26> ""Are you sure you want to overwrite the file '"" + file.getName() + ""'?"", <line27> ""Overwrite existing file?"", <line28> JOptionPane.YES_NO_OPTION); <line29> if (overwrite != JOptionPane.YES_OPTION) { <line30> return; <line31> } <line32> } <line33> final Writer writer = FileHelper.getBufferedWriter(file); <line34> new SwingWorker<Void, Void>() { <line35> @Override <line36> protected Void doInBackground() throws Exception { <line37> final HtmlAnalysisResultWriter resultWriter = new HtmlAnalysisResultWriter(); <line38> try { <line39> resultWriter.write(analysisResult, _configuration, writer); <line40> } finally { <line41> FileHelper.safeClose(writer); <line42> } <line43> return null; <line44> } <line45>  <line46> protected void done() { <line47> try { <line48> get(); <line49> } catch (final ExecutionException e) { <line50> final Throwable cause = e.getCause(); <line51> WidgetUtils.showErrorMessage(""Error writing result to HTML page"", cause); <line52> } catch (final InterruptedException e) { <line53> } <line54> } <line55> }.execute(); <line56> } <line57> } <line58> } <line59> "	<line39>, <line40>, <line50>, <line53>
6138	"public class A { <line0> @RequestMapping(""/adminNotificationView/viewNotificationList.do"") <line1> public ModelAndView viewNotificationList(HttpServletRequest request) { <line2> logger.entry(""begin viewNotificationList()""); <line3> String sucMsg = """"; <line4> String errMsg = """"; <line5> ModelMap map = new ModelMap(); <line6> List<NotificationBO> notificationList = null; <line7> ModelAndView mav = new ModelAndView(""login"", map); <line8> try { <line9> AuditLogEventRequest auditRequest = AuditEventMapper.fromHttpServletRequest(request); <line10> if (null != request.getSession().getAttribute(FdahpStudyDesignerConstants.SUC_MSG)) { <line11> sucMsg = (String) request.getSession().getAttribute(FdahpStudyDesignerConstants.SUC_MSG); <line12> map.addAttribute(FdahpStudyDesignerConstants.SUC_MSG, sucMsg); <line13> request.getSession().removeAttribute(FdahpStudyDesignerConstants.SUC_MSG); <line14> } <line15> if (null != request.getSession().getAttribute(FdahpStudyDesignerConstants.ERR_MSG)) { <line16> errMsg = (String) request.getSession().getAttribute(FdahpStudyDesignerConstants.ERR_MSG); <line17> map.addAttribute(FdahpStudyDesignerConstants.ERR_MSG, errMsg); <line18> request.getSession().removeAttribute(FdahpStudyDesignerConstants.ERR_MSG); <line19> } <line20> notificationList = notificationService.getNotificationList(0, """"); <line21> for (NotificationBO notification : notificationList) { <line22> if (!notification.isNotificationSent() <line23> && notification <line24> .getNotificationScheduleType() <line25> .equals(FdahpStudyDesignerConstants.NOTIFICATION_NOTIMMEDIATE)) { <line26> notification.setCheckNotificationSendingStatus(""Scheduled""); <line27> } else if (!notification.isNotificationSent() <line28> && notification <line29> .getNotificationScheduleType() <line30> .equals(FdahpStudyDesignerConstants.NOTIFICATION_IMMEDIATE)) { <line31> notification.setCheckNotificationSendingStatus(""Sending""); <line32> } else if (notification.isNotificationSent()) { <line33> notification.setCheckNotificationSendingStatus(""Sent""); <line34> } <line35> } <line36> map.addAttribute(""notificationList"", notificationList); <line37> auditLogEventHelper.logEvent(APP_LEVEL_NOTIFICATION_LIST_VIEWED, auditRequest); <line38> mav = new ModelAndView(""notificationListPage"", map); <line39> } catch (Exception e) { <line40> } <line41> logger.exit(""viewNotificationList() - ends""); <line42> return mav; <line43> } <line44> } <line45> "	<line40>
6139	public class A { <line0> public void notifyTaskFailed(TaskExecutor executor, Throwable exception) { <line1> synchronized (listeners) { <line2> int size = listeners.size(); <line3> if (size > 0) { <line4> for (TaskListener listenerl : listeners) { <line5> listenerl.onFailed(executor, exception); <line6> } <line7> } else { <line8> } <line9> } <line10> } <line11> } <line12> 	<line8>
6140	public class A { <line0> @Override <line1> public InstancesInfo getApplicationInstances(CloudApplication app) { <line2> return delegate.getApplicationInstances(app); <line3> } <line4> } <line5> 	<line2>
6141	public class A { <line0> private void registerStateInternal( <line1> String id, <line2> String description, <line3> Collection<? extends String> tags, <line4> Collection<? extends String> modules, <line5> Object state) { <line6> if (LOGGER.isDebugEnabled()) { <line7> } <line8> List<String> allModules = New.list(modules); <line9> allModules.addAll(getAlwaysActivateModules()); <line10> addStateToMap(id, description, tags, modules, state); <line11> saveToPreferences(); <line12> } <line13> } <line14> 	<line7>
6142	public class A { <line0> @Override <line1> public void channelActive(ChannelHandlerContext ctx) throws Exception { <line2> if (LOG.isTraceEnabled()) { <line3> } <line4> producer.getAllChannels().add(ctx.channel()); <line5> disconnecting = false; <line6> messageReceived = false; <line7> exceptionHandled = false; <line8> super.channelActive(ctx); <line9> } <line10> } <line11> 	<line3>
6143	public class A { <line0> private void resetPrivateKeyProviders( <line1> CipherFactory newCipherFactory, SecurityConfiguration config) { <line2> myPreselectedCertMap.clear(); <line3> for (final Iterator<? extends EncryptedPrivateKeyAndCertChain> iter = <line4> config.getEncryptedPrivateKeyAndCertChains().iterator(); <line5> iter.hasNext(); ) { <line6> final EncryptedPrivateKeyAndCertChain key = iter.next(); <line7> PrivateKey privateKey; <line8> try { <line9> privateKey = key.getPrivateKey(getCipherFactory()); <line10> try { <line11> key.setPrivateKey(privateKey, newCipherFactory); <line12> } catch (final GeneralSecurityException e) { <line13> iter.remove(); <line14> continue; <line15> } <line16> } catch (final NoSuchAlgorithmException e) { <line17> iter.remove(); <line18> continue; <line19> } catch (final GeneralSecurityException e) { <line20> if (LOGGER.isDebugEnabled()) { <line21> } <line22> iter.remove(); <line23> continue; <line24> } <line25> } <line26> } <line27> } <line28> 	<line13>, <line17>, <line21>
6144	"public class A { <line0> public boolean validateChannel(final Channel channel) { <line1> boolean ret = false; <line2> final SetVarAction var = new SetVarAction(channel, ""testState"", ""1""); <line3> ManagerResponse response = null; <line4> try { <line5> AsteriskPBX pbx = (AsteriskPBX) PBXFactory.getActivePBX(); <line6> response = pbx.sendAction(var, 500); <line7> } catch (final Exception e) { <line8> } <line9> if ((response != null) <line10> && (response.getAttribute(""Response"").compareToIgnoreCase(""success"") == 0)) { <line11> ret = true; <line12> } <line13> return ret; <line14> } <line15> } <line16> "	<line8>
6145	public class A { <line0> public boolean isOnline() throws InterruptedException { <line1> try { <line2> String url = this.getPublicInformationUrl(); <line3> Request request = this.createRequest(url, GET); <line4> ContentResponse contentResponse = request.send(); <line5> if (HttpStatus.getCode(contentResponse.getStatus()).isSuccess()) { <line6> String content = contentResponse.getContentAsString(); <line7> return true; <line8> } else { <line9> return false; <line10> } <line11> } catch (TimeoutException | ExecutionException | NullPointerException e) { <line12> return false; <line13> } <line14> } <line15> } <line16> 	<line7>, <line9>, <line12>
6146	"public class A { <line0> private void restoreBackupInsideLock( <line1> String workspaceId, <line2> String srcPath, <line3> String destinationPath, <line4> String destUserId, <line5> String destGroupId, <line6> String destUserName, <line7> String destAddress, <line8> int destPort) <line9> throws ServerException { <line10> boolean restored = false; <line11> ReentrantLock lock = new ReentrantLock(); <line12> lock.lock(); <line13> try { <line14> if (workspacesBackupLocks.putIfAbsent(workspaceId, lock) != null) { <line15> String err = <line16> ""Restore of workspace "" <line17> + workspaceId <line18> + "" failed. Another restore process of the same workspace is in progress""; <line19> throw new ServerException(err); <line20> } <line21> Files.createDirectories(Paths.get(srcPath)); <line22> CommandLine commandLine = <line23> new CommandLine( <line24> restoreScript, <line25> srcPath, <line26> destinationPath, <line27> destAddress, <line28> Integer.toString(destPort), <line29> destUserId, <line30> destGroupId, <line31> destUserName); <line32> executeCommand( <line33> commandLine.asArray(), <line34> restoreDuration, <line35> destAddress, <line36> workspaceId, <line37> RESTORE_SUCCESS_RETURN_CODES); <line38> restored = true; <line39> } catch (TimeoutException e) { <line40> throw new ServerException( <line41> ""Restoring of workspace "" <line42> + workspaceId <line43> + "" filesystem terminated due to timeout on "" <line44> + destAddress <line45> + "" node.""); <line46> } catch (InterruptedException e) { <line47> Thread.currentThread().interrupt(); <line48> throw new ServerException( <line49> ""Restoring of workspace "" <line50> + workspaceId <line51> + "" filesystem interrupted on "" <line52> + destAddress <line53> + "" node.""); <line54> } catch (IOException e) { <line55> String error = <line56> ""Restoring of workspace "" <line57> + workspaceId <line58> + "" filesystem terminated on "" <line59> + destAddress <line60> + "" node. "" <line61> + e.getLocalizedMessage(); <line62> throw new ServerException(error); <line63> } finally { <line64> lock.unlock(); <line65> if (!restored) { <line66> workspacesBackupLocks.remove(workspaceId, lock); <line67> } <line68> } <line69> } <line70> } <line71> "	<line19>, <line62>
6147	"public class A { <line0> public static void checkStopWithSavepointPreconditions( <line1> CheckpointCoordinator checkpointCoordinator, <line2> @Nullable String targetDirectory, <line3> JobID jobId, <line4> Logger logger) { <line5> if (checkpointCoordinator == null) { <line6> throw new IllegalStateException(String.format(""Job %s is not a streaming job."", jobId)); <line7> } <line8> if (targetDirectory == null <line9> && !checkpointCoordinator.getCheckpointStorage().hasDefaultSavepointLocation()) { <line10> throw new IllegalStateException( <line11> ""No savepoint directory configured. You can either specify a directory "" <line12> + ""while cancelling via -s :targetDirectory or configure a cluster-wide "" <line13> + ""default via key '"" <line14> + CheckpointingOptions.SAVEPOINT_DIRECTORY.key() <line15> + ""'.""); <line16> } <line17> } <line18> } <line19> "	<line10>
6148	"public class A { <line0> public static String getTaskManagerShellCommand( <line1> Configuration flinkConfig, <line2> ContaineredTaskManagerParameters tmParams, <line3> String configDirectory, <line4> String logDirectory, <line5> boolean hasLogback, <line6> boolean hasLog4j, <line7> boolean hasKrb5, <line8> Class<?> mainClass, <line9> String mainArgs) { <line10> final Map<String, String> startCommandValues = new HashMap<>(); <line11> startCommandValues.put(""java"", ""$JAVA_HOME/bin/java""); <line12> final TaskExecutorProcessSpec taskExecutorProcessSpec = tmParams.getTaskExecutorProcessSpec(); <line13> startCommandValues.put( <line14> ""jvmmem"", ProcessMemoryUtils.generateJvmParametersStr(taskExecutorProcessSpec)); <line15> String javaOpts = flinkConfig.getString(CoreOptions.FLINK_JVM_OPTIONS); <line16> if (flinkConfig.getString(CoreOptions.FLINK_TM_JVM_OPTIONS).length() > 0) { <line17> javaOpts += "" "" + flinkConfig.getString(CoreOptions.FLINK_TM_JVM_OPTIONS); <line18> } <line19> if (hasKrb5) { <line20> javaOpts += "" -Djava.security.krb5.conf=krb5.conf""; <line21> } <line22> startCommandValues.put(""jvmopts"", javaOpts); <line23> String logging = """"; <line24> if (hasLogback || hasLog4j) { <line25> logging = ""-Dlog.file="" + logDirectory + ""/taskmanager.log""; <line26> if (hasLogback) { <line27> logging += "" -Dlogback.configurationFile=file:"" + configDirectory + ""/logback.xml""; <line28> } <line29> if (hasLog4j) { <line30> logging += "" -Dlog4j.configuration=file:"" + configDirectory + ""/log4j.properties""; <line31> logging += "" -Dlog4j.configurationFile=file:"" + configDirectory + ""/log4j.properties""; <line32> } <line33> } <line34> startCommandValues.put(""logging"", logging); <line35> startCommandValues.put(""class"", mainClass.getName()); <line36> startCommandValues.put( <line37> ""redirects"", <line38> ""1> "" + logDirectory + ""/taskmanager.out "" + ""2> "" + logDirectory + ""/taskmanager.err""); <line39> String argsStr = <line40> TaskExecutorProcessUtils.generateDynamicConfigsStr(taskExecutorProcessSpec) <line41> + "" --configDir "" <line42> + configDirectory; <line43> if (!mainArgs.isEmpty()) { <line44> argsStr += "" "" + mainArgs; <line45> } <line46> startCommandValues.put(""args"", argsStr); <line47> final String commandTemplate = <line48> flinkConfig.getString( <line49> ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE, <line50> ConfigConstants.DEFAULT_YARN_CONTAINER_START_COMMAND_TEMPLATE); <line51> String startCommand = getStartCommand(commandTemplate, startCommandValues); <line52> return startCommand; <line53> } <line54> } <line55> "	<line52>
6149	"public class A { <line0> @Test <line1> public void test_12_BRCA_Splice_15_Hgvs() { <line2> int spliceSize = 15; <line3> String genome = ""test_BRCA""; <line4> String vcf = path(""test_BRCA_splice_15.vcf""); <line5> String args[] = {genome, vcf}; <line6> SnpEffCmdEff snpeff = new SnpEffCmdEff(); <line7> snpeff.parseArgs(args); <line8> snpeff.setDebug(debug); <line9> snpeff.setVerbose(verbose); <line10> snpeff.setSupressOutput(!verbose); <line11> snpeff.setFormatVersion(EffFormatVersion.FORMAT_EFF_4); <line12> snpeff.setSpliceSiteSize(spliceSize); <line13> snpeff.setUpDownStreamLength(0); <line14> snpeff.setShiftHgvs(false); <line15> List<VcfEntry> results = snpeff.run(true); <line16> VcfEntry ve = results.get(0); <line17> boolean ok = false; <line18> for (VcfEffect veff : ve.getVcfEffects()) { <line19> if (verbose) <line20> ok |= <line21> veff.getTranscriptId().equals(""ENST00000544455"") <line22> && veff.getHgvsDna().equals(""c.1909+12delT""); <line23> } <line24> Assert.assertTrue(ok); <line25> } <line26> } <line27> "	<line2>, <line20>
6150	public class A { <line0> @Override <line1> public boolean execute(Map<Object, Object> context) { <line2> synchronized (jobStatus) { <line3> if (!jobStatus.isRunning() && !jobStatus.isStopped()) { <line4> jobStatus.setRunning(true); <line5> jobStatus.setExecutionStartDate(new Date()); <line6> } else { <line7> if (logger.isDebugEnabled()) { <line8> } <line9> return false; <line10> } <line11> } <line12> if (logger.isDebugEnabled()) { <line13> } <line14> JobExecution execution = createExecution(context); <line15> try { <line16> onJobExecution(new JobExecutionEvent(execution)); <line17> job.init(execution); <line18> job.execute(); <line19> synchronized (jobStatus) { <line20> jobStatus.setExecutionEndDate(new Date()); <line21> jobStatus.setRunning(false); <line22> } <line23> onJobExecution(new JobExecutionEvent(execution)); <line24> } catch (Throwable failure) { <line25> if (logger.isDebugEnabled()) { <line26> } <line27> synchronized (jobStatus) { <line28> jobStatus.setExecutionEndDate(new Date()); <line29> jobStatus.setRunning(false); <line30> jobStatus.setFailure(failure); <line31> } <line32> onJobExecution(new JobExecutionEvent(execution)); <line33> } finally { <line34> try { <line35> job.close(); <line36> } catch (Exception exception) { <line37> if (logger.isDebugEnabled()) { <line38> } <line39> } <line40> } <line41> return true; <line42> } <line43> } <line44> 	<line8>, <line13>, <line26>, <line38>
6151	public class A { <line0> public void persist(StgMsCmState transientInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().persist(transientInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
6152	public class A { <line0> public void addLogln(String message) { <line1> progressStatus.append(message); <line2> progressStatus.append(NEWLINE); <line3> } <line4> } <line5> 	<line1>
6153	public class A { <line0> public PTNetworkSourceTypeEnum readPTNetworkSourceType(String netexSourceType) { <line1> if (netexSourceType == null) return null; <line2> PTNetworkSourceTypeEnum sourceType = null; <line3> try { <line4> sourceType = PTNetworkSourceTypeEnum.valueOf(firstLetterUpcase(netexSourceType)); <line5> } catch (Exception e) { <line6> } <line7> return sourceType; <line8> } <line9> } <line10> 	<line6>
6154	"public class A { <line0> @Override <line1> public void onTransaction(final Transaction<Store> transaction) { <line2> final ObjectStore userObjectStore = transaction.getObjectStore(Store.USER); <line3> final Index organizationIndex = userObjectStore.index(""organization""); <line4> final OpenCursorRequest openCursorRequest = <line5> organizationIndex.openCursor(IDBKeyRange.only(organizationId)); <line6> final ArrayList<UserDTO> users = new ArrayList<UserDTO>(); <line7> openCursorRequest.addCallback( <line8> new AsyncCallback<Request>() { <line9> @Override <line10> public void onFailure(Throwable caught) { <line11> callback.onFailure(caught); <line12> } <line13>  <line14> @Override <line15> public void onSuccess(Request request) { <line16> final Cursor cursor = openCursorRequest.getResult(); <line17> if (cursor != null) { <line18> final UserJS userJS = (UserJS) cursor.getValue(); <line19> final UserDTO userDTO = userJS.toDTO(); <line20> if (userJS.hasMainOrgUnit()) { <line21> orgUnitDAO.get( <line22> userJS.getMainOrgUnit(), <line23> new AsyncCallback<OrgUnitDTO>() { <line24> @Override <line25> public void onFailure(Throwable caught) { <line26> } <line27>  <line28> @Override <line29> public void onSuccess(OrgUnitDTO result) { <line30> userDTO.setMainOrgUnit(result); <line31> } <line32> }, <line33> transaction); <line34> } <line35> users.add(userDTO); <line36> cursor.next(); <line37> } else { <line38> callback.onSuccess(new ListResult<UserDTO>(users)); <line39> } <line40> } <line41> }); <line42> } <line43> } <line44> "	<line26>
6155	public class A { <line0> private static String nextLine(LineProducer lineProducer) throws IllegalArgumentException { <line1> try { <line2> return lineProducer.nextLine(); <line3> } catch (IOException e1) { <line4> throw new IllegalArgumentException(e1); <line5> } <line6> } <line7> } <line8> 	<line4>
6156	"public class A { <line0> private void onUploadSuccess(final String result) { <line1> final FileUploadResponse response = FileUploadResponse.parse(result); <line2> final FileVersionDTO fileVersion = response.getFileVersion(); <line3> final MonitoredPointDTO point = response.getMonitoredPoint(); <line4> if (fileVersion == null) { <line5> throw new UnsupportedOperationException(""Invalid required file version.""); <line6> } <line7> fileVersion.setAvailable(true); <line8> final ReportReference reportReference = new ReportReference(fileVersion); <line9> reportReference.setId(fileVersion.getId()); <line10> reportReference.setName(view.getFileUploadButtonField().getValue()); <line11> reportReference.setLastEditDate(new Date()); <line12> reportReference.setEditorName(auth().getUserShortName()); <line13> reportReference.setFlexibleElementLabel((String) view.getElementField().getValue()); <line14> reportReference.setPhaseName((String) view.getPhaseField().getValue()); <line15> N10N.infoNotif( <line16> I18N.CONSTANTS.infoConfirmation(), <line17> I18N.CONSTANTS.flexibleElementFilesListUploadFileConfirm()); <line18> if (point != null) { <line19> if (Log.isDebugEnabled()) { <line20> } <line21> N10N.infoNotif(I18N.CONSTANTS.infoConfirmation(), I18N.CONSTANTS.monitoredPointAddConfirm()); <line22> } <line23> eventBus.fireEvent(new UpdateEvent(UpdateEvent.REPORT_DOCUMENTS_UPDATE, reportReference)); <line24> hideView(); <line25> } <line26> } <line27> "	<line20>
6157	"public class A { <line0> public Map<String, Long> getAppsBySeverity(String assetGroup, String parentType, String severity) <line1> throws Exception { <line2> Map<String, Long> appDetails = new HashMap<>(); <line3> StringBuilder urlToQuery = new StringBuilder(esUrl).append(""/"").append(assetGroup); <line4> urlToQuery.append(""/"").append(parentType); <line5> urlToQuery.append(""/"").append(SEARCH); <line6> StringBuilder requestBody = <line7> new StringBuilder( <line8> ""{\""size\"":0,\""query\"":{\""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}}]}},"" <line9> + ""\""aggs\"":{\""apps\"":{\""terms\"":{\""field\"":\""tags.Application.keyword\"",\""size\"":10000},"" <line10> + ""\""aggs\"":{\""vulns\"":{\""children\"":{\""type\"":\""vulninfo\""},\""aggs\"":{\""NAME\"":{\""filters\"":{\""filters\"":{\""severity\"":{\""terms\"":{\""severitylevel.keyword\"":[""); <line11> requestBody.append(severity); <line12> requestBody.append(""]}}}}}}}}}}}""); <line13> String responseJson = """"; <line14> try { <line15> responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString()); <line16> } catch (Exception e) { <line17> throw e; <line18> } <line19> JsonParser jsonParser = new JsonParser(); <line20> JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson); <line21> JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString()); <line22> JsonArray buckets = aggsJson.getAsJsonObject(""apps"").getAsJsonArray(BUCKETS); <line23> if (buckets.size() > 0) { <line24> for (int i = 0; i < buckets.size(); i++) { <line25> appDetails.put( <line26> buckets.get(i).getAsJsonObject().get(""key"").getAsString(), <line27> buckets <line28> .get(i) <line29> .getAsJsonObject() <line30> .getAsJsonObject(""vulns"") <line31> .getAsJsonObject(""NAME"") <line32> .getAsJsonObject(""buckets"") <line33> .getAsJsonObject(""severity"") <line34> .get(DOC_COUNT) <line35> .getAsLong()); <line36> } <line37> } <line38> return appDetails; <line39> } <line40> } <line41> "	<line17>
6158	public class A { <line0> public void reconfigure(Dictionary<String, ?> props) { <line1> if (props == null) { <line2> if (bundleTracker != null) { <line3> bundleTracker.close(); <line4> } <line5> HttpContextTracker tracker = httpContextTrackers.remove(pid); <line6> if (tracker != null && symbolicName != null) { <line7> configExecutor.execute(tracker::cleanupContext); <line8> } <line9> properties = null; <line10> } else { <line11> if (bundleTracker != null) { <line12> bundleTracker.close(); <line13> configExecutor.execute(this::cleanupContext); <line14> } <line15> if (props.get(KEY_BUNDLE_SN) == null) { <line16> return; <line17> } <line18> properties = props; <line19> symbolicName = properties.get(KEY_BUNDLE_SN).toString().trim(); <line20> if (bundleTracker == null) { <line21> bundleTracker = new BundleTracker<>(serviceContext, Bundle.ACTIVE, this); <line22> } <line23> bundleTracker.open(); <line24> } <line25> } <line26> } <line27> 	<line16>
6159	public class A { <line0> private ModulesConfigurationProperties getModulesConfigurationPropertiesFallback( <line1> String serviceName, Throwable e) { <line2> e.printStackTrace(); <line3> return null; <line4> } <line5> } <line6> 	<line2>
6160	"public class A { <line0> protected void setDesiredAutoCommit(boolean desiredAutoCommit) { <line1> try { <line2> if (connection.getAutoCommit() != desiredAutoCommit) { <line3> if (log.isDebugEnabled()) { <line4> } <line5> connection.setAutoCommit(desiredAutoCommit); <line6> } <line7> } catch (SQLException e) { <line8> throw new TransactionException( <line9> ""Error configuring AutoCommit.  "" <line10> + ""Your driver may not support getAutoCommit() or setAutoCommit(). "" <line11> + ""Requested setting: "" <line12> + desiredAutoCommit <line13> + "".  Cause: "" <line14> + e, <line15> e); <line16> } <line17> } <line18> } <line19> "	<line4>
6161	public class A { <line0> public void run() { <line1> initedLatch.countDown(); <line2> long lastDiscardCount = 0; <line3> int errorCount = 0; <line4> for (; ; ) { <line5> try { <line6> lock.lockInterruptibly(); <line7> } catch (InterruptedException e2) { <line8> break; <line9> } <line10> long discardCount = DruidDataSource.this.discardCount; <line11> boolean discardChanged = discardCount - lastDiscardCount > 0; <line12> lastDiscardCount = discardCount; <line13> try { <line14> boolean emptyWait = true; <line15> if (createError != null && poolingCount == 0 && !discardChanged) { <line16> emptyWait = false; <line17> } <line18> if (emptyWait && asyncInit && createCount < initialSize) { <line19> emptyWait = false; <line20> } <line21> if (emptyWait) { <line22> if (poolingCount >= notEmptyWaitThreadCount <line23> && (!(keepAlive && activeCount + poolingCount < minIdle)) <line24> && !isFailContinuous()) { <line25> empty.await(); <line26> } <line27> if (activeCount + poolingCount >= maxActive) { <line28> empty.await(); <line29> continue; <line30> } <line31> } <line32> } catch (InterruptedException e) { <line33> lastCreateError = e; <line34> lastErrorTimeMillis = System.currentTimeMillis(); <line35> if ((!closing) && (!closed)) { <line36> } <line37> break; <line38> } finally { <line39> lock.unlock(); <line40> } <line41> PhysicalConnectionInfo connection = null; <line42> try { <line43> connection = createPhysicalConnection(); <line44> } catch (SQLException e) { <line45> errorCount++; <line46> if (errorCount > connectionErrorRetryAttempts && timeBetweenConnectErrorMillis > 0) { <line47> setFailContinuous(true); <line48> if (failFast) { <line49> lock.lock(); <line50> try { <line51> notEmpty.signalAll(); <line52> } finally { <line53> lock.unlock(); <line54> } <line55> } <line56> if (breakAfterAcquireFailure) { <line57> break; <line58> } <line59> try { <line60> Thread.sleep(timeBetweenConnectErrorMillis); <line61> } catch (InterruptedException interruptEx) { <line62> break; <line63> } <line64> } <line65> } catch (RuntimeException e) { <line66> setFailContinuous(true); <line67> continue; <line68> } catch (Error e) { <line69> setFailContinuous(true); <line70> break; <line71> } <line72> if (connection == null) { <line73> continue; <line74> } <line75> boolean result = put(connection); <line76> if (!result) { <line77> JdbcUtils.close(connection.getPhysicalConnection()); <line78> } <line79> errorCount = 0; <line80> if (closing || closed) { <line81> break; <line82> } <line83> } <line84> } <line85> } <line86> 	<line36>, <line45>, <line66>, <line69>, <line78>
6162	"public class A { <line0> public List<AttributeInterface> getAllowedNestedTypes(AttributeInterface listType) { <line1> List<AttributeInterface> attributes = new ArrayList<AttributeInterface>(); <line2> try { <line3> IEntityManager entityManager = this.getEntityManager(); <line4> Map<String, AttributeInterface> attributeTypes = entityManager.getEntityAttributePrototypes(); <line5> Iterator<AttributeInterface> attributeIter = attributeTypes.values().iterator(); <line6> while (attributeIter.hasNext()) { <line7> AttributeInterface attribute = attributeIter.next(); <line8> boolean simple = attribute.isSimple(); <line9> boolean multiLanguage = attribute.isMultilingual(); <line10> if ((listType instanceof ListAttribute && simple && !multiLanguage) <line11> || (listType instanceof MonoListAttribute <line12> && !(attribute instanceof AbstractListAttribute))) { <line13> attributes.add(attribute); <line14> } <line15> } <line16> Collections.sort(attributes, new BeanComparator(""type"")); <line17> } catch (Throwable t) { <line18> throw new RuntimeException(""Error while extracting Allowed Nested Types"", t); <line19> } <line20> return attributes; <line21> } <line22> } <line23> "	<line18>
6163	"public class A { <line0> protected String toQueryStr(final URI type) { <line1> final StringBuilder sb = new StringBuilder(); <line2> if (type == VERTEX) { <line3> sb.append(""construct { ?x <"" + TYPE + ""> <"" + type + ""> . }\n""); <line4> sb.append(""{\n  select distinct ?x where {\n""); <line5> } else { <line6> sb.append(""construct { ?from ?x ?to . }\n""); <line7> sb.append(""{\n  select distinct ?from ?x ?to where {\n""); <line8> sb.append(""    ?from ?x ?to .\n""); <line9> } <line10> final BlueprintsValueFactory factory = graph.factory; <line11> boolean hasHas = false; <line12> int i = 1; <line13> for (Has has : criteria) { <line14> if (log.isTraceEnabled()) { <line15> } <line16> if (has instanceof HasNot) { <line17> sb.append(""    filter not exists { ""); <line18> sb.append(""?x <"").append(factory.toPropertyURI(has.key)).append(""> ""); <line19> if (has.val != null) { <line20> final String val = factory.toLiteral(has.val).toString(); <line21> sb.append(val).append("" .""); <line22> } else { <line23> final String var = ""?val"" + i; <line24> sb.append(var).append("" .""); <line25> } <line26> sb.append(""}\n""); <line27> } else { <line28> hasHas = true; <line29> sb.append(""    ?x <"").append(factory.toPropertyURI(has.key)).append(""> ""); <line30> if (has.val != null && (has.pred == null || has.pred == BigdataPredicate.EQ)) { <line31> final Literal val = factory.toLiteral(has.val); <line32> sb.append(val).append("" .\n""); <line33> } else { <line34> final String var = ""?val"" + i; <line35> sb.append(var).append("" .\n""); <line36> if (has.pred != null) { <line37> sb.append(toFilterStr(has.pred, var, has.val)).append(""\n""); <line38> } <line39> } <line40> } <line41> i++; <line42> } <line43> if (!hasHas) { <line44> sb.append(""    ?x <"" + TYPE + ""> <"").append(type).append(""> .\n""); <line45> } <line46> sb.append(""  }""); <line47> if (limit < Integer.MAX_VALUE) { <line48> sb.append("" limit "" + factory.toLiteral(limit).getLabel()); <line49> } <line50> sb.append(""\n}""); <line51> if (log.isTraceEnabled()) { <line52> } <line53> return sb.toString(); <line54> } <line55> } <line56> "	<line15>, <line52>
6164	"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""scenarios"") <line2> public void testWriteBlocked(Scenario scenario) throws Exception { <line3> init(scenario); <line4> try (Socket client = _scenario.newClient(_connector)) { <line5> client.setSoTimeout(10000); <line6> try (SocketChannel server = _connector.accept()) { <line7> server.configureBlocking(false); <line8> _manager.accept(server); <line9> _writeCount.set(10000); <line10> String data = ""Now is the time for all good men to come to the aid of the party""; <line11> client.getOutputStream().write(data.getBytes(StandardCharsets.UTF_8)); <line12> BufferedInputStream in = new BufferedInputStream(client.getInputStream()); <line13> int byteNum = 0; <line14> try { <line15> for (int i = 0; i < _writeCount.get(); i++) { <line16> if (i % 1000 == 0) TimeUnit.MILLISECONDS.sleep(200); <line17> for (int j = 0; j < data.length(); j++) { <line18> char c = data.charAt(j); <line19> int b = in.read(); <line20> byteNum++; <line21> assertTrue(b > 0); <line22> assertEquals(c, (char) b, ""test-"" + i + ""/"" + j); <line23> } <line24> if (i == 0) _lastEndPoint.setIdleTimeout(60000); <line25> } <line26> } catch (SocketTimeoutException e) { <line27> System.err.println(""SelectorManager.dump() = "" + _manager.dump()); <line28> throw e; <line29> } <line30> client.close(); <line31> for (int i = 0; i < 10; ++i) { <line32> if (server.isOpen()) Thread.sleep(10); <line33> else break; <line34> } <line35> assertFalse(server.isOpen()); <line36> } <line37> } <line38> } <line39> } <line40> "	<line28>
6165	"public class A { <line0> @Override <line1> public void close(boolean cleanLog, CloseOperation operation) throws IOException { <line2> if (!closed.compareAndSet(false, true)) { <line3> return; <line4> } <line5> waitOnDeletions(); <line6> if (treeRootNode != null) { <line7> treeRootNode.markChanged(); <line8> treeRootNode.release(); <line9> if (treeRootNode.getLeaseCount() != 0) { <line10> throw new IllegalStateException(""invalid root state on shutdown : "" + treeRootNode); <line11> } <line12> } <line13> if (treeTrashNode != null) { <line14> treeTrashNode.markChanged(); <line15> treeTrashNode.release(); <line16> } <line17> sync(); <line18> if (source != null) { <line19> int status = source.close(cleanLog, operation); <line20> if (status != 0) { <line21> throw new RuntimeException(""page db close returned a non-zero exit code : "" + status); <line22> } <line23> } <line24> if (logger != null) { <line25> logger.terminate(); <line26> } <line27> } <line28> } <line29> "	<line3>, <line5>
6166	public class A { <line0> private SortByType buildSortBy(QName featureType, SortBy incomingSortBy) { <line1> net.opengis.filter.v_1_1_0.ObjectFactory filterObjectFactory = <line2> new net.opengis.filter.v_1_1_0.ObjectFactory(); <line3> String propertyName = <line4> mapSortByPropertyName( <line5> featureType, incomingSortBy.getPropertyName().getPropertyName(), metacardMappers); <line6> if (propertyName != null) { <line7> SortOrder sortOrder = incomingSortBy.getSortOrder(); <line8> SortPropertyType sortPropertyType = filterObjectFactory.createSortPropertyType(); <line9> PropertyNameType propertyNameType = filterObjectFactory.createPropertyNameType(); <line10> List<Serializable> props = Arrays.asList(propertyName); <line11> propertyNameType.setContent(props); <line12> sortPropertyType.setPropertyName(propertyNameType); <line13> if (SortOrder.ASCENDING.equals(sortOrder)) { <line14> sortPropertyType.setSortOrder(SortOrderType.ASC); <line15> } else if (SortOrder.DESCENDING.equals(sortOrder)) { <line16> sortPropertyType.setSortOrder(SortOrderType.DESC); <line17> } else { <line18> return null; <line19> } <line20> SortByType sortByType = filterObjectFactory.createSortByType(); <line21> sortByType.getSortProperty().add(sortPropertyType); <line22> return sortByType; <line23> } <line24> return null; <line25> } <line26> } <line27> 	<line18>
6167	"public class A { <line0> private void decodeVideo( <line1> DataTypeInfo dataType, InputStream inStream, long startTime, VideoPositionTracker tracker) { <line2> Runnable emptyHandler = () -> {}; <line3> try (CancellableInputStream cancellableStream = <line4> new CancellableInputStream(inStream, emptyHandler)) { <line5> Iterator<VideoDecoder> decodersIterator = ServiceLoader.load(VideoDecoder.class).iterator(); <line6> if (!decodersIterator.hasNext()) { <line7> throw new IllegalStateException(""Could not find a decoder for processing video.""); <line8> } <line9> VideoDecoder videoDecoder = decodersIterator.next(); <line10> videoDecoder.setInputStream(cancellableStream, TimeInstant.get(startTime)); <line11> videoDecoder.registerVideoContentHandler(new OSHVideoContentHandler(dataType, tracker), null); <line12> videoDecoder.decode(); <line13> } catch (IOException | VideoDecoderException e) { <line14> } <line15> } <line16> } <line17> "	<line14>
6168	"public class A { <line0> @Override <line1> public Authentication attemptAuthentication( <line2> HttpServletRequest request, HttpServletResponse response) <line3> throws AuthenticationException, IOException, ServletException { <line4> SpringSocialSecuritySignInDetails signInDetails = <line5> (SpringSocialSecuritySignInDetails) <line6> request <line7> .getSession() <line8> .getAttribute( <line9> SpringSocialSecuritySignInService.SIGN_IN_DETAILS_SESSION_ATTRIBUTE_NAME); <line10> String alreadyAuthenticatedUserId = AuthenticatedUserIdHolder.getAuthenticatedUserId(); <line11> if (signInDetails != null) { <line12> UserDetails user = <line13> userDetailsService.loadUserByUsername( <line14> signInDetails.getConnectionData().getProviderId() <line15> + Constants.USER_NAME_SPLITTER <line16> + signInDetails.getUserId()); <line17> if (removeSignInDetailsFromSessionOnSuccessfulAuthentication) { <line18> request <line19> .getSession() <line20> .removeAttribute( <line21> SpringSocialSecuritySignInService.SIGN_IN_DETAILS_SESSION_ATTRIBUTE_NAME); <line22> } <line23> updateUserKeys(signInDetails.getConnectionData(), signInDetails.getUserId()); <line24> return authenticationFactory.createAuthenticationFromUserDetails(user); <line25> } else if (allowRepeatedAuthenticationAttempts && alreadyAuthenticatedUserId != null) { <line26> return SecurityContextHolder.getContext().getAuthentication(); <line27> } else { <line28> throw new InsufficientAuthenticationException( <line29> ""SpringSocialSecurity sign in details not found in session""); <line30> } <line31> } <line32> } <line33> "	<line28>
6169	"public class A { <line0> @Override <line1> protected void before() throws Throwable { <line2> server = <line3> H2ServerBootstrap.bootstrap() <line4> .setLookupRegistry(new UriPatternMatcher<>()) <line5> .setVersionPolicy(HttpVersionPolicy.NEGOTIATE) <line6> .setIOReactorConfig(IOReactorConfig.custom().setSoTimeout(TIMEOUT).build()) <line7> .setTlsStrategy( <line8> scheme == URIScheme.HTTPS <line9> ? new H2ServerTlsStrategy(SSLTestContexts.createServerSSLContext()) <line10> : null) <line11> .setStreamListener(LoggingHttp1StreamListener.INSTANCE_SERVER) <line12> .setStreamListener(LoggingH2StreamListener.INSTANCE) <line13> .setIOSessionDecorator(LoggingIOSessionDecorator.INSTANCE) <line14> .setExceptionCallback(LoggingExceptionCallback.INSTANCE) <line15> .setIOSessionListener(LoggingIOSessionListener.INSTANCE) <line16> .register(""*"", () -> new EchoHandler(2048)) <line17> .create(); <line18> } <line19> } <line20> "	<line2>
6170	"public class A { <line0> public MediaPackageElement newElement( <line1> MediaPackageElement.Type type, MediaPackageElementFlavor flavor) { <line2> List<MediaPackageElementBuilderPlugin> candidates = <line3> new ArrayList<MediaPackageElementBuilderPlugin>(); <line4> for (Class<? extends MediaPackageElementBuilderPlugin> pluginClass : plugins) { <line5> MediaPackageElementBuilderPlugin plugin = createPlugin(pluginClass); <line6> if (plugin.accept(type, flavor)) { <line7> candidates.add(plugin); <line8> } <line9> } <line10> if (candidates.size() == 0) return null; <line11> else if (candidates.size() > 1) { <line12> StringBuffer buf = new StringBuffer(); <line13> for (MediaPackageElementBuilderPlugin plugin : candidates) { <line14> if (buf.length() > 0) buf.append("", ""); <line15> buf.append(plugin.toString()); <line16> } <line17> } <line18> MediaPackageElementBuilderPlugin builderPlugin = candidates.get(0); <line19> MediaPackageElement element = builderPlugin.newElement(type, flavor); <line20> builderPlugin.destroy(); <line21> return element; <line22> } <line23> } <line24> "	<line17>
6171	"public class A { <line0> @Test(description = ""Deploy autoscaling policy"", timeOut = APPLICATION_TEST_TIMEOUT) <line1> public void testAutoscalingPolicy() throws Exception { <line2> String policyId = ""autoscaling-policy-autoscaling-policy-test""; <line3> boolean added = <line4> restClient.addEntity( <line5> RESOURCES_PATH + RestConstants.AUTOSCALING_POLICIES_PATH + ""/"" + policyId + "".json"", <line6> RestConstants.AUTOSCALING_POLICIES, <line7> RestConstants.AUTOSCALING_POLICIES_NAME); <line8> assertTrue( <line9> String.format(""Autoscaling policy did not added: [autoscaling-policy-id] %s"", policyId), <line10> added); <line11> AutoscalePolicyBean bean = <line12> (AutoscalePolicyBean) <line13> restClient.getEntity( <line14> RestConstants.AUTOSCALING_POLICIES, <line15> policyId, <line16> AutoscalePolicyBean.class, <line17> RestConstants.AUTOSCALING_POLICIES_NAME); <line18> assertEquals( <line19> String.format(""[autoscaling-policy-id] %s is not correct"", bean.getId()), <line20> bean.getId(), <line21> policyId); <line22> assertEquals( <line23> String.format(""[autoscaling-policy-id] %s RIF is not correct"", policyId), <line24> bean.getLoadThresholds().getRequestsInFlight().getThreshold(), <line25> 35.0, <line26> 0.0); <line27> assertEquals( <line28> String.format(""[autoscaling-policy-id] %s Memory is not correct"", policyId), <line29> bean.getLoadThresholds().getMemoryConsumption().getThreshold(), <line30> 45.0, <line31> 0.0); <line32> assertEquals( <line33> String.format(""[autoscaling-policy-id] %s Load is not correct"", policyId), <line34> bean.getLoadThresholds().getLoadAverage().getThreshold(), <line35> 25.0, <line36> 0.0); <line37> boolean updated = <line38> restClient.updateEntity( <line39> RESOURCES_PATH + RestConstants.AUTOSCALING_POLICIES_PATH + ""/"" + policyId + ""-v1.json"", <line40> RestConstants.AUTOSCALING_POLICIES, <line41> RestConstants.AUTOSCALING_POLICIES_NAME); <line42> assertTrue(String.format(""[autoscaling-policy-id] %s update failed"", policyId), updated); <line43> AutoscalePolicyBean updatedBean = <line44> (AutoscalePolicyBean) <line45> restClient.getEntity( <line46> RestConstants.AUTOSCALING_POLICIES, <line47> policyId, <line48> AutoscalePolicyBean.class, <line49> RestConstants.AUTOSCALING_POLICIES_NAME); <line50> assertEquals( <line51> String.format(""[autoscaling-policy-id] %s RIF is not correct"", policyId), <line52> updatedBean.getLoadThresholds().getRequestsInFlight().getThreshold(), <line53> 30.0, <line54> 0.0); <line55> assertEquals( <line56> String.format(""[autoscaling-policy-id] %s Load is not correct"", policyId), <line57> updatedBean.getLoadThresholds().getMemoryConsumption().getThreshold(), <line58> 40.0, <line59> 0.0); <line60> assertEquals( <line61> String.format(""[autoscaling-policy-id] %s Memory is not correct"", policyId), <line62> updatedBean.getLoadThresholds().getLoadAverage().getThreshold(), <line63> 20.0, <line64> 0.0); <line65> boolean removed = <line66> restClient.removeEntity( <line67> RestConstants.AUTOSCALING_POLICIES, policyId, RestConstants.AUTOSCALING_POLICIES_NAME); <line68> assertTrue(String.format(""[autoscaling-policy-id] %s couldn't be removed"", policyId), removed); <line69> AutoscalePolicyBean beanRemoved = <line70> (AutoscalePolicyBean) <line71> restClient.getEntity( <line72> RestConstants.AUTOSCALING_POLICIES, <line73> policyId, <line74> AutoscalePolicyBean.class, <line75> RestConstants.AUTOSCALING_POLICIES_NAME); <line76> assertNull( <line77> String.format(""[autoscaling-policy-id] %s didn't get removed successfully"", policyId), <line78> beanRemoved); <line79> } <line80> } <line81> "	<line2>, <line79>
6172	public class A { <line0> @Override <line1> public synchronized void start() throws IllegalStateException { <line2> if (state == PlayerState.PREPARED <line3> || state == PlayerState.PAUSED <line4> || state == PlayerState.STOPPED <line5> || state == PlayerState.LAGGING <line6> || state == PlayerState.PLAYBACK_COMPLETE) { <line7> if (seekToWhenPrepared > 0) { <line8> seekTo(seekToWhenPrepared); <line9> } <line10> exoPlayer.setPlayWhenReady(true); <line11> if (callback != null) { <line12> callback.onPlaybackStarted(); <line13> } <line14> state = PlayerState.PLAYING; <line15> showController(); <line16> requestAccessibilityFocusPausePlay(); <line17> } else { <line18> } <line19> } <line20> } <line21> 	<line15>, <line18>
6173	"public class A { <line0> synchronized void start() { <line1> if (!isEnabled() || started) return; <line2> pageSize = ctx.igniteConfiguration().getDataStorageConfiguration().getPageSize(); <line3> pageMemoryMock = mockPageMemory(); <line4> GridCacheSharedContext sharedCtx = gridCtx.cache().context(); <line5> long maxMemorySize = 0; <line6> for (DataRegion dataRegion : sharedCtx.database().dataRegions()) { <line7> if (dataRegion.pageMemory() instanceof PageMemoryImpl) <line8> maxMemorySize += dataRegion.config().getMaxSize(); <line9> } <line10> long[] chunks = new long[] {maxMemorySize}; <line11> memoryProvider = new UnsafeMemoryProvider(log); <line12> memoryProvider.initialize(chunks); <line13> memoryRegion = memoryProvider.nextRegion(); <line14> GridUnsafe.setMemory(memoryRegion.address(), memoryRegion.size(), (byte) 0); <line15> maxPages = (int) (maxMemorySize / pageSize); <line16> pageSlots = new DirectMemoryPageSlot[maxPages]; <line17> freeSlotsCnt = maxPages; <line18> tmpBuf1 = ByteBuffer.allocateDirect(pageSize); <line19> tmpBuf2 = ByteBuffer.allocateDirect(pageSize); <line20> if (cfg.isCheckPagesOnCheckpoint()) { <line21> checkpointLsnr = <line22> new CheckpointListener() { <line23> @Override <line24> public void onMarkCheckpointBegin(Context ctx) throws IgniteCheckedException { <line25> if (!checkPages(false, true)) <line26> throw new IgniteCheckedException( <line27> ""Page memory is inconsistent after applying WAL delta records.""); <line28> } <line29>  <line30> @Override <line31> public void beforeCheckpointBegin(Context ctx) {} <line32>  <line33> @Override <line34> public void onCheckpointBegin(Context ctx) {} <line35> }; <line36> ((GridCacheDatabaseSharedManager) gridCtx.cache().context().database()) <line37> .addCheckpointListener(checkpointLsnr); <line38> } <line39> lastPageIdx = 0; <line40> started = true; <line41> } <line42> } <line43> "	<line41>
6174	"public class A { <line0> @Incoming(""my-server"") <line1> public CompletionStage<Void> source(MqttMessage message) { <line2> return message.ack(); <line3> } <line4> } <line5> "	<line2>
6175	"public class A { <line0> @Override <line1> public void ack(Object messageId) { <line2> if (!isAtLeastOnceProcessing()) { <line3> return; <line4> } <line5> final KafkaSpoutMessageId msgId = (KafkaSpoutMessageId) messageId; <line6> if (msgId.isNullTuple()) { <line7> offsetManagers.get(msgId.getTopicPartition()).addToAckMsgs(msgId); <line8> tupleListener.onAck(msgId); <line9> return; <line10> } <line11> if (!emitted.contains(msgId)) { <line12> } else { <line13> Validate.isTrue( <line14> !retryService.isScheduled(msgId), <line15> ""The message id "" <line16> + msgId <line17> + "" is queued for retry while being acked. This should never occur barring errors in"" <line18> + "" the RetryService implementation or the spout code.""); <line19> offsetManagers.get(msgId.getTopicPartition()).addToAckMsgs(msgId); <line20> emitted.remove(msgId); <line21> } <line22> tupleListener.onAck(msgId); <line23> } <line24> } <line25> "	<line8>, <line12>
6176	public class A { <line0> private void writePipe(String pipe, String result) { <line1> try (FileOutputStream output = new FileOutputStream(pipe, true); ) { <line2> output.write(result.getBytes()); <line3> output.flush(); <line4> output.close(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	<line6>
6177	public class A { <line0> private URI getURI(final String string) { <line1> if (string != null) { <line2> try { <line3> return new URI(string); <line4> } catch (final URISyntaxException e) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	<line5>
6178	public class A { <line0> protected void onLinkAddedPost( <line1> final String networkId, final Link link, final HashMap<String, Response> respList) { <line2> } <line3> } <line4> 	<line2>
6179	public class A { <line0> private void createUrlResolver(HUITypeFactory typeFactory) { <line1> final Set<String> allIDs = new HashSet<String>(); <line2> try { <line3> List<PropertyType> types; <line4> types = typeFactory.getURLPropertyTypes(); <line5> for (PropertyType type : types) { <line6> allIDs.add(type.getId()); <line7> } <line8> } catch (Exception e) { <line9> return; <line10> } <line11> urlresolver = <line12> new IUrlResolver() { <line13> public List<HuiUrl> resolve() { <line14> List<HuiUrl> result = Collections.emptyList(); <line15> try { <line16> FindHuiUrls command = new FindHuiUrls(allIDs); <line17> command = ServiceFactory.lookupCommandService().executeCommand(command); <line18> result = command.getList(); <line19> } catch (Exception e) { <line20> } <line21> return result; <line22> } <line23> }; <line24> } <line25> } <line26> 	<line20>
6180	public class A { <line0> public CancellableCompletableFuture<Void> monitor( <line1> Supplier<Boolean> condition, int checkInterval, int timeout, TimeUnit timeUnit) { <line2> return scheduledExecutor.scheduleWithFixedDelayAndTimeout( <line3> condition, 0L, checkInterval, timeout, timeUnit); <line4> } <line5> } <line6> 	<line2>
6181	public class A { <line0> public boolean saveProcessedFile(File file) { <line1> boolean saved = false; <line2> if (file == null || !file.isFile()) return saved; <line3> String destinationDir = messageProcessedDir; <line4> try { <line5> Utils.moveToDirectory(destinationDir, file); <line6> } catch (Exception ex) { <line7> } <line8> return saved; <line9> } <line10> } <line11> 	<line7>
6182	public class A { <line0> private void parseHeartbeatMode(HeartbeatExtensionMessage msg) { <line1> msg.setHeartbeatMode(parseByteArrayField(ExtensionByteLength.HEARTBEAT_MODE)); <line2> } <line3> } <line4> 	<line2>
6183	public class A { <line0> @GetMapping(CommonConstants.PATH_LEVELS) <line1> public List<String> getLevels(final Optional<String> criteria) { <line2> RestUtils.checkCriteria(criteria); <line3> return internalProfileService.getLevels(criteria); <line4> } <line5> } <line6> 	<line2>
6184	"public class A { <line0> protected FileSec createFileSection() throws IOException { <line1> FileSec fileSec = new FileSec(); <line2> List<MCRPath> filePaths = MCRMetsSave.listFiles(getDerivatePath(), getIgnorePaths()); <line3> List<FileGrp> fileGrps = MCRMetsSave.buildFileGroups(filePaths); <line4> fileGrps.forEach(fileSec::addFileGrp); <line5> for (MCRPath file : filePaths) { <line6> String contentType = MCRContentTypes.probeContentType(file); <line7> FileRef ref = buildFileRef(file, contentType); <line8> this.files.add(ref); <line9> } <line10> for (FileRef ref : this.files) { <line11> String use = <line12> MCRMetsModelHelper.getUseForHref(ref.getPath().getOwnerRelativePath()).orElse(""UNKNOWN""); <line13> FileGrp fileGrp = <line14> fileGrps.stream().filter(grp -> grp.getUse().equals(use)).findFirst().orElse(null); <line15> if (fileGrp == null) { <line16> continue; <line17> } <line18> addFile(ref, fileGrp); <line19> } <line20> return fileSec; <line21> } <line22> } <line23> "	<line16>
6185	"public class A { <line0> @Override <line1> public void onClick(final AjaxRequestTarget target, final RoleTO ignore) { <line2> AnyLayoutWrapper wrapper = <line3> new AnyLayoutWrapper( <line4> model.getObject().getKey(), <line5> AnyLayoutUtils.defaultIfEmpty( <line6> RoleRestClient.readAnyLayout(model.getObject().getKey()), <line7> AnyTypeRestClient.list())); <line8> utilityModal.header(new ResourceModel(""console.layout.info"", ""JSON Content"")); <line9> utilityModal.setContent( <line10> new JsonEditorPanel( <line11> utilityModal, new PropertyModel<String>(wrapper, ""content""), false, pageRef) { <line12> private static final long serialVersionUID = -8927036362466990179L; <line13>  <line14> @Override <line15> public void onSubmit(final AjaxRequestTarget target) { <line16> try { <line17> RoleRestClient.setAnyLayout(wrapper.getKey(), wrapper.getContent()); <line18> SyncopeConsoleSession.get().success(getString(Constants.OPERATION_SUCCEEDED)); <line19> modal.show(false); <line20> modal.close(target); <line21> } catch (Exception e) { <line22> SyncopeConsoleSession.get().onException(e); <line23> } <line24> ((BasePage) pageRef.getPage()).getNotificationPanel().refresh(target); <line25> } <line26> }); <line27> utilityModal.show(true); <line28> target.add(utilityModal); <line29> } <line30> } <line31> "	<line22>
6186	"public class A { <line0> @Override <line1> public synchronized boolean createNewFile() throws IOException { <line2> try { <line3> fileDescriptor = <line4> irodsFileSystemAO.createFile(getAbsolutePath(), DataObjInp.OpenFlags.READ_WRITE, 0600); <line5> } catch (JargonFileOrCollAlreadyExistsException e) { <line6> return false; <line7> } catch (ResourceHierarchyException rhe) { <line8> return false; <line9> } catch (JargonException e) { <line10> String msg = ""JargonException caught and rethrown as IOException:"" + e.getMessage(); <line11> throw new IOException(e); <line12> } <line13> return true; <line14> } <line15> } <line16> "	<line5>, <line11>
6187	public class A { <line0> private void activateCurrentTime(TimeType time) { <line1> PlayStateType playState = <line2> time.getAnimation() != null ? time.getAnimation().getPlayState() : null; <line3> boolean animationSetTheTime = <line4> EqualsHelper.equalsAny(playState, PlayState.FORWARD, PlayState.REVERSE); <line5> if (StringUtils.isNotEmpty(time.getCurrent()) && !animationSetTheTime) { <line6> try { <line7> TimeSpan span = TimeSpan.fromISO8601String(time.getCurrent()); <line8> resetPlanIfNecessary(span); <line9> myTimeManager.setPrimaryActiveTimeSpan(span); <line10> } catch (ParseException e) { <line11> } <line12> } <line13> } <line14> } <line15> 	<line11>
6188	public class A { <line0> protected void addManagedBlockDisks(Collection<DiskImage> templateDisks) { <line1> List<ManagedBlockStorageDisk> managedBlockDisks = <line2> DisksFilter.filterManagedBlockStorageDisks(templateDisks); <line3> if (managedBlockDisks.isEmpty()) { <line4> return; <line5> } <line6> Map<Guid, Guid> diskImageMap = new HashMap<>(); <line7> for (ManagedBlockStorageDisk managedBlockDisk : managedBlockDisks) { <line8> ImagesContainterParametersBase params = buildImagesContainterParameters(managedBlockDisk); <line9> ActionReturnValue actionReturnValue = <line10> runInternalAction( <line11> ActionType.CloneSingleManagedBlockDisk, <line12> params, <line13> cloneContext().withoutExecutionContext().withoutLock()); <line14> if (!actionReturnValue.getSucceeded()) { <line15> getReturnValue().setFault(actionReturnValue.getFault()); <line16> return; <line17> } <line18> Guid imageId = actionReturnValue.getActionReturnValue(); <line19> diskImageMap.put(managedBlockDisk.getId(), imageId); <line20> } <line21> srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap); <line22> } <line23> } <line24> 	<line15>
6189	public class A { <line0> private List<EntityReference> collectWikiObjectsList() { <line1> List<EntityReference> wikiObjectsList = new ArrayList<>(); <line2> try { <line3> List<WikiObjectComponentBuilder> componentBuilders = <line4> this.contextComponent.getInstanceList(WikiObjectComponentBuilder.class); <line5> for (WikiObjectComponentBuilder componentBuilder : componentBuilders) { <line6> wikiObjectsList.add(componentBuilder.getClassReference()); <line7> } <line8> } catch (ComponentLookupException e) { <line9> } <line10> return wikiObjectsList; <line11> } <line12> } <line13> 	<line9>
6190	public class A { <line0> public static <T> T getJsonObject(String jsonstr, Class<T> type) { <line1> ObjectMapper mapper = new ObjectMapper(); <line2> mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true); <line3> try { <line4> return mapper.readValue(jsonstr, type); <line5> } catch (IOException e) { <line6> } <line7> return null; <line8> } <line9> } <line10> 	<line6>
6191	"public class A { <line0> @ParallelNamespaceTest <line1> void testDeployAndUnDeployCruiseControl(ExtensionContext extensionContext) throws IOException { <line2> final String namespaceName = <line3> extensionContext <line4> .getStore(ExtensionContext.Namespace.GLOBAL) <line5> .get(Constants.NAMESPACE_KEY) <line6> .toString(); <line7> final String clusterName = mapWithClusterNames.get(extensionContext.getDisplayName()); <line8> resourceManager.createResource( <line9> extensionContext, KafkaTemplates.kafkaWithCruiseControl(clusterName, 3, 3).build()); <line10> Map<String, String> kafkaPods = <line11> StatefulSetUtils.ssSnapshot( <line12> namespaceName, KafkaResources.kafkaStatefulSetName(clusterName)); <line13> KafkaResource.replaceKafkaResourceInSpecificNamespace( <line14> clusterName, <line15> kafka -> { <line16> kafka.getSpec().setCruiseControl(null); <line17> }, <line18> namespaceName); <line19> StatefulSetUtils.waitTillSsHasRolled( <line20> namespaceName, kafkaStatefulSetName(clusterName), 3, kafkaPods); <line21> assertThat( <line22> KafkaResource.kafkaClient() <line23> .inNamespace(namespaceName) <line24> .withName(clusterName) <line25> .get() <line26> .getSpec() <line27> .getCruiseControl(), <line28> nullValue()); <line29> PodUtils.waitUntilPodStabilityReplicasCount(namespaceName, clusterName + ""-cruise-control-"", 0); <line30> assertThrows( <line31> WaitException.class, <line32> () -> <line33> CruiseControlUtils <line34> .verifyCruiseControlMetricReporterConfigurationInKafkaConfigMapIsPresent( <line35> CruiseControlUtils.getKafkaCruiseControlMetricsReporterConfiguration( <line36> namespaceName, clusterName))); <line37> CruiseControlUtils.verifyThatCruiseControlTopicsArePresent(namespaceName); <line38> kafkaPods = <line39> StatefulSetUtils.ssSnapshot( <line40> namespaceName, KafkaResources.kafkaStatefulSetName(clusterName)); <line41> KafkaResource.replaceKafkaResourceInSpecificNamespace( <line42> clusterName, <line43> kafka -> { <line44> kafka.getSpec().setCruiseControl(new CruiseControlSpec()); <line45> }, <line46> namespaceName); <line47> StatefulSetUtils.waitTillSsHasRolled( <line48> namespaceName, kafkaStatefulSetName(clusterName), 3, kafkaPods); <line49> CruiseControlUtils.verifyCruiseControlMetricReporterConfigurationInKafkaConfigMapIsPresent( <line50> CruiseControlUtils.getKafkaCruiseControlMetricsReporterConfiguration( <line51> namespaceName, clusterName)); <line52> CruiseControlUtils.verifyThatCruiseControlTopicsArePresent(namespaceName); <line53> } <line54> } <line55> "	<line16>, <line21>, <line29>, <line30>, <line37>, <line44>, <line49>, <line52>
6192	public class A { <line0> public String getCaseFileDataByName( <line1> String containerId, String caseId, String name, String marshallingType) { <line2> verifyContainerId(containerId, caseId); <line3> CaseFileInstance caseFileInstance = caseService.getCaseFileInstance(caseId); <line4> Object caseFileData = caseFileInstance.getData(name); <line5> return marshallerHelper.marshal( <line6> containerId, marshallingType, caseFileData, new ByCaseIdContainerLocator(caseId)); <line7> } <line8> } <line9> 	<line5>
6193	"public class A { <line0> @DELETE <line1> @Path(""{jobId}"") <line2> @Timed <line3> @ApiOperation(value = ""Cancel job with the given ID"") <line4> @Produces(MediaType.APPLICATION_JSON) <line5> @AuditEvent(type = AuditEventTypes.SYSTEM_JOB_STOP) <line6> public SystemJobSummary cancelJob( <line7> @ApiParam(name = ""jobId"", required = true) @PathParam(""jobId"") @NotEmpty String jobId) <line8> throws IOException { <line9> final Optional<Response<SystemJobSummary>> summaryResponse = <line10> nodeService.allActive().entrySet().stream() <line11> .map( <line12> entry -> { <line13> final RemoteSystemJobResource resource = <line14> remoteInterfaceProvider.get( <line15> entry.getValue(), <line16> this.authenticationToken, <line17> RemoteSystemJobResource.class); <line18> try { <line19> return resource.delete(jobId).execute(); <line20> } catch (IOException e) { <line21> return null; <line22> } <line23> }) <line24> .filter(response -> response != null && response.isSuccessful()) <line25> .findFirst(); <line26> return summaryResponse <line27> .orElseThrow(() -> new NotFoundException(""System job with ID <"" + jobId + ""> not found!"")) <line28> .body(); <line29> } <line30> } <line31> "	<line21>
6194	public class A { <line0> private void readCompoundCheckpoint(CheckpointInputStream checkpoint, Path path) <line1> throws IOException { <line2> Files.createDirectories(path); <line3> CompoundCheckpointFormat.CompoundCheckpointReader reader = <line4> new CompoundCheckpointFormat.CompoundCheckpointReader(checkpoint); <line5> Optional<CompoundCheckpointFormat.CompoundCheckpointReader.Entry> entryOpt; <line6> while ((entryOpt = reader.nextCheckpoint()).isPresent()) { <line7> CompoundCheckpointFormat.CompoundCheckpointReader.Entry entry = entryOpt.get(); <line8> Path checkpointPath = path.resolve(entry.getName().toString()); <line9> readCheckpoint(entry.getStream(), checkpointPath); <line10> } <line11> } <line12> } <line13> 	<line9>
6195	public class A { <line0> @Override <line1> public boolean deleteIfExists(Path path) throws IOException { <line2> Path r = unroot(path); <line3> if (log.isTraceEnabled()) { <line4> } <line5> FileSystemProvider p = provider(r); <line6> return p.deleteIfExists(r); <line7> } <line8> } <line9> 	<line4>
6196	public class A { <line0> public List executeScalarQuery(String cqlQuery) { <line1> CqlResult cqlResult = null; <line2> List results = new ArrayList(); <line3> try { <line4> if (log.isDebugEnabled()) { <line5> } <line6> cqlResult = (CqlResult) executeCQLQuery(cqlQuery, true); <line7> if (cqlResult != null && (cqlResult.getRows() != null || cqlResult.getRowsSize() > 0)) { <line8> results = new ArrayList<Object>(cqlResult.getRowsSize()); <line9> Iterator<CqlRow> iter = cqlResult.getRowsIterator(); <line10> while (iter.hasNext()) { <line11> Map<String, Object> entity = new HashMap<String, Object>(); <line12> CqlRow row = iter.next(); <line13> for (Column column : row.getColumns()) { <line14> if (column != null) { <line15> String thriftColumnName = <line16> PropertyAccessorFactory.STRING.fromBytes(String.class, column.getName()); <line17> if (column.getValue() == null) { <line18> entity.put(thriftColumnName, null); <line19> } else { <line20> entity.put( <line21> thriftColumnName, <line22> composeColumnValue(cqlResult.getSchema(), column.getValue(), column.getName())); <line23> } <line24> } <line25> } <line26> results.add(entity); <line27> } <line28> } <line29> } catch (Exception e) { <line30> throw new PersistenceException(e); <line31> } <line32> return results; <line33> } <line34> } <line35> 	<line5>, <line30>
6197	public class A { <line0> @Override <line1> public long getLong(String key) { <line2> if (containsKey(key)) { <line3> return PropertyConverter.toLong(getProperty(key)); <line4> } else { <line5> throw new NoSuchElementException(doesNotMapMessage(key)); <line6> } <line7> } <line8> } <line9> 	<line5>
6198	public class A { <line0> private boolean isAppendedToInbox(Added addedEvent) { <line1> try { <line2> return systemMailboxesProvider <line3> .findMailbox(Role.INBOX, addedEvent.getUsername()) <line4> .getId() <line5> .equals(addedEvent.getMailboxId()); <line6> } catch (MailboxException e) { <line7> return false; <line8> } <line9> } <line10> } <line11> 	<line7>
6199	"public class A { <line0> @Override <line1> protected ProxyAddress parseProxyAddress(HttpServletRequest servletRequest) { <line2> String reqQueryString = servletRequest.getQueryString(); <line3> String queryPostfix = """"; <line4> if (Strings.isNotBlank(reqQueryString)) { <line5> queryPostfix = ""?"" + reqQueryString; <line6> } <line7> String userName = null; <line8> String password = null; <line9> String podName = servletRequest.getPathInfo(); <line10> if (podName == null) { <line11> podName = """"; <line12> } <line13> if (podName.startsWith(""/"")) { <line14> podName = podName.substring(1); <line15> } <line16> int idx = podName.indexOf('/'); <line17> String podPort = """"; <line18> String podPath = ""/""; <line19> if (idx > 0) { <line20> podPath = podName.substring(idx); <line21> podName = podName.substring(0, idx); <line22> idx = podPath.indexOf('/', 1); <line23> if (idx >= 0) { <line24> podPort = podPath.substring(1, idx); <line25> podPath = podPath.substring(idx); <line26> } <line27> } <line28> if (podName.isEmpty()) { <line29> String url = ServiceResolver.getSingleton().getServiceURL(""kubernetes""); <line30> if (url == null) { <line31> return null; <line32> } <line33> url += ""/kubernetes/api/v1beta2/pods"" + queryPostfix; <line34> return new DefaultProxyAddress(url, userName, password); <line35> } <line36> String url = ServiceResolver.getSingleton().getPodUrl(podName, podPort); <line37> if (url == null) { <line38> if (LOG.isDebugEnabled()) { <line39> } <line40> System.out.println(""No pod for: "" + podName + "" port: "" + podPort + "" path: "" + podPath); <line41> return null; <line42> } else { <line43> url += podPath + queryPostfix; <line44> if (LOG.isDebugEnabled()) { <line45> } <line46> System.out.println( <line47> ""Invoking: "" + url + "" from pod: "" + podName + "" port: "" + podPort + "" path: "" + podPath); <line48> return new DefaultProxyAddress(url, userName, password); <line49> } <line50> } <line51> } <line52> "	<line39>, <line45>
6200	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Date lastSync = getBaseLastSync(); <line4> while (!stopped) { <line5> try { <line6> try { <line7> Thread.sleep(freqMillisec); <line8> } catch (InterruptedException e) { <line9> stopped = true; <line10> continue; <line11> } <line12> synchronized (ccls) { <line13> if (ccls.isEmpty()) { <line14> continue; <line15> } <line16> ChangedCollections changedCollections = getChangedCollections(lastSync); <line17> if (changedCollections.hasChanges()) { <line18> } <line19> List<PushNotification> toNotify = <line20> pushPublishAndSubscribe.listPushNotification( <line21> selectListenersToNotify(changedCollections, ccls)); <line22> notifyListeners(toNotify); <line23> lastSync = changedCollections.getLastSync(); <line24> } <line25> } catch (ChangedCollectionsException e1) { <line26> } catch (DaoException e) { <line27> } <line28> } <line29> } catch (ChangedCollectionsException e1) { <line30> } catch (DaoException e) { <line31> } <line32> } <line33> } <line34> 	<line4>, <line18>, <line26>, <line27>, <line30>, <line31>
6201	"public class A { <line0> @Override <line1> public RetrieveDocumentSetResponseType retrieveDocument( <line2> RetrieveDocumentSetRequestType msg, AssertionType assertion) { <line3> RetrieveDocumentSetResponseType response = null; <line4> try { <line5> String xdsbHomeCommunityId = <line6> PropertyAccessor.getInstance() <line7> .getProperty( <line8> NhincConstants.ADAPTER_PROPERTY_FILE_NAME, <line9> NhincConstants.XDS_HOME_COMMUNITY_ID_PROPERTY); <line10> String url = <line11> oProxyHelper.getAdapterEndPointFromConnectionManager( <line12> xdsbHomeCommunityId, NhincConstants.ADAPTER_DOC_REPOSITORY_SERVICE_NAME); <line13> if (msg == null) { <line14> throw new IllegalArgumentException(""Request Message must be provided""); <line15> } else { <line16> ServicePortDescriptor<DocumentRepositoryPortType> portDescriptor = <line17> new AdapterComponentDocRepositoryServicePortDescriptor(); <line18> CONNECTClient<DocumentRepositoryPortType> client = <line19> getCONNECTClientUnsecured(portDescriptor, url, assertion); <line20> client.enableMtom(); <line21> response = <line22> (RetrieveDocumentSetResponseType) <line23> client.invokePort( <line24> DocumentRepositoryPortType.class, ""documentRepositoryRetrieveDocumentSet"", msg); <line25> } <line26> } catch (Exception ex) { <line27> response = new RetrieveDocumentSetResponseType(); <line28> RegistryResponseType regResp = new RegistryResponseType(); <line29> regResp.setStatus(DocumentConstants.XDS_QUERY_RESPONSE_STATUS_FAILURE); <line30> RegistryError registryError = new RegistryError(); <line31> registryError.setCodeContext(""Processing Adapter Doc Query document retrieve""); <line32> registryError.setErrorCode(""XDSRepostoryError""); <line33> registryError.setSeverity(NhincConstants.XDS_REGISTRY_ERROR_SEVERITY_ERROR); <line34> regResp.getRegistryErrorList().getRegistryError().add(registryError); <line35> response.setRegistryResponse(regResp); <line36> throw new ErrorEventException(ex, response, ""Unable to call Document Repository Adapter""); <line37> } <line38> return response; <line39> } <line40> } <line41> "	<line3>, <line38>
6202	"public class A { <line0> @Override <line1> public void onFailure(IMqttToken asyncActionToken, Throwable exception) { <line2> Assert.fail(""MQTT connect failed: "" + exception.getMessage()); <line3> } <line4> } <line5> "	<line2>
6203	public class A { <line0> @Override <line1> public void commit(Xid xid, boolean b) throws XAException { <line2> this.commitStarted = true; <line3> } <line4> } <line5> 	<line3>
6204	"public class A { <line0> private StorageDirView allocateSpace(long sessionId, AllocateOptions options) <line1> throws WorkerOutOfSpaceException, IOException { <line2> StorageDirView dirView; <line3> BlockMetadataView allocatorView = <line4> new BlockMetadataAllocatorView(mMetaManager, options.canUseReservedSpace()); <line5> while (true) { <line6> if (options.isForceLocation()) { <line7> dirView = <line8> mAllocator.allocateBlockWithView( <line9> sessionId, options.getSize(), options.getLocation(), allocatorView, true); <line10> if (dirView != null) { <line11> return dirView; <line12> } <line13> if (options.isEvictionAllowed()) { <line14> freeSpace(sessionId, options.getSize(), options.getSize(), options.getLocation()); <line15> dirView = <line16> mAllocator.allocateBlockWithView( <line17> sessionId, <line18> options.getSize(), <line19> options.getLocation(), <line20> allocatorView.refreshView(), <line21> true); <line22> if (LOG.isDebugEnabled()) { <line23> } <line24> if (dirView == null) { <line25> break; <line26> } <line27> } else { <line28> break; <line29> } <line30> } else { <line31> dirView = <line32> mAllocator.allocateBlockWithView( <line33> sessionId, options.getSize(), options.getLocation(), allocatorView, false); <line34> if (dirView != null) { <line35> return dirView; <line36> } <line37> dirView = <line38> mAllocator.allocateBlockWithView( <line39> sessionId, options.getSize(), BlockStoreLocation.anyTier(), allocatorView, false); <line40> if (dirView != null) { <line41> return dirView; <line42> } <line43> if (options.isEvictionAllowed()) { <line44> long toFreeBytes = options.getSize() + FREE_AHEAD_BYTETS; <line45> freeSpace(sessionId, options.getSize(), toFreeBytes, BlockStoreLocation.anyTier()); <line46> dirView = <line47> mAllocator.allocateBlockWithView( <line48> sessionId, <line49> options.getSize(), <line50> BlockStoreLocation.anyTier(), <line51> allocatorView.refreshView(), <line52> true); <line53> if (LOG.isDebugEnabled()) { <line54> } <line55> } <line56> } <line57> if (dirView == null) { <line58> break; <line59> } <line60> return dirView; <line61> } <line62> throw new WorkerOutOfSpaceException( <line63> String.format(""Allocation failure. Options: %s. Error:"", options.toString())); <line64> } <line65> } <line66> "	<line14>, <line23>, <line25>, <line28>, <line37>, <line45>, <line54>
6205	"public class A { <line0> public void run(RegressionEnvironment env) { <line1> String methodName = "".testPerfPropertyAccess""; <line2> String joinStatement = <line3> ""@name('s0') select * from "" <line4> + ""SupportBeanCombinedProps#length(1)"" <line5> + "" where indexed[0].mapped('a').value = 'dummy'""; <line6> env.compileDeploy(joinStatement).addListener(""s0""); <line7> SupportBeanCombinedProps theEvent = SupportBeanCombinedProps.makeDefaultBean(); <line8> long startTime = System.currentTimeMillis(); <line9> for (int i = 0; i < 10000; i++) { <line10> sendEvent(env, theEvent); <line11> } <line12> long endTime = System.currentTimeMillis(); <line13> assertTrue((endTime - startTime) < 1000); <line14> env.undeployAll(); <line15> } <line16> } <line17> "	<line8>, <line12>, <line13>
6206	public class A { <line0> public void accept(RoutingContext ctx) { <line1> HttpResponse.responseText(ctx, 202); <line2> echo(ctx); <line3> } <line4> } <line5> 	<line1>
6207	"public class A { <line0> public static void issueTruncateTasks( <line1> Context context, <line2> Optional<Ref> oldRef, <line3> Optional<Ref> newRef, <line4> GeoServerTileLayer tileLayer, <line5> TileBreeder breeder) { <line6> final ObjectId oldCommit = oldRef.isPresent() ? oldRef.get().getObjectId() : ObjectId.NULL; <line7> final ObjectId newCommit = newRef.isPresent() ? newRef.get().getObjectId() : ObjectId.NULL; <line8> final String tileLayerName = tileLayer.getName(); <line9> final String layerTreeName = tileLayer.getLayerInfo().getResource().getNativeName(); <line10> final Geometry minimalBounds; <line11> Stopwatch sw = Stopwatch.createStarted(); <line12> try { <line13> MinimalDiffBounds geomBuildCommand = <line14> context <line15> .command(MinimalDiffBounds.class) <line16> .setOldVersion(oldCommit.toString()) <line17> .setNewVersion(newCommit.toString()); <line18> geomBuildCommand.setTreeNameFilter(layerTreeName); <line19> minimalBounds = geomBuildCommand.call(); <line20> sw.stop(); <line21> if (minimalBounds.isEmpty()) { <line22> return; <line23> } <line24> if (LOGGER.isDebugEnabled()) { <line25> } <line26> } catch (Exception e) { <line27> sw.stop(); <line28> throw Throwables.propagate(e); <line29> } <line30> final Set<String> gridSubsets = tileLayer.getGridSubsets(); <line31> LayerInfo layerInfo = tileLayer.getLayerInfo(); <line32> ResourceInfo resource = layerInfo.getResource(); <line33> final CoordinateReferenceSystem sourceCrs; <line34> { <line35> CoordinateReferenceSystem nativeCrs = resource.getNativeCRS(); <line36> if (nativeCrs == null) { <line37> sourceCrs = resource.getCRS(); <line38> } else { <line39> sourceCrs = nativeCrs; <line40> } <line41> } <line42> for (String gridsetId : gridSubsets) { <line43> GridSubset gridSubset = tileLayer.getGridSubset(gridsetId); <line44> final CoordinateReferenceSystem gridSetCrs = getGridsetCrs(gridSubset); <line45> Geometry geomInGridsetCrs = transformToGridsetCrs(minimalBounds, sourceCrs, gridSetCrs); <line46> if (LOGGER.isDebugEnabled()) { <line47> } <line48> geomInGridsetCrs = <line49> bufferAndSimplifyBySizeOfSmallerTile(geomInGridsetCrs, gridSetCrs, gridSubset); <line50> try { <line51> truncate(tileLayer, gridsetId, geomInGridsetCrs, breeder); <line52> } catch (Exception e) { <line53> LOGGER.log(Level.WARNING, """", e); <line54> } <line55> } <line56> } <line57> } <line58> "	<line10>, <line22>, <line25>, <line28>, <line45>, <line47>
6208	public class A { <line0> private static SocketState extractSocketState(State state) { <line1> try { <line2> if (state.getTlsContext().getTransportHandler() instanceof ClientTcpTransportHandler) { <line3> SocketState socketState = <line4> (((ClientTcpTransportHandler) (state.getTlsContext().getTransportHandler())) <line5> .getSocketState()); <line6> return socketState; <line7> } else { <line8> return null; <line9> } <line10> } catch (InvalidTransportHandlerStateException ex) { <line11> return SocketState.DATA_AVAILABLE; <line12> } <line13> } <line14> } <line15> 	<line11>
6209	"public class A { <line0> public void doHttpPost( <line1> String serverAddress, <line2> String subPath, <line3> byte[] data, <line4> String contentType, <line5> String encoding, <line6> HttpClientCallback callBack) { <line7> ConnectionFailoverMgr cfm = httpConnInvokeMgr.get(serverAddress); <line8> if (cfm == null) { <line9> final String postURL = (subPath != null) ? (serverAddress + subPath) : serverAddress; <line10> httpAsyncClient.doAsyncHttpPost(postURL, data, contentType, encoding, callBack); <line11> return; <line12> } <line13> String url = cfm.getConnection(); <line14> if (url == null) { <line15> String msg = ""No Available Address for ServerAddressList["" + serverAddress + ""]""; <line16> if (callBack != null) { <line17> HttpClientCallbackResult result = new HttpClientCallbackResult(null, null); <line18> result.setException( <line19> new HttpAsyncException(ExceptionEvent.REPLY_ERROR, new ConnectException(msg))); <line20> callBack.failed(result); <line21> } <line22> return; <line23> } <line24> String postURL = (subPath != null) ? (url + subPath) : url; <line25> PostHttpCallback postHttpCb = new PostHttpCallback(); <line26> postHttpCb.setCallBack(callBack); <line27> postHttpCb.setCfm(cfm); <line28> postHttpCb.setContentType(contentType); <line29> postHttpCb.setData(data); <line30> postHttpCb.setEncoding(encoding); <line31> postHttpCb.setPostURL(postURL); <line32> postHttpCb.setServerAddress(serverAddress); <line33> postHttpCb.setSubPath(subPath); <line34> postHttpCb.setUrl(url); <line35> httpAsyncClient.doAsyncHttpPost(postURL, data, contentType, encoding, postHttpCb); <line36> } <line37> } <line38> "	<line16>, <line25>
6210	"public class A { <line0> @Test <line1> public void testQueryList() throws Exception { <line2> MvcResult mvcResult = <line3> mockMvc <line4> .perform(get(""/queue/list"").header(SESSION_ID, sessionId)) <line5> .andExpect(status().isOk()) <line6> .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8)) <line7> .andReturn(); <line8> Result result = <line9> JSONUtils.parseObject(mvcResult.getResponse().getContentAsString(), Result.class); <line10> Assert.assertEquals(Status.SUCCESS.getCode(), result.getCode().intValue()); <line11> } <line12> } <line13> "	<line11>
6211	public class A { <line0> @Override <line1> public void rollback() { <line2> if (Objects.isNull(branch)) { <line3> return; <line4> } <line5> branch.rollback(); <line6> doOnRollback(); <line7> clear(); <line8> } <line9> } <line10> 	<line3>
6212	public class A { <line0> private void calculateEndWindowStats() { <line1> Map<Integer, PTOperator> allOperators = plan.getAllOperators(); <line2> UpdateOperatorLatencyContext ctx = <line3> new UpdateOperatorLatencyContext(rpcLatencies, endWindowStatsOperatorMap); <line4> for (PTOperator operator : allOperators.values()) { <line5> updateOperatorLatency(operator, ctx); <line6> } <line7> if (!endWindowStatsOperatorMap.isEmpty()) { <line8> if (endWindowStatsOperatorMap.size() > this.vars.maxWindowsBehindForStats) { <line9> while (endWindowStatsOperatorMap.size() > this.vars.maxWindowsBehindForStats) { <line10> endWindowStatsOperatorMap.remove(endWindowStatsOperatorMap.firstKey()); <line11> } <line12> } <line13> int numOperators = allOperators.size(); <line14> Long windowId = endWindowStatsOperatorMap.firstKey(); <line15> while (windowId != null) { <line16> Map<Integer, EndWindowStats> endWindowStatsMap = endWindowStatsOperatorMap.get(windowId); <line17> Set<Integer> endWindowStatsOperators = endWindowStatsMap.keySet(); <line18> aggregateMetrics(windowId, endWindowStatsMap); <line19> criticalPathInfo = findCriticalPath(); <line20> if (allOperators.keySet().containsAll(endWindowStatsOperators)) { <line21> if (endWindowStatsMap.size() < numOperators) { <line22> if (windowId < completeEndWindowStatsWindowId) { <line23> endWindowStatsOperatorMap.remove(windowId); <line24> } else { <line25> break; <line26> } <line27> } else { <line28> endWindowStatsOperatorMap.remove(windowId); <line29> currentEndWindowStatsWindowId = windowId; <line30> } <line31> } else { <line32> endWindowStatsOperatorMap.remove(windowId); <line33> } <line34> windowId = endWindowStatsOperatorMap.higherKey(windowId); <line35> } <line36> } <line37> } <line38> } <line39> 	<line9>, <line10>, <line23>, <line32>
6213	public class A { <line0> @Override <line1> public void injectConsistencyLevels(Session session, ConfigurationContext configContext) { <line2> ConsistencyLevel clusterConsistency = <line3> session.getCluster().getConfiguration().getQueryOptions().getConsistencyLevel(); <line4> ConsistencyLevel clusterSerialConsistency = <line5> session.getCluster().getConfiguration().getQueryOptions().getSerialConsistencyLevel(); <line6> final String tableOrViewName = this.getTableOrViewName(); <line7> this.readConsistencyLevel = <line8> OverridingOptional.from(staticReadConsistency) <line9> .andThen(configContext.getReadConsistencyLevelForTable(tableOrViewName)) <line10> .andThen(configContext.getDefaultReadConsistencyLevel()) <line11> .andThen(clusterConsistency) <line12> .defaultValue(ConfigurationContext.DEFAULT_CONSISTENCY_LEVEL) <line13> .get(); <line14> this.writeConsistencyLevel = <line15> OverridingOptional.from(staticWriteConsistency) <line16> .andThen(configContext.getWriteConsistencyLevelForTable(tableOrViewName)) <line17> .andThen(configContext.getDefaultWriteConsistencyLevel()) <line18> .andThen(clusterConsistency) <line19> .defaultValue(ConfigurationContext.DEFAULT_CONSISTENCY_LEVEL) <line20> .get(); <line21> this.serialConsistencyLevel = <line22> OverridingOptional.from(staticSerialConsistency) <line23> .andThen(configContext.getSerialConsistencyLevelForTable(tableOrViewName)) <line24> .andThen(clusterSerialConsistency) <line25> .andThen(configContext.getDefaultSerialConsistencyLevel()) <line26> .defaultValue(ConfigurationContext.DEFAULT_SERIAL_CONSISTENCY_LEVEL) <line27> .get(); <line28> if (LOGGER.isDebugEnabled()) { <line29> } <line30> } <line31> } <line32> 	<line29>
6214	"public class A { <line0> private Optional<Configuration> makeRootServiceConfiguration( <line1> final Optional<Configuration> serviceConfiguration) { <line2> final EvaluatorType evaluatorType = <line3> this.evaluatorManager.getEvaluatorDescriptor().getProcess().getType(); <line4> if (EvaluatorType.CLR == evaluatorType) { <line5> LOG.log( <line6> Level.FINE, <line7> ""Not using the ConfigurationProviders as we are configuring a {0} Evaluator."", <line8> evaluatorType); <line9> return serviceConfiguration; <line10> } <line11> if (!serviceConfiguration.isPresent() && this.evaluatorConfigurationProviders.isEmpty()) { <line12> return Optional.empty(); <line13> } else { <line14> final ConfigurationBuilder configurationBuilder = <line15> getConfigurationBuilder(serviceConfiguration); <line16> for (final ConfigurationProvider configurationProvider : <line17> this.evaluatorConfigurationProviders) { <line18> configurationBuilder.addConfiguration(configurationProvider.getConfiguration()); <line19> } <line20> return Optional.of(configurationBuilder.build()); <line21> } <line22> } <line23> } <line24> "	<line12>
6215	public class A { <line0> @Override <line1> public void onNext(T t) { <line2> } <line3> } <line4> 	<line2>
6216	public class A { <line0> public void receivedStatus(OperationStatus status) { <line1> CollectionOperationStatus cstatus; <line2> if (status instanceof CollectionOperationStatus) { <line3> cstatus = (CollectionOperationStatus) status; <line4> } else { <line5> cstatus = new CollectionOperationStatus(status); <line6> } <line7> if (cstatus.isSuccess()) { <line8> rv.set(position, cstatus); <line9> return; <line10> } <line11> switch (cstatus.getResponse()) { <line12> case NOT_FOUND: <line13> rv.set(null, cstatus); <line14> if (getLogger().isDebugEnabled()) { <line15> } <line16> break; <line17> case NOT_FOUND_ELEMENT: <line18> rv.set(null, cstatus); <line19> if (getLogger().isDebugEnabled()) { <line20> } <line21> break; <line22> case UNREADABLE: <line23> rv.set(null, cstatus); <line24> if (getLogger().isDebugEnabled()) { <line25> } <line26> break; <line27> case BKEY_MISMATCH: <line28> rv.set(null, cstatus); <line29> if (getLogger().isDebugEnabled()) { <line30> getLogger() <line31> } <line32> break; <line33> case TYPE_MISMATCH: <line34> rv.set(null, cstatus); <line35> if (getLogger().isDebugEnabled()) { <line36> } <line37> break; <line38> default: <line39> } <line40> } <line41> } <line42> 	<line5>, <line15>, <line20>, <line25>, <line31>, <line36>, <line39>
6217	public class A { <line0> public boolean deleteConfiguration(String domainName, String configurationName) <line1> throws RemoteException { <line2> try { <line3> return templateManagerAdminServiceStub.deleteConfiguration(domainName, configurationName); <line4> } catch (RemoteException e) { <line5> throw new RemoteException(e.getMessage(), e); <line6> } <line7> } <line8> } <line9> 	<line5>
6218	"public class A { <line0> @Override <line1> public synchronized void run() { <line2> try { <line3> setStatus(PluginStatus.STOPPING); <line4> try { <line5> onStop(); <line6> } catch (PluginShutdownException shutdownEx) { <line7> notifyError(shutdownEx.getMessage()); <line8> } <line9> sensorThread = null; <line10> setStatus(PluginStatus.STOPPED); <line11> PluginHasChanged event = <line12> new PluginHasChanged(this, getName(), PluginHasChanged.PluginActions.STOP); <line13> event.getPayload().addStatement(""plugin.status"", getStatus()); <line14> getBusService().send(event); <line15> } catch (Exception e) { <line16> setStatus(PluginStatus.FAILED); <line17> setDescription(""Plugin stopping FAILED. see logs for details.""); <line18> PluginHasChanged event = <line19> new PluginHasChanged(this, getName(), PluginHasChanged.PluginActions.START); <line20> event.getPayload().addStatement(""plugin.status"", getStatus()); <line21> getBusService().send(event); <line22> } <line23> } <line24> } <line25> "	<line18>
6219	"public class A { <line0> public static void main(String[] args) { <line1> BasePipelineOptions options = PipelinesOptionsFactory.create(BasePipelineOptions.class, args); <line2> String inputPath = options.getInputPath(); <line3> String tmpDir = PathBuilder.getTempDir(options); <line4> String outPath = options.getTargetPath(); <line5> Pipeline p = Pipeline.create(options); <line6> p.apply(""Read DwCA zip archive"", DwcaIO.Read.fromCompressed(inputPath, tmpDir)) <line7> .apply(""Interpret TemporalRecord"", TemporalTransform.builder().create().interpret()) <line8> .apply(""Interpret ExampleRecord"", ExampleTransform.exampleOne()) <line9> .apply( <line10> ""Write as Avro files"", <line11> AvroIO.write(ExampleRecord.class).to(outPath).withSuffix(AVRO_EXTENSION)); <line12> p.run().waitUntilFinish(); <line13> } <line14> } <line15> "	<line12>, <line13>
6220	"public class A { <line0> private void stopPeerConnectionStats(String jsFunction, String peerConnectionId) { <line1> try { <line2> browser.executeScript(""kurentoTest."" + jsFunction + ""('"" + peerConnectionId + ""');""); <line3> } catch (WebDriverException we) { <line4> we.printStackTrace(); <line5> } <line6> } <line7> } <line8> "	<line2>, <line5>
6221	"public class A { <line0> private static URL[] copyHdfsJarFilesToTempDir(String databaseName, List<String> jars) <line1> throws IOException { <line2> List<URL> urls = new ArrayList<URL>(); <line3> final Configuration conf = new Configuration(); <line4> Path localPath = createTempDir(databaseName, conf); <line5> for (String jar : jars) { <line6> Path jarPath = new Path(jar); <line7> final FileSystem fs = jarPath.getFileSystem(conf); <line8> if (fs.isFile(jarPath) && jarPath.getName().endsWith("".jar"")) { <line9> fs.copyToLocalFile(jarPath, localPath); <line10> } <line11> } <line12> urls.addAll(getJarsInPath(localPath.toUri().toURL())); <line13> return urls.toArray(new URL[urls.size()]); <line14> } <line15> } <line16> "	<line9>
6222	"public class A { <line0> public List<Product> getProducts() { <line1> return Arrays.asList( <line2> new Product(""Laptop"", 31000.00), <line3> new Product(""Mobile"", 16000.00), <line4> new Product(""Tablet"", 15000.00), <line5> new Product(""Camera"", 23000.00)); <line6> } <line7> } <line8> "	<line1>
6223	public class A { <line0> public boolean persist(SessionId session) { <line1> try { <line2> if (sessionIdService.updateSessionId(session, true)) { <line3> return true; <line4> } <line5> } catch (EntryPersistenceException e) { <line6> try { <line7> if (sessionIdService.persistSessionId(session, true)) { <line8> return true; <line9> } <line10> } catch (Exception ex) { <line11> } <line12> } catch (Exception e) { <line13> } <line14> return false; <line15> } <line16> } <line17> 	<line3>, <line8>, <line11>, <line13>
6224	"public class A { <line0> public static int getCommerceWishListItemByContainsCProductCount( <line1> HttpPrincipal httpPrincipal, long commerceWishListId, long cProductId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceWishListItemServiceUtil.class, <line7> ""getCommerceWishListItemByContainsCProductCount"", <line8> _getCommerceWishListItemByContainsCProductCountParameterTypes5); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceWishListId, cProductId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Integer) returnObj).intValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
6225	"public class A { <line0> @Override <line1> public void stateUpdated(Item item, State newState) { <line2> OnOffType onOffState = (OnOffType) item.getStateAs(OnOffType.class); <line3> if (onOffState != null) { <line4> boolean isOn = onOffState == OnOffType.ON; <line5> DeviceParam param = new DeviceParam(ParamType.STATUS, isOn ^ isInverted() ? ""1"" : ""0""); <line6> addParam(param); <line7> } <line8> } <line9> } <line10> "	<line2>
6226	public class A { <line0> public Cipher getDecryptCipher(String decryptKey) { <line1> Cipher cipher; <line2> setDataDecryptionKeyString(decryptKey); <line3> try { <line4> cipher = createDecryptCipherInternal(); <line5> } catch (Exception e) { <line6> cipher = null; <line7> } <line8> return cipher; <line9> } <line10> } <line11> 	<line6>
6227	public class A { <line0> public boolean cleanupFailedNodes(Map<NodeMetadata, Throwable> failedNodes) { <line1> boolean success; <line2> if (failedNodes.size() > 0) { <line3> Set<String> lostIds = Sets.newLinkedHashSet(); <line4> for (Map.Entry<NodeMetadata, Throwable> lostNode : failedNodes.entrySet()) { <line5> lostIds.add(lostNode.getKey().getId()); <line6> } <line7> int numberOfNodesToDelete = lostIds.size(); <line8> Set<? extends NodeMetadata> destroyedNodes = <line9> novaContext.getComputeService().destroyNodesMatching(Predicates.in(failedNodes.keySet())); <line10> lostIds.clear(); <line11> for (NodeMetadata destroyed : destroyedNodes) { <line12> lostIds.add(destroyed.getId()); <line13> } <line14> int numberOfNodesSuccesfullyDeleted = lostIds.size(); <line15> success = numberOfNodesSuccesfullyDeleted == numberOfNodesToDelete; <line16> } else { <line17> success = true; <line18> } <line19> return success; <line20> } <line21> } <line22> 	<line8>, <line14>
6228	"public class A { <line0> public static DefaultSlotPoolServiceSchedulerFactory fromConfiguration( <line1> Configuration configuration, JobType jobType) { <line2> final Time rpcTimeout = AkkaUtils.getTimeoutAsTime(configuration); <line3> final Time slotIdleTimeout = <line4> Time.milliseconds(configuration.getLong(JobManagerOptions.SLOT_IDLE_TIMEOUT)); <line5> final Time batchSlotTimeout = <line6> Time.milliseconds(configuration.getLong(JobManagerOptions.SLOT_REQUEST_TIMEOUT)); <line7> final SlotPoolServiceFactory slotPoolServiceFactory; <line8> final SchedulerNGFactory schedulerNGFactory; <line9> JobManagerOptions.SchedulerType schedulerType = ClusterOptions.getSchedulerType(configuration); <line10> if (schedulerType == JobManagerOptions.SchedulerType.Adaptive && jobType == JobType.BATCH) { <line11> schedulerType = JobManagerOptions.SchedulerType.Ng; <line12> } <line13> switch (schedulerType) { <line14> case Ng: <line15> schedulerNGFactory = new DefaultSchedulerFactory(); <line16> slotPoolServiceFactory = <line17> new DeclarativeSlotPoolBridgeServiceFactory( <line18> SystemClock.getInstance(), rpcTimeout, slotIdleTimeout, batchSlotTimeout); <line19> break; <line20> case Adaptive: <line21> schedulerNGFactory = getAdaptiveSchedulerFactoryFromConfiguration(configuration); <line22> slotPoolServiceFactory = <line23> new DeclarativeSlotPoolServiceFactory( <line24> SystemClock.getInstance(), slotIdleTimeout, rpcTimeout); <line25> break; <line26> default: <line27> throw new IllegalArgumentException( <line28> String.format( <line29> ""Illegal value [%s] for config option [%s]"", <line30> schedulerType, JobManagerOptions.SCHEDULER.key())); <line31> } <line32> return new DefaultSlotPoolServiceSchedulerFactory(slotPoolServiceFactory, schedulerNGFactory); <line33> } <line34> } <line35> "	<line11>
6229	"public class A { <line0> private void handleChecksumException(ChecksumException e) throws IOException { <line1> if (this.conf.getBoolean(""io.skip.checksum.errors"", false)) { <line2> sync(getPosition() + this.conf.getInt(""io.bytes.per.checksum"", 512)); <line3> } else { <line4> throw e; <line5> } <line6> } <line7> } <line8> "	<line2>
6230	"public class A { <line0> public OWLOntology generateOutputOntology(String outputIRI, boolean force, String errorsPath) <line1> throws Exception { <line2> boolean hasException = false; <line3> List<String[]> errors = new ArrayList<>(); <line4> errors.add(new String[] {""table"", ""cell"", ""rule ID"", ""message""}); <line5> for (List<String> row : tableRows) { <line6> try { <line7> processRow(row); <line8> } catch (RowParseException e) { <line9> if (!force) { <line10> throw e; <line11> } <line12> hasException = true; <line13> String message = e.getMessage().substring(e.getMessage().indexOf(""#"") + 1); <line14> if (e.rowNum != -1 && e.colNum != -1) { <line15> errors.add( <line16> new String[] {this.name, IOHelper.cellToA1(e.rowNum, e.colNum), e.ruleID, message}); <line17> } <line18> } <line19> } <line20> if (hasException) { <line21> if (errorsPath != null) { <line22> IOHelper.writeTable(errors, errorsPath); <line23> } <line24> } <line25> OWLOntologyManager manager = OWLManager.createOWLOntologyManager(); <line26> OWLOntology outputOntology; <line27> if (outputIRI != null) { <line28> IRI iri = IRI.create(outputIRI); <line29> outputOntology = manager.createOntology(iri); <line30> } else { <line31> outputOntology = manager.createOntology(); <line32> } <line33> manager.addAxioms(outputOntology, axioms); <line34> return outputOntology; <line35> } <line36> } <line37> "	<line14>, <line21>
6231	public class A { <line0> @Override <line1> public void beforeApplicationStart(CamelContext camelContext) { <line2> final String location = configuration.getConfigurationLocation(); <line3> final List<IntegrationStepHandler> handlers = new ArrayList<>(); <line4> handlers.addAll(integrationStepHandlers); <line5> for (IntegrationStepHandler handler : <line6> ServiceLoader.load( <line7> IntegrationStepHandler.class, Thread.currentThread().getContextClassLoader())) { <line8> handlers.add(handler); <line9> } <line10> if (LOGGER.isInfoEnabled()) { <line11> } <line12> final RouteBuilder routeBuilder = <line13> new IntegrationRouteBuilder(location, handlers, activityTrackingPolicyFactories); <line14> try { <line15> camelContext.addRoutes(routeBuilder); <line16> } catch (Exception e) { <line17> throw new IllegalArgumentException(e); <line18> } <line19> } <line20> } <line21> 	<line5>, <line11>
6232	"public class A { <line0> public static void stopProcessOnShutdown(final Process process) { <line1> Runtime.getRuntime() <line2> .addShutdownHook( <line3> new Thread( <line4> () -> { <line5> try { <line6> process.stop(); <line7> } catch (Throwable t) { <line8> } <line9> }, <line10> ""alluxio-process-shutdown-hook"")); <line11> } <line12> } <line13> "	<line8>
6233	"public class A { <line0> @Override <line1> public void run() { <line2> KunderaRedisClient cli = new KunderaRedisClient(); <line3> Properties props = new Properties(); <line4> props.setProperty(""hosts"", ""localhost""); <line5> cli.setProperties(props); <line6> try { <line7> cli.init(); <line8> } catch (Exception e) { <line9> System.exit(0); <line10> } <line11> HashMap<String, ByteIterator> vals = new HashMap<String, ByteIterator>(); <line12> vals.put(""age"", new StringByteIterator(""57"")); <line13> vals.put(""middlename"", new StringByteIterator(""bradley"")); <line14> vals.put(""favoritecolor"", new StringByteIterator(""blue"")); <line15> int res = cli.insert(""usertable"", ""BrianFrankCooper"", vals); <line16> cli.read(""usertable"", ""BrianFrankCooper"", null, null); <line17> System.out.println(""Result of insert: "" + res); <line18> try { <line19> cli.cleanup(); <line20> } catch (DBException e) { <line21> e.printStackTrace(); <line22> } <line23> } <line24> } <line25> "	<line9>
6234	public class A { <line0> protected List<Map<String, String>> selectStringList(String sql, List<String> columnList) { <line1> final DfJdbcFacade facade = new DfJdbcFacade(_dataSource); <line2> try { <line3> return facade.selectStringList(sql, columnList); <line4> } catch (RuntimeException continued) { <line5> return DfCollectionUtil.newArrayList(); <line6> } <line7> } <line8> } <line9> 	<line3>, <line5>
6235	"public class A { <line0> public void start(String url) { <line1> try { <line2> String baseDir = getBaseDir(url); <line3> if (tcpServer == null) { <line4> tcpServer = <line5> Server.createTcpServer( <line6> new String[] { <line7> ""-tcp"", ""-tcpAllowOthers"", ""-tcpPort"", getTcpPort(url), ""-baseDir"", baseDir <line8> }) <line9> .start(); <line10> logger.info(String.format(""h2 database tcp server is started on port %s"", TCP_PORT)); <line11> } else if (!tcpServer.isRunning(true)) { <line12> tcpServer.start(); <line13> } else { <line14> } <line15> if (webServer == null) { <line16> webServer = <line17> Server.createWebServer( <line18> new String[] { <line19> ""-web"", <line20> ""-webAllowOthers"", <line21> ""-webPort"", <line22> String.valueOf(WEB_PORT), <line23> ""-baseDir"", <line24> baseDir <line25> }) <line26> .start(); <line27> logger.info(String.format(""h2 database web server is started on port %s"", WEB_PORT)); <line28> } else if (!webServer.isRunning(true)) { <line29> webServer.start(); <line30> } else { <line31> } <line32> } catch (SQLException e) { <line33> } <line34> } <line35> } <line36> "	<line4>, <line12>, <line13>, <line14>, <line16>, <line29>, <line30>, <line31>, <line33>
6236	"public class A { <line0> @Scheduled(cron = ""0 0 1 * * ?"") <line1> public void removeNotActivatedUsers() { <line2> if (instanceId != 0) { <line3> return; <line4> } <line5> LocalDateTime now = LocalDateTime.now(); <line6> List<User> users = <line7> userRepository.findAllByActivatedIsFalseAndCreatedDateBefore(now.minusDays(3)); <line8> for (User user : users) { <line9> userRepository.delete(user); <line10> } <line11> } <line12> } <line13> "	<line9>
6237	"public class A { <line0> public void validateRegisteredS3Files( <line1> List<StorageFile> expectedStorageFiles, <line2> List<S3ObjectSummary> s3ObjectSummaries, <line3> String storageName, <line4> BusinessObjectDataKey businessObjectDataKey) { <line5> Set<String> actualS3FilePaths = <line6> new HashSet<>(getFilePathsFromS3ObjectSummaries(s3ObjectSummaries)); <line7> for (StorageFile expectedStorageFile : expectedStorageFiles) { <line8> if (!actualS3FilePaths.contains(expectedStorageFile.getFilePath())) { <line9> throw new ObjectNotFoundException( <line10> String.format( <line11> ""Registered file \""%s\"" does not exist in \""%s\"" storage."", <line12> expectedStorageFile.getFilePath(), storageName)); <line13> } <line14> } <line15> Set<String> expectedFilePaths = <line16> new HashSet<>(getFilePathsFromStorageFiles(expectedStorageFiles)); <line17> String businessObjectDataKeyAsJson = jsonHelper.objectToJson(businessObjectDataKey); <line18> for (S3ObjectSummary s3ObjectSummary : s3ObjectSummaries) { <line19> if (!expectedFilePaths.contains(s3ObjectSummary.getKey())) { <line20> if (s3ObjectSummary.getSize() == 0) { <line21> } else { <line22> throw new IllegalStateException( <line23> String.format( <line24> ""Found unregistered non-empty S3 file \""%s\"" in \""%s\"" storage. Business object"" <line25> + "" data {%s}"", <line26> s3ObjectSummary.getKey(), <line27> storageName, <line28> businessObjectDataHelper.businessObjectDataKeyToString(businessObjectDataKey))); <line29> } <line30> } <line31> } <line32> } <line33> } <line34> "	<line21>
6238	"public class A { <line0> @GET <line1> @Path(""/settings.json"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @RestQuery( <line4> name = ""getUserSettings"", <line5> description = ""Returns a list of the user settings for the current user"", <line6> returnDescription = ""Returns a JSON representation of the list of user settings"", <line7> restParameters = { <line8> @RestParameter( <line9> defaultValue = ""100"", <line10> description = ""The maximum number of items to return per page."", <line11> isRequired = false, <line12> name = ""limit"", <line13> type = RestParameter.Type.STRING), <line14> @RestParameter( <line15> defaultValue = ""0"", <line16> description = ""The page number."", <line17> isRequired = false, <line18> name = ""offset"", <line19> type = RestParameter.Type.STRING) <line20> }, <line21> responses = {@RestResponse(responseCode = SC_OK, description = ""The user settings."")}) <line22> public Response getUserSettings(@QueryParam(""limit"") int limit, @QueryParam(""offset"") int offset) <line23> throws IOException { <line24> if (limit < 1) { <line25> limit = 100; <line26> } <line27> UserSettings userSettings; <line28> try { <line29> userSettings = userSettingsService.findUserSettings(limit, offset); <line30> } catch (UserSettingsServiceException e) { <line31> return (Response.serverError().build()); <line32> } <line33> return Response.ok(userSettings.toJson().toJson()).build(); <line34> } <line35> } <line36> "	<line31>
6239	public class A { <line0> @Override <line1> public void initialized() { <line2> async.withLog( <line3> log, <line4> () -> { <line5> Registration registration = <line6> new Registration( <line7> WORKSPACE_FOLDERS_CAPABILITY_ID, WORKSPACE_FOLDERS_CAPABILITY_NAME, null); <line8> RegistrationParams registrationParams = <line9> new RegistrationParams(Collections.singletonList(registration)); <line10> getClient().registerCapability(registrationParams); <line11> this.initialized.complete(null); <line12> }); <line13> } <line14> } <line15> 	<line12>
6240	public class A { <line0> private void logFirstTimeMBeanException(String mbeanObjectName, Exception e) { <line1> if (loggedMBeanGauges.add(mbeanObjectName)) { <line2> } <line3> } <line4> } <line5> 	<line2>
6241	public class A { <line0> @Override <line1> public void onCreateTable(CreateTableEvent tableEvent) throws MetaException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> try { <line5> activatePluginClassLoader(); <line6> atlasMetastoreHookImpl.onCreateTable(tableEvent); <line7> } finally { <line8> deactivatePluginClassLoader(); <line9> } <line10> if (LOG.isDebugEnabled()) { <line11> } <line12> } <line13> } <line14> 	<line3>, <line11>
6242	"public class A { <line0> @Test <line1> void testUpgradeAcrossVersionsWithNoKafkaVersion(ExtensionContext extensionContext) <line2> throws IOException { <line3> JsonObject acrossUpgradeData = buildDataForUpgradeAcrossVersions(); <line4> JsonObject conversionTool = getConversionToolDataFromUpgradeJSON(); <line5> String continuousTopicName = ""continuous-topic""; <line6> String producerName = ""hello-world-producer""; <line7> String consumerName = ""hello-world-consumer""; <line8> String continuousConsumerGroup = ""continuous-consumer-group""; <line9> setupEnvAndUpgradeClusterOperator( <line10> extensionContext, <line11> acrossUpgradeData, <line12> producerName, <line13> consumerName, <line14> continuousTopicName, <line15> continuousConsumerGroup, <line16> null, <line17> NAMESPACE); <line18> convertCRDs(conversionTool, NAMESPACE); <line19> changeClusterOperator(acrossUpgradeData, NAMESPACE); <line20> zkPods = <line21> StatefulSetUtils.waitTillSsHasRolled( <line22> KafkaResources.zookeeperStatefulSetName(clusterName), 3, zkPods); <line23> kafkaPods = <line24> StatefulSetUtils.waitTillSsHasRolled( <line25> KafkaResources.kafkaStatefulSetName(clusterName), 3, kafkaPods); <line26> eoPods = <line27> DeploymentUtils.waitTillDepHasRolled( <line28> KafkaResources.entityOperatorDeploymentName(clusterName), 1, eoPods); <line29> logPodImages(clusterName); <line30> changeKafkaAndLogFormatVersion( <line31> acrossUpgradeData.getJsonObject(""proceduresAfterOperatorUpgrade""), <line32> acrossUpgradeData, <line33> clusterName, <line34> extensionContext); <line35> logPodImages(clusterName); <line36> checkAllImages(acrossUpgradeData.getJsonObject(""imagesAfterKafkaUpgrade"")); <line37> PodUtils.verifyThatRunningPodsAreStable(clusterName); <line38> verifyProcedure(acrossUpgradeData, producerName, consumerName, NAMESPACE); <line39> assertNoCoErrorsLogged(0); <line40> } <line41> } <line42> "	<line29>
6243	public class A { <line0> @Override <line1> public void init() throws Exception { <line2> String xmlConfig = this.getConfigManager().getConfigItem(SystemConstants.CONFIG_ITEM_LANGS); <line3> this.getCacheWrapper().initCache(xmlConfig); <line4> } <line5> } <line6> 	<line4>
6244	public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (command instanceof RefreshType) { <line3> return; <line4> } <line5> if (getThing().getStatus() == ThingStatus.UNKNOWN <line6> || (getThing().getStatus() == ThingStatus.OFFLINE <line7> && (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.BRIDGE_OFFLINE <line8> || getThing().getStatusInfo().getStatusDetail() <line9> == ThingStatusDetail.BRIDGE_UNINITIALIZED <line10> || getThing().getStatusInfo().getStatusDetail() <line11> == ThingStatusDetail.CONFIGURATION_ERROR))) { <line12> return; <line13> } <line14> if (bridgeHandler == null) { <line15> return; <line16> } <line17> switch (channelUID.getId()) { <line18> case PLAYURL: <line19> playMedia(channelUID, command); <line20> break; <line21> case STOP: <line22> stopMedia(channelUID, command); <line23> break; <line24> default: <line25> break; <line26> } <line27> } <line28> } <line29> 	<line25>
6245	public class A { <line0> public void destroy() { <line1> if (logger.isInfoEnabled()) { <line2> } <line3> Set<URL> destroyRegistered = new HashSet<URL>(getRegistered()); <line4> if (!destroyRegistered.isEmpty()) { <line5> for (URL url : new HashSet<URL>(getRegistered())) { <line6> if (url.getParameter(Constants.DYNAMIC_KEY, true)) { <line7> try { <line8> unregister(url); <line9> if (logger.isInfoEnabled()) { <line10> } <line11> } catch (Throwable t) { <line12> } <line13> } <line14> } <line15> } <line16> Map<URL, Set<NotifyListener>> destroySubscribed = <line17> new HashMap<URL, Set<NotifyListener>>(getSubscribed()); <line18> if (!destroySubscribed.isEmpty()) { <line19> for (Map.Entry<URL, Set<NotifyListener>> entry : destroySubscribed.entrySet()) { <line20> URL url = entry.getKey(); <line21> for (NotifyListener listener : entry.getValue()) { <line22> try { <line23> unsubscribe(url, listener); <line24> if (logger.isInfoEnabled()) { <line25> } <line26> } catch (Throwable t) { <line27> } <line28> } <line29> } <line30> } <line31> } <line32> } <line33> 	<line2>, <line10>, <line12>, <line25>, <line27>
6246	public class A { <line0> private void setMemberGroups( <line1> final CoreSession session, final String memberDN, final Set<String> groups) <line2> throws LdapException { <line3> final Set<String> newGroups = (groups == null) ? new HashSet<>() : new HashSet<>(groups); <line4> final Set<String> oldgroupDNs = getDNsOfGroupsContainingMember(session, memberDN); <line5> final Set<String> newgroupDNs = new HashSet<>(); <line6> for (String groupName : newGroups) { <line7> newgroupDNs.add(getGroupDN(groupName)); <line8> } <line9> final Set<String> tempOldgroupDNs = new HashSet<>(oldgroupDNs); <line10> tempOldgroupDNs.removeAll(newgroupDNs); <line11> for (String groupDN : tempOldgroupDNs) { <line12> removeMemberFromRoleOrGroup(session, groupDN, memberDN, UNIQUE_MEMBER); <line13> } <line14> newgroupDNs.removeAll(oldgroupDNs); <line15> if (this.rodaAdminDN.equals(memberDN)) { <line16> newgroupDNs.add(this.rodaAdministratorsDN); <line17> } <line18> for (String groupDN : newgroupDNs) { <line19> try { <line20> addMemberToRoleOrGroup(session, groupDN, memberDN, UNIQUE_MEMBER); <line21> } catch (final LdapNoSuchObjectException e) { <line22> } <line23> } <line24> } <line25> } <line26> 	<line22>
6247	"public class A { <line0> @Override <line1> public void updateConfig(AvatarConfig config) throws ApsSystemException { <line2> try { <line3> String xml = new AvatarConfigDOM().createConfigXml(config); <line4> this.getConfigManager().updateConfigItem(JpAvatarSystemConstants.CONFIG_ITEM, xml); <line5> this.setConfig(config); <line6> } catch (Throwable t) { <line7> throw new ApsSystemException(""Error updating jpavatar config"", t); <line8> } <line9> } <line10> } <line11> "	<line7>
6248	"public class A { <line0> @Test <line1> public void testMarkStartTime() { <line2> final DefaultTraceId traceId = new DefaultTraceId(""agentId"", 0, 0); <line3> TraceRoot traceRoot = new DefaultTraceRoot(traceId, ""agentId"", System.currentTimeMillis(), 0); <line4> Span span = new Span(traceRoot); <line5> span.markBeforeTime(); <line6> span.setElapsedTime((int) (span.getStartTime() + 10)); <line7> final SpanEvent spanEvent = new SpanEvent(); <line8> long currentTime = System.currentTimeMillis(); <line9> spanEvent.setStartTime(currentTime); <line10> spanEvent.setElapsedTime(10); <line11> span.setSpanEventList(Arrays.asList(spanEvent)); <line12> TSpan tSpan = new TSpan(); <line13> TSpanEvent tSpanEvent = new TSpanEvent(); <line14> tSpan.addToSpanEventList(tSpanEvent); <line15> compressorV1.preProcess(span, tSpan); <line16> compressorV1.postProcess(span, tSpan); <line17> Assert.assertEquals( <line18> ""startTime"", span.getStartTime() + tSpanEvent.getStartElapsed(), spanEvent.getStartTime()); <line19> Assert.assertEquals( <line20> ""endTime"", <line21> span.getStartTime() + tSpanEvent.getStartElapsed() + spanEvent.getElapsedTime(), <line22> spanEvent.getAfterTime()); <line23> } <line24> } <line25> "	<line7>, <line11>
6249	public class A { <line0> @Override <line1> public void setValency(Integer valency) { <line2> super.setValency(valency); <line3> } <line4> } <line5> 	<line2>
6250	public class A { <line0> @Override <line1> public Message receive(TestContext context, long timeout) { <line2> String endpointUri = <line3> context.replaceDynamicContentInString(endpointConfiguration.getEndpointUri()); <line4> if (log.isDebugEnabled()) { <line5> } <line6> Exchange exchange = getConsumerTemplate().receive(endpointUri, timeout); <line7> if (exchange == null) { <line8> throw new MessageTimeoutException(timeout, endpointUri); <line9> } <line10> Message message = <line11> endpointConfiguration <line12> .getMessageConverter() <line13> .convertInbound(exchange, endpointConfiguration, context); <line14> context.onInboundMessage(message); <line15> String correlationKeyName = <line16> endpointConfiguration.getCorrelator().getCorrelationKeyName(getName()); <line17> String correlationKey = endpointConfiguration.getCorrelator().getCorrelationKey(message); <line18> correlationManager.saveCorrelationKey(correlationKeyName, correlationKey, context); <line19> correlationManager.store(correlationKey, exchange); <line20> return message; <line21> } <line22> } <line23> 	<line5>, <line10>
6251	"public class A { <line0> public static java.util.List<com.liferay.calendar.model.CalendarBooking> getCalendarBookings( <line1> HttpPrincipal httpPrincipal, long calendarId, long startTime, long endTime) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CalendarBookingServiceUtil.class, <line7> ""getCalendarBookings"", <line8> _getCalendarBookingsParameterTypes12); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, calendarId, startTime, endTime); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (java.util.List<com.liferay.calendar.model.CalendarBooking>) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
6252	"public class A { <line0> public static com.liferay.message.boards.model.MBBan addBan( <line1> HttpPrincipal httpPrincipal, <line2> long banUserId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = new MethodKey(MBBanServiceUtil.class, ""addBan"", _addBanParameterTypes0); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, banUserId, serviceContext); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (com.liferay.message.boards.model.MBBan) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>
6253	"public class A { <line0> public void registerUuid(String key) throws DaikinCommunicationException { <line1> Map<String, String> params = new HashMap<>(); <line2> params.put(""key"", key); <line3> String response = invoke(registerUuidUri, params); <line4> } <line5> } <line6> "	<line4>
6254	"public class A { <line0> public boolean isFinancialYearActiveForPosting(Date fromDate, Date toDate) { <line1> String result = """"; <line2> Query query = <line3> getCurrentSession() <line4> .createQuery( <line5> "" from CFinancialYear cfinancialyear where  "" <line6> + "" cfinancialyear.isActiveForPosting=false and cfinancialyear.startingDate"" <line7> + "" <=:sDate and cfinancialyear.endingDate >=:eDate  ""); <line8> query.setDate(""sDate"", fromDate); <line9> query.setDate(""eDate"", toDate); <line10> ArrayList list = (ArrayList) query.list(); <line11> if (list.size() > 0) return false; <line12> else return true; <line13> } <line14> } <line15> "	<line1>
6255	public class A { <line0> @Override <line1> public List<Feed> getFeedsByProperties(Map<String, Object> properties, RequestContext context) { <line2> Response dbResponse = <line3> getCassandraInstance() <line4> .getRecordById( <line5> usrFeedDbInfo.getKeySpace(), usrFeedDbInfo.getTableName(), properties, context); <line6> List<Map<String, Object>> responseList = null; <line7> List<Feed> feedList = new ArrayList<>(); <line8> if (null != dbResponse && null != dbResponse.getResult()) { <line9> responseList = (List<Map<String, Object>>) dbResponse.getResult().get(JsonKey.RESPONSE); <line10> if (CollectionUtils.isNotEmpty(responseList)) { <line11> responseList.forEach( <line12> s -> { <line13> try { <line14> String data = (String) s.get(JsonKey.FEED_DATA); <line15> if (StringUtils.isNotBlank(data)) { <line16> s.put( <line17> JsonKey.FEED_DATA, <line18> mapper.readValue(data, new TypeReference<Map<String, Object>>() {})); <line19> } else { <line20> s.put(JsonKey.FEED_DATA, Collections.emptyMap()); <line21> } <line22> feedList.add(mapper.convertValue(s, Feed.class)); <line23> } catch (Exception ex) { <line24> } <line25> }); <line26> } <line27> } <line28> return feedList; <line29> } <line30> } <line31> 	<line2>, <line24>
6256	public class A { <line0> protected boolean handleEnv(Buffer buffer) throws IOException { <line1> String name = buffer.getString(); <line2> String value = buffer.getString(); <line3> addEnvVariable(name, value); <line4> return true; <line5> } <line6> } <line7> 	<line4>
6257	"public class A { <line0> protected void processRequest(HttpServletRequest request, HttpServletResponse response) <line1> throws ServletException, IOException { <line2> PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS); <line3> String system = policy.sanitize(request.getParameter(""system"")); <line4> ApplicationContext appContext = <line5> WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); <line6> ITestCaseService testService = appContext.getBean(ITestCaseService.class); <line7> JSONArray array = new JSONArray(); <line8> JSONObject jsonObject = new JSONObject(); <line9> for (String test : testService.findTestWithTestCaseActiveAutomatedBySystem(system)) { <line10> array.put(test); <line11> } <line12> try { <line13> jsonObject.put(""testsList"", array); <line14> response.setContentType(""application/json""); <line15> response.getWriter().print(jsonObject.toString()); <line16> } catch (JSONException exception) { <line17> } <line18> } <line19> } <line20> "	<line17>
6258	public class A { <line0> private void initHeapStates() throws Exception { <line1> requestCount += 1; <line2> RowData partitionKey = (RowData) keyContext.getCurrentKey(); <line3> buffer = kvSortedMap.get(partitionKey); <line4> rowKeyMap = kvRowKeyMap.get(partitionKey); <line5> if (buffer == null) { <line6> buffer = new TopNBuffer(sortKeyComparator, LinkedHashSet::new); <line7> rowKeyMap = new HashMap<>(); <line8> kvSortedMap.put(partitionKey, buffer); <line9> kvRowKeyMap.put(partitionKey, rowKeyMap); <line10> Iterator<Map.Entry<RowData, Tuple2<RowData, Integer>>> iter = dataState.iterator(); <line11> if (iter != null) { <line12> Map<RowData, TreeMap<Integer, RowData>> tempSortedMap = new HashMap<>(); <line13> while (iter.hasNext()) { <line14> Map.Entry<RowData, Tuple2<RowData, Integer>> entry = iter.next(); <line15> RowData rowKey = entry.getKey(); <line16> Tuple2<RowData, Integer> recordAndInnerRank = entry.getValue(); <line17> RowData record = recordAndInnerRank.f0; <line18> Integer innerRank = recordAndInnerRank.f1; <line19> rowKeyMap.put(rowKey, new RankRow(record, innerRank, false)); <line20> RowData sortKey = sortKeySelector.getKey(record); <line21> TreeMap<Integer, RowData> treeMap = tempSortedMap.get(sortKey); <line22> if (treeMap == null) { <line23> treeMap = new TreeMap<>(); <line24> tempSortedMap.put(sortKey, treeMap); <line25> } <line26> treeMap.put(innerRank, rowKey); <line27> } <line28> Iterator<Map.Entry<RowData, TreeMap<Integer, RowData>>> tempIter = <line29> tempSortedMap.entrySet().iterator(); <line30> while (tempIter.hasNext()) { <line31> Map.Entry<RowData, TreeMap<Integer, RowData>> entry = tempIter.next(); <line32> RowData sortKey = entry.getKey(); <line33> TreeMap<Integer, RowData> treeMap = entry.getValue(); <line34> Iterator<Map.Entry<Integer, RowData>> treeMapIter = treeMap.entrySet().iterator(); <line35> while (treeMapIter.hasNext()) { <line36> Map.Entry<Integer, RowData> treeMapEntry = treeMapIter.next(); <line37> Integer innerRank = treeMapEntry.getKey(); <line38> RowData recordRowKey = treeMapEntry.getValue(); <line39> int size = buffer.put(sortKey, recordRowKey); <line40> if (innerRank != size) { <line41> } <line42> } <line43> } <line44> } <line45> } else { <line46> hitCount += 1; <line47> } <line48> } <line49> } <line50> 	<line41>
6259	public class A { <line0> @Override <line1> public String getTypeName(Locale locale, long subtypeId) { <line2> try { <line3> DLFileEntryType dlFileEntryType = _dlFileEntryTypeLocalService.getFileEntryType(subtypeId); <line4> return dlFileEntryType.getName(locale); <line5> } catch (Exception exception) { <line6> if (_log.isDebugEnabled()) { <line7> } <line8> return super.getTypeName(locale, subtypeId); <line9> } <line10> } <line11> } <line12> 	<line7>
6260	public class A { <line0> @Override <line1> public boolean offer(ProcessContext context) throws FrameworkException { <line2> List<EventConsumer> eventHandlers = getEventConsumers(context.getClass()); <line3> if (CollectionUtils.isEmpty(eventHandlers)) { <line4> if (LOGGER.isWarnEnabled()) { <line5> } <line6> return false; <line7> } <line8> boolean isFirstEvent = false; <line9> Stack<ProcessContext> currentStack = <line10> (Stack<ProcessContext>) context.getVariable(VAR_NAME_SYNC_EXE_STACK); <line11> if (currentStack == null) { <line12> synchronized (context) { <line13> currentStack = (Stack<ProcessContext>) context.getVariable(VAR_NAME_SYNC_EXE_STACK); <line14> if (currentStack == null) { <line15> currentStack = new Stack<>(); <line16> context.setVariable(VAR_NAME_SYNC_EXE_STACK, currentStack); <line17> isFirstEvent = true; <line18> } <line19> } <line20> } <line21> currentStack.push(context); <line22> if (isFirstEvent) { <line23> try { <line24> while (currentStack.size() > 0) { <line25> ProcessContext currentContext = currentStack.pop(); <line26> for (EventConsumer eventHandler : eventHandlers) { <line27> eventHandler.process(currentContext); <line28> } <line29> } <line30> } finally { <line31> context.removeVariable(VAR_NAME_SYNC_EXE_STACK); <line32> } <line33> } <line34> return true; <line35> } <line36> } <line37> 	<line5>
6261	public class A { <line0> public void stop() { <line1> if (server != null) { <line2> server.shutdown(); <line3> } <line4> } <line5> } <line6> 	<line3>
6262	"public class A { <line0> private List<BundleItem> getBundleListFromTDM() throws Exception { <line1> ArrayList<BundleItem> output = new ArrayList<BundleItem>(); <line2> List<JsonObject> bundles = _apiLibrary.getItemsForRequest(""bundle"", ""list""); <line3> for (JsonObject itemToAdd : bundles) { <line4> BundleItem item = new BundleItem(); <line5> item.setId(itemToAdd.get(""id"").getAsString()); <line6> item.setName(itemToAdd.get(""name"").getAsString()); <line7> ArrayList<String> applicableAgencyIds = new ArrayList<String>(); <line8> for (JsonElement _subitemToAdd : itemToAdd.get(""applicable-agency-ids"").getAsJsonArray()) { <line9> String agencyIdToAdd = _subitemToAdd.getAsString(); <line10> applicableAgencyIds.add(agencyIdToAdd); <line11> } <line12> item.setApplicableAgencyIds(applicableAgencyIds); <line13> item.setServiceDateFrom( <line14> ServiceDate.parseString( <line15> itemToAdd.get(""service-date-from"").getAsString().replace(""-"", """"))); <line16> item.setServiceDateTo( <line17> ServiceDate.parseString(itemToAdd.get(""service-date-to"").getAsString().replace(""-"", """"))); <line18> item.setCreated(_updatedDateFormatter.parseDateTime(itemToAdd.get(""created"").getAsString())); <line19> item.setUpdated(_updatedDateFormatter.parseDateTime(itemToAdd.get(""updated"").getAsString())); <line20> ArrayList<BundleFileItem> files = new ArrayList<BundleFileItem>(); <line21> for (JsonElement _subitemToAdd : itemToAdd.get(""files"").getAsJsonArray()) { <line22> JsonObject subitemToAdd = _subitemToAdd.getAsJsonObject(); <line23> BundleFileItem fileItemToAdd = new BundleFileItem(); <line24> fileItemToAdd.setFilename(subitemToAdd.get(""filename"").getAsString()); <line25> fileItemToAdd.setMd5(subitemToAdd.get(""md5"").getAsString()); <line26> files.add(fileItemToAdd); <line27> } <line28> item.setFiles(files); <line29> output.add(item); <line30> } <line31> return output; <line32> } <line33> } <line34> "	<line2>, <line31>
6263	public class A { <line0> public void log(Level level, String msg) { <line1> if (level.intValue() >= Level.SEVERE.intValue()) { <line2> } else if (level.intValue() >= Level.WARNING.intValue()) { <line3> } else if (level.intValue() >= Level.CONFIG.intValue()) { <line4> } else if (level.intValue() >= Level.FINE.intValue()) { <line5> } else { <line6> } <line7> } <line8> } <line9> 	<line2>, <line3>, <line4>, <line5>, <line6>
6264	"public class A { <line0> @Override <line1> public void cleanup(String datasetName) throws SQLEngineException { <line2> BigQuerySQLDataset bqDataset = datasets.get(datasetName); <line3> if (bqDataset == null) { <line4> return; <line5> } <line6> SQLEngineException ex = null; <line7> try { <line8> cancelJob(datasetName, bqDataset); <line9> } catch (BigQueryException e) { <line10> ex = <line11> new SQLEngineException( <line12> String.format(""Exception when executing cleanup for stage '%s'"", datasetName), e); <line13> } <line14> try { <line15> deleteTable(datasetName, bqDataset); <line16> } catch (BigQueryException e) { <line17> if (ex == null) { <line18> ex = <line19> new SQLEngineException( <line20> String.format(""Exception when executing cleanup for stage '%s'"", datasetName), e); <line21> } else { <line22> ex.addSuppressed(e); <line23> } <line24> } <line25> try { <line26> deleteTempFolder(bqDataset); <line27> } catch (IOException e) { <line28> if (ex == null) { <line29> ex = <line30> new SQLEngineException( <line31> String.format(""Exception when executing cleanup for stage '%s'"", datasetName), e); <line32> } else { <line33> ex.addSuppressed(e); <line34> } <line35> } <line36> if (ex != null) { <line37> throw ex; <line38> } <line39> } <line40> } <line41> "	<line10>, <line17>, <line28>
6265	"public class A { <line0> private ComboPooledDataSource getComboPooledDataSource( <line1> String type, String host, String name, String driver, String user, String pass) { <line2> final String jdbcUrlTemplate = ""jdbc:%s://%s/%s""; <line3> ComboPooledDataSource pool = new ComboPooledDataSource(); <line4> try { <line5> pool.setDriverClass(driver); <line6> } catch (PropertyVetoException ex) { <line7> } <line8> final String jdbcUrl = String.format(jdbcUrlTemplate, type, host, name); <line9> pool.setJdbcUrl(jdbcUrl); <line10> pool.setUser(user); <line11> pool.setPassword(pass); <line12> pool.setMinPoolSize(1); <line13> pool.setMaxPoolSize(100); <line14> pool.setUnreturnedConnectionTimeout(30000); <line15> pool.setTestConnectionOnCheckout(false); <line16> pool.setTestConnectionOnCheckin(true); <line17> pool.setIdleConnectionTestPeriod(60); <line18> pool.setPreferredTestQuery(""SELECT 1""); <line19> return pool; <line20> } <line21> } <line22> "	<line7>
6266	"public class A { <line0> private double getCPUStateIdle() { <line1> double result = 0; <line2> try { <line3> return Double.parseDouble(provider.getAsString(new OID("".1.3.6.1.4.1.2021.11.11.0""))) / 100.0; <line4> } catch (Exception e) { <line5> } <line6> return result; <line7> } <line8> } <line9> "	<line5>, <line6>
6267	public class A { <line0> private void killBookie( <line1> ArrayList<BookieSocketAddress> firstEnsemble, BookieSocketAddress ensemble) <line2> throws InterruptedException { <line3> killBookie(ensemble); <line4> } <line5> } <line6> 	<line3>
6268	public class A { <line0> @Override <line1> public synchronized void saveHistory() { <line2> try { <line3> FileUtils.saveCommandHistoryString(history, new File(Constants.CMD_HISTORY_FILE)); <line4> } catch (Throwable e) { <line5> } <line6> } <line7> } <line8> 	<line5>
6269	"public class A { <line0> @Test <line1> public void testGetRootFolder() throws Exception { <line2> final com.box.sdk.BoxFolder result = requestBody(""direct://GETROOTFOLDER"", null); <line3> assertNotNull(result, ""getRootFolder result""); <line4> } <line5> } <line6> "	<line4>
6270	public class A { <line0> private synchronized void stopping(Bundle bundle) { <line1> ModuleState.State moduleState = getModuleState(bundle).getState(); <line2> if (isInvalid(moduleState)) { <line3> return; <line4> } <line5> if (!keepPreviousStateOnStop(bundle)) { <line6> setModuleState(bundle, ModuleState.State.STOPPING, null); <line7> } <line8> long startTime = System.currentTimeMillis(); <line9> JahiaTemplatesPackage jahiaTemplatesPackage = templatePackageRegistry.lookupByBundle(bundle); <line10> if (jahiaTemplatesPackage == null || !jahiaTemplatesPackage.isActiveVersion()) { <line11> return; <line12> } <line13> if (JahiaContextLoaderListener.isRunning()) { <line14> templatePackageRegistry.unregister(jahiaTemplatesPackage); <line15> jahiaTemplatesPackage.setActiveVersion(false); <line16> templatesService.fireTemplatePackageRedeployedEvent(jahiaTemplatesPackage); <line17> if (jahiaTemplatesPackage.getContext() != null) { <line18> jahiaTemplatesPackage.setContext(null); <line19> } <line20> for (Map.Entry<BundleURLScanner, BundleObserver<URL>> scannerAndObserver : <line21> extensionObservers.entrySet()) { <line22> List<URL> foundURLs = scannerAndObserver.getKey().scan(bundle); <line23> if (!foundURLs.isEmpty()) { <line24> scannerAndObserver.getValue().removingEntries(bundle, foundURLs); <line25> } <line26> } <line27> scriptEngineManager.removeScriptEngineFactoriesIfNeeded(bundle); <line28> flushOutputCachesForModule(jahiaTemplatesPackage); <line29> ServiceTracker<HttpService, HttpService> tracker = bundleHttpServiceTrackers.remove(bundle); <line30> if (tracker != null) { <line31> tracker.close(); <line32> } <line33> } <line34> long totalTime = System.currentTimeMillis() - startTime; <line35> } <line36> } <line37> 	<line5>, <line35>
6271	public class A { <line0> @Override <line1> protected void dbUserWarnMessage( <line2> String jdbcUsername, String jdbcPassword, String optionUsername, String optionPasssword) { <line3> if (!StringUtils.equals(optionUsername, jdbcUsername) <line4> || !StringUtils.equals(optionPasssword, jdbcPassword)) { <line5> } <line6> } <line7> } <line8> 	<line5>
6272	public class A { <line0> @Override <line1> public void render( <line2> List<JournalArticle> articles, InfoListRendererContext infoListRendererContext) { <line3> InfoListBasicListTag infoListBasicListTag = new InfoListBasicListTag(); <line4> infoListBasicListTag.setInfoListObjects(articles); <line5> Optional<String> infoListItemRendererKeyOptional = <line6> infoListRendererContext.getListItemRendererKeyOptional(); <line7> if (infoListItemRendererKeyOptional.isPresent() <line8> && Validator.isNotNull(infoListItemRendererKeyOptional.get())) { <line9> infoListBasicListTag.setItemRendererKey(infoListItemRendererKeyOptional.get()); <line10> } else { <line11> infoListBasicListTag.setItemRendererKey(JournalArticleTitleInfoItemRenderer.class.getName()); <line12> } <line13> infoListBasicListTag.setListStyleKey(getListStyle()); <line14> Optional<String> templateKeyOptional = infoListRendererContext.getTemplateKeyOptional(); <line15> if (templateKeyOptional.isPresent() && Validator.isNotNull(templateKeyOptional.get())) { <line16> infoListBasicListTag.setTemplateKey(templateKeyOptional.get()); <line17> } <line18> try { <line19> infoListBasicListTag.doTag( <line20> infoListRendererContext.getHttpServletRequest(), <line21> infoListRendererContext.getHttpServletResponse()); <line22> } catch (Exception exception) { <line23> } <line24> } <line25> } <line26> 	<line23>
6273	"public class A { <line0> protected boolean checkSavedPreviousResource(DfAlterCheckFinalInfo finalInfo) { <line1> final boolean unzipped = extractPreviousResource(); <line2> try { <line3> playPreviousSchema(); <line4> } catch (RuntimeException threwLater) { <line5> markPreviousNG(getAlterCheckSavePreviousFailureNotice()); <line6> setupAlterCheckSavePreviousFailureException(finalInfo, threwLater); <line7> } <line8> if (finalInfo.isFailure()) { <line9> finalInfo.addDetailMessage(""x (save failure)""); <line10> return false; <line11> } <line12> if (unzipped) { <line13> deleteExtractedPreviousResource(); <line14> } <line15> return true; <line16> } <line17> } <line18> "	<line2>
6274	public class A { <line0> private void updateTagServiceDefForDeletingRowFilterDef( <line1> RangerServiceDef tagServiceDef, String serviceDefName) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> RangerServiceDef.RangerRowFilterDef tagRowFilterDef = tagServiceDef.getRowFilterDef(); <line5> if (tagRowFilterDef == null) { <line6> return; <line7> } <line8> String prefix = serviceDefName + COMPONENT_ACCESSTYPE_SEPARATOR; <line9> List<RangerServiceDef.RangerAccessTypeDef> accessTypes = new ArrayList<>(); <line10> for (RangerServiceDef.RangerAccessTypeDef accessType : tagRowFilterDef.getAccessTypes()) { <line11> if (accessType.getName().startsWith(prefix)) { <line12> accessTypes.add(accessType); <line13> } <line14> } <line15> tagRowFilterDef.getAccessTypes().removeAll(accessTypes); <line16> if (LOG.isDebugEnabled()) { <line17> } <line18> } <line19> } <line20> 	<line3>, <line17>
6275	public class A { <line0> public static NotificationInterface get() { <line1> if (notificationProvider == null) { <line2> try { <line3> Configuration conf = ApplicationProperties.get(); <line4> KafkaNotification kafka = new KafkaNotification(conf); <line5> String spoolDir = getSpoolDir(conf); <line6> if (isSpoolingEnabled(conf) && StringUtils.isNotEmpty(spoolDir)) { <line7> conf.setProperty(CONF_ATLAS_HOOK_SPOOL_DIR, spoolDir); <line8> notificationProvider = new AtlasFileSpool(conf, kafka); <line9> } else { <line10> notificationProvider = kafka; <line11> } <line12> } catch (AtlasException e) { <line13> throw new RuntimeException(e); <line14> } <line15> } <line16> return notificationProvider; <line17> } <line18> } <line19> 	<line7>, <line10>
6276	public class A { <line0> @Override <line1> public boolean needsToWait() { <line2> try { <line3> return findChannel(channelName) == null; <line4> } catch (IOException e) { <line5> return false; <line6> } <line7> } <line8> } <line9> 	<line5>
6277	public class A { <line0> public Object eval(String expression, Map<String, Object> vars) { <line1> try { <line2> Object obj = compile(expression, context); <line3> return MVEL.executeExpression(obj, vars); <line4> } catch (Throwable e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	<line5>
6278	public class A { <line0> void testRun(HapiApiSpec spec) { <line1> double _targetTps = targetTps.getAsDouble(); <line2> long _testDuration = testDuration.getAsLong(); <line3> TimeUnit _ofUnit = ofUnit.get(); <line4> int totalOps = 0; <line5> float currentTPS = 0; <line6> Stopwatch duration = createStarted(); <line7> boolean reported = false; <line8> Stopwatch statDuration = duration; <line9> int submitOps = 0; <line10> while (duration.elapsed(_ofUnit) < _testDuration) { <line11> HapiSpecOperation[] ops = opSource.get(); <line12> allRunFor(spec, ops); <line13> submitOps += ops.length; <line14> totalOps += ops.length; <line15> long elapsedMS = statDuration.elapsed(MILLISECONDS); <line16> currentTPS = submitOps / (elapsedMS * 0.001f); <line17> if (statDuration.elapsed(SECONDS) % 10 == 0) { <line18> if (!reported) { <line19> reported = true; <line20> submitOps = 0; <line21> statDuration = createStarted(); <line22> } <line23> } else { <line24> reported = false; <line25> } <line26> try { <line27> if (currentTPS > _targetTps) { <line28> long pauseMillieSeconds = (long) ((submitOps / (float) _targetTps) * 1000 - elapsedMS); <line29> Thread.sleep(Math.max(5, pauseMillieSeconds)); <line30> } <line31> } catch (InterruptedException irrelevant) { <line32> } <line33> } <line34> totalOpsAllThread.addAndGet(totalOps); <line35> } <line36> } <line37> 	<line19>, <line34>
6279	public class A { <line0> public static void close(Closeable closeable, String name, Logger log) { <line1> if (closeable != null) { <line2> try { <line3> closeable.close(); <line4> } catch (IOException e) { <line5> if (log == null) { <line6> log = LOG; <line7> } <line8> if (name != null) { <line9> } else { <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	<line9>, <line10>
6280	"public class A { <line0> public String registerBlockListener( <line1> BlockingQueue<QueuedBlockEvent> blockEventQueue, long timeout, TimeUnit timeUnit) <line2> throws InvalidArgumentException { <line3> if (shutdown) { <line4> throw new InvalidArgumentException(format(""Channel %s has been shutdown."", name)); <line5> } <line6> if (null == blockEventQueue) { <line7> throw new InvalidArgumentException(""BlockEventQueue parameter is null.""); <line8> } <line9> if (timeout < 0L) { <line10> throw new InvalidArgumentException( <line11> format(""Timeout parameter must be greater than 0 not %d"", timeout)); <line12> } <line13> if (null == timeUnit) { <line14> throw new InvalidArgumentException(""TimeUnit parameter must not be null.""); <line15> } <line16> String handle = new BL(blockEventQueue, timeout, timeUnit).getHandle(); <line17> return handle; <line18> } <line19> } <line20> "	<line17>
6281	"public class A { <line0> protected void scheduleProjectResourceUpdate(final Path resource) { <line1> final Module module = moduleService.resolveModule(resource); <line2> getExecutor() <line3> .execute( <line4> new AsyncIncrementalBuilder() { <line5> @Override <line6> public void execute( <line7> final ModuleService projectService, <line8> final BuildService buildService, <line9> final Event<IncrementalBuildResults> incrementalBuildResultsEvent, <line10> final Event<BuildResults> buildResultsEvent) { <line11> try { <line12> final BuildResults results = buildService.build(module); <line13> buildResultsEvent.fire(results); <line14> } catch (Exception e) { <line15> } <line16> } <line17>  <line18> @Override <line19> public String getDescription() { <line20> return ""Incremental Build ["" + resource.toURI() + "" (updated)]""; <line21> } <line22> }); <line23> } <line24> } <line25> "	<line12>, <line15>
6282	"public class A { <line0> @Test( <line1> groups = {""TestClusteringService""}, <line2> dependsOnMethods = {""testCreateDhcpVmFolderFailed""}) <line3> public void testCreateDhcpVmNullResult() { <line4> List<NetworkAdd> networkAdds = createNetworkAdd(); <line5> List<BaseNode> vNodes = new ArrayList<BaseNode>(); <line6> BaseNode node = new BaseNode(""test-master-0""); <line7> ClusterCreate spec = createClusterSpec(); <line8> node.setCluster(spec); <line9> VmSchema vmSchema = createVmSchema(); <line10> node.setVmSchema(vmSchema); <line11> vNodes.add(node); <line12> MockTmScheduler.setFlag(VmOperation.CREATE_FOLDER, true); <line13> MockTmScheduler.setResultIsNull(true); <line14> try { <line15> service.createVcVms(spec, vNodes, null, false, null); <line16> Assert.assertTrue(false, ""should throw exception but not.""); <line17> } catch (Exception e) { <line18> Assert.assertTrue(true, ""got expected exception.""); <line19> } <line20> } <line21> } <line22> "	<line18>
6283	public class A { <line0> @Override <line1> public CoachShuttleGatheringSolution readSolution() throws IOException { <line2> solution = new CoachShuttleGatheringSolution(); <line3> solution.setId(0L); <line4> readLocationList(); <line5> busOrStopOrHubId = 0L; <line6> readBusList(); <line7> readBusStopList(); <line8> int busListSize = solution.getCoachList().size() + solution.getShuttleList().size(); <line9> int base = solution.getStopList().size() + solution.getShuttleList().size(); <line10> BigInteger a = factorial(base + busListSize - 1); <line11> BigInteger b = factorial(busListSize - 1); <line12> BigInteger possibleSolutionSize = (a == null || b == null) ? null : a.divide(b); <line13> return solution; <line14> } <line15> } <line16> 	<line13>
6284	public class A { <line0> @Override <line1> protected ApplicationTO resolveReference(final Method method, final Object... args) <line2> throws UnresolvedReferenceException { <line3> String key = null; <line4> if (ArrayUtils.isNotEmpty(args)) { <line5> for (int i = 0; key == null && i < args.length; i++) { <line6> if (args[i] instanceof String) { <line7> key = (String) args[i]; <line8> } else if (args[i] instanceof ApplicationTO) { <line9> key = ((ApplicationTO) args[i]).getKey(); <line10> } <line11> } <line12> } <line13> if (key != null) { <line14> try { <line15> return binder.getApplicationTO(applicationDAO.find(key)); <line16> } catch (Throwable ignore) { <line17> throw new UnresolvedReferenceException(ignore); <line18> } <line19> } <line20> throw new UnresolvedReferenceException(); <line21> } <line22> } <line23> 	<line17>
6285	"public class A { <line0> @Test <line1> public void testGrantResource() throws Exception { <line2> MultiValueMap<String, String> paramsMap = new LinkedMultiValueMap<>(); <line3> paramsMap.add(""userId"", ""32""); <line4> paramsMap.add(""resourceIds"", ""5""); <line5> MvcResult mvcResult = <line6> mockMvc <line7> .perform(post(""/users/grant-file"").header(SESSION_ID, sessionId).params(paramsMap)) <line8> .andExpect(status().isOk()) <line9> .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8)) <line10> .andReturn(); <line11> Result result = <line12> JSONUtils.parseObject(mvcResult.getResponse().getContentAsString(), Result.class); <line13> Assert.assertEquals(Status.SUCCESS.getCode(), result.getCode().intValue()); <line14> } <line15> } <line16> "	<line14>
6286	public class A { <line0> public Module find(final Long id) { <line1> return moduleRepository.findOne(id); <line2> } <line3> } <line4> 	<line1>
6287	"public class A { <line0> protected File getFileInternal(@Nullable JobID jobId, BlobKey blobKey) throws IOException { <line1> checkArgument(blobKey != null, ""BLOB key cannot be null.""); <line2> final File localFile = BlobUtils.getStorageLocation(storageDir, jobId, blobKey); <line3> readWriteLock.readLock().lock(); <line4> try { <line5> if (localFile.exists()) { <line6> return localFile; <line7> } <line8> } finally { <line9> readWriteLock.readLock().unlock(); <line10> } <line11> File incomingFile = createTemporaryFilename(); <line12> try { <line13> try { <line14> if (blobView.get(jobId, blobKey, incomingFile)) { <line15> readWriteLock.writeLock().lock(); <line16> try { <line17> BlobUtils.moveTempFileToStore(incomingFile, jobId, blobKey, localFile, log, null); <line18> } finally { <line19> readWriteLock.writeLock().unlock(); <line20> } <line21> return localFile; <line22> } <line23> } catch (Exception e) { <line24> } <line25> final InetSocketAddress currentServerAddress = serverAddress; <line26> if (currentServerAddress != null) { <line27> BlobClient.downloadFromBlobServer( <line28> jobId, blobKey, incomingFile, currentServerAddress, blobClientConfig, numFetchRetries); <line29> readWriteLock.writeLock().lock(); <line30> try { <line31> BlobUtils.moveTempFileToStore(incomingFile, jobId, blobKey, localFile, log, null); <line32> } finally { <line33> readWriteLock.writeLock().unlock(); <line34> } <line35> } else { <line36> throw new IOException( <line37> ""Cannot download from BlobServer, because the server address is unknown.""); <line38> } <line39> return localFile; <line40> } finally { <line41> if (!incomingFile.delete() && incomingFile.exists()) { <line42> } <line43> } <line44> } <line45> } <line46> "	<line24>, <line42>
6288	public class A { <line0> private void loadTimelinesFromTableProperties( <line1> UpdatePeriod updatePeriod, String storageTableName, String timeLineKey) <line2> throws HiveException, LensException { <line3> for (String partCol : getTimePartColNamesOfTable(storageTableName)) { <line4> ensureEntry(timeLineKey, storageTableName, updatePeriod, partCol) <line5> .init(getTable(storageTableName)); <line6> } <line7> } <line8> } <line9> 	<line3>
6289	public class A { <line0> protected Function<InternalEvent, InternalEvent> doAfter( <line1> SourceInterceptor interceptor, Component component, Optional<Throwable> thrown) { <line2> return event -> { <line3> final InternalEvent eventWithResolvedParams = removeResolvedParameters(event); <line4> DefaultInterceptionEvent interceptionEvent = <line5> new DefaultInterceptionEvent(eventWithResolvedParams); <line6> try { <line7> Thread currentThread = currentThread(); <line8> ClassLoader originalTCCL = currentThread.getContextClassLoader(); <line9> ClassLoader ctxClassLoader = interceptor.getClass().getClassLoader(); <line10> setContextClassLoader(currentThread, originalTCCL, ctxClassLoader); <line11> try { <line12> interceptor.afterCallback(component.getLocation(), interceptionEvent, thrown); <line13> } finally { <line14> setContextClassLoader(currentThread, ctxClassLoader, originalTCCL); <line15> } <line16> return interceptionEvent.resolve(); <line17> } catch (Exception e) { <line18> throw propagate( <line19> resolveMessagingException( <line20> interceptionEvent.resolve(), e.getCause(), component, empty())); <line21> } <line22> }; <line23> } <line24> } <line25> 	<line6>
6290	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Thread.sleep(initialSleep); <line4> } catch (InterruptedException e) { <line5> } <line6> } <line7> } <line8> 	<line5>
6291	"public class A { <line0> private static void notifySystemListenersOfStartup(final IPentahoSession session) <line1> throws PentahoSystemException { <line2> if (listeners != null && listeners.size() > 0) { <line3> for (final IPentahoSystemListener systemListener : listeners) { <line4> try { <line5> runAsSystem( <line6> new Callable<Void>() { <line7> @Override <line8> public Void call() throws Exception { <line9> PentahoSystem.systemEntryPoint(); <line10> try { <line11> if (debug) { <line12> } <line13> if (!systemListener.startup(session)) { <line14> throw new PentahoSystemException( <line15> Messages.getInstance() <line16> .getErrorString( <line17> ""PentahoSystem.ERROR_0014_STARTUP_FAILURE"", <line18> systemListener.getClass().getName())); <line19> } <line20> if (debug) { <line21> } <line22> } catch (Throwable e) { <line23> throw new PentahoSystemException( <line24> Messages.getInstance() <line25> .getErrorString( <line26> ""PentahoSystem.ERROR_0014_STARTUP_FAILURE"", <line27> systemListener.getClass().getName()), <line28> e); <line29> } finally { <line30> PentahoSystem.systemExitPoint(); <line31> } <line32> return null; <line33> } <line34> }); <line35> } catch (Exception e) { <line36> if (e instanceof PentahoSystemException) { <line37> throw (PentahoSystemException) e; <line38> } else { <line39> throw new PentahoSystemException(e); <line40> } <line41> } <line42> } <line43> } <line44> } <line45> } <line46> "	<line12>, <line21>
6292	public class A { <line0> public String safeGetJCRPath(Path path) { <line1> try { <line2> return context.getJCRPath(path); <line3> } catch (NamespaceException e) { <line4> return path.toString(); <line5> } <line6> } <line7> } <line8> 	<line4>
6293	"public class A { <line0> static void addRegistrationDateColumn(Statement st, String tableName, Columns col) <line1> throws SQLException { <line2> st.executeUpdate( <line3> ""ALTER TABLE "" <line4> + tableName <line5> + "" ADD COLUMN "" <line6> + col.REGISTRATION_DATE <line7> + "" BIGINT NOT NULL DEFAULT 0;""); <line8> long currentTimestamp = System.currentTimeMillis(); <line9> int updatedRows = <line10> st.executeUpdate( <line11> String.format( <line12> ""UPDATE %s SET %s = %d;"", tableName, col.REGISTRATION_DATE, currentTimestamp)); <line13> } <line14> } <line15> "	<line13>
6294	"public class A { <line0> @Nullable <line1> private static BitfinexWebSocketAuthBalance createBalanceObject(JsonNode balance) { <line2> if (balance.size() < 5) { <line3> return null; <line4> } <line5> String walletType = balance.get(0).textValue(); <line6> String currency = balance.get(1).textValue(); <line7> BigDecimal balanceValue = balance.get(2).decimalValue(); <line8> BigDecimal unsettledInterest = balance.get(3).decimalValue(); <line9> BigDecimal balanceAvailable = <line10> balance.get(4).asText().equals(""null"") ? null : balance.get(4).decimalValue(); <line11> return new BitfinexWebSocketAuthBalance( <line12> walletType, currency, balanceValue, unsettledInterest, balanceAvailable); <line13> } <line14> } <line15> "	<line3>
6295	"public class A { <line0> public String fetchDataViewerFormats() throws JSONException { <line1> String connURL; <line2> if (dataViewerUrl.endsWith(""/"")) { <line3> connURL = dataViewerUrl + ""api/explain/formats""; <line4> } else { <line5> connURL = dataViewerUrl + ""/api/explain/formats""; <line6> } <line7> DefaultHttpClient httpclient = new DefaultHttpClient(); <line8> HttpGet httpget = new HttpGet(connURL); <line9> HttpResponse resp; <line10> String str = """"; <line11> try { <line12> resp = httpclient.execute(httpget); <line13> if (200 == resp.getStatusLine().getStatusCode()) { <line14> HttpEntity entity = resp.getEntity(); <line15> if (entity != null) { <line16> String retSrc = EntityUtils.toString(entity); <line17> JSONArray array = new JSONArray(retSrc); <line18> int i = 0; <line19> while (i < array.length()) { <line20> str += array.get(i) + "", ""; <line21> i++; <line22> } <line23> } <line24> } <line25> } catch (Exception e) { <line26> } <line27> setDataViewerFormatListString(str); <line28> return """"; <line29> } <line30> } <line31> "	<line26>
6296	public class A { <line0> private void registerQueries() throws IOException { <line1> try (InputStream stream = <line2> this.getClass().getResourceAsStream(TASK_ASSIGNING_QUERY_DEFINITIONS_RESOURCE)) { <line3> if (stream == null) { <line4> throw new FileNotFoundException(QUERIES_RESOURCE_NOT_FOUND); <line5> } <line6> final Marshaller marshaller = <line7> MarshallerFactory.getMarshaller(MarshallingFormat.JSON, getClass().getClassLoader()); <line8> final String queriesString = IOUtils.toString(stream, StandardCharsets.UTF_8); <line9> final QueryDefinition[] queries = <line10> marshaller.unmarshall(queriesString, QueryDefinition[].class); <line11> if (queries == null || queries.length == 0) { <line12> return; <line13> } <line14> registerQueries(queries); <line15> } <line16> } <line17> } <line18> 	<line12>
6297	"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> File directory = new File(this.dirName); <line4> if (!directory.exists()) { <line5> return; <line6> } <line7> File[] listOfFiles = directory.listFiles(new HL7A04FileFilter()); <line8> if (listOfFiles == null || listOfFiles.length == 0) { <line9> return; <line10> } <line11> String sendAddr = oscarProperties.getEmeraldHL7A04TransportAddr(); <line12> int sendPort = oscarProperties.getEmeraldHL7A04TransportPort(); <line13> Socket client = new Socket(sendAddr, sendPort); <line14> PrintStream out = new PrintStream(client.getOutputStream()); <line15> BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream())); <line16> int numErrors = 0; <line17> for (int i = 0; i < listOfFiles.length; i++) { <line18> String fName = listOfFiles[i].getName(); <line19> String message = this.readA04File(this.dirName + fName); <line20> if (message.equals("""")) continue; <line21> this.sendMessage(out, message); <line22> String messageReceived = this.getResponse(in); <line23> boolean emeraldError = (this.processResponse(listOfFiles[i], messageReceived) == false); <line24> if (emeraldError) numErrors++; <line25> File dir = new File((!emeraldError ? this.sentDir : this.failDir)); <line26> boolean moveSuccess = listOfFiles[i].renameTo(new File(dir, fName)); <line27> if (!moveSuccess) { <line28> } <line29> } <line30> in.close(); <line31> out.close(); <line32> if (!client.isClosed()) client.shutdownOutput(); <line33> if (!client.isClosed()) client.close(); <line34> else { <line35> } <line36> } catch (Exception e) { <line37> } <line38> } <line39> } <line40> "	<line5>, <line9>, <line16>, <line21>, <line28>, <line34>, <line35>, <line37>
6298	"public class A { <line0> @Override <line1> public Local find() { <line2> final NSFileManager manager = NSFileManager.defaultManager(); <line3> if (manager.respondsToSelector( <line4> Foundation.selector(""containerURLForSecurityApplicationGroupIdentifier:""))) { <line5> final NSURL group = manager.containerURLForSecurityApplicationGroupIdentifier(identifier); <line6> if (null == group) { <line7> } else { <line8> final String application = <line9> PreferencesFactory.get().getProperty(""application.datafolder.name""); <line10> final Local folder = <line11> new FinderLocal( <line12> String.format(""%s/Library/Application Support"", group.path()), application); <line13> final Local previous = new ApplicationSupportDirectoryFinder().find(); <line14> if (previous.exists() && !previous.isSymbolicLink()) { <line15> try { <line16> FileUtils.copyDirectory( <line17> new File(previous.getAbsolute()), new File(folder.getAbsolute())); <line18> try { <line19> final Trash trash = LocalTrashFactory.get(); <line20> trash.trash(previous); <line21> final Symlink symlink = LocalSymlinkFactory.get(); <line22> symlink.symlink(previous, folder.getAbsolute()); <line23> } catch (AccessDeniedException e) { <line24> } <line25> } catch (IOException e) { <line26> } <line27> } else { <line28> } <line29> return folder; <line30> } <line31> } <line32> return new ApplicationSupportDirectoryFinder().find(); <line33> } <line34> } <line35> "	<line7>, <line15>, <line18>, <line24>, <line26>, <line28>, <line32>
6299	"public class A { <line0> public static com.liferay.commerce.model.CommerceShipment getCommerceShipment( <line1> HttpPrincipal httpPrincipal, long commerceShipmentId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceShipmentServiceUtil.class, <line7> ""getCommerceShipment"", <line8> _getCommerceShipmentParameterTypes4); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceShipmentId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.model.CommerceShipment) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
6300	public class A { <line0> @Test <line1> public void testGetPaginatedGroup() { <line2> super.testGetPaginatedEntities(); <line3> } <line4> } <line5> 	<line2>
6301	"public class A { <line0> public static void trasformazioneOutputCSV( <line1> Logger log, <line2> BufferedWriter bw, <line3> String codDominio, <line4> String codTipoVersamento, <line5> String jsonEsito, <line6> String tipoTemplate, <line7> byte[] template, <line8> String headerRisposta, <line9> Dominio dominio, <line10> Applicazione applicazione, <line11> Versamento versamento, <line12> Documento documento, <line13> String esitoOperazione, <line14> String descrizioneEsitoOperazione, <line15> String tipoOperazione) <line16> throws GovPayException { <line17> String name = ""TrasformazionePendenzaJSONtoCSV""; <line18> try { <line19> Map<String, Object> dynamicMap = new HashMap<String, Object>(); <line20> TrasformazioniUtils.fillDynamicMapRispostaTracciatoCSV( <line21> log, <line22> dynamicMap, <line23> ContextThreadLocal.get(), <line24> headerRisposta, <line25> jsonEsito, <line26> codDominio, <line27> codTipoVersamento, <line28> dominio, <line29> applicazione, <line30> versamento, <line31> documento, <line32> esitoOperazione, <line33> descrizioneEsitoOperazione, <line34> tipoOperazione); <line35> TrasformazioniUtils.convertFreeMarkerTemplate(name, template, dynamicMap, bw); <line36> } catch (TrasformazioneException e) { <line37> log.error( <line38> ""Trasformazione esito caricamento pendenza JSON -> CSV tramite template freemarker"" <line39> + "" completata con errore: "" <line40> + e.getMessage(), <line41> e); <line42> throw new GovPayException(e.getMessage(), EsitoOperazione.TRASFORMAZIONE, e, e.getMessage()); <line43> } catch (UnprocessableEntityException e) { <line44> } <line45> } <line46> } <line47> "	<line17>, <line36>, <line44>
6302	"public class A { <line0> static void verifyOutput( <line1> HamaConfiguration conf, Path outputPath, double expectedResult, double delta) <line2> throws IOException { <line3> FileStatus[] listStatus = fs.listStatus(outputPath); <line4> for (FileStatus status : listStatus) { <line5> if (!status.isDir()) { <line6> SequenceFile.Reader reader = new SequenceFile.Reader(fs, status.getPath(), conf); <line7> NullWritable key = NullWritable.get(); <line8> DoubleWritable value = new DoubleWritable(); <line9> if (reader.next(key, value)) { <line10> assertEquals( <line11> ""Expected value: '"" + expectedResult + ""' != '"" + value + ""'"", <line12> expectedResult, <line13> value.get(), <line14> delta); <line15> } <line16> reader.close(); <line17> } <line18> } <line19> } <line20> } <line21> "	<line10>
6303	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private void handleFinishContainers(List<ContainerStatus> finishedContainers) { <line2> for (ContainerStatus cont : finishedContainers) { <line3> Id id = assignedContainerToIDMap.get(cont.getContainerId()); <line4> if (id == null) { <line5> } else { <line6> assignedContainerToIDMap.remove(cont.getContainerId()); <line7> idToContainerMap.remove(id); <line8> String diagnostics = StringInterner.weakIntern(cont.getDiagnostics()); <line9> if (id instanceof PSAttemptId) { <line10> context <line11> .getEventHandler() <line12> .handle(new PSAttemptDiagnosticsUpdateEvent(diagnostics, (PSAttemptId) id)); <line13> context.getEventHandler().handle(createContainerFinishedEvent(cont, (PSAttemptId) id)); <line14> } else if (id instanceof WorkerAttemptId) { <line15> context <line16> .getEventHandler() <line17> .handle(new WorkerAttemptDiagnosticsUpdateEvent((WorkerAttemptId) id, diagnostics)); <line18> context <line19> .getEventHandler() <line20> .handle(createContainerFinishedEvent(cont, (WorkerAttemptId) id)); <line21> } <line22> } <line23> } <line24> } <line25> } <line26> "	<line3>, <line5>
6304	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> sendHeartbeat(false); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	<line5>
6305	public class A { <line0> @Override <line1> public HandlerResult handle(ProcessState state, ProcessInstance process) { <line2> Secret secret = (Secret) state.getResource(); <line3> String secretValue = secret.getValue(); <line4> if (StringUtils.isNotBlank(secretValue)) { <line5> try { <line6> secretsService.delete(secret.getAccountId(), secret.getValue()); <line7> } catch (IOException e) { <line8> throw new IllegalStateException(e); <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	<line8>
6306	public class A { <line0> private void processCurrentTagAgainstDesiredTags( <line1> final IRODSTagValue currentTag, <line2> final String[] userTags, <line3> final UserAnnotatedCatalogItem irodsTagGrouping) <line4> throws JargonException { <line5> boolean isDesired = false; <line6> for (String userTag : userTags) { <line7> if (userTag.equals(currentTag.getTagData())) { <line8> isDesired = true; <line9> break; <line10> } <line11> } <line12> if (!isDesired) { <line13> irodsTaggingService.removeTagFromGivenDomain( <line14> currentTag, irodsTagGrouping.getMetadataDomain(), irodsTagGrouping.getDomainUniqueName()); <line15> } <line16> } <line17> } <line18> 	<line5>, <line13>
6307	public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> User user = twitter.updateProfileImage(image); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.updatedProfileImage(user); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6308	"public class A { <line0> public String getRemoteBssWsUrl() { <line1> String servletAddress = ""https://"" + host + "":"" + port + ""/oscm/""; <line2> if (serviceVersion != null) { <line3> servletAddress += serviceVersion + ""/""; <line4> } <line5> servletAddress += serviceName + ""/"" + servicePort.name(); <line6> String url = servletAddress + ""?wsdl""; <line7> if (ServicePort.STS.equals(servicePort)) { <line8> String tenantParam = ""&tenantID="" + tenantId; <line9> url += tenantParam; <line10> } <line11> verifyAttributes(url); <line12> return url; <line13> } <line14> } <line15> "	<line11>
6309	"public class A { <line0> String removeFromStart(String string, int numberToRemove) { <line1> int startingFrom = string.indexOf(""#EXTINF:""); <line2> for (int loop = numberToRemove; loop > 0; loop--) { <line3> startingFrom = string.indexOf(""#EXTINF:"", startingFrom + 27); <line4> if (startingFrom == -1) { <line5> return string; <line6> } <line7> } <line8> mediaSequence = mediaSequence + numberToRemove; <line9> entries = entries - numberToRemove; <line10> return string.substring(startingFrom); <line11> } <line12> } <line13> "	<line5>
6310	public class A { <line0> @Override <line1> public void removeStoreCommand( <line2> final org.locationtech.geowave.service.grpc.protobuf.RemoveStoreCommandParametersProtos <line3> request, <line4> final StreamObserver< <line5> org.locationtech.geowave.service.grpc.protobuf.GeoWaveReturnTypesProtos <line6> .StringResponseProtos> <line7> responseObserver) { <line8> final RemoveStoreCommand cmd = new RemoveStoreCommand(); <line9> final Map<FieldDescriptor, Object> m = request.getAllFields(); <line10> GeoWaveGrpcServiceCommandUtil.setGrpcToCommandFields(m, cmd); <line11> final File configFile = GeoWaveGrpcServiceOptions.geowaveConfigFile; <line12> final OperationParams params = new ManualOperationParams(); <line13> params.getContext().put(ConfigOptions.PROPERTIES_FILE_CONTEXT, configFile); <line14> cmd.prepare(params); <line15> try { <line16> final String result = cmd.computeResults(params); <line17> final StringResponseProtos resp = <line18> StringResponseProtos.newBuilder().setResponseValue(result).build(); <line19> responseObserver.onNext(resp); <line20> responseObserver.onCompleted(); <line21> } catch (final Exception e) { <line22> responseObserver.onError(e); <line23> } <line24> } <line25> } <line26> 	<line15>, <line22>
6311	"public class A { <line0> @Override <line1> public void deleteProjects(List<Project> projects) { <line2> EKBCommit commit = getEKBCommit(); <line3> preparePersistenceAccess(); <line4> for (Project project : projects) { <line5> List<Project> result = <line6> queryService.query(Project.class, QueryRequest.query(""name"", project.getName())); <line7> if (result.size() == 0) { <line8> } else { <line9> commit.addDelete(project); <line10> } <line11> deleteAllAssignmentsForProject(project); <line12> } <line13> persistService.commit(commit); <line14> revokePersistenceAccess(); <line15> } <line16> } <line17> "	<line8>
6312	"public class A { <line0> public MGsiegel findById(java.lang.Short id) { <line1> try { <line2> MGsiegel instance = (MGsiegel) getSession().get(""sernet.gs.reveng.MGsiegel"", id); <line3> return instance; <line4> } catch (RuntimeException re) { <line5> throw re; <line6> } <line7> } <line8> } <line9> "	<line1>, <line5>
6313	"public class A { <line0> private void changeInputValueForm2(int index, String keyword) throws Exception { <line1> WebElement input = getSettingWebElement(index); <line2> input.clear(); <line3> input.sendKeys(keyword); <line4> driver <line5> .findElement( <line6> By.xpath( <line7> ""//form[@id='"" <line8> + AppHtmlElements.APP_CONFIG_FORM2 <line9> + ""']"" <line10> + ""//input[@class='"" <line11> + AppHtmlElements.APP_CONFIG_FORM_BUTTON_CLASS <line12> + ""']"")) <line13> .click(); <line14> if (!getExecutionResult()) throw new Exception(); <line15> } <line16> } <line17> "	<line4>, <line14>
6314	public class A { <line0> public void reportActiveUser(String id) { <line1> if (!initialized) { <line2> return; <line3> } <line4> if (StringUtils.isBlank(id)) { <line5> return; <line6> } <line7> try { <line8> setupCurrentEntry(); <line9> hll.addRaw(id.hashCode()); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	<line11>
6315	public class A { <line0> private static int extractErrorIndex(final String message) { <line1> if (message != null) { <line2> final Matcher matcher = INDEX_EXTRACTION_PATTERN.matcher(message); <line3> if (matcher.find()) { <line4> try { <line5> return Integer.parseInt(matcher.group(1)); <line6> } catch (NumberFormatException ex) { <line7> } <line8> } <line9> } <line10> return -1; <line11> } <line12> } <line13> 	<line7>
6316	"public class A { <line0> @Test <line1> public void testLanguageJsonSchema() throws Exception { <line2> CamelContext context = new DefaultCamelContext(); <line3> String json = context.getLanguageParameterJsonSchema(""groovy""); <line4> assertNotNull(""Should have found some auto-generated JSON"", json); <line5> assertTrue(json.contains(""\""name\"": \""groovy\"""")); <line6> assertTrue(json.contains(""\""modelName\"": \""groovy\"""")); <line7> } <line8> } <line9> "	<line5>
6317	"public class A { <line0> private Map<String, Object> getFeatureOfInterestChanges() { <line1> try { <line2> Map<String, Object> changes = new HashMap<>(); <line3> changes.put(""encodingType"", ""SQUARE""); <line4> changes.put( <line5> ""feature"", new JSONObject(""{ \""type\"": \""Point\"", \""coordinates\"": [-114.05, 51.05] }"")); <line6> changes.put(""name"", ""POIUYTREW""); <line7> changes.put(""description"", ""POIUYTREW""); <line8> return changes; <line9> } catch (JSONException ex) { <line10> Assert.fail(""Generating FeatureOfInterest changes failed: "" + ex.getMessage()); <line11> } <line12> throw new IllegalStateException(); <line13> } <line14> } <line15> "	<line10>
6318	"public class A { <line0> public static int getGroupArticlesCount( <line1> HttpPrincipal httpPrincipal, long groupId, long userId, long rootFolderId, int status) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> JournalArticleServiceUtil.class, <line7> ""getGroupArticlesCount"", <line8> _getGroupArticlesCountParameterTypes43); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, groupId, userId, rootFolderId, status); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return ((Integer) returnObj).intValue(); <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line22>
6319	public class A { <line0> public static boolean executeProgram( <line1> CommandLine commandLine, <line2> String workingDirectory, <line3> boolean executeInBackground, <line4> int successExitValue, <line5> OutputStream outputStream) { <line6> long printJobTimeout = PRINT_JOB_TIMEOUT; <line7> ExecuteStreamHandler streamHandler = null; <line8> if (outputStream != null) { <line9> streamHandler = new PumpStreamHandler(outputStream); <line10> } <line11> PrintResultHandler printResult = null; <line12> try { <line13> printResult = <line14> executeProgram( <line15> commandLine, <line16> workingDirectory, <line17> printJobTimeout, <line18> executeInBackground, <line19> successExitValue, <line20> streamHandler); <line21> } catch (Exception ex) { <line22> ex.printStackTrace(); <line23> return false; <line24> } <line25> try { <line26> if (printResult == null) { <line27> return false; <line28> } <line29> printResult.waitFor(); <line30> } catch (InterruptedException ex) { <line31> } <line32> return true; <line33> } <line34> } <line35> 	<line13>, <line21>, <line22>, <line25>, <line31>, <line32>
6320	public class A { <line0> @Override <line1> protected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) { <line2> if (transaction.isTransactional()) { <line3> FlinkKafkaInternalProducer<byte[], byte[]> producer = null; <line4> try { <line5> producer = initTransactionalProducer(transaction.transactionalId, false); <line6> producer.resumeTransaction(transaction.producerId, transaction.epoch); <line7> producer.commitTransaction(); <line8> } catch (InvalidTxnStateException | ProducerFencedException ex) { <line9> } finally { <line10> if (producer != null) { <line11> producer.close(0, TimeUnit.SECONDS); <line12> } <line13> } <line14> } <line15> } <line16> } <line17> 	<line9>
6321	public class A { <line0> @Override <line1> public boolean distinguishRole(@Nonnull PsiElementRole role) { <line2> switch (role) { <line3> case VARIABLE_NAME: <line4> return DISTINGUISH_VARIABLES; <line5> case FIELD_NAME: <line6> return DISTINGUISH_VARIABLES; <line7> case FUNCTION_NAME: <line8> return DISTINGUISH_FUNCTIONS; <line9> default: <line10> return true; <line11> } <line12> } <line13> } <line14> 	<line10>
6322	"public class A { <line0> public void setLevel2CacheLocation(String locationExpr) { <line1> if (null != locationExpr) { <line2> String location = propertyReplace(locationExpr); <line3> File dir = new File(location); <line4> if (!dir.isDirectory()) { <line5> if (dir.exists()) { <line6> throw new RuntimeException( <line7> ""Invalid location for setLevel2CacheLocation, "" <line8> + location <line9> + "" has to be a directory.""); <line10> } else { <line11> if (!dir.mkdirs()) { <line12> } <line13> } <line14> } <line15> this.location = location; <line16> } <line17> } <line18> } <line19> "	<line6>, <line12>
6323	public class A { <line0> @Override <line1> public void onComplete(HeartBeatResponse resp) { <line2> long followerTerm = resp.getTerm(); <line3> if (followerTerm == RESPONSE_AGREE) { <line4> handleNormalHeartbeatResponse(resp); <line5> } else { <line6> synchronized (localMember.getTerm()) { <line7> long currTerm = localMember.getTerm().get(); <line8> if (currTerm < followerTerm) { <line9> localMember.stepDown(followerTerm, false); <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	<line2>, <line9>
6324	"public class A { <line0> @AdapterDelegationEvent( <line1> beforeBuilder = PRPAIN201305UV02EventDescriptionBuilder.class, <line2> afterReturningBuilder = PRPAIN201306UV02EventDescriptionBuilder.class, <line3> serviceType = ""Patient Discovery"", <line4> version = ""LEVEL_a0"") <line5> @Override <line6> public PRPAIN201306UV02 respondingGatewayPRPAIN201305UV02( <line7> PRPAIN201305UV02 body, AssertionType assertion) { <line8> return new PRPAIN201306UV02(); <line9> } <line10> } <line11> "	<line8>
6325	"public class A { <line0> @Override <line1> public void execute() { <line2> if (env.supports(""feature.newsletter"")) { <line3> ScrollableResults results = users.moderators(); <line4> newsMailer.sendTo(results, true); <line5> result.notFound(); <line6> } <line7> } <line8> } <line9> "	<line2>, <line3>
6326	"public class A { <line0> @Override <line1> public final void exchangeVertexPartitions( <line2> Collection<? extends PartitionOwner> masterSetPartitionOwners) { <line3> PartitionExchange partitionExchange = <line4> workerGraphPartitioner.updatePartitionOwners(getWorkerInfo(), masterSetPartitionOwners); <line5> workerClient.openConnections(); <line6> Map<WorkerInfo, List<Integer>> sendWorkerPartitionMap = <line7> partitionExchange.getSendWorkerPartitionMap(); <line8> if (!getPartitionStore().isEmpty()) { <line9> sendWorkerPartitions(sendWorkerPartitionMap); <line10> } <line11> Set<WorkerInfo> myDependencyWorkerSet = partitionExchange.getMyDependencyWorkerSet(); <line12> Set<String> workerIdSet = new HashSet<String>(); <line13> for (WorkerInfo tmpWorkerInfo : myDependencyWorkerSet) { <line14> if (!workerIdSet.add(tmpWorkerInfo.getHostnameId())) { <line15> throw new IllegalStateException( <line16> ""exchangeVertexPartitions: Duplicate entry "" + tmpWorkerInfo); <line17> } <line18> } <line19> if (myDependencyWorkerSet.isEmpty() && getPartitionStore().isEmpty()) { <line20> if (LOG.isInfoEnabled()) { <line21> } <line22> return; <line23> } <line24> String vertexExchangePath = getPartitionExchangePath(getApplicationAttempt(), getSuperstep()); <line25> List<String> workerDoneList; <line26> try { <line27> while (true) { <line28> workerDoneList = getZkExt().getChildrenExt(vertexExchangePath, true, false, false); <line29> workerIdSet.removeAll(workerDoneList); <line30> if (workerIdSet.isEmpty()) { <line31> break; <line32> } <line33> if (LOG.isInfoEnabled()) { <line34> } <line35> getPartitionExchangeChildrenChangedEvent() <line36> .waitForTimeoutOrFail( <line37> GiraphConstants.WAIT_FOR_OTHER_WORKERS_TIMEOUT_MSEC.get(getConfiguration())); <line38> getPartitionExchangeChildrenChangedEvent().reset(); <line39> } <line40> } catch (KeeperException | InterruptedException e) { <line41> throw new RuntimeException(""exchangeVertexPartitions: Got runtime exception"", e); <line42> } <line43> if (LOG.isInfoEnabled()) { <line44> } <line45> } <line46> } <line47> "	<line21>, <line34>, <line44>
6327	"public class A { <line0> @Test <line1> public void testTimePositionSubset() { <line2> String xml = <line3> ""<wfs:GetFeature "" <line4> + ""service=\""WFS\"" "" <line5> + ""version=\""1.1.0\"" "" <line6> + ""outputFormat=\""gml32\"" "" <line7> + ""xmlns:cdf=\""http://www.opengis.net/cite/data\"" "" <line8> + ""xmlns:ogc=\""http://www.opengis.net/ogc\"" "" <line9> + ""xmlns:wfs=\""http://www.opengis.net/wfs\"" "" <line10> + ""xmlns:gml=\""http://www.opengis.net/gml/3.2\"" "" <line11> + ""xmlns:csml=\"""" <line12> + TimeSeriesMockData.CSML_URI <line13> + ""\"" xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"" "" <line14> + ""xsi:schemaLocation=\""http://www.opengis.net/wfs"" <line15> + "" http://schemas.opengis.net/wfs/1.1.0/wfs.xsd\""><wfs:Query"" <line16> + "" typeName=\""csml:PointSeriesFeature\"">    <ogc:Filter>       "" <line17> + "" <ogc:PropertyIsBetween>            "" <line18> + "" <ogc:PropertyName>csml:PointSeriesFeature/csml:value/csml:PointSeriesCoverage/csml:pointSeriesDomain/csml:TimeSeries/csml:timePositionList</ogc:PropertyName>"" <line19> + ""            "" <line20> + "" <ogc:LowerBoundary><ogc:Literal>1949-05-01</ogc:Literal></ogc:LowerBoundary>       "" <line21> + ""      <ogc:UpperBoundary><ogc:Literal>1949-09-01</ogc:Literal></ogc:UpperBoundary>  "" <line22> + ""      </ogc:PropertyIsBetween>    </ogc:Filter></wfs:Query> </wfs:GetFeature>""; <line23> validate(xml); <line24> Document doc = postAsDOM(""wfs"", xml); <line25> assertEquals(""wfs:FeatureCollection"", doc.getDocumentElement().getNodeName()); <line26> assertXpathEvaluatesTo(""1"", ""/wfs:FeatureCollection/@numberReturned"", doc); <line27> assertXpathCount(1, ""//csml:PointSeriesFeature"", doc); <line28> checkPointFeatureTwo(doc); <line29> assertXpathEvaluatesTo( <line30> ""1949-05-01 1949-06-01 1949-07-01 1949-08-01 1949-09-01"", <line31> ""//csml:PointSeriesFeature[@gml:id='ID2"" <line32> + ""']/csml:value/csml:PointSeriesCoverage/csml:pointSeriesDomain/csml:TimeSeries/csml:timePositionList"", <line33> doc); <line34> assertXpathEvaluatesTo( <line35> ""16.2 17.1 22.0 25.1 23.9"", <line36> ""//csml:PointSeriesFeature[@gml:id='ID2"" <line37> + ""']/csml:value/csml:PointSeriesCoverage/gml:rangeSet/gml:ValueArray/gml:valueComponent/gml:QuantityList"", <line38> doc); <line39> } <line40> } <line41> "	<line25>
6328	public class A { <line0> @Override <line1> public HtmlPreviewEntry fetchByG_C_C( <line2> long groupId, long classNameId, long classPK, boolean useFinderCache) { <line3> Object[] finderArgs = null; <line4> if (useFinderCache) { <line5> finderArgs = new Object[] {groupId, classNameId, classPK}; <line6> } <line7> Object result = null; <line8> if (useFinderCache) { <line9> result = finderCache.getResult(_finderPathFetchByG_C_C, finderArgs); <line10> } <line11> if (result instanceof HtmlPreviewEntry) { <line12> HtmlPreviewEntry htmlPreviewEntry = (HtmlPreviewEntry) result; <line13> if ((groupId != htmlPreviewEntry.getGroupId()) <line14> || (classNameId != htmlPreviewEntry.getClassNameId()) <line15> || (classPK != htmlPreviewEntry.getClassPK())) { <line16> result = null; <line17> } <line18> } <line19> if (result == null) { <line20> StringBundler sb = new StringBundler(5); <line21> sb.append(_SQL_SELECT_HTMLPREVIEWENTRY_WHERE); <line22> sb.append(_FINDER_COLUMN_G_C_C_GROUPID_2); <line23> sb.append(_FINDER_COLUMN_G_C_C_CLASSNAMEID_2); <line24> sb.append(_FINDER_COLUMN_G_C_C_CLASSPK_2); <line25> String sql = sb.toString(); <line26> Session session = null; <line27> try { <line28> session = openSession(); <line29> Query query = session.createQuery(sql); <line30> QueryPos queryPos = QueryPos.getInstance(query); <line31> queryPos.add(groupId); <line32> queryPos.add(classNameId); <line33> queryPos.add(classPK); <line34> List<HtmlPreviewEntry> list = query.list(); <line35> if (list.isEmpty()) { <line36> if (useFinderCache) { <line37> finderCache.putResult(_finderPathFetchByG_C_C, finderArgs, list); <line38> } <line39> } else { <line40> if (list.size() > 1) { <line41> Collections.sort(list, Collections.reverseOrder()); <line42> if (_log.isWarnEnabled()) { <line43> if (!useFinderCache) { <line44> finderArgs = new Object[] {groupId, classNameId, classPK}; <line45> } <line46> } <line47> } <line48> HtmlPreviewEntry htmlPreviewEntry = list.get(0); <line49> result = htmlPreviewEntry; <line50> cacheResult(htmlPreviewEntry); <line51> } <line52> } catch (Exception exception) { <line53> throw processException(exception); <line54> } finally { <line55> closeSession(session); <line56> } <line57> } <line58> if (result instanceof List<?>) { <line59> return null; <line60> } else { <line61> return (HtmlPreviewEntry) result; <line62> } <line63> } <line64> } <line65> 	<line46>
6329	public class A { <line0> @Override <line1> public void run() { <line2> List<ActiveQuerySnapshot> activeQueryList = new ArrayList<>(); <line3> cacheLock.readLock().lock(); <line4> try { <line5> for (ActiveQuery q : ActiveQueryLog.this.CACHE.asMap().values()) { <line6> activeQueryList.add(q.snapshot()); <line7> } <line8> } finally { <line9> cacheLock.readLock().unlock(); <line10> } <line11> activeQueryList.sort(ActiveQuerySnapshot.greatestElapsedTime); <line12> List<ActiveQuerySnapshot> sublist = activeQueryList; <line13> if (ActiveQueryLog.this.logMaxQueries > 0) { <line14> sublist = <line15> activeQueryList.subList( <line16> 0, Math.min(ActiveQueryLog.this.logMaxQueries, activeQueryList.size())); <line17> } <line18> if (sublist.size() > 0) { <line19> ActiveQueryLog.this.touch(); <line20> } <line21> for (ActiveQuerySnapshot q : sublist) { <line22> } <line23> } <line24> } <line25> 	<line22>
6330	public class A { <line0> @Override <line1> public AsyncExecutionState execute(ProcessContext context) { <line2> CloudApplication application = context.getVariable(Variables.APP_TO_PROCESS); <line3> CloudControllerClient client = context.getControllerClient(); <line4> CloudPackage cloudPackage = context.getVariable(Variables.CLOUD_PACKAGE); <line5> Upload upload = getUploadStatus(client, cloudPackage.getGuid(), application.getName()); <line6> switch (upload.getStatus()) { <line7> case FAILED: <line8> case EXPIRED: <line9> ErrorDetails errorDetails = upload.getErrorDetails(); <line10> context <line11> .getStepLogger() <line12> return AsyncExecutionState.ERROR; <line13> case READY: <line14> return AsyncExecutionState.FINISHED; <line15> case PROCESSING_UPLOAD: <line16> case COPYING: <line17> case AWAITING_UPLOAD: <line18> return AsyncExecutionState.RUNNING; <line19> default: <line20> throw new IllegalStateException(format(Messages.UNKNOWN_UPLOAD_STATUS, upload.getStatus())); <line21> } <line22> } <line23> } <line24> 	<line3>, <line6>, <line12>, <line14>
6331	public class A { <line0> public boolean cancel(final AccountDTO accountDTO) { <line1> return accountMapper.cancel(accountDTO) > 0; <line2> } <line3> } <line4> 	<line1>
6332	public class A { <line0> void put(String uuid, CachingIndexReader reader, int n) { <line1> LRUMap cacheSegment = docNumbers[getSegmentIndex(uuid.charAt(0))]; <line2> synchronized (cacheSegment) { <line3> Entry e = (Entry) cacheSegment.get(uuid); <line4> if (e != null) { <line5> if (reader.getCreationTick() <= e.creationTick) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> e = null; <line9> } <line10> } else { <line11> e = new Entry(reader.getCreationTick(), n); <line12> } <line13> if (e != null) { <line14> cacheSegment.put(uuid, e); <line15> } <line16> } <line17> } <line18> } <line19> 	<line7>
6333	"public class A { <line0> public void publish(Release release) { <line1> ServiceRegistration<Release> oldServiceRegistration = <line2> _serviceConfiguratorRegistrations.get(release.getServletContextName()); <line3> if (oldServiceRegistration != null) { <line4> oldServiceRegistration.unregister(); <line5> } <line6> Dictionary<String, Object> properties = new Hashtable<>(); <line7> properties.put(""release.bundle.symbolic.name"", release.getBundleSymbolicName()); <line8> properties.put(""release.state"", release.getState()); <line9> try { <line10> if (Validator.isNotNull(release.getSchemaVersion())) { <line11> Version version = new Version(release.getSchemaVersion()); <line12> properties.put(""release.schema.version"", version); <line13> } <line14> } catch (IllegalArgumentException illegalArgumentException) { <line15> if (_log.isWarnEnabled()) { <line16> } <line17> } <line18> ServiceRegistration<Release> newServiceRegistration = <line19> _bundleContext.registerService(Release.class, release, properties); <line20> _serviceConfiguratorRegistrations.put(release.getServletContextName(), newServiceRegistration); <line21> } <line22> } <line23> "	<line16>
6334	"public class A { <line0> public String getProcessInstanceVariable( <line1> String containerId, Number processInstanceId, String varName, String marshallingType) { <line2> containerId = <line3> context.getContainerId( <line4> containerId, new ByProcessInstanceIdContainerLocator(processInstanceId.longValue())); <line5> Object variable = <line6> processService.getProcessInstanceVariable( <line7> containerId, processInstanceId.longValue(), varName); <line8> if (variable == null) { <line9> throw new IllegalStateException( <line10> ""Unable to find variable '"" <line11> + varName <line12> + ""' within process instance with id "" <line13> + processInstanceId); <line14> } <line15> String response = marshallerHelper.marshal(containerId, marshallingType, variable); <line16> return response; <line17> } <line18> } <line19> "	<line15>
6335	public class A { <line0> @PostMapping <line1> public ContextDto create(@Valid @RequestBody ContextDto contextDto) { <line2> final VitamContext vitamContext = <line3> securityService.buildVitamContext(securityService.getTenantIdentifier()); <line4> return contextInternalService.create(vitamContext, contextDto); <line5> } <line6> } <line7> 	<line2>
6336	"public class A { <line0> @Path(""device/{deviceId}/change-status"") <line1> @POST <line2> @Feature( <line3> code = ""change-status"", <line4> name = ""Change status of sensor: on/off"", <line5> description = ""Change status of sensor: on/off"") <line6> public Response changeStatus( <line7> @PathParam(""deviceId"") String deviceId, <line8> @QueryParam(""state"") String state, <line9> @Context HttpServletResponse response) { <line10> try { <line11> if (!APIUtil.getDeviceAccessAuthorizationService() <line12> .isUserAuthorized(new DeviceIdentifier(deviceId, DeviceTypeConstants.DEVICE_TYPE))) { <line13> return Response.status(Response.Status.UNAUTHORIZED.getStatusCode()).build(); <line14> } <line15> String sensorState = state.toUpperCase(); <line16> if (!sensorState.equals(DeviceTypeConstants.STATE_ON) <line17> && !sensorState.equals(DeviceTypeConstants.STATE_OFF)) { <line18> return Response.status(Response.Status.BAD_REQUEST.getStatusCode()).build(); <line19> } <line20> Map<String, String> dynamicProperties = new HashMap<>(); <line21> String publishTopic = <line22> APIUtil.getAuthenticatedUserTenantDomain() <line23> + ""/"" <line24> + DeviceTypeConstants.DEVICE_TYPE <line25> + ""/"" <line26> + deviceId <line27> + ""/command""; <line28> dynamicProperties.put(DeviceTypeConstants.ADAPTER_TOPIC_PROPERTY, publishTopic); <line29> APIUtil.getOutputEventAdapterService() <line30> .publish(DeviceTypeConstants.MQTT_ADAPTER_NAME, dynamicProperties, state); <line31> return Response.ok().build(); <line32> } catch (DeviceAccessAuthorizationException e) { <line33> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build(); <line34> } <line35> } <line36> } <line37> "	<line18>, <line33>
6337	"public class A { <line0> private static SecretKey getRootKey() throws KeyManagementException { <line1> try { <line2> String rootKeyHex = CryptoUtils.extractKeyFromBootstrapFile(); <line3> return new SecretKeySpec(Hex.decodeHex(rootKeyHex.toCharArray()), ""AES""); <line4> } catch (IOException | DecoderException e) { <line5> throw new KeyManagementException(e); <line6> } <line7> } <line8> } <line9> "	<line5>
6338	public class A { <line0> public void start() { <line1> if (!running.compareAndSet(false, true)) { <line2> return; <line3> } <line4> try { <line5> this.mongoClient = replicaSetsContext.createMongoClient(replicaSetConfig); <line6> this.checkReplicaMongo(); <line7> executorService.submit( <line8> new ReplicatorTask(this, mongoClient, replicaSetConfig, replicaSetsContext)); <line9> } catch (Exception e) { <line10> shutdown(); <line11> } <line12> } <line13> } <line14> 	<line2>, <line10>
6339	public class A { <line0> public Map<Integer, ImageResourceDimension> getDimensions() { <line1> Map<Integer, ImageResourceDimension> dimensions = <line2> new HashMap<Integer, ImageResourceDimension>(); <line3> List<Element> dimensionElements = _doc.getRootElement().getChildren(TAB_DIMENSION); <line4> if (null != dimensionElements && dimensionElements.size() > 0) { <line5> Iterator<Element> dimensionElementsIter = dimensionElements.iterator(); <line6> while (dimensionElementsIter.hasNext()) { <line7> Element currentElement = (Element) dimensionElementsIter.next(); <line8> ImageResourceDimension dimension = new ImageResourceDimension(); <line9> Element idElement = currentElement.getChild(TAB_ID); <line10> if (null != idElement) { <line11> String id = idElement.getText(); <line12> dimension.setIdDim(Integer.parseInt(id)); <line13> } <line14> Element dimxElement = currentElement.getChild(TAB_DIMX); <line15> if (null != dimxElement) { <line16> String dimx = dimxElement.getText(); <line17> dimension.setDimx(Integer.parseInt(dimx)); <line18> } <line19> Element dimyElement = currentElement.getChild(TAB_DIMY); <line20> if (null != dimyElement) { <line21> String dimy = dimyElement.getText(); <line22> dimension.setDimy(Integer.parseInt(dimy)); <line23> } <line24> dimensions.put(new Integer(dimension.getIdDim()), dimension); <line25> } <line26> } <line27> return dimensions; <line28> } <line29> } <line30> 	<line25>
6340	public class A { <line0> protected void doStartScheduler() throws Exception { <line1> if (scheduler == null) { <line2> createAndInitScheduler(); <line3> } else { <line4> storeCamelContextInQuartzContext(); <line5> } <line6> for (SchedulerInitTask task : schedulerInitTasks) { <line7> task.initializeTask(scheduler); <line8> } <line9> schedulerInitTasks.clear(); <line10> schedulerInitTasksDone = true; <line11> if (!autoStartScheduler) { <line12> } else { <line13> if (startDelayedSeconds > 0) { <line14> if (scheduler.isStarted()) { <line15> } else { <line16> scheduler.startDelayed(startDelayedSeconds); <line17> } <line18> } else { <line19> if (scheduler.isStarted()) { <line20> } else { <line21> scheduler.start(); <line22> } <line23> } <line24> } <line25> } <line26> } <line27> 	<line12>, <line15>, <line16>, <line20>, <line21>
6341	"public class A { <line0> public void run() { <line1> try { <line2> while (!shutdown) { <line3> env.sendEventBean(new SupportBean_S1(0, null)); <line4> Object value = listener.assertOneGetNewAndReset().get(""c0""); <line5> if (value == null) { <line6> throw new IllegalStateException(""Value is null""); <line7> } <line8> numQueries++; <line9> } <line10> } catch (RuntimeException ex) { <line11> exception = ex; <line12> } <line13> } <line14> } <line15> "	<line1>, <line11>, <line13>
6342	"public class A { <line0> @Override <line1> public Response getLatestBundle() { <line2> Bundle latestBundle = getLatestBundleAsBundle(); <line3> if (latestBundle != null) { <line4> try { <line5> JSONObject response = new JSONObject(); <line6> response.put(""id"", latestBundle.getId()); <line7> response.put(""dataset"", latestBundle.getDataset()); <line8> response.put(""name"", latestBundle.getName()); <line9> return Response.ok(response.toString()).build(); <line10> } catch (Exception e) { <line11> } <line12> } <line13> return Response.ok(""Error: No bundles deployed."").build(); <line14> } <line15> } <line16> "	<line2>, <line11>
6343	"public class A { <line0> @Override <line1> public synchronized void open() throws KaleidescapeException { <line2> try { <line3> SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName); <line4> if (portIdentifier == null) { <line5> setConnected(false); <line6> throw new KaleidescapeException(""Opening serial connection failed: No Such Port""); <line7> } <line8> SerialPort commPort = portIdentifier.open(this.getClass().getName(), 2000); <line9> commPort.setSerialPortParams( <line10> 19200, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE); <line11> commPort.enableReceiveThreshold(1); <line12> commPort.enableReceiveTimeout(100); <line13> commPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE); <line14> InputStream dataIn = commPort.getInputStream(); <line15> OutputStream dataOut = commPort.getOutputStream(); <line16> if (dataOut != null) { <line17> dataOut.flush(); <line18> } <line19> if (dataIn != null && dataIn.markSupported()) { <line20> try { <line21> dataIn.reset(); <line22> } catch (IOException e) { <line23> } <line24> } <line25> Thread thread = new KaleidescapeReaderThread(this, this.uid, this.serialPortName); <line26> setReaderThread(thread); <line27> thread.start(); <line28> this.serialPort = commPort; <line29> this.dataIn = dataIn; <line30> this.dataOut = dataOut; <line31> setConnected(true); <line32> } catch (PortInUseException e) { <line33> setConnected(false); <line34> throw new KaleidescapeException(""Opening serial connection failed: Port in Use Exception"", e); <line35> } catch (UnsupportedCommOperationException e) { <line36> setConnected(false); <line37> throw new KaleidescapeException( <line38> ""Opening serial connection failed: Unsupported Comm Operation Exception"", e); <line39> } catch (UnsupportedEncodingException e) { <line40> setConnected(false); <line41> throw new KaleidescapeException( <line42> ""Opening serial connection failed: Unsupported Encoding Exception"", e); <line43> } catch (IOException e) { <line44> setConnected(false); <line45> throw new KaleidescapeException(""Opening serial connection failed: IO Exception"", e); <line46> } <line47> } <line48> } <line49> "	<line2>, <line23>, <line32>
6344	public class A { <line0> @VisibleForTesting <line1> void logFailure(AttachmentJobStatusResponse response) throws InternalServerErrorException { <line2> CloudStackErrorResponse errorResponse = response.getErrorResponse(); <line3> String errorText = <line4> String.format( <line5> FAILED_ATTACH_ERROR_MESSAGE, <line6> errorResponse.getErrorCode(), <line7> errorResponse.getErrorText()); <line8> } <line9> } <line10> 	<line8>
6345	public class A { <line0> public boolean isValid() { <line1> if (_startTime == null) { <line2> return false; <line3> } <line4> if ((_recurUnit == null && _recurInterval != null) <line5> || (_recurUnit != null && _recurInterval == null)) { <line6> return false; <line7> } <line8> if (_recurInterval != null && _recurInterval <= 0) { <line9> return false; <line10> } <line11> if (_recurUnit != null) { <line12> long converted = _recurUnit.toMillis(_recurInterval); <line13> if (converted < MIN_RECURRENCE_MILLIS) { <line14> return false; <line15> } <line16> } <line17> return true; <line18> } <line19> } <line20> 	<line2>, <line6>, <line9>, <line14>
6346	public class A { <line0> void startExport(DocketData docketData, OutputStream os) throws IOException { <line1> try { <line2> Document doc = createDocument(docketData, true); <line3> XMLOutputter outp = new XMLOutputter(); <line4> outp.setFormat(Format.getPrettyFormat()); <line5> outp.output(doc, os); <line6> os.close(); <line7> } catch (RuntimeException e) { <line8> throw new IOException(e); <line9> } <line10> } <line11> } <line12> 	<line8>
6347	public class A { <line0> @Override <line1> public JsonNode selectObjects(JsonNode jsonQuery) <line2> throws IllegalArgumentException, InvalidParseOperationException, <line3> AccessInternalExecutionException { <line4> JsonNode jsonNode = null; <line5> try (MetaDataClient metaDataClient = metaDataClientFactory.getClient()) { <line6> SanityChecker.checkJsonAll(jsonQuery); <line7> final RequestParserMultiple parser = RequestParserHelper.getParser(jsonQuery.deepCopy()); <line8> parser.getRequest().reset(); <line9> if (!(parser instanceof SelectParserMultiple)) { <line10> throw new InvalidParseOperationException(NOT_A_SELECT_OPERATION); <line11> } <line12> jsonNode = metaDataClient.selectObjectGroups(jsonQuery); <line13> } catch (final InvalidParseOperationException e) { <line14> throw e; <line15> } catch (final IllegalArgumentException e) { <line16> throw e; <line17> } catch (final Exception e) { <line18> throw new AccessInternalExecutionException(e); <line19> } <line20> removeFileName(jsonNode); <line21> return jsonNode; <line22> } <line23> } <line24> 	<line5>, <line7>, <line13>, <line14>, <line16>, <line18>
6348	public class A { <line0> public int read(final String context) throws IOException { <line1> int b = read(); <line2> return b; <line3> } <line4> } <line5> 	<line2>
6349	public class A { <line0> private LookupResult performReverseLookup(Object key) { <line1> final PtrDnsAnswer dnsResponse; <line2> try { <line3> dnsResponse = dnsClient.reverseLookup(key.toString()); <line4> } catch (Exception e) { <line5> errorCounter.inc(); <line6> return getErrorResult(); <line7> } <line8> if (dnsResponse != null) { <line9> if (!Strings.isNullOrEmpty(dnsResponse.fullDomain())) { <line10> final Map<Object, Object> multiValueResults = new LinkedHashMap<>(); <line11> multiValueResults.put(PtrDnsAnswer.FIELD_DOMAIN, dnsResponse.domain()); <line12> multiValueResults.put(PtrDnsAnswer.FIELD_FULL_DOMAIN, dnsResponse.fullDomain()); <line13> multiValueResults.put(PtrDnsAnswer.FIELD_DNS_TTL, dnsResponse.dnsTTL()); <line14> final LookupResult.Builder builder = <line15> LookupResult.builder() <line16> .single(dnsResponse.fullDomain()) <line17> .multiValue(multiValueResults) <line18> .stringListValue(ImmutableList.of(dnsResponse.fullDomain())); <line19> if (config.hasOverrideTTL()) { <line20> builder.cacheTTL(config.getCacheTTLOverrideMillis()); <line21> } else { <line22> builder.cacheTTL(dnsResponse.dnsTTL() * 1000); <line23> } <line24> return builder.build(); <line25> } <line26> } <line27> return getEmptyResult(); <line28> } <line29> } <line30> 	<line5>, <line27>
6350	public class A { <line0> private int getPoolSize(String plugin) { <line1> String prop = PROP_POOLSIZE + plugin; <line2> String sPoolSize = agentConfig.getProperty(prop); <line3> if (sPoolSize != null) { <line4> try { <line5> return Integer.parseInt(sPoolSize); <line6> } catch (NumberFormatException exc) { <line7> } <line8> } <line9> return 1; <line10> } <line11> } <line12> 	<line7>
6351	"public class A { <line0> @Override <line1> public void rip() throws IOException { <line2> Document doc = Http.url(url).get(); <line3> List<String> mp4s = Utils.between(doc.html(), ""file:\"""", ""\""""); <line4> if (mp4s.size() == 0) { <line5> throw new IOException(""Could not find files at "" + url); <line6> } <line7> String vidUrl = mp4s.get(0); <line8> addURLToDownload(new URL(vidUrl), HOST + ""_"" + getGID(this.url)); <line9> waitForThreads(); <line10> } <line11> } <line12> "	<line2>
6352	"public class A { <line0> @Override <line1> public ContainerBuilder<T> newCustomContainerBuilder(String template) { <line2> if (log.isTraceEnabled()) { <line3> } <line4> Container container = new ContainerImpl(template, null); <line5> @SuppressWarnings(""unchecked"") <line6> T t = (T) this; <line7> return new CustomContainerBuilderImpl<T>(container, t); <line8> } <line9> } <line10> "	<line3>
6353	public class A { <line0> @Override <line1> public void init() throws Exception { <line2> this.getCacheWrapper().initCache(this.getWidgetTypeDAO()); <line3> } <line4> } <line5> 	<line3>
6354	public class A { <line0> @UserAggregationUpdate <line1> public void logAround() { <line2> } <line3> } <line4> 	<line2>
6355	public class A { <line0> public DrillRpcFuture<Ack> cancelQuery(QueryId id) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> return client.send(RpcType.CANCEL_QUERY, id, Ack.class); <line4> } <line5> } <line6> 	<line2>
6356	"public class A { <line0> protected void initParams(final Request request) { <line1> uuid = (String) request.getAttributes().get(""uuid""); <line2> } <line3> } <line4> "	<line1>, <line2>
6357	"public class A { <line0> private void transformNode( <line1> Node node, Matrix4d inMatrix, Collection<? super AbstractGeometry> results) { <line2> Matrix4d nodeMatrix; <line3> if (node.getMatrix() == null) { <line4> nodeMatrix = null; <line5> } else { <line6> nodeMatrix = new Matrix4d(); <line7> nodeMatrix.set(node.getMatrix(), true); <line8> } <line9> Matrix4d matrix = <line10> nodeMatrix == null ? inMatrix : inMatrix == null ? nodeMatrix : inMatrix.mult(nodeMatrix); <line11> transformInstanceGeometries(node, matrix, results); <line12> for (Node child : node.getNodes()) { <line13> myUnusedTags.remove(""#"" + child.getId()); <line14> transformNode(child, matrix, results); <line15> } <line16> for (InstanceNode ref : node.getInstanceNodes()) { <line17> myUnusedTags.remove(ref.getUrl()); <line18> Node deref = myNodeLibrary.get(ref.getUrl()); <line19> if (deref == null) { <line20> } else { <line21> transformNode(deref, matrix, results); <line22> } <line23> } <line24> } <line25> } <line26> "	<line20>
6358	public class A { <line0> public ResponseEntity<ResultsDto> findObjectById(String id, ExternalHttpContext context) { <line1> return archiveSearchExternalRestClient.findObjectById(id, context); <line2> } <line3> } <line4> 	<line1>
6359	"public class A { <line0> private void initialize() { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> try { <line4> atlasPluginClassLoader = <line5> AtlasPluginClassLoader.getInstance(ATLAS_PLUGIN_TYPE, this.getClass()); <line6> @SuppressWarnings(""unchecked"") <line7> Class<ExecuteWithHookContext> cls = <line8> (Class<ExecuteWithHookContext>) <line9> Class.forName(ATLAS_HIVE_HOOK_IMPL_CLASSNAME, true, atlasPluginClassLoader); <line10> activatePluginClassLoader(); <line11> hiveHookImpl = cls.newInstance(); <line12> } catch (Exception excp) { <line13> } finally { <line14> deactivatePluginClassLoader(); <line15> } <line16> if (LOG.isDebugEnabled()) { <line17> } <line18> } <line19> } <line20> "	<line2>, <line13>, <line17>
6360	"public class A { <line0> @Override <line1> public void onValueReceived( <line2> @Nullable String variable, @Nullable String value, @Nullable String service) { <line3> if (variable == null) { <line4> return; <line5> } <line6> String oldValue = stateMap.get(variable); <line7> if ((value == null && oldValue == null) || (value != null && value.equals(oldValue))) { <line8> return; <line9> } <line10> stateMap.put(variable, (value != null) ? value : """"); <line11> for (EventListener listener : listeners) { <line12> switch (variable) { <line13> case ""CurrentVolume"": <line14> listener.valueReceived( <line15> VOLUME, (value != null) ? new PercentType(value) : UnDefType.UNDEF); <line16> break; <line17> case ""CurrentMute"": <line18> State newState = UnDefType.UNDEF; <line19> if (value != null) { <line20> newState = value.equals(""true"") ? OnOffType.ON : OnOffType.OFF; <line21> } <line22> listener.valueReceived(MUTE, newState); <line23> break; <line24> case ""CurrentBrightness"": <line25> listener.valueReceived( <line26> BRIGHTNESS, (value != null) ? new PercentType(value) : UnDefType.UNDEF); <line27> break; <line28> case ""CurrentContrast"": <line29> listener.valueReceived( <line30> CONTRAST, (value != null) ? new PercentType(value) : UnDefType.UNDEF); <line31> break; <line32> case ""CurrentSharpness"": <line33> listener.valueReceived( <line34> SHARPNESS, (value != null) ? new PercentType(value) : UnDefType.UNDEF); <line35> break; <line36> case ""CurrentColorTemperature"": <line37> listener.valueReceived( <line38> COLOR_TEMPERATURE, (value != null) ? new DecimalType(value) : UnDefType.UNDEF); <line39> break; <line40> } <line41> } <line42> } <line43> } <line44> "	<line8>
6361	public class A { <line0> public void executeMethod( <line1> Method m, Object object, Transaction transaction, Request<JsonObject> request) <line2> throws IOException { <line3> try { <line4> Response<JsonElement> response = <line5> execJavaMethod(transaction.getSession(), object, m, transaction, request); <line6> if (response != null) { <line7> response.setId(request.getId()); <line8> transaction.sendResponseObject(response); <line9> } else { <line10> transaction.sendVoidResponse(); <line11> } <line12> } catch (InvocationTargetException e) { <line13> if (e.getCause() instanceof JsonRpcErrorException) { <line14> JsonRpcErrorException ex = (JsonRpcErrorException) e.getCause(); <line15> transaction.sendError(ex.getError()); <line16> } else { <line17> transaction.sendError(e.getCause()); <line18> } <line19> } catch (Exception e) { <line20> transaction.sendError(e); <line21> } <line22> } <line23> } <line24> 	<line17>, <line20>
6362	"public class A { <line0> private void publishSegments(TaskToolbox toolbox, Map<String, PushedSegmentsReport> reportsMap) <line1> throws IOException { <line2> final Set<DataSegment> oldSegments = new HashSet<>(); <line3> final Set<DataSegment> newSegments = new HashSet<>(); <line4> reportsMap <line5> .values() <line6> .forEach( <line7> report -> { <line8> oldSegments.addAll(report.getOldSegments()); <line9> newSegments.addAll(report.getNewSegments()); <line10> }); <line11> final boolean storeCompactionState = <line12> getContextValue(Tasks.STORE_COMPACTION_STATE_KEY, Tasks.DEFAULT_STORE_COMPACTION_STATE); <line13> final Function<Set<DataSegment>, Set<DataSegment>> annotateFunction = <line14> compactionStateAnnotateFunction( <line15> storeCompactionState, <line16> toolbox, <line17> ingestionSchema.getTuningConfig(), <line18> ingestionSchema.getDataSchema().getGranularitySpec()); <line19> Set<DataSegment> segmentsFoundForDrop = null; <line20> if (ingestionSchema.getIOConfig().isDropExisting()) { <line21> segmentsFoundForDrop = <line22> getUsedSegmentsWithinInterval( <line23> toolbox, <line24> getDataSource(), <line25> ingestionSchema.getDataSchema().getGranularitySpec().inputIntervals()); <line26> } <line27> final TransactionalSegmentPublisher publisher = <line28> (segmentsToBeOverwritten, segmentsToDrop, segmentsToPublish, commitMetadata) -> <line29> toolbox <line30> .getTaskActionClient() <line31> .submit( <line32> SegmentTransactionalInsertAction.overwriteAction( <line33> segmentsToBeOverwritten, segmentsToDrop, segmentsToPublish)); <line34> final boolean published = <line35> newSegments.isEmpty() <line36> || publisher <line37> .publishSegments( <line38> oldSegments, segmentsFoundForDrop, newSegments, annotateFunction, null) <line39> .isSuccess(); <line40> if (published) { <line41> } else { <line42> throw new ISE(""Failed to publish segments""); <line43> } <line44> } <line45> } <line46> "	<line41>
6363	public class A { <line0> private boolean verifyCreatedAfter(Date invocationDate) { <line1> if (getCreated() != null && getCreated().after(invocationDate)) { <line2> return false; <line3> } else { <line4> return true; <line5> } <line6> } <line7> } <line8> 	<line2>
6364	"public class A { <line0> private synchronized AttendanceScheduleSetting createNewScheduleSetting( <line1> String unitName, String topUnitName, Boolean debugger) throws Exception { <line2> AttendanceScheduleSetting new_attendanceScheduleSetting = null; <line3> Business business = null; <line4> List<String> ids = null; <line5> try (EntityManagerContainer emc = EntityManagerContainerFactory.instance().create()) { <line6> business = new Business(emc); <line7> new_attendanceScheduleSetting = new AttendanceScheduleSetting(); <line8> new_attendanceScheduleSetting.setAbsenceStartTime(null); <line9> new_attendanceScheduleSetting.setLateStartTime(""9:05""); <line10> new_attendanceScheduleSetting.setLeaveEarlyStartTime(null); <line11> new_attendanceScheduleSetting.setOffDutyTime(""17:00""); <line12> new_attendanceScheduleSetting.setOnDutyTime(""09:00""); <line13> new_attendanceScheduleSetting.setUnitOu(unitName); <line14> new_attendanceScheduleSetting.setTopUnitName(topUnitName); <line15> new_attendanceScheduleSetting.setUnitName(unitName); <line16> ids = business.getAttendanceScheduleSettingFactory().listByUnitName(unitName, topUnitName); <line17> if (ids == null || ids.isEmpty()) { <line18> emc.beginTransaction(AttendanceScheduleSetting.class); <line19> emc.persist(new_attendanceScheduleSetting, CheckPersistType.all); <line20> emc.commit(); <line21> } <line22> } catch (Exception e) { <line23> throw e; <line24> } <line25> return new_attendanceScheduleSetting; <line26> } <line27> } <line28> "	<line18>
6365	"public class A { <line0> @Test <line1> public void testGenerateAppId() { <line2> List<String> appIds = new ArrayList<>(); <line3> for (int i = 0; i < 10; i++) { <line4> String appId = appIdGenerationManager.createNewAppId(); <line5> assertNotNull(appId); <line6> assertTrue(appId.matches(""APP-[a-zA-Z0-9]{16}"")); <line7> assertFalse(appIds.contains(appId)); <line8> appIds.add(appId); <line9> } <line10> } <line11> } <line12> "	<line5>
6366	public class A { <line0> private void deleteAlertJob(JobKey scheduledJobKey) throws SchedulerException { <line1> Long configId = TaskUtils.getIdFromJobKey(scheduledJobKey.getName()); <line2> DetectionAlertConfigDTO alertConfigSpec = alertConfigDAO.findById(configId); <line3> if (alertConfigSpec == null) { <line4> stopJob(scheduledJobKey); <line5> } <line6> } <line7> } <line8> 	<line4>
6367	"public class A { <line0> @Override <line1> public void start(Collection<? extends Location> locs) { <line2> callHistory.add(""start""); <line3> ServiceStateLogic.setExpectedState(this, Lifecycle.STARTING); <line4> counter.incrementAndGet(); <line5> addLocations(locs); <line6> sensors().set(SERVICE_UP, true); <line7> ServiceStateLogic.setExpectedState(this, Lifecycle.RUNNING); <line8> } <line9> } <line10> "	<line2>
6368	"public class A { <line0> private void treeConnected( <line1> SmbTransportImpl transport, SmbSessionImpl sess, TreeConnectResponse response) <line2> throws CIFSException { <line3> if (!response.isValidTid()) { <line4> throw new SmbException(""TreeID is invalid""); <line5> } <line6> this.tid = response.getTid(); <line7> String rsvc = response.getService(); <line8> if (rsvc == null && !transport.isSMB2()) { <line9> throw new SmbException(""Service is NULL""); <line10> } <line11> if (transport.getContext().getConfig().isIpcSigningEnforced() <line12> && (""IPC$"".equals(this.getShare()) || ""IPC"".equals(rsvc)) <line13> && !sess.getCredentials().isAnonymous() <line14> && sess.getDigest() == null) { <line15> throw new SmbException(""IPC signing is enforced, but no signing is available""); <line16> } <line17> this.service = rsvc; <line18> this.inDfs = response.isShareDfs(); <line19> this.treeNum = TREE_CONN_COUNTER.incrementAndGet(); <line20> this.connectionState.set(2); <line21> try { <line22> validateNegotiation(transport, sess); <line23> } catch (CIFSException se) { <line24> try { <line25> transport.disconnect(true); <line26> } catch (IOException e) { <line27> se.addSuppressed(e); <line28> } <line29> throw se; <line30> } <line31> } <line32> } <line33> "	<line27>
6369	"public class A { <line0> @Override <line1> public void run() { <line2> webRtcReceiver[i - 1] = new WebRtcEndpoint.Builder(pipeline).build(); <line3> recordingFile[i - 1] = getRecordUrl(""-receiver"" + i + extension); <line4> recorder[i - 1] = <line5> new RecorderEndpoint.Builder(pipeline, recordingFile[i - 1]) <line6> .withMediaProfile(mediaProfileSpecType) <line7> .build(); <line8> webRtcSender.connect(webRtcReceiver[i - 1]); <line9> webRtcSender.connect(recorder[i - 1]); <line10> try { <line11> getPage(i).subscribeEvents(""playing""); <line12> getPage(i) <line13> .initWebRtc(webRtcReceiver[i - 1], WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY); <line14> Assert.assertTrue(""Not received media in receiver "" + i, getPage(i).waitForEvent(""playing"")); <line15> recorder[i - 1].record(); <line16> Thread.sleep(PLAYTIME_MS); <line17> recorder[i - 1].stopAndWait(); <line18> Thread.sleep(4000); <line19> } catch (InterruptedException e) { <line20> } <line21> latch.countDown(); <line22> } <line23> } <line24> "	<line20>
6370	"public class A { <line0> private boolean checkSplitBrainJoinMessage() { <line1> ClusterServiceImpl service = getService(); <line2> ILogger logger = getLogger(); <line3> try { <line4> if (!service.getClusterJoinManager().validateJoinMessage(request)) { <line5> return false; <line6> } <line7> if (!service.getClusterVersion().equals(request.getClusterVersion())) { <line8> return false; <line9> } <line10> SplitBrainMergeCheckResult result = service.getClusterJoinManager().shouldMerge(request); <line11> if (result == REMOTE_NODE_SHOULD_MERGE) { <line12> return service.getMembershipManager().verifySplitBrainMergeMemberListVersion(request); <line13> } <line14> return result != CANNOT_MERGE; <line15> } catch (Exception e) { <line16> if (logger.isFineEnabled()) { <line17> logger.fine(""Could not validate split-brain join message! -> "" + e.getMessage()); <line18> } <line19> return false; <line20> } <line21> } <line22> } <line23> "	<line8>
6371	"public class A { <line0> @Override <line1> public void afterSingletonsInstantiated() { <line2> sentinelProperties <line3> .getDatasource() <line4> .forEach( <line5> (dataSourceName, dataSourceProperties) -> { <line6> try { <line7> List<String> validFields = dataSourceProperties.getValidField(); <line8> if (validFields.size() != 1) { <line9> return; <line10> } <line11> AbstractDataSourceProperties abstractDataSourceProperties = <line12> dataSourceProperties.getValidDataSourceProperties(); <line13> abstractDataSourceProperties.setEnv(env); <line14> abstractDataSourceProperties.preCheck(dataSourceName); <line15> registerBean( <line16> abstractDataSourceProperties, <line17> dataSourceName + ""-sentinel-"" + validFields.get(0) + ""-datasource""); <line18> } catch (Exception e) { <line19> } <line20> }); <line21> } <line22> } <line23> "	<line9>, <line19>
6372	public class A { <line0> private void removeGeoNamesMetacardsFromCatalog( <line1> String resource, ProgressCallback extractionCallback) <line2> throws UnsupportedQueryException, SourceUnavailableException, FederationException, <line3> IngestException { <line4> extractionCallback.updateProgress(0); <line5> Optional<CatalogProvider> catalogProviderOptional = catalogProviders.stream().findFirst(); <line6> if (catalogProviderOptional.isPresent()) { <line7> CatalogProvider catalogProvider = catalogProviderOptional.get(); <line8> if (StringUtils.isNotBlank(resource)) { <line9> filter = <line10> filterBuilder.allOf( <line11> filterBuilder <line12> .attribute(GeoEntryAttributes.IMPORT_LOCATION) <line13> .is() <line14> .equalTo() <line15> .text(resource), <line16> filter); <line17> } <line18> while (true) { <line19> Query query = <line20> new QueryImpl( <line21> filter, 1, BATCH_SIZE, SortBy.NATURAL_ORDER, false, TimeUnit.SECONDS.toMillis(90)); <line22> QueryRequest queryRequest = new QueryRequestImpl(query); <line23> QueryResponse response = catalogFramework.query(queryRequest); <line24> List<Serializable> metacardsToDelete = <line25> response.getResults().stream() <line26> .map(Result::getMetacard) <line27> .map(Metacard::getId) <line28> .collect(Collectors.toList()); <line29> if (CollectionUtils.isEmpty(metacardsToDelete)) { <line30> break; <line31> } <line32> removeMetacards(catalogProvider, extractionCallback, metacardsToDelete); <line33> } <line34> } <line35> extractionCallback.updateProgress(50); <line36> } <line37> } <line38> 	<line23>, <line32>
6373	public class A { <line0> private static void compareXml(InputStream expected, InputStream actual) { <line1> Source sexpected = Input.fromStream(expected).build(); <line2> Source sactual = Input.fromStream(actual).build(); <line3> Diff myDiff = <line4> DiffBuilder.compare(sexpected) <line5> .withTest(sactual) <line6> .ignoreWhitespace() <line7> .ignoreComments() <line8> .build(); <line9> boolean hasDiff = myDiff.hasDifferences(); <line10> if (hasDiff) { <line11> } <line12> assertFalse(hasDiff); <line13> } <line14> } <line15> 	<line11>
6374	"public class A { <line0> @Test <line1> public void testDeleted() { <line2> SentinelHello normalHello = <line3> new SentinelHello(sentinels.iterator().next(), masterAddr, sentinelMonitorName); <line4> HostPort remoteDcMAster = new HostPort(""127.0.0.1"", 7379); <line5> Mockito.when(metaCache.getDc(remoteDcMAster)).thenReturn(""remote-dc""); <line6> Set<SentinelHello> hellos = new HashSet<>(); <line7> hellos.add(normalHello); <line8> hellos.add(new SentinelHello(new HostPort(""11.0.0.1"", 5000), masterAddr, sentinelMonitorName)); <line9> hellos.add(new SentinelHello(sentinels.iterator().next(), remoteDcMAster, sentinelMonitorName)); <line10> hellos.add(new SentinelHello(sentinels.iterator().next(), masterAddr, ""error-monitor-name"")); <line11> Set<SentinelHello> needDeletedHello = <line12> collector.checkAndDelete(sentinelMonitorName, sentinels, hellos, quorumConfig, masterAddr); <line13> Assert.assertEquals(3, needDeletedHello.size()); <line14> Assert.assertFalse(needDeletedHello.contains(normalHello)); <line15> Assert.assertEquals(1, hellos.size()); <line16> Assert.assertTrue(hellos.contains(normalHello)); <line17> } <line18> } <line19> "	<line13>
6375	public class A { <line0> private void checkGetFromBackupStoreReadThroughDisabled( <line1> List<CacheConfiguration<Object, Object>> cacheCfgs) throws Exception { <line2> for (CacheConfiguration<Object, Object> ccfg : cacheCfgs) { <line3> ccfg.setCacheStoreFactory(new TestStoreFactory()); <line4> ccfg.setReadThrough(false); <line5> boolean near = (ccfg.getNearConfiguration() != null); <line6> ignite(0).createCache(ccfg); <line7> awaitPartitionMapExchange(); <line8> try { <line9> checkLocalRead(NODES, ccfg); <line10> } finally { <line11> ignite(0).destroyCache(ccfg.getName()); <line12> } <line13> } <line14> } <line15> } <line16> 	<line6>
6376	public class A { <line0> @Before <line1> public void setup() throws Exception { <line2> policyFile = super.setupPolicy(); <line3> super.setup(); <line4> } <line5> } <line6> 	<line2>
6377	public class A { <line0> protected static Image createImage(String path, String description) { <line1> URL imageURL = TrayUI.class.getResource(path); <line2> if (imageURL == null) { <line3> return null; <line4> } else { <line5> return (new ImageIcon(imageURL, description)).getImage(); <line6> } <line7> } <line8> } <line9> 	<line3>
6378	public class A { <line0> @Override <line1> public PerChannelBookieClient create(BookieSocketAddress address) { <line2> Optional<String> networkLocation = Optional.absent(); <line3> try { <line4> if (dnsResolver.isPresent()) { <line5> networkLocation = <line6> Optional.of( <line7> NetUtils.resolveNetworkLocation(dnsResolver.get(), address.getSocketAddress())); <line8> } <line9> } catch (Exception exc) { <line10> } <line11> return new PerChannelBookieClient( <line12> conf, executor, channelFactory, address, requestTimer, statsLogger, networkLocation); <line13> } <line14> } <line15> 	<line10>
6379	public class A { <line0> private Application create(AssemblyTemplate template, CampPlatform platform) { <line1> ManagementContext mgmt = getManagementContext(platform); <line2> BrooklynClassLoadingContext loader = JavaBrooklynClassLoadingContext.create(mgmt); <line3> EntitySpec<? extends Application> spec = <line4> createApplicationSpec(template, platform, loader, MutableSet.<String>of()); <line5> Application instance = mgmt.getEntityManager().createEntity(spec); <line6> return instance; <line7> } <line8> } <line9> 	<line6>
6380	public class A { <line0> public void maybeSendShutdown() { <line1> if (assignmentErrorCode.get() == AssignorError.SHUTDOWN_REQUESTED.code()) { <line2> mainConsumer.enforceRebalance(); <line3> } <line4> } <line5> } <line6> 	<line2>
6381	public class A { <line0> private void disconnect(Throwable reason) { <line1> try { <line2> if (session != null) { <line3> session.close(); <line4> session = null; <line5> } <line6> } catch (IOException e) { <line7> if (reason != null) { <line8> reason.addSuppressed(e); <line9> } else { <line10> } <line11> } finally { <line12> client.stop(); <line13> client = null; <line14> } <line15> } <line16> } <line17> 	<line10>
6382	"public class A { <line0> @Test <line1> void testSplitDocumentation() throws Exception { <line2> try (CamelContext context = new DefaultCamelContext()) { <line3> String json = context.adapt(CatalogCamelContext.class).getEipParameterJsonSchema(""split""); <line4> assertNotNull(""Should have found json for split"", json); <line5> assertTrue(json.contains(""\""name\"": \""split\"""")); <line6> assertTrue( <line7> json.contains(""If enabled then processing each splitted messages occurs concurrently."")); <line8> assertTrue( <line9> json.contains( <line10> ""\""outputs\"": { \""kind\"": \""element\"", \""displayName\"": \""Outputs\"", \""required\"":"" <line11> + "" true, \""type\"": \""array\"", \""javaType\"""")); <line12> } <line13> } <line14> } <line15> "	<line4>
6383	public class A { <line0> private FileEntry _fetchFileEntry(long fileEntryId) { <line1> try { <line2> return _dlAppLocalService.getFileEntry(fileEntryId); <line3> } catch (PortalException portalException) { <line4> if (_log.isDebugEnabled()) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	<line5>
6384	public class A { <line0> private void collectVirtualContainers() { <line1> if (getVirtualItems() == null) { <line2> return; <line3> } <line4> if (getParent() == null) { <line5> return; <line6> } <line7> PrismObjectWrapper objectWrapper = getParent().findObjectWrapper(); <line8> if (objectWrapper == null) { <line9> return; <line10> } <line11> for (VirtualContainerItemSpecificationType virtualItem : getVirtualItems()) { <line12> try { <line13> ItemPath virtualItemPath = getVirtualItemPath(virtualItem); <line14> ItemWrapper itemWrapper = objectWrapper.findItem(virtualItemPath, ItemWrapper.class); <line15> if (itemWrapper == null) { <line16> continue; <line17> } <line18> if (itemWrapper instanceof PrismContainerWrapper) { <line19> continue; <line20> } <line21> nonContainers.add(itemWrapper); <line22> } catch (SchemaException e) { <line23> } <line24> } <line25> } <line26> } <line27> 	<line5>, <line9>, <line16>, <line23>
6385	"public class A { <line0> @Override <line1> public void initializeUI(UIBuilder builder) throws Exception { <line2> StopWatch watch = new StopWatch(); <line3> final UIContext context = builder.getUIContext(); <line4> letsChat = (LetsChatClient) builder.getUIContext().getAttributeMap().get(""letsChatClient""); <line5> taigaClient = (TaigaClient) builder.getUIContext().getAttributeMap().get(""taigaClient""); <line6> ProjectConfig config = (ProjectConfig) context.getAttributeMap().get(""projectConfig""); <line7> if (config != null) { <line8> CommandHelpers.setInitialComponentValue(chatRoom, config.getChatRoom()); <line9> CommandHelpers.setInitialComponentValue(issueProjectName, config.getIssueProjectName()); <line10> CommandHelpers.setInitialComponentValue(codeReview, config.getCodeReview()); <line11> } <line12> builder.add(chatRoom); <line13> builder.add(issueProjectName); <line14> builder.add(codeReview); <line15> } <line16> } <line17> "	<line15>
6386	"public class A { <line0> public List findByExample(FilterResZob instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.FilterResZob"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	<line1>, <line8>, <line10>
6387	"public class A { <line0> public String getHostName(GenericContainer container) { <line1> String OS = System.getProperty(""os.name"", ""generic"").toLowerCase(Locale.ENGLISH); <line2> if ((OS.indexOf(""mac"") >= 0) || (OS.indexOf(""darwin"") >= 0)) { <line3> return ""host.docker.internal""; <line4> } else if (OS.indexOf(""win"") >= 0) { <line5> return ""host.docker.internal""; <line6> } else if (OS.indexOf(""nux"") >= 0) { <line7> Container.ExecResult execResult; <line8> try { <line9> execResult = container.execInContainer(""/sbin/ip route|awk '/default/ { print $3 }'""); <line10> } catch (IOException e) { <line11> return DOCKER_FOR_LINUX_STATIC_IP; <line12> } catch (InterruptedException e) { <line13> Thread.currentThread().interrupt(); <line14> return DOCKER_FOR_LINUX_STATIC_IP; <line15> } <line16> String hostIpAddress = execResult.getStdout(); <line17> if (isValidIpAddress(hostIpAddress)) { <line18> return hostIpAddress; <line19> } else { <line20> return DOCKER_FOR_LINUX_STATIC_IP; <line21> } <line22> } <line23> return container.getTestHostIpAddress(); <line24> } <line25> } <line26> "	<line11>
6388	public class A { <line0> @Override <line1> public synchronized void onEndRequest(RequestCycle requestCycle) { <line2> val isisRequestCycle = requestCycle.getMetaData(REQ_CYCLE_HANDLE_KEY); <line3> requestCycle.setMetaData(REQ_CYCLE_HANDLE_KEY, null); <line4> if (isisRequestCycle != null) { <line5> isisRequestCycle.onEndRequest(); <line6> } <line7> } <line8> } <line9> 	<line2>
6389	public class A { <line0> @Test <line1> public void test_05() { <line2> double pvals[] = {0.01, 0.2, 0.3}; <line3> ScoreList gpl = new ScoreList(); <line4> for (double pval : pvals) gpl.add(pval); <line5> double pvalue = gpl.score(ScoreSummary.FISHER_CHI_SQUARE); <line6> Assert.assertEquals(0.021561751324834642, pvalue, EPSILON); <line7> } <line8> } <line9> 	<line2>
6390	public class A { <line0> protected void updated(Map<String, Object> properties) { <line1> doUpdate(properties); <line2> this.bluetoothAdapter.stopBeaconAdvertising(); <line3> this.bluetoothAdapter = null; <line4> this.bluetoothAdapter = this.bluetoothService.getBluetoothAdapter(this.name, this); <line5> if (this.bluetoothAdapter != null) { <line6> if (!this.bluetoothAdapter.isEnabled()) { <line7> this.bluetoothAdapter.enable(); <line8> } <line9> configureBeacon(); <line10> } else { <line11> } <line12> } <line13> } <line14> 	<line6>, <line7>, <line8>, <line11>, <line12>
6391	"public class A { <line0> private ProcessDefinitionLog moveProcessDefinition( <line1> User loginUser, <line2> Long targetProjectCode, <line3> ProcessDefinition processDefinition, <line4> Map<String, Object> result, <line5> List<String> failedProcessList) { <line6> try { <line7> Integer version = <line8> processDefinitionLogMapper.queryMaxVersionForDefinition(processDefinition.getCode()); <line9> ProcessDefinitionLog processDefinitionLog = new ProcessDefinitionLog(processDefinition); <line10> processDefinitionLog.setVersion(version == null || version == 0 ? 1 : version + 1); <line11> processDefinitionLog.setProjectCode(targetProjectCode); <line12> processDefinitionLog.setOperator(loginUser.getId()); <line13> Date now = new Date(); <line14> processDefinitionLog.setOperateTime(now); <line15> processDefinitionLog.setUpdateTime(now); <line16> processDefinitionLog.setCreateTime(now); <line17> int update = processDefinitionMapper.updateById(processDefinitionLog); <line18> int insertLog = processDefinitionLogMapper.insert(processDefinitionLog); <line19> if ((insertLog & update) > 0) { <line20> putMsg(result, Status.SUCCESS); <line21> } else { <line22> failedProcessList.add(processDefinition.getId() + ""["" + processDefinition.getName() + ""]""); <line23> putMsg(result, Status.UPDATE_PROCESS_DEFINITION_ERROR); <line24> } <line25> return processDefinitionLog; <line26> } catch (Exception e) { <line27> putMsg(result, Status.UPDATE_PROCESS_DEFINITION_ERROR); <line28> failedProcessList.add(processDefinition.getId() + ""["" + processDefinition.getName() + ""]""); <line29> } <line30> return null; <line31> } <line32> } <line33> "	<line29>
6392	"public class A { <line0> public URL getFinalUrl(URL url) throws IOException { <line1> if (url.getHost().endsWith(""artstation.com"")) { <line2> return url; <line3> } <line4> Response response = Http.url(url).connection().followRedirects(false).execute(); <line5> if (response.statusCode() / 100 == 3 && response.hasHeader(""location"")) { <line6> return getFinalUrl(new URL(response.header(""location""))); <line7> } else { <line8> return null; <line9> } <line10> } <line11> } <line12> "	<line4>
6393	public class A { <line0> @Override <line1> public void destroy(IServerSession session) { <line2> try { <line3> session.stop(); <line4> } finally { <line5> if (m_clientNodeId != null) { <line6> BEANS <line7> .get(IClientNotificationService.class) <line8> .unregisterSession(m_clientNodeId, session.getId(), session.getUserId()); <line9> } <line10> } <line11> } <line12> } <line13> 	<line2>
6394	"public class A { <line0> @Override <line1> public <T> T getJAXBObject( <line2> Class<T> type, String key, SupplierX<JAXBContext, JAXBException> contextSupplier, T def) { <line3> Preference<? extends Object> pref = getPreference(key); <line4> if (pref == null) { <line5> return def; <line6> } <line7> if (pref.getValueType() != null && type.isAssignableFrom(pref.getValueType())) { <line8> @SuppressWarnings(""unchecked"") <line9> Preference<T> castPref = (Preference<T>) pref; <line10> T value = castPref.getValue(def, contextSupplier); <line11> return value == null ? def : value; <line12> } <line13> return def; <line14> } <line15> } <line16> "	<line13>
6395	public class A { <line0> private int runCommand(boolean json) <line1> throws InterruptedException, ExecutionException, IOException { <line2> final int ret = command.run(options, client, out, json, null); <line3> return ret; <line4> } <line5> } <line6> 	<line3>
6396	"public class A { <line0> private BrooklynNode setUpBrooklynNodeWithApp() throws InterruptedException, ExecutionException { <line1> BrooklynNode brooklynNode = <line2> app.createAndManageChild( <line3> EntitySpec.create(BrooklynNode.class) <line4> .configure(BrooklynNode.NO_WEB_CONSOLE_AUTHENTICATION, Boolean.TRUE)); <line5> app.start(locs); <line6> EntityAsserts.assertAttributeEqualsEventually(brooklynNode, BrooklynNode.SERVICE_UP, true); <line7> String baseUrl = brooklynNode.getAttribute(BrooklynNode.WEB_CONSOLE_URI).toString(); <line8> waitForApps(baseUrl); <line9> final String id = <line10> brooklynNode <line11> .invoke( <line12> BrooklynNode.DEPLOY_BLUEPRINT, <line13> ConfigBag.newInstance() <line14> .configure( <line15> DeployBlueprintEffector.BLUEPRINT_TYPE, BasicApplication.class.getName()) <line16> .getAllConfig()) <line17> .get(); <line18> String entityUrl = Urls.mergePaths(baseUrl, ""v1/applications/"", id, ""entities"", id); <line19> Entity mirror = <line20> brooklynNode.addChild( <line21> EntitySpec.create(BrooklynEntityMirror.class) <line22> .configure(BrooklynEntityMirror.MIRRORED_ENTITY_URL, entityUrl) <line23> .configure(BrooklynEntityMirror.MIRRORED_ENTITY_ID, id)); <line24> assertEquals(brooklynNode.getChildren().size(), 1); <line25> return brooklynNode; <line26> } <line27> } <line28> "	<line6>
6397	public class A { <line0> protected final void setChannelError(@Nullable final Throwable cause) { <line1> if (hasException()) { <line2> return; <line3> } <line4> exception.set(cause); <line5> } <line6> } <line7> 	<line4>
6398	"public class A { <line0> public static int getUserGroupsAndOrganizationsActivitiesCount( <line1> HttpPrincipal httpPrincipal, long userId) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> SocialActivityServiceUtil.class, <line6> ""getUserGroupsAndOrganizationsActivitiesCount"", <line7> _getUserGroupsAndOrganizationsActivitiesCountParameterTypes28); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, userId); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> throw systemException; <line18> } <line19> } <line20> } <line21> "	<line17>
6399	"public class A { <line0> @Override <line1> public boolean exportsClass(final String name) { <line2> checkArgument(!isEmpty(name), ""Class name cannot be empty""); <line3> boolean exported = classLoaderFilter.exportsClass(name); <line4> if (!exported) { <line5> exported = exportedClasses.get(name) != null; <line6> if (exported) { <line7> } <line8> } <line9> return exported; <line10> } <line11> } <line12> "	<line7>
6400	public class A { <line0> private void updateDiskStatusMapWithInactiveIscsiSessions(Connect conn) { <line1> try { <line2> int[] domains = conn.listDomains(); <line3> for (int domId : domains) { <line4> Domain dm = conn.domainLookupByID(domId); <line5> final String domXml = dm.getXMLDesc(0); <line6> final LibvirtDomainXMLParser parser = new LibvirtDomainXMLParser(); <line7> parser.parseDomainXML(domXml); <line8> List<LibvirtVMDef.DiskDef> disks = parser.getDisks(); <line9> for (final LibvirtVMDef.DiskDef disk : disks) { <line10> if (diskStatusMap.containsKey(disk.getDiskPath()) <line11> && !disk.getDiskPath().matches(REGEX_PART)) { <line12> diskStatusMap.put(disk.getDiskPath(), true); <line13> } <line14> } <line15> } <line16> } catch (LibvirtException e) { <line17> } <line18> } <line19> } <line20> 	<line3>, <line13>, <line17>
6401	"public class A { <line0> public static void dumpToLog(final AtlasGraph<?, ?> graph) { <line1> LOG.debug(""*******************Graph Dump****************************""); <line2> for (AtlasVertex vertex : graph.getVertices()) { <line3> } <line4> for (AtlasEdge edge : graph.getEdges()) { <line5> } <line6> } <line7> } <line8> "	<line2>, <line3>, <line4>, <line5>, <line6>
6402	public class A { <line0> @Override <line1> public void messageReceived(IoSession session, Object object) throws Exception { <line2> if (LOG.isDebugEnabled()) { <line3> Object in = object; <line4> if (in instanceof byte[]) { <line5> in = getEndpoint().getCamelContext().getTypeConverter().convertTo(String.class, in); <line6> } <line7> } <line8> Exchange exchange = createExchange(session, object); <line9> if (getEndpoint().getConfiguration().getCharsetName() != null) { <line10> exchange.setProperty( <line11> ExchangePropertyKey.CHARSET_NAME, <line12> IOHelper.normalizeCharset(getEndpoint().getConfiguration().getCharsetName())); <line13> } <line14> try { <line15> getProcessor().process(exchange); <line16> } catch (Exception e) { <line17> getExceptionHandler().handleException(e); <line18> } <line19> try { <line20> boolean disconnect = getEndpoint().getConfiguration().isDisconnect(); <line21> Object response; <line22> if (exchange.hasOut()) { <line23> response = MinaPayloadHelper.getOut(getEndpoint(), exchange); <line24> } else { <line25> response = MinaPayloadHelper.getIn(getEndpoint(), exchange); <line26> } <line27> boolean failed = exchange.isFailed(); <line28> if (failed && !getEndpoint().getConfiguration().isTransferExchange()) { <line29> if (exchange.getException() != null) { <line30> response = exchange.getException(); <line31> } else { <line32> response = exchange.getOut().getBody(); <line33> } <line34> } <line35> if (response != null) { <line36> MinaHelper.writeBody(session, response, exchange, configuration.getWriteTimeout()); <line37> } else { <line38> disconnect = Boolean.TRUE; <line39> } <line40> Boolean close; <line41> if (ExchangeHelper.isOutCapable(exchange)) { <line42> close = <line43> exchange <line44> .getOut() <line45> .getHeader(MinaConstants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class); <line46> } else { <line47> close = <line48> exchange <line49> .getIn() <line50> .getHeader(MinaConstants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class); <line51> } <line52> if (close != null) { <line53> disconnect = close; <line54> } <line55> if (disconnect) { <line56> session.closeNow(); <line57> } <line58> } finally { <line59> releaseExchange(exchange, false); <line60> } <line61> } <line62> } <line63> 	<line7>, <line36>, <line38>, <line56>
6403	public class A { <line0> @Override <line1> public void enqueueMutateBatch(List<RowMutation> mutations) throws BlurException, TException { <line2> try { <line3> resetSearchers(); <line4> for (RowMutation mutation : mutations) { <line5> checkTable(_cluster, mutation.table); <line6> checkForUpdates(_cluster, mutation.table); <line7> MutationHelper.validateMutation(mutation); <line8> } <line9> _indexManager.enqueue(mutations); <line10> } catch (Exception e) { <line11> if (e instanceof BlurException) { <line12> throw (BlurException) e; <line13> } <line14> throw new BException(e.getMessage(), e); <line15> } <line16> } <line17> } <line18> 	<line11>
6404	public class A { <line0> @Override <line1> public boolean userCanSendFrom(Username connectedUser, Username fromUser) { <line2> try { <line3> return connectedUser.equals(fromUser) <line4> || emailIsAnAliasOfTheConnectedUser(connectedUser, fromUser); <line5> } catch (RecipientRewriteTableException | RecipientRewriteTable.ErrorMappingException e) { <line6> return false; <line7> } <line8> } <line9> } <line10> 	<line6>
6405	"public class A { <line0> @NwhinInvocationEvent( <line1> beforeBuilder = DeferredResponseDescriptionBuilder.class, <line2> afterReturningBuilder = DeferredResponseDescriptionBuilder.class, <line3> serviceType = ""Document Submission Deferred Response"", <line4> version = ""1.1"") <line5> @Override <line6> public XDRAcknowledgementType provideAndRegisterDocumentSetBDeferredResponse11( <line7> RegistryResponseType request, AssertionType assertion, NhinTargetSystemType target) { <line8> XDRAcknowledgementType response = null; <line9> try { <line10> String url = getUrl(target); <line11> if (request == null) { <line12> throw new IllegalArgumentException(""Request Message must be provided""); <line13> } else { <line14> ServicePortDescriptor<XDRDeferredResponsePortType> portDescriptor = <line15> new NhinDocSubmissionDeferredResponseServicePortDescriptor(); <line16> CONNECTClient<XDRDeferredResponsePortType> client = <line17> getCONNECTClientSecured( <line18> portDescriptor, <line19> url, <line20> assertion, <line21> target, <line22> NhincConstants.NHINC_XDR_RESPONSE_SERVICE_NAME); <line23> client.enableMtom(); <line24> response = <line25> (XDRAcknowledgementType) <line26> client.invokePort( <line27> XDRDeferredResponsePortType.class, <line28> ""provideAndRegisterDocumentSetBDeferredResponse"", <line29> request); <line30> } <line31> } catch (Exception ex) { <line32> response = <line33> getMessageGeneratorUtils().createRegistryErrorXDRAcknowledgementType(ex.getMessage()); <line34> throw new ErrorEventException( <line35> ex, response, ""Unable to call Doc Submission Deferred Response""); <line36> } <line37> return response; <line38> } <line39> } <line40> "	<line8>, <line37>
6406	"public class A { <line0> public synchronized HeritrixTemplate read(String orderXmlName) { <line1> ArgumentNotValid.checkNotNullOrEmpty(orderXmlName, ""String orderXmlName""); <line2> Connection c = HarvestDBConnection.get(); <line3> PreparedStatement s = null; <line4> try { <line5> s = <line6> c.prepareStatement( <line7> ""SELECT template_id, orderxml, isActive FROM ordertemplates WHERE name = ?""); <line8> s.setString(1, orderXmlName); <line9> ResultSet res = s.executeQuery(); <line10> if (!res.next()) { <line11> throw new UnknownID(""Can't find template "" + orderXmlName); <line12> } <line13> Reader orderTemplateReader = null; <line14> long template_id = res.getLong(1); <line15> if (DBSpecifics.getInstance().supportsClob()) { <line16> Clob clob = res.getClob(2); <line17> orderTemplateReader = clob.getCharacterStream(); <line18> } else { <line19> String string = res.getString(2); <line20> orderTemplateReader = new StringReader(string); <line21> } <line22> HeritrixTemplate heritrixTemplate = HeritrixTemplate.read(template_id, orderTemplateReader); <line23> heritrixTemplate.setIsActive(res.getBoolean(3)); <line24> return heritrixTemplate; <line25> } catch (SQLException e) { <line26> final String message = <line27> ""SQL error finding order.xml for "" <line28> + orderXmlName <line29> + ""\n"" <line30> + ExceptionUtils.getSQLExceptionCause(e); <line31> throw new IOFailure(message, e); <line32> } finally { <line33> DBUtils.closeStatementIfOpen(s); <line34> HarvestDBConnection.release(c); <line35> } <line36> } <line37> } <line38> "	<line4>, <line31>
6407	public class A { <line0> private String convertCheckName(DataType checkName) { <line1> if (checkName instanceof Text) { <line2> return checkName.toString(); <line3> } else { <line4> return checkName.toString(); <line5> } <line6> } <line7> } <line8> 	<line4>
6408	"public class A { <line0> public static void main(final String[] args) { <line1> final long start = System.currentTimeMillis(); <line2> final String inputFilePath = args[0]; <line3> final Integer numFeatures = Integer.parseInt(args[1]); <line4> final Integer numClasses = Integer.parseInt(args[2]); <line5> final Integer numItr = Integer.parseInt(args[3]); <line6> final List<Integer> initialModelKeys = new ArrayList<>(numClasses); <line7> for (Integer i = 0; i < numClasses; i++) { <line8> initialModelKeys.add(i); <line9> } <line10> final PipelineOptions options = NemoPipelineOptionsFactory.create(); <line11> options.setJobName(""MLR""); <line12> options.setStableUniqueNames(PipelineOptions.CheckEnabled.OFF); <line13> final Pipeline p = Pipeline.create(options); <line14> PCollection<KV<Integer, List<Double>>> model = <line15> p.apply(Create.of(initialModelKeys)) <line16> .apply( <line17> ParDo.of( <line18> new DoFn<Integer, KV<Integer, List<Double>>>() { <line19> @ProcessElement <line20> public void processElement(final ProcessContext c) throws Exception { <line21> if (c.element() == numClasses - 1) { <line22> final List<Double> model = new ArrayList<>(1); <line23> model.add(0.0); <line24> c.output(KV.of(c.element(), model)); <line25> } else { <line26> final List<Double> model = new ArrayList<>(numFeatures); <line27> for (Integer i = 0; i < numFeatures; i++) { <line28> model.add(i, 0.0); <line29> } <line30> c.output(KV.of(c.element(), model)); <line31> } <line32> } <line33> })); <line34> final PCollection<String> readInput = GenericSourceSink.read(p, inputFilePath); <line35> for (Integer i = 1; i <= numItr; i++) { <line36> model = model.apply(new UpdateModel(numFeatures, numClasses, i, readInput)); <line37> } <line38> p.run().waitUntilFinish(); <line39> } <line40> } <line41> "	<line2>, <line39>
6409	"public class A { <line0> protected void internalDeleteTopic(boolean authoritative, boolean deleteSchema) { <line1> validateNamespaceOperation(topicName.getNamespaceObject(), NamespaceOperation.DELETE_TOPIC); <line2> validateTopicOwnership(topicName, authoritative); <line3> try { <line4> pulsar().getBrokerService().deleteTopic(topicName.toString(), false, deleteSchema).get(); <line5> } catch (Exception e) { <line6> Throwable t = e.getCause(); <line7> if (t instanceof TopicBusyException) { <line8> throw new RestException( <line9> Status.PRECONDITION_FAILED, ""Topic has active producers/subscriptions""); <line10> } else if (t instanceof MetadataNotFoundException) { <line11> throw new RestException(Status.NOT_FOUND, ""Topic not found""); <line12> } else { <line13> throw new RestException(t); <line14> } <line15> } <line16> } <line17> } <line18> "	<line5>, <line7>
6410	public class A { <line0> public void addGlobal(FacesMessage msg) { <line1> if (shouldLogAsWarning(msg.getSeverity())) { <line2> } <line3> globalMessages.add(msg); <line4> } <line5> } <line6> 	<line2>
6411	"public class A { <line0> @Test <line1> public void testBuildArgs() { <line2> SparkParameters param = new SparkParameters(); <line3> param.setDeployMode(mode); <line4> param.setMainClass(mainClass); <line5> param.setDriverCores(driverCores); <line6> param.setDriverMemory(driverMemory); <line7> param.setExecutorCores(executorCores); <line8> param.setExecutorMemory(executorMemory); <line9> param.setMainJar(mainJar); <line10> param.setNumExecutors(numExecutors); <line11> param.setProgramType(programType); <line12> param.setSparkVersion(sparkVersion); <line13> param.setMainArgs(mainArgs); <line14> param.setAppName(appName); <line15> param.setQueue(queue); <line16> List<String> result = SparkArgsUtils.buildArgs(param); <line17> for (String s : result) { <line18> } <line19> assertEquals(22, result.size()); <line20> assertEquals(""--master"", result.get(0)); <line21> assertEquals(""yarn"", result.get(1)); <line22> assertEquals(""--deploy-mode"", result.get(2)); <line23> assertEquals(mode, result.get(3)); <line24> assertEquals(""--class"", result.get(4)); <line25> assertEquals(mainClass, result.get(5)); <line26> assertEquals(""--driver-cores"", result.get(6)); <line27> assertSame(driverCores, Integer.valueOf(result.get(7))); <line28> assertEquals(""--driver-memory"", result.get(8)); <line29> assertEquals(driverMemory, result.get(9)); <line30> assertEquals(""--num-executors"", result.get(10)); <line31> assertSame(numExecutors, Integer.valueOf(result.get(11))); <line32> assertEquals(""--executor-cores"", result.get(12)); <line33> assertSame(executorCores, Integer.valueOf(result.get(13))); <line34> assertEquals(""--executor-memory"", result.get(14)); <line35> assertEquals(executorMemory, result.get(15)); <line36> assertEquals(""--name"", result.get(16)); <line37> assertEquals(ArgsUtils.escape(appName), result.get(17)); <line38> assertEquals(""--queue"", result.get(18)); <line39> assertEquals(queue, result.get(19)); <line40> assertEquals(mainJar.getRes(), result.get(20)); <line41> assertEquals(mainArgs, result.get(21)); <line42> SparkParameters param1 = new SparkParameters(); <line43> param1.setOthers(""--files xxx/hive-site.xml""); <line44> param1.setQueue(queue); <line45> result = SparkArgsUtils.buildArgs(param1); <line46> assertEquals(7, result.size()); <line47> } <line48> } <line49> "	<line18>
6412	"public class A { <line0> @Override <line1> public void execute(final FunctionContext<String> context) { <line2> Cache cache = context.getCache(); <line3> try { <line4> if (cache instanceof InternalCache) { <line5> InternalCache gemfireCache = (InternalCache) cache; <line6> DistributedMember member = gemfireCache.getMyId(); <line7> String diskStoreName = context.getArguments(); <line8> String memberId = member.getId(); <line9> String memberName = member.getName(); <line10> DiskStore diskStore = gemfireCache.findDiskStore(diskStoreName); <line11> if (diskStore != null) { <line12> DiskStoreDetails diskStoreDetails = <line13> new DiskStoreDetails( <line14> diskStore.getDiskStoreUUID(), diskStore.getName(), memberId, memberName); <line15> diskStoreDetails.setAllowForceCompaction(diskStore.getAllowForceCompaction()); <line16> diskStoreDetails.setAutoCompact(diskStore.getAutoCompact()); <line17> diskStoreDetails.setCompactionThreshold(diskStore.getCompactionThreshold()); <line18> diskStoreDetails.setMaxOplogSize(diskStore.getMaxOplogSize()); <line19> diskStoreDetails.setQueueSize(diskStore.getQueueSize()); <line20> diskStoreDetails.setTimeInterval(diskStore.getTimeInterval()); <line21> diskStoreDetails.setWriteBufferSize(diskStore.getWriteBufferSize()); <line22> diskStoreDetails.setDiskUsageWarningPercentage(diskStore.getDiskUsageWarningPercentage()); <line23> diskStoreDetails.setDiskUsageCriticalPercentage( <line24> diskStore.getDiskUsageCriticalPercentage()); <line25> setDiskDirDetails(diskStore, diskStoreDetails); <line26> setRegionDetails(gemfireCache, diskStore, diskStoreDetails); <line27> setCacheServerDetails(gemfireCache, diskStore, diskStoreDetails); <line28> setGatewayDetails(gemfireCache, diskStore, diskStoreDetails); <line29> setPdxSerializationDetails(gemfireCache, diskStore, diskStoreDetails); <line30> setAsyncEventQueueDetails(gemfireCache, diskStore, diskStoreDetails); <line31> context.getResultSender().lastResult(diskStoreDetails); <line32> } else { <line33> context <line34> .getResultSender() <line35> .sendException( <line36> new EntityNotFoundException( <line37> String.format( <line38> ""A disk store with name '%1$s' was not found on member '%2$s'."", <line39> diskStoreName, memberName))); <line40> } <line41> } <line42> } catch (Exception e) { <line43> context.getResultSender().sendException(e); <line44> } <line45> } <line46> } <line47> "	<line43>
6413	public class A { <line0> @Override <line1> public Object call() { <line2> Thread.currentThread().setName(THREAD_NAME); <line3> try { <line4> amqpReactor.run(); <line5> } catch (HandlerException e) { <line6> throw e; <line7> } <line8> return null; <line9> } <line10> } <line11> 	<line3>, <line6>, <line8>
6414	"public class A { <line0> public FcmPushNotificationResponse pushFcmNotification( <line1> NotificationBean notification, AppEntity appPropertiesDetails) throws IOException { <line2> String authKey = """"; <line3> logger.entry(""Begin pushFCMNotification()""); <line4> if (notification.getDeviceToken() != null <line5> && notification.getDeviceToken().length() > 0 <line6> && appPropertiesDetails != null) { <line7> authKey = appPropertiesDetails.getAndroidServerKey(); <line8> URL url = new URL((String) applicationPropertyConfiguration.getApiUrlFcm()); <line9> HttpURLConnection conn = (HttpURLConnection) url.openConnection(); <line10> conn.setUseCaches(false); <line11> conn.setDoInput(true); <line12> conn.setDoOutput(true); <line13> conn.setRequestMethod(""POST""); <line14> conn.setRequestProperty(""Authorization"", ""key="" + authKey); <line15> conn.setRequestProperty(""Content-Type"", ""application/json""); <line16> JSONObject json = new JSONObject(); <line17> json.put(""registration_ids"", notification.getDeviceToken()); <line18> json.put(""priority"", ""high""); <line19> JSONObject dataInfo = new JSONObject(); <line20> dataInfo.put(""subtype"", notification.getNotificationSubType()); <line21> dataInfo.put(""type"", notification.getNotificationType()); <line22> dataInfo.put(""title"", notification.getNotificationTitle()); <line23> dataInfo.put(""message"", notification.getNotificationText()); <line24> if (notification.getCustomStudyId() != null <line25> && StringUtils.isNotEmpty(notification.getCustomStudyId())) { <line26> dataInfo.put(""studyId"", notification.getCustomStudyId()); <line27> } <line28> json.put(""data"", dataInfo); <line29> OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); <line30> wr.write(json.toString()); <line31> wr.flush(); <line32> String response = IOUtils.toString(conn.getInputStream(), StandardCharsets.UTF_8); <line33> JsonNode responseJson = new ObjectMapper().readTree(response); <line34> FcmPushNotificationResponse fcmNotificationResponse = <line35> new FcmPushNotificationResponse( <line36> responseJson, conn.getResponseCode(), conn.getResponseMessage()); <line37> return fcmNotificationResponse; <line38> } <line39> return new FcmPushNotificationResponse(null, HttpStatus.OK.value(), ""SUCCESS""); <line40> } <line41> } <line42> "	<line37>
6415	public class A { <line0> public ID validRequestorForSendType_returnType(String sendType, String returnType) { <line1> if (StringUtils.isNotEmpty(sendType)) { <line2> return null; <line3> } <line4> if (StringUtils.isNotEmpty(returnType)) { <line5> if (NSPasteboard.FilenamesPboardType.equals(sendType)) { <line6> return this.id(); <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	<line1>
6416	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private String[] getAllNoteIdsWithinDateRange( <line2> LoggedInInfo loggedInInfo, <line3> HttpServletRequest request, <line4> String demoNo, <line5> Date startDate, <line6> Date endDate) { <line7> HttpSession se = loggedInInfo.getSession(); <line8> ProgramProvider pp = <line9> programManager2.getCurrentProgramInDomain( <line10> loggedInInfo, loggedInInfo.getLoggedInProviderNo()); <line11> String programId = null; <line12> if (pp != null && pp.getProgramId() != null) { <line13> programId = """" + pp.getProgramId(); <line14> } else { <line15> programId = String.valueOf(programMgr.getProgramIdByProgramName(""OSCAR"")); <line16> } <line17> NoteSelectionCriteria criteria = new NoteSelectionCriteria(); <line18> criteria.setStartDate(startDate); <line19> criteria.setEndDate(endDate); <line20> criteria.setMaxResults(Integer.MAX_VALUE); <line21> criteria.setDemographicId(ConversionUtils.fromIntString(demoNo)); <line22> criteria.setUserRole((String) request.getSession().getAttribute(""userrole"")); <line23> criteria.setUserName((String) request.getSession().getAttribute(""user"")); <line24> if (request.getParameter(""note_sort"") != null <line25> && request.getParameter(""note_sort"").length() > 0) { <line26> criteria.setNoteSort(request.getParameter(""note_sort"")); <line27> } <line28> if (programId != null && !programId.trim().isEmpty()) { <line29> criteria.setProgramId(programId); <line30> } <line31> if (se.getAttribute(""CaseManagementViewAction_filter_roles"") != null) { <line32> criteria <line33> .getRoles() <line34> .addAll((List<String>) se.getAttribute(""CaseManagementViewAction_filter_roles"")); <line35> } <line36> if (se.getAttribute(""CaseManagementViewAction_filter_providers"") != null) { <line37> criteria <line38> .getProviders() <line39> .addAll((List<String>) se.getAttribute(""CaseManagementViewAction_filter_providers"")); <line40> } <line41> if (se.getAttribute(""CaseManagementViewAction_filter_providers"") != null) { <line42> criteria <line43> .getIssues() <line44> .addAll((List<String>) se.getAttribute(""CaseManagementViewAction_filter_issues"")); <line45> } <line46> if (logger.isDebugEnabled()) { <line47> } <line48> NoteSelectionResult result = noteService.findNotes(loggedInInfo, criteria); <line49> List<String> buf = new ArrayList<String>(); <line50> for (NoteDisplay nd : result.getNotes()) { <line51> if (!(nd instanceof NoteDisplayLocal)) { <line52> continue; <line53> } <line54> buf.add(nd.getNoteId().toString()); <line55> } <line56> return buf.toArray(new String[0]); <line57> } <line58> } <line59> "	<line47>
6417	"public class A { <line0> public static void unsubscribeFolder(HttpPrincipal httpPrincipal, long groupId, long folderId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> DLAppServiceUtil.class, ""unsubscribeFolder"", _unsubscribeFolderParameterTypes97); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, folderId); <line7> try { <line8> TunnelUtil.invoke(httpPrincipal, methodHandler); <line9> } catch (Exception exception) { <line10> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line11> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line12> } <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	<line16>
6418	"public class A { <line0> @Test <line1> public void testCreateAndRemoveElement() throws Exception { <line2> uuidList = new LinkedList<String>(); <line3> Organization organization = createOrganization(); <line4> uuidList.add(organization.getUuid()); <line5> checkOrganization(organization); <line6> uuidList.addAll(createElementsInGroups(organization, NUMBER_PER_GROUP)); <line7> RemoveElement<CnATreeElement> removeCommand = new RemoveElement<CnATreeElement>(organization); <line8> commandService.executeCommand(removeCommand); <line9> for (String uuid : uuidList) { <line10> LoadElementByUuid<CnATreeElement> command = new LoadElementByUuid<CnATreeElement>(uuid); <line11> command = commandService.executeCommand(command); <line12> CnATreeElement element = command.getElement(); <line13> assertNull(""Organization was not deleted."", element); <line14> } <line15> } <line16> } <line17> "	<line7>
6419	"public class A { <line0> @Override <line1> public boolean publishToStreaming() { <line2> HttpGet get = new HttpGet(""/publishToStreaming""); <line3> HttpResponse response = getResponse(get); <line4> if (response != null) { <line5> String content = null; <line6> try (BufferedReader r = <line7> new BufferedReader(new InputStreamReader(response.getEntity().getContent()))) { <line8> content = r.readLine(); <line9> } catch (Exception e) { <line10> } finally { <line11> closeConnection(response); <line12> } <line13> if (content != null) { <line14> return Boolean.parseBoolean(content.trim()); <line15> } <line16> } <line17> return false; <line18> } <line19> } <line20> "	<line10>
6420	"public class A { <line0> protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) { <line1> SpringApplicationBuilder builder = createSpringApplicationBuilder(); <line2> builder.main(getClass()); <line3> ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); <line4> if (parent != null) { <line5> servletContext.setAttribute( <line6> WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); <line7> builder.initializers(new ParentContextApplicationContextInitializer(parent)); <line8> } <line9> builder.initializers(new ServletContextApplicationContextInitializer(servletContext)); <line10> builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); <line11> builder = configure(builder); <line12> SpringApplication application = builder.build(); <line13> if (application.getSources().isEmpty() <line14> && AnnotationUtils.findAnnotation(getClass(), Configuration.class) != null) { <line15> application.getSources().add(getClass()); <line16> } <line17> Assert.state( <line18> !application.getSources().isEmpty(), <line19> ""No SpringApplication sources have been defined. Either override the "" <line20> + ""configure method or add an @Configuration annotation""); <line21> if (this.registerErrorPageFilter) { <line22> application.getSources().add(ErrorPageFilter.class); <line23> } <line24> return run(application); <line25> } <line26> } <line27> "	<line5>
6421	public class A { <line0> @Override <line1> public void delete(DeletePlan deletePlan) throws QueryProcessException { <line2> if (deletePlan.getPaths().isEmpty()) { <line3> return; <line4> } <line5> for (PartialPath path : deletePlan.getPaths()) { <line6> delete( <line7> path, <line8> deletePlan.getDeleteStartTime(), <line9> deletePlan.getDeleteEndTime(), <line10> deletePlan.getIndex()); <line11> } <line12> } <line13> } <line14> 	<line3>
6422	"public class A { <line0> @DeleteMapping(value = ""/{modelId:.+}"") <line1> @PreAuthorize( <line2> ""hasAuthority('sysadmin') or "" <line3> + ""hasPermission(T(org.eclipse.vorto.model.ModelId).fromPrettyFormat(#modelId),"" <line4> + ""T(org.eclipse.vorto.repository.core.PolicyEntry.Permission).FULL_ACCESS)"") <line5> public ResponseEntity<Boolean> deleteModelResource(final @PathVariable String modelId) { <line6> Objects.requireNonNull(modelId, ""modelId must not be null""); <line7> try { <line8> getModelRepository(ModelId.fromPrettyFormat(modelId)) <line9> .removeModel(ModelId.fromPrettyFormat(modelId)); <line10> return new ResponseEntity<>(false, HttpStatus.OK); <line11> } catch (FatalModelRepositoryException | NullPointerException e) { <line12> return new ResponseEntity<>(false, HttpStatus.NOT_FOUND); <line13> } <line14> } <line15> } <line16> "	<line12>
6423	"public class A { <line0> @Override <line1> public void appendStripe( <line2> byte[] stripe, <line3> int offset, <line4> int length, <line5> StripeInformation stripeInfo, <line6> OrcProto.StripeStatistics stripeStatistics) <line7> throws IOException { <line8> checkArgument(stripe != null, ""Stripe must not be null""); <line9> checkArgument( <line10> length <= stripe.length, ""Specified length must not be greater specified array length""); <line11> checkArgument(stripeInfo != null, ""Stripe information must not be null""); <line12> checkArgument(stripeStatistics != null, ""Stripe statistics must not be null""); <line13> getStream(); <line14> long start = rawWriter.getBytesWritten(); <line15> long stripeLen = length; <line16> long availBlockSpace = blockSize - (start % blockSize); <line17> if (stripeLen < blockSize && stripeLen > availBlockSpace && addBlockPadding) { <line18> byte[] pad = new byte[(int) Math.min(HDFS_BUFFER_SIZE, availBlockSpace)]; <line19> start += availBlockSpace; <line20> while (availBlockSpace > 0) { <line21> int writeLen = (int) Math.min(availBlockSpace, pad.length); <line22> rawWriter.write(pad, 0, writeLen); <line23> availBlockSpace -= writeLen; <line24> } <line25> } <line26> rawWriter.write(stripe); <line27> rowsInStripe = stripeStatistics.getColStats(0).getNumberOfValues(); <line28> rowCount += rowsInStripe; <line29> treeWriter.stripeStatsBuilders.add(stripeStatistics.toBuilder()); <line30> updateFileStatistics(stripeStatistics); <line31> OrcProto.StripeInformation dirEntry = <line32> OrcProto.StripeInformation.newBuilder() <line33> .setOffset(start) <line34> .setNumberOfRows(rowsInStripe) <line35> .setIndexLength(stripeInfo.getIndexLength()) <line36> .setDataLength(stripeInfo.getDataLength()) <line37> .setFooterLength(stripeInfo.getFooterLength()) <line38> .build(); <line39> stripes.add(dirEntry); <line40> rowsInStripe = 0; <line41> } <line42> } <line43> "	<line19>
6424	public class A { <line0> private static void invokeMethod( <line1> String referenceName, <line2> Dataset ds, <line3> Class<? extends Dataset> dsClass, <line4> String methodName, <line5> AccessType accessType) { <line6> try { <line7> Method method = dsClass.getMethod(methodName); <line8> method.invoke(ds); <line9> } catch (NoSuchMethodException e) { <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	<line10>, <line11>
6425	"public class A { <line0> protected void internalRemoveActivity(InternalActivityImpl activity) throws RepositoryException { <line1> WriteOperation operation = startWriteOperation(); <line2> try { <line3> NodeId nodeId = activity.getId(); <line4> if (stateMgr.hasNodeReferences(nodeId)) { <line5> NodeReferences refs = stateMgr.getNodeReferences(nodeId); <line6> if (refs.hasReferences()) { <line7> throw new ReferentialIntegrityException(""Unable to delete activity. still referenced.""); <line8> } <line9> } <line10> NodeStateEx act = getNodeStateEx(nodeId); <line11> NodeId parentId = act.getParentId(); <line12> Name name = act.getName(); <line13> while (parentId != null) { <line14> NodeStateEx parent = getNodeStateEx(parentId); <line15> parent.removeNode(name); <line16> parent.store(); <line17> if (parent.getChildNodes().length == 0 && !parentId.equals(activitiesId)) { <line18> name = parent.getName(); <line19> parentId = parent.getParentId(); <line20> } else { <line21> parentId = null; <line22> } <line23> } <line24> operation.save(); <line25> } catch (ItemStateException e) { <line26> } finally { <line27> operation.close(); <line28> } <line29> } <line30> } <line31> "	<line26>
6426	public class A { <line0> private void matchMultiCallMethodNode( <line1> ISyntaxNode node, <line2> IBindingContext bindingContext, <line3> IOpenClass[] methodArguments, <line4> Deque<Integer> arrayArgArguments, <line5> int countOfChanged, <line6> MutableInt bestCountOfChanged, <line7> Map<MethodKey, IOpenMethod> candidates, <line8> MutableObject<IBoundNode> best) { <line9> if (countOfChanged > bestCountOfChanged.getValue() || arrayArgArguments.isEmpty()) { <line10> return; <line11> } <line12> IMethodCaller singleParameterMethodCaller; <line13> try { <line14> singleParameterMethodCaller = <line15> bindingContext.findMethodCaller( <line16> ISyntaxConstants.THIS_NAMESPACE, methodName, methodArguments); <line17> } catch (AmbiguousMethodException e) { <line18> if (countOfChanged < bestCountOfChanged.getValue()) { <line19> candidates.clear(); <line20> } <line21> for (IOpenMethod openMethod : e.getMatchingMethods()) { <line22> candidates.put(new MethodKey(openMethod), openMethod); <line23> } <line24> return; <line25> } <line26> if (singleParameterMethodCaller instanceof CastingMethodCaller) { <line27> CastingMethodCaller castingMethodCaller = (CastingMethodCaller) singleParameterMethodCaller; <line28> int i = 0; <line29> for (IOpenCast openCast : castingMethodCaller.getCasts()) { <line30> if (openCast instanceof IOneElementArrayCast && arrayArgArguments.contains(i)) { <line31> return; <line32> } <line33> i++; <line34> } <line35> } <line36> if (singleParameterMethodCaller == null) { <line37> return; <line38> } <line39> if (countOfChanged < bestCountOfChanged.getValue()) { <line40> candidates.clear(); <line41> bestCountOfChanged.setValue(countOfChanged); <line42> BindHelper.checkOnDeprecation(node, bindingContext, singleParameterMethodCaller); <line43> IBoundNode multiCallMethodBoundNode = <line44> makeMultiCallMethodBoundNode( <line45> node, children, new ArrayList<>(arrayArgArguments), singleParameterMethodCaller); <line46> best.setValue(multiCallMethodBoundNode); <line47> } <line48> candidates.put( <line49> new MethodKey(singleParameterMethodCaller.getMethod()), <line50> singleParameterMethodCaller.getMethod()); <line51> } <line52> } <line53> 	<line24>
6427	public class A { <line0> @Override <line1> public MatchResult getMatchingWeight(Record record1, Record record2) { <line2> Iterator<Attribute> mergedRecordAttributes = record1.getAttributes().iterator(); <line3> Iterator<Attribute> currentRecordAttributes = record2.getAttributes().iterator(); <line4> List<Double> leftWorstConfidenceValueScoreList = record1.getWorstConfidenceValueScoreList(); <line5> List<Double> rightWorstConfidenceValueScoreList = record2.getWorstConfidenceValueScoreList(); <line6> double confidence = 0; <line7> int matchIndex = 0; <line8> MatchResult result = new MatchResult(record1.getAttributes().size()); <line9> int maxWeight = 0; <line10> double finalWorstConfidenceValue = 0.0d; <line11> while (mergedRecordAttributes.hasNext()) { <line12> Attribute left = mergedRecordAttributes.next(); <line13> Attribute right = currentRecordAttributes.next(); <line14> IAttributeMatcher matcher = attributeMatchers[matchIndex]; <line15> Double leftWorstScore = getWorstScore(leftWorstConfidenceValueScoreList, matchIndex); <line16> Double rightWorstScore = getWorstScore(rightWorstConfidenceValueScoreList, matchIndex); <line17> double score = matchScore(left, right, matcher, leftWorstScore, rightWorstScore, matchIndex); <line18> attributeMatchingWeights[matchIndex] = score; <line19> result.setScore( <line20> matchIndex, <line21> matcher.getMatchType(), <line22> score, <line23> record1.getId(), <line24> left.getValue(), <line25> record2.getId(), <line26> right.getValue()); <line27> result.setThreshold(matchIndex, matcher.getThreshold()); <line28> result.storeWorstScore(matchIndex, worstConfidenceValue); <line29> confidence += score * matcher.getWeight(); <line30> finalWorstConfidenceValue += worstConfidenceValue * matcher.getWeight(); <line31> maxWeight += matcher.getWeight(); <line32> matchIndex++; <line33> } <line34> double normalizedConfidence = <line35> confidence > 0 && maxWeight != 0 ? confidence / maxWeight : confidence; <line36> finalWorstConfidenceValue = <line37> finalWorstConfidenceValue > 0 && maxWeight != 0 <line38> ? finalWorstConfidenceValue / maxWeight <line39> : finalWorstConfidenceValue; <line40> result.setConfidence(normalizedConfidence); <line41> result.setFinalWorstConfidenceValue(finalWorstConfidenceValue); <line42> if (normalizedConfidence < minConfidenceValue) { <line43> if (LOGGER.isDebugEnabled()) { <line44> } <line45> return MFB.NonMatchResult.wrap(result); <line46> } <line47> return result; <line48> } <line49> } <line50> 	<line44>
6428	public class A { <line0> private Method getSetterMethod(S step, String propertyName, Class<?> expectedType) { <line1> Method setterMethod = null; <line2> String setterName = ClassUtils.setter(propertyName); <line3> try { <line4> setterMethod = step.getClass().getMethod(setterName, expectedType); <line5> } catch (Exception e) { <line6> try { <line7> setterName = getSetterName(propertyName); <line8> setterMethod = step.getClass().getMethod(setterName, expectedType); <line9> } catch (Exception e1) { <line10> } <line11> } <line12> return setterMethod; <line13> } <line14> } <line15> 	<line10>
6429	public class A { <line0> void removeJobFromQueue(JobKey key, boolean sendToSpawn) { <line1> minionStateLock.lock(); <line2> try { <line3> for (Iterator<CommandTaskKick> iter = jobQueue.iterator(); iter.hasNext(); ) { <line4> CommandTaskKick kick = iter.next(); <line5> if (kick.getJobKey().matches(key)) { <line6> if (sendToSpawn) { <line7> try { <line8> sendStatusMessage( <line9> new StatusTaskEnd(uuid, kick.getJobUuid(), kick.getNodeID(), 0, 0, 0)); <line10> } catch (Exception ex) { <line11> } <line12> } <line13> iter.remove(); <line14> } <line15> } <line16> } finally { <line17> minionStateLock.unlock(); <line18> } <line19> } <line20> } <line21> 	<line6>, <line11>
6430	"public class A { <line0> @Before <line1> public void setup() { <line2> system = TestUtils.getInstance(); <line3> system.start(); <line4> userService = system.getServiceFactory().getUserService(); <line5> admin = userService.findAdminUser(); <line6> try { <line7> Class.forName(""org.apache.derby.jdbc.EmbeddedDriver""); <line8> DriverManager.getConnection(""jdbc:derby:memory:argus;create=true"").close(); <line9> } catch (Exception ex) { <line10> LoggerFactory.getLogger(AlertServiceTest.class) <line11> fail(""Exception during database startup.""); <line12> } <line13> alertDefinitionsCache = new AlertDefinitionsCache(refreshThreadMock); <line14> } <line15> } <line16> "	<line11>
6431	"public class A { <line0> private long renewToken(Token token, String metaStoreUri, String hiveMetaStorePrincipal) { <line1> HCatClient hcatClient = null; <line2> if (UserGroupInformation.isSecurityEnabled()) { <line3> try { <line4> String tokenStr = token.encodeToUrlString(); <line5> HiveConf hcatConf = createHiveConf(metaStoreUri, hiveMetaStorePrincipal); <line6> hcatClient = HCatClient.create(hcatConf); <line7> Long expiryTime = hcatClient.renewDelegationToken(tokenStr); <line8> return expiryTime; <line9> } catch (Exception ex) { <line10> throw new RuntimeException(""Failed to renew delegation tokens."", ex); <line11> } finally { <line12> if (hcatClient != null) { <line13> try { <line14> hcatClient.close(); <line15> } catch (HCatException e) { <line16> } <line17> } <line18> } <line19> } else { <line20> throw new RuntimeException(""Security is not enabled for Hadoop""); <line21> } <line22> } <line23> } <line24> "	<line6>, <line8>, <line16>
6432	public class A { <line0> @Override <line1> public boolean propogateKey() { <line2> if ((seenIgnore && count > maxUids) || !quarantinedIds.isEmpty()) return true; <line3> HashSet<String> uidsCopy = new HashSet<>(uids); <line4> uidsCopy.removeAll(uidsToRemove); <line5> if (log.isDebugEnabled()) { <line6> } <line7> if (count <= 0 && uidsCopy.isEmpty()) return false; <line8> else return true; <line9> } <line10> } <line11> 	<line6>
6433	"public class A { <line0> @Override <line1> public void onMessage(final Message m) { <line2> TextMessage tm = (TextMessage) m; <line3> count++; <line4> try { <line5> if (count == 1) { <line6> if (!""a"".equals(tm.getText())) { <line7> failed(""Should be a but was "" + tm.getText()); <line8> latch.countDown(); <line9> } <line10> throw new RuntimeException(""Aardvark""); <line11> } else if (count == 2) { <line12> if (sess.getAcknowledgeMode() == Session.AUTO_ACKNOWLEDGE <line13> || sess.getAcknowledgeMode() == Session.DUPS_OK_ACKNOWLEDGE) { <line14> if (!""a"".equals(tm.getText())) { <line15> failed(""Should be a but was "" + tm.getText()); <line16> latch.countDown(); <line17> } <line18> if (!tm.getJMSRedelivered()) { <line19> failed(""Message was supposed to be a redelivery""); <line20> latch.countDown(); <line21> } <line22> } else { <line23> if (!""b"".equals(tm.getText())) { <line24> failed(""Should be b but was "" + tm.getText()); <line25> latch.countDown(); <line26> } <line27> } <line28> } else if (count == 3) { <line29> if (sess.getAcknowledgeMode() == Session.AUTO_ACKNOWLEDGE <line30> || sess.getAcknowledgeMode() == Session.DUPS_OK_ACKNOWLEDGE) { <line31> if (!""b"".equals(tm.getText())) { <line32> failed(""Should be b but was "" + tm.getText()); <line33> latch.countDown(); <line34> } <line35> } else { <line36> if (!""c"".equals(tm.getText())) { <line37> failed(""Should be c but was "" + tm.getText()); <line38> latch.countDown(); <line39> } <line40> latch.countDown(); <line41> } <line42> } else if (count == 4) { <line43> if (sess.getAcknowledgeMode() == Session.AUTO_ACKNOWLEDGE <line44> || sess.getAcknowledgeMode() == Session.DUPS_OK_ACKNOWLEDGE) { <line45> if (!""c"".equals(tm.getText())) { <line46> failed(""Should be c but was "" + tm.getText()); <line47> latch.countDown(); <line48> } <line49> latch.countDown(); <line50> } else { <line51> failed(""Shouldn't get a 4th message""); <line52> latch.countDown(); <line53> } <line54> } <line55> } catch (JMSException e) { <line56> failed(""Got a JMSException "" + e.toString()); <line57> latch.countDown(); <line58> } <line59> } <line60> } <line61> "	<line56>
6434	"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> @Override <line2> public boolean containsPerson(GluuCustomPerson person) { <line3> boolean result = false; <line4> try { <line5> result = persistenceEntryManager.contains(GluuCustomPerson.class); <line6> } catch (Exception e) { <line7> } <line8> return result; <line9> } <line10> } <line11> "	<line7>
6435	"public class A { <line0> @Ignore <line1> @Test <line2> public void findAllUsers() { <line3> UserSearchForm searchForm = new UserSearchForm(); <line4> searchForm.setSelectedLanguage(UserLanguage.ENGLISH); <line5> Pageable pageable = new PageRequest(0, 10, Sort.Direction.ASC, ""firstName""); <line6> Page<User> usersPage = userService.findAll(pageable, searchForm); <line7> assertEquals(5, usersPage.getTotalElements()); <line8> } <line9> } <line10> "	<line7>
6436	"public class A { <line0> @Test <line1> public void test_binSeq_03() { <line2> checkOverlap( <line3> ""acgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgt"", ""acgt"", 0, 0); <line4> } <line5> } <line6> "	<line2>
6437	public class A { <line0> @Override <line1> public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) { <line2> } <line3> } <line4> 	<line2>
6438	public class A { <line0> public Long countLeaveEarlierByEmployeeCycleYearAndMonth( <line1> List<String> employeeNames, String cycleYear, String cycleMonth) throws Exception { <line2> if (employeeNames == null || employeeNames.size() == 0) { <line3> return null; <line4> } <line5> EntityManager em = this.entityManagerContainer().get(AttendanceDetail.class); <line6> CriteriaBuilder cb = em.getCriteriaBuilder(); <line7> CriteriaQuery<Long> cq = cb.createQuery(Long.class); <line8> Root<AttendanceDetail> root = cq.from(AttendanceDetail.class); <line9> Predicate p = root.get(AttendanceDetail_.empName).in(employeeNames); <line10> p = cb.and(p, cb.equal(root.get(AttendanceDetail_.recordStatus), 1)); <line11> p = cb.and(p, cb.isTrue(root.get(AttendanceDetail_.isLeaveEarlier))); <line12> if (cycleYear == null || cycleYear.isEmpty()) { <line13> } else { <line14> p = cb.and(p, cb.equal(root.get(AttendanceDetail_.cycleYear), cycleYear)); <line15> } <line16> if (cycleMonth == null || cycleMonth.isEmpty()) { <line17> } else { <line18> p = cb.and(p, cb.equal(root.get(AttendanceDetail_.cycleMonth), cycleMonth)); <line19> } <line20> cq.select(cb.count(root)); <line21> return em.createQuery(cq.where(p)).getSingleResult(); <line22> } <line23> } <line24> 	<line3>, <line13>, <line17>
6439	public class A { <line0> private void unregisterCommand(final ServiceRegistration<?> serviceRegistration) { <line1> try { <line2> serviceRegistration.unregister(); <line3> } catch (final IllegalStateException ex) { <line4> } <line5> } <line6> } <line7> 	<line4>
6440	public class A { <line0> public Object getJsonFieldValue(JSONObject jsonObject) { <line1> Object fieldValue = null; <line2> if (mNestedFields != null) { <line3> Object finalValue = null; <line4> for (int i = 0; i < mNestedFields.length; i++) { <line5> if (!jsonObject.containsKey(mNestedFields[i])) { <line6> break; <line7> } <line8> if (i < (mNestedFields.length - 1)) { <line9> jsonObject = (JSONObject) jsonObject.get(mNestedFields[i]); <line10> } else { <line11> finalValue = jsonObject.get(mNestedFields[i]); <line12> } <line13> } <line14> fieldValue = finalValue; <line15> } else { <line16> fieldValue = jsonObject.get(mConfig.getMessageTimestampName()); <line17> } <line18> return fieldValue; <line19> } <line20> } <line21> 	<line6>
6441	public class A { <line0> @Override <line1> public List<Project> getProjects(String key, String value, UserInfo userInfo) <line2> throws InvalidProtocolBufferException, ExecutionException, InterruptedException { <line3> FindProjects findProjects = <line4> FindProjects.newBuilder() <line5> .addPredicates( <line6> KeyValueQuery.newBuilder() <line7> .setKey(key) <line8> .setValue(Value.newBuilder().setStringValue(value).build()) <line9> .setOperator(OperatorEnum.Operator.EQ) <line10> .setValueType(ValueTypeEnum.ValueType.STRING) <line11> .build()) <line12> .build(); <line13> ProjectPaginationDTO projectPaginationDTO = <line14> findProjects(findProjects, null, userInfo, ResourceVisibility.PRIVATE); <line15> return projectPaginationDTO.getProjects(); <line16> } <line17> } <line18> 	<line15>
6442	public class A { <line0> @Override <line1> public QanaryMessage process(QanaryMessage myQanaryMessage) throws Exception { <line2> long startTime = System.currentTimeMillis(); <line3> QanaryUtils myQanaryUtils = this.getUtils(myQanaryMessage); <line4> QanaryQuestion<String> myQanaryQuestion = this.getQanaryQuestion(myQanaryMessage); <line5> String myQuestion = myQanaryQuestion.getTextualRepresentation(); <line6> Detector detector = DetectorFactory.create(); <line7> detector.append(myQuestion); <line8> String lang = detector.detect(); <line9> myQanaryQuestion.setLanguageText(lang); <line10> return myQanaryMessage; <line11> } <line12> } <line13> 	<line3>, <line6>, <line9>
6443	"public class A { <line0> private void openGoogleForm() { <line1> String url = ""https://goo.gl/CC65By""; <line2> if (Desktop.isDesktopSupported()) { <line3> Desktop desktop = Desktop.getDesktop(); <line4> if (desktop.isSupported(java.awt.Desktop.Action.BROWSE)) { <line5> try { <line6> URI uri = new URI(url); <line7> desktop.browse(uri); <line8> } catch (IOException | URISyntaxException ex) { <line9> } <line10> } <line11> } else { <line12> JOptionPane.showMessageDialog(this, i18n.msg(""goto"") + url); <line13> } <line14> } <line15> } <line16> "	<line9>
6444	"public class A { <line0> @DELETE <line1> @Path(""preparedqueries"") <line2> @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN}) <line3> public APIResult destroyPreparedQueries( <line4> @QueryParam(""sessionid"") LensSessionHandle sessionid, <line5> @DefaultValue("""") @QueryParam(""user"") String user, <line6> @DefaultValue("""") @QueryParam(""queryName"") String queryName, <line7> @QueryParam(""fromDate"") String fromDate, <line8> @QueryParam(""toDate"") String toDate) <line9> throws LensException { <line10> validateSessionId(sessionid); <line11> int numDestroyed = 0; <line12> boolean failed = false; <line13> List<QueryPrepareHandle> handles = null; <line14> try { <line15> handles = getAllPreparedQueries(sessionid, user, queryName, fromDate, toDate); <line16> for (QueryPrepareHandle prepared : handles) { <line17> if (queryServer.destroyPrepared(sessionid, prepared)) { <line18> numDestroyed++; <line19> } <line20> } <line21> } catch (Exception e) { <line22> failed = true; <line23> } <line24> String msgString = (StringUtils.isBlank(user) ? """" : "" for user "" + user); <line25> if (handles != null && numDestroyed == handles.size()) { <line26> return new APIResult( <line27> Status.SUCCEEDED, ""Destroy all prepared "" + ""queries "" + msgString + "" is successful""); <line28> } else { <line29> assert (failed); <line30> if (numDestroyed == 0) { <line31> return new APIResult( <line32> Status.FAILED, ""Destroy all prepared "" + ""queries "" + msgString + "" has failed""); <line33> } else { <line34> return new APIResult( <line35> Status.PARTIAL, ""Destroy all prepared "" + ""queries "" + msgString + "" is partial""); <line36> } <line37> } <line38> } <line39> } <line40> "	<line22>
6445	public class A { <line0> @Override <line1> public FileTime lastModifiedTime() { <line2> if (file == null) { <line3> return null; <line4> } <line5> FileTime time = null; <line6> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line7> final Date date = file.getLastModifiedDate(); <line8> if (date != null) { <line9> time = FileTime.fromMillis(date.getTime()); <line10> } <line11> tx.success(); <line12> } catch (FrameworkException fex) { <line13> } <line14> return time; <line15> } <line16> } <line17> 	<line13>
6446	public class A { <line0> private void addSuggestionMonitoringEntry( <line1> ExecutableSuggestionSearch search, <line2> DocumentFactory factory, <line3> Session session, <line4> HashMap<String, Object> metadata, <line5> ZonedDateTime start, <line6> SuggestionResult result, <line7> ZonedDateTime end) { <line8> try { <line9> final SuggestionEntry entry = <line10> new SuggestionEntry( <line11> this.server, <line12> factory, <line13> application, <line14> search, <line15> result, <line16> start, <line17> end, <line18> result.getQueryTime(), <line19> result.getElapsedTime(), <line20> session); <line21> final HashMap<String, Object> mergedMetadata = new HashMap<>(); <line22> mergedMetadata.putAll(this.monitoringMetadata); <line23> mergedMetadata.putAll(metadata); <line24> entry.setMetadata(mergedMetadata); <line25> logger.log(entry); <line26> } catch (Exception e) { <line27> if (!silent) { <line28> throw e; <line29> } <line30> } <line31> } <line32> } <line33> 	<line25>, <line27>
6447	public class A { <line0> public static boolean isByteValue(int b) { <line1> final boolean valid = ((b & 0xffffff00) == 0 || (b & 0xffffff00) == 0xffffff00); <line2> if (logger.isTraceEnabled() && valid && (b < -128 || b > 127)) { <line3> } <line4> return valid; <line5> } <line6> } <line7> 	<line3>
6448	"public class A { <line0> @Override <line1> public Plugin newWikiPlugin(final String pluginName, final ResourceBundle rb) <line2> throws PluginException { <line3> Plugin plugin = null; <line4> WikiPluginInfo pluginInfo = m_pluginClassMap.get(pluginName); <line5> try { <line6> if (pluginInfo == null) { <line7> pluginInfo = WikiPluginInfo.newInstance(findPluginClass(pluginName)); <line8> registerPlugin(pluginInfo); <line9> } <line10> if (!checkCompatibility(pluginInfo)) { <line11> final String msg = <line12> ""Plugin '"" + pluginInfo.getName() + ""' not compatible with this version of JSPWiki""; <line13> } else { <line14> plugin = pluginInfo.newPluginInstance(m_searchPath, m_externalJars); <line15> } <line16> } catch (final ClassNotFoundException e) { <line17> throw new PluginException( <line18> MessageFormat.format(rb.getString(""plugin.error.couldnotfind""), pluginName), e); <line19> } catch (final InstantiationException e) { <line20> throw new PluginException( <line21> MessageFormat.format(rb.getString(""plugin.error.cannotinstantiate""), pluginName), e); <line22> } catch (final IllegalAccessException e) { <line23> throw new PluginException( <line24> MessageFormat.format(rb.getString(""plugin.error.notallowed""), pluginName), e); <line25> } catch (final Exception e) { <line26> throw new PluginException( <line27> MessageFormat.format(rb.getString(""plugin.error.instantationfailed""), pluginName), e); <line28> } <line29> return plugin; <line30> } <line31> } <line32> "	<line13>
6449	public class A { <line0> void process( <line1> Text key, <line2> Reducer<Text, BytesWritable, Text, Text>.Context context, <line3> Iterable<BytesWritable> documents, <line4> int maxNumberOfDocuments) <line5> throws IOException, InterruptedException { <line6> Iterator<BytesWritable> docsIterator = documents.iterator(); <line7> int partNb = 1; <line8> while (docsIterator.hasNext()) { <line9> int counter = 0; <line10> List<DocumentProtos.DocumentMetadata> metadataList = <line11> new ArrayList<DocumentProtos.DocumentMetadata>(); <line12> while (counter < maxNumberOfDocuments && docsIterator.hasNext()) { <line13> DocumentProtos.DocumentWrapper docWrapper = <line14> DocumentProtos.DocumentWrapper.parseFrom(docsIterator.next().copyBytes()); <line15> metadataList.add(docWrapper.getDocumentMetadata()); <line16> counter++; <line17> } <line18> if (counter > 0) { <line19> if (isDebugMode(context.getConfiguration())) { <line20> StringBuilder debugInfo = new StringBuilder(); <line21> duplicateWorkService.findDuplicates(metadataList, debugInfo); <line22> context.write(key, new Text(debugInfo.toString())); <line23> } else { <line24> Map<Integer, Set<DocumentProtos.DocumentMetadata>> duplicateWorksMap = <line25> duplicateWorkService.findDuplicates(metadataList, null); <line26> saveDuplicatesToContext(duplicateWorksMap, key, context); <line27> } <line28> context.progress(); <line29> } <line30> partNb++; <line31> } <line32> } <line33> } <line34> 	<line7>, <line19>, <line32>
6450	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (Thread.currentThread().isInterrupted()) { <line4> return; <line5> } <line6> authorizationDriver.publishAuthUpdate(systemId); <line7> } catch (final Throwable ex) { <line8> } <line9> } <line10> } <line11> 	<line3>, <line4>, <line8>
6451	public class A { <line0> public StgSysExportZos merge(StgSysExportZos detachedInstance) { <line1> try { <line2> StgSysExportZos result = <line3> (StgSysExportZos) sessionFactory.getCurrentSession().merge(detachedInstance); <line4> return result; <line5> } catch (RuntimeException re) { <line6> throw re; <line7> } <line8> } <line9> } <line10> 	<line1>, <line4>, <line6>
6452	"public class A { <line0> public static java.io.File getFileCustom(JFileChooser fileChooser) { <line1> fileChooser.rescanCurrentDirectory(); <line2> int retVal = fileChooser.showDialog(null, Bundle.getMessage(""MenuItemLoad"")); <line3> if (retVal != JFileChooser.APPROVE_OPTION) { <line4> return null; <line5> } <line6> if (log.isDebugEnabled()) { <line7> } <line8> return fileChooser.getSelectedFile(); <line9> } <line10> } <line11> "	<line7>
6453	"public class A { <line0> @PatchMapping(CommonConstants.PATH_ID) <line1> @Secured(ServicesData.ROLE_UPDATE_SECURITY_PROFILES) <line2> public SecurityProfileDto patch( <line3> final @PathVariable(""id"") String id, @RequestBody final Map<String, Object> partialDto) { <line4> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line5> Assert.isTrue( <line6> StringUtils.equals(id, (String) partialDto.get(""id"")), <line7> ""The DTO identifier must match the path identifier for update.""); <line8> return securityProfileExternalService.patch(partialDto); <line9> } <line10> } <line11> "	<line4>
6454	"public class A { <line0> @Override <line1> public void onDeviceAdded(Bridge bridge, Device device) { <line2> ThingUID thingUID = null; <line3> switch (device.getType()) { <line4> case WallMountedThermostat: <line5> thingUID = <line6> new ThingUID( <line7> MaxBindingConstants.WALLTHERMOSTAT_THING_TYPE, <line8> bridge.getUID(), <line9> device.getSerialNumber()); <line10> break; <line11> case HeatingThermostat: <line12> thingUID = <line13> new ThingUID( <line14> MaxBindingConstants.HEATINGTHERMOSTAT_THING_TYPE, <line15> bridge.getUID(), <line16> device.getSerialNumber()); <line17> break; <line18> case HeatingThermostatPlus: <line19> thingUID = <line20> new ThingUID( <line21> MaxBindingConstants.HEATINGTHERMOSTATPLUS_THING_TYPE, <line22> bridge.getUID(), <line23> device.getSerialNumber()); <line24> break; <line25> case ShutterContact: <line26> thingUID = <line27> new ThingUID( <line28> MaxBindingConstants.SHUTTERCONTACT_THING_TYPE, <line29> bridge.getUID(), <line30> device.getSerialNumber()); <line31> break; <line32> case EcoSwitch: <line33> thingUID = <line34> new ThingUID( <line35> MaxBindingConstants.ECOSWITCH_THING_TYPE, <line36> bridge.getUID(), <line37> device.getSerialNumber()); <line38> break; <line39> default: <line40> break; <line41> } <line42> if (thingUID != null) { <line43> String name = device.getName(); <line44> if (name.isEmpty()) { <line45> name = device.getSerialNumber(); <line46> } <line47> DiscoveryResult discoveryResult = <line48> DiscoveryResultBuilder.create(thingUID) <line49> .withProperty(Thing.PROPERTY_SERIAL_NUMBER, device.getSerialNumber()) <line50> .withBridge(bridge.getUID()) <line51> .withLabel(device.getType() + "": "" + name) <line52> .withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER) <line53> .build(); <line54> thingDiscovered(discoveryResult); <line55> } else { <line56> } <line57> } <line58> } <line59> "	<line2>, <line56>
6455	public class A { <line0> synchronized void addPacket(short apid, long instant, short seq) throws RocksDBException { <line1> YRDB db = tablespace.getRdb(); <line2> RocksIterator it = tablespace.getRdb().newIterator(); <line3> try { <line4> it.seek(Record.key(tbsIndex, apid, instant, seq)); <line5> int cright, cleft; <line6> Record rright, rleft; <line7> while (true) { <line8> assert (it.isValid()); <line9> rright = new Record(it.key(), it.value()); <line10> cright = compare(apid, instant, seq, rright); <line11> if (cright == 0) { <line12> if (log.isTraceEnabled()) { <line13> } <line14> return; <line15> } else if (cright < 0) { <line16> break; <line17> } else { <line18> it.next(); <line19> } <line20> } <line21> it.prev(); <line22> rleft = new Record(it.key(), it.value()); <line23> cleft = compare(apid, instant, seq, rleft); <line24> if (cleft == 0) { <line25> if (log.isTraceEnabled()) { <line26> } <line27> return; <line28> } <line29> if ((cleft == 1) && (cright == -1)) { <line30> rleft.seqLast = rright.seqLast; <line31> rleft.lastTime = rright.lastTime; <line32> rleft.numPackets += rright.numPackets + 1; <line33> db.put(rleft.key(tbsIndex), rleft.val()); <line34> db.delete(rright.key(tbsIndex)); <line35> } else if (cleft == 1) { <line36> rleft.seqLast = seq; <line37> rleft.lastTime = instant; <line38> rleft.numPackets++; <line39> db.put(rleft.key(tbsIndex), rleft.val()); <line40> } else if (cright == -1) { <line41> db.delete(rright.key(tbsIndex)); <line42> rright.seqFirst = seq; <line43> rright.firstTime = instant; <line44> rright.numPackets++; <line45> db.put(rright.key(tbsIndex), rright.val()); <line46> } else { <line47> Record r = new Record(apid, instant, seq, 1); <line48> db.put(r.key(tbsIndex), r.val()); <line49> } <line50> } finally { <line51> it.close(); <line52> } <line53> } <line54> } <line55> 	<line13>, <line26>
6456	"public class A { <line0> private static Query buildQuery(String keyword) { <line1> try { <line2> Analyzer analyzer = createAnalyzer(); <line3> QueryParser queryParser1 = new QueryParser(""text"", analyzer); <line4> Query termQuery1 = queryParser1.parse(keyword); <line5> BooleanClause booleanClause1 = new BooleanClause(termQuery1, BooleanClause.Occur.SHOULD); <line6> QueryParser queryParser2 = new QueryParser(""title"", analyzer); <line7> Query termQuery2 = queryParser2.parse(keyword); <line8> BooleanClause booleanClause2 = new BooleanClause(termQuery2, BooleanClause.Occur.SHOULD); <line9> BooleanQuery.Builder builder = new BooleanQuery.Builder(); <line10> builder.add(booleanClause1).add(booleanClause2); <line11> return builder.build(); <line12> } catch (ParseException e) { <line13> } <line14> return null; <line15> } <line16> } <line17> "	<line13>
6457	public class A { <line0> private String _toJSON(DataDefinition dataDefinition, DataRecord dataRecord) { <line1> try { <line2> return DataStorageUtil.toJSON(dataDefinition, dataRecord.getDataRecordValues()); <line3> } catch (Exception exception) { <line4> if (_log.isDebugEnabled()) { <line5> } <line6> return StringPool.BLANK; <line7> } <line8> } <line9> } <line10> 	<line5>
6458	public class A { <line0> void addDependencySet( <line1> final DependencySet dependencySet, <line2> final Archiver archiver, <line3> final AssemblerConfigurationSource configSource) <line4> throws AssemblyFormattingException, ArchiveCreationException, <line5> InvalidAssemblerConfigurationException { <line6> if (!dependencySet.isUseTransitiveDependencies() && dependencySet.isUseTransitiveFiltering()) { <line7> } <line8> final Set<Artifact> dependencyArtifacts = resolveDependencyArtifacts(dependencySet); <line9> if (!unpackTransformsContent(dependencySet) && dependencyArtifacts.size() > 1) { <line10> checkMultiArtifactOutputConfig(dependencySet); <line11> } <line12> InputStreamTransformer fileSetTransformers = <line13> isUnpackWithOptions(dependencySet) <line14> ? ReaderFormatter.getFileSetTransformers( <line15> configSource, <line16> dependencySet.getUnpackOptions().isFiltered(), <line17> dependencySet.getUnpackOptions().getLineEnding()) <line18> : null; <line19> for (final Artifact depArtifact : dependencyArtifacts) { <line20> ProjectBuildingRequest pbr = getProjectBuildingRequest(configSource); <line21> MavenProject depProject; <line22> try { <line23> ProjectBuildingResult build = projectBuilder1.build(depArtifact, pbr); <line24> depProject = build.getProject(); <line25> } catch (final ProjectBuildingException e) { <line26> depProject = buildProjectStub(depArtifact); <line27> } <line28> if (NON_ARCHIVE_DEPENDENCY_TYPES.contains(depArtifact.getType())) { <line29> addNonArchiveDependency(depArtifact, depProject, dependencySet, archiver, configSource); <line30> } else { <line31> addNormalArtifact( <line32> dependencySet, depArtifact, depProject, archiver, configSource, fileSetTransformers); <line33> } <line34> } <line35> } <line36> } <line37> 	<line6>, <line7>, <line12>, <line26>
6459	public class A { <line0> public Iterator<ITuple> search( <line1> DataRequest dataRequest, <line2> CubeInstance cube, <line3> StreamingTupleConverter tupleConverter, <line4> RecordsSerializer recordsSerializer, <line5> ReplicaSet rs, <line6> TupleInfo tupleInfo) <line7> throws Exception { <line8> List<Node> receivers = Lists.newArrayList(rs.getNodes()); <line9> Node queryReceiver = findBestReceiverServeQuery(receivers, cube.getName()); <line10> IOException exception; <line11> try { <line12> return doSearch( <line13> dataRequest, cube, tupleConverter, recordsSerializer, queryReceiver, tupleInfo); <line14> } catch (IOException e) { <line15> exception = e; <line16> failedReceivers.put(queryReceiver, System.currentTimeMillis()); <line17> } <line18> for (int i = 0; i < receivers.size(); i++) { <line19> Node receiver = receivers.get(i); <line20> if (receiver.equals(queryReceiver)) { <line21> continue; <line22> } <line23> try { <line24> return doSearch(dataRequest, cube, tupleConverter, recordsSerializer, receiver, tupleInfo); <line25> } catch (IOException e) { <line26> exception = e; <line27> failedReceivers.put(receiver, System.currentTimeMillis()); <line28> } <line29> } <line30> throw exception; <line31> } <line32> } <line33> 	<line17>, <line28>
6460	"public class A { <line0> @Override <line1> public void connectionLost(SocketAddress sa) { <line2> String msg = ""lost memcached connection ["" + sa + ""] reconnecting...""; <line3> } <line4> } <line5> "	<line3>
6461	public class A { <line0> public static boolean checkProtectionChanged( <line1> VirtualPool from, FileVirtualPoolProtectionUpdateParam to) { <line2> if (to == null) { <line3> return false; <line4> } <line5> if (to.getScheduleSnapshots() != from.getScheduleSnapshots() <line6> || to.getReplicationSupported() != from.getFileReplicationSupported() <line7> || to.getAllowFilePolicyAtProjectLevel() != from.getAllowFilePolicyAtProjectLevel() <line8> || to.getAllowFilePolicyAtFSLevel() != from.getAllowFilePolicyAtFSLevel()) { <line9> return true; <line10> } <line11> if (to.getMinRpoType() != from.getFrRpoType() || to.getMinRpoValue() != from.getFrRpoValue()) { <line12> return true; <line13> } <line14> return false; <line15> } <line16> } <line17> 	<line3>, <line9>, <line12>, <line14>
6462	"public class A { <line0> @Override <line1> public void validate() { <line2> super.validate(); <line3> if (this.getFieldErrors().isEmpty()) { <line4> try { <line5> Content publishingContent = this.getContentManager().loadContent(this.getContentId(), true); <line6> if (null == publishingContent) { <line7> this.addFieldError(""contentId"", this.getText(""error.widget.viewer.nullContent"")); <line8> } else { <line9> IPage currentPage = this.getCurrentPage(); <line10> if (!CmsPageUtil.isContentPublishableOnPageDraft(publishingContent, currentPage)) { <line11> PageMetadata metadata = currentPage.getMetadata(); <line12> List<String> pageGroups = new ArrayList<String>(); <line13> pageGroups.add(currentPage.getGroup()); <line14> if (null != metadata.getExtraGroups()) { <line15> pageGroups.addAll(metadata.getExtraGroups()); <line16> } <line17> this.addFieldError( <line18> ""contentId"", <line19> this.getText( <line20> ""error.widget.viewer.invalidContent"", new String[] {pageGroups.toString()})); <line21> } <line22> } <line23> } catch (Throwable t) { <line24> throw new RuntimeException( <line25> ""Errore in validazione contenuto con id "" + this.getContentId(), t); <line26> } <line27> } <line28> if (this.getFieldErrors().size() > 0) { <line29> try { <line30> this.createValuedShowlet(); <line31> } catch (Throwable t) { <line32> throw new RuntimeException(""Errore in creazione widget valorizzato"", t); <line33> } <line34> } <line35> } <line36> } <line37> "	<line24>, <line32>
6463	"public class A { <line0> @SuppressWarnings(""squid:S2583"") <line1> @SuppressFBWarnings( <line2> justification = <line3> ""yes, there is a redundant null check in the catch - to suppress warnings we are leaving"" <line4> + "" the null check"", <line5> value = {""RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE""}) <line6> public HttpURLConnection createHttpURLConnection(URL url) throws URLConnectionFailureException { <line7> HttpURLConnection conn = null; <line8> final String proxyHost = settings.getString(Settings.KEYS.PROXY_SERVER); <line9> try { <line10> if (proxyHost != null && !matchNonProxy(url)) { <line11> final int proxyPort = settings.getInt(Settings.KEYS.PROXY_PORT); <line12> final SocketAddress address = new InetSocketAddress(proxyHost, proxyPort); <line13> final String username = settings.getString(Settings.KEYS.PROXY_USERNAME); <line14> final String password = settings.getString(Settings.KEYS.PROXY_PASSWORD); <line15> if (username != null && password != null) { <line16> final Authenticator auth = <line17> new Authenticator() { <line18> @Override <line19> public PasswordAuthentication getPasswordAuthentication() { <line20> if (proxyHost.equals(getRequestingHost()) <line21> || getRequestorType().equals(Authenticator.RequestorType.PROXY)) { <line22> if (settings.getBoolean(Settings.KEYS.PROXY_DISABLE_SCHEMAS, true)) { <line23> System.setProperty(""jdk.http.auth.tunneling.disabledSchemes"", """"); <line24> } <line25> return new PasswordAuthentication(username, password.toCharArray()); <line26> } <line27> return super.getPasswordAuthentication(); <line28> } <line29> }; <line30> Authenticator.setDefault(auth); <line31> } <line32> final Proxy proxy = new Proxy(Proxy.Type.HTTP, address); <line33> conn = (HttpURLConnection) url.openConnection(proxy); <line34> } else { <line35> conn = (HttpURLConnection) url.openConnection(); <line36> } <line37> final int connectionTimeout = settings.getInt(Settings.KEYS.CONNECTION_TIMEOUT, 10000); <line38> conn.setConnectTimeout(connectionTimeout); <line39> conn.setInstanceFollowRedirects(true); <line40> } catch (IOException ex) { <line41> if (conn != null) { <line42> try { <line43> conn.disconnect(); <line44> } finally { <line45> conn = null; <line46> } <line47> } <line48> throw new URLConnectionFailureException(""Error getting connection."", ex); <line49> } <line50> configureTLS(url, conn); <line51> addAuthenticationIfPresent(conn); <line52> return conn; <line53> } <line54> } <line55> "	<line22>
6464	"public class A { <line0> private synchronized void discover() { <line1> MulticastListener epsonMulticastListener; <line2> String local = ""127.0.0.1""; <line3> try { <line4> String ip = networkAddressService.getPrimaryIpv4HostAddress(); <line5> epsonMulticastListener = new MulticastListener((ip != null ? ip : local)); <line6> } catch (SocketException se) { <line7> return; <line8> } catch (IOException ioe) { <line9> return; <line10> } <line11> while (!terminate) { <line12> boolean beaconReceived; <line13> try { <line14> beaconReceived = epsonMulticastListener.waitForBeacon(); <line15> } catch (IOException ioe) { <line16> beaconReceived = false; <line17> } <line18> if (beaconReceived) { <line19> Map<String, Object> properties = new HashMap<>(); <line20> String uid = epsonMulticastListener.getUID(); <line21> properties.put(THING_PROPERTY_HOST, epsonMulticastListener.getIPAddress()); <line22> properties.put(THING_PROPERTY_PORT, DEFAULT_PORT); <line23> ThingUID thingUid = new ThingUID(THING_TYPE_PROJECTOR_TCP, uid); <line24> thingDiscovered( <line25> DiscoveryResultBuilder.create(thingUid) <line26> .withProperties(properties) <line27> .withLabel(""Epson Projector "" + uid) <line28> .withProperty(THING_PROPERTY_MAC, uid) <line29> .withRepresentationProperty(THING_PROPERTY_MAC) <line30> .build()); <line31> } <line32> } <line33> epsonMulticastListener.shutdown(); <line34> } <line35> } <line36> "	<line1>, <line7>, <line9>, <line16>, <line23>, <line24>, <line34>
6465	public class A { <line0> public void unwrap(VaultPackage pack, boolean force, boolean autoSave) <line1> throws RepositoryException, IOException { <line2> if (!force && isUnwrapped()) { <line3> return; <line4> } <line5> long now = System.currentTimeMillis(); <line6> unwrap(pack == null ? null : pack.getArchive(), autoSave); <line7> if (log.isDebugEnabled()) { <line8> } <line9> } <line10> } <line11> 	<line5>, <line8>
6466	public class A { <line0> @Override <line1> public void registerRequestHandler(String appId, RequestHandler requestHandler) { <line2> this.registeredRequestHandlers.put(appId, requestHandler); <line3> if (isConnected()) { <line4> try { <line5> publishAppCertificate(); <line6> } catch (KuraException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6467	"public class A { <line0> @Override <line1> public List<TaggerCrisis> getCrisesByUserId(Integer userId) throws AidrException { <line2> Client client = ClientBuilder.newBuilder().register(JacksonFeature.class).build(); <line3> try { <line4> WebTarget webResource = client.target(taggerMainUrl + ""/crisis?userID="" + userId); <line5> ObjectMapper objectMapper = JacksonWrapper.getObjectMapper(); <line6> objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false); <line7> Response clientResponse = webResource.request(MediaType.APPLICATION_JSON).get(); <line8> String jsonResponse = clientResponse.readEntity(String.class); <line9> TaggerAllCrisesResponse taggerAllCrisesResponse = <line10> objectMapper.readValue(jsonResponse, TaggerAllCrisesResponse.class); <line11> if (taggerAllCrisesResponse.getCrisises() != null) { <line12> } <line13> return taggerAllCrisesResponse.getCrisises(); <line14> } catch (Exception e) { <line15> throw new AidrException( <line16> ""No collection is enabled for Tagger. Please enable tagger for one of your collections."", <line17> e); <line18> } <line19> } <line20> } <line21> "	<line12>, <line15>
6468	public class A { <line0> @Override <line1> public void create(Object key, Object value) throws IOException { <line2> long start = stats.startUpdate(); <line3> Collection<Document> docs = Collections.emptyList(); <line4> boolean exceptionHappened = false; <line5> try { <line6> try { <line7> docs = serializer.toDocuments(index, value); <line8> } catch (Exception e) { <line9> exceptionHappened = true; <line10> stats.incFailedEntries(); <line11> } <line12> if (!exceptionHappened) { <line13> docs.forEach(doc -> SerializerUtil.addKey(key, doc)); <line14> writer.addDocuments(docs); <line15> } <line16> } finally { <line17> stats.endUpdate(start); <line18> } <line19> } <line20> } <line21> 	<line11>
6469	public class A { <line0> @Override <line1> protected void checkExpiringObjects() { <line2> for (SingularityExpiringMachineState expiringObject : rackManager.getExpiringObjects()) { <line3> if (isExpiringDue(expiringObject)) { <line4> Optional<SingularityRack> rack = rackManager.getObject(expiringObject.getMachineId()); <line5> if (!rack.isPresent()) { <line6> } else { <line7> try { <line8> handleExpiringObject(expiringObject, rack.get(), getMessage(expiringObject)); <line9> } catch (Exception e) { <line10> } <line11> } <line12> rackManager.deleteExpiringObject(expiringObject.getMachineId()); <line13> } <line14> } <line15> } <line16> } <line17> 	<line6>, <line10>
6470	public class A { <line0> public ScheduledFuture<?> schedule(final Runnable task, long delay) { <line1> if (task == null) { <line2> return null; <line3> } <line4> return getProvider().getScheduler().schedule(task, delay, TimeUnit.MILLISECONDS); <line5> } <line6> } <line7> 	<line2>
6471	"public class A { <line0> @AfterClass <line1> public static void reportTest() { <line2> LOGGER.warn(""-----------------------------------------""); <line3> LOGGER.warn(""*                                       *""); <line4> } <line5> } <line6> "	<line4>
6472	public class A { <line0> public void executeTransaction( <line1> int serviceId, <line2> String interfaceName, <line3> int txId, <line4> byte[] arguments, <line5> BlockchainData blockchainData, <line6> int callerServiceId, <line7> HashCode txMessageHash, <line8> PublicKey authorPublicKey) { <line9> synchronized (lock) { <line10> ServiceWrapper service = getServiceById(serviceId); <line11> ExecutionContext context = <line12> newContext(service, blockchainData) <line13> .txMessageHash(txMessageHash) <line14> .authorPk(authorPublicKey) <line15> .build(); <line16> try { <line17> service.executeTransaction(interfaceName, txId, arguments, callerServiceId, context); <line18> } catch (Exception e) { <line19> throw e; <line20> } <line21> } <line22> } <line23> } <line24> 	<line19>
6473	public class A { <line0> @Override <line1> public void load(final List<Identifiable> proxy, final List<RpslObject> result) { <line2> final Map<Integer, RpslObject> loadedObjects = Maps.newHashMapWithExpectedSize(proxy.size()); <line3> Set<Integer> differences = loadObjects(proxy, loadedObjects); <line4> if (!differences.isEmpty()) { <line5> final Source originalSource = sourceContext.getCurrentSource(); <line6> if (originalSource.getType().equals(Source.Type.SLAVE)) { <line7> final Source masterSource = Source.master(originalSource.getName()); <line8> try { <line9> sourceContext.setCurrent(masterSource); <line10> differences = loadObjects(proxy, loadedObjects); <line11> if (!differences.isEmpty()) { <line12> } <line13> } catch (IllegalSourceException e) { <line14> } finally { <line15> sourceContext.setCurrent(originalSource); <line16> } <line17> } <line18> } <line19> final List<RpslObject> rpslObjects = Lists.newArrayList(loadedObjects.values()); <line20> Collections.sort( <line21> rpslObjects, <line22> new Comparator<RpslObject>() { <line23> final List<Integer> requestedIds = <line24> Lists.newArrayList(Iterables.transform(proxy, input -> input.getObjectId())); <line25>  <line26> @Override <line27> public int compare(final RpslObject o1, final RpslObject o2) { <line28> return requestedIds.indexOf(o1.getObjectId()) - requestedIds.indexOf(o2.getObjectId()); <line29> } <line30> }); <line31> result.addAll(rpslObjects); <line32> } <line33> } <line34> 	<line6>, <line12>, <line14>
6474	"public class A { <line0> static int getExpirationHoursForTable(String tableName, CentralStorageConfig storageConfig) { <line1> if (tableName.startsWith(""trace_"")) { <line2> return storageConfig.traceExpirationHours(); <line3> } else if (tableName.startsWith(""gauge_value_rollup_"")) { <line4> int rollupLevel = Integer.parseInt(tableName.substring(tableName.lastIndexOf('_') + 1)); <line5> if (rollupLevel == 0) { <line6> return storageConfig.rollupExpirationHours().get(rollupLevel); <line7> } else { <line8> return storageConfig.rollupExpirationHours().get(rollupLevel - 1); <line9> } <line10> } else if (tableName.startsWith(""aggregate_tt_query_"") <line11> || tableName.startsWith(""aggregate_tn_query_"") <line12> || tableName.startsWith(""aggregate_tt_service_call_"") <line13> || tableName.startsWith(""aggregate_tn_service_call_"")) { <line14> int rollupLevel = Integer.parseInt(tableName.substring(tableName.lastIndexOf('_') + 1)); <line15> return storageConfig.queryAndServiceCallRollupExpirationHours().get(rollupLevel); <line16> } else if (tableName.startsWith(""aggregate_tt_main_thread_profile_"") <line17> || tableName.startsWith(""aggregate_tn_main_thread_profile_"") <line18> || tableName.startsWith(""aggregate_tt_aux_thread_profile_"") <line19> || tableName.startsWith(""aggregate_tn_aux_thread_profile_"")) { <line20> int rollupLevel = Integer.parseInt(tableName.substring(tableName.lastIndexOf('_') + 1)); <line21> return storageConfig.profileRollupExpirationHours().get(rollupLevel); <line22> } else if (tableName.startsWith(""aggregate_"") || tableName.startsWith(""synthetic_"")) { <line23> int rollupLevel = Integer.parseInt(tableName.substring(tableName.lastIndexOf('_') + 1)); <line24> return storageConfig.rollupExpirationHours().get(rollupLevel); <line25> } else if (tableName.equals(""gauge_name"") || tableName.equals(""agent"")) { <line26> return getMaxRollupExpirationHours(storageConfig); <line27> } else if (tableName.equals(""heartbeat"")) { <line28> return HeartbeatDao.EXPIRATION_HOURS; <line29> } else if (tableName.equals(""resolved_incident"")) { <line30> return Constants.RESOLVED_INCIDENT_EXPIRATION_HOURS; <line31> } else { <line32> return -1; <line33> } <line34> } <line35> } <line36> "	<line32>
6475	public class A { <line0> public static boolean createUpgradeLog() { <line1> try { <line2> if (!upgradeLogPath.getParentFile().exists()) { <line3> upgradeLogPath.getParentFile().mkdirs(); <line4> } <line5> upgradeLogPath.createNewFile(); <line6> upgradeLogWriter = new BufferedWriter(new FileWriter(getUpgradeLogPath(), true)); <line7> return true; <line8> } catch (IOException e) { <line9> return false; <line10> } <line11> } <line12> } <line13> 	<line9>
6476	public class A { <line0> @Override <line1> public void addTransaction(final PageTransactionInfo pageTransaction) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> transactions.put(pageTransaction.getTransactionID(), pageTransaction); <line5> } <line6> } <line7> 	<line3>
6477	public class A { <line0> public org.talend.mdm.webservice.WSString getTransformerPluginV2Configuration( <line1> org.talend.mdm.webservice.WSTransformerPluginV2GetConfiguration arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSString _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	<line2>
6478	public class A { <line0> public Collection<AuthzAuditEvent> getAuthzEvents(Collection<RangerAccessResult> results) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> List<AuthzAuditEvent> ret = null; <line4> if (results != null) { <line5> for (RangerAccessResult result : results) { <line6> AuthzAuditEvent event = getAuthzEvents(result); <line7> if (event == null) { <line8> continue; <line9> } <line10> if (ret == null) { <line11> ret = new ArrayList<>(); <line12> } <line13> ret.add(event); <line14> } <line15> } <line16> if (LOG.isDebugEnabled()) { <line17> } <line18> return ret; <line19> } <line20> } <line21> 	<line2>, <line17>
6479	"public class A { <line0> private OAuthToken prepareNewToken( <line1> OAuthToken oldToken, <line2> String scope, <line3> List<String> oldRequestedScopesList, <line4> long ownerId, <line5> long clientId, <line6> String clientUserName, <line7> boolean createIdToken, <line8> String grant) <line9> throws OAuthErrorException { <line10> OAuthToken newToken = new OAuthToken(oldToken); <line11> List<String> newRequestedScopeList = new ArrayList<>(); <line12> if (scope != null && !scope.isEmpty()) { <line13> newRequestedScopeList.addAll(Arrays.asList(scope.split("" ""))); <line14> } <line15> if (!oldRequestedScopesList.containsAll(newRequestedScopeList)) { <line16> throw new OAuthErrorException(makeError(OAuth2Error.INVALID_SCOPE, ""wrong scope"")); <line17> } <line18> newToken.setRequestedScope(newRequestedScopeList.stream().toArray(String[]::new)); <line19> TranslationResult userInfoRes = getAttributes(clientId, ownerId, grant); <line20> List<ScopeInfo> newValidRequestedScopes = <line21> requestValidator.getValidRequestedScopes( <line22> Scope.parse(String.join("" "", newRequestedScopeList))); <line23> newToken.setEffectiveScope( <line24> newValidRequestedScopes.stream().map(s -> s.getName()).toArray(String[]::new)); <line25> UserInfo userInfoClaimSet = <line26> createUserInfo(newValidRequestedScopes, newToken.getSubject(), userInfoRes); <line27> newToken.setUserInfo(userInfoClaimSet.toJSONObject().toJSONString()); <line28> Date now = new Date(); <line29> if (newRequestedScopeList.contains(OIDCScopeValue.OPENID.getValue()) && createIdToken) { <line30> try { <line31> newToken.setOpenidToken( <line32> createIdToken( <line33> now, newToken, Arrays.asList(new Audience(clientUserName)), userInfoClaimSet)); <line34> } catch (Exception e) { <line35> throw new OAuthErrorException(makeError(OAuth2Error.SERVER_ERROR, e.getMessage())); <line36> } <line37> } else { <line38> newToken.setOpenidToken(null); <line39> } <line40> newToken.setMaxExtendedValidity(config.getMaxExtendedAccessTokenValidity()); <line41> newToken.setTokenValidity(config.getAccessTokenValidity()); <line42> newToken.setAccessToken(null); <line43> newToken.setRefreshToken(null); <line44> newToken.setIssuerUri(config.getIssuerName()); <line45> ; <line46> return newToken; <line47> } <line48> } <line49> "	<line35>
6480	public class A { <line0> @Override <line1> public Object unmarshal(final HierarchicalStreamReader arg0, final UnmarshallingContext arg1) { <line2> Object result; <line3> Class<?> targetType = null; <line4> try { <line5> targetType = arg1.getRequiredType(); <line6> Converter conv = defaultConv.lookupConverterForType(targetType); <line7> result = conv.unmarshal(arg0, arg1); <line8> } catch (final Exception ex) { <line9> return null; <line10> } <line11> try { <line12> if (result != null) { <line13> registerObject(result); <line14> } <line15> } catch (final HibernateException | NullPointerException ex) { <line16> } <line17> return result; <line18> } <line19> } <line20> 	<line9>, <line16>
6481	"public class A { <line0> @Override <line1> public void removeProperty(final String property) <line2> throws AccumuloException, AccumuloSecurityException { <line3> checkArgument(property != null, ""property is null""); <line4> DeprecatedPropertyUtil.getReplacementName( <line5> property, <line6> (log, replacement) -> { <line7> }); <line8> ManagerClient.executeVoid( <line9> context, <line10> client -> client.removeSystemProperty(TraceUtil.traceInfo(), context.rpcCreds(), property)); <line11> checkLocalityGroups(property); <line12> } <line13> } <line14> "	<line7>
6482	public class A { <line0> @Override <line1> public void warn(Marker marker, String format, Object... arguments) { <line2> for (Logger logger : this.loggers) { <line3> } <line4> } <line5> } <line6> 	<line3>
6483	"public class A { <line0> @Override <line1> public List<Broker> getBrokerByRetryType(String retryType) { <line2> Command request = <line3> new Command( <line4> new JoyQueueHeader(Direction.REQUEST, NsrCommandType.GET_BROKER_BY_RETRYTYPE), <line5> new GetBrokerByRetryType().retryType(retryType)); <line6> Command response = send(request); <line7> if (!response.isSuccess()) { <line8> throw new RuntimeException( <line9> String.format(""getBrokerByRetryType error request {},response {}"", request, response)); <line10> } <line11> return ((GetBrokerByRetryTypeAck) response.getPayload()).getBrokers(); <line12> } <line13> } <line14> "	<line8>
6484	"public class A { <line0> @Override <line1> public Optional<MigrationIssue> getCourseMigrationIssue( <line2> String courseId, Integer migrationId, Integer issueId) throws IOException { <line3> String url = <line4> buildCanvasUrl( <line5> ""courses/"" <line6> + courseId <line7> + ""/content_migrations/"" <line8> + migrationId.toString() <line9> + ""/migration_issues/"" <line10> + issueId.toString(), <line11> Collections.emptyMap()); <line12> Response response = canvasMessenger.getSingleResponseFromCanvas(oauthToken, url); <line13> return responseParser.parseToObject(MigrationIssue.class, response); <line14> } <line15> } <line16> "	<line3>
6485	public class A { <line0> @Override <line1> public GModelRoot loadModel(RequestModelAction action, GraphicalModelState modelState) { <line2> Optional<String> sourceURI = <line3> ClientOptions.getValue(action.getOptions(), ClientOptions.SOURCE_URI); <line4> if (sourceURI.isEmpty()) { <line5> return createEmptyRoot(); <line6> } <line7> Optional<ModelServerClient> modelServerClient = modelServerClientProvider.get(); <line8> if (modelServerClient.isEmpty()) { <line9> return createEmptyRoot(); <line10> } <line11> WorkflowModelServerAccess modelAccess = <line12> new WorkflowModelServerAccess( <line13> sourceURI.get(), modelServerClient.get(), adapterFactory, commandCodec); <line14> modelAccess.subscribe( <line15> new WorkflowModelServerSubscriptionListener(modelState, modelAccess, actionProcessor)); <line16> if (modelState instanceof ModelServerAwareModelState) { <line17> ((ModelServerAwareModelState) modelState).setModelAccess(modelAccess); <line18> } <line19> WorkflowFacade workflowFacade = modelAccess.getWorkflowFacade(); <line20> if (workflowFacade == null) { <line21> return createEmptyRoot(); <line22> } <line23> Optional<Integer> givenWorkflowIndex = <line24> ClientOptions.getIntValue(action.getOptions(), OPTION_WORKFLOW_INDEX); <line25> int workflowIndex = givenWorkflowIndex.orElse(WORKFLOW_INDEX_DEFAULT); <line26> if (givenWorkflowIndex.isEmpty()) { <line27> } <line28> Optional<Machine> machine = workflowFacade.getMachine(); <line29> if (machine.isEmpty() <line30> || workflowIndex < 0 <line31> || machine.get().getWorkflows().size() <= workflowIndex) { <line32> return createEmptyRoot(); <line33> } <line34> workflowFacade.setCurrentWorkflowIndex(workflowIndex); <line35> MappedGModelRoot mappedGModelRoot = populate(workflowFacade, modelState, true); <line36> modelAccess.setNodeMapping(mappedGModelRoot.getMapping()); <line37> return mappedGModelRoot.getRoot(); <line38> } <line39> } <line40> 	<line5>, <line9>, <line27>, <line32>
6486	public class A { <line0> public void requestThrottle(LocoAddress l) { <line1> ThrottleManager t = InstanceManager.throttleManagerInstance(); <line2> boolean result; <line3> result = t.requestThrottle(l, this, false); <line4> if (!result) { <line5> try { <line6> sendErrorStatus(); <line7> } catch (IOException ioe) { <line8> } <line9> } <line10> } <line11> } <line12> 	<line8>
6487	public class A { <line0> private void buildLanguagesFromClassification() { <line1> this.classificationLastRead = categoryDAO.getLastModified(); <line2> MCRCategory root = categoryDAO.getCategory(classification, -1); <line3> if (root == null) { <line4> return; <line5> } <line6> for (MCRCategory category : root.getChildren()) { <line7> buildLanguage(category); <line8> } <line9> } <line10> } <line11> 	<line4>
6488	public class A { <line0> public static void push(GCMWrapper gcmWrapper, DashBoard dash, String body) { <line1> if (Notification.isWrongBody(body)) { <line2> return; <line3> } <line4> Notification widget = dash.getNotificationWidget(); <line5> if (widget == null || widget.hasNoToken()) { <line6> return; <line7> } <line8> widget.push(gcmWrapper, body, dash.id); <line9> } <line10> } <line11> 	<line2>, <line6>
6489	"public class A { <line0> public static SiteReportRater getSiteReportRater(String recommendationLanguage) <line1> throws JAXBException { <line2> ClassLoader classLoader = SiteReport.class.getClassLoader(); <line3> JAXBContext context = JAXBContext.newInstance(RatingInfluencers.class); <line4> Unmarshaller um = context.createUnmarshaller(); <line5> InputStream in = classLoader.getResourceAsStream(INFLUENCERS_RESOURCE_LOCATION); <line6> RatingInfluencers influencers = (RatingInfluencers) um.unmarshal(in); <line7> context = JAXBContext.newInstance(Recommendations.class); <line8> um = context.createUnmarshaller(); <line9> String fileName = RECOMMENDATIONS_RESOURCE_LOCATION + ""_"" + recommendationLanguage + "".xml""; <line10> URL u = classLoader.getResource(fileName); <line11> if (u == null) { <line12> fileName = RECOMMENDATIONS_RESOURCE_LOCATION + "".xml""; <line13> } <line14> in = classLoader.getResourceAsStream(fileName); <line15> Recommendations recommendations = (Recommendations) um.unmarshal(in); <line16> SiteReportRater instance = new SiteReportRater(influencers, recommendations); <line17> return instance; <line18> } <line19> } <line20> "	<line12>
6490	public class A { <line0> @Override <line1> public void doneUoW(Exchange exchange) { <line2> try { <line3> if (exchange == null) { <line4> return; <line5> } <line6> if (exchange.getUnitOfWork() == null) { <line7> List<Synchronization> synchronizations = <line8> exchange.adapt(ExtendedExchange.class).handoverCompletions(); <line9> UnitOfWorkHelper.doneSynchronizations(exchange, synchronizations, LOG); <line10> } else { <line11> exchange.getUnitOfWork().done(exchange); <line12> } <line13> } catch (Throwable e) { <line14> } <line15> } <line16> } <line17> 	<line14>
6491	public class A { <line0> private static synchronized Map<String, DataMapperLibrary> getLibraries() { <line1> if (libraries.size() == 0) { <line2> ClassLoader cl = Thread.currentThread().getContextClassLoader(); <line3> ServiceLoader<DataMapperLibrary> sl = ServiceLoader.load(DataMapperLibrary.class); <line4> Map<String, Integer> dups = new HashMap<>(); <line5> for (DataMapperLibrary dataMapperLibrary : sl) { <line6> if (libraries.get(dataMapperLibrary.getLibraryName()) != null) { <line7> String name = dataMapperLibrary.getLibraryName(); <line8> dups.put(name, dups.getOrDefault(name, 0)); <line9> } <line10> libraries.put(dataMapperLibrary.getLibraryName(), dataMapperLibrary); <line11> } <line12> if (dups.size() > 0) { <line13> } <line14> } <line15> return libraries; <line16> } <line17> } <line18> 	<line3>, <line6>, <line13>, <line15>
6492	public class A { <line0> public Authenticated authenticate(Credentials credentials) throws ContextAuthenticationException { <line1> Authenticated authenticated = null; <line2> try { <line3> authenticated = authenticationScheme.authenticate(credentials); <line4> this.user = authenticated.getUser(); <line5> notifyUserSessionListener(this.user, Event.LOGIN, Status.SUCCESS); <line6> } catch (ContextAuthenticationException e) { <line7> User loggingInUser = new User(); <line8> loggingInUser.setUsername(credentials.getClientName()); <line9> notifyUserSessionListener(loggingInUser, Event.LOGIN, Status.FAIL); <line10> throw e; <line11> } <line12> setUserLocation(); <line13> return authenticated; <line14> } <line15> } <line16> 	<line1>, <line13>
6493	public class A { <line0> private void processResults( <line1> OMMetrics omMetrics, <line2> long numSubmittedOpenKeys, <line3> long numDeletedOpenKeys, <line4> OzoneManagerProtocolProtos.DeleteOpenKeysRequest request, <line5> Result result) { <line6> switch (result) { <line7> case SUCCESS: <line8> break; <line9> case FAILURE: <line10> omMetrics.incNumOpenKeyDeleteRequestFails(); <line11> break; <line12> default: <line13> } <line14> } <line15> } <line16> 	<line8>, <line11>, <line13>
6494	"public class A { <line0> protected void assignCurrentExpenditureToNonExistingAccountObjectCode( <line1> ContractsGrantsInvoiceDocument contractsGrantsInvoiceDocument, <line2> ContractsGrantsInvoiceDetail invoiceDetail) { <line3> String categoryCode = invoiceDetail.getCategoryCode(); <line4> if (StringUtils.isBlank(categoryCode)) { <line5> throw new IllegalArgumentException( <line6> ""Category Code can not be null during recalculation of account object code for Contracts"" <line7> + "" & Grants Invoice Document.""); <line8> } <line9> final CostCategory category = <line10> businessObjectService.findBySinglePrimaryKey(CostCategory.class, categoryCode); <line11> if (!ObjectUtils.isNull(category)) { <line12> final KualiDecimal oneCent = new KualiDecimal(0.01); <line13> int size = contractsGrantsInvoiceDocument.getAccountDetails().size(); <line14> KualiDecimal amount = <line15> new KualiDecimal( <line16> invoiceDetail <line17> .getInvoiceAmount() <line18> .bigDecimalValue() <line19> .divide(new BigDecimal(size), 2, RoundingMode.HALF_UP)); <line20> KualiDecimal remainder = <line21> invoiceDetail.getInvoiceAmount().subtract(amount.multiply(new KualiDecimal(size))); <line22> for (InvoiceAccountDetail invoiceAccountDetail : <line23> contractsGrantsInvoiceDocument.getAccountDetails()) { <line24> InvoiceDetailAccountObjectCode invoiceDetailAccountObjectCode = <line25> new InvoiceDetailAccountObjectCode(); <line26> invoiceDetailAccountObjectCode.setDocumentNumber( <line27> contractsGrantsInvoiceDocument.getDocumentNumber()); <line28> invoiceDetailAccountObjectCode.setProposalNumber( <line29> contractsGrantsInvoiceDocument.getInvoiceGeneralDetail().getProposalNumber()); <line30> invoiceDetailAccountObjectCode.setCategoryCode(categoryCode); <line31> invoiceDetailAccountObjectCode.setAccountNumber(invoiceAccountDetail.getAccountNumber()); <line32> invoiceDetailAccountObjectCode.setChartOfAccountsCode( <line33> invoiceAccountDetail.getChartOfAccountsCode()); <line34> invoiceDetailAccountObjectCode.setCumulativeExpenditures(KualiDecimal.ZERO); <line35> invoiceDetailAccountObjectCode.setTotalBilled(KualiDecimal.ZERO); <line36> final ObjectCodeCurrent objectCode = <line37> getCostCategoryService() <line38> .findObjectCodeForChartAndCategory( <line39> invoiceAccountDetail.getChartOfAccountsCode(), categoryCode); <line40> if (!ObjectUtils.isNull(objectCode)) { <line41> invoiceDetailAccountObjectCode.setFinancialObjectCode( <line42> objectCode.getFinancialObjectCode()); <line43> } <line44> if (remainder.isGreaterThan(KualiDecimal.ZERO)) { <line45> amount = amount.add(oneCent); <line46> remainder = remainder.subtract(oneCent); <line47> } else if (remainder.isLessThan(KualiDecimal.ZERO)) { <line48> amount = amount.subtract(oneCent); <line49> remainder = remainder.add(oneCent); <line50> } <line51> invoiceDetailAccountObjectCode.setCurrentExpenditures(amount); <line52> List<InvoiceDetailAccountObjectCode> invoiceDetailAccountObjectCodes = <line53> contractsGrantsInvoiceDocument.getInvoiceDetailAccountObjectCodes(); <line54> if (invoiceDetailAccountObjectCodes.contains(invoiceDetailAccountObjectCode)) { <line55> InvoiceDetailAccountObjectCode original = <line56> invoiceDetailAccountObjectCodes.get( <line57> invoiceDetailAccountObjectCodes.indexOf(invoiceDetailAccountObjectCode)); <line58> original.setCurrentExpenditures(amount); <line59> original.setCategoryCode(categoryCode); <line60> } else { <line61> contractsGrantsInvoiceDocument <line62> .getInvoiceDetailAccountObjectCodes() <line63> .add(invoiceDetailAccountObjectCode); <line64> } <line65> } <line66> } else { <line67> } <line68> } <line69> } <line70> "	<line67>
6495	public class A { <line0> @Override <line1> protected void dispose(JRVirtualizable o) { <line2> VirtualizerStore store = store(o, false); <line3> if (store == null) { <line4> if (log.isTraceEnabled()) { <line5> } <line6> return; <line7> } <line8> store.remove(o.getUID()); <line9> } <line10> } <line11> 	<line5>
6496	public class A { <line0> private void interruptBackup() { <line1> if (mBackupFuture != null && !mBackupFuture.isDone()) { <line2> mBackupFuture.cancel(true); <line3> } <line4> boolean shouldResume = true; <line5> if (mBackupTimeoutTask != null) { <line6> shouldResume = mBackupTimeoutTask.cancel(true); <line7> } <line8> if (shouldResume) { <line9> try { <line10> mJournalSystem.resume(); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> } <line16> 	<line1>, <line2>, <line6>, <line10>, <line12>, <line14>
6497	public class A { <line0> @Override <line1> protected Group[] getRoleSets() throws LoginException { <line2> if (this.assertion == null) { <line3> try { <line4> this.assertion = SAMLUtil.fromElement(this.credential.getAssertionAsElement()); <line5> } catch (Exception e) { <line6> throw logger.authFailedToParseSAMLAssertion(e); <line7> } <line8> } <line9> if (logger.isTraceEnabled()) { <line10> try { <line11> } catch (ProcessingException ignore) { <line12> } <line13> } <line14> List<String> roleKeys = new ArrayList<String>(); <line15> if (StringUtil.isNotNull(roleKey)) { <line16> roleKeys.addAll(StringUtil.tokenize(roleKey)); <line17> } <line18> String groupName = SecurityConstants.ROLES_IDENTIFIER; <line19> Group rolesGroup = new PicketLinkGroup(groupName); <line20> List<String> roles = AssertionUtil.getRoles(assertion, roleKeys); <line21> for (String role : roles) { <line22> rolesGroup.addMember(new SimplePrincipal(role)); <line23> } <line24> return new Group[] {rolesGroup}; <line25> } <line26> } <line27> 	<line11>
6498	"public class A { <line0> @Override <line1> public Representation post(Representation entity) { <line2> try { <line3> String clusterName = (String) getRequest().getAttributes().get(""clusterName""); <line4> JsonParameters jsonParameters = new JsonParameters(entity); <line5> String command = jsonParameters.getCommand(); <line6> ZkClient zkClient = <line7> (ZkClient) getContext().getAttributes().get(RestAdminApplication.ZKCLIENT); <line8> ClusterSetup setupTool = new ClusterSetup(zkClient); <line9> if (command.equalsIgnoreCase(ClusterSetup.addInstance) <line10> || JsonParameters.CLUSTERSETUP_COMMAND_ALIASES <line11> .get(ClusterSetup.addInstance) <line12> .contains(command)) { <line13> if (jsonParameters.getParameter(JsonParameters.INSTANCE_NAME) != null) { <line14> setupTool.addInstanceToCluster( <line15> clusterName, jsonParameters.getParameter(JsonParameters.INSTANCE_NAME)); <line16> } else if (jsonParameters.getParameter(JsonParameters.INSTANCE_NAMES) != null) { <line17> setupTool.addInstancesToCluster( <line18> clusterName, jsonParameters.getParameter(JsonParameters.INSTANCE_NAMES).split("";"")); <line19> } else { <line20> throw new HelixException( <line21> ""Missing Json paramaters: '"" <line22> + JsonParameters.INSTANCE_NAME <line23> + ""' or '"" <line24> + JsonParameters.INSTANCE_NAMES <line25> + ""' ""); <line26> } <line27> } else if (command.equalsIgnoreCase(ClusterSetup.swapInstance)) { <line28> if (jsonParameters.getParameter(JsonParameters.NEW_INSTANCE) == null <line29> || jsonParameters.getParameter(JsonParameters.OLD_INSTANCE) == null) { <line30> throw new HelixException( <line31> ""Missing Json paramaters: '"" <line32> + JsonParameters.NEW_INSTANCE <line33> + ""' or '"" <line34> + JsonParameters.OLD_INSTANCE <line35> + ""' ""); <line36> } <line37> setupTool.swapInstance( <line38> clusterName, <line39> jsonParameters.getParameter(JsonParameters.OLD_INSTANCE), <line40> jsonParameters.getParameter(JsonParameters.NEW_INSTANCE)); <line41> } else { <line42> throw new HelixException( <line43> ""Unsupported command: "" <line44> + command <line45> + "". Should be one of ["" <line46> + ClusterSetup.addInstance <line47> + "", "" <line48> + ClusterSetup.swapInstance <line49> + ""]""); <line50> } <line51> getResponse().setEntity(getInstancesRepresentation(clusterName)); <line52> getResponse().setStatus(Status.SUCCESS_OK); <line53> } catch (Exception e) { <line54> getResponse() <line55> .setEntity( <line56> ClusterRepresentationUtil.getErrorAsJsonStringFromException(e), <line57> MediaType.APPLICATION_JSON); <line58> getResponse().setStatus(Status.SUCCESS_OK); <line59> } <line60> return null; <line61> } <line62> } <line63> "	<line59>
6499	public class A { <line0> @Test <line1> public void testHexBase32() { <line2> try { <line3> final GUIDImpl parsed1 = new GUIDImpl(properties.getProperty(FIELDS.BASE32.name())); <line4> final GUIDImpl parsed2 = new GUIDImpl(properties.getProperty(FIELDS.BASE64.name())); <line5> final GUIDImpl parsed0 = new GUIDImpl(properties.getProperty(FIELDS.BASE16.name())); <line6> final GUIDImpl parsed8 = new GUIDImpl(properties.getProperty(FIELDS.BASEARK.name())); <line7> final byte[] bytes = <line8> StringUtils.getBytesFromArraysToString(properties.getProperty(FIELDS.BYTES.name())); <line9> final GUIDImpl parsed9 = new GUIDImpl(bytes); <line10> assertTrue(parsed1.equals(parsed2)); <line11> assertTrue(parsed1.equals(parsed0)); <line12> assertTrue(parsed1.equals(parsed8)); <line13> assertTrue(parsed1.equals(parsed9)); <line14> final GUIDImpl parsed3 = new GUIDImpl(parsed9.getBytes()); <line15> final GUIDImpl parsed4 = new GUIDImpl(parsed9.toBase32()); <line16> final GUIDImpl parsed5 = new GUIDImpl(parsed9.toHex()); <line17> final GUIDImpl parsed6 = new GUIDImpl(parsed9.toString()); <line18> final GUIDImpl parsed7 = new GUIDImpl(parsed9.toBase64()); <line19> assertTrue(parsed9.equals(parsed3)); <line20> assertTrue(parsed9.equals(parsed4)); <line21> assertTrue(parsed9.equals(parsed5)); <line22> assertTrue(parsed9.equals(parsed6)); <line23> assertTrue(parsed9.equals(parsed7)); <line24> final GUIDImpl generated = new GUIDImpl(); <line25> assertTrue(generated.getVersion() == 0); <line26> } catch (final InvalidGuidOperationException e) { <line27> fail(e.getMessage()); <line28> } <line29> } <line30> } <line31> 	<line27>
6500	"public class A { <line0> @POST <line1> @Path(""schedule/{wdID}"") <line2> @RestQuery( <line3> name = ""schedule"", <line4> description = ""Schedule an event based on the given media package"", <line5> pathParameters = { <line6> @RestParameter( <line7> description = ""Workflow definition id"", <line8> isRequired = true, <line9> name = ""wdID"", <line10> type = RestParameter.Type.STRING) <line11> }, <line12> restParameters = { <line13> @RestParameter( <line14> description = ""The media package"", <line15> isRequired = true, <line16> name = ""mediaPackage"", <line17> type = RestParameter.Type.TEXT) <line18> }, <line19> responses = { <line20> @RestResponse( <line21> description = ""Event scheduled"", <line22> responseCode = HttpServletResponse.SC_CREATED), <line23> @RestResponse( <line24> description = ""Media package not valid"", <line25> responseCode = HttpServletResponse.SC_BAD_REQUEST) <line26> }, <line27> returnDescription = """") <line28> public Response schedule( <line29> @PathParam(""wdID"") String wdID, MultivaluedMap<String, String> formData) { <line30> if (StringUtils.isBlank(wdID)) { <line31> return Response.status(Response.Status.BAD_REQUEST).build(); <line32> } <line33> Map<String, String> wfConfig = getWorkflowConfig(formData); <line34> if (StringUtils.isNotBlank(wdID)) { <line35> wfConfig.put(CaptureParameters.INGEST_WORKFLOW_DEFINITION, wdID); <line36> } <line37> String mediaPackageXml = formData.getFirst(""mediaPackage""); <line38> if (StringUtils.isBlank(mediaPackageXml)) { <line39> return Response.status(Status.BAD_REQUEST).build(); <line40> } <line41> MediaPackage mp = null; <line42> try { <line43> mp = MP_FACTORY.newMediaPackageBuilder().loadFromXml(mediaPackageXml); <line44> if (MediaPackageSupport.sanityCheck(mp).isSome()) { <line45> throw new MediaPackageException(""Insane media package""); <line46> } <line47> } catch (MediaPackageException e) { <line48> return Response.status(Status.BAD_REQUEST).build(); <line49> } <line50> MediaPackageElement[] mediaPackageElements = <line51> mp.getElementsByFlavor(MediaPackageElements.EPISODE); <line52> if (mediaPackageElements.length != 1) { <line53> return Response.status(Status.BAD_REQUEST).build(); <line54> } <line55> try { <line56> ingestService.schedule(mp, wdID, wfConfig); <line57> return Response.status(Status.CREATED).build(); <line58> } catch (IngestException e) { <line59> return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build(); <line60> } catch (SchedulerConflictException e) { <line61> return Response.status(Status.CONFLICT).entity(e.getMessage()).build(); <line62> } catch (NotFoundException | UnauthorizedException | SchedulerException e) { <line63> return Response.serverError().build(); <line64> } <line65> } <line66> } <line67> "	<line31>, <line37>, <line39>, <line48>, <line53>
6501	"public class A { <line0> @Override <line1> public List<DocumentInfo> findDocumentByEmployeeName(String employeeName) { <line2> List<DocumentInfo> documents = new ArrayList<DocumentInfo>(); <line3> String query = <line4> ""Select d from "" <line5> + DocumentInfo.class.getSimpleName() <line6> + "" d where d.ownerName =  "" <line7> + employeeName; <line8> documents = (List<DocumentInfo>) dao.findByQuery(query); <line9> for (DocumentInfo documentInfo : documents) { <line10> StreamedContent file = <line11> toStreamedContent( <line12> documentInfo.getData(), documentInfo.getDocumentName(), ""application/pdf""); <line13> documentInfo.addFile(file); <line14> } <line15> return documents; <line16> } <line17> } <line18> "	<line3>
6502	"public class A { <line0> public void handleCondition( <line1> BaseCondition condition, String deplomentId, String statementName, String optionalEPL) { <line2> if (conditionHandlers.isEmpty()) { <line3> String message = <line4> ""Condition encountered processing deployment id '"" <line5> + deplomentId <line6> + ""' statement '"" <line7> + statementName <line8> + ""'""; <line9> if (optionalEPL != null) { <line10> message += "" statement text '"" + optionalEPL + ""'""; <line11> } <line12> message += "" :"" + condition.toString(); <line13> return; <line14> } <line15> ConditionHandlerContext context = <line16> new ConditionHandlerContext(runtimeURI, statementName, deplomentId, condition); <line17> for (ConditionHandler handler : conditionHandlers) { <line18> handler.handle(context); <line19> } <line20> } <line21> } <line22> "	<line13>
6503	"public class A { <line0> public File getSystemVMPatchIsoFile() { <line1> String iso = ""systemvm.iso""; <line2> String systemVmIsoPath = Script.findScript("""", ""vms/"" + iso); <line3> File isoFile = null; <line4> if (systemVmIsoPath != null) { <line5> isoFile = new File(systemVmIsoPath); <line6> } <line7> if (isoFile == null || !isoFile.exists()) { <line8> String svm = ""client/target/generated-webapp/WEB-INF/classes/vms/"" + iso; <line9> isoFile = new File(svm); <line10> } <line11> assert isoFile != null; <line12> if (!isoFile.exists()) { <line13> } <line14> return isoFile; <line15> } <line16> } <line17> "	<line5>, <line9>, <line13>
6504	"public class A { <line0> private PopupObjectListPanel<T> createObjectListPanel( <line1> String id, final String countId, final QName type) { <line2> PopupObjectListPanel<T> listPanel = <line3> new PopupObjectListPanel<T>(id, qnameToCompileTimeClass(type), true, getPageBase()) { <line4> @Override <line5> protected void onUpdateCheckbox(AjaxRequestTarget target) { <line6> refreshCounts(target); <line7> } <line8>  <line9> @Override <line10> protected ObjectQuery addFilterToContentQuery(ObjectQuery query) { <line11> if (type.equals(RoleType.COMPLEX_TYPE)) { <line12> OperationResult result = new OperationResult(OPERATION_LOAD_ASSIGNABLE_ROLES); <line13> ObjectFilter filter = null; <line14> try { <line15> ModelInteractionService mis = parentPage.getModelInteractionService(); <line16> RoleSelectionSpecification roleSpec = <line17> mis.getAssignableRoleSpecification( <line18> SecurityUtils.getPrincipalUser().getUser().asPrismObject(), result); <line19> filter = roleSpec.getFilter(); <line20> } catch (Exception ex) { <line21> LoggingUtils.logUnexpectedException(LOGGER, ""Couldn't load available roles"", ex); <line22> result.recordFatalError(""Couldn't load available roles"", ex); <line23> } finally { <line24> result.recomputeStatus(); <line25> } <line26> if (!result.isSuccess() && !result.isHandledError()) { <line27> parentPage.showResult(result); <line28> } <line29> if (query == null) { <line30> query = new ObjectQuery(); <line31> } <line32> query.addFilter(filter); <line33> } <line34> return query; <line35> } <line36> }; <line37> listPanel.setOutputMarkupId(true); <line38> listPanel.add( <line39> new VisibleEnableBehaviour() { <line40> @Override <line41> public boolean isVisible() { <line42> return type.equals(typeModel.getObject()); <line43> } <line44> }); <line45> return listPanel; <line46> } <line47> } <line48> "	<line12>
6505	"public class A { <line0> public static <T> T throwIfTypeNot(Object entity, Class<T> targetClass) { <line1> if (entity != null && !targetClass.isAssignableFrom(entity.getClass())) { <line2> throw new IllegalArgumentException(""Expected "" + targetClass + "" got "" + entity); <line3> } <line4> return (T) entity; <line5> } <line6> } <line7> "	<line2>
6506	public class A { <line0> public SecurityEvent createSecurityEvent( <line1> String loggingClass, <line2> URI requestUri, <line3> String slMessage, <line4> Entity explicitRealmEntity, <line5> String entityType, <line6> Set<Entity> entities) { <line7> Set<String> targetEdOrgs = getTargetEdOrgStateIds(entityType, entities); <line8> return createSecurityEvent( <line9> loggingClass, requestUri, slMessage, null, null, explicitRealmEntity, targetEdOrgs, false); <line10> } <line11> } <line12> 	<line7>
6507	public class A { <line0> @Override <line1> protected Optional<ExtendedAreaStatus> retrieveStatus() { <line2> try { <line3> final OmnilinkBridgeHandler bridge = getOmnilinkBridgeHandler(); <line4> if (bridge != null) { <line5> ObjectStatus objStatus = <line6> bridge.requestObjectStatus(Message.OBJ_TYPE_AREA, thingID, thingID, true); <line7> return Optional.of((ExtendedAreaStatus) objStatus.getStatuses()[0]); <line8> } else { <line9> return Optional.empty(); <line10> } <line11> } catch (OmniInvalidResponseException <line12> | OmniUnknownMessageTypeException <line13> | BridgeOfflineException e) { <line14> return Optional.empty(); <line15> } <line16> } <line17> } <line18> 	<line9>, <line14>
6508	"public class A { <line0> private void streamChangesForReplicaSet(ChangeEventSourceContext context, ReplicaSet replicaSet) { <line1> MongoPrimary primaryClient = null; <line2> try { <line3> primaryClient = establishConnectionToPrimary(replicaSet); <line4> if (primaryClient != null) { <line5> final AtomicReference<MongoPrimary> primaryReference = new AtomicReference<>(primaryClient); <line6> primaryClient.execute( <line7> ""read from oplog on '"" + replicaSet + ""'"", <line8> primary -> { <line9> readOplog(primary, primaryReference.get(), replicaSet, context); <line10> }); <line11> } <line12> } catch (Throwable t) { <line13> errorHandler.setProducerThrowable(t); <line14> } finally { <line15> if (primaryClient != null) { <line16> primaryClient.stop(); <line17> } <line18> } <line19> } <line20> } <line21> "	<line13>
6509	public class A { <line0> @Override <line1> public void writeItems(List<Object> people) throws Exception { <line2> for (Object person : people) { <line3> if (LOG.isInfoEnabled()) { <line4> } <line5> } <line6> } <line7> } <line8> 	<line4>
6510	public class A { <line0> @Override <line1> public boolean isAvailableLocale(long groupId, String languageId) { <line2> if (groupId <= 0) { <line3> return isAvailableLocale(languageId); <line4> } <line5> try { <line6> if (isInheritLocales(groupId)) { <line7> Group group = GroupLocalServiceUtil.getGroup(groupId); <line8> CompanyLocalesBag companyLocalesBag = _getCompanyLocalesBag(group.getCompanyId()); <line9> return companyLocalesBag.containsLanguageId(languageId); <line10> } <line11> } catch (Exception exception) { <line12> if (_log.isDebugEnabled()) { <line13> } <line14> } <line15> Map<String, Locale> groupLanguageIdLocalesMap = _getGroupLanguageIdLocalesMap(groupId); <line16> return groupLanguageIdLocalesMap.containsKey(languageId); <line17> } <line18> } <line19> 	<line13>
6511	"public class A { <line0> public String buildOutputZip() { <line1> bundleBuildResponse = bundleRequestService.lookupBuildRequest(getId()); <line2> String zipFileName = <line3> fileService.createOutputFilesZip(bundleBuildResponse.getRemoteOutputDirectory()); <line4> try { <line5> downloadInputStream = new FileInputStream(zipFileName); <line6> } catch (FileNotFoundException e) { <line7> e.printStackTrace(); <line8> } <line9> return ""downloadZip""; <line10> } <line11> } <line12> "	<line1>
6512	public class A { <line0> @Override <line1> public SegmentMetadata load(File segmentDir) throws Exception { <line2> final SegmentMetadata segmentMetadata = new SegmentMetadataImpl(segmentDir); <line3> return segmentMetadata; <line4> } <line5> } <line6> 	<line3>
6513	public class A { <line0> public synchronized void addConnection(Address peer_addr, Connection conn) throws Exception { <line1> boolean conn_exists = hasConnection(peer_addr), <line2> replace = conn_exists && local_addr.compareTo(peer_addr) < 0; <line3> if (!conn_exists || replace) { <line4> replaceConnection(peer_addr, conn); <line5> conn.start(); <line6> } else { <line7> Util.close(conn); <line8> } <line9> } <line10> } <line11> 	<line7>
6514	"public class A { <line0> @Parameters({""host"", ""opHost"", ""redirectUrls""}) <line1> @BeforeSuite <line2> public static void beforeSuite(String host, String opHost, String redirectUrls) { <line3> try { <line4> ServerLauncher.setSetUpSuite(true); <line5> SUPPORT = <line6> new DropwizardTestSupport<OxdServerConfiguration>( <line7> OxdServerApplication.class, <line8> ResourceHelpers.resourceFilePath(""oxd-server-jenkins.yml""), <line9> ConfigOverride.config(""server.applicationConnectors[0].port"", ""0"")); <line10> SUPPORT.before(); <line11> removeExistingRps(); <line12> RegisterSiteResponse setupClient = <line13> SetupClientTest.setupClient(Tester.newClient(host), opHost, redirectUrls); <line14> Tester.setSetupClient(setupClient, host, opHost); <line15> Preconditions.checkNotNull(Tester.getAuthorization()); <line16> setupSwaggerSuite(Tester.getTargetHost(host), opHost, redirectUrls); <line17> } catch (Exception e) { <line18> throw new AssertionError(""Failed to start suite.""); <line19> } <line20> } <line21> } <line22> "	<line4>, <line11>, <line12>, <line15>, <line16>, <line17>, <line18>
6515	public class A { <line0> public Map<String, IngestFromHdfsPlugin<?, ?>> createHdfsIngestPlugins() { <line1> final Map<String, IngestFromHdfsPlugin<?, ?>> ingestPlugins = new HashMap<>(); <line2> for (final Entry<String, IngestFormatPluginProviderSpi<?, ?>> entry : plugins.entrySet()) { <line3> final IngestFormatPluginProviderSpi<?, ?> formatPlugin = entry.getValue(); <line4> final IngestFormatOptions formatOptions = options.get(entry.getKey()); <line5> IngestFromHdfsPlugin<?, ?> plugin = null; <line6> try { <line7> plugin = formatPlugin.createIngestFromHdfsPlugin(formatOptions); <line8> if (plugin == null) { <line9> throw new UnsupportedOperationException(); <line10> } <line11> } catch (final UnsupportedOperationException e) { <line12> continue; <line13> } <line14> ingestPlugins.put(formatPlugin.getIngestFormatName(), plugin); <line15> } <line16> return ingestPlugins; <line17> } <line18> } <line19> 	<line12>
6516	"public class A { <line0> static void attemptClientReLogin() { <line1> try { <line2> UserGroupInformation loginUser = UserGroupInformation.getLoginUser(); <line3> if (loginUser == null || !loginUser.hasKerberosCredentials()) { <line4> throw new RuntimeException(""Expected to find Kerberos UGI credentials, but did not""); <line5> } <line6> UserGroupInformation currentUser = UserGroupInformation.getCurrentUser(); <line7> UserGroupInformation realUser = currentUser.getRealUser(); <line8> if (loginUser.equals(currentUser) || loginUser.equals(realUser)) { <line9> if (UserGroupInformation.isLoginKeytabBased()) { <line10> loginUser.reloginFromKeytab(); <line11> } else { <line12> loginUser.reloginFromTicketCache(); <line13> } <line14> try { <line15> Thread.sleep((SASL_BACKOFF_RAND.nextInt(RELOGIN_MAX_BACKOFF) + 1)); <line16> } catch (InterruptedException e) { <line17> Thread.currentThread().interrupt(); <line18> return; <line19> } <line20> } else { <line21> } <line22> } catch (IOException e) { <line23> throw new RuntimeException(e); <line24> } <line25> } <line26> } <line27> "	<line10>, <line12>, <line21>, <line23>
6517	public class A { <line0> public org.talend.mdm.webservice.WSTransformerV2PK putTransformerV2( <line1> org.talend.mdm.webservice.WSPutTransformerV2 arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSTransformerV2PK _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	<line2>
6518	"public class A { <line0> private void detailedLogging(String methodName, String description) { <line1> if (_logger.isDebugEnabled()) { <line2> String localAddress = ""not connected""; <line3> if (m_SockChannel != null) { <line4> Socket socket = m_SockChannel.socket(); <line5> if (socket != null) { <line6> SocketAddress localSocketAddress = socket.getLocalSocketAddress(); <line7> if (localSocketAddress != null) localAddress = localSocketAddress.toString(); <line8> } <line9> } <line10> } <line11> if (_logger.isTraceEnabled()) { <line12> } <line13> } <line14> } <line15> "	<line10>, <line12>
6519	public class A { <line0> @Override <line1> public void onError(Throwable t) { <line2> PingPongImpl.this.streamRequests.add(streamRequests); <line3> } <line4> } <line5> 	<line3>
6520	public class A { <line0> public void stop() { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> if (serializedExecutor != null) { <line4> serializedExecutor.shutdownNow(); <line5> } <line6> serializedExecutor = null; <line7> } <line8> } <line9> 	<line2>
6521	"public class A { <line0> @Override <line1> protected void onTimer(final AjaxRequestTarget target) { <line2> if (isStopped()) { <line3> getComponent().remove(this); <line4> return; <line5> } <line6> final TimerPushService pushService = TimerPushService.get(target.getPage().getApplication()); <line7> final WebRequest request = (WebRequest) RequestCycle.get().getRequest(); <line8> if (!request.getRequestParameters().getParameterValue(""unload"").isNull()) <line9> for (final TimerPushNode<?> node : handlers.keySet()) pushService.onDisconnect(node); <line10> else <line11> for (final Entry<TimerPushNode, IPushEventHandler> entry : handlers.entrySet()) { <line12> final TimerPushNode node = entry.getKey(); <line13> for (final IPushEventContext<?> ctx : <line14> (List<IPushEventContext<?>>) pushService.pollEvents(node)) <line15> try { <line16> entry.getValue().onEvent(target, ctx.getEvent(), node, ctx); <line17> } catch (final RuntimeException ex) { <line18> } <line19> } <line20> } <line21> } <line22> "	<line18>
6522	public class A { <line0> private void saveTranslationsInBatches( <line1> List<HTextFlow> textFlows, <line2> MTDocument transDoc, <line3> HLocale targetLocale, <line4> ContentState saveState) { <line5> int batchStart = 0; <line6> Stopwatch saveAllTimer = Stopwatch.createStarted(); <line7> while (batchStart < textFlows.size()) { <line8> int batchEnd = Math.min(batchStart + SAVE_BATCH_SIZE, textFlows.size()); <line9> List<HTextFlow> sourceBatch = textFlows.subList(batchStart, batchEnd); <line10> List<TypeString> transContentBatch = transDoc.getContents().subList(batchStart, batchEnd); <line11> Stopwatch transactionTime = Stopwatch.createStarted(); <line12> try { <line13> transactionUtil.run( <line14> () -> { <line15> List<TransUnitUpdateRequest> updateRequests = <line16> makeUpdateRequestsForBatch( <line17> targetLocale, <line18> transDoc.getBackendId(), <line19> saveState, <line20> sourceBatch, <line21> transContentBatch); <line22> Stopwatch storeTranslations = Stopwatch.createStarted(); <line23> translationService.translate(targetLocale.getLocaleId(), updateRequests); <line24> }); <line25> } catch (Exception e) { <line26> } <line27> entityManager.clear(); <line28> batchStart = batchEnd; <line29> } <line30> } <line31> } <line32> 	<line6>, <line11>, <line24>, <line26>, <line29>, <line30>
6523	"public class A { <line0> ReadonlyValueException translateReadonlyViolation( <line1> Throwable sourceThrowable, PSQLException pSqlException) { <line2> Matcher matcher = <line3> Pattern.compile( <line4> ""Updating read-only column \""?(.*?)\""? of table \""?(.*?)\""? with id \\[(.*?)] is"" <line5> + "" not allowed"") <line6> .matcher(pSqlException.getServerErrorMessage().getMessage()); <line7> boolean matches = matcher.matches(); <line8> if (!matches) { <line9> throw new RuntimeException(ERROR_TRANSLATING_EXCEPTION_MSG, pSqlException); <line10> } <line11> String colName = matcher.group(1); <line12> String tableName = matcher.group(2); <line13> String id = matcher.group(3); <line14> String attributeName = tryGetAttributeName(tableName, colName).orElse(null); <line15> String entityTypeId = tryGetEntityTypeName(tableName).orElse(null); <line16> return new ReadonlyValueException(entityTypeId, attributeName, id, sourceThrowable); <line17> } <line18> } <line19> "	<line9>
6524	public class A { <line0> @Override <line1> public Single<ShouldRetryResult> shouldRetry(Exception exception) { <line2> Duration retryDelay = Duration.ZERO; <line3> if (this.currentAttemptCount < this.maxAttemptCount <line4> && (retryDelay = checkIfRetryNeeded(exception)) != null) { <line5> this.currentAttemptCount++; <line6> return Single.just(ShouldRetryResult.retryAfter(retryDelay)); <line7> } else { <line8> return Single.just(ShouldRetryResult.noRetry()); <line9> } <line10> } <line11> } <line12> 	<line6>, <line8>
6525	public class A { <line0> private boolean isAccessPointReachable(String interfaceName, int tout) throws KuraException { <line1> boolean ret = true; <line2> RouteService rs = getRouteService(); <line3> RouteConfig rconf = rs.getDefaultRoute(interfaceName); <line4> if (rconf != null) { <line5> IPAddress ipAddress = rconf.getGateway(); <line6> String iface = rconf.getInterfaceName(); <line7> if (ipAddress != null && iface != null && iface.equals(interfaceName)) { <line8> try { <line9> InetAddress inetAddress = InetAddress.getByName(ipAddress.getHostAddress()); <line10> ret = inetAddress.isReachable(tout); <line11> } catch (Exception e) { <line12> throw new KuraException(KuraErrorCode.INTERNAL_ERROR, e); <line13> } <line14> } <line15> } <line16> return ret; <line17> } <line18> } <line19> 	<line11>
6526	public class A { <line0> @Override <line1> public void handleTextMessage(final WebSocketSession wsSession, TextMessage message) <line2> throws Exception { <line3> try { <line4> String messageJson = message.getPayload(); <line5> ServerSessionFactory factory = <line6> new ServerSessionFactory() { <line7> @Override <line8> public ServerSession createSession( <line9> String sessionId, Object registerInfo, SessionsManager sessionsManager) { <line10> return new WebSocketServerSession( <line11> sessionId, registerInfo, sessionsManager, wsSession); <line12> } <line13>  <line14> @Override <line15> public void updateSessionOnReconnection(ServerSession session) { <line16> ((WebSocketServerSession) session).updateWebSocketSession(wsSession); <line17> } <line18> }; <line19> protocolManager.processMessage( <line20> messageJson, <line21> factory, <line22> new ResponseSender() { <line23> @Override <line24> public void sendResponse(Message message) throws IOException { <line25> String jsonMessage = message.toString(); <line26> sendJsonMessage(jsonMessage); <line27> } <line28>  <line29> @Override <line30> public void sendPingResponse(Message message) throws IOException { <line31> String jsonMessage = message.toString(); <line32> sendJsonMessage(jsonMessage); <line33> } <line34>  <line35> private void sendJsonMessage(String jsonMessage) throws IOException { <line36> synchronized (wsSession) { <line37> if (wsSession.isOpen()) { <line38> wsSession.sendMessage(new TextMessage(jsonMessage)); <line39> } else { <line40> } <line41> } <line42> } <line43> }, <line44> wsSession.getId()); <line45> } catch (Throwable t) { <line46> } <line47> } <line48> } <line49> 	<line26>, <line32>, <line40>, <line46>
6527	public class A { <line0> private void showLater(TestModalSampleDialog dialog) { <line1> SwingUtilities.invokeLater( <line2> new Runnable() { <line3> @Override <line4> public void run() { <line5> dialog.showDialog(); <line6> } <line7> }); <line8> } <line9> } <line10> 	<line5>
6528	public class A { <line0> private void initializeFileSystem(final IndexedDiskCacheAttributes cattr) { <line1> this.rafDir = cattr.getDiskPath(); <line2> } <line3> } <line4> 	<line2>
6529	"public class A { <line0> @Override <line1> public void deleteTestTopic(String topic) { <line2> Properties props = getSecureProperties(); <line3> props.putAll(getStandardProperties()); <line4> String clientId = Long.toString(new Random().nextLong()); <line5> props.put(""client.id"", clientId); <line6> AdminClient adminClient = AdminClient.create(props); <line7> try { <line8> tryDelete(adminClient, topic); <line9> } catch (Exception e) { <line10> e.printStackTrace(); <line11> fail(String.format(""Delete test topic : %s failed, %s"", topic, e.getMessage())); <line12> } finally { <line13> adminClient.close(Duration.ofMillis(5000L)); <line14> maybePrintDanglingThreadStacktrace(clientId); <line15> } <line16> } <line17> } <line18> "	<line2>
6530	"public class A { <line0> static PCollection<SampleRecord> loadSampleRecords( <line1> AllDatasetsPipelinesOptions options, Pipeline p) { <line2> FileSystem fs = <line3> FileSystemFactory.getInstance(options.getHdfsSiteConfig(), options.getCoreSiteConfig()) <line4> .getFs(options.getAllDatasetsInputPath()); <line5> String samplingDir = ALAFsUtils.buildPathSamplingUsingTargetPath(options); <line6> boolean hasSampling = ALAFsUtils.existsAndNonEmpty(fs, samplingDir); <line7> if (hasSampling) { <line8> String samplingPath = String.join(""/"", samplingDir, ""*.avro""); <line9> return p.apply(AvroIO.read(SampleRecord.class).from(samplingPath)); <line10> } else { <line11> return p.apply(Create.empty(AvroCoder.of(SampleRecord.class))); <line12> } <line13> } <line14> } <line15> "	<line7>, <line9>
6531	"public class A { <line0> protected ExecutionResult prepareNetworkElementCommand(final IpAssocCommand cmd) { <line1> final Connection conn = getConnection(); <line2> final String routerName = cmd.getAccessDetail(NetworkElementCommand.ROUTER_NAME); <line3> final String routerIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP); <line4> try { <line5> final IpAddressTO[] ips = cmd.getIpAddresses(); <line6> for (final IpAddressTO ip : ips) { <line7> final VM router = getVM(conn, routerName); <line8> final NicTO nic = new NicTO(); <line9> nic.setMac(ip.getVifMacAddress()); <line10> nic.setType(ip.getTrafficType()); <line11> if (ip.getBroadcastUri() == null) { <line12> nic.setBroadcastType(BroadcastDomainType.Native); <line13> } else { <line14> final URI uri = BroadcastDomainType.fromString(ip.getBroadcastUri()); <line15> nic.setBroadcastType(BroadcastDomainType.getSchemeValue(uri)); <line16> nic.setBroadcastUri(uri); <line17> } <line18> nic.setDeviceId(0); <line19> nic.setNetworkRateMbps(ip.getNetworkRate()); <line20> nic.setName(ip.getNetworkName()); <line21> final Network network = getNetwork(conn, nic); <line22> VIF correctVif = getCorrectVif(conn, router, network); <line23> boolean addVif = false; <line24> if (ip.isAdd() && correctVif == null) { <line25> addVif = true; <line26> } <line27> if (addVif) { <line28> final String vifDeviceNum = getLowestAvailableVIFDeviceNum(conn, router); <line29> if (vifDeviceNum == null) { <line30> throw new InternalErrorException( <line31> ""There were no more available slots for a new VIF on router: "" <line32> + router.getNameLabel(conn)); <line33> } <line34> nic.setDeviceId(Integer.parseInt(vifDeviceNum)); <line35> correctVif = createVif(conn, routerName, router, null, nic); <line36> correctVif.plug(conn); <line37> networkUsage(conn, routerIp, ""addVif"", ""eth"" + correctVif.getDevice(conn)); <line38> } <line39> if (ip.isAdd() && correctVif == null) { <line40> throw new InternalErrorException( <line41> ""Failed to find DomR VIF to associate/disassociate IP with.""); <line42> } <line43> if (correctVif != null) { <line44> ip.setNicDevId(Integer.valueOf(correctVif.getDevice(conn))); <line45> ip.setNewNic(addVif); <line46> } <line47> } <line48> } catch (final InternalErrorException e) { <line49> return new ExecutionResult(false, e.getMessage()); <line50> } catch (final Exception e) { <line51> return new ExecutionResult(false, e.getMessage()); <line52> } <line53> return new ExecutionResult(true, null); <line54> } <line55> } <line56> "	<line49>
6532	"public class A { <line0> @Override <line1> public Set<AcceptApplication> findAcceptApplicationName( <line2> Application fromApplication, Range range) { <line3> Objects.requireNonNull(fromApplication, ""fromApplication""); <line4> final Scan scan = createScan(fromApplication, range); <line5> TableName hostApplicationMapTableName = <line6> tableNameProvider.getTableName(HbaseTable.HOST_APPLICATION_MAP_VER2); <line7> final List<List<AcceptApplication>> result = <line8> hbaseOperations2.findParallel( <line9> hostApplicationMapTableName, <line10> scan, <line11> acceptApplicationRowKeyDistributor, <line12> hostApplicationMapperVer2, <line13> HOST_APPLICATION_MAP_VER2_NUM_PARTITIONS); <line14> if (CollectionUtils.isNotEmpty(result)) { <line15> final Set<AcceptApplication> resultSet = new HashSet<>(); <line16> for (List<AcceptApplication> resultList : result) { <line17> resultSet.addAll(resultList); <line18> } <line19> return resultSet; <line20> } else { <line21> return Collections.emptySet(); <line22> } <line23> } <line24> } <line25> "	<line19>
6533	public class A { <line0> public AIResource mapAIPLarformValueToAIResource( <line1> AIPlatformValue aiPlatform, AIResource aiResource) { <line2> if (null == aiPlatform) { <line3> return aiResource; <line4> } <line5> if (null == aiResource) { <line6> aiResource = new AIResource(); <line7> } <line8> aiResource.setNaturalID(aiPlatform.getFqdn()); <line9> aiResource.setName(aiPlatform.getName()); <line10> aiResource.setResourceType(ResourceTypeModel.PLATFORM); <line11> ResourcePrototype resourcePrototype = new ResourcePrototype(); <line12> resourcePrototype.setName(aiPlatform.getPlatformTypeName()); <line13> aiResource.setResourcePrototype(resourcePrototype); <line14> AIServerValue[] aiServerValues = aiPlatform.getAIServerValues(); <line15> if ((null != aiServerValues) && (aiServerValues.length > 0)) { <line16> List<ResourceModel> subResources = new ArrayList<ResourceModel>(aiServerValues.length); <line17> for (int i = 0; i < aiServerValues.length; i++) { <line18> AIResource aiServer = mapAIServerValueToAIResource(aiServerValues[i], null); <line19> subResources.add(aiServer); <line20> } <line21> aiResource.setSubResources(subResources); <line22> } <line23> return aiResource; <line24> } <line25> } <line26> 	<line3>
6534	public class A { <line0> private void assertEqualPositions( <line1> SourceFile[] sourceFiles, <line2> SourceFile sourceFile, <line3> String javaCodeSnippet, <line4> String tsCodeSnippet) { <line5> SourcePosition tsPosition = getPosition(sourceFile.getTsFile(), tsCodeSnippet); <line6> SourcePosition javaPosition = <line7> SourceFile.findOriginPosition(tsPosition, Arrays.asList(sourceFiles)); <line8> assertEquals( <line9> getPosition(sourceFile.getJavaFile(), javaCodeSnippet).getStartLine(), <line10> javaPosition.getStartLine()); <line11> } <line12> } <line13> 	<line5>, <line8>
6535	"public class A { <line0> @Nullable <line1> public String read() throws Exception { <line2> if (index >= input.length) { <line3> return null; <line4> } <line5> if (fail && index == 4) { <line6> synchronized (ExampleItemReader.class) { <line7> if (fail) { <line8> fail = false; <line9> index++; <line10> throw new RuntimeException(""Planned failure""); <line11> } <line12> } <line13> } <line14> return input[index++]; <line15> } <line16> } <line17> "	<line5>, <line9>
6536	public class A { <line0> @Override <line1> public void onCommunicationLost(Association association) { <line2> this.handleCommDown(); <line3> } <line4> } <line5> 	<line2>
6537	public class A { <line0> public void setTracingEnabled(String executionPlanName, boolean isEnabled) <line1> throws RemoteException { <line2> try { <line3> eventProcessorAdminServiceStub.setTracingEnabled(executionPlanName, isEnabled); <line4> } catch (RemoteException e) { <line5> throw e; <line6> } <line7> } <line8> } <line9> 	<line5>
6538	public class A { <line0> public void run() { <line1> while (true) { <line2> try { <line3> sleep(flushInterval); <line4> bookie.getSyncThread().checkpoint(Checkpoint.MAX); <line5> ledgerCache.flushLedger(true); <line6> } catch (InterruptedException ie) { <line7> Thread.currentThread().interrupt(); <line8> return; <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> } <line14> 	<line10>
6539	"public class A { <line0> private void setStationData() throws IOException { <line1> String cStationName = this.stationName; <line2> if (this.getUrnToStationName().containsKey(this.stationName)) { <line3> cStationName = this.getUrnToStationName().get(this.stationName); <line4> } <line5> switch (this.getDatasetFeatureType()) { <line6> case STATION: <line7> this.stationData = new TimeSeries(new String[] {cStationName}, null, null); <line8> this.stationData.setData(this.getFeatureTypeDataSet()); <line9> break; <line10> case STATION_PROFILE: <line11> this.stationData = <line12> new TimeSeriesProfile( <line13> new String[] {cStationName}, null, null, false, false, false, null); <line14> this.stationData.setData(this.getFeatureTypeDataSet()); <line15> break; <line16> case PROFILE: <line17> this.stationData = new Profile(new String[] {cStationName}, null, null); <line18> this.stationData.setData(this.getFeatureTypeDataSet()); <line19> break; <line20> case TRAJECTORY: <line21> this.stationData = new Trajectory(new String[] {cStationName}, null, null); <line22> this.stationData.setData(this.getFeatureTypeDataSet()); <line23> this.locationLineFlag = true; <line24> break; <line25> case SECTION: <line26> this.stationData = new Section(new String[] {cStationName}, null, null); <line27> this.stationData.setData(this.getFeatureTypeDataSet()); <line28> this.locationLineFlag = true; <line29> break; <line30> case GRID: <line31> HashMap<String, String> latLon = new HashMap<String, String>(); <line32> latLon.put( <line33> Grid.LAT, <line34> this.getGridDataset().getBoundingBox().getLatMin() <line35> + ""_"" <line36> + this.getGridDataset().getBoundingBox().getLatMax()); <line37> latLon.put( <line38> Grid.LON, <line39> this.getGridDataset().getBoundingBox().getLonMin() <line40> + ""_"" <line41> + this.getGridDataset().getBoundingBox().getLonMax()); <line42> List<String> dataVars = new ArrayList<String>(); <line43> for (VariableSimpleIF var : this.getDataVariables()) { <line44> dataVars.add(var.getShortName()); <line45> } <line46> this.stationData = <line47> new Grid( <line48> new String[] {cStationName.replaceAll(""[A-Za-z]+"", """")}, <line49> null, <line50> dataVars.toArray(new String[dataVars.size()]), <line51> latLon); <line52> this.stationData.setData(this.getGridDataset()); <line53> break; <line54> default: <line55> this.errorString = ""Unsupported feature type for DS response""; <line56> } <line57> } <line58> } <line59> "	<line55>
6540	"public class A { <line0> public void read(InputStream stream, Object filter, XARInputFilter proxyFilter) <line1> throws IOException { <line2> ZipArchiveInputStream zis = new ZipArchiveInputStream(stream, ""UTF-8"", false); <line3> for (ZipArchiveEntry entry = zis.getNextZipEntry(); <line4> entry != null; <line5> entry = zis.getNextZipEntry()) { <line6> if (entry.isDirectory() || entry.getName().startsWith(""META-INF"")) { <line7> continue; <line8> } else if (entry.getName().equals(XarModel.PATH_PACKAGE)) { <line9> try { <line10> this.xarPackage.readDescriptor(zis); <line11> } catch (Exception e) { <line12> if (this.properties.isVerbose()) { <line13> } <line14> } <line15> } else { <line16> try { <line17> this.documentReader.read(zis, filter, proxyFilter); <line18> } catch (SkipEntityException skip) { <line19> if (this.properties.isVerbose()) { <line20> } <line21> } catch (Exception e) { <line22> if (this.properties.isVerbose()) { <line23> } <line24> } <line25> } <line26> } <line27> } <line28> } <line29> "	<line13>, <line20>, <line23>
6541	public class A { <line0> @Override <line1> public void injectCacheResult(Object result) { <line2> this.result = (CnATreeElement) result; <line3> resultInjectedFromCache = true; <line4> if (log.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> 	<line5>
6542	public class A { <line0> @Override <line1> public boolean insertListTestCaseCountryProperties( <line2> List<TestCaseCountryProperties> testCaseCountryPropertiesList) { <line3> for (TestCaseCountryProperties tccp : testCaseCountryPropertiesList) { <line4> try { <line5> insertTestCaseCountryProperties(tccp); <line6> } catch (CerberusException ex) { <line7> return false; <line8> } <line9> } <line10> return true; <line11> } <line12> } <line13> 	<line7>
6543	public class A { <line0> public void checkFail(Instance ip, HealthCheckTask task, String msg) { <line1> Cluster cluster = task.getCluster(); <line2> try { <line3> if (ip.isHealthy() || ip.isMockValid()) { <line4> if (ip.getFailCount().incrementAndGet() >= switchDomain.getCheckTimes()) { <line5> if (distroMapper.responsible(cluster, ip)) { <line6> ip.setHealthy(false); <line7> ip.setMockValid(false); <line8> Service service = cluster.getService(); <line9> service.setLastModifiedMillis(System.currentTimeMillis()); <line10> pushService.serviceChanged(service); <line11> } else { <line12> } <line13> } else { <line14> } <line15> } <line16> } catch (Throwable t) { <line17> } <line18> ip.getOkCount().set(0); <line19> ip.setBeingChecked(false); <line20> } <line21> } <line22> 	<line11>, <line12>, <line14>, <line17>
6544	public class A { <line0> @Override <line1> public void cancelAllActiveSearches() { <line2> for (SearchTask next : myIdToSearchTask.values()) { <line3> next.requestImmediateAbort(); <line4> AsyncUtil.awaitLatchAndIgnoreInterrupt(next.getCompletionLatch(), 30, TimeUnit.SECONDS); <line5> } <line6> } <line7> } <line8> 	<line3>
6545	"public class A { <line0> public static void restartSeleniumApp() { <line1> List<String> beforeRestart = <line2> Kubernetes.getInstance().listPods(SystemtestsKubernetesApps.SELENIUM_PROJECT).stream() <line3> .map(pod -> pod.getMetadata().getName()) <line4> .collect(Collectors.toList()); <line5> int attempts = 5; <line6> for (int i = 1; i <= attempts; i++) { <line7> SystemtestsKubernetesApps.deleteSeleniumPod( <line8> SystemtestsKubernetesApps.SELENIUM_PROJECT, Kubernetes.getInstance()); <line9> try { <line10> TestUtils.waitUntilCondition( <line11> ""Selenium pods ready"", <line12> (phase) -> { <line13> List<String> current = <line14> TestUtils.listReadyPods( <line15> Kubernetes.getInstance(), SystemtestsKubernetesApps.SELENIUM_PROJECT) <line16> .stream() <line17> .map(pod -> pod.getMetadata().getName()) <line18> .collect(Collectors.toList()); <line19> current.removeAll(beforeRestart); <line20> return current.size() == beforeRestart.size(); <line21> }, <line22> new TimeoutBudget(1, TimeUnit.MINUTES)); <line23> break; <line24> } catch (Exception ex) { <line25> } <line26> } <line27> } <line28> } <line29> "	<line20>, <line25>
6546	"public class A { <line0> @Override <line1> public void run() { <line2> Thread.currentThread().setName(""Pipe "" + pipe.getPipesLocation() + "" Reader""); <line3> try { <line4> while (readerAlive) { <line5> PipeCommand command; <line6> try { <line7> command = pipe.readCommand(); <line8> } catch (UnknownCommandException uce) { <line9> continue; <line10> } <line11> synchronized (ControlPipePair.this) { <line12> PendingCommandStatus commandStatus = waitingCommands.remove(command); <line13> if (commandStatus == null) { <line14> ControlPipePair.this.unusedCommands.add(command); <line15> } else { <line16> commandStatus.completed(false, command); <line17> } <line18> } <line19> } <line20> } catch (ExternalExecutorException eee) { <line21> synchronized (ControlPipePair.this) { <line22> for (PendingCommandStatus commandStatus : waitingCommands.values()) { <line23> commandStatus.completed(true, null); <line24> } <line25> } <line26> } <line27> } <line28> } <line29> "	<line9>
6547	"public class A { <line0> public WebContainerContext resolveHttpContext(Bundle bundle) { <line1> if (httpContext != null) { <line2> return httpContext; <line3> } <line4> BundleContext bundleContext = bundle != null ? bundle.getBundleContext() : null; <line5> if (bundleContext == null) { <line6> throw new IllegalArgumentException( <line7> ""Can't resolve WebContainerContext without Bundle argument""); <line8> } <line9> if (contextSupplier != null) { <line10> return contextSupplier.apply(bundleContext, getName()); <line11> } <line12> if (contextReference != null) { <line13> Object context = bundleContext.getService(contextReference); <line14> if (context instanceof WebContainerContext) { <line15> return (WebContainerContext) context; <line16> } <line17> if (context instanceof HttpContext) { <line18> return new WebContainerContextWrapper( <line19> bundleContext.getBundle(), (HttpContext) context, name); <line20> } <line21> if (context instanceof ServletContextHelper) { <line22> return new WebContainerContextWrapper( <line23> bundleContext.getBundle(), (ServletContextHelper) context, name); <line24> } <line25> throw new IllegalStateException( <line26> ""Unsupported Whiteboard service for HttpContext/ServletContextHelper"" + "" specified""); <line27> } <line28> throw new IllegalStateException(""No HttpContext/ServletContextHelper configured for "" + this); <line29> } <line30> } <line31> "	<line13>
6548	"public class A { <line0> private void parseFactoryComponent(Annotation annotation) { <line1> EntryWriter writer = new EntryWriter(EntryType.FactoryConfigurationAdapterService); <line2> m_writers.add(writer); <line3> writer.put(EntryParam.impl, m_componentClassName); <line4> String factoryPid = get(annotation, EntryParam.factoryPid.toString(), null); <line5> if (factoryPid != null) { <line6> writer.put(EntryParam.factoryPid, factoryPid); <line7> } else { <line8> } <line9> writer.putString(annotation, EntryParam.updated, ""updated""); <line10> writer.putString(annotation, EntryParam.propagate, Boolean.FALSE.toString()); <line11> if (writer.putClassArray(annotation, EntryParam.provides, m_interfaces, m_exportService) == 0) { <line12> checkRegisteredUnregisteredNotPresent(); <line13> } <line14> parseCommonComponentAttributes(annotation, writer); <line15> writer.putString(annotation, EntryParam.factoryMethod, null); <line16> } <line17> } <line18> "	<line16>
6549	public class A { <line0> private void publishToRegistry( <line1> Set<Geometry> oldVisibleGeomSet, <line2> Set<Geometry> newVisibleGeomSet, <line3> Set<Geometry> newHiddenGeomSet) { <line4> long start; <line5> start = System.nanoTime(); <line6> getProvider() <line7> .getToolbox() <line8> .getGeometryRegistry() <line9> .receiveObjects(getProvider().getUpdateSource(), newVisibleGeomSet, oldVisibleGeomSet); <line10> if (LOGGER.isTraceEnabled()) { <line11> } <line12> } <line13> } <line14> 	<line11>
6550	"public class A { <line0> private String getBearerToken(final Tenant tenant, final ID principal, final Secret secret) { <line1> try { <line2> final String payload = <line3> String.format( <line4> ""grant_type=client_credentials&client_id=%s&client_secret=%s&resource=%s"", <line5> principal.getValue(), <line6> URLEncoder.encode(secret.getValue(), ""UTF-8""), <line7> URLEncoder.encode(""https://graph.windows.net"", ""UTF-8"")); <line8> final URL url = <line9> new URL( <line10> String.format(""https://login.microsoftonline.com/%s/oauth2/token"", tenant.getName())); <line11> final HttpsURLConnection connection = (HttpsURLConnection) url.openConnection(); <line12> connection.setRequestMethod(""POST""); <line13> connection.setRequestProperty(""Host"", ""login.microsoftonline.com""); <line14> connection.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded""); <line15> connection.setRequestProperty(""Accept"", ""application/json""); <line16> connection.setDoOutput(true); <line17> connection.getOutputStream().write(payload.getBytes()); <line18> connection.getOutputStream().flush(); <line19> final StringBuilder result = new StringBuilder(); <line20> try (final BufferedReader in = <line21> new BufferedReader(new InputStreamReader(connection.getInputStream()))) { <line22> for (String line = in.readLine(); line != null; line = in.readLine()) { <line23> result.append(line); <line24> } <line25> } <line26> final ObjectMapper mapper = new ObjectMapper(); <line27> final JsonNode node = mapper.readValue(result.toString().getBytes(), JsonNode.class); <line28> return node.get(""access_token"").asText(); <line29> } catch (IOException e) { <line30> return null; <line31> } catch (RuntimeException e) { <line32> return null; <line33> } <line34> } <line35> } <line36> "	<line30>, <line32>
6551	"public class A { <line0> @PostConstruct <line1> void connect() { <line2> if (customProducer.isResolvable()) { <line3> producer = customProducer.get(); <line4> return; <line5> } <line6> final Config config = ConfigProvider.getConfig(); <line7> connectionString = config.getValue(PROP_CONNECTION_STRING_NAME, String.class); <line8> eventHubName = config.getValue(PROP_EVENTHUB_NAME, String.class); <line9> partitionID = config.getOptionalValue(PROP_PARTITION_ID, String.class).orElse(""""); <line10> partitionKey = config.getOptionalValue(PROP_PARTITION_KEY, String.class).orElse(""""); <line11> maxBatchSize = config.getOptionalValue(PROP_MAX_BATCH_SIZE, Integer.class).orElse(0); <line12> String finalConnectionString = <line13> String.format(CONNECTION_STRING_FORMAT, connectionString, eventHubName); <line14> try { <line15> producer = <line16> new EventHubClientBuilder().connectionString(finalConnectionString).buildProducerClient(); <line17> } catch (Exception e) { <line18> throw new DebeziumException(e); <line19> } <line20> } <line21> } <line22> "	<line4>, <line20>
6552	"public class A { <line0> public void subscribeEventChannel() throws MagentaTVException { <line1> String sid = """"; <line2> String subscribe = <line3> MessageFormat.format( <line4> PAIRING_SUBSCRIBE, <line5> config.getIpAddress(), <line6> config.getPort(), <line7> network.getLocalIP(), <line8> network.getLocalPort(), <line9> PAIRING_NOTIFY_URI, <line10> PAIRING_TIMEOUT_SEC); <line11> String response = http.sendData(config.getIpAddress(), config.getPort(), subscribe); <line12> if (!response.contains(""200 OK"")) { <line13> response = substringBefore(response, ""SERVER""); <line14> throw new MagentaTVException(""Unable to subscribe to pairing channel: "" + response); <line15> } <line16> if (!response.contains(NOTIFY_SID)) { <line17> throw new MagentaTVException( <line18> ""Unable to subscribe to pairing channel, SID missing: "" + response); <line19> } <line20> StringTokenizer tokenizer = new StringTokenizer(response, ""\r\n""); <line21> while (tokenizer.hasMoreElements()) { <line22> String str = tokenizer.nextToken(); <line23> if (!str.isEmpty()) { <line24> if (str.contains(NOTIFY_SID)) { <line25> sid = str.substring(""SID: uuid:"".length()); <line26> break; <line27> } <line28> } <line29> } <line30> } <line31> } <line32> "	<line2>, <line26>
6553	public class A { <line0> static <T> boolean trySuccess(Promise<T> promise, T result) { <line1> final boolean notifiedRecords = promise.trySuccess(result); <line2> if (!notifiedRecords) { <line3> } <line4> return notifiedRecords; <line5> } <line6> } <line7> 	<line3>
6554	"public class A { <line0> private Set<String> keyspacesInCluster(AppContext context, Cluster cluster) <line1> throws ReaperException { <line2> List<String> keyspaces = ClusterFacade.create(context).getKeyspaces(cluster); <line3> if (keyspaces.isEmpty()) { <line4> String message = format(""No keyspace found in cluster %s"", cluster.getName()); <line5> throw new IllegalArgumentException(message); <line6> } <line7> return Sets.newHashSet(keyspaces); <line8> } <line9> } <line10> "	<line5>
6555	public class A { <line0> @Override <line1> public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) { <line2> } <line3> } <line4> 	<line2>
6556	"public class A { <line0> @Override <line1> public OQueryDataProvider<ODocument> getDataProviderForGenericSearch( <line2> OClass oClass, IModel<String> queryModel) { <line3> String searchSql = CustomAttribute.SEARCH_QUERY.getValue(oClass); <line4> String sql = null; <line5> if (!Strings.isEmpty(searchSql)) { <line6> String upper = searchSql.toUpperCase().trim(); <line7> if (upper.startsWith(""SELECT"")) sql = searchSql; <line8> else if (upper.startsWith(""WHERE"")) sql = ""select from "" + oClass.getName() + "" "" + searchSql; <line9> else { <line10> } <line11> } <line12> if (sql == null) sql = ""select from "" + oClass.getName() + "" where any() containstext :query""; <line13> return new OQueryDataProvider<ODocument>(sql).setParameter(""query"", queryModel); <line14> } <line15> } <line16> "	<line10>
6557	public class A { <line0> public void init() { <line1> requestDataService = new RequestDataService(daoManager); <line2> cleaner.scheduleWithFixedDelay( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> for (RequestedHostImpl requestedHost : requestDataService.getAll()) { <line7> if (requestedHost.getStatus() == ResourceHostRegistrationStatus.REQUESTED <line8> && System.currentTimeMillis() <line9> - (requestedHost.getDateUpdated() == null <line10> ? 0L <line11> : requestedHost.getDateUpdated()) <line12> > TimeUnit.MINUTES.toMillis(60)) { <line13> requestDataService.remove(requestedHost.getId()); <line14> } <line15> } <line16> } <line17> }, <line18> 3, <line19> 30, <line20> TimeUnit.MINUTES); <line21> } <line22> } <line23> 	<line13>
6558	public class A { <line0> public static void deleteAccountEntryUserRelByEmailAddress( <line1> long accountEntryId, String emailAddress) throws RemoteException { <line2> try { <line3> AccountEntryUserRelServiceUtil.deleteAccountEntryUserRelByEmailAddress( <line4> accountEntryId, emailAddress); <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>
6559	public class A { <line0> private void readObject(int index, DataInput in, DeserializationContext context) <line1> throws IOException, ClassNotFoundException { <line2> Object value; <line3> this.objectTypeArray[index] = in.readByte(); <line4> if (logger.isTraceEnabled(LogMarker.VERSIONED_OBJECT_LIST_VERBOSE)) { <line5> } <line6> boolean isException = this.objectTypeArray[index] == EXCEPTION; <line7> if (isException) { <line8> byte[] exBytes = DataSerializer.readByteArray(in); <line9> value = CacheServerHelper.deserialize(exBytes); <line10> DataSerializer.readString(in); <line11> } else if (this.serializeValues) { <line12> value = DataSerializer.readByteArray(in); <line13> } else { <line14> value = context.getDeserializer().readObject(in); <line15> } <line16> this.objects.add(value); <line17> } <line18> } <line19> 	<line5>
6560	public class A { <line0> private void preLoadClass( <line1> String agentId, <line2> long agentStartTimestamp, <line3> AgentStatMetricCollector<AgentStatMetricSnapshot> agentStatCollector) { <line4> CollectJob collectJob = <line5> new CollectJob( <line6> EmptyDataSender.INSTANCE, agentId, agentStartTimestamp, agentStatCollector, 1); <line7> collectJob.run(); <line8> collectJob.run(); <line9> } <line10> } <line11> 	<line4>, <line9>
6561	"public class A { <line0> public String computeDiffWithDiffCommand(File directoryVersionOne, File directoryVersionTwo) { <line1> final String command = <line2> String.join( <line3> "" "", <line4> new String[] { <line5> ""diff"", <line6> ""-ru"", <line7> directoryVersionOne.getAbsolutePath(), <line8> directoryVersionTwo.getAbsolutePath() <line9> }); <line10> return this.executeCommand(command, directoryVersionOne); <line11> } <line12> } <line13> "	<line1>
6562	public class A { <line0> @Override <line1> public boolean create(Personname personnameRecord) { <line2> return personnameRecord != null ? super.create(personnameRecord) : true; <line3> } <line4> } <line5> 	<line2>
6563	public class A { <line0> public BBSConfigSetting save(BBSConfigSetting bbsConfigSetting) throws Exception { <line1> BBSConfigSetting _bbsConfigSetting = null; <line2> try (EntityManagerContainer emc = EntityManagerContainerFactory.instance().create()) { <line3> _bbsConfigSetting = emc.find(bbsConfigSetting.getId(), BBSConfigSetting.class); <line4> if (_bbsConfigSetting != null) { <line5> emc.beginTransaction(BBSConfigSetting.class); <line6> bbsConfigSetting.copyTo(_bbsConfigSetting, JpaObject.FieldsUnmodify); <line7> emc.check(_bbsConfigSetting, CheckPersistType.all); <line8> emc.commit(); <line9> } else { <line10> emc.beginTransaction(BBSConfigSetting.class); <line11> emc.persist(bbsConfigSetting, CheckPersistType.all); <line12> emc.commit(); <line13> } <line14> } catch (Exception e) { <line15> throw e; <line16> } <line17> return bbsConfigSetting; <line18> } <line19> } <line20> 	<line15>
6564	"public class A { <line0> private static final void setupExplicitSubstitutionsMap() throws Exception { <line1> java.lang.ClassLoader classLoader = BestMatchingMapper.class.getClassLoader(); <line2> JAXBContext substitutionsContext = <line3> JAXBContext.newInstance(""org.docx4j.fonts.substitutions"", classLoader); <line4> Unmarshaller u2 = substitutionsContext.createUnmarshaller(); <line5> u2.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler()); <line6> java.io.InputStream is2 = null; <line7> is2 = <line8> org.docx4j.utils.ResourceUtils.getResource( <line9> ""org/docx4j/fonts/substitutions/FontSubstitutions.xml""); <line10> org.docx4j.fonts.substitutions.FontSubstitutions fs = <line11> (org.docx4j.fonts.substitutions.FontSubstitutions) u2.unmarshal(is2); <line12> List<FontSubstitutions.Replace> replaceList = fs.getReplace(); <line13> for (FontSubstitutions.Replace replacement : replaceList) { <line14> explicitSubstitutionsMap.put(replacement.getName(), replacement); <line15> } <line16> } <line17> } <line18> "	<line6>
6565	public class A { <line0> public boolean isEmailDomainValidationEnabled(ThemeDisplay themeDisplay) { <line1> try { <line2> AccountEntryEmailDomainsConfiguration accountEntryEmailDomainsConfiguration = <line3> ConfigurationProviderUtil.getCompanyConfiguration( <line4> AccountEntryEmailDomainsConfiguration.class, themeDisplay.getCompanyId()); <line5> if (accountEntryEmailDomainsConfiguration.enableEmailDomainValidation()) { <line6> return true; <line7> } <line8> } catch (ConfigurationException configurationException) { <line9> if (_log.isDebugEnabled()) { <line10> } <line11> } <line12> return false; <line13> } <line14> } <line15> 	<line10>
6566	"public class A { <line0> public static AccountsCommon createAccountInstance( <line1> String screenName, <line2> String userName, <line3> String passwd, <line4> String email, <line5> String tenantId, <line6> boolean useScreenName, <line7> boolean invalidTenant, <line8> boolean useUser, <line9> boolean usePassword) { <line10> AccountsCommon account = new AccountsCommon(); <line11> if (useScreenName) { <line12> account.setScreenName(screenName); <line13> } <line14> if (useUser) { <line15> account.setUserId(userName); <line16> } <line17> if (usePassword) { <line18> if (logger.isDebugEnabled()) { <line19> } <line20> account.setPassword(passwd.getBytes()); <line21> } <line22> account.setPersonRefName(screenName); <line23> account.setEmail(email); <line24> account.setPhone(""1234567890""); <line25> List<AccountTenant> atList = new ArrayList<AccountTenant>(); <line26> AccountTenant at = new AccountTenant(); <line27> if (!invalidTenant) { <line28> if (tenantId != null) { <line29> at.setTenantId(tenantId); <line30> atList.add(at); <line31> account.setTenants(atList); <line32> } <line33> } else { <line34> at.setTenantId(UUID.randomUUID().toString()); <line35> atList.add(at); <line36> account.setTenants(atList); <line37> } <line38> return account; <line39> } <line40> } <line41> "	<line19>
6567	public class A { <line0> private static void logPlatform(ExtensionOrigin o, MessageWriter log) { <line1> final ArtifactCoords bom = o.isPlatform() ? o.getBom() : null; <line2> if (bom != null) { <line3> } <line4> } <line5> } <line6> 	<line3>
6568	public class A { <line0> public final void init() { <line1> Logging.withPrefix( <line2> getName(), <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> onInit(); <line7> } <line8> }); <line9> } <line10> } <line11> 	<line6>, <line7>
6569	public class A { <line0> @Override <line1> public void closeNativeSession(String reason) { <line2> try { <line3> wsSession.close(new CloseStatus(CloseStatus.NORMAL.getCode(), reason)); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	<line5>
6570	public class A { <line0> private void addMetadataRecordImpl(final InputStream input, String name, long recordLength) <line1> throws DataStoreException { <line2> try { <line3> CloudBlobDirectory metaDir = getAzureContainer().getDirectoryReference(META_DIR_NAME); <line4> CloudBlockBlob blob = metaDir.getBlockBlobReference(name); <line5> addLastModified(blob); <line6> blob.upload(input, recordLength); <line7> } catch (StorageException e) { <line8> throw new DataStoreException(e); <line9> } catch (URISyntaxException | IOException e) { <line10> throw new DataStoreException(e); <line11> } <line12> } <line13> } <line14> 	<line8>
6571	"public class A { <line0> @Test(timeout = 60000) <line1> public void testCannotConnectWithSameContainerId() throws Exception { <line2> AmqpClient client = createAmqpClient(); <line3> List<Symbol> desiredCapabilities = new ArrayList<>(1); <line4> desiredCapabilities.add(AmqpSupport.SOLE_CONNECTION_CAPABILITY); <line5> assertNotNull(client); <line6> AmqpConnection connection1 = addConnection(client.createConnection()); <line7> AmqpConnection connection2 = addConnection(client.createConnection()); <line8> connection1.setDesiredCapabilities(desiredCapabilities); <line9> connection2.setDesiredCapabilities(desiredCapabilities); <line10> connection1.setContainerId(getTestName()); <line11> connection2.setContainerId(getTestName()); <line12> connection1.connect(); <line13> assertEquals(1, server.getConnectionCount()); <line14> connection2.setStateInspector( <line15> new AmqpValidator() { <line16> @Override <line17> public void inspectOpenedResource(Connection connection) { <line18> if (!connection.getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) { <line19> markAsInvalid(""Broker did not set connection establishment failed property""); <line20> } <line21> } <line22>  <line23> @Override <line24> public void inspectClosedResource(Connection connection) { <line25> ErrorCondition remoteError = connection.getRemoteCondition(); <line26> if (remoteError == null || remoteError.getCondition() == null) { <line27> markAsInvalid(""Broker did not add error condition for duplicate client ID""); <line28> } else { <line29> if (!remoteError.getCondition().equals(AmqpError.INVALID_FIELD)) { <line30> markAsInvalid(""Broker did not set condition to "" + AmqpError.INVALID_FIELD); <line31> } <line32> if (!remoteError.getCondition().equals(AmqpError.INVALID_FIELD)) { <line33> markAsInvalid(""Broker did not set condition to "" + AmqpError.INVALID_FIELD); <line34> } <line35> } <line36> Map<?, ?> infoMap = remoteError.getInfo(); <line37> if (infoMap == null) { <line38> markAsInvalid(""Broker did not set an info map on condition""); <line39> } else if (!infoMap.containsKey(INVALID_FIELD)) { <line40> markAsInvalid(""Info map does not contain expected key""); <line41> } else { <line42> Object value = infoMap.get(INVALID_FIELD); <line43> if (!CONTAINER_ID.equals(value)) { <line44> markAsInvalid(""Info map does not contain expected value: "" + value); <line45> } <line46> } <line47> } <line48> }); <line49> try { <line50> connection2.connect(); <line51> fail(""Should not be able to connect with same container Id.""); <line52> } catch (Exception ex) { <line53> } <line54> connection2.getStateInspector().assertValid(); <line55> connection2.close(); <line56> Wait.assertEquals(1, server::getConnectionCount); <line57> connection1.close(); <line58> Wait.assertEquals(0, server::getConnectionCount); <line59> } <line60> } <line61> "	<line53>
6572	"public class A { <line0> private HttpClientConfigurer configureHttpProxy( <line1> Map<String, Object> parameters, HttpClientConfigurer configurer, boolean secure) <line2> throws Exception { <line3> String proxyAuthScheme = <line4> getParameter(parameters, ""proxyAuthScheme"", String.class, getProxyAuthScheme()); <line5> if (proxyAuthScheme == null) { <line6> proxyAuthScheme = secure ? ""https"" : ""http""; <line7> } <line8> String proxyAuthHost = <line9> getParameter(parameters, ""proxyAuthHost"", String.class, getProxyAuthHost()); <line10> Integer proxyAuthPort = <line11> getParameter(parameters, ""proxyAuthPort"", Integer.class, getProxyAuthPort()); <line12> if (proxyAuthHost == null) { <line13> proxyAuthHost = getParameter(parameters, ""proxyHost"", String.class); <line14> } <line15> if (proxyAuthPort == null) { <line16> proxyAuthPort = getParameter(parameters, ""proxyPort"", Integer.class); <line17> } <line18> if (proxyAuthHost != null && proxyAuthPort != null) { <line19> String proxyAuthUsername = <line20> getParameter(parameters, ""proxyAuthUsername"", String.class, getProxyAuthUsername()); <line21> String proxyAuthPassword = <line22> getParameter(parameters, ""proxyAuthPassword"", String.class, getProxyAuthPassword()); <line23> String proxyAuthDomain = <line24> getParameter(parameters, ""proxyAuthDomain"", String.class, getProxyAuthDomain()); <line25> String proxyAuthNtHost = <line26> getParameter(parameters, ""proxyAuthNtHost"", String.class, getProxyAuthNtHost()); <line27> if (proxyAuthUsername != null && proxyAuthPassword != null) { <line28> return CompositeHttpConfigurer.combineConfigurers( <line29> configurer, <line30> new ProxyHttpClientConfigurer( <line31> proxyAuthHost, <line32> proxyAuthPort, <line33> proxyAuthScheme, <line34> proxyAuthUsername, <line35> proxyAuthPassword, <line36> proxyAuthDomain, <line37> proxyAuthNtHost)); <line38> } else { <line39> return CompositeHttpConfigurer.combineConfigurers( <line40> configurer, <line41> new ProxyHttpClientConfigurer(proxyAuthHost, proxyAuthPort, proxyAuthScheme)); <line42> } <line43> } <line44> return configurer; <line45> } <line46> } <line47> "	<line27>
6573	"public class A { <line0> public String createSession(String username, String baseDatabaseName) <line1> throws InvalidSessionException { <line2> String sessionId; <line3> Session oldSession; <line4> sessionId = UUID.randomUUID().toString(); <line5> Session newSession = new Session(sessionId, username, baseDatabaseName); <line6> oldSession = sessions.putIfAbsent(sessionId, newSession); <line7> if (oldSession != null) { <line8> throw new InvalidSessionException(""Session id is duplicated: "" + oldSession.getSessionId()); <line9> } <line10> return sessionId; <line11> } <line12> } <line13> "	<line10>
6574	public class A { <line0> boolean removeQueueEvent(String regionName, HARegionQueue hrq, EventID id) { <line1> boolean interrupted = Thread.interrupted(); <line2> try { <line3> if (logger.isTraceEnabled()) { <line4> } <line5> hrq.removeDispatchedEvents(id); <line6> } catch (RegionDestroyedException ignore) { <line7> } catch (CancelException ignore) { <line8> return false; <line9> } catch (CacheException e) { <line10> } catch (InterruptedException ignore) { <line11> Thread.currentThread().interrupt(); <line12> return false; <line13> } catch (RejectedExecutionException ignore) { <line14> interrupted = true; <line15> } finally { <line16> if (interrupted) { <line17> Thread.currentThread().interrupt(); <line18> } <line19> } <line20> return true; <line21> } <line22> } <line23> 	<line4>, <line7>, <line10>
6575	public class A { <line0> @Override <line1> public void sendPing(TelemetryWebSocketSessionRef sessionRef, long currentTime) <line2> throws IOException { <line3> String externalId = sessionRef.getSessionId(); <line4> String internalId = externalSessionMap.get(externalId); <line5> if (internalId != null) { <line6> SessionMetaData sessionMd = internalSessionMap.get(internalId); <line7> if (sessionMd != null) { <line8> sessionMd.sendPing(currentTime); <line9> } else { <line10> } <line11> } else { <line12> } <line13> } <line14> } <line15> 	<line10>, <line12>
6576	public class A { <line0> private void stopList(Queue<Object> instances, Class<? extends Annotation> annotation) { <line1> List<Object> reversedInstances = Lists.newArrayList(instances); <line2> Collections.reverse(reversedInstances); <line3> for (Object obj : reversedInstances) { <line4> LifeCycleMethods methods = methodsMap.get(obj.getClass()); <line5> for (Method preDestroy : methods.methodsFor(annotation)) { <line6> try { <line7> preDestroy.invoke(obj); <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> } <line13> } <line14> 	<line4>, <line6>, <line9>
6577	public class A { <line0> private void send(final ByteBuffer buffer) { <line1> buffer.flip(); <line2> try { <line3> while (buffer.hasRemaining()) { <line4> this.socketChannel.write(buffer); <line5> } <line6> } catch (final IOException e) { <line7> } <line8> buffer.clear(); <line9> } <line10> } <line11> 	<line7>
6578	"public class A { <line0> @Override <line1> public void run() { <line2> synchronized (query) { <line3> try { <line4> logSegregationContext.setLogSegragationAndQueryId(query.getQueryHandleString()); <line5> acquire(query.getLensSessionIdentifier()); <line6> if (!query.getStatus().cancelled()) { <line7> launchQuery(query); <line8> } <line9> } catch (Exception e) { <line10> if (!query.getStatus().cancelled()) { <line11> incrCounter(QUERY_SUBMITTER_COUNTER); <line12> try { <line13> setFailedStatus(query, ""Launching query failed"", e); <line14> } catch (LensException e1) { <line15> } <line16> } <line17> } finally { <line18> query.setLaunching(false); <line19> try { <line20> release(query.getLensSessionIdentifier()); <line21> } catch (LensException e) { <line22> } <line23> } <line24> } <line25> } <line26> } <line27> "	<line5>, <line11>, <line15>, <line22>
6579	public class A { <line0> public synchronized void deactivateSplitSource(MarkerSplitSource splitSource) { <line1> if (activeSplitSources.remove(splitSource)) { <line2> for (MarkerSplitSource source : activeSplitSources) { <line3> source.finishDependency(splitSource); <line4> } <line5> if (!markerSplitSent.contains(splitSource)) { <line6> checkMarkerSplitCompleteness(); <line7> } <line8> } <line9> } <line10> } <line11> 	<line5>
6580	"public class A { <line0> @Test( <line1> dataProvider = ""testName"", <line2> groups = {""readItem""}, <line3> dependsOnMethods = {""readItem""}) <line4> public void readContact(String testName) throws Exception { <line5> setupRead(); <line6> OrganizationClient client = new OrganizationClient(); <line7> Response res = client.readContact(knownResourceId, knownItemResourceId, knownContactResourceId); <line8> try { <line9> assertStatusCode(res, testName); <line10> PoxPayloadIn input = new PoxPayloadIn(res.readEntity(String.class)); <line11> ContactsCommon contact = <line12> (ContactsCommon) <line13> extractPart(input, new ContactClient().getCommonPartName(), ContactsCommon.class); <line14> Assert.assertNotNull(contact); <line15> boolean showFull = true; <line16> if (showFull && logger.isDebugEnabled()) { <line17> } <line18> Assert.assertEquals(contact.getInAuthority(), knownResourceId); <line19> Assert.assertEquals(contact.getInItem(), knownItemResourceId); <line20> } finally { <line21> if (res != null) { <line22> res.close(); <line23> } <line24> } <line25> } <line26> } <line27> "	<line17>
6581	public class A { <line0> private Mono<Void> doShutdown() { <line1> return Mono.defer( <line2> () -> { <line3> return Mono.whenDelayError( <line4> processBeforeDestroy(), <line5> compositeDiscovery.shutdown(), <line6> gatewayBootstrap.shutdown(), <line7> transportBootstrap.shutdown()) <line8> }); <line9> } <line10> } <line11> 	<line3>, <line8>
6582	"public class A { <line0> @Override <line1> public <T extends IChemObject> T read(T object) throws CDKException { <line2> if (object instanceof IChemFile) { <line3> IChemFile cf = (IChemFile) object; <line4> try { <line5> cf = readChemFile(cf); <line6> } catch (IOException exception) { <line7> String error = ""Input/Output error while reading from input: "" + exception.getMessage(); <line8> throw new CDKException(error, exception); <line9> } <line10> return (T) cf; <line11> } else { <line12> throw new CDKException(""Only supported is reading of ChemFile.""); <line13> } <line14> } <line15> } <line16> "	<line8>
6583	"public class A { <line0> private String getMaxDateWithDataInDB(UpdateInfo updateInfo) { <line1> final String entityName = JPAUtils.getEntityName(MovesPlaceFacet.class); <line2> final List<MovesPlaceFacet> newest = <line3> jpaDaoService.executeQueryWithLimit( <line4> ""SELECT facet from "" <line5> + entityName <line6> + "" facet WHERE facet.apiKeyId=? ORDER BY facet.end DESC,facet.date DESC"", <line7> 1, <line8> MovesPlaceFacet.class, <line9> updateInfo.apiKey.getId()); <line10> String ret = null; <line11> if (newest.size() > 0) { <line12> ret = newest.get(0).date; <line13> } else { <line14> } <line15> return ret; <line16> } <line17> } <line18> "	<line13>, <line14>
6584	public class A { <line0> private Object convertDocFieldToAvroField( <line1> final Schema fieldSchema, <line2> final OrientDBMapping.DocumentFieldType storeType, <line3> final Schema.Field field, <line4> final String docf, <line5> final ODocument obj) <line6> throws GoraException { <line7> Object result = null; <line8> switch (fieldSchema.getType()) { <line9> case MAP: <line10> result = convertDocFieldToAvroMap(docf, fieldSchema, obj, field, storeType); <line11> break; <line12> case ARRAY: <line13> result = convertDocFieldToAvroList(docf, fieldSchema, obj, field, storeType); <line14> break; <line15> case RECORD: <line16> ODocument record = obj.field(docf); <line17> if (record == null) { <line18> result = null; <line19> break; <line20> } <line21> result = convertAvroBeanToOrientDoc(fieldSchema, record); <line22> break; <line23> case BOOLEAN: <line24> result = OType.convert(obj.field(docf), Boolean.class); <line25> break; <line26> case DOUBLE: <line27> result = OType.convert(obj.field(docf), Double.class); <line28> break; <line29> case FLOAT: <line30> result = OType.convert(obj.field(docf), Float.class); <line31> break; <line32> case INT: <line33> result = OType.convert(obj.field(docf), Integer.class); <line34> break; <line35> case LONG: <line36> result = OType.convert(obj.field(docf), Long.class); <line37> break; <line38> case STRING: <line39> result = convertDocFieldToAvroString(storeType, docf, obj); <line40> break; <line41> case ENUM: <line42> result = AvroUtils.getEnumValue(fieldSchema, obj.field(docf)); <line43> break; <line44> case BYTES: <line45> case FIXED: <line46> if (obj.field(docf) == null) { <line47> result = null; <line48> break; <line49> } <line50> result = ByteBuffer.wrap((byte[]) obj.field(docf)); <line51> break; <line52> case NULL: <line53> result = null; <line54> break; <line55> case UNION: <line56> result = convertDocFieldToAvroUnion(fieldSchema, storeType, field, docf, obj); <line57> break; <line58> default: <line59> break; <line60> } <line61> return result; <line62> } <line63> } <line64> 	<line59>
6585	public class A { <line0> public void takeOverAccessCount(ActionInfo actionInfo) { <line1> List<String> smallFiles = getSmallFileList(actionInfo); <line2> List<Long> oldFids = actionInfo.getOldFileIds(); <line3> try { <line4> for (int i = 0; i < smallFiles.size(); i++) { <line5> String filePath = smallFiles.get(i); <line6> long oldFid = oldFids.get(i); <line7> long newFid = dfsClient.getFileInfo(filePath).getFileId(); <line8> metaStore.updateAccessCountTableFid(oldFid, newFid); <line9> } <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	<line11>
6586	public class A { <line0> public synchronized void deleteUser(User user) throws IOException { <line1> String username = user.getName(); <line2> for (Group group : groups.values()) { <line3> group.removeMember(user.getId()); <line4> } <line5> users.remove(username); <line6> persistChanges(); <line7> } <line8> } <line9> 	<line2>
6587	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private <T> T lookupInJndi(String objName) throws Exception { <line2> ClassLoader old = Thread.currentThread().getContextClassLoader(); <line3> Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); <line4> try { <line5> InitialContext ctx = null; <line6> try { <line7> ctx = new InitialContext(); <line8> return (T) ctx.lookup(objName); <line9> } finally { <line10> if (ctx != null) <line11> try { <line12> ctx.close(); <line13> } catch (Exception ex1) { <line14> } <line15> } <line16> } finally { <line17> Thread.currentThread().setContextClassLoader(old); <line18> } <line19> } <line20> } <line21> "	<line14>
6588	"public class A { <line0> private String executeCommand(String command, File pathToWorkingDirectory) { <line1> ExecutorService executor = Executors.newSingleThreadExecutor(); <line2> final Process process; <line3> try { <line4> process = Runtime.getRuntime().exec(command, null, pathToWorkingDirectory); <line5> } catch (IOException e) { <line6> throw new RuntimeException(e); <line7> } <line8> final Future<?> submit = <line9> executor.submit( <line10> () -> { <line11> try { <line12> process.waitFor(); <line13> } catch (Exception e) { <line14> throw new RuntimeException(e); <line15> } <line16> }); <line17> try { <line18> submit.get(5, TimeUnit.SECONDS); <line19> if (process != null) { <line20> InputStreamReader inputStreamReader = new InputStreamReader(process.getInputStream()); <line21> int current; <line22> StringBuilder output = new StringBuilder(); <line23> while (true) { <line24> try { <line25> if ((current = inputStreamReader.read()) == -1) { <line26> break; <line27> } <line28> output.append((char) current); <line29> } catch (Exception e) { <line30> throw new RuntimeException(e); <line31> } <line32> } <line33> try (FileWriter writer = new FileWriter(pathToWorkingDirectory + DIFF_FILE_NAME, false)) { <line34> writer.write(output.toString()); <line35> } catch (Exception e) { <line36> throw new RuntimeException(e); <line37> } <line38> return output.toString(); <line39> } else { <line40> return """"; <line41> } <line42> } catch (Exception e) { <line43> throw new RuntimeException(e); <line44> } finally { <line45> if (process != null) { <line46> process.destroyForcibly(); <line47> } <line48> submit.cancel(true); <line49> executor.shutdownNow(); <line50> } <line51> } <line52> } <line53> "	<line1>
6589	"public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> checkNotNull(destinationDir, ""destinationDir""); <line3> BrooklynLauncher launcher; <line4> failIfArguments(); <line5> try { <line6> PersistMode persistMode = PersistMode.REBIND; <line7> HighAvailabilityMode highAvailabilityMode = HighAvailabilityMode.DISABLED; <line8> launcher = <line9> BrooklynLauncher.newInstance() <line10> .localBrooklynPropertiesFile(localBrooklynProperties) <line11> .brooklynProperties(OsgiManager.USE_OSGI, false) <line12> .persistMode(persistMode) <line13> .persistenceDir(persistenceDir) <line14> .persistenceLocation(persistenceLocation) <line15> .highAvailabilityMode(highAvailabilityMode); <line16> } catch (FatalConfigurationRuntimeException e) { <line17> throw e; <line18> } catch (Exception e) { <line19> throw new FatalConfigurationRuntimeException( <line20> ""Fatal error configuring Brooklyn launch: "" + e.getMessage(), e); <line21> } <line22> try { <line23> launcher.cleanOrphanedState(destinationDir, destinationLocation); <line24> } catch (FatalRuntimeException e) { <line25> throw e; <line26> } catch (Exception e) { <line27> Exceptions.propagateIfFatal(e); <line28> Exceptions.propagate(e); <line29> } finally { <line30> try { <line31> launcher.terminate(); <line32> } catch (Exception e2) { <line33> } <line34> } <line35> return null; <line36> } <line37> } <line38> "	<line6>, <line28>, <line33>
6590	"public class A { <line0> @Override <line1> public void start() { <line2> sinkCounter.start(); <line3> super.start(); <line4> pathController.setBaseDirectory(directory); <line5> if (rollInterval > 0) { <line6> rollService = <line7> Executors.newScheduledThreadPool( <line8> 1, <line9> new ThreadFactoryBuilder() <line10> .setNameFormat(""rollingFileSink-roller-"" + Thread.currentThread().getId() + ""-%d"") <line11> .build()); <line12> rollService.scheduleAtFixedRate( <line13> new Runnable() { <line14> @Override <line15> public void run() { <line16> shouldRotate = true; <line17> } <line18> }, <line19> rollInterval, <line20> rollInterval, <line21> TimeUnit.SECONDS); <line22> } else { <line23> } <line24> } <line25> } <line26> "	<line2>, <line16>, <line23>, <line24>
6591	public class A { <line0> public Optional<MailAddress> asMailAddress() { <line1> return user.flatMap( <line2> user -> { <line3> try { <line4> return Optional.of(user.asMailAddress()); <line5> } catch (AddressException e) { <line6> return Optional.empty(); <line7> } <line8> }); <line9> } <line10> } <line11> 	<line6>
6592	"public class A { <line0> private void verifyCA(final X509Certificate cert) throws ClientException { <line1> CertificateVerificationCallback callback = new CertificateVerificationCallback(cert); <line2> try { <line3> Callback[] callbacks = new Callback[1]; <line4> callbacks[0] = callback; <line5> handler.handle(callbacks); <line6> } catch (UnsupportedCallbackException e) { <line7> LOGGER.debug(""Certificate verification failed.""); <line8> throw new ClientException(e); <line9> } catch (IOException e) { <line10> throw new ClientException(e); <line11> } <line12> if (!callback.isVerified()) { <line13> throw new ClientException(""CA certificate fingerprint could not be verified.""); <line14> } else { <line15> } <line16> } <line17> } <line18> "	<line3>, <line13>, <line15>
6593	public class A { <line0> public void update(List<Task> criticalPath) { <line1> if (criticalPath.isEmpty()) { <line2> return; <line3> } <line4> progressAllByNumHours = rootTask.getOrderElement().getAdvancePercentageChildren(); <line5> progressByDuration = calculateByDuration(criticalPath); <line6> progressByNumHours = calculateByNumHours(criticalPath); <line7> Date now = new Date(); <line8> theoreticalProgressByNumHoursForAllTasks = <line9> rootTask.getTheoreticalAdvancePercentageUntilDate(now); <line10> theoreticalProgressByDurationForCriticalPath = <line11> calculateTheoreticalAdvanceByDurationForCriticalPath(criticalPath, now); <line12> theoreticalProgressByNumHoursForCriticalPath = <line13> calculateTheoreticalAdvanceByNumHoursForCriticalPath(criticalPath, now); <line14> } <line15> } <line16> 	<line2>
6594	"public class A { <line0> public static com.liferay.sharing.model.SharingEntry deleteSharingEntry( <line1> HttpPrincipal httpPrincipal, <line2> long sharingEntryId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = <line7> new MethodKey( <line8> SharingEntryServiceUtil.class, <line9> ""deleteSharingEntry"", <line10> _deleteSharingEntryParameterTypes2); <line11> MethodHandler methodHandler = new MethodHandler(methodKey, sharingEntryId, serviceContext); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.sharing.model.SharingEntry) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>
6595	"public class A { <line0> @Secured(ServicesData.ROLE_GET_INGEST) <line1> @GetMapping(CommonConstants.PATH_ID) <line2> public LogbookOperationDto getOne(@PathVariable(""id"") final String id) { <line3> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line4> return ingestExternalService.getOne(id); <line5> } <line6> } <line7> "	<line3>
6596	public class A { <line0> @Override <line1> public synchronized Collection<OpMessage<OutT>> processWatermark(long time) { <line2> assert outputList.isEmpty(); <line3> try { <line4> op.processWatermark(new Instant(time), emitter); <line5> } catch (Exception e) { <line6> throw UserCodeException.wrap(e); <line7> } <line8> final List<OpMessage<OutT>> results = new ArrayList<>(outputList); <line9> outputList.clear(); <line10> return results; <line11> } <line12> } <line13> 	<line6>
6597	public class A { <line0> @Test <line1> @Order(1) <line2> void sampleBook_shouldHave_injectionPointsResolved() { <line3> val book = getSampleBook(); <line4> assertTrue(book.hasInjectionPointsResolved()); <line5> } <line6> } <line7> 	<line3>, <line5>
6598	public class A { <line0> @Override <line1> public void cleanup() { <line2> sendHeartBeat.set(false); <line3> for (Entry<HiveEndPoint, HiveWriter> entry : allWriters.entrySet()) { <line4> try { <line5> HiveWriter w = entry.getValue(); <line6> w.flushAndClose(); <line7> } catch (Exception ex) { <line8> if (ex instanceof InterruptedException) { <line9> Thread.currentThread().interrupt(); <line10> } <line11> } <line12> } <line13> ExecutorService[] toShutdown = {callTimeoutPool}; <line14> for (ExecutorService execService : toShutdown) { <line15> execService.shutdown(); <line16> try { <line17> while (!execService.isTerminated()) { <line18> execService.awaitTermination(options.getCallTimeOut(), TimeUnit.MILLISECONDS); <line19> } <line20> } catch (InterruptedException ex) { <line21> } <line22> } <line23> callTimeoutPool = null; <line24> if (heartBeatTimer != null) { <line25> heartBeatTimer.cancel(); <line26> } <line27> super.cleanup(); <line28> } <line29> } <line30> 	<line8>, <line21>, <line28>
6599	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (status.compareAndSet(Status.QUEUED, Status.RUNNING)) { <line4> queuedTask.remove(this); <line5> compactable.compact(csid, getJob(), readLimiter, writeLimiter, queuedTime); <line6> completionCallback.accept(compactable); <line7> } <line8> } catch (Exception e) { <line9> status.compareAndSet(Status.RUNNING, Status.FAILED); <line10> } finally { <line11> status.compareAndSet(Status.RUNNING, Status.COMPLETE); <line12> } <line13> } <line14> } <line15> 	<line9>
6600	public class A { <line0> protected InputStream getConfigurationInputStream(String resource) throws HibernateException { <line1> return ConfigHelper.getResourceAsStream(resource); <line2> } <line3> } <line4> 	<line1>
6601	public class A { <line0> private Connection getConnection() throws SQLException { <line1> if (connection == null) { <line2> this.connection = <line3> DriverManager.getConnection(config.hiveJDBCUrl, config.hiveUsername, config.hivePassword); <line4> } <line5> return connection; <line6> } <line7> } <line8> 	<line2>
6602	"public class A { <line0> @Test <line1> public void testBadPassword_PreHashedServer() throws Exception { <line2> Map<String, Object> serverProps = new HashMap<String, Object>(); <line3> serverProps.put(REALM_PROPERTY, ""TestRealm""); <line4> serverProps.put(PRE_DIGESTED_PROPERTY, ""true""); <line5> SaslServer server = <line6> new SaslServerBuilder(DigestServerFactory.class, DIGEST) <line7> .setUserName(""George"") <line8> .setPassword( <line9> DigestPassword.ALGORITHM_DIGEST_MD5, <line10> getDigestKeySpec(""George"", ""gpwd"", ""TestRealm"")) <line11> .setProperties(serverProps) <line12> .setProtocol(""TestProtocol"") <line13> .setServerName(""TestServer"") <line14> .build(); <line15> CallbackHandler clientCallback = createClearPwdClientCallbackHandler(""George"", ""bad"", null); <line16> SaslClient client = <line17> Sasl.createSaslClient( <line18> new String[] {DIGEST}, <line19> ""George"", <line20> ""TestProtocol"", <line21> ""TestServer"", <line22> Collections.<String, Object>emptyMap(), <line23> clientCallback); <line24> assertFalse(client.hasInitialResponse()); <line25> byte[] message = server.evaluateResponse(new byte[0]); <line26> message = client.evaluateChallenge(message); <line27> try { <line28> server.evaluateResponse(message); <line29> fail(""Expection exception not thrown.""); <line30> } catch (IOException e) { <line31> } <line32> } <line33> } <line34> "	<line26>, <line27>
6603	public class A { <line0> @Override <line1> public int indexOf(ISingleElectron electron) { <line2> return super.indexOf(electron); <line3> } <line4> } <line5> 	<line2>
6604	public class A { <line0> private File writeInTmpFile(File tmp, InputStream fis) throws IOException { <line1> FileOutputStream fos = new FileOutputStream(tmp); <line2> try { <line3> StorageUtils.writeInOut(fis, fos, true); <line4> return tmp; <line5> } catch (Exception e) { <line6> return null; <line7> } finally { <line8> fos.close(); <line9> fis.close(); <line10> } <line11> } <line12> } <line13> 	<line6>
6605	"public class A { <line0> public static LdapContext getWiredContext( <line1> LdapServer ldapServer, String principalDn, String password) throws NamingException { <line2> Hashtable<String, String> env = new Hashtable<>(); <line3> env.put(Context.INITIAL_CONTEXT_FACTORY, CTX_FACTORY); <line4> env.put(Context.PROVIDER_URL, Network.ldapLoopbackUrl(ldapServer.getPort())); <line5> env.put(Context.SECURITY_PRINCIPAL, principalDn); <line6> env.put(Context.SECURITY_CREDENTIALS, password); <line7> env.put(Context.SECURITY_AUTHENTICATION, ""simple""); <line8> return new InitialLdapContext(env, null); <line9> } <line10> } <line11> "	<line2>
6606	"public class A { <line0> @Test <line1> public void simpleReadUUID() throws Exception { <line2> final EntityManager em = app.getEntityManager(); <line3> final long stopTime = System.currentTimeMillis() + RUNTIME; <line4> final Map<String, Object> entityMap = new HashMap<>(); <line5> entityMap.put(""key1"", 1000); <line6> entityMap.put(""key2"", 2000); <line7> entityMap.put(""key3"", ""Some value""); <line8> List<UUID> uuids = new ArrayList<UUID>(); <line9> int i = 0; <line10> while (System.currentTimeMillis() < stopTime) { <line11> entityMap.put(""key"", i); <line12> final Entity created = em.create(""testType"", entityMap); <line13> uuids.add(created.getUuid()); <line14> i++; <line15> if (i % 1000 == 0) { <line16> } <line17> Thread.sleep(writeDelayMs); <line18> } <line19> final String meterName = this.getClass().getSimpleName() + "".simpleReadUUID""; <line20> final Meter meter = registry.meter(meterName); <line21> for (UUID uuid : uuids) { <line22> Entity entity = em.get(uuid); <line23> meter.mark(); <line24> Thread.sleep(readDelayMs); <line25> } <line26> registry.remove(meterName); <line27> } <line28> } <line29> "	<line2>, <line16>, <line19>, <line27>
6607	"public class A { <line0> public static int getAssetListEntriesCount(HttpPrincipal httpPrincipal, long groupId) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey( <line4> AssetListEntryServiceUtil.class, <line5> ""getAssetListEntriesCount"", <line6> _getAssetListEntriesCountParameterTypes18); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line13> } <line14> return ((Integer) returnObj).intValue(); <line15> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	<line16>
6608	public class A { <line0> void sortAuthorizablesForDeletion(List<Authorizable> authorizablesToDelete) <line1> throws RepositoryException { <line2> outer: <line3> for (int i = 0; i < authorizablesToDelete.size(); ) { <line4> Authorizable currentAuthorizable = authorizablesToDelete.get(i); <line5> Iterator<Group> declaredMemberOfIt = currentAuthorizable.declaredMemberOf(); <line6> while (declaredMemberOfIt != null && declaredMemberOfIt.hasNext()) { <line7> Group groupOfAuthorizable = declaredMemberOfIt.next(); <line8> int groupOfAuthorizableIndex = authorizablesToDelete.indexOf(groupOfAuthorizable); <line9> if (groupOfAuthorizableIndex > -1 && groupOfAuthorizableIndex < i) { <line10> authorizablesToDelete.set(groupOfAuthorizableIndex, currentAuthorizable); <line11> authorizablesToDelete.set(i, groupOfAuthorizable); <line12> i = groupOfAuthorizableIndex; <line13> continue outer; <line14> } <line15> } <line16> i++; <line17> } <line18> } <line19> } <line20> 	<line6>, <line9>, <line10>
6609	"public class A { <line0> @GET <line1> @Timed <line2> @Compress <line3> @Produces(APPLICATION_JSON_WITH_CHARSET) <line4> public String list( <line5> @Context GraphManager manager, <line6> @PathParam(""graph"") String graph, <line7> @QueryParam(""ids"") List<String> stringIds) { <line8> E.checkArgument( <line9> stringIds != null && !stringIds.isEmpty(), ""The ids parameter can't be null or empty""); <line10> Object[] ids = new Id[stringIds.size()]; <line11> for (int i = 0; i < ids.length; i++) { <line12> ids[i] = HugeEdge.getIdValue(stringIds.get(i), false); <line13> } <line14> HugeGraph g = graph(manager, graph); <line15> Iterator<Edge> edges = g.edges(ids); <line16> return manager.serializer(g).writeEdges(edges, false); <line17> } <line18> } <line19> "	<line8>
6610	public class A { <line0> private void stopTimer() { <line1> if (myTimer != null) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> myTimer.cancel(); <line5> myTimer = null; <line6> } <line7> } <line8> } <line9> 	<line3>
6611	"public class A { <line0> @GET <line1> @Path(""/address/regions/{countryId}"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> public Response getRegions( <line4> @PathParam(""countryId"") long countryId, @Context ThemeDisplay themeDisplay) { <line5> List<RegionModel> regionModels = new ArrayList<>(); <line6> List<Region> regions = _regionService.getRegions(countryId, true); <line7> for (Region region : regions) { <line8> regionModels.add(new RegionModel(region.getRegionId(), region.getName())); <line9> } <line10> try { <line11> String json = _OBJECT_MAPPER.writeValueAsString(regionModels); <line12> return Response.ok(json, MediaType.APPLICATION_JSON).build(); <line13> } catch (JsonProcessingException jsonProcessingException) { <line14> } <line15> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build(); <line16> } <line17> } <line18> "	<line14>
6612	public class A { <line0> @Override <line1> public PdxType getType(int typeId) { <line2> Collection<Pool> pools = getAllPools(); <line3> ServerConnectivityException lastException = null; <line4> for (Pool pool : pools) { <line5> try { <line6> PdxType type = GetPDXTypeByIdOp.execute((ExecutablePool) pool, typeId); <line7> if (type != null) { <line8> return type; <line9> } <line10> } catch (ServerConnectivityException e) { <line11> lastException = e; <line12> } <line13> } <line14> if (lastException != null) { <line15> throw lastException; <line16> } else { <line17> throw returnCorrectExceptionForFailure(pools, typeId, lastException); <line18> } <line19> } <line20> } <line21> 	<line11>
6613	public class A { <line0> private boolean isWritablePath(Path path, FileSystem fileSystem) throws InterruptedIOException { <line1> try { <line2> FileStatus fileStatus = fileSystem.getFileStatus(path); <line3> if (fileStatus.isDirectory()) { <line4> fileSystem.access(path, FsAction.WRITE); <line5> return true; <line6> } <line7> } catch (FileNotFoundException e) { <line8> Path parent = path.getParent(); <line9> if (parent != null) { <line10> return isWritablePath(parent, fileSystem); <line11> } <line12> } catch (InterruptedIOException ioe) { <line13> throw ioe; <line14> } catch (Exception e) { <line15> } <line16> return false; <line17> } <line18> } <line19> 	<line15>
6614	"public class A { <line0> @Override <line1> public void processOpts() { <line2> super.processOpts(); <line3> if (StringUtils.isEmpty(System.getenv(""DART_POST_PROCESS_FILE""))) { <line4> } <line5> if (!additionalProperties.containsKey(CodegenConstants.SERIALIZATION_LIBRARY)) { <line6> additionalProperties.put( <line7> CodegenConstants.SERIALIZATION_LIBRARY, SERIALIZATION_LIBRARY_DEFAULT); <line8> } <line9> setLibrary(additionalProperties.get(CodegenConstants.SERIALIZATION_LIBRARY).toString()); <line10> if (!additionalProperties.containsKey(DATE_LIBRARY)) { <line11> additionalProperties.put(DATE_LIBRARY, DATE_LIBRARY_DEFAULT); <line12> } <line13> setDateLibrary(additionalProperties.get(DATE_LIBRARY).toString()); <line14> if (!additionalProperties.containsKey(CLIENT_NAME)) { <line15> final String name = org.openapitools.codegen.utils.StringUtils.camelize(pubName); <line16> additionalProperties.put(CLIENT_NAME, name); <line17> } <line18> setClientName(additionalProperties.get(CLIENT_NAME).toString()); <line19> supportingFiles.add(new SupportingFile(""pubspec.mustache"", """", ""pubspec.yaml"")); <line20> supportingFiles.add( <line21> new SupportingFile(""analysis_options.mustache"", """", ""analysis_options.yaml"")); <line22> supportingFiles.add(new SupportingFile(""gitignore.mustache"", """", "".gitignore"")); <line23> supportingFiles.add(new SupportingFile(""README.mustache"", """", ""README.md"")); <line24> final String libFolder = sourceFolder + File.separator + ""lib""; <line25> supportingFiles.add(new SupportingFile(""lib.mustache"", libFolder, pubName + "".dart"")); <line26> final String srcFolder = libFolder + File.separator + ""src""; <line27> supportingFiles.add(new SupportingFile(""api_client.mustache"", srcFolder, ""api.dart"")); <line28> supportingFiles.add(new SupportingFile(""api_util.mustache"", srcFolder, ""api_util.dart"")); <line29> final String authFolder = srcFolder + File.separator + ""auth""; <line30> supportingFiles.add( <line31> new SupportingFile(""auth/api_key_auth.mustache"", authFolder, ""api_key_auth.dart"")); <line32> supportingFiles.add( <line33> new SupportingFile(""auth/basic_auth.mustache"", authFolder, ""basic_auth.dart"")); <line34> supportingFiles.add(new SupportingFile(""auth/oauth.mustache"", authFolder, ""oauth.dart"")); <line35> supportingFiles.add(new SupportingFile(""auth/auth.mustache"", authFolder, ""auth.dart"")); <line36> configureSerializationLibrary(srcFolder); <line37> configureDateLibrary(srcFolder); <line38> } <line39> } <line40> "	<line4>, <line8>, <line12>, <line17>
6615	public class A { <line0> @Override <line1> public void delete(final String id) throws SeriesServiceDatabaseException { <line2> if (synchronousIndexing) { <line3> try { <line4> synchronized (solrServer) { <line5> solrServer.deleteById(getCompositeKey(id, securityService.getOrganization().getId())); <line6> solrServer.commit(); <line7> } <line8> } catch (Exception e) { <line9> throw new SeriesServiceDatabaseException(e); <line10> } <line11> } else { <line12> indexingExecutor.submit( <line13> new Runnable() { <line14> @Override <line15> public void run() { <line16> try { <line17> synchronized (solrServer) { <line18> solrServer.deleteById(id); <line19> solrServer.commit(); <line20> } <line21> } catch (Exception e) { <line22> } <line23> } <line24> }); <line25> } <line26> } <line27> } <line28> 	<line22>
6616	"public class A { <line0> protected void subscribeLayerized(final String layerizedId) { <line1> try { <line2> addEntryEventSubscription(LINK_CHANGED, layerizedId); <line3> addEntryEventSubscription(FLOW_CHANGED, layerizedId); <line4> addEntryEventSubscription(OUT_PACKET_ADDED, layerizedId); <line5> String attrBase = AttrElements.ATTRIBUTES + SEPARATOR + ""%s""; <line6> ArrayList<String> portAttributes = <line7> new ArrayList<String>( <line8> Arrays.asList( <line9> String.format(attrBase, AttrElements.UNRESERVED_BANDWIDTH), <line10> String.format(attrBase, AttrElements.IS_BOUNDARY))); <line11> updateEntryEventSubscription(PORT_CHANGED, layerizedId, portAttributes); <line12> ArrayList<String> linkAttributes = <line13> new ArrayList<String>( <line14> Arrays.asList( <line15> String.format(attrBase, AttrElements.COST), <line16> String.format(attrBase, AttrElements.REQ_LATENCY), <line17> String.format(attrBase, AttrElements.UNRESERVED_BANDWIDTH), <line18> String.format(attrBase, AttrElements.REQ_BANDWIDTH))); <line19> updateEntryEventSubscription(LINK_CHANGED, layerizedId, linkAttributes); <line20> ArrayList<String> flowAttributes = <line21> new ArrayList<String>( <line22> Arrays.asList( <line23> NetworkElements.OWNER, <line24> NetworkElements.ENABLED, <line25> NetworkElements.PRIORITY, <line26> String.format(attrBase, AttrElements.BANDWIDTH), <line27> String.format(attrBase, AttrElements.LATENCY))); <line28> updateEntryEventSubscription(FLOW_CHANGED, layerizedId, flowAttributes); <line29> applyEventSubscription(); <line30> } catch (Exception ex) { <line31> } <line32> } <line33> } <line34> "	<line1>, <line31>
6617	public class A { <line0> public void doRemoveFromMap(Word e, C c) { <line1> C b = val.remove(e); <line2> if (debug) { <line3> if (c == null) { <line4> return; <line5> } <line6> if (!c.equals(b)) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6618	public class A { <line0> private Completable refreshLocationPrivateAsync(DatabaseAccount databaseAccount) { <line1> return Completable.defer( <line2> () -> { <line3> if (databaseAccount != null) { <line4> this.locationCache.onDatabaseAccountRead(databaseAccount); <line5> } <line6> Utils.ValueHolder<Boolean> canRefreshInBackground = new Utils.ValueHolder(); <line7> if (this.locationCache.shouldRefreshEndpoints(canRefreshInBackground)) { <line8> if (databaseAccount == null && !canRefreshInBackground.v) { <line9> Single<DatabaseAccount> databaseAccountObs = <line10> getDatabaseAccountFromAnyLocationsAsync( <line11> this.defaultEndpoint, <line12> new ArrayList<>(this.connectionPolicy.getPreferredLocations()), <line13> url -> this.getDatabaseAccountAsync(url)); <line14> return databaseAccountObs <line15> .map( <line16> dbAccount -> { <line17> this.locationCache.onDatabaseAccountRead(dbAccount); <line18> this.isRefreshing.set(false); <line19> return dbAccount; <line20> }) <line21> .flatMapCompletable( <line22> dbAccount -> { <line23> if (!this.refreshInBackground.get()) { <line24> this.startRefreshLocationTimerAsync(); <line25> } <line26> return Completable.complete(); <line27> }); <line28> } <line29> if (!this.refreshInBackground.get()) { <line30> this.startRefreshLocationTimerAsync(); <line31> } <line32> this.isRefreshing.set(false); <line33> return Completable.complete(); <line34> } else { <line35> this.isRefreshing.set(false); <line36> return Completable.complete(); <line37> } <line38> }); <line39> } <line40> } <line41> 	<line3>, <line8>, <line9>, <line35>
6619	"public class A { <line0> @Test <line1> public void testHeaderAndTrailer() throws Exception { <line2> results.expectedMessageCount(1); <line3> results.message(0).body().isInstanceOf(List.class); <line4> results.message(0).header(""camelFlatpackCounter"").isEqualTo(6); <line5> results.assertIsSatisfied(); <line6> List<Map<String, String>> data = <line7> CastUtils.cast(results.getExchanges().get(0).getIn().getBody(List.class)); <line8> Map<String, String> header = data.get(0); <line9> assertEquals(""HBT"", header.get(""INDICATOR"")); <line10> assertEquals(""20080817"", header.get(""DATE"")); <line11> int counter = 0; <line12> for (Map<String, String> row : data.subList(1, 5)) { <line13> assertEquals(expectedFirstName[counter], row.get(""FIRSTNAME""), ""FIRSTNAME""); <line14> counter++; <line15> } <line16> Map<String, String> trailer = data.get(5); <line17> assertEquals(""FBT"", trailer.get(""INDICATOR"")); <line18> assertEquals(""SUCCESS"", trailer.get(""STATUS"")); <line19> } <line20> } <line21> "	<line14>
6620	"public class A { <line0> @Override <line1> public DocumentEntry create( <line2> Account actor, <line3> Account owner, <line4> File tempFile, <line5> String fileName, <line6> String comment, <line7> boolean isFromCmis, <line8> String metadata) <line9> throws BusinessException { <line10> preChecks(actor, owner); <line11> Validate.notEmpty(fileName, ""fileName is required.""); <line12> checkCreatePermission( <line13> actor, owner, DocumentEntry.class, BusinessErrorCode.DOCUMENT_ENTRY_FORBIDDEN, null); <line14> DocumentEntry docEntry = null; <line15> try { <line16> fileName = sanitizeFileName(fileName); <line17> Long size = tempFile.length(); <line18> checkSpace(owner, size); <line19> String mimeType = mimeTypeIdentifier.getMimeType(tempFile); <line20> if (mimeTypeFilteringStatus(owner)) { <line21> mimeTypeService.checkFileMimeType(owner, fileName, mimeType); <line22> } <line23> virusScannerService.checkVirus(fileName, owner, tempFile, size); <line24> String timeStampingUrl = null; <line25> StringValueFunctionality timeStampingFunctionality = <line26> functionalityReadOnlyService.getTimeStampingFunctionality(owner.getDomain()); <line27> if (timeStampingFunctionality.getActivationPolicy().getStatus()) { <line28> timeStampingUrl = timeStampingFunctionality.getValue(); <line29> } <line30> Functionality enciphermentFunctionality = <line31> functionalityReadOnlyService.getEnciphermentFunctionality(owner.getDomain()); <line32> Boolean checkIfIsCiphered = enciphermentFunctionality.getActivationPolicy().getStatus(); <line33> docEntry = <line34> documentEntryBusinessService.createDocumentEntry( <line35> owner, <line36> tempFile, <line37> size, <line38> fileName, <line39> comment, <line40> checkIfIsCiphered, <line41> timeStampingUrl, <line42> mimeType, <line43> getDocumentExpirationDate(owner.getDomain()), <line44> isFromCmis, <line45> metadata); <line46> addToQuota(owner, size); <line47> } finally { <line48> try { <line49> if (tempFile.exists()) { <line50> tempFile.delete(); <line51> } <line52> } catch (Exception e) { <line53> } <line54> } <line55> DocumentEntryAuditLogEntry log = <line56> new DocumentEntryAuditLogEntry(actor, owner, docEntry, LogAction.CREATE); <line57> logEntryService.insert(log); <line58> return docEntry; <line59> } <line60> } <line61> "	<line49>, <line53>
6621	public class A { <line0> public void setScannerFactory(ScannerFactory scannerFactory) { <line1> this.scannerFactory = scannerFactory; <line2> } <line3> } <line4> 	<line1>
6622	public class A { <line0> @Override <line1> public ActionBuilderModule<DocumentSimilarity, Relation> instantiate(Configuration config) { <line2> Float similarityThreshold = null; <line3> String thresholdStr = <line4> WorkflowRuntimeParameters.getParamValue(EXPORT_DOCUMENTSSIMILARITY_THRESHOLD, config); <line5> if (thresholdStr != null) { <line6> similarityThreshold = Float.valueOf(thresholdStr); <line7> } <line8> return new DocumentSimilarityActionBuilderModule( <line9> provideTrustLevelThreshold(config), similarityThreshold); <line10> } <line11> } <line12> 	<line7>
6623	"public class A { <line0> public void initDeviceState() { <line1> Bridge bridge = getBridge(); <line2> if (bridge == null) { <line3> updateStatus( <line4> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""No bridge configured""); <line5> } else if (bridge.getStatus() == ThingStatus.ONLINE) { <line6> updateStatus(ThingStatus.ONLINE); <line7> } else { <line8> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); <line9> } <line10> } <line11> } <line12> "	<line5>, <line7>, <line9>
6624	public class A { <line0> public static void main(String[] args) { <line1> if (!ObjectUtils.isEmpty(args)) { <line2> } <line3> SpringApplication.run(LambdaApplication.class, args); <line4> } <line5> } <line6> 	<line1>, <line2>
6625	public class A { <line0> public boolean validateToken(final String token) { <line1> try { <line2> final JwtParser jwtParser = Jwts.parser().setSigningKey(key); <line3> final Jws<Claims> claims = jwtParser.parseClaimsJws(token); <line4> this.subject = claims.getBody().getSubject(); <line5> this.expiration = claims.getBody().getExpiration(); <line6> this.identityProvider = <line7> IdentityProvider.forName(claims.getBody().get(IDENTITY_PROVIDER_CLAIM, String.class)); <line8> return true; <line9> } catch (SignatureException e) { <line10> } catch (ExpiredJwtException e) { <line11> } catch (MalformedJwtException e) { <line12> } catch (UnsupportedJwtException | IllegalArgumentException e) { <line13> } <line14> return false; <line15> } <line16> } <line17> 	<line10>, <line11>, <line12>, <line13>
6626	public class A { <line0> private static void overrideRowsCommitTimeAndSetMicroseconds( <line1> Long commitTimestamp, <line2> Long transactionSequenceNumber, <line3> Collection<AugmentedRow> extractedAugmentedRows) { <line4> for (AugmentedRow ar : extractedAugmentedRows) { <line5> ar.setCommitTimestamp(commitTimestamp); <line6> ar.setTransactionSequenceNumber(transactionSequenceNumber); <line7> Long microsOverride = commitTimestamp * 1000 + ar.getTransactionSequenceNumber(); <line8> ar.setRowMicrosecondTimestamp(microsOverride); <line9> } <line10> } <line11> } <line12> 	<line8>
6627	public class A { <line0> @Override <line1> public void run() { <line2> for (int i = 0; i < this.runs; i++) { <line3> } <line4> } <line5> } <line6> 	<line3>
6628	public class A { <line0> private void logResult() { <line1> List<Pair<AnnotationKey>> annotationKeys = <line2> new ArrayList<Pair<AnnotationKey>>(annotationKeyCodeMap.values()); <line3> Collections.sort( <line4> annotationKeys, <line5> new Comparator<Pair<AnnotationKey>>() { <line6> @Override <line7> public int compare(Pair<AnnotationKey> o1, Pair<AnnotationKey> o2) { <line8> int code1 = o1.value.getCode(); <line9> int code2 = o2.value.getCode(); <line10> return Integer.compare(code1, code2); <line11> } <line12> }); <line13> for (Pair<AnnotationKey> annotationKey : annotationKeys) { <line14> } <line15> } <line16> } <line17> 	<line1>, <line14>
6629	public class A { <line0> public void delete(StgMUmsetzStatTxt persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
6630	public class A { <line0> private void advanceCursorsIfNecessary(List<LedgerInfo> ledgersToDelete) { <line1> if (ledgersToDelete.isEmpty()) { <line2> return; <line3> } <line4> long firstNonDeletedLedger = <line5> ledgers.higherKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId()); <line6> PositionImpl highestPositionToDelete = new PositionImpl(firstNonDeletedLedger, -1); <line7> cursors.forEach( <line8> cursor -> { <line9> if (highestPositionToDelete.compareTo((PositionImpl) cursor.getMarkDeletedPosition()) > 0 <line10> && highestPositionToDelete.compareTo( <line11> (PositionImpl) cursor.getManagedLedger().getLastConfirmedEntry()) <line12> <= 0) { <line13> cursor.asyncMarkDelete( <line14> highestPositionToDelete, <line15> new MarkDeleteCallback() { <line16> @Override <line17> public void markDeleteComplete(Object ctx) {} <line18>  <line19> @Override <line20> public void markDeleteFailed(ManagedLedgerException exception, Object ctx) { <line21> } <line22> }, <line23> null); <line24> } <line25> }); <line26> } <line27> } <line28> 	<line21>
6631	public class A { <line0> public void stop() { <line1> clientController.stopClient(false); <line2> if (executor == null) return; <line3> serverChannel.unbind(); <line4> serverSecureChannel.unbind(); <line5> serverChannel.close(); <line6> serverSecureChannel.close(); <line7> serverChannel.getCloseFuture().awaitUninterruptibly(); <line8> serverSecureChannel.getCloseFuture().awaitUninterruptibly(); <line9> executor.shutdownNow(); <line10> executor = null; <line11> serverBootstrap.shutdown(); <line12> serverSecureBootstrap.shutdown(); <line13> nioServerSocketChannelFactory.shutdown(); <line14> } <line15> } <line16> 	<line14>
6632	public class A { <line0> private void submitInvokePoints() { <line1> AtomicInteger uploadCounter = new AtomicInteger(0); <line2> List<DataPoint> points = invokeDataQueue.peek(); <line3> InvocationContext invocationContext = InvocationContextImpl.Factory.currentInstance(); <line4> invocationContext.timeout(5000); <line5> while (points != null) { <line6> try { <line7> if (!points.isEmpty()) { <line8> CounterClientFactory.COUNTER_CLIENT.submitPoints(points); <line9> uploadCounter.addAndGet(points.size()); <line10> } <line11> invokeDataQueue.remove(points); <line12> points = invokeDataQueue.peek(); <line13> } catch (Throwable e) { <line14> if (LOGGER.isDebugEnabled()) { <line15> } <line16> return; <line17> } <line18> } <line19> if (LOGGER.isDebugEnabled()) { <line20> } <line21> InvocationContextImpl.Factory.removeCurrentInstance(); <line22> } <line23> } <line24> 	<line8>, <line14>, <line15>, <line20>
6633	public class A { <line0> public void onReleased(String serviceName) { <line1> } <line2> } <line3> 	<line1>
6634	public class A { <line0> @Override <line1> public void run() { <line2> if (isSuspending()) { <line3> suspended(); <line4> return; <line5> } <line6> Exception suppressed = null; <line7> int retryCount = getRetryCount(); <line8> for (int i = 0; i <= retryCount; i++) { <line9> if (i > 0) { <line10> } <line11> Exception e = runWorkWithTransactionAndCheckExceptions(); <line12> if (e == null) { <line13> return; <line14> } <line15> if (suppressed == null) { <line16> suppressed = e; <line17> } else { <line18> suppressed.addSuppressed(e); <line19> } <line20> } <line21> if (suppressed != null) { <line22> if (suppressed instanceof RuntimeException) { <line23> throw (RuntimeException) suppressed; <line24> } else { <line25> throw new RuntimeException(suppressed); <line26> } <line27> } <line28> } <line29> } <line30> 	<line10>
6635	"public class A { <line0> private void affinityCallRestartNode() throws Exception { <line1> final int ITERS = 10; <line2> for (int i = 0; i < ITERS; i++) { <line3> Integer key = primaryKey(grid(0).cache(CACHE_NAME)); <line4> AffinityTopologyVersion topVer = grid(0).context().discovery().topologyVersionEx(); <line5> IgniteInternalFuture<Object> fut = <line6> GridTestUtils.runAsync( <line7> new Callable<Object>() { <line8> @Override <line9> public Object call() throws Exception { <line10> U.sleep(500); <line11> stopGrid(0); <line12> return null; <line13> } <line14> }, <line15> ""stop-thread""); <line16> while (!fut.isDone()) <line17> grid(1).compute().affinityCall(CACHE_NAME, key, new CheckCallable(key, topVer)); <line18> fut.get(); <line19> if (i < ITERS - 1) startGrid(0); <line20> } <line21> stopAllGrids(); <line22> } <line23> } <line24> "	<line3>
6636	public class A { <line0> public void setDistanceTolerance(int distanceTolerance) { <line1> if (distanceTolerance < MIN_DISTANCE_TOLERANCE_IN_METERS) { <line2> this.distanceTolerance = distanceTolerance; <line3> } else { <line4> this.distanceTolerance = distanceTolerance; <line5> } <line6> } <line7> } <line8> 	<line3>
6637	"public class A { <line0> @Override <line1> public boolean foundDuplicateDocumentNominalLabel(DocumentNominalLabelDTO documentNominalLabel) { <line2> Map<String, Long> attMap = new HashMap<String, Long>(); <line3> try { <line4> attMap.put(""id.documentId"", documentNominalLabel.getIdDTO().getDocumentId()); <line5> attMap.put(""id.nominalLabelId"", documentNominalLabel.getIdDTO().getNominalLabelId()); <line6> } catch (PropertyNotSetException e) { <line7> } <line8> DocumentNominalLabel obj = <line9> remoteDocumentNominalLabelEJB.getByCriterionID(Restrictions.allEq(attMap)); <line10> if (obj != null) { <line11> return true; <line12> } else { <line13> return false; <line14> } <line15> } <line16> } <line17> "	<line7>
6638	public class A { <line0> @Override <line1> public void stateChanged(int oldState) { <line2> super.stateChanged(oldState); <line3> if (_initialised && isAudioAlive()) { <line4> al.alSourcef(_source[0], AL.AL_PITCH, this.getPitch()); <line5> al.alSourcef(_source[0], AL.AL_GAIN, this.getGain()); <line6> al.alSource3f( <line7> _source[0], <line8> AL.AL_POSITION, <line9> this.getCurrentPosition().x, <line10> this.getCurrentPosition().y, <line11> this.getCurrentPosition().z); <line12> al.alSource3f( <line13> _source[0], <line14> AL.AL_VELOCITY, <line15> this.getVelocity().x, <line16> this.getVelocity().y, <line17> this.getVelocity().z); <line18> al.alSourcei(_source[0], AL.AL_LOOPING, this.isLooped() ? AL.AL_TRUE : AL.AL_FALSE); <line19> if (JoalAudioFactory.checkALError()) { <line20> } <line21> } else { <line22> _initialised = init(); <line23> } <line24> } <line25> } <line26> 	<line20>
6639	"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Consumes(MediaType.APPLICATION_JSON) <line3> @Path(""termsPolicy"") <line4> public Object termsPolicy( <line5> @Context ServletContext context, @Context HttpServletResponse response) { <line6> LOGGER.entry(""begin termsPolicy()""); <line7> TermsPolicyResponse termsPolicyResponse = new TermsPolicyResponse(); <line8> try { <line9> termsPolicyResponse = appMetaDataOrchestration.termsPolicy(); <line10> if (!termsPolicyResponse.getMessage().equals(StudyMetaDataConstants.SUCCESS)) { <line11> StudyMetaDataUtil.getFailureResponse( <line12> ErrorCodes.STATUS_103, ErrorCodes.NO_DATA, StudyMetaDataConstants.FAILURE, response); <line13> return Response.status(Response.Status.NO_CONTENT) <line14> .entity(StudyMetaDataConstants.NO_RECORD) <line15> .build(); <line16> } <line17> } catch (Exception e) { <line18> StudyMetaDataUtil.getFailureResponse( <line19> ErrorCodes.STATUS_104, ErrorCodes.UNKNOWN, StudyMetaDataConstants.FAILURE, response); <line20> return Response.status(Response.Status.INTERNAL_SERVER_ERROR) <line21> .entity(StudyMetaDataConstants.FAILURE) <line22> .build(); <line23> } <line24> LOGGER.exit(""termsPolicy() :: Ends""); <line25> return termsPolicyResponse; <line26> } <line27> } <line28> "	<line18>
6640	"public class A { <line0> @Override <line1> public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { <line2> if (file.getNameCount() > 0) { <line3> Path dest = <line4> folder.resolve( <line5> file.getNameCount() < 1 ? """" : file.subpath(0, file.getNameCount()).toString()); <line6> try { <line7> Files.copy(file, dest, StandardCopyOption.REPLACE_EXISTING); <line8> } catch (Exception ex) { <line9> } <line10> } <line11> return FileVisitResult.CONTINUE; <line12> } <line13> } <line14> "	<line6>, <line9>
6641	public class A { <line0> private static void multithreadTransition( <line1> final Transition transition, int[] workflowRunAccessions) { <line2> ExecutorService pool = Executors.newFixedThreadPool(Math.min(10, workflowRunAccessions.length)); <line3> List<Future<?>> futures = new ArrayList<>(workflowRunAccessions.length); <line4> for (int workflowRunAccession : workflowRunAccessions) { <line5> final int workflowRunAccessionCopy = workflowRunAccession; <line6> futures.add( <line7> pool.submit( <line8> new Runnable() { <line9> @Override <line10> public void run() { <line11> if (transition == Transition.RETRY) { <line12> retryWorkflowRun(workflowRunAccessionCopy); <line13> } else if (transition == Transition.CANCEL) { <line14> cancelWorkflowRun(workflowRunAccessionCopy); <line15> } else if (transition == Transition.FAIL) { <line16> failWorkflowRun(workflowRunAccessionCopy); <line17> } <line18> } <line19> })); <line20> } <line21> for (Future<?> future : futures) { <line22> try { <line23> future.get(); <line24> } catch (InterruptedException | ExecutionException ex) { <line25> } <line26> } <line27> pool.shutdown(); <line28> } <line29> } <line30> 	<line25>
6642	"public class A { <line0> private boolean doRequestWhenFailureExpected() throws InterruptedException { <line1> sink.start(); <line2> Assert.assertTrue(LifecycleController.waitForOneOf(sink, LifecycleState.START_OR_ERROR, 5000)); <line3> Transaction transaction = channel.getTransaction(); <line4> transaction.begin(); <line5> Event event = EventBuilder.withBody(""test event 1"", Charsets.UTF_8); <line6> channel.put(event); <line7> transaction.commit(); <line8> transaction.close(); <line9> boolean failed; <line10> try { <line11> sink.process(); <line12> failed = false; <line13> } catch (EventDeliveryException ex) { <line14> failed = true; <line15> } <line16> sink.stop(); <line17> Assert.assertTrue(LifecycleController.waitForOneOf(sink, LifecycleState.STOP_OR_ERROR, 5000)); <line18> return failed; <line19> } <line20> } <line21> "	<line14>
6643	"public class A { <line0> @Before <line1> public void createClient() throws IOException { <line2> final SshClient client = SshClient.setUpDefaultClient(); <line3> client.setForwardingFilter(AcceptAllForwardingFilter.INSTANCE); <line4> client.start(); <line5> session = <line6> client.connect(""user"", TEST_LOCALHOST, sshServerPort).verify(CONNECT_TIMEOUT).getSession(); <line7> session.addPasswordIdentity(""foo""); <line8> session.auth().verify(AUTH_TIMEOUT); <line9> } <line10> } <line11> "	<line5>, <line7>, <line9>
6644	public class A { <line0> @Override <line1> public TextMessage createTextMessage() throws JMSException { <line2> Session session = getSessionInternal(); <line3> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line4> } <line5> return session.createTextMessage(); <line6> } <line7> } <line8> 	<line4>
6645	public class A { <line0> @Override <line1> public void onClose() { <line2> doWakeup(); <line3> } <line4> } <line5> 	<line2>
6646	public class A { <line0> private Response notifyInPacketAdded(Packet inpacket) throws Exception { <line1> InPacketAdded msg = new InPacketAdded(inpacket); <line2> return postEvent(InPacketAdded.TYPE, msg); <line3> } <line4> } <line5> 	<line1>
6647	"public class A { <line0> protected void createSchemaChangeEventsForTables( <line1> ChangeEventSourceContext sourceContext, <line2> RelationalSnapshotContext snapshotContext, <line3> SnapshottingTask snapshottingTask) <line4> throws Exception { <line5> tryStartingSnapshot(snapshotContext); <line6> for (Iterator<TableId> iterator = snapshotContext.capturedTables.iterator(); <line7> iterator.hasNext(); ) { <line8> final TableId tableId = iterator.next(); <line9> if (!sourceContext.isRunning()) { <line10> throw new InterruptedException(""Interrupted while capturing schema of table "" + tableId); <line11> } <line12> Table table = snapshotContext.tables.forTable(tableId); <line13> if (schema != null) { <line14> snapshotContext.offset.event(tableId, getClock().currentTime()); <line15> if (!snapshottingTask.snapshotData() && !iterator.hasNext()) { <line16> lastSnapshotRecord(snapshotContext); <line17> } <line18> dispatcher.dispatchSchemaChangeEvent( <line19> table.id(), <line20> (receiver) -> { <line21> try { <line22> receiver.schemaChangeEvent(getCreateTableEvent(snapshotContext, table)); <line23> } catch (Exception e) { <line24> throw new DebeziumException(e); <line25> } <line26> }); <line27> } <line28> } <line29> } <line30> } <line31> "	<line12>
6648	public class A { <line0> @Override <line1> public Output<T> output(String text) throws MediaException { <line2> OutputImpl<T> output = null; <line3> getComponentstLock().lock(); <line4> try { <line5> VerbRef verbRef = _mohoRemote.getRayoClient().output(text, this.getId()); <line6> output = new OutputImpl<T>(verbRef, this, (T) this); <line7> } catch (XmppException e) { <line8> throw new MediaException(e); <line9> } finally { <line10> getComponentstLock().unlock(); <line11> } <line12> return output; <line13> } <line14> } <line15> 	<line8>
6649	"public class A { <line0> @Test <line1> public void testProcessFlagsOrder() throws Exception { <line2> setUpFlagDir(); <line3> createTestFiles(2, 5); <line4> final List<Collection<InputFile>> flagFileLists = new ArrayList<>(); <line5> FlagMaker instance = <line6> new TestWrappedFlagMaker(fmc) { <line7> @Override <line8> void writeFlagFile(FlagDataTypeConfig fc, Collection<InputFile> inFiles) <line9> throws IOException { <line10> flagFileLists.add(inFiles); <line11> } <line12> }; <line13> instance.processFlags(); <line14> assertEquals(2, flagFileLists.size()); <line15> long lastTime = 0; <line16> for (Collection<InputFile> flagFileList : flagFileLists) { <line17> long nextTime = 0; <line18> for (InputFile file : flagFileList) { <line19> assertTrue(""Found file out of expected order"", file.getTimestamp() > lastTime); <line20> nextTime = Math.max(nextTime, file.getTimestamp()); <line21> } <line22> lastTime = nextTime; <line23> } <line24> } <line25> } <line26> "	<line2>
6650	"public class A { <line0> public static void messageReceived(ChannelHandlerContext ctx, User user, StringMessage message) { <line1> String[] split = split2(message.body); <line2> if (split.length < 2) { <line3> throw new IllegalCommandException(""Wrong income message format.""); <line4> } <line5> int dashId = Integer.parseInt(split[0]); <line6> String deviceString = split[1]; <line7> if (deviceString == null || deviceString.isEmpty()) { <line8> throw new IllegalCommandException(""Income tag message is empty.""); <line9> } <line10> Profile profile = user.profile; <line11> DashBoard dash = profile.getDashByIdOrThrow(dashId); <line12> Tag newTag = JsonParser.parseTag(deviceString, message.id); <line13> if (newTag.isNotValid()) { <line14> throw new IllegalCommandException(""Income tag name is not valid.""); <line15> } <line16> for (Tag tag : dash.tags) { <line17> if (tag.id == newTag.id || tag.name.equals(newTag.name)) { <line18> throw new IllegalCommandException(""Tag with same id/name already exists.""); <line19> } <line20> } <line21> profile.addTag(dash, newTag); <line22> user.lastModifiedTs = System.currentTimeMillis(); <line23> if (ctx.channel().isWritable()) { <line24> ctx.writeAndFlush( <line25> makeUTF8StringMessage(CREATE_TAG, message.id, newTag.toString()), ctx.voidPromise()); <line26> } <line27> } <line28> } <line29> "	<line13>
6651	public class A { <line0> @Override <line1> protected void onEvent(Event event) { <line2> boolean initialized = CartridgeAgentConfiguration.getInstance().isInitialized(); <line3> if (!initialized) { <line4> try { <line5> TopologyManager.acquireReadLock(); <line6> if (log.isDebugEnabled()) { <line7> } <line8> CompleteTopologyEvent completeTopologyEvent = (CompleteTopologyEvent) event; <line9> extensionHandler.onCompleteTopologyEvent(completeTopologyEvent); <line10> } catch (Exception e) { <line11> if (log.isErrorEnabled()) { <line12> } <line13> } finally { <line14> TopologyManager.releaseReadLock(); <line15> } <line16> } <line17> } <line18> } <line19> 	<line7>, <line12>
6652	"public class A { <line0> @Override <line1> public void putCollectionReference(String ref, CollectionReference col) { <line2> try { <line3> this.instance.getReplicatedMap(""collections"").put(ref, col, cacheTimeout, TimeUnit.SECONDS); <line4> } catch (HazelcastInstanceNotActiveException e) { <line5> init(); <line6> this.instance.getReplicatedMap(""collections"").put(ref, col, cacheTimeout, TimeUnit.SECONDS); <line7> } <line8> this.instance.getReplicatedMap(ref).clear(); <line9> } <line10> } <line11> "	<line2>, <line8>
6653	public class A { <line0> public static void writeClass(Class<?> c, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> if (c == null || c.isPrimitive()) { <line5> StaticSerialization.writePrimitiveClass(c, out); <line6> } else { <line7> out.writeByte(DSCODE.CLASS.toByte()); <line8> String cname = c.getName(); <line9> cname = InternalDataSerializer.processOutgoingClassName(cname, out); <line10> writeString(cname, out); <line11> } <line12> } <line13> } <line14> 	<line3>
6654	"public class A { <line0> @Override <line1> public boolean addURLToDownload(URL url, File saveAs) { <line2> if (Utils.getConfigBoolean(""urls_only.save"", false)) { <line3> String urlFile = this.workingDir + File.separator + ""urls.txt""; <line4> try { <line5> FileWriter fw = new FileWriter(urlFile, true); <line6> fw.write(url.toExternalForm()); <line7> fw.write(""\n""); <line8> fw.close(); <line9> RipStatusMessage msg = new RipStatusMessage(STATUS.DOWNLOAD_COMPLETE, urlFile); <line10> observer.update(this, msg); <line11> } catch (IOException e) { <line12> return false; <line13> } <line14> } else { <line15> if (isThisATest()) { <line16> this.url = url; <line17> return true; <line18> } <line19> threadPool.addThread(new DownloadVideoThread(url, saveAs, this)); <line20> } <line21> return true; <line22> } <line23> } <line24> "	<line12>, <line16>
6655	"public class A { <line0> @Override <line1> public List<String> getListInDirWithFilter( <line2> final IRODSFile irodsFile, final FilenameFilter fileNameFilter) <line3> throws JargonException, DataNotFoundException { <line4> if (irodsFile == null) { <line5> throw new JargonException(""irods file is null""); <line6> } <line7> if (fileNameFilter == null) { <line8> throw new JargonException(""file name filter is null""); <line9> } <line10> List<String> subdirs = new ArrayList<>(); <line11> String path = irodsFile.getAbsolutePath(); <line12> IRODSGenQueryBuilder builder = new IRODSGenQueryBuilder(true, null); <line13> IRODSQueryResultSet resultSet = null; <line14> try { <line15> IRODSFileSystemAOHelper.buildQueryListAllCollections(path, builder); <line16> IRODSGenQueryFromBuilder irodsQuery = <line17> builder.exportIRODSQueryFromBuilder(getJargonProperties().getMaxFilesAndDirsQueryMax()); <line18> resultSet = irodsGenQueryExecutor.executeIRODSQuery(irodsQuery, 0); <line19> for (IRODSQueryResultRow row : resultSet.getResults()) { <line20> processRowForSubdirWhenListDirWithFilter(fileNameFilter, subdirs, row); <line21> } <line22> while (resultSet.isHasMoreRecords()) { <line23> log.debug(""more results to get for listing files, requerying""); <line24> resultSet = irodsGenQueryExecutor.getMoreResults(resultSet); <line25> for (IRODSQueryResultRow row : resultSet.getResults()) { <line26> processRowForSubdirWhenListDirWithFilter(fileNameFilter, subdirs, row); <line27> } <line28> } <line29> } catch (JargonQueryException e) { <line30> log.error(""query exception for  query"", e); <line31> throw new JargonException(""error in exists query""); <line32> } catch (GenQueryBuilderException e) { <line33> log.error(""query exception for  query"", e); <line34> throw new JargonException(""error in exists query""); <line35> } finally { <line36> if (resultSet != null) { <line37> irodsGenQueryExecutor.closeResults(resultSet); <line38> } <line39> } <line40> resultSet = null; <line41> builder = new IRODSGenQueryBuilder(true, null); <line42> IRODSFileSystemAOHelper.buildQueryListAllFiles(path, builder); <line43> try { <line44> IRODSGenQueryFromBuilder irodsQuery = <line45> builder.exportIRODSQueryFromBuilder(getJargonProperties().getMaxFilesAndDirsQueryMax()); <line46> resultSet = irodsGenQueryExecutor.executeIRODSQuery(irodsQuery, 0); <line47> for (IRODSQueryResultRow row : resultSet.getResults()) { <line48> processRowWhenListDirWithFilter(fileNameFilter, subdirs, row); <line49> } <line50> while (resultSet.isHasMoreRecords()) { <line51> resultSet = irodsGenQueryExecutor.getMoreResults(resultSet); <line52> for (IRODSQueryResultRow row : resultSet.getResults()) { <line53> processRowWhenListDirWithFilter(fileNameFilter, subdirs, row); <line54> } <line55> } <line56> } catch (JargonQueryException e) { <line57> log.error(""query exception for  query"", e); <line58> throw new JargonException(""error in exists query""); <line59> } catch (GenQueryBuilderException e) { <line60> throw new JargonException(""error in exists query""); <line61> } finally { <line62> if (resultSet != null) { <line63> irodsGenQueryExecutor.closeResults(resultSet); <line64> } <line65> } <line66> return subdirs; <line67> } <line68> } <line69> "	<line4>, <line12>, <line51>, <line60>
6656	"public class A { <line0> private static void sendEmailIntent( <line1> FragmentActivity activityContext, String to, String subject, String email) { <line2> Intent email_intent = new Intent(Intent.ACTION_SEND); <line3> email_intent.putExtra(Intent.EXTRA_EMAIL, new String[] {to}); <line4> email_intent.putExtra(Intent.EXTRA_SUBJECT, subject); <line5> email_intent.putExtra(Intent.EXTRA_TEXT, email); <line6> email_intent.setType(""plain/text""); <line7> try { <line8> email_intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <line9> if (activityContext != null) { <line10> Intent targetIntent = <line11> Intent.createChooser( <line12> email_intent, activityContext.getString(R.string.email_chooser_header)); <line13> targetIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <line14> activityContext.startActivity(targetIntent); <line15> } <line16> } catch (android.content.ActivityNotFoundException ex) { <line17> Toast.makeText( <line18> activityContext, <line19> activityContext.getString(R.string.email_client_not_present), <line20> Toast.LENGTH_SHORT) <line21> .show(); <line22> } <line23> } <line24> } <line25> "	<line22>
6657	public class A { <line0> public static void validate(long listTypeId, long classNameId, String type) <line1> throws RemoteException { <line2> try { <line3> ListTypeServiceUtil.validate(listTypeId, classNameId, type); <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>
6658	"public class A { <line0> public static Properties getBuildProperties(final Console console) { <line1> final Properties props = new Properties(); <line2> try (InputStream stream = <line3> VersionUtils.class.getClassLoader().getResourceAsStream(BUILD_PROPERTIES_FILE_NAME); ) { <line4> if (stream != null) { <line5> props.load(stream); <line6> } <line7> return props; <line8> } catch (final IOException e) { <line9> if (console != null) { <line10> console.println( <line11> ""Cannot read GeoWave build properties to show version information: "" + e.getMessage()); <line12> } <line13> } <line14> return props; <line15> } <line16> } <line17> "	<line9>
6659	"public class A { <line0> protected void processProcedure(Connection conn, DatabaseMetaData metaData) throws SQLException { <line1> final Map<String, DfProcedureMeta> procedureMap = extractProcedureMap(); <line2> if (procedureMap == null) { <line3> return; <line4> } <line5> final Element procedureGroupElement = _doc.createElement(""procedureGroup""); <line6> for (Entry<String, DfProcedureMeta> entry : procedureMap.entrySet()) { <line7> final DfProcedureMeta procedureMeta = entry.getValue(); <line8> doProcessProcedure(procedureGroupElement, procedureMeta); <line9> } <line10> _databaseNode.appendChild(procedureGroupElement); <line11> } <line12> } <line13> "	<line1>, <line5>
6660	"public class A { <line0> @Test <line1> public void restartBothBundles() throws BundleException { <line2> Logger log = LoggerFactory.getLogger(this.getClass()); <line3> Bundle paxLoggingApi = Helpers.paxLoggingApi(context); <line4> Bundle paxLoggingService = Helpers.paxLoggingLog4j1(context); <line5> osgiLog.log(LogService.LOG_INFO, ""Before restarting""); <line6> paxLoggingApi.stop(Bundle.STOP_TRANSIENT); <line7> paxLoggingService.stop(Bundle.STOP_TRANSIENT); <line8> osgiLog.log(LogService.LOG_INFO, ""When bundles are stopped (log service)""); <line9> assertNull(context.getServiceReference(LogService.class)); <line10> Logger log1 = LoggerFactory.getLogger(this.getClass()); <line11> paxLoggingService.start(Bundle.START_TRANSIENT); <line12> paxLoggingApi.start(Bundle.START_TRANSIENT); <line13> osgiLog.log(LogService.LOG_INFO, ""After restarting bundles (log service old ref)""); <line14> ServiceReference<LogService> ref = context.getServiceReference(LogService.class); <line15> assertNotNull(ref); <line16> context <line17> .getService(ref) <line18> .log(LogService.LOG_INFO, ""After restarting bundles (log service new ref)""); <line19> Logger log3 = LoggerFactory.getLogger(this.getClass()); <line20> List<String> lines = readLines(); <line21> assertTrue( <line22> ""TTCCLayout"", <line23> lines.contains( <line24> ""[main] INFO org.ops4j.pax.logging.it.Log4J1RestartBothPaxLoggingBundlesIntegrationTest"" <line25> + "" - Before restarting"")); <line26> assertTrue(""TTCCLayout"", lines.contains(""[main] INFO PaxExam-Probe - Before restarting"")); <line27> assertTrue( <line28> ""TTCCLayout"", <line29> lines.contains( <line30> ""[main] INFO org.ops4j.pax.logging.internal.Activator - Disabling SLF4J API support."")); <line31> assertTrue( <line32> ""Default Logger"", <line33> lines.contains( <line34> ""PaxExam-Probe"" <line35> + "" [org.ops4j.pax.logging.it.Log4J1RestartBothPaxLoggingBundlesIntegrationTest]"" <line36> + "" INFO : When bundles are stopped"")); <line37> assertFalse( <line38> ""old LogService reference should not work"", <line39> lines.contains(""When pax-logging-log4j1 is stopped (log service)"")); <line40> assertTrue( <line41> ""old LogService reference should not work"", <line42> lines.contains( <line43> ""org.ops4j.pax.logging.pax-logging-log4j1 [log4j] WARN : No appenders could be found"" <line44> + "" for logger (PaxExam-Probe)."")); <line45> assertTrue( <line46> ""Default Logger"", <line47> lines.contains( <line48> ""PaxExam-Probe"" <line49> + "" [org.ops4j.pax.logging.it.Log4J1RestartBothPaxLoggingBundlesIntegrationTest]"" <line50> + "" INFO : When bundles are stopped (log1)"")); <line51> assertTrue( <line52> ""Reconfiguration"", <line53> lines.contains( <line54> ""org.ops4j.pax.logging.pax-logging-log4j1 [log4j] DEBUG : Finished configuring."")); <line55> assertTrue( <line56> ""TTCCLayout, startup of pax-logging-api"", <line57> lines.contains( <line58> ""[main] INFO org.ops4j.pax.logging.internal.Activator - Enabling Java Util Logging API"" <line59> + "" support."")); <line60> assertTrue( <line61> ""Default Logger"", <line62> lines.contains( <line63> ""PaxExam-Probe"" <line64> + "" [org.ops4j.pax.logging.it.Log4J1RestartBothPaxLoggingBundlesIntegrationTest]"" <line65> + "" INFO : After restarting bundles"")); <line66> assertTrue( <line67> ""TTCCLayout"", <line68> lines.contains( <line69> ""[main] INFO org.ops4j.pax.logging.it.Log4J1RestartBothPaxLoggingBundlesIntegrationTest"" <line70> + "" - After restarting bundles (log1)"")); <line71> assertTrue( <line72> ""TTCCLayout"", <line73> lines.contains( <line74> ""[main] INFO PaxExam-Probe - After restarting bundles (log service old ref)"")); <line75> assertTrue( <line76> ""TTCCLayout"", <line77> lines.contains( <line78> ""[main] INFO PaxExam-Probe - After restarting bundles (log service new ref)"")); <line79> assertTrue( <line80> ""TTCCLayout"", <line81> lines.contains( <line82> ""[main] INFO org.ops4j.pax.logging.it.Log4J1RestartBothPaxLoggingBundlesIntegrationTest"" <line83> + "" - After restarting bundles (log3)"")); <line84> } <line85> } <line86> "	<line5>, <line8>, <line11>, <line13>, <line20>
6661	public class A { <line0> private Set<Dependency> toDependencies(Set<PipInstalledPackage> _packs) { <line1> PipInstalledPackage prj_package = null; <line2> for (PipInstalledPackage pack : _packs) { <line3> if (pack.getStandardDistributionName() <line4> .equals( <line5> PipInstalledPackage.getStandardDistributionName( <line6> this.getApplication().getMvnGroup()))) { <line7> prj_package = pack; <line8> break; <line9> } <line10> } <line11> final Set<Dependency> deps = new HashSet<Dependency>(); <line12> for (PipInstalledPackage pack : _packs) { <line13> try { <line14> if ((prj_package == null || !prj_package.equals(pack)) <line15> && pack.getLibrary().hasValidDigest()) { <line16> final Dependency dep = new Dependency(); <line17> dep.setLib(pack.getLibrary()); <line18> dep.setApp(this.getApplication()); <line19> final Path download_path = pack.getDownloadPath(); <line20> if (download_path != null) { <line21> dep.setFilename(download_path.getFileName().toString()); <line22> dep.setPath(download_path.toString()); <line23> } <line24> dep.setDeclared(true); <line25> dep.setScope(Scope.RUNTIME); <line26> dep.setTransitive((prj_package != null && prj_package.requires(pack) ? false : true)); <line27> deps.add(dep); <line28> } <line29> } catch (FileAnalysisException e) { <line30> } <line31> } <line32> for (PipInstalledPackage pack : _packs) { <line33> final Set<FileAnalyzer> nested_fas = pack.getNestedArchives(); <line34> if (nested_fas != null) { <line35> for (FileAnalyzer nested_fa : nested_fas) { <line36> if (nested_fa instanceof PythonArchiveAnalyzer) { <line37> try { <line38> final PythonArchiveAnalyzer paa = (PythonArchiveAnalyzer) nested_fa; <line39> final Library nested_lib = paa.getLibrary(); <line40> if (DependencyUtil.containsLibraryDependency(deps, nested_lib)) { <line41> } else { <line42> final Dependency dep = new Dependency(); <line43> dep.setLib(nested_lib); <line44> dep.setApp(this.getApplication()); <line45> final Path archive_path = paa.getArchivePath(); <line46> if (archive_path != null) { <line47> dep.setFilename(archive_path.getFileName().toString()); <line48> dep.setPath(archive_path.toString()); <line49> } <line50> dep.setDeclared(false); <line51> dep.setScope(Scope.RUNTIME); <line52> dep.setTransitive(true); <line53> deps.add(dep); <line54> } <line55> } catch (FileAnalysisException e) { <line56> } <line57> } else { <line58> } <line59> } <line60> } <line61> } <line62> return deps; <line63> } <line64> } <line65> 	<line30>, <line41>, <line56>, <line58>
6662	public class A { <line0> @Override <line1> public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { <line2> boolean sendContent = ihf.checkFile(file, attrs); <line3> try { <line4> if (sendContent) { <line5> subHandlerList.add(ihf.getIndexHandler(file, attrs, solrClient, true)); <line6> } else { <line7> SolrInputDocument fileDoc = <line8> MCRSolrPathDocumentFactory.getInstance().getDocument(file, attrs); <line9> docs.add(fileDoc); <line10> } <line11> } catch (Exception ex) { <line12> } <line13> return super.visitFile(file, attrs); <line14> } <line15> } <line16> 	<line12>
6663	"public class A { <line0> protected String escapeString(String data) { <line1> StringBuilder sb = new StringBuilder(); <line2> for (int i = 0; i < data.length(); ++i) { <line3> char c = data.charAt(i); <line4> switch (c) { <line5> case 0x00: <line6> ""); <line7> continue; <line8> case Constant.QUOTE_CHAR: <line9> case Constant.ESCAPE: <line10> sb.append(Constant.ESCAPE); <line11> break; <line12> default: <line13> break; <line14> } <line15> sb.append(c); <line16> } <line17> return sb.toString(); <line18> } <line19> } <line20> "	<line6>
6664	"public class A { <line0> @Override <line1> public void onClick(AjaxRequestTarget target) { <line2> String cacheInformation = getCacheInformation(); <line3> MidPointApplication.get().getCacheRegistry().dumpContent(); <line4> getSession().success(getPageBase().getString(""InternalsCachePanel.result.dumped"")); <line5> target.add(getPageBase()); <line6> } <line7> } <line8> "	<line3>
6665	"public class A { <line0> public ActionForward save( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> if (!securityInfoManager.hasPrivilege( <line8> LoggedInInfo.getLoggedInInfoFromSession(request), ""_admin"", ""w"", null)) { <line9> throw new SecurityException(""missing required security object (_admin)""); <line10> } <line11> ActionMessages errors = form.validate(mapping, request); <line12> if (!errors.isEmpty()) { <line13> saveErrors(request, errors); <line14> return mapping.findForward(""edit""); <line15> } <line16> DynaActionForm issueAdminForm = (DynaActionForm) form; <line17> String newCode = ((Issue) issueAdminForm.get(""issueAdmin"")).getCode(); <line18> String newId = String.valueOf(((Issue) issueAdminForm.get(""issueAdmin"")).getId()); <line19> List<Issue> issueAdmins = mgr.getIssueAdmins(); <line20> for (Iterator<Issue> it = issueAdmins.iterator(); it.hasNext(); ) { <line21> Issue issueAdmin = it.next(); <line22> String existCode = issueAdmin.getCode(); <line23> String existId = String.valueOf(issueAdmin.getId()); <line24> if ((existCode.equals(newCode)) && !(existId.equals(newId))) { <line25> ActionMessages messages = new ActionMessages(); <line26> messages.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(""issueAdmin.code.exist"")); <line27> saveErrors(request, messages); <line28> return mapping.findForward(""edit""); <line29> } <line30> } <line31> mgr.saveIssueAdmin((Issue) issueAdminForm.get(""issueAdmin"")); <line32> ActionMessages messages = new ActionMessages(); <line33> messages.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(""issueAdmin.saved"")); <line34> saveMessages(request, messages); <line35> return list(mapping, form, request, response); <line36> } <line37> } <line38> "	<line6>
6666	"public class A { <line0> public void foo(@Simple(""${header.foo}"") String bar) { <line1> this.bar = bar; <line2> } <line3> } <line4> "	<line2>
6667	public class A { <line0> @NotAtomicAndNotIdempotent <line1> List<Node> makeCubeImmutableInReplicaSet(ReplicaSet rs, String cubeName) { <line2> List<Node> failedNodes = new ArrayList<>(); <line3> for (final Node node : rs.getNodes()) { <line4> try { <line5> getCoordinator().makeCubeImmutableForReceiver(node, cubeName); <line6> } catch (IOException ioe) { <line7> failedNodes.add(node); <line8> } <line9> } <line10> return failedNodes; <line11> } <line12> } <line13> 	<line7>
6668	public class A { <line0> @PostConstruct <line1> public void start() { <line2> _executor.scheduleAtFixedRate(new ServiceUpdateImpl(), 0, _updateFrequency, TimeUnit.SECONDS); <line3> } <line4> } <line5> 	<line2>
6669	public class A { <line0> private void fetchSTCCList() { <line1> try { <line2> } catch (Exception e) { <line3> } <line4> } <line5> } <line6> 	<line3>
6670	public class A { <line0> private void closeEventExecutorGroup() { <line1> if (eventExecutorGroup != null) { <line2> try { <line3> eventExecutorGroup.shutdownGracefully().sync(); <line4> } catch (InterruptedException e) { <line5> } <line6> eventExecutorGroup = null; <line7> } <line8> } <line9> } <line10> 	<line5>
6671	"public class A { <line0> public String getHiveDatabaseDir(String databaseName) { <line1> String dbDir = getOptional(""kylin.source.hive.warehouse-dir"", """"); <line2> if (!StringUtil.isEmpty(dbDir)) { <line3> } else { <line4> } <line5> if (!StringUtil.isEmpty(databaseName) && !databaseName.equalsIgnoreCase(DEFAULT)) { <line6> if (!dbDir.endsWith(""/"")) { <line7> dbDir += ""/""; <line8> } <line9> dbDir += databaseName + "".db""; <line10> } <line11> return dbDir; <line12> } <line13> } <line14> "	<line3>, <line4>
6672	public class A { <line0> private void updateTask(String task) { <line1> listenerForwarder.setTask(task); <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>
6673	public class A { <line0> @Override <line1> public void onDisconnected() { <line2> if (mode.contains(MODE.RESEND_SUBSCRIBE_ON_RECONNECTED)) { <line3> pubSubDriverSuspended = true; <line4> } else { <line5> } <line6> } <line7> } <line8> 	<line2>
6674	"public class A { <line0> @Override <line1> public <A extends Action<R>, R extends Result> void execute( <line2> final A action, final AsyncCallback<R> callback) { <line3> if (action instanceof AbstractWorkspaceAction<?>) { <line4> AbstractWorkspaceAction<?> wsAction = (AbstractWorkspaceAction<?>) action; <line5> if (userWorkspaceContext == null || identity == null) { <line6> callback.onFailure(new AuthorizationError(messages.dispatcherSetupFailed())); <line7> return; <line8> } <line9> wsAction.setEditorClientId(identity.getEditorClientId()); <line10> wsAction.setWorkspaceId(userWorkspaceContext.getWorkspaceContext().getWorkspaceId()); <line11> } <line12> final String sessionId = getSessionId(); <line13> realService.execute( <line14> new WrappedAction<R>(action, sessionId), <line15> new AbstractAsyncCallback<Result>() { <line16> public void onFailure(final Throwable caught) { <line17> if (caught instanceof com.google.gwt.user.client.rpc.StatusCodeException <line18> && ((StatusCodeException) caught).getStatusCode() == 0) { <line19> if (!(action instanceof ExitWorkspaceAction)) { <line20> eventBus.fireEvent( <line21> new NotificationEvent( <line22> NotificationEvent.Severity.Error, messages.noResponseFromServer())); <line23> } <line24> } <line25> if (caught instanceof AuthenticationError) { <line26> Application.redirectToLogin(); <line27> } else if (caught instanceof InvalidTokenError) { <line28> Application.redirectToLogin(); <line29> } else if (caught instanceof AuthorizationError) { <line30> callback.onFailure(caught); <line31> } else { <line32> callback.onFailure(caught); <line33> } <line34> } <line35>  <line36> @SuppressWarnings(""unchecked"") <line37> public void onSuccess(final Result result) { <line38> callback.onSuccess((R) result); <line39> } <line40> }); <line41> } <line42> } <line43> "	<line26>, <line28>, <line30>
6675	public class A { <line0> @Override <line1> public void deleteStaticRoute(String netIdIpAdress, String nextHopIpAddress) <line2> throws CapabilityException { <line3> String[] aParams = new String[2]; <line4> aParams[0] = netIdIpAdress; <line5> aParams[1] = nextHopIpAddress; <line6> IAction action = createActionAndCheckParams(StaticRouteActionSet.STATIC_ROUTE_DELETE, aParams); <line7> queueAction(action); <line8> } <line9> } <line10> 	<line3>, <line8>
6676	public class A { <line0> @Override <line1> public int read(final String context) throws IOException { <line2> int b = read(); <line3> return b; <line4> } <line5> } <line6> 	<line3>
6677	"public class A { <line0> @Override <line1> public void handleWorkflowTransition( <line2> ServiceContext ctx, DocumentWrapper<DocumentModel> wrapDoc, TransitionDef transitionDef) <line3> throws Exception { <line4> if (this.getShouldUpdateRevNumber() == true) { <line5> updateRevNumbers(wrapDoc); <line6> } <line7> DocumentModel docModel = wrapDoc.getWrappedObject(); <line8> if (transitionDef.getName().equalsIgnoreCase(WorkflowClient.WORKFLOWTRANSITION_DELETE)) { <line9> AuthorityRefDocList refsToAllObjects = <line10> getReferencingObjectsForStateTransitions(ctx, docModel, RefObjsSearchType.ALL); <line11> AuthorityRefDocList refsToSoftDeletedObjects = <line12> getReferencingObjectsForStateTransitions(ctx, docModel, RefObjsSearchType.DELETED_ONLY); <line13> if (refsToAllObjects.getTotalItems() > 0) { <line14> if (refsToAllObjects.getTotalItems() > refsToSoftDeletedObjects.getTotalItems()) { <line15> if (logger.isWarnEnabled() == true) { <line16> logReferencingObjects(docModel, refsToAllObjects); <line17> } <line18> throw new DocumentReferenceException( <line19> String.format( <line20> ""Cannot delete authority item '%s' because it still has records in the system"" <line21> + "" that are referencing it.  See the service layer log file for details."", <line22> docModel.getName())); <line23> } <line24> } <line25> } <line26> } <line27> } <line28> "	<line15>
6678	public class A { <line0> @Override <line1> public void iterationDone(Model model, int iteration, int epoch) { <line2> if (iteration % frequency == 0) { <line3> double score = model.score(); <line4> listIteration.add(iteration); <line5> listScore.add(score); <line6> if (logScore) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6679	public class A { <line0> @BeforeRun <line1> public void beforeRun(ThreadState state) { <line2> state.threadId = (int) threadIdGenerator.getAndIncrement(); <line3> state.totalThreadCount = (int) totalThreadCount.get(); <line4> } <line5> } <line6> 	<line4>
6680	"public class A { <line0> @ApiOperation( <line1> value = ""Reopens a closed case instance for a specified case definition."", <line2> response = Void.class, <line3> code = 201) <line4> @ApiResponses( <line5> value = { <line6> @ApiResponse(code = 500, message = ""Unexpected error""), <line7> @ApiResponse(code = 404, message = ""Case instance not found"") <line8> }) <line9> @PUT <line10> @Path(REOPEN_CASE_PUT_URI) <line11> @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line12> @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line13> public Response reopenCase( <line14> @javax.ws.rs.core.Context HttpHeaders headers, <line15> @ApiParam( <line16> value = ""container id where the case definition resides"", <line17> required = true, <line18> example = ""evaluation_1.0.0-SNAPSHOT"") <line19> @PathParam(CONTAINER_ID) <line20> String containerId, <line21> @ApiParam( <line22> value = ""case definition id that new instance should be created from"", <line23> required = true, <line24> example = ""evaluation"") <line25> @PathParam(CASE_DEF_ID) <line26> String caseDefId, <line27> @ApiParam(value = ""identifier of the case instance"", required = true) @PathParam(CASE_ID) <line28> String caseId, <line29> @ApiParam( <line30> value = ""optional CaseFile with variables and/or case role assignments"", <line31> required = false, <line32> examples = <line33> @Example( <line34> value = { <line35> @ExampleProperty(mediaType = JSON, value = CASE_FILE_JSON), <line36> @ExampleProperty(mediaType = XML, value = CASE_FILE_XML) <line37> })) <line38> String payload) { <line39> return invokeCaseOperation( <line40> headers, <line41> containerId, <line42> null, <line43> (Variant v, String type, Header... customHeaders) -> { <line44> caseManagementServiceBase.reopenCase(caseId, containerId, caseDefId, payload, type); <line45> return createResponse("""", v, Response.Status.CREATED, customHeaders); <line46> }); <line47> } <line48> } <line49> "	<line45>
6681	"public class A { <line0> private void searchExposedEndpoints(CoreSettings coreSettings) { <line1> if (!enableMqtt) { <line2> endpoints = Collections.emptyList(); <line3> return; <line4> } <line5> String endpointsString = customSettings.get(TAG_EXPOSED_MQTT_ENDPOINTS, getClass()); <line6> if (!endpointsString.isEmpty()) { <line7> String[] splitEndpoints = endpointsString.split("",""); <line8> endpoints = Collections.unmodifiableList(Arrays.asList(splitEndpoints)); <line9> } else { <line10> String serviceRootUrl = coreSettings.getQueryDefaults().getServiceRootUrl(); <line11> try { <line12> URL serviceRoot = new URL(serviceRootUrl); <line13> List<String> genEndpoints = new ArrayList<>(); <line14> genEndpoints.add(""mqtt://"" + serviceRoot.getHost() + "":"" + getPort()); <line15> endpoints = Collections.unmodifiableList(genEndpoints); <line16> } catch (MalformedURLException ex) { <line17> } <line18> } <line19> } <line20> } <line21> "	<line16>, <line17>
6682	public class A { <line0> public static com.liferay.document.library.kernel.model.DLFileEntrySoap[] getFileEntries( <line1> long groupId, <line2> long folderId, <line3> String[] mimeTypes, <line4> int status, <line5> int start, <line6> int end, <line7> com.liferay.portal.kernel.util.OrderByComparator< <line8> com.liferay.document.library.kernel.model.DLFileEntry> <line9> orderByComparator) <line10> throws RemoteException { <line11> try { <line12> java.util.List<com.liferay.document.library.kernel.model.DLFileEntry> returnValue = <line13> DLFileEntryServiceUtil.getFileEntries( <line14> groupId, folderId, mimeTypes, status, start, end, orderByComparator); <line15> return com.liferay.document.library.kernel.model.DLFileEntrySoap.toSoapModels(returnValue); <line16> } catch (Exception exception) { <line17> throw new RemoteException(exception.getMessage()); <line18> } <line19> } <line20> } <line21> 	<line17>
6683	public class A { <line0> @Override <line1> public void persist(TripUpdateModel tripUpdate) { <line2> boolean accepted = _tripUpdates.offer(tripUpdate); <line3> if (!accepted) { <line4> } <line5> } <line6> } <line7> 	<line4>
6684	"public class A { <line0> @Override <line1> public void addObjectField(String fieldName, Object member) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> if (fieldName == null) { <line5> throw new IllegalStateException(""addObjectField:Object should have fieldname""); <line6> } <line7> fieldList.add(new JSONFieldHolder(fieldName, member, FieldType.OBJECT)); <line8> } <line9> } <line10> "	<line3>
6685	public class A { <line0> @Test <line1> public void testCacheAndNodeStop() throws Exception { <line2> final Ignite ignite = startGrid(0); <line3> for (int i = 0; i < 3; i++) { <line4> startGrid(1); <line5> final CacheConfiguration ccfg = new CacheConfiguration(DEFAULT_CACHE_NAME); <line6> ignite.createCache(ccfg); <line7> final CyclicBarrier barrier = new CyclicBarrier(2); <line8> IgniteInternalFuture<?> fut1 = <line9> GridTestUtils.runAsync( <line10> new Callable<Object>() { <line11> @Override <line12> public Object call() throws Exception { <line13> barrier.await(); <line14> ignite.destroyCache(DEFAULT_CACHE_NAME); <line15> return null; <line16> } <line17> }); <line18> IgniteInternalFuture<?> fut2 = <line19> GridTestUtils.runAsync( <line20> new Callable<Object>() { <line21> @Override <line22> public Object call() throws Exception { <line23> barrier.await(); <line24> stopGrid(1); <line25> return null; <line26> } <line27> }); <line28> fut1.get(); <line29> fut2.get(); <line30> } <line31> } <line32> } <line33> 	<line4>
6686	"public class A { <line0> public void startHandshake(ClientHandshakeBuilder handshakedata) <line1> throws InvalidHandshakeException { <line2> this.handshakerequest = draft.postProcessHandshakeRequestAsClient(handshakedata); <line3> resourceDescriptor = handshakedata.getResourceDescriptor(); <line4> assert (resourceDescriptor != null); <line5> try { <line6> wsl.onWebsocketHandshakeSentAsClient(this, this.handshakerequest); <line7> } catch (InvalidDataException e) { <line8> throw new InvalidHandshakeException(""Handshake data rejected by client.""); <line9> } catch (RuntimeException e) { <line10> wsl.onWebsocketError(this, e); <line11> throw new InvalidHandshakeException(""rejected because of "" + e); <line12> } <line13> write(draft.createHandshake(this.handshakerequest)); <line14> } <line15> } <line16> "	<line10>
6687	"public class A { <line0> @Override <line1> public Object apply(final ActionContext ctx, final Object caller, final Object[] sources) <line2> throws FrameworkException { <line3> try { <line4> assertArrayHasLengthAndAllElementsNotNull(sources, 1); <line5> final HttpSession session = ctx.getSecurityContext().getSession(); <line6> if (session != null) { <line7> session.removeAttribute( <line8> ActionContext.SESSION_ATTRIBUTE_PREFIX.concat(sources[0].toString())); <line9> } else { <line10> } <line11> return """"; <line12> } catch (ArgumentNullException pe) { <line13> return null; <line14> } catch (ArgumentCountException pe) { <line15> logParameterError(caller, sources, pe.getMessage(), ctx.isJavaScriptContext()); <line16> return usage(ctx.isJavaScriptContext()); <line17> } <line18> } <line19> } <line20> "	<line10>
6688	"public class A { <line0> @Override <line1> public void initialize() { <line2> handlerConfig = getConfig().as(AccountHandlerConfig.class); <line3> synchronized (synchronizeConnection) { <line4> Connection connection = this.connection; <line5> if (connection == null) { <line6> this.connection = new Connection(null, gson); <line7> } <line8> } <line9> if (accountServlet == null) { <line10> try { <line11> accountServlet = <line12> new AccountServlet(httpService, this.getThing().getUID().getId(), this, gson); <line13> } catch (IllegalStateException e) { <line14> } <line15> } <line16> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, ""Wait for login""); <line17> checkLoginJob = scheduler.scheduleWithFixedDelay(this::checkLogin, 0, 60, TimeUnit.SECONDS); <line18> checkDataJob = scheduler.scheduleWithFixedDelay(this::checkData, 4, 60, TimeUnit.SECONDS); <line19> int pollingIntervalAlexa = handlerConfig.pollingIntervalSmartHomeAlexa; <line20> if (pollingIntervalAlexa < 10) { <line21> pollingIntervalAlexa = 10; <line22> } <line23> int pollingIntervalSkills = handlerConfig.pollingIntervalSmartSkills; <line24> if (pollingIntervalSkills < 60) { <line25> pollingIntervalSkills = 60; <line26> } <line27> smartHomeDeviceStateGroupUpdateCalculator = <line28> new SmartHomeDeviceStateGroupUpdateCalculator(pollingIntervalAlexa, pollingIntervalSkills); <line29> updateSmartHomeStateJob = <line30> scheduler.scheduleWithFixedDelay( <line31> () -> updateSmartHomeState(null), 20, 10, TimeUnit.SECONDS); <line32> } <line33> } <line34> "	<line14>
6689	public class A { <line0> public void submitSchemaRefresh( <line1> final SchemaElement targetType, final String targetKeyspace, final String targetName) { <line2> executor.submit( <line3> new ExceptionCatchingRunnable() { <line4> @Override <line5> public void runMayThrow() throws InterruptedException, ExecutionException { <line6> controlConnection.refreshSchema(targetType, targetKeyspace, targetName); <line7> } <line8> }); <line9> } <line10> } <line11> 	<line2>
6690	"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/crisisType/adddel"") <line3> public Response TestAddDeleteCrisisType() { <line4> try { <line5> CrisisTypeDTO crisisType = new CrisisTypeDTO(""test_db-manager_crisisType""); <line6> CrisisTypeDTO dto = remoteCrisisTypeEJB.addCrisisType(crisisType); <line7> if (dto != null) { <line8> Integer ret = remoteCrisisTypeEJB.deleteCrisisType(dto.getCrisisTypeId()); <line9> if (ret != null && ret.intValue() == 1) <line10> return Response.ok(""CrisisType Add-Delete test successful"" + dto).build(); <line11> } <line12> } catch (Exception e) { <line13> return Response.ok(""Exception: "" + e).build(); <line14> } <line15> return Response.ok(""CrisisType add-Delete test failed"").build(); <line16> } <line17> } <line18> "	<line8>, <line13>
6691	public class A { <line0> private void buildAndSignEnvelope( <line1> final DeviceRequest deviceRequest, <line2> final Oslp.Message payloadMessage, <line3> final Serializable extraData) { <line4> final String deviceIdentification = deviceRequest.getDeviceIdentification(); <line5> final String organisationIdentification = deviceRequest.getOrganisationIdentification(); <line6> final String correlationUid = deviceRequest.getCorrelationUid(); <line7> final String ipAddress = deviceRequest.getIpAddress(); <line8> final String domain = deviceRequest.getDomain(); <line9> final String domainVersion = deviceRequest.getDomainVersion(); <line10> final String messageType = deviceRequest.getMessageType(); <line11> final int messagePriority = deviceRequest.getMessagePriority(); <line12> final int retryCount = deviceRequest.getRetryCount(); <line13> final boolean isScheduled = deviceRequest.isScheduled(); <line14> final OslpDevice oslpDevice = <line15> this.oslpDeviceSettingsService.getDeviceByDeviceIdentification(deviceIdentification); <line16> if (oslpDevice == null) { <line17> return; <line18> } <line19> final byte[] deviceId = Base64.decodeBase64(oslpDevice.getDeviceUid()); <line20> final byte[] sequenceNumber = <line21> SequenceNumberUtils.convertIntegerToByteArray(oslpDevice.getSequenceNumber()); <line22> this.oslpSigningService.buildAndSignEnvelope( <line23> organisationIdentification, <line24> deviceIdentification, <line25> correlationUid, <line26> deviceId, <line27> sequenceNumber, <line28> ipAddress, <line29> domain, <line30> domainVersion, <line31> messageType, <line32> messagePriority, <line33> retryCount, <line34> isScheduled, <line35> payloadMessage, <line36> extraData); <line37> } <line38> } <line39> 	<line17>
6692	public class A { <line0> public void addSession(Session session) { <line1> this.availableSessionsById.put(session.getId(), session); <line2> final KieServerMessageHandler messageHandler = new KieServerMessageHandler(session); <line3> this.handlersPerSession.put(session.getId(), messageHandler); <line4> session.addMessageHandler(messageHandler); <line5> } <line6> } <line7> 	<line5>
6693	"public class A { <line0> public List<DocumentModel> getQuotes(DocumentModel docModel) throws ClientException { <line1> RelationManager relationManager; <line2> Map<String, Object> ctxMap = new HashMap<String, Object>(); <line3> ctxMap.put(ResourceAdapter.CORE_SESSION_CONTEXT_KEY, docModel.getSessionId()); <line4> try { <line5> relationManager = getRelationManager(); <line6> } catch (Exception e) { <line7> throw new ClientException(e); <line8> } <line9> Resource docResource = relationManager.getResource(config.documentNamespace, docModel, ctxMap); <line10> if (docResource == null) { <line11> throw new ClientException( <line12> ""Could not adapt document model to relation resource ; "" <line13> + ""check the service relation adapters configuration""); <line14> } <line15> Statement pattern = new StatementImpl(null, null, docResource); <line16> List<Statement> statementList = relationManager.getStatements(config.graphName, pattern); <line17> Resource oldDocResource = new QNameResourceImpl(config.documentNamespace, docModel.getId()); <line18> Statement oldPattern = new StatementImpl(null, null, oldDocResource); <line19> statementList.addAll(relationManager.getStatements(config.graphName, oldPattern)); <line20> List<DocumentModel> commentList = new ArrayList<DocumentModel>(); <line21> for (Statement stmt : statementList) { <line22> QNameResourceImpl subject = (QNameResourceImpl) stmt.getSubject(); <line23> DocumentModel commentDocModel = null; <line24> try { <line25> commentDocModel = <line26> (DocumentModel) <line27> relationManager.getResourceRepresentation(config.commentNamespace, subject, ctxMap); <line28> } catch (Exception e) { <line29> } <line30> if (commentDocModel == null) { <line31> continue; <line32> } <line33> commentList.add(commentDocModel); <line34> } <line35> QuoteSorter sorter = new QuoteSorter(true); <line36> Collections.sort(commentList, sorter); <line37> return commentList; <line38> } <line39> } <line40> "	<line29>, <line31>
6694	public class A { <line0> private @Nullable String addMachineTranslationsToDoc( <line1> HDocument doc, <line2> HLocale targetLocale, <line3> String projectSlug, <line4> String versionSlug, <line5> ContentState saveState, <line6> boolean overwriteFuzzy, <line7> String backendId, <line8> AsyncTaskHandle taskHandle) { <line9> DocumentId documentId = new DocumentId(doc.getId(), doc.getDocId()); <line10> entityManager.clear(); <line11> List<HTextFlow> textFlowsToTranslate = <line12> getTextFlowsByDocumentIdWithConstraints(targetLocale, documentId, overwriteFuzzy); <line13> int textFlowsToSkip = <line14> entityManager.find(HDocument.class, doc.getId()).getTextFlows().size() <line15> - textFlowsToTranslate.size(); <line16> taskHandle.increaseProgress(textFlowsToSkip); <line17> if (textFlowsToTranslate.isEmpty()) { <line18> return null; <line19> } <line20> int startBatch = 0; <line21> String backendIdConfirmation = null; <line22> while (startBatch < textFlowsToTranslate.size()) { <line23> int batchEnd = Math.min(startBatch + REQUEST_BATCH_SIZE, textFlowsToTranslate.size()); <line24> List<HTextFlow> textFlowBatch = textFlowsToTranslate.subList(startBatch, batchEnd); <line25> MTDocument mtDocument = <line26> textFlowsToMTDoc.fromTextFlows( <line27> projectSlug, <line28> versionSlug, <line29> doc.getDocId(), <line30> doc.getSourceLocaleId(), <line31> textFlowBatch, <line32> TextFlowsToMTDoc::extractPluralIfPresent, <line33> backendId); <line34> Stopwatch mtProviderStopwatch = Stopwatch.createStarted(); <line35> MTDocument result = getTranslationFromMT(mtDocument, targetLocale.getLocaleId()); <line36> saveTranslationsInBatches(textFlowBatch, result, targetLocale, saveState); <line37> backendIdConfirmation = result.getBackendId(); <line38> startBatch = batchEnd; <line39> taskHandle.increaseProgress(textFlowBatch.size()); <line40> } <line41> if (backendIdConfirmation == null) { <line42> } <line43> return backendIdConfirmation; <line44> } <line45> } <line46> 	<line18>, <line24>, <line34>, <line36>, <line42>
6695	public class A { <line0> public void quickRun() { <line1> EventManager eventManager = new EventManager(); <line2> try { <line3> int aEventId = eventManager.createAsync(60); <line4> eventManager.start(aEventId); <line5> int sEventId = eventManager.create(60); <line6> eventManager.start(sEventId); <line7> eventManager.status(aEventId); <line8> eventManager.status(sEventId); <line9> eventManager.cancel(aEventId); <line10> eventManager.cancel(sEventId); <line11> } catch (MaxNumOfEventsAllowedException <line12> | LongRunningEventException <line13> | EventDoesNotExistException <line14> | InvalidOperationException e) { <line15> } <line16> } <line17> } <line18> 	<line4>, <line5>, <line6>, <line7>, <line10>, <line11>, <line15>
6696	public class A { <line0> @Override <line1> public State newState(String namespace, Map<String, Object> topoConf, TopologyContext context) { <line2> try { <line3> return getRedisKeyValueState(namespace, topoConf, context, getStateConfig(topoConf)); <line4> } catch (Exception ex) { <line5> throw new RuntimeException(ex); <line6> } <line7> } <line8> } <line9> 	<line5>
6697	public class A { <line0> public String getChecksum(String replicaId, String filename) { <line1> if (results.containsKey(Replica.getReplicaFromId(replicaId))) { <line2> try { <line3> String res = results.get(Replica.getReplicaFromId(replicaId)); <line4> KeyValuePair<String, String> kvp = ChecksumJob.parseLine(res); <line5> if (kvp.getKey().equals(filename)) { <line6> return kvp.getValue(); <line7> } <line8> } catch (ArgumentNotValid e) { <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	<line8>, <line9>
6698	public class A { <line0> @Override <line1> public boolean start() throws PlatformInitializationException { <line2> PentahoSystem.setSystemSettingsService(new PathBasedSystemSettings()); <line3> BasicConfigurator.configure(); <line4> boolean ret = super.start(); <line5> try { <line6> Object o = PentahoSystem.get(ISolutionEngine.class); <line7> if (o != null && o instanceof ILogger) { <line8> ((ILogger) o).setLoggingLevel(ILogger.DEBUG); <line9> } <line10> } catch (Throwable e) { <line11> } <line12> return ret; <line13> } <line14> } <line15> 	<line11>
6699	public class A { <line0> @After <line1> public void stopCounter() { <line2> final long runtime = System.currentTimeMillis() - testStartTime; <line3> if (runtime > 2000) { <line4> } <line5> } <line6> } <line7> 	<line4>
6700	public class A { <line0> @Override <line1> public void stop() { <line2> final Configuration conf = createConfiguration(); <line3> try { <line4> final JobClient client = new JobClient(conf); <line5> if (client != null) { <line6> final RunningJob job = client.getJob(JobID.forName(this.jobId)); <line7> if (job != null) { <line8> job.killJob(); <line9> } <line10> } <line11> } catch (IOException e) { <line12> getLogger().severe(e.getMessage()); <line13> } <line14> } <line15> } <line16> 	<line2>, <line14>
6701	"public class A { <line0> public List<UserDefinedCalendarConfiguration> getCalendarConfigurations(String subscribeId) { <line1> try { <line2> @SuppressWarnings(""unchecked"") <line3> List<UserDefinedCalendarConfiguration> configurations = <line4> (List<UserDefinedCalendarConfiguration>) <line5> getHibernateTemplate() <line6> .find( <line7> ""from CalendarConfiguration config where "" <line8> + ""subscribeId = ? and displayed = true "" <line9> + ""order by calendarDefinition.name"", <line10> subscribeId); <line11> return configurations; <line12> } catch (HibernateException ex) { <line13> throw convertHibernateAccessException(ex); <line14> } <line15> } <line16> } <line17> "	<line2>
6702	"public class A { <line0> public List<String> terms( <line1> final String table, <line2> final String columnFamily, <line3> final String columnName, <line4> final String startWith, <line5> final short size) <line6> throws Exception { <line7> Map<String, BlurIndex> blurIndexes; <line8> try { <line9> blurIndexes = _indexServer.getIndexes(table); <line10> } catch (IOException e) { <line11> throw new BException(e.getMessage(), e); <line12> } <line13> TableContext tableContext = getTableContext(table); <line14> FieldManager fieldManager = tableContext.getFieldManager(); <line15> final FieldTypeDefinition typeDefinition = <line16> fieldManager.getFieldTypeDefinition(columnFamily + ""."" + columnName); <line17> return ForkJoin.execute( <line18> _executor, <line19> blurIndexes.entrySet(), <line20> new ParallelCall<Entry<String, BlurIndex>, List<String>>() { <line21> @Override <line22> public List<String> call(Entry<String, BlurIndex> input) throws Exception { <line23> BlurIndex index = input.getValue(); <line24> IndexSearcherCloseable searcher = index.getIndexSearcher(); <line25> try { <line26> return terms( <line27> searcher.getIndexReader(), <line28> typeDefinition, <line29> columnFamily, <line30> columnName, <line31> startWith, <line32> size); <line33> } finally { <line34> searcher.close(); <line35> } <line36> } <line37> }) <line38> .merge( <line39> new Merger<List<String>>() { <line40> @Override <line41> public List<String> merge(BlurExecutorCompletionService<List<String>> service) <line42> throws BlurException { <line43> SortedSet<String> terms = new TreeSet<String>(); <line44> while (service.getRemainingCount() > 0) { <line45> Future<List<String>> future = <line46> service.poll( <line47> _defaultParallelCallTimeout, <line48> TimeUnit.MILLISECONDS, <line49> true, <line50> table, <line51> columnFamily, <line52> columnName, <line53> startWith, <line54> size); <line55> terms.addAll( <line56> service.getResultThrowException( <line57> future, table, columnFamily, columnName, startWith, size)); <line58> } <line59> return new ArrayList<String>(terms).subList(0, Math.min(size, terms.size())); <line60> } <line61> }); <line62> } <line63> } <line64> "	<line11>
6703	public class A { <line0> public CreateProjectPage enterDescription(String projectDescription) { <line1> enterText(readyElement(descriptionField), projectDescription); <line2> return new CreateProjectPage(getDriver()); <line3> } <line4> } <line5> 	<line1>
6704	"public class A { <line0> public void insertEdge(String parentSysmlId, String childSysmlId, DbEdgeTypes edgeType) { <line1> if (parentSysmlId == null <line2> || childSysmlId == null <line3> || parentSysmlId.isEmpty() <line4> || childSysmlId.isEmpty()) { <line5> return; <line6> } <line7> String query = <line8> String.format( <line9> ""INSERT INTO \""edges%1$s\"" (parent, child, edgeType) VALUES ((SELECT id FROM"" <line10> + "" \""nodes%1$s\"" WHERE sysmlId = ?), (SELECT id FROM \""nodes%1$s\"" WHERE sysmlId ="" <line11> + "" ?), ?)"", <line12> workspaceId); <line13> try (PreparedStatement statement = prepareStatement(query)) { <line14> statement.setString(1, parentSysmlId); <line15> statement.setString(2, childSysmlId); <line16> statement.setInt(3, edgeType.getValue()); <line17> statement.executeUpdate(); <line18> } catch (Exception e) { <line19> if (e.getMessage().contains(""duplicate key"")) { <line20> } else { <line21> } <line22> } finally { <line23> close(); <line24> } <line25> } <line26> } <line27> "	<line5>, <line20>, <line21>
6705	"public class A { <line0> @BeforeClass <line1> public static void setUpClass() { <line2> if (Info.PATHS.PATH_DATA_FOLDER.exists()) { <line3> hasDataDir = true; <line4> } else { <line5> try { <line6> File dataExample = <line7> new File(Info.PATHS.PATH_WORKDIR.getParentFile().getParentFile() + ""/data-example""); <line8> copy(dataExample.getAbsolutePath(), Info.PATHS.PATH_DATA_FOLDER.getAbsolutePath()); <line9> canPerformTest = true; <line10> } catch (IOException e) { <line11> canPerformTest = false; <line12> } <line13> } <line14> } <line15> } <line16> "	<line8>
6706	"public class A { <line0> @Test(enabled = false) <line1> public void testPresenceSolutionBlind() { <line2> optimizer = new Optimizer(NUM_PLANS_TO_GENERATE, SearchMethodName.BLINDSEARCH); <line3> String[] arrayDam = optimizer.optimize(appModel, suitableCloudOffer); <line4> for (int damnum = 0; damnum < arrayDam.length; damnum++) { <line5> try { <line6> checkCorrectness(arrayDam[damnum]); <line7> } catch (Exception e) { <line8> throw e; <line9> } <line10> saveFile( <line11> OUTPUT_FILENAME_JULY15 + SearchMethodName.BLINDSEARCH + damnum + "".yaml"", <line12> arrayDam[damnum]); <line13> } <line14> } <line15> } <line16> "	<line2>, <line8>, <line14>
6707	"public class A { <line0> @Override <line1> public int doEndTag() throws JspException { <line2> try { <line3> String value = this.extractValue(); <line4> if (null == value) { <line5> return super.doEndTag(); <line6> } <line7> IParameterParentTag parentTag = <line8> (IParameterParentTag) findAncestorWithClass(this, IParameterParentTag.class); <line9> parentTag.addParameter(this.getName(), value); <line10> } catch (Throwable t) { <line11> throw new JspException(""Error closing tag "", t); <line12> } <line13> return super.doEndTag(); <line14> } <line15> } <line16> "	<line11>
6708	public class A { <line0> @Override <line1> public void validate(Context context, DOReader reader) throws ServerException { <line2> if (m_enabled) { <line3> for (DOObjectValidator validator : m_validators.values()) { <line4> try { <line5> validator.validate(context, reader); <line6> } catch (ObjectValidityException e) { <line7> throw e; <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	<line7>
6709	public class A { <line0> private DlmsConnector connectorFor(final SecurityLevel securityLevel) throws FunctionalException { <line1> switch (securityLevel) { <line2> case HLS5: <line3> return this.hls5Connector; <line4> case LLS1: <line5> return this.lls1Connector; <line6> case LLS0: <line7> return this.lls0Connector; <line8> default: <line9> throw new FunctionalException( <line10> FunctionalExceptionType.UNSUPPORTED_COMMUNICATION_SETTING, ComponentType.PROTOCOL_DLMS); <line11> } <line12> } <line13> } <line14> 	<line9>
6710	public class A { <line0> public boolean exists(String key) { <line1> Path dir = getKeyDir(key); <line2> boolean res = false; <line3> try { <line4> fileSystem = dir.getFileSystem(hadoopConf); <line5> res = fileSystem.exists(dir); <line6> } catch (IOException e) { <line7> } <line8> return res; <line9> } <line10> } <line11> 	<line7>
6711	public class A { <line0> @Override <line1> public void visit(SchemaIndexCacheVisitorClosure clo) { <line2> assert nonNull(clo); <line3> List<GridDhtLocalPartition> locParts = cctx.topology().localPartitions(); <line4> if (locParts.isEmpty()) { <line5> buildIdxFut.onDone(); <line6> return; <line7> } <line8> cctx.group().metrics().addIndexBuildCountPartitionsLeft(locParts.size()); <line9> cctx.cache().metrics0().resetIndexRebuildKeyProcessed(); <line10> beforeExecute(); <line11> AtomicInteger partsCnt = new AtomicInteger(locParts.size()); <line12> AtomicBoolean stop = new AtomicBoolean(); <line13> SchemaIndexCacheCompoundFuture buildIdxCompoundFut = new SchemaIndexCacheCompoundFuture(); <line14> for (GridDhtLocalPartition locPart : locParts) { <line15> GridWorkerFuture<SchemaIndexCacheStat> workerFut = new GridWorkerFuture<>(); <line16> GridWorker worker = <line17> new SchemaIndexCachePartitionWorker( <line18> cctx, locPart, stop, cancel, clo, workerFut, partsCnt); <line19> workerFut.setWorker(worker); <line20> buildIdxCompoundFut.add(workerFut); <line21> cctx.kernalContext().buildIndexExecutorService().execute(worker); <line22> } <line23> buildIdxCompoundFut.listen( <line24> fut -> { <line25> if (isNull(err) && collectStat && log.isInfoEnabled()) { <line26> try { <line27> GridCompoundFuture<SchemaIndexCacheStat, SchemaIndexCacheStat> compoundFut = <line28> (GridCompoundFuture<SchemaIndexCacheStat, SchemaIndexCacheStat>) fut; <line29> SchemaIndexCacheStat resStat = new SchemaIndexCacheStat(); <line30> compoundFut.futures().stream() <line31> .map(IgniteInternalFuture::result) <line32> .filter(Objects::nonNull) <line33> .forEach(resStat::accumulate); <line34> } catch (Exception e) { <line35> } <line36> } <line37> buildIdxFut.onDone(err); <line38> }); <line39> buildIdxCompoundFut.markInitialized(); <line40> } <line41> } <line42> 	<line25>, <line34>, <line35>
6712	public class A { <line0> @Override <line1> public final void run() { <line2> this.running = true; <line3> if (ResourceManager.useCloud()) { <line4> try { <line5> Thread.sleep(INITIAL_SLEEP); <line6> } catch (InterruptedException e) { <line7> Thread.currentThread().interrupt(); <line8> } <line9> } <line10> if (ResourceManager.useCloud()) { <line11> initialCreations(); <line12> } <line13> while (this.running) { <line14> try { <line15> doOperations(); <line16> periodicRemoveObsoletes(); <line17> try { <line18> synchronized (this) { <line19> if (this.running) { <line20> this.wait(SLEEP_TIME); <line21> } <line22> } <line23> } catch (InterruptedException ie) { <line24> } <line25> } catch (Exception e) { <line26> } <line27> } <line28> } <line29> } <line30> 	<line11>, <line26>
6713	public class A { <line0> private synchronized void onInconsistency(AppendEntriesReplyProto reply) { <line1> AppendEntriesRequestProto request = pendingRequests.remove(reply.getServerReply().getCallId()); <line2> if (request == null) { <line3> return; <line4> } <line5> Preconditions.assertTrue(request.hasPreviousLog()); <line6> if (request.getPreviousLog().getIndex() >= reply.getNextIndex()) { <line7> clearPendingRequests(reply.getNextIndex()); <line8> } <line9> } <line10> } <line11> 	<line3>
6714	public class A { <line0> public void debugFreeList() { <line1> } <line2> } <line3> 	<line1>
6715	"public class A { <line0> @Override <line1> public void prepare(ResponseBuilder rb) throws IOException { <line2> SolrParams params = rb.req.getParams(); <line3> if (!params.getBool(COMPONENT_NAME, false)) { <line4> return; <line5> } <line6> boolean buildAll = params.getBool(SUGGEST_BUILD_ALL, false); <line7> boolean reloadAll = params.getBool(SUGGEST_RELOAD_ALL, false); <line8> final Collection<SolrSuggester> querysuggesters; <line9> if (buildAll || reloadAll) { <line10> Collection<SuggesterCache> suggesterCaches = suggesters.values(); <line11> querysuggesters = new ArrayList<SolrSuggester>(suggesterCaches.size()); <line12> for (SuggesterCache cache : suggesterCaches) { <line13> querysuggesters.add(cache.get(ASYNC_CACHE_KEY)); <line14> } <line15> } else { <line16> querysuggesters = getSuggesters(params); <line17> } <line18> if (params.getBool(SUGGEST_BUILD, false) || buildAll) { <line19> for (SolrSuggester suggester : querysuggesters) { <line20> suggester.build(rb.req.getCore(), rb.req.getSearcher()); <line21> } <line22> rb.rsp.add(""command"", (!buildAll) ? ""build"" : ""buildAll""); <line23> } else if (params.getBool(SUGGEST_RELOAD, false) || reloadAll) { <line24> for (SolrSuggester suggester : querysuggesters) { <line25> reloadSuggester(suggester, rb.req.getCore(), rb.req.getSearcher()); <line26> } <line27> rb.rsp.add(""command"", (!reloadAll) ? ""reload"" : ""reloadAll""); <line28> } <line29> } <line30> } <line31> "	<line3>
6716	public class A { <line0> private Optional<Event> toEvent(Delivery delivery) { <line1> String message = new String(delivery.getBody(), StandardCharsets.UTF_8); <line2> try { <line3> Event event = serializer.deserialize(message); <line4> return Optional.of(event); <line5> } catch (Exception e) { <line6> return Optional.empty(); <line7> } <line8> } <line9> } <line10> 	<line6>
6717	public class A { <line0> private void loadSQLDriverClass() { <line1> try { <line2> Class.forName(getChosenSQLDriver()); <line3> } catch (ClassNotFoundException e) { <line4> } <line5> } <line6> } <line7> 	<line4>
6718	public class A { <line0> @Override <line1> public void startFolderEvent( <line2> Session session, FileOperation op, Path file, Set<PosixFilePermission> perms) <line3> throws IOException { <line4> } <line5> } <line6> 	<line4>
6719	"public class A { <line0> private Path createClassesLst( <line1> JarBuildItem jarResult, <line2> OutputTargetBuildItem outputTarget, <line3> String javaBinPath, <line4> String containerImage, <line5> Path appCDSDir, <line6> boolean isFastJar) { <line7> List<String> commonJavaArgs = new ArrayList<>(3); <line8> commonJavaArgs.add(""-XX:DumpLoadedClassList="" + CLASSES_LIST_FILE_NAME); <line9> commonJavaArgs.add( <line10> String.format(""-D%s=true"", MainClassBuildStep.GENERATE_APP_CDS_SYSTEM_PROPERTY)); <line11> commonJavaArgs.add(""-jar""); <line12> List<String> command; <line13> if (containerImage != null) { <line14> List<String> dockerRunCommand = <line15> dockerRunCommands(outputTarget, containerImage, CONTAINER_IMAGE_APPCDS_DIR); <line16> command = new ArrayList<>(dockerRunCommand.size() + 1 + commonJavaArgs.size()); <line17> command.addAll(dockerRunCommand); <line18> command.add(""java""); <line19> command.addAll(commonJavaArgs); <line20> if (isFastJar) { <line21> command.add( <line22> CONTAINER_IMAGE_BASE_BUILD_DIR <line23> + ""/"" <line24> + JarResultBuildStep.DEFAULT_FAST_JAR_DIRECTORY_NAME <line25> + ""/"" <line26> + JarResultBuildStep.QUARKUS_RUN_JAR); <line27> } else { <line28> command.add( <line29> CONTAINER_IMAGE_BASE_BUILD_DIR + ""/"" + jarResult.getPath().getFileName().toString()); <line30> } <line31> } else { <line32> command = new ArrayList<>(2 + commonJavaArgs.size()); <line33> command.add(javaBinPath); <line34> command.addAll(commonJavaArgs); <line35> if (isFastJar) { <line36> command.add( <line37> jarResult <line38> .getLibraryDir() <line39> .getParent() <line40> .resolve(JarResultBuildStep.QUARKUS_RUN_JAR) <line41> .toAbsolutePath() <line42> .toString()); <line43> } else { <line44> command.add(jarResult.getPath().toAbsolutePath().toString()); <line45> } <line46> } <line47> if (log.isDebugEnabled()) { <line48> log.debugf( <line49> ""Launching command: '%s' to create '"" + CLASSES_LIST_FILE_NAME + ""' file."", <line50> String.join("" "", command)); <line51> } <line52> int exitCode; <line53> try { <line54> ProcessBuilder processBuilder = new ProcessBuilder(command).directory(appCDSDir.toFile()); <line55> if (log.isDebugEnabled()) { <line56> processBuilder.inheritIO(); <line57> } else { <line58> processBuilder.redirectError(NULL_FILE); <line59> processBuilder.redirectOutput(NULL_FILE); <line60> } <line61> exitCode = processBuilder.start().waitFor(); <line62> } catch (Exception e) { <line63> return null; <line64> } <line65> if (exitCode != 0) { <line66> log.debugf( <line67> ""The process that was supposed to create AppCDS exited with error code: %d."", exitCode); <line68> return null; <line69> } <line70> Path result = appCDSDir.resolve(CLASSES_LIST_FILE_NAME); <line71> if (!Files.exists(result)) { <line72> log.warnf( <line73> ""Unable to create AppCDS because '%s' was not created. Check the logs for details"", <line74> CLASSES_LIST_FILE_NAME); <line75> return null; <line76> } <line77> return result; <line78> } <line79> } <line80> "	<line63>
6720	public class A { <line0> protected void unmapSession(Long sessionId) { <line1> if (sessionId != null) { <line2> IoSession ioSession = sessions.remove(sessionId); <line3> if (log.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> } <line8> 	<line4>
6721	"public class A { <line0> @POST <line1> @Path(""addZippedMediaPackage/{workflowDefinitionId}"") <line2> @Produces(MediaType.TEXT_XML) <line3> @RestQuery( <line4> name = ""addZippedMediaPackage"", <line5> description = <line6> ""Create media package from a compressed file containing a manifest.xml document and all"" <line7> + "" media tracks, metadata catalogs and attachments"", <line8> pathParameters = { <line9> @RestParameter( <line10> description = ""Workflow definition id"", <line11> isRequired = true, <line12> name = WORKFLOW_DEFINITION_ID_PARAM, <line13> type = RestParameter.Type.STRING) <line14> }, <line15> restParameters = { <line16> @RestParameter( <line17> description = ""The workflow instance ID to associate with this zipped mediapackage"", <line18> isRequired = false, <line19> name = WORKFLOW_INSTANCE_ID_PARAM, <line20> type = RestParameter.Type.STRING) <line21> }, <line22> bodyParameter = <line23> @RestParameter( <line24> description = ""The compressed (application/zip) media package file"", <line25> isRequired = true, <line26> name = ""BODY"", <line27> type = RestParameter.Type.FILE), <line28> responses = { <line29> @RestResponse(description = """", responseCode = HttpServletResponse.SC_OK), <line30> @RestResponse(description = """", responseCode = HttpServletResponse.SC_BAD_REQUEST), <line31> @RestResponse(description = """", responseCode = HttpServletResponse.SC_NOT_FOUND), <line32> @RestResponse(description = """", responseCode = HttpServletResponse.SC_SERVICE_UNAVAILABLE) <line33> }, <line34> returnDescription = """") <line35> public Response addZippedMediaPackage( <line36> @Context HttpServletRequest request, <line37> @PathParam(""workflowDefinitionId"") String wdID, <line38> @QueryParam(""id"") String wiID) { <line39> if (!isIngestLimitEnabled() || getIngestLimit() > 0) { <line40> return ingestZippedMediaPackage(request, wdID, wiID); <line41> } else { <line42> return Response.status(Status.SERVICE_UNAVAILABLE).build(); <line43> } <line44> } <line45> } <line46> "	<line39>, <line42>
6722	"public class A { <line0> private RestResponse<CustomGroup> groups() throws CatalogException, ClientException { <line1> studiesCommandOptions.groupsCommandOptions.study = <line2> getSingleValidStudy(studiesCommandOptions.groupsCommandOptions.study); <line3> ObjectMap params = new ObjectMap(); <line4> params.putIfNotNull(""id"", studiesCommandOptions.groupsCommandOptions.group); <line5> return openCGAClient <line6> .getStudyClient() <line7> .groups(studiesCommandOptions.groupsCommandOptions.study, params); <line8> } <line9> } <line10> "	<line1>
6723	public class A { <line0> protected void deactivate(ComponentContext componentContext) { <line1> if (isConnected()) { <line2> try { <line3> publishDisconnectCertificate(); <line4> } catch (KuraException e) { <line5> } <line6> } <line7> this.dataService.removeDataServiceListener(this); <line8> this.cloudClients.clear(); <line9> this.dataService = null; <line10> this.systemService = null; <line11> this.systemAdminService = null; <line12> this.networkService = null; <line13> this.positionService = null; <line14> this.eventAdmin = null; <line15> this.certificatesService = null; <line16> this.cloudServiceRegistration.unregister(); <line17> this.notificationPublisherRegistration.unregister(); <line18> } <line19> } <line20> 	<line1>, <line5>
6724	"public class A { <line0> @Override <line1> public ProjectRecord cloneProject(Long idProject) { <line2> ProjectRecord original = getProject(idProject); <line3> if (original == null) { <line4> throw new NullPointerException(""Project doesn't exist""); <line5> } <line6> Long idUser = BlocklyPropSecurityUtils.getCurrentUserId(); <line7> if (original.getIdUser().equals(idUser) || original.getShared()) { <line8> return doProjectClone(original); <line9> } <line10> return null; <line11> } <line12> } <line13> "	<line2>
6725	public class A { <line0> private static TopologyDef processIncludes( <line1> Yaml yaml, TopologyDef topologyDef, Properties properties, boolean envSub) <line2> throws IOException { <line3> if (topologyDef.getIncludes() != null) { <line4> for (IncludeDef include : topologyDef.getIncludes()) { <line5> TopologyDef includeTopologyDef = null; <line6> if (include.isResource()) { <line7> includeTopologyDef = parseResource(include.getFile(), true, false, properties, envSub); <line8> } else { <line9> includeTopologyDef = parseFile(include.getFile(), true, false, properties, envSub); <line10> } <line11> boolean override = include.isOverride(); <line12> if (includeTopologyDef.getName() != null) { <line13> topologyDef.setName(includeTopologyDef.getName(), override); <line14> } <line15> if (includeTopologyDef.getConfig() != null) { <line16> Map<String, Object> config = topologyDef.getConfig(); <line17> Map<String, Object> includeConfig = includeTopologyDef.getConfig(); <line18> if (override) { <line19> config.putAll(includeTopologyDef.getConfig()); <line20> } else { <line21> for (String key : includeConfig.keySet()) { <line22> if (config.containsKey(key)) { <line23> } else { <line24> config.put(key, includeConfig.get(key)); <line25> } <line26> } <line27> } <line28> } <line29> if (includeTopologyDef.getComponents() != null) { <line30> topologyDef.addAllComponents(includeTopologyDef.getComponents(), override); <line31> } <line32> if (includeTopologyDef.getBolts() != null) { <line33> topologyDef.addAllBolts(includeTopologyDef.getBolts(), override); <line34> } <line35> if (includeTopologyDef.getSpouts() != null) { <line36> topologyDef.addAllSpouts(includeTopologyDef.getSpouts(), override); <line37> } <line38> if (includeTopologyDef.getStreams() != null) { <line39> topologyDef.addAllStreams(includeTopologyDef.getStreams(), override); <line40> } <line41> } <line42> } <line43> return topologyDef; <line44> } <line45> } <line46> 	<line7>, <line9>, <line23>
6726	public class A { <line0> @Override <line1> public void close() throws HiveException { <line2> if (model != null) { <line3> if (count == 0) { <line4> this.model = null; <line5> return; <line6> } <line7> if (iterations > 1) { <line8> runIterativeTraining(iterations); <line9> } <line10> final IntWritable idx = new IntWritable(); <line11> final FloatWritable[] Pu = HiveUtils.newFloatArray(factor, 0.f); <line12> final FloatWritable[] Qi = HiveUtils.newFloatArray(factor, 0.f); <line13> final FloatWritable Bu = new FloatWritable(); <line14> final FloatWritable Bi = new FloatWritable(); <line15> final Object[] forwardObj; <line16> if (updateMeanRating) { <line17> assert useBiasClause; <line18> float meanRating = model.getMeanRating(); <line19> FloatWritable mu = new FloatWritable(meanRating); <line20> forwardObj = new Object[] {idx, Pu, Qi, Bu, Bi, mu}; <line21> } else { <line22> if (useBiasClause) { <line23> forwardObj = new Object[] {idx, Pu, Qi, Bu, Bi}; <line24> } else { <line25> forwardObj = new Object[] {idx, Pu, Qi}; <line26> } <line27> } <line28> int numForwarded = 0; <line29> for (int i = model.getMinIndex(), maxIdx = model.getMaxIndex(); i <= maxIdx; i++) { <line30> idx.set(i); <line31> Rating[] userRatings = model.getUserVector(i); <line32> if (userRatings == null) { <line33> forwardObj[1] = null; <line34> } else { <line35> forwardObj[1] = Pu; <line36> copyTo(userRatings, Pu); <line37> } <line38> Rating[] itemRatings = model.getItemVector(i); <line39> if (itemRatings == null) { <line40> forwardObj[2] = null; <line41> } else { <line42> forwardObj[2] = Qi; <line43> copyTo(itemRatings, Qi); <line44> } <line45> if (useBiasClause) { <line46> Bu.set(model.getUserBias(i)); <line47> Bi.set(model.getItemBias(i)); <line48> } <line49> forward(forwardObj); <line50> numForwarded++; <line51> } <line52> this.model = null; <line53> } <line54> } <line55> } <line56> 	<line53>
6727	public class A { <line0> @Override <line1> public void start(final Map<String, String> props) { <line2> config = new JdbcSinkConfig(props); <line3> initWriter(); <line4> remainingRetries = config.maxRetries; <line5> try { <line6> reporter = context.errantRecordReporter(); <line7> } catch (NoSuchMethodError | NoClassDefFoundError e) { <line8> reporter = null; <line9> } <line10> } <line11> } <line12> 	<line2>
6728	"public class A { <line0> private void logEntityInfo( <line1> final DataDefinition dataDefinition, final Long entityId, final String message) { <line2> if (LOG.isInfoEnabled()) { <line3> StringBuilder entityInfo = new StringBuilder(""Entity[""); <line4> entityInfo <line5> .append(dataDefinition.getPluginIdentifier()) <line6> .append('.') <line7> .append(dataDefinition.getName()); <line8> entityInfo.append(""][id="").append(entityId).append(""] ""); <line9> entityInfo.append(message); <line10> } <line11> } <line12> } <line13> "	<line10>
6729	"public class A { <line0> public static void waitForAddressSpaceConfigurationApplied( <line1> AddressSpace addressSpace, String currentConfig) throws Exception { <line2> TimeoutBudget budget = new TimeoutBudget(15, TimeUnit.MINUTES); <line3> boolean isConfigApplied = false; <line4> while (budget.timeLeft() >= 0 && !isConfigApplied) { <line5> addressSpace = <line6> Kubernetes.getInstance() <line7> .getAddressSpaceClient(addressSpace.getMetadata().getNamespace()) <line8> .withName(addressSpace.getMetadata().getName()) <line9> .get(); <line10> isConfigApplied = <line11> !addressSpace.getAnnotation(AnnotationKeys.APPLIED_CONFIGURATION).equals(currentConfig); <line12> if (!isConfigApplied) { <line13> Thread.sleep(2000); <line14> } <line15> if (verboseLogs) { <line16> } <line17> } <line18> isConfigApplied = <line19> !addressSpace.getAnnotation(AnnotationKeys.APPLIED_CONFIGURATION).equals(currentConfig); <line20> if (!isConfigApplied) { <line21> String jsonStatus = addressSpace.getAnnotation(AnnotationKeys.APPLIED_CONFIGURATION); <line22> throw new IllegalStateException( <line23> ""Address Space "" + addressSpace + "" contains wrong configuration: "" + jsonStatus); <line24> } <line25> } <line26> } <line27> "	<line16>, <line25>
6730	public class A { <line0> public boolean evaluateState(VeluxBridge bridge) { <line1> boolean success = false; <line2> GetHouseStatus bcp = bridge.bridgeAPI().getHouseStatus(); <line3> if (bcp != null) { <line4> if (bridge.bridgeCommunicate(bcp) && bcp.isCommunicationSuccessful()) { <line5> success = true; <line6> } <line7> } <line8> return success; <line9> } <line10> } <line11> 	<line1>, <line8>
6731	"public class A { <line0> @Override <line1> public CertificateVerificationResult verifyCertificate( <line2> final ConnectionId cid, <line3> final ServerNames serverName, <line4> final Boolean clientUsage, <line5> final boolean truncateCertificatePath, <line6> final CertificateMessage message, <line7> final DTLSSession session) { <line8> try { <line9> final CertPath certChain = message.getCertificateChain(); <line10> if (certChain == null) { <line11> final AlertMessage alert = <line12> new AlertMessage(AlertLevel.FATAL, AlertDescription.BAD_CERTIFICATE, session.getPeer()); <line13> throw new HandshakeException(""RPK not supported"", alert); <line14> } <line15> final List<? extends Certificate> list = certChain.getCertificates(); <line16> final int pathSize = list.size(); <line17> if (pathSize < 1) { <line18> final AlertMessage alert = <line19> new AlertMessage(AlertLevel.FATAL, AlertDescription.BAD_CERTIFICATE, session.getPeer()); <line20> throw new HandshakeException(""client certificate chain must not be empty"", alert); <line21> } <line22> if (clientUsage != null) { <line23> final Certificate certificate = list.get(0); <line24> if (certificate instanceof X509Certificate) { <line25> if (!CertPathUtil.canBeUsedForAuthentication( <line26> (X509Certificate) certificate, clientUsage)) { <line27> final AlertMessage alert = <line28> new AlertMessage( <line29> AlertLevel.FATAL, AlertDescription.BAD_CERTIFICATE, session.getPeer()); <line30> throw new HandshakeException( <line31> ""certificate cannot be used for client authentication"", alert); <line32> } <line33> } <line34> } <line35> adapter.runOnContext((v) -> validateCertificateAndLoadDevice(cid, certChain, session)); <line36> return null; <line37> } catch (HandshakeException e) { <line38> return new CertificateVerificationResult(cid, e, null); <line39> } <line40> } <line41> } <line42> "	<line38>
6732	"public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent e) { <line2> try { <line3> this.application.getMainFrame().removeAllProjectFrames(); <line4> URL paysURL = new URL(""file"", """", ""./data/ne_admin_0_countries/ne_50m_admin_0_countries.shp""); <line5> IPopulation<IFeature> paysPop = ShapefileReader.read(paysURL.getPath()); <line6> double saut = 45.0; <line7> double sautCourant = 45.0; <line8> while (sautCourant <= 180.0) { <line9> System.out.println(""Saut = "" + sautCourant); <line10> Population<DefaultFeature> popTranslation = new Population<DefaultFeature>(); <line11> popTranslation.setFeatureType(paysPop.getFeatureType()); <line12> for (IFeature feature : paysPop.getElements()) { <line13> String continent = feature.getAttribute(""continent"").toString().trim(); <line14> if (continent.equals(""North America"") || continent.equals(""Europe"")) { <line15> ArrayList<DefaultFeature> listATraiter = splitMultiPolygonToSinglePolygon(feature); <line16> for (DefaultFeature feat : listATraiter) { <line17> List<DefaultFeature> listNouveauFeature = getFeatureTranslate(feat, saut); <line18> if (listNouveauFeature != null && listNouveauFeature.size() > 0) { <line19> for (int j = 0; j < listNouveauFeature.size(); j++) { <line20> popTranslation.add(listNouveauFeature.get(j)); <line21> } <line22> } <line23> } <line24> } <line25> } <line26> ProjectFrame projectFrame = application.getMainFrame().newProjectFrame(); <line27> Layer layerEntite = <line28> projectFrame.addUserLayer( <line29> popTranslation, popTranslation.getNom() + ""-"" + sautCourant, null); <line30> Float size = 2f; <line31> ((PolygonSymbolizer) layerEntite.getSymbolizer()).getStroke().setStrokeWidth(size); <line32> Color darkGreen = new Color(0, 148, 255); <line33> Color lightGreen = new Color(127, 201, 255); <line34> ((PolygonSymbolizer) layerEntite.getSymbolizer()).getFill().setColor(lightGreen); <line35> ((PolygonSymbolizer) layerEntite.getSymbolizer()).getStroke().setStroke(darkGreen); <line36> layerEntite.getSymbolizer().setUnitOfMeasurePixel(); <line37> sautCourant = sautCourant + saut; <line38> } <line39> } catch (Exception ex) { <line40> ex.printStackTrace(); <line41> } <line42> try { <line43> this.application.getMainFrame().organizeCurrentDesktop(); <line44> for (int i = 0; i < this.application.getMainFrame().getDesktopProjectFrames().length; i++) { <line45> ProjectFrame frame = this.application.getMainFrame().getDesktopProjectFrames()[i]; <line46> frame.getLayerLegendPanel().getLayerViewPanel().getViewport().zoomToFullExtent(); <line47> } <line48> } catch (Exception ex) { <line49> ex.printStackTrace(); <line50> } <line51> System.out.println(""----""); <line52> } <line53> } <line54> "	<line2>
6733	"public class A { <line0> @Override <line1> public boolean cancelJob(String id) { <line2> client <line3> .delete(JOBS_PATH + ""/"" + id) <line4> .send( <line5> res -> { <line6> if (res.succeeded() <line7> && (res.result().statusCode() == 200 || res.result().statusCode() == 404)) { <line8> } else { <line9> } <line10> }); <line11> return true; <line12> } <line13> } <line14> "	<line8>, <line9>
6734	public class A { <line0> public static void writeAllFiles(Map<Path, String> outputDataByPath) throws IOException { <line1> for (Entry<Path, String> outputDataEntry : outputDataByPath.entrySet()) { <line2> Path outputPath = outputDataEntry.getKey(); <line3> outputPath.getParent().toFile().mkdirs(); <line4> MoreFiles.asCharSink(outputPath, UTF_8).write(outputDataEntry.getValue()); <line5> } <line6> } <line7> } <line8> 	<line3>
6735	"public class A { <line0> @Override <line1> public void run() { <line2> Object o = event.getSource(); <line3> if (o == attachButton) { <line4> if (attachButton.getText().equals(attach)) { <line5> int index = controllerList.getSelectedIndex(); <line6> if (index != -1) { <line7> swingGui.send( <line8> boundServiceName, <line9> attach, <line10> controllerList.getSelectedItem(), <line11> deviceBusList.getSelectedItem(), <line12> deviceAddressList.getSelectedItem()); <line13> } <line14> } else { <line15> swingGui.send(boundServiceName, detach, controllerList.getSelectedItem()); <line16> } <line17> } <line18> if (o == refresh) { <line19> swingGui.send(boundServiceName, ""refresh""); <line20> } <line21> } <line22> } <line23> "	<line15>
6736	public class A { <line0> @Override <line1> public void transportInterupted() { <line2> interruptedCount.incrementAndGet(); <line3> } <line4> } <line5> 	<line2>
6737	public class A { <line0> public Map setPartitionFieldValues(String partitionfieldValuesStr) { <line1> Map<String, Object> fieldValues; <line2> try { <line3> ObjectMapper objectMapper = new ObjectMapper(); <line4> fieldValues = objectMapper.readValue(partitionfieldValuesStr, Map.class); <line5> for (String key : fieldValues.keySet()) { <line6> List value = (List) fieldValues.get(key); <line7> fieldValues.put(key, value); <line8> } <line9> return fieldValues; <line10> } catch (Exception e) { <line11> throw new RuntimeException(e); <line12> } <line13> } <line14> } <line15> 	<line11>
6738	public class A { <line0> private void deleteElementFile(File elementFile) { <line1> if (elementFile.exists()) { <line2> if (!elementFile.delete()) { <line3> } <line4> } else { <line5> } <line6> File elementDir = elementFile.getParentFile(); <line7> if (elementDir != null && elementDir.exists() && elementDir.list() != null) { <line8> if (elementDir.list().length == 0) { <line9> if (!elementDir.delete()) { <line10> } <line11> } else { <line12> } <line13> } else { <line14> } <line15> File mediapackageDir = elementDir.getParentFile(); <line16> if (mediapackageDir != null && mediapackageDir.exists()) { <line17> if (mediapackageDir.list().length == 0) { <line18> if (!mediapackageDir.delete()) { <line19> } <line20> } else { <line21> } <line22> } else { <line23> } <line24> } <line25> } <line26> 	<line3>, <line5>, <line10>, <line12>, <line14>, <line19>, <line21>, <line23>
6739	public class A { <line0> public StepPhase stageApp(CloudApplication app) { <line1> CloudPackage cloudPackage = context.getVariable(Variables.CLOUD_PACKAGE); <line2> if (cloudPackage == null) { <line3> return StepPhase.DONE; <line4> } <line5> return createBuild(cloudPackage.getGuid()); <line6> } <line7> } <line8> 	<line5>
6740	"public class A { <line0> public B addExtra(String key, String value) { <line1> Preconditions.checkArgument(!(null == key), ""Key should not be null.""); <line2> if (null == value) { <line3> return theBuilder; <line4> } <line5> if (null == extrasBuilder) { <line6> extrasBuilder = new HashMap<String, String>(); <line7> } <line8> extrasBuilder.put(key, value); <line9> return theBuilder; <line10> } <line11> } <line12> "	<line3>
6741	"public class A { <line0> @Override <line1> public void process(InputStream in, OutputStream out) throws IOException { <line2> InputStream pgpin = getDecoderStream(in); <line3> JcaPGPObjectFactory pgpFactory = new JcaPGPObjectFactory(pgpin); <line4> Object obj = pgpFactory.nextObject(); <line5> if (!(obj instanceof PGPEncryptedDataList)) { <line6> obj = pgpFactory.nextObject(); <line7> if (!(obj instanceof PGPEncryptedDataList)) { <line8> throw new ProcessException(""Invalid OpenPGP data""); <line9> } <line10> } <line11> PGPEncryptedDataList encList = (PGPEncryptedDataList) obj; <line12> obj = encList.get(0); <line13> if (!(obj instanceof PGPPBEEncryptedData)) { <line14> throw new ProcessException(""Invalid OpenPGP data""); <line15> } <line16> PGPPBEEncryptedData encryptedData = (PGPPBEEncryptedData) obj; <line17> try { <line18> final PGPDigestCalculatorProvider digestCalculatorProvider = <line19> new JcaPGPDigestCalculatorProviderBuilder().setProvider(provider).build(); <line20> final PBEDataDecryptorFactory decryptorFactory = <line21> new JcePBEDataDecryptorFactoryBuilder(digestCalculatorProvider) <line22> .setProvider(provider) <line23> .build(password); <line24> InputStream clear = encryptedData.getDataStream(decryptorFactory); <line25> JcaPGPObjectFactory pgpObjectFactory = new JcaPGPObjectFactory(clear); <line26> obj = pgpObjectFactory.nextObject(); <line27> if (obj instanceof PGPCompressedData) { <line28> PGPCompressedData compressedData = (PGPCompressedData) obj; <line29> pgpObjectFactory = new JcaPGPObjectFactory(compressedData.getDataStream()); <line30> obj = pgpObjectFactory.nextObject(); <line31> } <line32> PGPLiteralData literalData = (PGPLiteralData) obj; <line33> InputStream plainIn = literalData.getInputStream(); <line34> final byte[] buffer = new byte[org.apache.nifi.processors.standard.util.PGPUtil.BLOCK_SIZE]; <line35> int len; <line36> while ((len = plainIn.read(buffer)) >= 0) { <line37> out.write(buffer, 0, len); <line38> } <line39> if (encryptedData.isIntegrityProtected()) { <line40> if (!encryptedData.verify()) { <line41> throw new PGPException(""Integrity check failed""); <line42> } <line43> } else { <line44> } <line45> } catch (Exception e) { <line46> throw new ProcessException(e.getMessage()); <line47> } <line48> } <line49> } <line50> "	<line44>
6742	public class A { <line0> public void detach(Attachable device) { <line1> if (!isAttached(device)) { <line2> return; <line3> } <line4> if (device instanceof ServoControl && device.isAttached(this)) { <line5> device.detach(this); <line6> } <line7> Integer id = getDeviceId(device); <line8> if (id != null) { <line9> msg.deviceDetach(id); <line10> deviceIndex.remove(id); <line11> } <line12> deviceList.remove(device.getName()); <line13> } <line14> } <line15> 	<line1>, <line2>, <line7>
6743	"public class A { <line0> @NonNull <line1> @Override <line2> public ReconnectionSchedule newControlConnectionSchedule( <line3> @SuppressWarnings(""ignored"") boolean isInitialConnection) { <line4> return new ExponentialSchedule(); <line5> } <line6> } <line7> "	<line4>
6744	public class A { <line0> @Override <line1> public void warn(Throwable t, I18nResource message, Object... params) { <line2> if (!isWarnEnabled()) return; <line3> if (t == null) { <line4> warn(message, params); <line5> return; <line6> } <line7> if (message == null) { <line8> return; <line9> } <line10> } <line11> } <line12> 	<line8>, <line10>
6745	"public class A { <line0> @RequestMapping( <line1> value = ""/{mvnGroup:.+}/{artifact:.+}/{version:.+}/{type:.+}/{qname:.+}"", <line2> method = RequestMethod.GET) <line3> public void getConstructSourceForGav( <line4> @PathVariable String mvnGroup, <line5> @PathVariable String artifact, <line6> @PathVariable String version, <line7> @PathVariable String type, <line8> @PathVariable String qname, <line9> HttpServletResponse response) { <line10> Path file = null; <line11> JavaId jid = null; <line12> JavaId def_ctx = null; <line13> try { <line14> jid = JavaId.getJavaId(type, qname); <line15> def_ctx = JavaId.getCompilationUnit(jid); <line16> file = <line17> ClassDownloader.getInstance() <line18> .getClass( <line19> mvnGroup, <line20> artifact, <line21> version, <line22> def_ctx.getQualifiedName(), <line23> ClassDownloader.Format.JAVA); <line24> if (file == null) { <line25> response.sendError( <line26> HttpServletResponse.SC_NOT_FOUND, <line27> ""Cannot retrieve class ["" + def_ctx.getQualifiedName() + ""]""); <line28> response.flushBuffer(); <line29> } else { <line30> FileAnalyzer jfa = FileAnalyzerFactory.buildFileAnalyzer(file.toFile()); <line31> if (jfa.containsConstruct(jid)) { <line32> response.setContentType(""text/plain""); <line33> final String source_code = jfa.getConstruct(jid).getContent(); <line34> response.getWriter().print(source_code); <line35> response.flushBuffer(); <line36> } else { <line37> response.sendError(HttpServletResponse.SC_NOT_FOUND, ""Cannot find construct "" + jid); <line38> response.flushBuffer(); <line39> } <line40> try { <line41> Files.delete(file); <line42> } catch (Exception e) { <line43> } <line44> } <line45> } catch (IllegalArgumentException iae) { <line46> throw new RuntimeException(iae.getMessage()); <line47> } catch (FileNotFoundException e) { <line48> log.error(""Error: "" + e.getMessage(), e); <line49> throw new RuntimeException(""Cannot read file ["" + file + ""]""); <line50> } catch (IOException e) { <line51> log.error(""Error: "" + e.getMessage(), e); <line52> throw new RuntimeException(""IO exception when reading file ["" + file + ""]""); <line53> } catch (Exception e) { <line54> throw new RuntimeException( <line55> e.getClass().getSimpleName() + "" when writing file to output stream: "" + e.getMessage()); <line56> } <line57> } <line58> } <line59> "	<line16>, <line43>, <line46>, <line54>
6746	"public class A { <line0> @Override <line1> public ListProperty getListProperty(String name) { <line2> if (name == null) { <line3> return new ListPropertyImpl(""""); <line4> } <line5> ListPropertyImpl listProperty = new ListPropertyImpl(name); <line6> configListeners.put(listProperty, true); <line7> return listProperty; <line8> } <line9> } <line10> "	<line3>
6747	"public class A { <line0> public String getNextSequenceNumber(int numDigits, String vcenterId) throws Exception { <line1> if (vcenterId == null) { <line2> throw new IllegalArgumentException( <line3> ""DataAccessService.getNextSequenceNumber() vCenter cannot be null.""); <line4> } <line5> String seqName = ""vcenter_"" + vcenterId.trim() + ""_seq""; <line6> String seq = null; <line7> String query = ""SELECT nextval('"" + seqName + ""')""; <line8> try (Connection con = getDatasource().getConnection(); <line9> PreparedStatement stmt = con.prepareStatement(query); ) { <line10> ResultSet rs = stmt.executeQuery(); <line11> while (rs.next()) { <line12> Integer seqnum = new Integer(rs.getInt(""nextval"")); <line13> seq = String.format(""%0"" + numDigits + ""d"", seqnum); <line14> } <line15> } catch (SQLException e) { <line16> String message = Messages.get(locale, ""error_db_seq"", seqName); <line17> throw new Exception(message); <line18> } <line19> return seq; <line20> } <line21> } <line22> "	<line1>, <line16>
6748	"public class A { <line0> @VisibleForTesting <line1> static boolean copy( <line2> FileSystem srcFS, <line3> Path src, <line4> FileSystem dstFS, <line5> Path dst, <line6> boolean deleteSource, <line7> boolean overwrite, <line8> HiveConf conf, <line9> HadoopShims shims) <line10> throws IOException { <line11> boolean copied = false; <line12> boolean triedDistcp = false; <line13> if (srcFS.getUri().getScheme().equals(""hdfs"")) { <line14> ContentSummary srcContentSummary = srcFS.getContentSummary(src); <line15> if (srcContentSummary.getFileCount() <line16> > conf.getLongVar(HiveConf.ConfVars.HIVE_EXEC_COPYFILE_MAXNUMFILES) <line17> && srcContentSummary.getLength() <line18> > conf.getLongVar(HiveConf.ConfVars.HIVE_EXEC_COPYFILE_MAXSIZE)) { <line19> triedDistcp = true; <line20> copied = <line21> distCp(srcFS, Collections.singletonList(src), dst, deleteSource, null, conf, shims); <line22> } <line23> } <line24> if (!triedDistcp) { <line25> copied = FileUtil.copy(srcFS, src, dstFS, dst, deleteSource, overwrite, conf); <line26> } <line27> return copied; <line28> } <line29> } <line30> "	<line19>
6749	public class A { <line0> public static <K, C> void createColumnFamiliy( <line1> final Keyspace keyspace, <line2> final ColumnFamily<K, C> columnFamily, <line3> final Map<String, Object> options) { <line4> try { <line5> if (keyspace.describeKeyspace().getColumnFamily(columnFamily.getName()) == null) { <line6> keyspace.createColumnFamily(columnFamily, new HashMap<String, Object>()); <line7> } <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> 	<line9>
6750	public class A { <line0> public void readEntryAndFenceLedger( <line1> final long ledgerId, byte[] masterKey, final long entryId, ReadEntryCallback cb, Object ctx) { <line2> final long txnId = getTxnId(); <line3> final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY); <line4> completionObjects.put( <line5> completionKey, <line6> new ReadCompletion( <line7> statsLogger, <line8> BookKeeperClientStats.CHANNEL_READ_ENTRY_AND_FENCE, <line9> cb, <line10> ctx, <line11> ledgerId, <line12> entryId, <line13> scheduleTimeout(completionKey, conf.getReadEntryTimeout()))); <line14> BKPacketHeader.Builder headerBuilder = <line15> BKPacketHeader.newBuilder() <line16> .setVersion(ProtocolVersion.VERSION_THREE) <line17> .setOperation(OperationType.READ_ENTRY) <line18> .setTxnId(txnId); <line19> ReadRequest.Builder readBuilder = <line20> ReadRequest.newBuilder() <line21> .setLedgerId(ledgerId) <line22> .setEntryId(entryId) <line23> .setMasterKey(ByteString.copyFrom(masterKey)) <line24> .setFlag(ReadRequest.Flag.FENCE_LEDGER); <line25> final Request readRequest = <line26> Request.newBuilder().setHeader(headerBuilder).setReadRequest(readBuilder).build(); <line27> final Channel c = channel; <line28> if (c == null) { <line29> errorOutReadKey(completionKey); <line30> return; <line31> } <line32> writeRequestToChannel( <line33> c, <line34> readRequest, <line35> new GenericCallback<Void>() { <line36> @Override <line37> public void operationComplete(int rc, Void result) { <line38> if (rc != 0) { <line39> errorOutReadKey(completionKey); <line40> } else { <line41> if (LOG.isDebugEnabled()) { <line42> } <line43> } <line44> } <line45> }); <line46> } <line47> } <line48> 	<line42>
6751	"public class A { <line0> private ResultSet getColumnsMetadata(Connection con, String tableNameFilter) { <line1> try { <line2> if (con != null) { <line3> DatabaseMetaData dbMetaData = con.getMetaData(); <line4> if (dbMetaData != null) { <line5> return dbMetaData.getColumns(null, null, tableNameFilter, ""%""); <line6> } <line7> } <line8> } catch (SQLException ex) { <line9> } <line10> return null; <line11> } <line12> } <line13> "	<line9>
6752	"public class A { <line0> @Override <line1> public void validateHttpPostOnly() { <line2> if (user != null) { <line3> String trimmedPassword = StringUtils.trimToNull(user.getPassword()); <line4> String trimmedPassword2 = StringUtils.trimToNull(password2); <line5> if (trimmedPassword != null && !trimmedPassword.equals(trimmedPassword2)) { <line6> addFieldError(""password2"", getText(""validation.password2.wrong"")); <line7> password2 = null; <line8> } else if (trimmedPassword == null) { <line9> addFieldError(""user.password"", getText(""validation.password.reentered"")); <line10> } else { <line11> user.setPassword(trimmedPassword); <line12> } <line13> } <line14> } <line15> } <line16> "	<line7>, <line10>, <line12>
6753	"public class A { <line0> @Override <line1> public void onTraversalDone(GenomeLocSortedSet result) { <line2> if (VALIDATE_GVCF) { <line3> final GenomeLocSortedSet toolkitIntervals = getToolkit().getIntervals(); <line4> final GenomeLocSortedSet traversalIntervals; <line5> if (toolkitIntervals == null) { <line6> traversalIntervals = <line7> GenomeLocSortedSet.createSetFromSequenceDictionary( <line8> getToolkit().getMasterSequenceDictionary()); <line9> } else { <line10> traversalIntervals = toolkitIntervals; <line11> } <line12> final GenomeLocSortedSet uncoveredIntervals = traversalIntervals.subtractRegions(result); <line13> if (traversalIntervals.subtractRegions(result).coveredSize() > 0) { <line14> final UserException e = <line15> new UserException.FailsStrictValidation( <line16> file, <line17> ""Found "" <line18> + uncoveredIntervals.coveredSize() <line19> + "" positions not covered by a VariantContext record. The first uncovered"" <line20> + "" segment is: "" <line21> + uncoveredIntervals.iterator().next() <line22> + "". As noted in the documentation for the --validateGVCF/-gvcf argument, GVCF"" <line23> + "" validation requires that all positions to validate be covered by records."" <line24> + "" Use -L or --XL to specify what intervals are covered in the GVCF. These"" <line25> + "" should be the same intervals used to generate the GVCF or a subset"" <line26> + "" thereof.""); <line27> if (WARN_ON_ERROR) { <line28> numErrors++; <line29> } else { <line30> throw e; <line31> } <line32> } <line33> } <line34> if (numErrors == 0) <line35> System.out.println( <line36> ""Successfully validated the input file.  Checked "" <line37> + result.size() <line38> + "" records with no failures.""); <line39> else System.out.println(""Found "" + numErrors + "" records with failures.""); <line40> } <line41> } <line42> "	<line29>
6754	public class A { <line0> protected final void sneakySaveLevelDat() { <line1> try { <line2> this.saveLevelDat(); <line3> } catch (IOException cause) { <line4> } <line5> } <line6> } <line7> 	<line4>
6755	public class A { <line0> public final ApplicationTraceMetadata registerTrace() { <line1> final TraceMetadata enclosingTrace = this.getTrace(); <line2> if (enclosingTrace != null) { <line3> Stack<TraceMetadata> localTraceStack = this.enclosingTraceStack.get(); <line4> if (localTraceStack == null) { <line5> localTraceStack = new Stack<>(); <line6> this.enclosingTraceStack.set(localTraceStack); <line7> } <line8> localTraceStack.push(enclosingTrace); <line9> } <line10> final Thread thread = Thread.currentThread(); <line11> final TracePoint tp = this.getAndRemoveParentTraceId(thread); <line12> final long traceId = this.getNewId(); <line13> final long parentTraceId; <line14> final int parentOrderId; <line15> if (tp != null) { <line16> if ((enclosingTrace != null) && (enclosingTrace.getTraceId() != tp.traceId)) { <line17> } <line18> parentTraceId = tp.traceId; <line19> parentOrderId = tp.orderId; <line20> } else if (enclosingTrace != null) { <line21> parentTraceId = enclosingTrace.getTraceId(); <line22> parentOrderId = -1; <line23> } else { <line24> parentTraceId = traceId; <line25> parentOrderId = -1; <line26> } <line27> final String sessionId = SessionRegistry.INSTANCE.recallThreadLocalSessionId(); <line28> final String applicationName = MonitoringController.getInstance().getApplicationName(); <line29> final ApplicationTraceMetadata trace = <line30> new ApplicationTraceMetadata( <line31> traceId, <line32> thread.getId(), <line33> sessionId, <line34> this.hostname, <line35> parentTraceId, <line36> parentOrderId, <line37> applicationName); <line38> this.traceStorage.set(trace); <line39> return trace; <line40> } <line41> } <line42> 	<line17>
6756	public class A { <line0> public final Response putConnection(final ComponentConnection body) { <line1> if (body == null) { <line2> return new Response(Response.BAD_REQUEST, null); <line3> } <line4> String path = String.format(CONNECTION_PATH, body.getObjectId()); <line5> return putObjectToSystemMng(path, body); <line6> } <line7> } <line8> 	<line5>
6757	"public class A { <line0> protected String getXacmlDataType(String curPermValue) { <line1> if (""false"".equalsIgnoreCase(curPermValue) || ""true"".equalsIgnoreCase(curPermValue)) { <line2> return BOOLEAN_DATA_TYPE; <line3> } else if (IntegerValidator.getInstance().validate(curPermValue) != null) { <line4> return INTEGER_DATA_TYPE; <line5> } else if (DoubleValidator.getInstance().validate(curPermValue, Locale.getDefault()) != null) { <line6> return DOUBLE_DATA_TYPE; <line7> } else if (TimeValidator.getInstance().validate(curPermValue, ""H:mm:ss"") != null <line8> || TimeValidator.getInstance().validate(curPermValue, ""H:mm:ss.SSS"") != null <line9> || TimeValidator.getInstance().validate(curPermValue, ""H:mm:ssXXX"") != null <line10> || TimeValidator.getInstance().validate(curPermValue, ""H:mm:ss.SSSXXX"") != null) { <line11> return TIME_DATA_TYPE; <line12> } else if (DateValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd"") != null <line13> || DateValidator.getInstance().validate(curPermValue, ""yyyy-MM-ddXXX"") != null) { <line14> return DATE_DATA_TYPE; <line15> } else if (CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd:ss'T'H:mm"") <line16> != null <line17> || CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd'T'H:mm:ssXXX"") != null <line18> || CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd'T'H:mm:ss.SSS"") <line19> != null <line20> || CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd'T'H:mm:ss.SSSXXX"") <line21> != null <line22> || CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd'T'H:mm:ss"") != null) { <line23> return DATE_TIME_DATA_TYPE; <line24> } else if (EmailValidator.getInstance().isValid(curPermValue)) { <line25> return RFC822_NAME_DATA_TYPE; <line26> } else if (new UrlValidator().isValid(curPermValue)) { <line27> return URI_DATA_TYPE; <line28> } else if (InetAddresses.isUriInetAddress(curPermValue)) { <line29> return IP_ADDRESS_DATA_TYPE; <line30> } else { <line31> try { <line32> if (new X500Name(curPermValue).getRDNs().length > 0) { <line33> return X500_NAME_DATA_TYPE; <line34> } <line35> } catch (IllegalArgumentException e) { <line36> } <line37> } <line38> return STRING_DATA_TYPE; <line39> } <line40> } <line41> "	<line36>
6758	public class A { <line0> private boolean deleteAllInstantsOlderorEqualsInAuxMetaFolder(HoodieInstant thresholdInstant) <line1> throws IOException { <line2> List<HoodieInstant> instants = null; <line3> boolean success = true; <line4> try { <line5> instants = <line6> metaClient.scanHoodieInstantsFromFileSystem( <line7> new Path(metaClient.getMetaAuxiliaryPath()), <line8> HoodieActiveTimeline.VALID_EXTENSIONS_IN_ACTIVE_TIMELINE, <line9> false); <line10> } catch (FileNotFoundException e) { <line11> return success; <line12> } <line13> List<HoodieInstant> instantsToBeDeleted = <line14> instants.stream() <line15> .filter( <line16> instant1 -> <line17> HoodieTimeline.compareTimestamps( <line18> instant1.getTimestamp(), <line19> LESSER_THAN_OR_EQUALS, <line20> thresholdInstant.getTimestamp())) <line21> .collect(Collectors.toList()); <line22> for (HoodieInstant deleteInstant : instantsToBeDeleted) { <line23> Path metaFile = new Path(metaClient.getMetaAuxiliaryPath(), deleteInstant.getFileName()); <line24> if (metaClient.getFs().exists(metaFile)) { <line25> success &= metaClient.getFs().delete(metaFile, false); <line26> } <line27> } <line28> return success; <line29> } <line30> } <line31> 	<line11>, <line23>, <line26>
6759	public class A { <line0> @Deprecated <line1> protected Object readSync(final ZclAttribute attribute) { <line2> CommandResult result; <line3> try { <line4> result = read(attribute).get(); <line5> } catch (InterruptedException e) { <line6> return null; <line7> } catch (ExecutionException e) { <line8> return null; <line9> } <line10> if (!result.isSuccess()) { <line11> return null; <line12> } <line13> ReadAttributesResponse response = result.getResponse(); <line14> if (response.getRecords().get(0).getStatus() == ZclStatus.SUCCESS) { <line15> ReadAttributeStatusRecord attributeRecord = response.getRecords().get(0); <line16> return normalizer.normalizeZclData( <line17> attribute.getDataType(), attributeRecord.getAttributeValue()); <line18> } <line19> return null; <line20> } <line21> } <line22> 	<line2>, <line6>, <line8>
6760	"public class A { <line0> protected boolean processZKCmd(MyCommandOptions co) <line1> throws CliException, IOException, InterruptedException { <line2> String[] args = co.getArgArray(); <line3> String cmd = co.getCommand(); <line4> if (args.length < 1) { <line5> usage(); <line6> throw new MalformedCommandException(""No command entered""); <line7> } <line8> if (!commandMap.containsKey(cmd)) { <line9> usage(); <line10> throw new CommandNotFoundException(""Command not found "" + cmd); <line11> } <line12> boolean watch = false; <line13> if (cmd.equals(""quit"")) { <line14> zk.close(); <line15> ServiceUtils.requestSystemExit(exitCode); <line16> } else if (cmd.equals(""redo"") && args.length >= 2) { <line17> Integer i = Integer.decode(args[1]); <line18> if (commandCount <= i || i < 0) { <line19> throw new MalformedCommandException(""Command index out of range""); <line20> } <line21> cl.parseCommand(history.get(i)); <line22> if (cl.getCommand().equals(""redo"")) { <line23> throw new MalformedCommandException(""No redoing redos""); <line24> } <line25> history.put(commandCount, history.get(i)); <line26> processCmd(cl); <line27> } else if (cmd.equals(""history"")) { <line28> for (int i = commandCount - 10; i <= commandCount; ++i) { <line29> if (i < 0) { <line30> continue; <line31> } <line32> System.out.println(i + "" - "" + history.get(i)); <line33> } <line34> } else if (cmd.equals(""printwatches"")) { <line35> if (args.length == 1) { <line36> System.out.println(""printwatches is "" + (printWatches ? ""on"" : ""off"")); <line37> } else { <line38> printWatches = args[1].equals(""on""); <line39> } <line40> } else if (cmd.equals(""connect"")) { <line41> if (args.length >= 2) { <line42> connectToZK(args[1]); <line43> } else { <line44> connectToZK(host); <line45> } <line46> } <line47> if (zk == null || !zk.getState().isAlive()) { <line48> System.out.println(""Not connected""); <line49> return false; <line50> } <line51> CliCommand cliCmd = commandMapCli.get(cmd); <line52> if (cliCmd != null) { <line53> cliCmd.setZk(zk); <line54> watch = cliCmd.parse(args).exec(); <line55> } else if (!commandMap.containsKey(cmd)) { <line56> usage(); <line57> } <line58> return watch; <line59> } <line60> } <line61> "	<line13>
6761	public class A { <line0> @EventListener(ApplicationReadyEvent.class) <line1> @Order(value = 2) <line2> public void onApplicationEvent(ApplicationReadyEvent event) { <line3> this.nfConsumer.subscribe(); <line4> launchNotificationsConsumer(); <line5> launchMainConsumers(); <line6> } <line7> } <line8> 	<line3>
6762	public class A { <line0> @Override <line1> public BroadcastSubscriptionListener getBroadcastSubscriptionListener(String subscriptionId) { <line2> if (!subscriptionStates.containsKey(subscriptionId) <line3> || !broadcastSubscriptionListenerDirectory.containsKey(subscriptionId)) { <line4> } <line5> return broadcastSubscriptionListenerDirectory.get(subscriptionId); <line6> } <line7> } <line8> 	<line4>
6763	public class A { <line0> private void notifyServerFailed(GrayServer server, boolean notifyToMaster) <line1> throws ServiceException { <line2> try { <line3> dispatchMessageQueue.put(new ServerEvent(EventType.SERVER_FAILED, server.psLoc)); <line4> } catch (Exception e) { <line5> } <line6> if (notifyToMaster) { <line7> PSAgentContext.get().getMasterClient().psFailed(server.psLoc); <line8> } <line9> } <line10> } <line11> 	<line5>
6764	public class A { <line0> private boolean updateTextSections() { <line1> XTextSectionsSupplier supp = UNO.XTextSectionsSupplier(doc); <line2> if (supp == null) { <line3> return false; <line4> } <line5> long startTime = System.currentTimeMillis(); <line6> HashSet<String> knownTextSections = new HashSet<>(); <line7> HashSet<TextSection> invalidTextSections = new HashSet<>(); <line8> for (Iterator<TextSection> iter = allTextSectionsWithGROUPS.iterator(); iter.hasNext(); ) { <line9> TextSection s = iter.next(); <line10> if (s.isInvalid()) invalidTextSections.add(s); <line11> else knownTextSections.add(s.getName()); <line12> } <line13> HashSet<TextSection> newTextSections = new HashSet<>(); <line14> String[] textSectionNames = supp.getTextSections().getElementNames(); <line15> for (int i = 0; i < textSectionNames.length; i++) { <line16> String name = textSectionNames[i]; <line17> Matcher m = sectionWithGROUPSPattern.matcher(name); <line18> if (m.find() && !knownTextSections.contains(name)) { <line19> TextSection s = createTextSection(name, m.group(1), UNO.XTextSectionsSupplier(doc)); <line20> if (s != null) { <line21> newTextSections.add(s); <line22> } <line23> } <line24> } <line25> removeInvalidTextSections(invalidTextSections); <line26> addNewTextSections(newTextSections); <line27> return !invalidTextSections.isEmpty() || !newTextSections.isEmpty(); <line28> } <line29> } <line30> 	<line27>
6765	"public class A { <line0> protected List<Elem> getReleaseChoices(final String keyword) { <line1> try { <line2> final List<Elem> choices = new ArrayList<Elem>(); <line3> getContainer() <line4> .run( <line5> true, <line6> true, <line7> new IRunnableWithProgress() { <line8> @Override <line9> public void run(IProgressMonitor monitor) <line10> throws InvocationTargetException, InterruptedException { <line11> monitor.beginTask(""Fetching latest releases from the Forge"", 55); <line12> try { <line13> final Exception[] te = new Exception[1]; <line14> Thread t = <line15> new Thread() { <line16> @Override <line17> public void run() { <line18> try { <line19> for (Module module : <line20> moduleService.listAll( <line21> new Modules.WithText(keyword), <line22> Modules.LAST_RELEASED, <line23> false)) { <line24> for (AbbrevRelease ab : module.getReleases()) <line25> choices.add(new Elem(ab)); <line26> } <line27> } catch (SocketException e) { <line28> if (!""Socket closed"".equals(e.getMessage())) te[0] = e; <line29> } catch (Exception e) { <line30> te[0] = e; <line31> } <line32> } <line33> }; <line34> t.start(); <line35> int idx = 0; <line36> while (t.isAlive()) { <line37> t.join(1000); <line38> if (monitor.isCanceled()) { <line39> moduleService.abortCurrentRequest(); <line40> throw new OperationCanceledException(); <line41> } <line42> if (++idx <= 5) monitor.worked(1); <line43> } <line44> if (te[0] != null) throw new InvocationTargetException(te[0]); <line45> } catch (RuntimeException e) { <line46> throw e; <line47> } catch (InvocationTargetException e) { <line48> throw e; <line49> } catch (Exception e) { <line50> throw new InvocationTargetException(e); <line51> } finally { <line52> monitor.done(); <line53> } <line54> } <line55> }); <line56> if (!choices.isEmpty()) return choices; <line57> MessageDialog.openConfirm( <line58> getShell(), <line59> getLocalString(""_UI_No_modules_found""), <line60> getLocalString(""_UI_No_module_matching_keyword"", keyword)); <line61> } catch (InvocationTargetException e) { <line62> Throwable t = e.getTargetException(); <line63> StringBuilder builder = new StringBuilder(); <line64> builder.append(t.getClass().getName()); <line65> builder.append(""\n""); <line66> builder.append(t.getMessage()); <line67> builder.append(""\n\n(See the log view for technical details).""); <line68> MessageDialog.openError( <line69> getShell(), ""Error while communicating with the ForgeAPI."", builder.toString()); <line70> } catch (InterruptedException e) { <line71> } <line72> return Collections.emptyList(); <line73> } <line74> } <line75> "	<line70>
6766	"public class A { <line0> public void getTableAttributesInfo() throws ArcgisException { <line1> String fullUrl = serviceUrl.toString(); <line2> String responseJSON = null; <line3> String token = """"; <line4> try { <line5> Map<String, String> params = new LinkedHashMap<String, String>(); <line6> if (getCredential() != null && !"""".equals(getCredential().getToken())) { <line7> token = getCredential().getToken(); <line8> params.put(TOKEN_PARAM, token); <line9> } <line10> params.put(OUTPUT_FORMAT_PARAM, DEFAULT_OUTPUT_FORMAT); <line11> HttpResponse response = httpGet(fullUrl, params); <line12> checkResponse(response); <line13> if (response.isSuccessful()) { <line14> responseJSON = response.getBody(); <line15> getUniqueIdFieldFromJson(responseJSON); <line16> getAttributeInfoFromJson(responseJSON); <line17> getAttributeIndexFromJson(responseJSON); <line18> } else { <line19> String errorMsg = <line20> ""getTableAttributesInfo: Unexpected server response, Error: "" <line21> + response.getErrorCode() <line22> + ""\n"" <line23> + response.getErrorMessage(); <line24> errorMsg += "" \n\t token: "" + token; <line25> throw new ArcgisException(errorMsg); <line26> } <line27> } catch (ArcgisException e) { <line28> throw e; <line29> } catch (Exception e) { <line30> throw new ArcgisException(""getTableAttributesInfo, Unexpected Exception "" + e.toString()); <line31> } <line32> } <line33> } <line34> "	<line1>, <line11>, <line12>, <line15>, <line25>
6767	"public class A { <line0> @PayloadRoot( <line1> localPart = ""SetDeviceVerificationKeyRequest"", <line2> namespace = DEVICE_MANAGEMENT_NAMESPACE) <line3> @ResponsePayload <line4> public SetDeviceVerificationKeyAsyncResponse setDeviceVerificationKey( <line5> @OrganisationIdentification final String organisationIdentification, <line6> @RequestPayload final SetDeviceVerificationKeyRequest request, <line7> @MessagePriority final String messagePriority) <line8> throws OsgpException { <line9> final SetDeviceVerificationKeyAsyncResponse response = <line10> new SetDeviceVerificationKeyAsyncResponse(); <line11> try { <line12> final String correlationUid = <line13> this.deviceManagementService.enqueueSetDeviceVerificationKeyRequest( <line14> organisationIdentification, <line15> request.getDeviceIdentification(), <line16> request.getVerificationKey(), <line17> MessagePriorityEnum.getMessagePriority(messagePriority)); <line18> final AsyncResponse asyncResponse = new AsyncResponse(); <line19> asyncResponse.setCorrelationUid(correlationUid); <line20> asyncResponse.setDeviceId(request.getDeviceIdentification()); <line21> response.setAsyncResponse(asyncResponse); <line22> } catch (final ConstraintViolationException e) { <line23> throw new FunctionalException( <line24> FunctionalExceptionType.VALIDATION_ERROR, <line25> ComponentType.WS_CORE, <line26> new ValidationException(e.getConstraintViolations())); <line27> } catch (final Exception e) { <line28> this.handleException(e); <line29> } <line30> return response; <line31> } <line32> } <line33> "	<line9>
6768	public class A { <line0> protected Scroll buildScroll(BulkCommand command) { <line1> ScrollRequest request; <line2> String query = command.getQuery(); <line3> if (command.useExternalScroller()) { <line4> request = EmptyScrollRequest.of(); <line5> } else if (command.useGenericScroller()) { <line6> request = <line7> GenericScrollRequest.builder(command.getScroller(), query) <line8> .options(command.getParams()) <line9> .size(scrollSize) <line10> .build(); <line11> } else { <line12> request = <line13> DocumentScrollRequest.builder(query) <line14> .username(command.getUsername()) <line15> .repository(command.getRepository()) <line16> .size(scrollSize) <line17> .timeout(Duration.ofSeconds(scrollKeepAliveSeconds)) <line18> .name(command.getScroller()) <line19> .build(); <line20> } <line21> ScrollService service = Framework.getService(ScrollService.class); <line22> return service.scroll(request); <line23> } <line24> } <line25> 	<line3>
6769	public class A { <line0> private void executeImpl() { <line1> boolean purgePoints = SystemSettingsDao.instance.getBooleanValue(ENABLE_POINT_DATA_PURGE); <line2> this.countPointValues = <line3> SystemSettingsDao.instance.getBooleanValue(SystemSettingsDao.POINT_DATA_PURGE_COUNT); <line4> if (purgePoints) { <line5> List<PurgeFilter> purgeFilters = new ArrayList<PurgeFilter>(); <line6> for (PurgeFilterDefinition pfd : ModuleRegistry.getDefinitions(PurgeFilterDefinition.class)) <line7> purgeFilters.add(pfd.getPurgeFilter()); <line8> List<DataPointVO> dataPoints = dataPointDao.getAll(); <line9> for (DataPointVO dataPoint : dataPoints) <line10> purgePoint(dataPoint, countPointValues, purgeFilters); <line11> if (countPointValues) { <line12> deletedSamples += pointValueDao.deleteOrphanedPointValues(); <line13> } else { <line14> pointValueDao.deleteOrphanedPointValuesWithoutCount(); <line15> } <line16> pointValueDao.deleteOrphanedPointValueAnnotations(); <line17> if (countPointValues) { <line18> } else if (anyDeletedSamples) { <line19> } else { <line20> } <line21> } else { <line22> } <line23> filedataPurge(); <line24> eventPurge(); <line25> for (PurgeDefinition def : ModuleRegistry.getDefinitions(PurgeDefinition.class)) <line26> def.execute(runtime); <line27> } <line28> } <line29> 	<line1>, <line18>, <line19>, <line20>, <line22>, <line24>
6770	"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> @Test <line2> public void testSqlSelect() { <line3> OuterJoinOperator oper = new OuterJoinOperator(); <line4> oper.setFullJoin(true); <line5> CollectorTestSink sink = new CollectorTestSink(); <line6> oper.outport.setSink(sink); <line7> Condition cond = new JoinColumnEqualCondition(""a"", ""a""); <line8> oper.setJoinCondition(cond); <line9> oper.selectTable1Column(new ColumnIndex(""b"", null)); <line10> oper.selectTable2Column(new ColumnIndex(""c"", null)); <line11> oper.setup(null); <line12> oper.beginWindow(1); <line13> HashMap<String, Object> tuple = new HashMap<String, Object>(); <line14> tuple.put(""a"", 0); <line15> tuple.put(""b"", 1); <line16> tuple.put(""c"", 2); <line17> oper.inport1.process(tuple); <line18> tuple = new HashMap<String, Object>(); <line19> tuple.put(""a"", 1); <line20> tuple.put(""b"", 3); <line21> tuple.put(""c"", 4); <line22> oper.inport1.process(tuple); <line23> tuple = new HashMap<String, Object>(); <line24> tuple.put(""a"", 2); <line25> tuple.put(""b"", 11); <line26> tuple.put(""c"", 12); <line27> oper.inport1.process(tuple); <line28> tuple = new HashMap<String, Object>(); <line29> tuple.put(""a"", 0); <line30> tuple.put(""b"", 7); <line31> tuple.put(""c"", 8); <line32> oper.inport2.process(tuple); <line33> tuple = new HashMap<String, Object>(); <line34> tuple.put(""a"", 1); <line35> tuple.put(""b"", 5); <line36> tuple.put(""c"", 6); <line37> oper.inport2.process(tuple); <line38> oper.endWindow(); <line39> oper.teardown(); <line40> } <line41> } <line42> "	<line40>
6771	public class A { <line0> private void severeCannotLoad(AbstractResource menubarsLayoutXmlResource, Exception cause) { <line1> } <line2> } <line3> 	<line1>
6772	"public class A { <line0> @Override <line1> protected void addChildUrlFromTagAttribute( <line2> final List<String> urlList, final URL url, final String attrValue, final String encoding) { <line3> final String urlValue = attrValue.trim(); <line4> URL childUrl; <line5> String u = null; <line6> try { <line7> childUrl = new URL(url, urlValue.startsWith("":"") ? url.getProtocol() + urlValue : urlValue); <line8> u = encodeUrl(normalizeUrl(childUrl.toExternalForm()), encoding); <line9> } catch (final MalformedURLException e) { <line10> final int pos = urlValue.indexOf(':'); <line11> if (pos > 0 && pos < 10) { <line12> u = encodeUrl(normalizeUrl(urlValue), encoding); <line13> } <line14> } <line15> if (u == null) { <line16> return; <line17> } <line18> if (logger.isDebugEnabled()) { <line19> } <line20> if (StringUtil.isNotBlank(u)) { <line21> if (logger.isDebugEnabled()) { <line22> } <line23> urlList.add(u); <line24> } else if (logger.isDebugEnabled()) { <line25> } <line26> } <line27> } <line28> "	<line16>, <line19>, <line22>, <line25>
6773	public class A { <line0> public String decrypt(String password, String keyString) { <line1> try { <line2> byte[] keySrcBytes = encodeUTF8(keyString); <line3> byte[] newKey1 = Base64.decodeBase64(keySrcBytes); <line4> Key newKey2 = toKey(newKey1); <line5> byte[] srcBytes = encodeUTF8(password); <line6> byte[] desBytes = decrypt(Base64.decodeBase64(srcBytes), newKey2); <line7> String tempdecodeUTF8 = decodeUTF8(desBytes); <line8> if (tempdecodeUTF8.substring(0, appendString.length()).equals(appendString)) { <line9> return tempdecodeUTF8.substring(appendString.length(), tempdecodeUTF8.length()); <line10> } <line11> return password; <line12> } catch (Exception e) { <line13> return password; <line14> } <line15> } <line16> } <line17> 	<line13>
6774	public class A { <line0> private static boolean _exists(long groupId, long userId, String curFileName) { <line1> try { <line2> FileEntry fileEntry = <line3> TempFileEntryUtil.getTempFileEntry(groupId, userId, _TEMP_FILE_NAME, curFileName); <line4> if (fileEntry != null) { <line5> return true; <line6> } <line7> return false; <line8> } catch (PortalException portalException) { <line9> if (_log.isDebugEnabled()) { <line10> } <line11> return false; <line12> } <line13> } <line14> } <line15> 	<line10>
6775	public class A { <line0> @Override <line1> public void sendCeaMessage(int resultCode, Message cer, String errMessage) <line2> throws TransportException, OverloadException { <line3> IMessage message = parser.createEmptyMessage(Message.CAPABILITIES_EXCHANGE_ANSWER, 0); <line4> message.setRequest(false); <line5> message.setHopByHopIdentifier(cer.getHopByHopIdentifier()); <line6> message.setEndToEndIdentifier(cer.getEndToEndIdentifier()); <line7> message <line8> .getAvps() <line9> .addAvp(Avp.ORIGIN_HOST, metaData.getLocalPeer().getUri().getFQDN(), true, false, true); <line10> message <line11> .getAvps() <line12> .addAvp(Avp.ORIGIN_REALM, metaData.getLocalPeer().getRealmName(), true, false, true); <line13> for (InetAddress ia : metaData.getLocalPeer().getIPAddresses()) { <line14> message.getAvps().addAvp(Avp.HOST_IP_ADDRESS, ia, true, false); <line15> } <line16> message <line17> .getAvps() <line18> .addAvp(Avp.VENDOR_ID, metaData.getLocalPeer().getVendorId(), true, false, true); <line19> for (ApplicationId appId : metaData.getLocalPeer().getCommonApplications()) { <line20> addAppId(appId, message); <line21> } <line22> message.getAvps().addAvp(Avp.PRODUCT_NAME, metaData.getLocalPeer().getProductName(), false); <line23> message.getAvps().addAvp(Avp.RESULT_CODE, resultCode, true, false, true); <line24> message.getAvps().addAvp(Avp.FIRMWARE_REVISION, metaData.getLocalPeer().getFirmware(), true); <line25> if (errMessage != null) { <line26> message.getAvps().addAvp(Avp.ERROR_MESSAGE, errMessage, false); <line27> } <line28> sendMessage(message); <line29> } <line30> } <line31> 	<line3>
6776	public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler(); <line3> if (velbusBridgeHandler == null) { <line4> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); <line5> return; <line6> } <line7> if (command instanceof RefreshType) { <line8> VelbusStatusRequestPacket packet = <line9> new VelbusStatusRequestPacket(getModuleAddress().getChannelIdentifier(channelUID)); <line10> byte[] packetBytes = packet.getBytes(); <line11> velbusBridgeHandler.sendPacket(packetBytes); <line12> } else if (command instanceof UpDownType) { <line13> UpDownType s = (UpDownType) command; <line14> if (s == UpDownType.UP) { <line15> byte commandByte = COMMAND_BLIND_UP; <line16> VelbusBlindUpDownPacket packet = <line17> new VelbusBlindUpDownPacket( <line18> getModuleAddress().getChannelIdentifier(channelUID), commandByte); <line19> byte[] packetBytes = packet.getBytes(); <line20> velbusBridgeHandler.sendPacket(packetBytes); <line21> } else { <line22> byte commandByte = COMMAND_BLIND_DOWN; <line23> VelbusBlindUpDownPacket packet = <line24> new VelbusBlindUpDownPacket( <line25> getModuleAddress().getChannelIdentifier(channelUID), commandByte); <line26> byte[] packetBytes = packet.getBytes(); <line27> velbusBridgeHandler.sendPacket(packetBytes); <line28> } <line29> } else if (command instanceof StopMoveType) { <line30> StopMoveType s = (StopMoveType) command; <line31> if (s == StopMoveType.STOP) { <line32> VelbusBlindOffPacket packet = <line33> new VelbusBlindOffPacket(getModuleAddress().getChannelIdentifier(channelUID)); <line34> byte[] packetBytes = packet.getBytes(); <line35> velbusBridgeHandler.sendPacket(packetBytes); <line36> } <line37> } else if (command instanceof PercentType) { <line38> VelbusBlindPositionPacket packet = <line39> new VelbusBlindPositionPacket( <line40> getModuleAddress().getChannelIdentifier(channelUID), <line41> ((PercentType) command).byteValue()); <line42> byte[] packetBytes = packet.getBytes(); <line43> velbusBridgeHandler.sendPacket(packetBytes); <line44> } else { <line45> } <line46> } <line47> } <line48> 	<line45>
6777	public class A { <line0> @ParamName(LegacyResourceConstants.HOMEPAGE_URL_PARAM) <line1> public void setDatasetHomepageUrl(String homepageUrl) { <line2> if (!Strings.isNullOrEmpty(homepageUrl)) { <line3> try { <line4> URI uri = new URI(homepageUrl); <line5> setHomepage(uri); <line6> } catch (URISyntaxException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6778	"public class A { <line0> private JButton getJButtonDelete() { <line1> if (jButtonDelete == null) { <line2> jButtonDelete = new JButton(MessageBundle.getMessage(""angal.common.delete.btn"")); <line3> jButtonDelete.setMnemonic(MessageBundle.getMnemonic(""angal.common.delete.btn.key"")); <line4> jButtonDelete.addActionListener( <line5> new ActionListener() { <line6> @Override <line7> public void actionPerformed(ActionEvent e) { <line8> int[] row = jTableSummary.getSelectedRows(); <line9> if (row.length == 0) { <line10> return; <line11> } <line12> int ok = <line13> JOptionPane.showConfirmDialog( <line14> PatientExaminationEdit.this, <line15> MessageBundle.getMessage(""angal.common.doyouwanttoproceed"")); <line16> if (ok == JOptionPane.OK_OPTION) { <line17> ArrayList<PatientExamination> patexList = new ArrayList<>(); <line18> for (int i = 0; i < row.length; i++) { <line19> patexList.add( <line20> (PatientExamination) jTableSummary.getModel().getValueAt(row[i], -1)); <line21> } <line22> try { <line23> examManager.remove(patexList); <line24> } catch (OHServiceException ohServiceException) { <line25> MessageDialog.showExceptions(ohServiceException); <line26> } finally { <line27> JTableModelSummary model = (JTableModelSummary) jTableSummary.getModel(); <line28> model.reloadData(); <line29> } <line30> } <line31> } <line32> }); <line33> } <line34> return jButtonDelete; <line35> } <line36> } <line37> "	<line10>
6779	"public class A { <line0> public static String getKBArticleRSS( <line1> HttpPrincipal httpPrincipal, <line2> long resourcePrimKey, <line3> int status, <line4> int rssDelta, <line5> String rssDisplayStyle, <line6> String rssFormat, <line7> com.liferay.portal.kernel.theme.ThemeDisplay themeDisplay) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey( <line12> KBArticleServiceUtil.class, ""getKBArticleRSS"", _getKBArticleRSSParameterTypes17); <line13> MethodHandler methodHandler = <line14> new MethodHandler( <line15> methodKey, <line16> resourcePrimKey, <line17> status, <line18> rssDelta, <line19> rssDisplayStyle, <line20> rssFormat, <line21> themeDisplay); <line22> Object returnObj = null; <line23> try { <line24> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line25> } catch (Exception exception) { <line26> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line27> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line28> } <line29> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line30> } <line31> return (String) returnObj; <line32> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line33> throw systemException; <line34> } <line35> } <line36> } <line37> "	<line33>
6780	"public class A { <line0> public static void basicWriteObject(Object o, DataOutput out, boolean ensurePdxCompatibility) <line1> throws IOException { <line2> checkOut(out); <line3> final boolean isDebugEnabled_SERIALIZER = logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE); <line4> if (isDebugEnabled_SERIALIZER) { <line5> } <line6> if (o == null) { <line7> out.writeByte(DSCODE.NULL.toByte()); <line8> } else if (o instanceof BasicSerializable) { <line9> checkPdxCompatible(o, ensurePdxCompatibility); <line10> BasicSerializable bs = (BasicSerializable) o; <line11> dsfidSerializer.write(bs, out); <line12> } else if (autoSerialized(o, out)) { <line13> } else if (o instanceof DataSerializable.Replaceable) { <line14> Object replacement = ((DataSerializable.Replaceable) o).replace(); <line15> basicWriteObject(replacement, out, ensurePdxCompatibility); <line16> } else if (o instanceof PdxSerializable) { <line17> writePdx( <line18> out, <line19> GemFireCacheImpl.getForPdx( <line20> ""PDX registry is unavailable because the Cache has been closed.""), <line21> o, <line22> null); <line23> } else if (o instanceof DataSerializable) { <line24> if (isDebugEnabled_SERIALIZER) { <line25> } <line26> checkPdxCompatible(o, ensurePdxCompatibility); <line27> Class c = o.getClass(); <line28> int classId = InternalInstantiator.getClassId(c); <line29> if (classId != 0) { <line30> writeUserDataSerializableHeader(classId, out); <line31> } else { <line32> out.writeByte(DSCODE.DATA_SERIALIZABLE.toByte()); <line33> DataSerializer.writeClass(c, out); <line34> } <line35> invokeToData(o, out); <line36> } else if (o instanceof Sendable) { <line37> if (!(o instanceof PdxInstance) || o instanceof PdxInstanceEnum) { <line38> checkPdxCompatible(o, ensurePdxCompatibility); <line39> } <line40> ((Sendable) o).sendTo(out); <line41> } else if (writeWellKnownObject(o, out, ensurePdxCompatibility)) { <line42> } else { <line43> checkPdxCompatible(o, ensurePdxCompatibility); <line44> if (logger.isTraceEnabled(LogMarker.SERIALIZER_ANNOUNCE_TYPE_WRITTEN_VERBOSE)) { <line45> } <line46> if (disallowJavaSerialization() && o instanceof Serializable) { <line47> throw new NotSerializableException( <line48> String.format( <line49> ""%s is not DataSerializable and Java Serialization is disallowed"", <line50> o.getClass().getName())); <line51> } <line52> writeSerializableObject(o, out); <line53> } <line54> } <line55> } <line56> "	<line5>, <line25>, <line45>
6781	"public class A { <line0> @Test <line1> void createConsumerNameIsNotSetAndBridgeIdNotSet(VertxTestContext context) <line2> throws InterruptedException, ExecutionException, TimeoutException { <line3> JsonObject json = new JsonObject(); <line4> CompletableFuture<Boolean> create = new CompletableFuture<>(); <line5> consumerService() <line6> .createConsumerRequest(groupId, json) <line7> .as(BodyCodec.jsonObject()) <line8> .sendJsonObject( <line9> json, <line10> ar -> { <line11> context.verify( <line12> () -> { <line13> assertThat(ar.succeeded(), is(true)); <line14> HttpResponse<JsonObject> response = ar.result(); <line15> assertThat(response.statusCode(), is(HttpResponseStatus.OK.code())); <line16> JsonObject bridgeResponse = response.body(); <line17> consumerInstanceId = bridgeResponse.getString(""instance_id""); <line18> assertThat(consumerInstanceId.startsWith(""kafka-bridge-consumer-""), is(true)); <line19> create.complete(true); <line20> }); <line21> }); <line22> create.get(TEST_TIMEOUT, TimeUnit.SECONDS); <line23> consumerService().deleteConsumer(context, groupId, consumerInstanceId); <line24> context.completeNow(); <line25> } <line26> } <line27> "	<line13>, <line15>, <line18>
6782	"public class A { <line0> private void assertCondition( <line1> InvocationContext rCtx, VisitableCommand rCommand, Object rv, Throwable throwable) <line2> throws Throwable { <line3> boolean succeeded = throwable == null && rCommand.isSuccessful(); <line4> log.tracef(""After command(successful=%s) %s"", succeeded, rCommand); <line5> List<Runnable> toExecute = new ArrayList<>(); <line6> synchronized (ExpectingInterceptor.this) { <line7> for (Iterator<Condition> iterator = conditions.iterator(); iterator.hasNext(); ) { <line8> Condition condition = iterator.next(); <line9> log.tracef(""Testing condition %s"", condition); <line10> if ((condition.success == null || condition.success == succeeded) <line11> && condition.predicate.test(rCtx, rCommand)) { <line12> assert condition.action != null; <line13> toExecute.add(condition.action); <line14> if (condition.removeCheck == null || condition.removeCheck.getAsBoolean()) { <line15> iterator.remove(); <line16> } <line17> } else { <line18> } <line19> } <line20> } <line21> for (Runnable runnable : toExecute) { <line22> log.tracef(""Executing %s"", runnable); <line23> runnable.run(); <line24> } <line25> } <line26> } <line27> "	<line13>, <line18>
6783	public class A { <line0> public static <T> T fromJson(String json, Class<T> clazz) { <line1> T output = null; <line2> try { <line3> output = mapper.readValue(json, clazz); <line4> } catch (Exception e) { <line5> } <line6> return output; <line7> } <line8> } <line9> 	<line5>
6784	"public class A { <line0> private ConfiguredNotificationService createService(final Element serviceElement) { <line1> final Element idElement = getChild(serviceElement, ""id""); <line2> if (idElement == null) { <line3> return null; <line4> } <line5> final String serviceId = idElement.getTextContent().trim(); <line6> final Element classElement = getChild(serviceElement, ""class""); <line7> if (classElement == null) { <line8> return null; <line9> } <line10> final String className = classElement.getTextContent().trim(); <line11> final Class<?> clazz; <line12> try { <line13> clazz = Class.forName(className); <line14> } catch (final Exception e) { <line15> logger.error("""", e); <line16> return null; <line17> } <line18> if (!NotificationService.class.isAssignableFrom(clazz)) { <line19> return null; <line20> } <line21> final Object serviceObject; <line22> try { <line23> serviceObject = clazz.newInstance(); <line24> } catch (final Exception e) { <line25> logger.error("""", e); <line26> return null; <line27> } <line28> final Map<String, String> propertyValues = new HashMap<>(); <line29> final List<Element> propertyElements = getChildElementsByTagName(serviceElement, ""property""); <line30> for (final Element propertyElement : propertyElements) { <line31> final String propName = propertyElement.getAttribute(""name""); <line32> if (propName == null || propName.trim().isEmpty()) { <line33> continue; <line34> } <line35> final String propValue = propertyElement.getTextContent().trim(); <line36> propertyValues.put(propName, propValue); <line37> } <line38> final NotificationService service = (NotificationService) serviceObject; <line39> try { <line40> service.initialize( <line41> new NotificationInitializationContext() { <line42> @Override <line43> public PropertyValue getProperty(final PropertyDescriptor descriptor) { <line44> final String propName = descriptor.getName(); <line45> String value = propertyValues.get(propName); <line46> if (value == null) { <line47> value = descriptor.getDefaultValue(); <line48> } <line49> final ResourceContext resourceContext = <line50> new StandardResourceContext(new StandardResourceReferenceFactory(), descriptor); <line51> return new StandardPropertyValue( <line52> resourceContext, value, null, ParameterLookup.EMPTY, variableRegistry); <line53> } <line54>  <line55> @Override <line56> public Map<String, String> getAllProperties() { <line57> return Collections.unmodifiableMap(propertyValues); <line58> } <line59>  <line60> @Override <line61> public String getIdentifier() { <line62> return serviceId; <line63> } <line64> }); <line65> } catch (final Exception e) { <line66> } <line67> return new ConfiguredNotificationService(service, propertyValues); <line68> } <line69> } <line70> "	<line3>, <line6>, <line8>, <line15>, <line19>, <line25>, <line33>, <line66>
6785	"public class A { <line0> TenantResult<JsonObject> getTenantObjectResult(final String tenantId, final Span span) { <line1> final Versioned<Tenant> tenant = tenants.get(tenantId); <line2> if (tenant == null) { <line3> TracingHelper.logError(span, ""tenant not found""); <line4> return TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND); <line5> } else { <line6> return TenantResult.from( <line7> HttpURLConnection.HTTP_OK, <line8> DeviceRegistryUtils.convertTenant(tenantId, tenant.getValue(), true), <line9> DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())); <line10> } <line11> } <line12> } <line13> "	<line1>
6786	public class A { <line0> protected List<String> getPoolNamesForHost(String host) { <line1> String test = host; <line2> if (!hrtlbConf.derive().isIpBasedRegex) { <line3> try { <line4> test = getNameFromIp(host); <line5> } catch (UnknownHostException e1) { <line6> return Collections.singletonList(DEFAULT_POOL); <line7> } <line8> } <line9> List<String> pools = new ArrayList<>(); <line10> for (Entry<String, Pattern> e : hrtlbConf.derive().poolNameToRegexPattern.entrySet()) { <line11> if (e.getValue().matcher(test).matches()) { <line12> pools.add(e.getKey()); <line13> } <line14> } <line15> if (pools.isEmpty()) { <line16> pools.add(DEFAULT_POOL); <line17> } <line18> return pools; <line19> } <line20> } <line21> 	<line6>
6787	"public class A { <line0> public int queueCommand(String command, String params, String cloudServer) <line1> throws MiIoCryptoException, IOException, JsonSyntaxException { <line2> try { <line3> JsonObject fullCommand = new JsonObject(); <line4> int cmdId = id.incrementAndGet(); <line5> if (cmdId > MAX_ID) { <line6> id.set(0); <line7> } <line8> fullCommand.addProperty(""id"", cmdId); <line9> fullCommand.addProperty(""method"", command); <line10> fullCommand.add(""params"", JsonParser.parseString(params)); <line11> MiIoSendCommand sendCmd = <line12> new MiIoSendCommand(cmdId, MiIoCommand.getCommand(command), fullCommand, cloudServer); <line13> concurrentLinkedQueue.add(sendCmd); <line14> if (logger.isDebugEnabled()) { <line15> String tokenText = Utils.obfuscateToken(Utils.getHex(token)); <line16> } <line17> if (needPing && cloudServer.isBlank()) { <line18> sendPing(ip); <line19> } <line20> return cmdId; <line21> } catch (JsonSyntaxException e) { <line22> throw e; <line23> } <line24> } <line25> } <line26> "	<line16>, <line22>
6788	"public class A { <line0> @Transactional <line1> public FileDTO generatePackageFile( <line2> ExperimentPackage pckg, <line3> MetadataCommand mc, <line4> License license, <line5> List<Experiment> selectList, <line6> Person loggedUser, <line7> DownloadPackageManager manager) { <line8> ZipOutputStream zipOutputStream = null; <line9> FileOutputStream fileOutputStream = null; <line10> File tempZipFile = null; <line11> ZipInputStream in = null; <line12> File file = null; <line13> try { <line14> FileDTO dto = new FileDTO(); <line15> dto.setFileName(pckg.getName().replaceAll(""\\s"", ""_"") + "".zip""); <line16> tempZipFile = File.createTempFile(""experimentDownload_"", "".zip""); <line17> fileOutputStream = new FileOutputStream(tempZipFile); <line18> zipOutputStream = new ZipOutputStream(fileOutputStream); <line19> for (Experiment tmp : selectList) { <line20> Experiment exp = service.getExperimentForDetail(tmp.getExperimentId()); <line21> String experimentDirPrefix = """"; <line22> String scenarioName = exp.getScenario().getTitle(); <line23> if (scenarioName != null) { <line24> experimentDirPrefix = <line25> ""Experiment_"" <line26> + exp.getExperimentId() <line27> + ""_"" <line28> + scenarioName.replaceAll(""\\s"", ""_"") <line29> + ""/""; <line30> } else experimentDirPrefix = ""Experiment_data_"" + exp.getExperimentId() + ""/""; <line31> byte[] licenseFile = licenseService.getLicenseAttachmentContent(license.getLicenseId()); <line32> file = <line33> zipGenerator.generate( <line34> exp, mc, exp.getDataFiles(), licenseFile, license.getAttachmentFileName()); <line35> in = new ZipInputStream(new FileInputStream(file)); <line36> ZipEntry entryIn = null; <line37> while ((entryIn = in.getNextEntry()) != null) { <line38> zipOutputStream.putNextEntry(new ZipEntry(experimentDirPrefix + entryIn.getName())); <line39> IOUtils.copyLarge(in, zipOutputStream); <line40> zipOutputStream.closeEntry(); <line41> } <line42> FileUtils.deleteOnExitQuietly(file); <line43> IOUtils.closeQuietly(in); <line44> FileUtils.deleteQuietly(file); <line45> createHistoryRecordAboutDownload(exp, loggedUser); <line46> synchronized (this) { <line47> manager.setNumberOfDownloadedExperiments(manager.getNumberOfDownloadedExperiments() + 1); <line48> } <line49> } <line50> dto.setFile(tempZipFile); <line51> FileUtils.deleteOnExitQuietly(tempZipFile); <line52> IOUtils.closeQuietly(zipOutputStream); <line53> IOUtils.closeQuietly(fileOutputStream); <line54> return dto; <line55> } catch (Exception e) { <line56> IOUtils.closeQuietly(zipOutputStream); <line57> IOUtils.closeQuietly(fileOutputStream); <line58> FileUtils.deleteOnExitQuietly(tempZipFile); <line59> FileUtils.deleteOnExitQuietly(file); <line60> FileUtils.deleteQuietly(tempZipFile); <line61> FileUtils.deleteQuietly(file); <line62> return null; <line63> } <line64> } <line65> } <line66> "	<line56>
6789	"public class A { <line0> @Test <line1> public void testSaveGridSet() throws Exception { <line2> String name = ""testGrid""; <line3> SRS srs = SRS.getEPSG4326(); <line4> BoundingBox extent = new BoundingBox(-1, -1, 1, 1); <line5> boolean alignTopLeft = true; <line6> double[] resolutions = {3, 2, 1}; <line7> double[] scaleDenoms = null; <line8> Double metersPerUnit = 1.5; <line9> double pixelSize = 2 * GridSetFactory.DEFAULT_PIXEL_SIZE_METER; <line10> String[] scaleNames = {""uno"", ""dos"", ""tres""}; <line11> int tileWidth = 128; <line12> int tileHeight = 512; <line13> boolean yCoordinateFirst = true; <line14> GridSet gridSet = <line15> GridSetFactory.createGridSet( <line16> name, <line17> srs, <line18> extent, <line19> alignTopLeft, <line20> resolutions, <line21> scaleDenoms, <line22> metersPerUnit, <line23> pixelSize, <line24> scaleNames, <line25> tileWidth, <line26> tileHeight, <line27> yCoordinateFirst); <line28> gridSet.setDescription(""test description""); <line29> config.addGridSet(gridSet); <line30> try { <line31> XMLConfiguration.validate(XMLConfiguration.loadDocument(new FileInputStream(configFile))); <line32> } catch (SAXParseException e) { <line33> fail(e.getMessage()); <line34> } <line35> XMLConfiguration config2 = new XMLConfiguration(null, configDir.getAbsolutePath()); <line36> GridSetBroker gridSetBroker2 = <line37> new GridSetBroker(Arrays.asList(new DefaultGridsets(true, true), config2)); <line38> config2.setGridSetBroker(gridSetBroker2); <line39> config2.afterPropertiesSet(); <line40> config2.getLayerCount(); <line41> GridSet gridSet2 = gridSetBroker2.get(name); <line42> assertNotNull(gridSet2); <line43> assertEquals(gridSet, gridSet2); <line44> } <line45> } <line46> "	<line33>
6790	"public class A { <line0> @GET <line1> public Object getCountries(@QueryParam(""fields"") String fields) { <line2> List<Country> countries = CountryService.getInstance().getAll(); <line3> return parsedCountries(countries, fields); <line4> } <line5> } <line6> "	<line2>
6791	public class A { <line0> @Override <line1> public void run(FlowTrigger trigger, Map data) { <line2> VmInstanceSpec spec = <line3> (VmInstanceSpec) data.get(VmInstanceConstant.Params.VmInstanceSpec.toString()); <line4> changeVmStateInDb( <line5> struct.getStrategy() == VmCreationStrategy.InstantStart <line6> ? VmInstanceStateEvent.running <line7> : VmInstanceStateEvent.paused, <line8> () -> { <line9> self.setLastHostUuid(spec.getDestHost().getUuid()); <line10> self.setHostUuid(spec.getDestHost().getUuid()); <line11> self.setClusterUuid(spec.getDestHost().getClusterUuid()); <line12> self.setZoneUuid(spec.getDestHost().getZoneUuid()); <line13> self.setHypervisorType(spec.getDestHost().getHypervisorType()); <line14> self.setRootVolumeUuid(spec.getDestRootVolume().getUuid()); <line15> }); <line16> VmInstanceInventory inv = VmInstanceInventory.valueOf(self); <line17> extEmitter.afterStartNewCreatedVm(inv); <line18> trigger.next(); <line19> } <line20> } <line21> 	<line16>
6792	"public class A { <line0> @Test( <line1> groups = {""Phase 1 Stop""}, <line2> description = ""empty column stop_id"", <line3> priority = 46) <line4> public void verifyTest_2_3_1() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""stop_3_1"", GTFS_1_GTFS_Common_12, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""stops.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(5), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	<line5>
6793	public class A { <line0> private static void validateResult(String input, String origInput) { <line1> if (input.length() == 0) { <line2> } <line3> } <line4> } <line5> 	<line2>
6794	"public class A { <line0> public static <T> T createPojo(Document doc, Class<T> clazz) { <line1> try { <line2> final String typeVal = getType(clazz); <line3> if (!StringUtils.equals(typeVal, doc.getType())) { <line4> throw new IllegalArgumentException( <line5> ""@Type does not match. Expected "" + typeVal + "" but found "" + doc.getType()); <line6> } <line7> final Map<String, Field> fieldMap = new HashMap<>(); <line8> for (Field field : getFields(clazz)) { <line9> final FieldDescriptor fd = createFieldDescriptor(field); <line10> if (fd == null || ComplexFieldDescriptor.class.isAssignableFrom(fd.getClass())) { <line11> continue; <line12> } <line13> fieldMap.put(fd.getName(), field); <line14> } <line15> final Field idField = getIdField(clazz); <line16> final Field scoreField = getScoreField(clazz); <line17> final T instance; <line18> try { <line19> instance = clazz.newInstance(); <line20> } catch (InstantiationException e) { <line21> throw new RuntimeException(""Unable to instantiate class "" + clazz.getSimpleName(), e); <line22> } <line23> idField.set(instance, doc.getId()); <line24> if (scoreField != null) { <line25> scoreField.set(instance, doc.getScore()); <line26> } <line27> for (String fName : fieldMap.keySet()) { <line28> final Field f = fieldMap.get(fName); <line29> f.setAccessible(true); <line30> final Object value = doc.getValue(fName); <line31> if (value instanceof Collection && Collection.class.isAssignableFrom(f.getType())) { <line32> Collection c; <line33> if (Modifier.isAbstract(f.getType().getModifiers())) { <line34> throw new IllegalArgumentException( <line35> ""Annotated field "" + f.getName() + "" can not be abstract""); <line36> } else { <line37> try { <line38> c = (Collection) f.getType().newInstance(); <line39> } catch (InstantiationException e) { <line40> throw new RuntimeException( <line41> ""Unable to instantiate collection field "" <line42> + f.getName() <line43> + "" of type ["" <line44> + f.getType() <line45> + ""]"", <line46> e); <line47> } <line48> } <line49> c.addAll((Collection) value); <line50> f.set(instance, c); <line51> } else { <line52> f.set(instance, value); <line53> } <line54> } <line55> return instance; <line56> } catch (IllegalAccessException e) { <line57> throw new RuntimeException(""Unable to access pojo field"", e); <line58> } <line59> } <line60> } <line61> "	<line4>, <line21>, <line34>, <line40>, <line57>
6795	public class A { <line0> @Override <line1> public Resource getResource() { <line2> final String path = _pathTextField.getText(); <line3> try { <line4> return _resourceTypeHandler.parsePath(path); <line5> } catch (final Exception e) { <line6> return null; <line7> } <line8> } <line9> } <line10> 	<line6>
6796	public class A { <line0> private void handleBrightness(Command command) throws IOException, CommandUnsuccessfulException { <line1> if (command instanceof PercentType) { <line2> PercentType percent = (PercentType) command; <line3> Transform transform = new Transform(); <line4> transform.setLuminanceGain(percent.doubleValue() / 100); <line5> TransformCommand transformCommand = new TransformCommand(transform); <line6> sendCommand(transformCommand); <line7> } else { <line8> } <line9> } <line10> } <line11> 	<line8>
6797	public class A { <line0> @Override <line1> public void stop() { <line2> try { <line3> for (Transport transport : transports) { <line4> if (!(transport instanceof TcpTransport)) { <line5> continue; <line6> } <line7> List<WriteFuture> writeFutures = new ArrayList<>(); <line8> List<IoSession> sessions; <line9> try { <line10> sessions = new ArrayList<>(getSocketAcceptor(transport).getManagedSessions().values()); <line11> } catch (IllegalArgumentException e) { <line12> return; <line13> } <line14> getSocketAcceptor(transport).dispose(); <line15> if (LOG.isInfoEnabled()) { <line16> } <line17> if (sessions != null) { <line18> for (IoSession session : sessions) { <line19> writeFutures.add(session.write(NoticeOfDisconnect.UNAVAILABLE)); <line20> } <line21> } <line22> Iterator<IoSession> sessionIt = sessions.iterator(); <line23> for (WriteFuture future : writeFutures) { <line24> future.await(1000L); <line25> sessionIt.next().closeNow(); <line26> } <line27> if (replicationReqHandler != null) { <line28> replicationReqHandler.stop(); <line29> } <line30> } <line31> stopConsumers(); <line32> } catch (Exception e) { <line33> } <line34> started = false; <line35> } <line36> } <line37> 	<line12>, <line16>, <line33>, <line35>
6798	public class A { <line0> @Override <line1> public boolean acquire(String tableName) { <line2> if (isQueryRateLimitDisabled()) { <line3> return true; <line4> } <line5> String offlineTableName = null; <line6> String realtimeTableName = null; <line7> QueryQuotaEntity offlineTableQueryQuotaEntity = null; <line8> QueryQuotaEntity realtimeTableQueryQuotaEntity = null; <line9> TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableName); <line10> if (tableType == TableType.OFFLINE) { <line11> offlineTableName = tableName; <line12> offlineTableQueryQuotaEntity = _rateLimiterMap.get(tableName); <line13> } else if (tableType == TableType.REALTIME) { <line14> realtimeTableName = tableName; <line15> realtimeTableQueryQuotaEntity = _rateLimiterMap.get(tableName); <line16> } else { <line17> offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(tableName); <line18> realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(tableName); <line19> offlineTableQueryQuotaEntity = _rateLimiterMap.get(offlineTableName); <line20> realtimeTableQueryQuotaEntity = _rateLimiterMap.get(realtimeTableName); <line21> } <line22> boolean offlineQuotaOk = <line23> offlineTableQueryQuotaEntity == null <line24> || tryAcquireToken(offlineTableName, offlineTableQueryQuotaEntity); <line25> boolean realtimeQuotaOk = <line26> realtimeTableQueryQuotaEntity == null <line27> || tryAcquireToken(realtimeTableName, realtimeTableQueryQuotaEntity); <line28> return offlineQuotaOk && realtimeQuotaOk; <line29> } <line30> } <line31> 	<line5>
6799	"public class A { <line0> @Override <line1> public KBFolder fetchByG_P_UT( <line2> long groupId, long parentKBFolderId, String urlTitle, boolean useFinderCache) { <line3> urlTitle = Objects.toString(urlTitle, """"); <line4> Object[] finderArgs = null; <line5> if (useFinderCache) { <line6> finderArgs = new Object[] {groupId, parentKBFolderId, urlTitle}; <line7> } <line8> Object result = null; <line9> if (useFinderCache) { <line10> result = finderCache.getResult(_finderPathFetchByG_P_UT, finderArgs); <line11> } <line12> if (result instanceof KBFolder) { <line13> KBFolder kbFolder = (KBFolder) result; <line14> if ((groupId != kbFolder.getGroupId()) <line15> || (parentKBFolderId != kbFolder.getParentKBFolderId()) <line16> || !Objects.equals(urlTitle, kbFolder.getUrlTitle())) { <line17> result = null; <line18> } <line19> } <line20> if (result == null) { <line21> StringBundler sb = new StringBundler(5); <line22> sb.append(_SQL_SELECT_KBFOLDER_WHERE); <line23> sb.append(_FINDER_COLUMN_G_P_UT_GROUPID_2); <line24> sb.append(_FINDER_COLUMN_G_P_UT_PARENTKBFOLDERID_2); <line25> boolean bindUrlTitle = false; <line26> if (urlTitle.isEmpty()) { <line27> sb.append(_FINDER_COLUMN_G_P_UT_URLTITLE_3); <line28> } else { <line29> bindUrlTitle = true; <line30> sb.append(_FINDER_COLUMN_G_P_UT_URLTITLE_2); <line31> } <line32> String sql = sb.toString(); <line33> Session session = null; <line34> try { <line35> session = openSession(); <line36> Query query = session.createQuery(sql); <line37> QueryPos queryPos = QueryPos.getInstance(query); <line38> queryPos.add(groupId); <line39> queryPos.add(parentKBFolderId); <line40> if (bindUrlTitle) { <line41> queryPos.add(urlTitle); <line42> } <line43> List<KBFolder> list = query.list(); <line44> if (list.isEmpty()) { <line45> if (useFinderCache) { <line46> finderCache.putResult(_finderPathFetchByG_P_UT, finderArgs, list); <line47> } <line48> } else { <line49> if (list.size() > 1) { <line50> Collections.sort(list, Collections.reverseOrder()); <line51> if (_log.isWarnEnabled()) { <line52> if (!useFinderCache) { <line53> finderArgs = new Object[] {groupId, parentKBFolderId, urlTitle}; <line54> } <line55> } <line56> } <line57> KBFolder kbFolder = list.get(0); <line58> result = kbFolder; <line59> cacheResult(kbFolder); <line60> } <line61> } catch (Exception exception) { <line62> throw processException(exception); <line63> } finally { <line64> closeSession(session); <line65> } <line66> } <line67> if (result instanceof List<?>) { <line68> return null; <line69> } else { <line70> return (KBFolder) result; <line71> } <line72> } <line73> } <line74> "	<line55>
6800	public class A { <line0> @Override <line1> public void onMessage(final Message message) { <line2> try { <line3> if (message instanceof ObjectMessage) { <line4> ObjectMessage objectMessage = (ObjectMessage) message; <line5> UserActionRequest userActionRequest = (UserActionRequest) objectMessage.getObject(); <line6> taskHandler.handleTask(userActionRequest); <line7> } else { <line8> } <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> 	<line4>, <line6>, <line8>, <line10>
6801	public class A { <line0> public static void debug(String strLogger, Object objToLog) { <line1> Logger logger = Logger.getLogger(strLogger); <line2> if (logger.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>
6802	"public class A { <line0> @Override <line1> public void clear(Properties properties) { <line2> Map<String, Object> settings = parseDatasourceProperties(properties); <line3> Connection conn = null; <line4> Statement stmt = null; <line5> try { <line6> conn = openConnection(settings); <line7> List<String> names = getQuotedSchemaTableNames(settings, conn); <line8> if (!names.isEmpty()) { <line9> List<String> list = Lists.newArrayList(); <line10> list.add(""SET FOREIGN_KEY_CHECKS=0;""); <line11> for (String name : names) { <line12> list.add(String.format(""truncate %s;"", name)); <line13> } <line14> list.add(""SET FOREIGN_KEY_CHECKS=1;""); <line15> stmt = conn.createStatement(); <line16> for (String sql : list) { <line17> stmt.execute(sql); <line18> } <line19> } <line20> } catch (SQLException ex) { <line21> throw new ConfigurationError(ex); <line22> } finally { <line23> close(stmt); <line24> close(conn); <line25> } <line26> } <line27> } <line28> "	<line17>
6803	"public class A { <line0> @Test( <line1> groups = {""Phase 1 Stop""}, <line2> description = ""missing column stop_lat"", <line3> priority = 44) <line4> public void verifyTest_2_2_3() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""stop_2_3"", GTFS_1_GTFS_Common_9, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""stops.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(1), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	<line5>
6804	"public class A { <line0> @Override <line1> protected RouteBuilder createRouteBuilder() throws Exception { <line2> return new RouteBuilder() { <line3> public void configure() throws Exception { <line4> context.addComponent(""activemq"", activeMQComponent(vmUri(""?broker.persistent=false""))); <line5> from(""activemq:InitialQueue"").to(""log:Messages""); <line6> from(""activemq:topic:ActiveMQ.Advisory.Queue?cacheLevelName=CACHE_CONSUMER"") <line7> .process( <line8> new Processor() { <line9> public void process(Exchange exchange) { <line10> Message in = exchange.getIn(); <line11> if (in instanceof JmsMessage) { <line12> JmsMessage jmsMessage = (JmsMessage) in; <line13> javax.jms.Message value = jmsMessage.getJmsMessage(); <line14> if (value instanceof ActiveMQMessage) { <line15> ActiveMQMessage activeMQMessage = (ActiveMQMessage) value; <line16> DataStructure structure = activeMQMessage.getDataStructure(); <line17> if (structure instanceof DestinationInfo) { <line18> DestinationInfo destinationInfo = (DestinationInfo) structure; <line19> } <line20> } <line21> } <line22> } <line23> }); <line24> } <line25> }; <line26> } <line27> } <line28> "	<line19>
6805	public class A { <line0> private void processChangeGlobalStateResponse( <line1> final UUID nodeId, final GridChangeGlobalStateMessageResponse msg) { <line2> assert nodeId != null; <line3> assert msg != null; <line4> if (log.isDebugEnabled()) { <line5> } <line6> UUID requestId = msg.getRequestId(); <line7> final GridChangeGlobalStateFuture fut = stateChangeFut.get(); <line8> if (fut != null && requestId.equals(fut.requestId)) { <line9> if (fut.initFut.isDone()) fut.onResponse(nodeId, msg); <line10> else { <line11> fut.initFut.listen( <line12> new CI1<IgniteInternalFuture<?>>() { <line13> @Override <line14> public void apply(IgniteInternalFuture<?> f) { <line15> ctx.getSystemExecutorService() <line16> .execute( <line17> new Runnable() { <line18> @Override <line19> public void run() { <line20> fut.onResponse(nodeId, msg); <line21> } <line22> }); <line23> } <line24> }); <line25> } <line26> } <line27> } <line28> } <line29> 	<line5>
6806	"public class A { <line0> private static String getMavenHome(Log log) { <line1> String mavenHome = System.getProperty(""maven.home""); <line2> if (mavenHome == null) { <line3> try { <line4> mavenHome = CommandLineUtils.getSystemEnvVars().getProperty(""M2_HOME""); <line5> } catch (IOException e) { <line6> if (log != null && log.isDebugEnabled()) { <line7> } <line8> } <line9> } <line10> File m2Home = new File(mavenHome); <line11> if (!m2Home.exists()) { <line12> if (log != null && log.isErrorEnabled()) { <line13> } <line14> } <line15> return mavenHome; <line16> } <line17> } <line18> "	<line7>, <line13>
6807	public class A { <line0> private void run() { <line1> try { <line2> refresh(); <line3> if (super.thing.getStatus() == ThingStatus.INITIALIZING) { <line4> setBridgeProperties(); <line5> } <line6> } catch (PlugwiseHAInvalidHostException e) { <line7> updateStatus(OFFLINE, CONFIGURATION_ERROR, STATUS_DESCRIPTION_INVALID_HOSTNAME); <line8> } catch (PlugwiseHAUnauthorizedException | PlugwiseHANotAuthorizedException e) { <line9> updateStatus(OFFLINE, CONFIGURATION_ERROR, STATUS_DESCRIPTION_INVALID_CREDENTIALS); <line10> } catch (PlugwiseHACommunicationException e) { <line11> updateStatus(OFFLINE, COMMUNICATION_ERROR, STATUS_DESCRIPTION_COMMUNICATION_ERROR); <line12> } catch (PlugwiseHATimeoutException e) { <line13> updateStatus(OFFLINE, COMMUNICATION_ERROR, STATUS_DESCRIPTION_TIMEOUT); <line14> } catch (PlugwiseHAException e) { <line15> updateStatus(OFFLINE, COMMUNICATION_ERROR, e.getMessage()); <line16> } catch (RuntimeException e) { <line17> updateStatus(OFFLINE, COMMUNICATION_ERROR, e.getMessage()); <line18> } <line19> } <line20> } <line21> 	<line2>
6808	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> List<HostState> allHosts = spawnBalancer.hostManager.listHostStatus(null); <line4> spawnBalancer.updateAggregateStatistics(allHosts); <line5> } catch (Exception e) { <line6> if ((errorCounter.getAndIncrement() % 10) == 0) { <line7> } else { <line8> } <line9> } <line10> } <line11> } <line12> 	<line7>, <line8>
6809	public class A { <line0> @Override <line1> public String getPassword() { <line2> return config.getPassword(); <line3> } <line4> } <line5> 	<line2>
6810	public class A { <line0> private void closeAllSources() { <line1> for (DataSourceHolder sourceHolder : dataSources) { <line2> try { <line3> sourceHolder.close(); <line4> } catch (Throwable e) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>
6811	"public class A { <line0> @Override <line1> public void process(LegDataFragment legDataFragment) { <line2> DataProcessUnit unit = createProcessUnit(legDataFragment); <line3> String xmlString = legDataFragment.getText(); <line4> try { <line5> Node root = getXmlRoot(xmlString); <line6> Node committeeRoot = xml.getNode(""sencommmem"", root); <line7> SessionYear sessionYear = <line8> new SessionYear(Integer.parseInt(xml.getString(""@sessyr"", committeeRoot))); <line9> int year = Integer.parseInt(xml.getString(""@year"", committeeRoot)); <line10> Chamber chamber = Chamber.SENATE; <line11> committeeRoot = xml.getNode(""committees"", committeeRoot); <line12> NodeList committeeNodes = committeeRoot.getChildNodes(); <line13> for (int i = 0; i < committeeNodes.getLength(); i++) { <line14> Node committeeNode = committeeNodes.item(i); <line15> if (committeeNode.getNodeName().equals(""committee"")) { <line16> Committee committee = new Committee(); <line17> committee.setSession(sessionYear); <line18> committee.setPublishedDateTime(legDataFragment.getPublishedDateTime()); <line19> committee.setChamber(chamber); <line20> processCommittee(committeeNode, committee); <line21> committee.setModifiedDateTime(legDataFragment.getPublishedDateTime()); <line22> committeeDataService.saveCommittee(committee, legDataFragment); <line23> } <line24> } <line25> } catch (Exception e) { <line26> unit.addException(""XML Sen Comm parsing error"", e); <line27> RuntimeException rethrowEx; <line28> if (e instanceof RuntimeException) { <line29> rethrowEx = (RuntimeException) e; <line30> } else { <line31> rethrowEx = new ParseError(""Error occurred while parsing committee data"", e); <line32> } <line33> throw rethrowEx; <line34> } finally { <line35> postDataUnitEvent(unit); <line36> checkIngestCache(); <line37> } <line38> } <line39> } <line40> "	<line2>, <line11>
6812	public class A { <line0> @Override <line1> public Enumeration getMapNames() throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> return ((MapMessage) message).getMapNames(); <line5> } <line6> } <line7> 	<line3>
6813	public class A { <line0> void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) { <line1> try { <line2> doAsyncCloseInternal(cb, ctx, rc); <line3> } catch (RejectedExecutionException re) { <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> errorOutPendingAdds(BookKeeper.getReturnRc(clientCtx.getBookieClient(), rc)); <line7> cb.closeComplete( <line8> BookKeeper.getReturnRc( <line9> clientCtx.getBookieClient(), BKException.Code.InterruptedException), <line10> this, <line11> ctx); <line12> } <line13> } <line14> } <line15> 	<line5>
6814	public class A { <line0> public void attachClean(StgNZielobjekt instance) { <line1> try { <line2> sessionFactory.getCurrentSession().lock(instance, LockMode.NONE); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
6815	"public class A { <line0> private Integer queryAfterUpdateRowId( <line1> String dbName, String tableName, Map<Field, Object[]> fieldMap) { <line2> int count = 0, id = 0; <line3> ResultSet rs; <line4> PreparedStatement stmt; <line5> Boolean finishQuery = false; <line6> String query = ""select id from "" + dbName + ""."" + tableName + "" where 1=1""; <line7> for (Map.Entry<Field, Object[]> entry : fieldMap.entrySet()) { <line8> count++; <line9> String fieldName = entry.getKey().getName(); <line10> FieldType fieldType = entry.getKey().getType(); <line11> Object fieldValue = entry.getValue()[1]; <line12> if (""id"".equals(fieldName)) continue; <line13> if (count <= fieldMap.size()) { <line14> query += "" and ""; <line15> } <line16> if (fieldValue == null) { <line17> query += fieldName + "" is NULL""; <line18> } else { <line19> query = typeParser(fieldType, fieldName, fieldValue, query); <line20> } <line21> } <line22> try { <line23> while (!connection.isClosed() && !finishQuery) { <line24> stmt = connection.prepareStatement(query); <line25> rs = stmt.executeQuery(); <line26> if (rs != null) { <line27> while (rs.next()) { <line28> id = rs.getInt(""id""); <line29> } <line30> finishQuery = true; <line31> rs.close(); <line32> } <line33> } <line34> } catch (SQLException e) { <line35> } <line36> return id; <line37> } <line38> } <line39> "	<line35>
6816	public class A { <line0> @Override <line1> protected void receiveUpdate(ItemStateEvent updateEvent) { <line2> String itemName = updateEvent.getItemName(); <line3> State newState = updateEvent.getItemState(); <line4> try { <line5> GenericItem item = (GenericItem) itemRegistry.getItem(itemName); <line6> boolean isAccepted = false; <line7> if (item.getAcceptedDataTypes().contains(newState.getClass())) { <line8> isAccepted = true; <line9> } else { <line10> for (Class<? extends State> state : item.getAcceptedDataTypes()) { <line11> try { <line12> if (!state.isEnum() <line13> && state <line14> .getDeclaredConstructor() <line15> .newInstance() <line16> .getClass() <line17> .isAssignableFrom(newState.getClass())) { <line18> isAccepted = true; <line19> break; <line20> } <line21> } catch (ReflectiveOperationException e) { <line22> } <line23> } <line24> } <line25> if (isAccepted) { <line26> item.setState(newState); <line27> } else { <line28> } <line29> } catch (ItemNotFoundException e) { <line30> } <line31> } <line32> } <line33> 	<line22>, <line28>, <line30>
6817	"public class A { <line0> @Override <line1> public synchronized void sendCommand(String command) throws IOException { <line2> if (command == null) { <line3> throw new IllegalArgumentException(""command cannot be null""); <line4> } <line5> if (!isConnected()) { <line6> throw new IOException(""Cannot send message - disconnected""); <line7> } <line8> ByteBuffer toSend = ByteBuffer.wrap((command + ""\r\n"").getBytes()); <line9> final SocketChannel channel = socketChannel.get(); <line10> if (channel == null) { <line11> } else { <line12> channel.write(toSend); <line13> } <line14> } <line15> } <line16> "	<line11>, <line12>
6818	"public class A { <line0> @Test( <line1> groups = {""Phase 2 Route""}, <line2> description = ""route_long_name includes route_short_name"", <line3> priority = 326) <line4> public void verifyTest_2_8() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""route_8"", GTFS_2_GTFS_Route_2, SEVERITY.WARNING, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""routes.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(2), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	<line5>
6819	public class A { <line0> void cleanHelperFiles() { <line1> try { <line2> fs.delete(basePath, true); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7> 	<line4>
6820	public class A { <line0> @Override <line1> public void setResponseManaType(UUID manaTypePlayerId, ManaType manaType) { <line2> waitResponseOpen(); <line3> synchronized (response) { <line4> response.setManaType(manaType); <line5> response.setResponseManaTypePlayerId(manaTypePlayerId); <line6> response.notifyAll(); <line7> } <line8> } <line9> } <line10> 	<line7>
6821	"public class A { <line0> @PostConstruct <line1> public void load() { <line2> this.loadLoginModuleNames(); <line3> this.loadJaasConfig(); <line4> authenticatedSessionTimeoutMinutes = <line5> sysPropConfigStore.get(""authenticatedSessionTimeoutMinutes"", 180); <line6> enforceMatchingUsernames = <line7> Boolean.parseBoolean(sysPropConfigStore.get(""zanata.enforce.matchingusernames"")); <line8> tokenExpiresInSeconds = sysPropConfigStore.getLong(ACCESS_TOKEN_EXPIRES_IN_SECONDS, 3600); <line9> } <line10> } <line11> "	<line2>
6822	public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public void deleteSubscription(final String eventType, final SystemRequestDTO subscriberSystem) { <line2> final EventType validEventType = validateEventTypeIsInDB(eventType); <line3> final System validSubscriber = validateSystemRequestDTO(subscriberSystem); <line4> try { <line5> final Optional<Subscription> subcriptionOptional = <line6> subscriptionRepository.findByEventTypeAndSubscriberSystem( <line7> validEventType, validSubscriber); <line8> if (subcriptionOptional.isPresent()) { <line9> final Subscription subscriptionEntry = subcriptionOptional.get(); <line10> final Set<SubscriptionPublisherConnection> involvedPublisherSystems = <line11> subscriptionPublisherConnectionRepository.findBySubscriptionEntry(subscriptionEntry); <line12> subscriptionPublisherConnectionRepository.deleteInBatch(involvedPublisherSystems); <line13> subscriptionRepository.refresh(subscriptionEntry); <line14> subscriptionRepository.delete(subscriptionEntry); <line15> } <line16> } catch (final Exception ex) { <line17> throw new ArrowheadException(CoreCommonConstants.DATABASE_OPERATION_EXCEPTION_MSG); <line18> } <line19> } <line20> } <line21> 	<line2>, <line17>
6823	"public class A { <line0> public BaseExternalType createExternalTypeFromStringWithPythonException( <line1> CustomScript customScript, Map<String, SimpleCustomProperty> configurationAttributes) <line2> throws Exception { <line3> String script = customScript.getScript(); <line4> String scriptName = StringHelper.toLowerCase(customScript.getName()) + "".py""; <line5> if (script == null) { <line6> return null; <line7> } <line8> CustomScriptType customScriptType = customScript.getScriptType(); <line9> BaseExternalType externalType = null; <line10> InputStream bis = null; <line11> try { <line12> bis = new ByteArrayInputStream(script.getBytes(""UTF-8"")); <line13> externalType = <line14> pythonService.loadPythonScript( <line15> bis, <line16> scriptName, <line17> customScriptType.getPythonClass(), <line18> customScriptType.getCustomScriptType(), <line19> new PyObject[] {new PyLong(System.currentTimeMillis())}); <line20> } catch (UnsupportedEncodingException e) { <line21> } finally { <line22> IOUtils.closeQuietly(bis); <line23> } <line24> if (externalType == null) { <line25> return null; <line26> } <line27> boolean initialized = false; <line28> try { <line29> if (externalType.getApiVersion() > 10) { <line30> initialized = externalType.init(customScript, configurationAttributes); <line31> } else { <line32> initialized = externalType.init(configurationAttributes); <line33> } <line34> } catch (Exception ex) { <line35> } <line36> if (initialized) { <line37> return externalType; <line38> } <line39> return null; <line40> } <line41> } <line42> "	<line21>, <line33>, <line35>
6824	"public class A { <line0> @Override <line1> protected void render(AjaxRequestTarget aTarget) { <line2> RequestCycle requestCycle = RequestCycle.get(); <line3> Set<String> renderedEditors = <line4> requestCycle.getMetaData(AnnotationEditorRenderedMetaDataKey.INSTANCE); <line5> if (renderedEditors == null) { <line6> renderedEditors = new HashSet<>(); <line7> requestCycle.setMetaData(AnnotationEditorRenderedMetaDataKey.INSTANCE, renderedEditors); <line8> } <line9> if (renderedEditors.contains(getMarkupId())) { <line10> return; <line11> } <line12> renderedEditors.add(getMarkupId()); <line13> Set<Component> components = new HashSet<>(aTarget.getComponents()); <line14> boolean deferredRenderingRequired = <line15> components.contains(this) <line16> || visitParents( <line17> MarkupContainer.class, <line18> (aParent, aVisit) -> { <line19> if (components.contains(aParent)) { <line20> aVisit.stop(aParent); <line21> } <line22> }) <line23> != null; <line24> if (deferredRenderingRequired) { <line25> return; <line26> } <line27> try { <line28> bratRenderCommand(getCasProvider().get()) <line29> .ifPresent( <line30> cmd -> { <line31> StringBuilder js = new StringBuilder(); <line32> if (bratProperties.isDeferredRendering()) { <line33> js.append(""setTimeout(function() {""); <line34> } <line35> if (bratProperties.isClientSideProfiling()) { <line36> js.append(""Util.profileEnable(true);""); <line37> js.append(""Util.profileClear();""); <line38> } <line39> if (bratProperties.isClientSideTraceLog()) { <line40> js.append(""console.log('Rendering ("" + vis.getMarkupId() + "")...');""); <line41> } <line42> js.append(cmd); <line43> if (bratProperties.isClientSideProfiling()) { <line44> js.append(""Util.profileReport();""); <line45> } <line46> if (bratProperties.isDeferredRendering()) { <line47> js.append(""}, 1);""); <line48> } <line49> aTarget.appendJavaScript(js); <line50> }); <line51> } catch (IOException e) { <line52> error(""Unable to load data: "" + ExceptionUtils.getRootCauseMessage(e)); <line53> aTarget.addChildren(getPage(), IFeedback.class); <line54> } <line55> } <line56> } <line57> "	<line10>, <line25>, <line27>, <line52>
6825	public class A { <line0> @Override <line1> public PlayerSkin createPlayerSkin(InputStream inputStream) { <line2> try { <line3> return io.gomint.server.player.PlayerSkin.fromInputStream(inputStream); <line4> } catch (IOException e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	<line5>
6826	public class A { <line0> @Override <line1> public IoWriteFuture writeBuffer(Buffer buffer) throws IOException { <line2> if (log.isDebugEnabled()) { <line3> } <line4> ByteBuffer buf = ByteBuffer.wrap(buffer.array(), buffer.rpos(), buffer.available()); <line5> Nio2DefaultIoWriteFuture future = new Nio2DefaultIoWriteFuture(getRemoteAddress(), null, buf); <line6> if (isClosing()) { <line7> Throwable exc = new ClosedChannelException(); <line8> future.setException(exc); <line9> exceptionCaught(exc); <line10> return future; <line11> } <line12> writes.add(future); <line13> startWriting(); <line14> return future; <line15> } <line16> } <line17> 	<line3>
6827	"public class A { <line0> @Override <line1> public <E> List<E> getColumnsById( <line2> String schemaName, <line3> String tableName, <line4> String pKeyColumnName, <line5> String inverseJoinColumnName, <line6> Object pKeyColumnValue, <line7> Class columnJavaType) { <line8> List<E> foreignKeys = new ArrayList<E>(); <line9> URI uri = null; <line10> HttpResponse response = null; <line11> try { <line12> String q = ""key="" + CouchDBUtils.appendQuotes(pKeyColumnValue); <line13> uri = <line14> new URI( <line15> CouchDBConstants.PROTOCOL, <line16> null, <line17> httpHost.getHostName(), <line18> httpHost.getPort(), <line19> CouchDBConstants.URL_SEPARATOR <line20> + schemaName.toLowerCase() <line21> + CouchDBConstants.URL_SEPARATOR <line22> + CouchDBConstants.DESIGN <line23> + tableName <line24> + CouchDBConstants.VIEW <line25> + pKeyColumnName, <line26> q, <line27> null); <line28> HttpGet get = new HttpGet(uri); <line29> get.addHeader(""Accept"", ""application/json""); <line30> response = httpClient.execute(get); <line31> InputStream content = response.getEntity().getContent(); <line32> Reader reader = new InputStreamReader(content); <line33> JsonObject json = gson.fromJson(reader, JsonObject.class); <line34> JsonElement jsonElement = json.get(""rows""); <line35> if (jsonElement == null) { <line36> return foreignKeys; <line37> } <line38> JsonArray array = jsonElement.getAsJsonArray(); <line39> for (JsonElement element : array) { <line40> JsonElement value = <line41> element.getAsJsonObject().get(""value"").getAsJsonObject().get(inverseJoinColumnName); <line42> if (value != null) { <line43> foreignKeys.add( <line44> (E) <line45> PropertyAccessorHelper.fromSourceToTargetClass( <line46> columnJavaType, String.class, value.getAsString())); <line47> } <line48> } <line49> } catch (Exception e) { <line50> throw new KunderaException(e); <line51> } finally { <line52> closeContent(response); <line53> } <line54> return foreignKeys; <line55> } <line56> } <line57> "	<line50>
6828	public class A { <line0> @Override <line1> public Void run() { <line2> startServer(server); <line3> return null; <line4> } <line5> } <line6> 	<line2>
6829	public class A { <line0> private static Set<JobInfo> getAllJobInfo( <line1> ProcessType ptype, <line2> JobInfo parentJobInfo, <line3> Set<JobInfo> jobInfos, <line4> boolean firstChildOnly, <line5> boolean includeJoblet) { <line6> if (ptype == null) { <line7> return jobInfos; <line8> } <line9> EList<NodeType> nodes = ptype.getNode(); <line10> getSubjobInfo(nodes, ptype, parentJobInfo, jobInfos, firstChildOnly, includeJoblet); <line11> if (parentJobInfo.isTestContainer() <line12> && GlobalServiceRegister.getDefault() <line13> .isServiceRegistered(ITestContainerProviderService.class)) { <line14> ITestContainerProviderService testContainerService = <line15> GlobalServiceRegister.getDefault().getService(ITestContainerProviderService.class); <line16> if (testContainerService != null) { <line17> getSubjobInfo( <line18> testContainerService.getOriginalNodes(ptype), <line19> ptype, <line20> parentJobInfo, <line21> jobInfos, <line22> firstChildOnly, <line23> includeJoblet); <line24> } <line25> } <line26> if (!parentJobInfo.isTestContainer() <line27> && !parentJobInfo.isJoblet() <line28> && GlobalServiceRegister.getDefault() <line29> .isServiceRegistered(ITestContainerProviderService.class)) { <line30> ITestContainerProviderService testContainerService = <line31> GlobalServiceRegister.getDefault().getService(ITestContainerProviderService.class); <line32> if (testContainerService != null) { <line33> List<ProcessItem> testsItems = <line34> testContainerService.getTestContainersByVersion(parentJobInfo.getProcessItem()); <line35> for (ProcessItem testItem : testsItems) { <line36> ProcessType testProcess = testContainerService.getTestContainerProcess(testItem); <line37> if (testItem.getProcess() == null) { <line38> testItem.setProcess(testProcess); <line39> } <line40> if (testProcess == null) { <line41> continue; <line42> } <line43> JobInfo jobInfo = new JobInfo(testItem, testProcess.getDefaultContext()); <line44> jobInfo.setTestContainer(true); <line45> jobInfo.setFatherJobInfo(parentJobInfo); <line46> if (!jobInfos.contains(jobInfo)) { <line47> jobInfos.add(jobInfo); <line48> getSubjobInfo( <line49> testProcess.getNode(), <line50> testProcess, <line51> parentJobInfo, <line52> jobInfos, <line53> firstChildOnly, <line54> includeJoblet); <line55> } <line56> } <line57> } <line58> } <line59> return jobInfos; <line60> } <line61> } <line62> 	<line41>
6830	"public class A { <line0> @Test <line1> public void testMaxConnections() throws Exception { <line2> assertMemoryLeak( <line3> () -> { <line4> HttpServerConfiguration httpServerConfiguration = new DefaultHttpServerConfiguration(); <line5> int N = 200; <line6> AtomicInteger openCount = new AtomicInteger(0); <line7> AtomicInteger closeCount = new AtomicInteger(0); <line8> final IODispatcherConfiguration configuration = <line9> new DefaultIODispatcherConfiguration() { <line10> @Override <line11> public int getActiveConnectionLimit() { <line12> return 15; <line13> } <line14> }; <line15> try (IODispatcher<HttpConnectionContext> dispatcher = <line16> IODispatchers.create( <line17> configuration, <line18> new IOContextFactory<HttpConnectionContext>() { <line19> @Override <line20> public HttpConnectionContext newInstance( <line21> long fd, IODispatcher<HttpConnectionContext> dispatcher1) { <line22> openCount.incrementAndGet(); <line23> return new HttpConnectionContext( <line24> httpServerConfiguration.getHttpContextConfiguration()) { <line25> @Override <line26> public void close() { <line27> closeCount.incrementAndGet(); <line28> super.close(); <line29> } <line30> }.of(fd, dispatcher1); <line31> } <line32> })) { <line33> HttpRequestProcessorSelector selector = <line34> new HttpRequestProcessorSelector() { <line35> @Override <line36> public HttpRequestProcessor select(CharSequence url) { <line37> return null; <line38> } <line39>  <line40> @Override <line41> public HttpRequestProcessor getDefaultProcessor() { <line42> return new HttpRequestProcessor() {}; <line43> } <line44>  <line45> @Override <line46> public void close() {} <line47> }; <line48> AtomicBoolean serverRunning = new AtomicBoolean(true); <line49> SOCountDownLatch serverHaltLatch = new SOCountDownLatch(1); <line50> new Thread( <line51> () -> { <line52> do { <line53> dispatcher.run(0); <line54> dispatcher.processIOQueue( <line55> (operation, context) -> <line56> context.handleClientOperation( <line57> operation, selector, EmptyRescheduleContext)); <line58> } while (serverRunning.get()); <line59> serverHaltLatch.countDown(); <line60> }) <line61> .start(); <line62> for (int i = 0; i < N; i++) { <line63> long fd = Net.socketTcp(true); <line64> long sockAddr = Net.sockaddr(""127.0.0.1"", 9001); <line65> try { <line66> Assert.assertTrue(fd > -1); <line67> Assert.assertEquals(0, Net.connect(fd, sockAddr)); <line68> Assert.assertEquals(0, Net.close(fd)); <line69> } finally { <line70> Net.freeSockAddr(sockAddr); <line71> } <line72> } <line73> Assert.assertFalse( <line74> configuration.getActiveConnectionLimit() < dispatcher.getConnectionCount()); <line75> serverRunning.set(false); <line76> serverHaltLatch.await(); <line77> } <line78> }); <line79> } <line80> } <line81> "	<line2>, <line69>
6831	public class A { <line0> public static void moveQuantitiesBetweenWarehouses( <line1> long fromCommerceInventoryWarehouseId, <line2> long toCommerceInventoryWarehouseId, <line3> String sku, <line4> int quantity) <line5> throws RemoteException { <line6> try { <line7> CommerceInventoryWarehouseItemServiceUtil.moveQuantitiesBetweenWarehouses( <line8> fromCommerceInventoryWarehouseId, toCommerceInventoryWarehouseId, sku, quantity); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line10>
6832	public class A { <line0> @Override <line1> public void open() throws DatabaseConfigurationException { <line2> final Path file = getDataDir().resolve(FILE_NAME); <line3> try { <line4> btree = <line5> new BTreeStore( <line6> pool, <line7> STRUCTURAL_INDEX_ID, <line8> FILE_FORMAT_VERSION_ID, <line9> false, <line10> file, <line11> pool.getCacheManager()); <line12> } catch (final DBException e) { <line13> throw new DatabaseConfigurationException(e.getMessage(), e); <line14> } <line15> } <line16> } <line17> 	<line3>, <line13>
6833	public class A { <line0> protected void reset() { <line1> for (RouteMap.Entry<String, RouteAsImpl> e = this.route.head(), end = this.route.tail(); <line2> (e = e.getNext()) != end; ) { <line3> String key = e.getKey(); <line4> RouteAsImpl routeAs = e.getValue(); <line5> routeAs.setM3uaManagement(this.m3uaManagement); <line6> routeAs.reset(); <line7> As[] asList = routeAs.getAsArray(); <line8> try { <line9> String[] keys = key.split(KEY_SEPARATOR); <line10> int dpc = Integer.parseInt(keys[0]); <line11> for (count = 0; count < asList.length; count++) { <line12> AsImpl asImpl = (AsImpl) asList[count]; <line13> if (asImpl != null) { <line14> this.addAsToDPC(dpc, asImpl); <line15> } <line16> } <line17> } catch (Exception ex) { <line18> } <line19> } <line20> } <line21> } <line22> 	<line18>
6834	"public class A { <line0> public static <T> T getObjectFromAerospikeRecord( <line1> Class<T> classEntity, AerospikeRecord aerospikeRecord, AerospikeDeepJobConfig aerospikeConfig) <line2> throws IllegalAccessException, InstantiationException, InvocationTargetException { <line3> Tuple2<String, Object> equalsFilter = aerospikeConfig.getEqualsFilter(); <line4> String equalsFilterBin = equalsFilter != null ? equalsFilter._1() : null; <line5> Object equalsFilterValue = equalsFilter != null ? equalsFilter._2() : null; <line6> Map<String, Object> bins = aerospikeRecord.bins; <line7> T t = classEntity.newInstance(); <line8> if (equalsFilter == null || checkEqualityFilter(bins, equalsFilterBin, equalsFilterValue)) { <line9> Field[] fields = AnnotationUtils.filterDeepFields(classEntity); <line10> Object insert = null; <line11> List<String> inputColumns = null; <line12> if (aerospikeConfig.getInputColumns() != null) { <line13> inputColumns = Arrays.asList(aerospikeConfig.getInputColumns()); <line14> } <line15> for (Field field : fields) { <line16> if (inputColumns != null && !inputColumns.contains(AnnotationUtils.deepFieldName(field))) { <line17> continue; <line18> } <line19> Object currentBin = null; <line20> Method method = null; <line21> Class<?> classField = field.getType(); <line22> try { <line23> method = Utils.findSetter(field.getName(), classEntity, field.getType()); <line24> currentBin = bins.get(AnnotationUtils.deepFieldName(field)); <line25> if (currentBin != null) { <line26> if (currentBin instanceof Integer && classField.equals(Long.class)) { <line27> currentBin = new Long((Integer) currentBin); <line28> } <line29> if (currentBin instanceof String <line30> || currentBin instanceof Integer <line31> || currentBin instanceof Long) { <line32> insert = currentBin; <line33> } else { <line34> throw new DeepGenericException( <line35> ""Data type ["" <line36> + classField.toString() <line37> + ""] not supported in Aerospike entity extractor (only Strings and"" <line38> + "" Integers)""); <line39> } <line40> method.invoke(t, insert); <line41> } <line42> } catch (IllegalAccessException | InvocationTargetException | IllegalArgumentException e) { <line43> method.invoke(t, Utils.castNumberType(insert, classField)); <line44> } <line45> } <line46> } <line47> return t; <line48> } <line49> } <line50> "	<line43>
6835	public class A { <line0> public void deleteExpired() { <line1> int deletedCount; <line2> do { <line3> PageRequest pageable = PageRequest.of(0, 500); <line4> List<Long> expired = mBlobRepository.findExpiredBlobIds(pageable); <line5> if (!expired.isEmpty()) { <line6> deletedCount = mBlobRepository.deleteByIds(expired); <line7> } else { <line8> deletedCount = 0; <line9> } <line10> } while (deletedCount > 0); <line11> } <line12> } <line13> 	<line7>, <line8>
6836	"public class A { <line0> private void runJoinSample(EPRuntime runtime) { <line1> String epl = <line2> ""select sw.* "" <line3> + ""from SampleJoinEvent#lastevent sje, MySampleWindow sw "" <line4> + ""where sw.key1 = sje.propOne and sw.key2 = sje.propTwo""; <line5> EPStatement stmt = compileDeploy(epl, runtime); <line6> SampleUpdateListener sampleListener = new SampleUpdateListener(); <line7> stmt.addListener(sampleListener); <line8> runtime <line9> .getEventService() <line10> .sendEventBean(new SampleJoinEvent(""sample1"", ""sample2""), ""SampleJoinEvent""); <line11> } <line12> } <line13> "	<line11>
6837	public class A { <line0> public boolean matchFilter(String filterString, Map<String, ?> map) { <line1> if (filterString != null) { <line2> try { <line3> Filter filter = paxBundleContext.createFilter(filterString); <line4> if (filter.matches(map)) { <line5> return true; <line6> } else { <line7> } <line8> } catch (InvalidSyntaxException e) { <line9> } <line10> } <line11> return false; <line12> } <line13> } <line14> 	<line5>, <line7>, <line9>
6838	"public class A { <line0> public static void storeQuery(List<String> querySet, String outputPath) throws IOException { <line1> String fileName = outputPath + "".sql""; <line2> File parentFile = new File(fileName).getParentFile(); <line3> if (!parentFile.exists()) { <line4> parentFile.mkdirs(); <line5> } <line6> try (BufferedWriter bufferedWriter = <line7> new BufferedWriter( <line8> new OutputStreamWriter(new FileOutputStream(fileName), StandardCharsets.UTF_8))) { <line9> for (String query : querySet) { <line10> bufferedWriter.append(query); <line11> bufferedWriter.append(SQL_SEPARATOR + ""\n""); <line12> } <line13> } <line14> } <line15> } <line16> "	<line12>
6839	"public class A { <line0> public static com.liferay.portal.kernel.model.ClassName fetchByClassNameId( <line1> HttpPrincipal httpPrincipal, long classNameId) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> ClassNameServiceUtil.class, ""fetchByClassNameId"", _fetchByClassNameIdParameterTypes0); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, classNameId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line12> } <line13> return (com.liferay.portal.kernel.model.ClassName) returnObj; <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	<line15>
6840	public class A { <line0> public void setPrimaryFieldPos(int p) { <line1> primaryFieldPos = p; <line2> } <line3> } <line4> 	<line1>
6841	public class A { <line0> private void obtainExecutionResources(int jobId, ResourceDescription requirements) <line1> throws UnsufficientAvailableResourcesException { <line2> long timeAssignResourcesStart = 0L; <line3> if (IS_TIMER_COMPSS_ENABLED) { <line4> timeAssignResourcesStart = System.nanoTime(); <line5> } <line6> this.resources = this.platform.acquireResources(jobId, requirements, resources); <line7> assignExecutionResources(); <line8> if (IS_TIMER_COMPSS_ENABLED) { <line9> final long timeAssignResourcesEnd = System.nanoTime(); <line10> final float timeAssignResourcesElapsed = <line11> (timeAssignResourcesEnd - timeAssignResourcesStart) / (float) NANO_TO_MS; <line12> } <line13> } <line14> } <line15> 	<line12>
6842	"public class A { <line0> protected BinaryAttachmentResponse encodeNetCDFObsToNetcdf( <line1> List<NetCDFObservation> netCDFObsList, Version version) throws EncodingException { <line2> if (CollectionHelper.isEmptyOrNull(netCDFObsList)) { <line3> throw new EncodingException(""No feature types to encode""); <line4> } else if (netCDFObsList.size() > 1) { <line5> throwTooManyFeatureTypesOrSensorsException(netCDFObsList, netCDFObsList.size(), null); <line6> } <line7> NetCDFObservation netCDFObservation = netCDFObsList.get(0); <line8> if (CollectionHelper.isEmpty(netCDFObservation.getSensorDatasets())) { <line9> throw new EncodingException(""No sensors to encode""); <line10> } else if (netCDFObservation.getSensorDatasets().size() > 1) { <line11> throwTooManyFeatureTypesOrSensorsException( <line12> netCDFObsList, null, netCDFObservation.getSensorDatasets().size()); <line13> } <line14> AbstractSensorDataset sensorDataset = netCDFObservation.getSensorDatasets().get(0); <line15> File tempDir = Files.createTempDir(); <line16> String filename = getFilename(sensorDataset); <line17> File netcdfFile = new File(tempDir, filename); <line18> try { <line19> encodeSensorDataToNetcdf(netcdfFile, sensorDataset, version); <line20> return new BinaryAttachmentResponse( <line21> Files.toByteArray(netcdfFile), <line22> getContentType(), <line23> String.format(filename, makeDateSafe(new DateTime(DateTimeZone.UTC)))); <line24> } catch (IOException e) { <line25> throw new EncodingException(""Couldn't create netCDF file"", e); <line26> } finally { <line27> } <line28> } <line29> } <line30> "	<line27>
6843	"public class A { <line0> @Override <line1> public void delete(String... usernames) throws SecurityManagementException { <line2> checkNotNull(""usernames"", usernames); <line3> for (String username : usernames) { <line4> final User user = get(username); <line5> if (user == null) { <line6> throw new UserNotFoundException(username); <line7> } <line8> try { <line9> usersFileLoader.getProperties().remove(username); <line10> usersFileLoader.persistProperties(); <line11> getGroupsPropertiesManager().removeEntry(username); <line12> } catch (IOException e) { <line13> throw new SecurityManagementException(e); <line14> } <line15> } <line16> } <line17> } <line18> "	<line13>
6844	"public class A { <line0> public void checkLatency( <line1> final long testTime, final TimeUnit testTimeUnit, WebPage localClient, WebPage remoteClient) { <line2> addChangeColorEventListener( <line3> new VideoTag(VideoTagType.LOCAL), localClient, getName() + "" "" + VideoTagType.LOCAL); <line4> addChangeColorEventListener( <line5> new VideoTag(VideoTagType.REMOTE), remoteClient, getName() + "" "" + VideoTagType.REMOTE); <line6> String msgName = name != null ? ""["" + name + ""] "" : """"; <line7> if (localChangeColor == null || remoteChangeColor == null) { <line8> throw new RuntimeException( <line9> msgName <line10> + ""Bad setup in latency controller "" <line11> + "" (local and remote tag of browser(s) needed""); <line12> } <line13> try { <line14> final Thread waitingThread = Thread.currentThread(); <line15> Thread thread; <line16> if (testTimeUnit != null) { <line17> thread = <line18> new Thread() { <line19> @Override <line20> public void run() { <line21> try { <line22> testTimeUnit.sleep(testTime); <line23> waitingThread.interrupt(); <line24> } catch (InterruptedException e) { <line25> } <line26> } <line27> }; <line28> thread.setDaemon(true); <line29> thread.start(); <line30> } else { <line31> thread = waitingThread; <line32> } <line33> do { <line34> waitForLocalColor(msgName, thread); <line35> } while (!similarColor(lastLocalColor, Color.GREEN)); <line36> do { <line37> waitForRemoteColor(msgName, thread); <line38> } while (!similarColor(lastRemoteColor, Color.GREEN)); <line39> while (true) { <line40> waitForLocalColor(msgName, thread); <line41> waitForRemoteColor(msgName, thread); <line42> long latencyMilis = <line43> Math.abs(lastRemoteColorChangeTimeAbsolute - lastLocalColorChangeTimeAbsolute); <line44> SimpleDateFormat formater = new SimpleDateFormat(""mm:ss.SSS""); <line45> String parsedLocaltime = formater.format(lastLocalColorChangeTimeAbsolute); <line46> String parsedRemotetime = formater.format(lastRemoteColorChangeTimeAbsolute); <line47> if (similarColor(lastLocalColor, lastRemoteColor)) { <line48> if (monitor != null) { <line49> monitor.addCurrentLatency(latencyMilis); <line50> } <line51> LatencyRegistry LatencyRegistry = new LatencyRegistry(lastRemoteColor, latencyMilis); <line52> if (latencyMilis > getLatencyThreshold(TimeUnit.MILLISECONDS)) { <line53> LatencyException latencyException = <line54> new LatencyException( <line55> latencyMilis, <line56> testTimeUnit, <line57> parsedLocaltime, <line58> parsedRemotetime, <line59> testTime, <line60> latencyMilis); <line61> LatencyRegistry.setLatencyException(latencyException); <line62> if (failIfLatencyProblem) { <line63> thread.interrupt(); <line64> throw latencyException; <line65> } else { <line66> } <line67> if (monitor != null) { <line68> monitor.incrementLatencyErrors(); <line69> } <line70> } <line71> latencyMap.put(lastRemoteColorChangeTime, LatencyRegistry); <line72> } <line73> } <line74> } catch (InterruptedException e) { <line75> } <line76> localColorTrigger.interrupt(); <line77> remoteColorTrigger.interrupt(); <line78> } <line79> } <line80> "	<line47>, <line48>, <line66>, <line75>
6845	public class A { <line0> public static void schedule() { <line1> service.scheduleWithFixedDelay(new DataCacheHandler(), 0, TTL, TimeUnit.SECONDS); <line2> } <line3> } <line4> 	<line2>
6846	public class A { <line0> private void doProcessMessage( <line1> ReplicationMessageProcessor processor, <line2> TypeRegistry typeRegistry, <line3> byte[] content, <line4> boolean lastMessage) <line5> throws IOException, SQLException, InterruptedException { <line6> if (content != null) { <line7> final Document change = DocumentReader.floatNumbersAsTextReader().read(content); <line8> processor.process( <line9> new Wal2JsonReplicationMessage( <line10> txId, commitTime, change, containsMetadata, lastMessage, typeRegistry)); <line11> } else { <line12> processor.process(new NoopMessage(txId, commitTime)); <line13> } <line14> } <line15> } <line16> 	<line8>, <line12>
6847	"public class A { <line0> @Test <line1> public void callerData() { <line2> assertEquals(0, listAppender.list.size()); <line3> PatternLayout pl = new PatternLayout(); <line4> pl.setPattern(""%-5level [%class] %logger - %msg""); <line5> pl.setContext(lc); <line6> pl.start(); <line7> listAppender.layout = pl; <line8> Logger logger = Logger.getLogger(""basic-test""); <line9> assertEquals(0, listAppender.list.size()); <line10> rootLogger.setLevel(Level.TRACE); <line11> assertEquals(1, listAppender.list.size()); <line12> ILoggingEvent event = (ILoggingEvent) listAppender.list.get(0); <line13> assertEquals(HELLO, event.getMessage()); <line14> assertEquals(1, listAppender.stringList.size()); <line15> assertEquals( <line16> ""TRACE ["" + Log4jInvocation.class.getName() + ""] basic-test - Hello"", <line17> listAppender.stringList.get(0)); <line18> } <line19> } <line20> "	<line9>, <line11>
6848	"public class A { <line0> @Override <line1> protected void doExportStagedModel(PortletDataContext portletDataContext, BlogsEntry entry) <line2> throws Exception { <line3> Element entryElement = portletDataContext.getExportDataElement(entry); <line4> if (entry.isSmallImage()) { <line5> if (entry.getSmallImageFileEntryId() > 0) { <line6> FileEntry fileEntry = <line7> _portletFileRepository.getPortletFileEntry(entry.getSmallImageFileEntryId()); <line8> StagedModelDataHandlerUtil.exportReferenceStagedModel( <line9> portletDataContext, entry, fileEntry, PortletDataContext.REFERENCE_TYPE_WEAK); <line10> } else if (entry.getSmallImageId() > 0) { <line11> Image smallImage = _imageLocalService.fetchImage(entry.getSmallImageId()); <line12> if ((smallImage != null) && (smallImage.getTextObj() != null)) { <line13> String smallImagePath = <line14> ExportImportPathUtil.getModelPath( <line15> entry, smallImage.getImageId() + StringPool.PERIOD + smallImage.getType()); <line16> entryElement.addAttribute(""small-image-path"", smallImagePath); <line17> entry.setSmallImageType(smallImage.getType()); <line18> portletDataContext.addZipEntry(smallImagePath, smallImage.getTextObj()); <line19> } else { <line20> if (_log.isWarnEnabled()) { <line21> StringBundler sb = new StringBundler(4); <line22> sb.append(""Unable to export small image ""); <line23> sb.append(entry.getSmallImageId()); <line24> sb.append("" to blogs entry ""); <line25> sb.append(entry.getEntryId()); <line26> } <line27> entry.setSmallImage(false); <line28> entry.setSmallImageId(0); <line29> } <line30> } <line31> } <line32> if (entry.getCoverImageFileEntryId() != 0) { <line33> FileEntry fileEntry = <line34> _portletFileRepository.getPortletFileEntry(entry.getCoverImageFileEntryId()); <line35> StagedModelDataHandlerUtil.exportReferenceStagedModel( <line36> portletDataContext, entry, fileEntry, PortletDataContext.REFERENCE_TYPE_WEAK); <line37> } <line38> _exportFriendlyURLEntries(portletDataContext, entry); <line39> String content = <line40> _exportImportContentProcessor.replaceExportContentReferences( <line41> portletDataContext, <line42> entry, <line43> entry.getContent(), <line44> portletDataContext.getBooleanParameter(""blogs"", ""referenced-content""), <line45> true); <line46> entry.setContent(content); <line47> _exportAssetDisplayPage(portletDataContext, entry); <line48> portletDataContext.addClassedModel( <line49> entryElement, ExportImportPathUtil.getModelPath(entry), entry); <line50> } <line51> } <line52> "	<line26>
6849	public class A { <line0> private void closeMoveOutNamespace( <line1> String zkClusterKey, <line2> List<NamespaceZkClusterMapping> nsZkClusterMappingList, <line3> List<RegistryCenterConfiguration> regCenterConfList) { <line4> if (regCenterConfList == null) { <line5> return; <line6> } <line7> Iterator<RegistryCenterConfiguration> regIter = regCenterConfList.iterator(); <line8> while (regIter.hasNext()) { <line9> RegistryCenterConfiguration conf = regIter.next(); <line10> String namespace = conf.getNamespace(); <line11> String nns = conf.getNameAndNamespace(); <line12> boolean include = false; <line13> if (nsZkClusterMappingList != null) { <line14> for (NamespaceZkClusterMapping mapping : nsZkClusterMappingList) { <line15> if (namespace.equals(mapping.getNamespace())) { <line16> include = true; <line17> break; <line18> } <line19> } <line20> } <line21> if (!include) { <line22> synchronized (getNnsLock(nns)) { <line23> regIter.remove(); <line24> closeNamespace(nns); <line25> } <line26> } <line27> } <line28> } <line29> } <line30> 	<line25>
6850	public class A { <line0> @Override <line1> protected void supplyActiveThreads() { <line2> if (owner.getTargetLevelAsInt() <= 0) { <line3> return; <line4> } <line5> startTime = System.currentTimeMillis(); <line6> boolean isDebugEnabled = log.isDebugEnabled(); <line7> while (!owner.isLimitReached() && getPlannedConcurrency(isDebugEnabled) >= 0) { <line8> if (isDebugEnabled) { <line9> } <line10> while (concurrTG.getConcurrency() < getPlannedConcurrency(isDebugEnabled)) { <line11> DynamicThread thread = addActiveThread(); <line12> concurrTG.threadStarted(thread); <line13> } <line14> concurrTG.waitThreadStopped(); <line15> } <line16> } <line17> } <line18> 	<line2>, <line3>, <line9>, <line16>
6851	"public class A { <line0> @Override <line1> public ContentRecordVO loadContentVO(String id) throws ApsSystemException { <line2> try { <line3> return (ContentRecordVO) this.getContentDAO().loadEntityRecord(id); <line4> } catch (Throwable t) { <line5> throw new ApsSystemException(""Error while loading content vo : id "" + id, t); <line6> } <line7> } <line8> } <line9> "	<line5>
6852	public class A { <line0> void addListener( <line1> Object listener, PropertyKey propertyKey, ChangeType changeType, EventType[] eventType) { <line2> checkConnected(_waitForConnectedTimeout); <line3> PropertyType type = propertyKey.getType(); <line4> synchronized (this) { <line5> for (CallbackHandler handler : _handlers) { <line6> if (handler.getPath().equals(propertyKey.getPath()) <line7> && handler.getListener().equals(listener)) { <line8> return; <line9> } <line10> } <line11> CallbackHandler newHandler = <line12> new CallbackHandler( <line13> this, <line14> _zkclient, <line15> propertyKey, <line16> listener, <line17> eventType, <line18> changeType, <line19> _callbackMonitors.get(changeType)); <line20> _handlers.add(newHandler); <line21> } <line22> } <line23> } <line24> 	<line8>, <line21>
6853	"public class A { <line0> public static void initDataSources(ThirdEyeConfiguration thirdeyeConfig) { <line1> try { <line2> URL dataSourcesUrl = thirdeyeConfig.getDataSourcesAsUrl(); <line3> DataSources dataSources = DataSourcesLoader.fromDataSourcesUrl(dataSourcesUrl); <line4> if (dataSources == null) { <line5> throw new IllegalStateException( <line6> ""Could not create data sources from path "" + dataSourcesUrl); <line7> } <line8> Map<String, ThirdEyeDataSource> thirdEyeDataSourcesMap = <line9> DataSourcesLoader.getDataSourceMap(dataSources); <line10> QueryCache queryCache = <line11> new QueryCache(thirdEyeDataSourcesMap, Executors.newCachedThreadPool()); <line12> ThirdEyeCacheRegistry.getInstance().registerQueryCache(queryCache); <line13> } catch (Exception e) { <line14> } <line15> } <line16> } <line17> "	<line14>
6854	public class A { <line0> public void updateStatus(WorkerHeartbeat heartbeat) { <line1> String workerAddress = heartbeat.getWorkerAddress(); <line2> long heartbeatTime = heartbeat.getHeartbeatTime(); <line3> WorkerInfo workerInfo = <line4> address2WorkerInfo.computeIfAbsent( <line5> workerAddress, <line6> ignore -> { <line7> WorkerInfo wf = new WorkerInfo(); <line8> wf.refresh(heartbeat); <line9> return wf; <line10> }); <line11> long oldTime = workerInfo.getLastActiveTime(); <line12> if (heartbeatTime < oldTime) { <line13> return; <line14> } <line15> workerInfo.refresh(heartbeat); <line16> List<DeployedContainerInfo> containerInfos = heartbeat.getContainerInfos(); <line17> if (!CollectionUtils.isEmpty(containerInfos)) { <line18> containerInfos.forEach( <line19> containerInfo -> { <line20> Map<String, DeployedContainerInfo> infos = <line21> containerId2Infos.computeIfAbsent( <line22> containerInfo.getContainerId(), ignore -> Maps.newConcurrentMap()); <line23> infos.put(workerAddress, containerInfo); <line24> }); <line25> } <line26> } <line27> } <line28> 	<line13>
6855	public class A { <line0> @Override <line1> public List<SourceRecord> poll() throws InterruptedException { <line2> final long yieldExpiration = <line3> Math.max(failureYieldExpiration, dataflow.getSourceYieldExpiration()); <line4> final long now = System.currentTimeMillis(); <line5> final long yieldMillis = yieldExpiration - now; <line6> if (yieldMillis > 0) { <line7> Thread.sleep(yieldMillis); <line8> return null; <line9> } <line10> if (unacknowledgedRecords.get() > 0) { <line11> return null; <line12> } <line13> final long start = System.nanoTime(); <line14> final DataflowTrigger trigger = dataflow.trigger(); <line15> final Optional<TriggerResult> resultOptional = <line16> trigger.getResult(timeoutMillis, TimeUnit.MILLISECONDS); <line17> if (!resultOptional.isPresent()) { <line18> trigger.cancel(); <line19> return null; <line20> } <line21> triggerResult = resultOptional.get(); <line22> if (!triggerResult.isSuccessful()) { <line23> trigger.cancel(); <line24> failureYieldExpiration = System.currentTimeMillis() + 1000L; <line25> return null; <line26> } <line27> verifyFlowFilesTransferredToProperPort(triggerResult, outputPortName, trigger); <line28> final long nanos = System.nanoTime() - start; <line29> final List<FlowFile> outputFlowFiles = triggerResult.getOutputFlowFiles(outputPortName); <line30> final List<SourceRecord> sourceRecords = new ArrayList<>(outputFlowFiles.size()); <line31> Map<String, ?> componentState = dataflow.getComponentStates(Scope.CLUSTER); <line32> final Map<String, ?> partitionMap; <line33> if (componentState == null || componentState.isEmpty()) { <line34> componentState = dataflow.getComponentStates(Scope.LOCAL); <line35> partitionMap = localStatePartitionMap; <line36> } else { <line37> partitionMap = clusterStatePartitionMap; <line38> } <line39> for (final FlowFile flowFile : outputFlowFiles) { <line40> final byte[] contents = triggerResult.readContent(flowFile); <line41> final SourceRecord sourceRecord = <line42> createSourceRecord(flowFile, contents, componentState, partitionMap); <line43> sourceRecords.add(sourceRecord); <line44> } <line45> if (sourceRecords.size() > 0) { <line46> unacknowledgedRecords.addAndGet(sourceRecords.size()); <line47> } else { <line48> triggerResult.acknowledge(); <line49> } <line50> return sourceRecords; <line51> } <line52> } <line53> 	<line7>, <line13>, <line18>, <line23>, <line45>
6856	"public class A { <line0> @Override <line1> public void emit(Event event) { <line2> if (!started.get()) { <line3> throw new ISE(""Emit called unexpectedly before service start""); <line4> } <line5> if (event instanceof ServiceMetricEvent) { <line6> OpentsdbEvent opentsdbEvent = converter.convert((ServiceMetricEvent) event); <line7> if (opentsdbEvent != null) { <line8> sender.enqueue(opentsdbEvent); <line9> } else { <line10> } <line11> } <line12> } <line13> } <line14> "	<line10>
6857	public class A { <line0> public static void removeShutdownHook( <line1> final Thread shutdownHook, final String serviceName, final Logger logger) { <line2> if (shutdownHook == null || shutdownHook == Thread.currentThread()) { <line3> return; <line4> } <line5> checkNotNull(logger); <line6> try { <line7> Runtime.getRuntime().removeShutdownHook(shutdownHook); <line8> } catch (IllegalStateException e) { <line9> } catch (Throwable t) { <line10> } <line11> } <line12> } <line13> 	<line9>, <line10>
6858	public class A { <line0> @EventListener({InteractiveAuthenticationSuccessEvent.class, AuthenticationSuccessEvent.class}) <line1> public void handleAuthenticationSuccess(AbstractAuthenticationEvent event) { <line2> Authentication auth = event.getAuthentication(); <line3> String username = event.getAuthentication().getName(); <line4> Object details = auth.getDetails(); <line5> if (TwoFactorWebAuthenticationDetails.class.isAssignableFrom(details.getClass())) { <line6> TwoFactorWebAuthenticationDetails authDetails = (TwoFactorWebAuthenticationDetails) details; <line7> } <line8> if (OAuth2LoginAuthenticationToken.class.isAssignableFrom(auth.getClass())) { <line9> OAuth2LoginAuthenticationToken authenticationToken = (OAuth2LoginAuthenticationToken) auth; <line10> DhisOidcUser principal = (DhisOidcUser) authenticationToken.getPrincipal(); <line11> UserCredentials userCredentials = principal.getUserCredentials(); <line12> username = userCredentials.getUsername(); <line13> WebAuthenticationDetails tokenDetails = <line14> (WebAuthenticationDetails) authenticationToken.getDetails(); <line15> String remoteAddress = tokenDetails.getRemoteAddress(); <line16> } <line17> registerSuccessfulLogin(username); <line18> } <line19> } <line20> 	<line7>, <line16>
6859	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> preWalk(); <line4> specWalker.walk(profileInstance.getProfileSpec(), walkState); <line5> } catch (InterruptedException e) { <line6> } catch (IOException e) { <line7> inError = true; <line8> throw new ProfileException(e); <line9> } finally { <line10> postWalk(); <line11> counter.cancel(); <line12> countFuture.cancel(false); <line13> if (!inError) { <line14> profileInstance.finish(); <line15> } <line16> submissionGateway.save(); <line17> profileWalkerDao.delete(); <line18> } <line19> } <line20> } <line21> 	<line6>, <line8>
6860	"public class A { <line0> public static List<Folder> getFolders(HttpServletRequest httpServletRequest) <line1> throws PortalException { <line2> long[] folderIds = ParamUtil.getLongValues(httpServletRequest, ""rowIdsFolder""); <line3> List<Folder> folders = new ArrayList<>(); <line4> for (long folderId : folderIds) { <line5> try { <line6> folders.add(DLAppServiceUtil.getFolder(folderId)); <line7> } catch (NoSuchFolderException noSuchFolderException) { <line8> if (_log.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> return folders; <line13> } <line14> } <line15> "	<line9>
6861	"public class A { <line0> @Test <line1> public void testPrepare() { <line2> TimeHelper.setProvider(new FixedTimeProvider(12345l)); <line3> List<CipherSuite> suiteList = new LinkedList<>(); <line4> context.getConfig().setHighestProtocolVersion(ProtocolVersion.TLS12); <line5> suiteList.add(CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA256); <line6> suiteList.add(CipherSuite.TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256); <line7> suiteList.add(CipherSuite.TLS_DHE_PSK_WITH_AES_128_GCM_SHA256); <line8> context.setClientSupportedCiphersuites(suiteList); <line9> List<CipherSuite> ourSuiteList = new LinkedList<>(); <line10> ourSuiteList.add(CipherSuite.TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256); <line11> List<CompressionMethod> ourCompressionList = new LinkedList<>(); <line12> ourCompressionList.add(CompressionMethod.LZS); <line13> context.getConfig().setDefaultClientSupportedCiphersuites(ourSuiteList); <line14> context.getConfig().setDefaultServerSupportedCompressionMethods(ourCompressionList); <line15> context.setHighestClientProtocolVersion(ProtocolVersion.TLS11); <line16> List<CompressionMethod> compressionList = new LinkedList<>(); <line17> compressionList.add(CompressionMethod.NULL); <line18> compressionList.add(CompressionMethod.LZS); <line19> context.setClientSupportedCompressions(compressionList); <line20> context.getConfig().setDefaultServerSessionId(new byte[] {0, 1, 2, 3, 4, 5}); <line21> preparator.prepare(); <line22> assertArrayEquals(ProtocolVersion.TLS11.getValue(), message.getProtocolVersion().getValue()); <line23> assertArrayEquals(ArrayConverter.longToUint32Bytes(12345l), message.getUnixTime().getValue()); <line24> assertArrayEquals( <line25> ArrayConverter.concatenate( <line26> ArrayConverter.longToUint32Bytes(12345l), <line27> ArrayConverter.hexStringToByteArray( <line28> ""60B420BB3851D9D47ACB933DBE70399BF6C92DA33AF01D4FB770E98C"")), <line29> message.getRandom().getValue()); <line30> assertArrayEquals( <line31> ArrayConverter.hexStringToByteArray(""000102030405""), message.getSessionId().getValue()); <line32> assertTrue(6 == message.getSessionIdLength().getValue()); <line33> assertTrue(message.getExtensionBytes().getValue().length == 0); <line34> assertTrue(0 == message.getExtensionsLength().getValue()); <line35> } <line36> } <line37> "	<line24>
6862	"public class A { <line0> public void waitForCompletion(long timeout, TimeUnit unit) { <line1> try { <line2> if (!_latch.await(timeout, unit)) { <line3> Exception e = <line4> new Exception( <line5> ""Timeout waiting for activity to complete ("" + timeout + "" "" + unit + "")""); <line6> } <line7> } catch (final InterruptedException e) { <line8> } <line9> } <line10> } <line11> "	<line6>, <line8>
6863	public class A { <line0> private void updateRack() { <line1> Rack rack = this.rackClient.getByName(RACK_NAME).get(0); <line2> String resourceId = rack.getResourceId(); <line3> rack.setThermalLimit(Integer.valueOf(1000)); <line4> Rack updatedRack = this.rackClient.update(resourceId, rack); <line5> } <line6> } <line7> 	<line5>
6864	public class A { <line0> private RegionLocations locateRowBeforeInCache( <line1> TableCache tableCache, TableName tableName, byte[] row, int replicaId) { <line2> boolean isEmptyStopRow = isEmptyStopRow(row); <line3> Map.Entry<byte[], RegionLocations> entry = <line4> isEmptyStopRow ? tableCache.cache.lastEntry() : tableCache.cache.lowerEntry(row); <line5> if (entry == null) { <line6> recordCacheMiss(); <line7> return null; <line8> } <line9> RegionLocations locs = entry.getValue(); <line10> HRegionLocation loc = locs.getRegionLocation(replicaId); <line11> if (loc == null) { <line12> recordCacheMiss(); <line13> return null; <line14> } <line15> if (isEmptyStopRow(loc.getRegion().getEndKey()) <line16> || (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) { <line17> if (LOG.isTraceEnabled()) { <line18> } <line19> recordCacheHit(); <line20> return locs; <line21> } else { <line22> recordCacheMiss(); <line23> return null; <line24> } <line25> } <line26> } <line27> 	<line18>
6865	"public class A { <line0> private static void configEnvironment(Map<String, String> env) { <line1> String jvmargs = ConfigUtils.getString(ini, nodeSection, NCConfig.Option.JVM_ARGS.ini(), null); <line2> if (jvmargs != null) { <line3> } else { <line4> jvmargs = env.get(""JAVA_OPTS""); <line5> if (jvmargs != null) { <line6> } else { <line7> jvmargs = """"; <line8> } <line9> } <line10> if (!jvmargs.contains(""-Xmx"")) { <line11> long ramSize = <line12> ((com.sun.management.OperatingSystemMXBean) osMXBean).getTotalPhysicalMemorySize(); <line13> int proportionalRamSize = (int) Math.ceil(0.6 * ramSize / (1024 * 1024)); <line14> int heapSize = <line15> ""32"".equals(System.getProperty(""sun.arch.data.model"")) <line16> ? (proportionalRamSize <= 1024 ? proportionalRamSize : 1024) <line17> : proportionalRamSize; <line18> jvmargs = jvmargs + "" -Xmx"" + heapSize + ""m""; <line19> } <line20> env.put(""JAVA_OPTS"", jvmargs.trim()); <line21> } <line22> } <line23> "	<line3>, <line6>, <line7>, <line21>
6866	public class A { <line0> public void startBackupExclusiveOperation() throws IOException { <line1> try (Table table = connection.getTable(tableName)) { <line2> Put put = createPutForStartBackupSession(); <line3> if (!table <line4> .checkAndMutate(ACTIVE_SESSION_ROW, SESSIONS_FAMILY) <line5> .qualifier(ACTIVE_SESSION_COL) <line6> .ifNotExists() <line7> .thenPut(put)) { <line8> if (!table <line9> .checkAndMutate(ACTIVE_SESSION_ROW, SESSIONS_FAMILY) <line10> .qualifier(ACTIVE_SESSION_COL) <line11> .ifEquals(ACTIVE_SESSION_NO) <line12> .thenPut(put)) { <line13> throw new ExclusiveOperationException(); <line14> } <line15> } <line16> } <line17> } <line18> } <line19> 	<line1>
6867	"public class A { <line0> public void sendEventJson(String json, String jsonEventTypeName) { <line1> if (json == null) { <line2> throw new IllegalArgumentException(""Invalid null event object""); <line3> } <line4> if ((ExecutionPathDebugLog.isDebugEnabled) && (log.isDebugEnabled())) { <line5> } <line6> if (inboundThreading) { <line7> services <line8> .getThreadingService() <line9> .submitInbound(new InboundUnitSendJson(json, jsonEventTypeName, this, services)); <line10> } else { <line11> EventBean eventBean = wrapEventJson(json, jsonEventTypeName); <line12> processWrappedEvent(eventBean); <line13> } <line14> } <line15> } <line16> "	<line5>
6868	"public class A { <line0> public void afterPropertiesSet() throws Exception { <line1> JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); <line2> jdbcTemplate.execute(CREATE_TABLES); <line3> String query = <line4> ""insert into users values ('user', '"" + new Sha256Hash(""user"").toBase64() + ""' )""; <line5> jdbcTemplate.execute(query); <line6> query = ""insert into users values ( 'admin', '"" + new Sha256Hash(""admin"").toBase64() + ""' )""; <line7> jdbcTemplate.execute(query); <line8> query = ""insert into roles values ( 'user' )""; <line9> jdbcTemplate.execute(query); <line10> query = ""insert into roles values ( 'admin' )""; <line11> jdbcTemplate.execute(query); <line12> query = ""insert into roles_permissions values ( 'user', 'view')""; <line13> jdbcTemplate.execute(query); <line14> query = ""insert into roles_permissions values ( 'admin', 'user:*')""; <line15> jdbcTemplate.execute(query); <line16> query = ""insert into user_roles values ( 'user', 'user' )""; <line17> jdbcTemplate.execute(query); <line18> query = ""insert into user_roles values ( 'admin', 'admin' )""; <line19> jdbcTemplate.execute(query); <line20> } <line21> } <line22> "	<line6>, <line8>, <line10>, <line12>, <line14>, <line16>, <line18>, <line20>
6869	public class A { <line0> @Override <line1> public void storeFile(String digest, File file) throws IOException { <line2> long t0 = 0; <line3> if (log.isDebugEnabled()) { <line4> t0 = System.currentTimeMillis(); <line5> } <line6> String key = bucketNamePrefix + digest; <line7> try { <line8> amazonS3.getObjectMetadata(bucketName, key); <line9> if (log.isDebugEnabled()) { <line10> } <line11> } catch (AmazonClientException e) { <line12> if (!isMissingKey(e)) { <line13> throw new IOException(e); <line14> } <line15> PutObjectRequest request; <line16> if (!isEncrypted) { <line17> request = new PutObjectRequest(bucketName, key, file); <line18> if (useServerSideEncryption) { <line19> ObjectMetadata objectMetadata = new ObjectMetadata(); <line20> if (isNotBlank(serverSideKMSKeyID)) { <line21> SSEAwsKeyManagementParams keyManagementParams = <line22> new SSEAwsKeyManagementParams(serverSideKMSKeyID); <line23> request = request.withSSEAwsKeyManagementParams(keyManagementParams); <line24> } else { <line25> objectMetadata.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION); <line26> } <line27> request.setMetadata(objectMetadata); <line28> } <line29> } else { <line30> request = new EncryptedPutObjectRequest(bucketName, key, file); <line31> } <line32> Upload upload = transferManager.upload(request); <line33> try { <line34> upload.waitForUploadResult(); <line35> } catch (AmazonClientException ee) { <line36> throw new IOException(ee); <line37> } catch (InterruptedException ee) { <line38> Thread.currentThread().interrupt(); <line39> throw new RuntimeException(ee); <line40> } finally { <line41> if (log.isDebugEnabled()) { <line42> long dtms = System.currentTimeMillis() - t0; <line43> } <line44> } <line45> } <line46> } <line47> } <line48> 	<line5>, <line10>, <line43>
6870	public class A { <line0> @Override <line1> public byte[] serializeHandshakeMessageContent() { <line2> if (!version.isSSL()) { <line3> writeSerializedPublicKeyLength(msg); <line4> } <line5> writeSerializedPublickey(msg); <line6> return getAlreadySerialized(); <line7> } <line8> } <line9> 	<line2>
6871	public class A { <line0> @Override <line1> public void run() { <line2> if (disposed.compareAndSet(false, true)) { <line3> try { <line4> doDispose(); <line5> } catch (Throwable t) { <line6> try { <line7> } catch (Exception e) { <line8> t.addSuppressed(e); <line9> } <line10> Throwables.propagateIfInstanceOf(t, Error.class); <line11> } <line12> } <line13> } <line14> } <line15> 	<line5>, <line7>
6872	"public class A { <line0> public static java.util.List<com.liferay.commerce.tax.model.CommerceTaxMethod> <line1> getCommerceTaxMethods(HttpPrincipal httpPrincipal, long groupId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceTaxMethodServiceUtil.class, <line7> ""getCommerceTaxMethods"", <line8> _getCommerceTaxMethodsParameterTypes6); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (java.util.List<com.liferay.commerce.tax.model.CommerceTaxMethod>) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
6873	public class A { <line0> @Test <line1> public void test_00() { <line2> initRand(); <line3> for (int len = 1; len < 1000; len++) DnaSequenceBaseAt(len); <line4> } <line5> } <line6> 	<line2>
6874	public class A { <line0> public void terminated(TaskAttemptID taskid) { <line1> TaskStatus status = taskStatuses.get(taskid); <line2> status.setRunState(TaskStatus.State.FAILED); <line3> activeTasks.remove(taskid); <line4> } <line5> } <line6> 	<line1>
6875	public class A { <line0> private boolean importImpersonators( <line1> @NotNull Tree parent, <line2> @NotNull Authorizable a, <line3> @NotNull PropInfo propInfo, <line4> @NotNull PropertyDefinition def) { <line5> if (a.isGroup() || !isValid(def, MIX_REP_IMPERSONATABLE, true)) { <line6> return false; <line7> } <line8> referenceTracker.processedReference( <line9> new Impersonators(parent.getPath(), propInfo.getTextValues())); <line10> return true; <line11> } <line12> } <line13> 	<line6>
6876	public class A { <line0> public static com.liferay.oauth2.provider.model.OAuth2AuthorizationSoap[] <line1> getApplicationOAuth2Authorizations( <line2> long oAuth2ApplicationId, <line3> int start, <line4> int end, <line5> com.liferay.portal.kernel.util.OrderByComparator< <line6> com.liferay.oauth2.provider.model.OAuth2Authorization> <line7> orderByComparator) <line8> throws RemoteException { <line9> try { <line10> java.util.List<com.liferay.oauth2.provider.model.OAuth2Authorization> returnValue = <line11> OAuth2AuthorizationServiceUtil.getApplicationOAuth2Authorizations( <line12> oAuth2ApplicationId, start, end, orderByComparator); <line13> return com.liferay.oauth2.provider.model.OAuth2AuthorizationSoap.toSoapModels(returnValue); <line14> } catch (Exception exception) { <line15> throw new RemoteException(exception.getMessage()); <line16> } <line17> } <line18> } <line19> 	<line15>
6877	public class A { <line0> @Override <line1> public void run() { <line2> Timer t = times.getTimer().start(); <line3> while (true) { <line4> boolean txStillOpen = false; <line5> Iterator<? extends JanusGraphTransaction> iterator = openTx.iterator(); <line6> while (iterator.hasNext()) { <line7> if (iterator.next().isClosed()) { <line8> iterator.remove(); <line9> } else { <line10> txStillOpen = true; <line11> } <line12> } <line13> final JanusGraphManager jgm = JanusGraphManagerUtility.getInstance(); <line14> final boolean janusGraphManagerIsInBadState = null == jgm && action.equals(EVICT); <line15> if (!txStillOpen && janusGraphManagerIsInBadState) { <line16> break; <line17> } else if (!txStillOpen) { <line18> DataOutput out = graph.getDataSerializer().getDataOutput(64); <line19> out.writeObjectNotNull(MgmtLogType.CACHED_TYPE_EVICTION_ACK); <line20> out.writeObjectNotNull(originId); <line21> VariableLong.writePositive(out, evictionId); <line22> if (null != jgm && action.equals(EVICT)) { <line23> jgm.removeGraph(graphName); <line24> } <line25> try { <line26> sysLog.add(out.getStaticBuffer()); <line27> } catch (ResourceUnavailableException e) { <line28> } <line29> break; <line30> } <line31> if (MAX_WAIT_TIME.compareTo(t.elapsed()) < 0) { <line32> break; <line33> } <line34> try { <line35> times.sleepPast(times.getTime().plus(SLEEP_INTERVAL)); <line36> } catch (InterruptedException e) { <line37> break; <line38> } <line39> } <line40> } <line41> } <line42> 	<line16>, <line24>, <line27>, <line28>, <line32>, <line37>
6878	"public class A { <line0> @Override <line1> public @Nullable CounterUpdate transform(MonitoringInfo monitoringInfo) { <line2> Optional<String> validationResult = validate(monitoringInfo); <line3> if (validationResult.isPresent()) { <line4> return null; <line5> } <line6> DistributionData data = decodeInt64Distribution(monitoringInfo.getPayload()); <line7> final String pcollectionId = <line8> monitoringInfo.getLabelsMap().get(MonitoringInfoConstants.Labels.PCOLLECTION); <line9> final String pcollectionName = pcollectionIdToNameContext.get(pcollectionId).userName(); <line10> String counterName = pcollectionName + ""-MeanByteCount""; <line11> NameAndKind name = new NameAndKind(); <line12> name.setName(counterName).setKind(Kind.MEAN.toString()); <line13> return new CounterUpdate() <line14> .setNameAndKind(name) <line15> .setCumulative(true) <line16> .setIntegerMean( <line17> new IntegerMean() <line18> .setSum(longToSplitInt(data.sum())) <line19> .setCount(longToSplitInt(data.count()))); <line20> } <line21> } <line22> "	<line4>
6879	public class A { <line0> @Override <line1> public View onCreateView( <line2> LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <line3> try { <line4> isSystemUpdatingWebView = false; <line5> return inflater.inflate(R.layout.fragment_authenticated_webview, container, false); <line6> } catch (InflateException e) { <line7> isSystemUpdatingWebView = true; <line8> return inflater.inflate(R.layout.content_error, container, false); <line9> } <line10> } <line11> } <line12> 	<line7>
6880	public class A { <line0> public static void setTableLayout( <line1> final CuratorFramework zkClient, final KijiURI tableURI, final String layoutID) <line2> throws IOException { <line3> final String path = ZooKeeperUtils.getTableLayoutFile(tableURI).getPath(); <line4> try { <line5> zkClient.newNamespaceAwareEnsurePath(path).ensure(zkClient.getZookeeperClient()); <line6> zkClient.setData().forPath(path, Bytes.toBytes(layoutID)); <line7> } catch (Exception e) { <line8> wrapAndRethrow(e); <line9> } <line10> } <line11> } <line12> 	<line7>
6881	public class A { <line0> @Override <line1> public void handleMessage(Message msg) { <line2> if (msg.what == MSG_TYPE_TICK) { <line3> if (callback != null) { <line4> if (player != null && player.isPlaying()) { <line5> long pos = player.getCurrentPosition(); <line6> if (pos > 0 && pos != lastSavedPosition) { <line7> lastSavedPosition = pos; <line8> callback.saveCurrentPlaybackPosition(pos); <line9> } <line10> } <line11> } <line12> sendEmptyMessageDelayed(MSG_TYPE_TICK, DELAY_TIME_MS); <line13> } <line14> } <line15> } <line16> 	<line9>
6882	"public class A { <line0> private void doLostReliability( <line1> boolean isInitializing, final InternalDistributedMember id, final Set newlyMissingRoles) { <line2> try { <line3> if (!isInitializing) { <line4> Thread thread = <line5> new LoggingThread( <line6> ""Reconnect Distributed System"", <line7> () -> { <line8> try { <line9> initializationLatchAfterMemberTimeout.await(); <line10> getSystem().tryReconnect(false, ""Role Loss"", getCache()); <line11> synchronized (missingRequiredRoles) { <line12> missingRequiredRoles.notifyAll(); <line13> if (hasListener() && id != null) { <line14> RoleEventImpl relEvent = <line15> new RoleEventImpl( <line16> this, Operation.CACHE_RECONNECT, null, true, id, newlyMissingRoles); <line17> dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_LOSS, relEvent); <line18> } <line19> } <line20> } catch (Exception e) { <line21> } <line22> }); <line23> thread.start(); <line24> } else { <line25> getSystem().tryReconnect(false, ""Role Loss"", getCache()); <line26> synchronized (missingRequiredRoles) { <line27> missingRequiredRoles.notifyAll(); <line28> if (hasListener() && id != null) { <line29> RoleEventImpl relEvent = <line30> new RoleEventImpl( <line31> this, Operation.CACHE_RECONNECT, null, true, id, newlyMissingRoles); <line32> dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_LOSS, relEvent); <line33> } <line34> } <line35> } <line36> } catch (CancelException ignor) { <line37> throw ignor; <line38> } catch (Exception e) { <line39> } <line40> } <line41> } <line42> "	<line9>, <line21>, <line39>
6883	"public class A { <line0> private void pushDocuments( <line1> ObjectOutputStream out, <line2> LoggedInInfo loggedInInfo, <line3> Date lastDataUpdated, <line4> Facility facility, <line5> Integer demographicId, <line6> Set<Path> documentPaths) <line7> throws IOException, ParseException { <line8> if (""true"" <line9> .equals( <line10> OscarProperties.getInstance() <line11> .getProperty(""integrator.send.documents.disabled"", ""false""))) { <line12> return; <line13> } <line14> List<EDoc> privateDocs = <line15> EDocUtil.listAllDemographicDocsSince(loggedInInfo, demographicId, lastDataUpdated); <line16> StringBuilder sentIds = new StringBuilder(); <line17> for (EDoc eDoc : privateDocs) { <line18> Path documentPath = sendSingleDocument(out, eDoc, demographicId); <line19> if (documentPath == null) { <line20> continue; <line21> } <line22> if (documentPaths != null) { <line23> documentPaths.add(documentPath); <line24> } <line25> documentMetaWriter.println( <line26> eDoc.getDocId() + "","" + demographicId + "","" + documentPath.getFileName()); <line27> sentIds.append("","" + eDoc.getDocId()); <line28> } <line29> conformanceTestLog(facility, ""EDoc"", sentIds.toString()); <line30> } <line31> } <line32> "	<line12>, <line14>
6884	public class A { <line0> public void extract(IItem evidence) { <line1> InputStream is = null; <line2> try { <line3> is = evidence.getBufferedStream(); <line4> extractFile(is, evidence, null); <line5> } catch (IOException e) { <line6> } finally { <line7> IOUtil.closeQuietly(is); <line8> } <line9> } <line10> } <line11> 	<line6>
6885	public class A { <line0> @Override <line1> public void start() throws Exception { <line2> if (externalInitializer != null) { <line3> InetSocketAddress externalLocalAddress = configureInitializer(externalInitializer); <line4> portRegister.register(BoltConnector.NAME, externalLocalAddress); <line5> var host = externalInitializer.address().getHostname(); <line6> var port = externalLocalAddress.getPort(); <line7> } <line8> if (internalInitializer != null) { <line9> var internalLocalAddress = configureInitializer(internalInitializer); <line10> portRegister.register(BoltConnector.INTERNAL_NAME, internalLocalAddress); <line11> var host = internalInitializer.address().getHostname(); <line12> var port = internalLocalAddress.getPort(); <line13> } <line14> } <line15> } <line16> 	<line7>, <line13>
6886	"public class A { <line0> public Page<AuthorizationIntraCloud> getAuthorizationIntraCloudEntries( <line1> final int page, final int size, final Direction direction, final String sortField) { <line2> final int validatedPage = page < 0 ? 0 : page; <line3> final int validatedSize = size <= 0 ? Integer.MAX_VALUE : size; <line4> final Direction validatedDirection = direction == null ? Direction.ASC : direction; <line5> final String validatedSortField = <line6> Utilities.isEmpty(sortField) ? CoreCommonConstants.COMMON_FIELD_NAME_ID : sortField.trim(); <line7> if (!AuthorizationIntraCloud.SORTABLE_FIELDS_BY.contains(validatedSortField)) { <line8> throw new InvalidParameterException( <line9> ""Sortable field with reference '"" + validatedSortField + ""' is not available""); <line10> } <line11> try { <line12> return authorizationIntraCloudRepository.findAll( <line13> PageRequest.of(validatedPage, validatedSize, validatedDirection, validatedSortField)); <line14> } catch (final Exception ex) { <line15> throw new ArrowheadException(CoreCommonConstants.DATABASE_OPERATION_EXCEPTION_MSG); <line16> } <line17> } <line18> } <line19> "	<line2>, <line15>
6887	"public class A { <line0> @Override <line1> public void initExtensions(PluginContext ctx, ExtensionRegistry registry) { <line2> IgniteConfiguration igniteCfg = ctx.igniteConfiguration(); <line3> log = ctx.log(getClass()); <line4> if (igniteCfg.getPluginConfigurations() != null) { <line5> for (PluginConfiguration pluginCfg : igniteCfg.getPluginConfigurations()) { <line6> if (pluginCfg instanceof PageMemoryTrackerConfiguration) { <line7> PageMemoryTrackerConfiguration cfg = (PageMemoryTrackerConfiguration) pluginCfg; <line8> plugin = new PageMemoryTracker(ctx, cfg); <line9> if (cfg.isEnabled() && !CU.isPersistenceEnabled(igniteCfg)) { <line10> log.warning( <line11> ""Page memory tracker plugin enabled, but there are no persistable data regions in"" <line12> + "" configuration. Tracker will be disabled.""); <line13> } <line14> return; <line15> } <line16> } <line17> } <line18> if (Boolean.getBoolean(IGNITE_ENABLE_PAGE_MEMORY_TRACKER) <line19> && CU.isPersistenceEnabled(igniteCfg)) { <line20> plugin = <line21> new PageMemoryTracker( <line22> ctx, <line23> new PageMemoryTrackerConfiguration() <line24> .setEnabled(true) <line25> .setCheckPagesOnCheckpoint(true)); <line26> } else plugin = new PageMemoryTracker(ctx, null); <line27> } <line28> } <line29> "	<line26>
6888	"public class A { <line0> private static String getManagementServerIpInternal() { <line1> String ip = System.getProperty(""management.server.ip""); <line2> if (ip != null) { <line3> return ip; <line4> } <line5> ip = System.getenv(""ZSTACK_MANAGEMENT_SERVER_IP""); <line6> if (ip != null) { <line7> return ip; <line8> } <line9> Linux.ShellResult ret = Linux.shell(""/sbin/ip route""); <line10> String defaultLine = null; <line11> for (String s : ret.getStdout().split(""\n"")) { <line12> if (s.contains(""default via"")) { <line13> defaultLine = s; <line14> break; <line15> } <line16> } <line17> String err = <line18> ""cannot get management server ip of this machine. there are three ways to get the ip.\n"" <line19> + ""1) search for 'management.server.ip' java property\n"" <line20> + ""2) search for 'ZSTACK_MANAGEMENT_SERVER_IP' environment variable\n"" <line21> + ""3) search for default route printed out by '/sbin/ip route'\n"" <line22> + ""however, all above methods failed""; <line23> if (defaultLine == null) { <line24> throw new CloudRuntimeException(err); <line25> } <line26> try { <line27> Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces(); <line28> for (NetworkInterface iface : Collections.list(nets)) { <line29> String name = iface.getName(); <line30> if (defaultLine.contains(name)) { <line31> InetAddress ia = iface.getInetAddresses().nextElement(); <line32> ip = ia.getHostAddress(); <line33> break; <line34> } <line35> } <line36> } catch (SocketException e) { <line37> throw new CloudRuntimeException(e); <line38> } <line39> if (ip == null) { <line40> throw new CloudRuntimeException(err); <line41> } <line42> return ip; <line43> } <line44> } <line45> "	<line3>, <line7>, <line42>
6889	public class A { <line0> public int execUpdate(String query) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> try { <line4> return getConn().createStatement().executeUpdate(query); <line5> } catch (SQLException e) { <line6> if (logger.isDebugEnabled()) { <line7> } <line8> } <line9> return 0; <line10> } <line11> } <line12> 	<line2>, <line7>
6890	"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public <T extends Page> List<T> getVersionHistory(final String pageName) { <line3> List<T> c = null; <line4> try { <line5> if (pageExists(pageName)) { <line6> c = (List<T>) m_provider.getVersionHistory(pageName); <line7> } <line8> if (c == null) { <line9> c = (List<T>) m_engine.getManager(AttachmentManager.class).getVersionHistory(pageName); <line10> } <line11> } catch (final ProviderException e) { <line12> } <line13> return c; <line14> } <line15> } <line16> "	<line12>
6891	public class A { <line0> public Form build() { <line1> Form form = new Form(mode); <line2> if (groupedPropertyAccessors == null) { <line3> configReflectiveFields(); <line4> } <line5> List<PropertyAccessor> allPropertyAccessors = new ArrayList<PropertyAccessor>(); <line6> for (ArrayList<PropertyAccessor> group : groupedPropertyAccessors) { <line7> allPropertyAccessors.addAll(group); <line8> } <line9> removeUnusedSelectionProviders(allPropertyAccessors); <line10> Map<String, Field> fieldMap = new HashMap<String, Field>(); <line11> for (int i = 0; i < groupedPropertyAccessors.size(); i++) { <line12> buildFieldGroup(form, i, fieldMap); <line13> } <line14> for (Map.Entry<String[], SelectionProvider> current : selectionProviders.entrySet()) { <line15> String[] fieldNames = current.getKey(); <line16> SelectionProvider selectionProvider = current.getValue(); <line17> SelectionModel selectionModel = selectionProvider.createSelectionModel(); <line18> SelectField previousField = null; <line19> for (int i = 0; i < fieldNames.length; i++) { <line20> SelectField selectField = (SelectField) fieldMap.get(fieldNames[i]); <line21> selectField.setSelectionModel(selectionModel); <line22> selectField.setSelectionModelIndex(i); <line23> if (previousField != null) { <line24> selectField.setPreviousSelectField(previousField); <line25> previousField.setNextSelectField(selectField); <line26> } <line27> previousField = selectField; <line28> } <line29> } <line30> return form; <line31> } <line32> } <line33> 	<line1>
6892	public class A { <line0> @Override <line1> public boolean moveNext() { <line2> currentRow = null; <line3> if (iteratorBreadcrumb.isEmpty()) { <line4> ProcessGroupStatus rootStatus = context.getEventAccess().getControllerStatus(); <line5> iteratorBreadcrumb.push(rootStatus.getProcessGroupStatus().iterator()); <line6> processorStatusIterator = rootStatus.getProcessorStatus().iterator(); <line7> } <line8> final ProcessorStatus connectionStatus = getNextProcessorStatus(); <line9> if (connectionStatus == null) { <line10> close(); <line11> try { <line12> onFinish(); <line13> } catch (final Exception e) { <line14> } <line15> return false; <line16> } <line17> currentRow = filterColumns(connectionStatus); <line18> recordsRead++; <line19> return true; <line20> } <line21> } <line22> 	<line14>
6893	public class A { <line0> private static boolean canMove(UIComponent child, final UIContainer parent) { <line1> if (parent instanceof org.exoplatform.portal.webui.container.UIContainer) { <line2> org.exoplatform.portal.webui.container.UIContainer targetContainer = <line3> (org.exoplatform.portal.webui.container.UIContainer) parent; <line4> if (child instanceof UIPortlet<?, ?>) { <line5> return targetContainer.hasMoveAppsPermission(); <line6> } else if (child instanceof org.exoplatform.portal.webui.container.UIContainer) { <line7> return targetContainer.hasMoveContainersPermission(); <line8> } else if (child instanceof org.exoplatform.portal.webui.page.UIPageBody) { <line9> return true; <line10> } else { <line11> return false; <line12> } <line13> } else { <line14> return false; <line15> } <line16> } <line17> } <line18> 	<line11>
6894	"public class A { <line0> private Response runFailover(SingularityUser user) { <line1> CompletableFuture.runAsync( <line2> () -> { <line3> abort.abort( <line4> AbortReason.MANUAL, <line5> Optional.of( <line6> new RuntimeException(String.format(""Forced failover by %s"", user.getId())))); <line7> }, <line8> Executors.newSingleThreadExecutor()); <line9> return Response.ok().build(); <line10> } <line11> } <line12> "	<line3>
6895	"public class A { <line0> @Test <line1> public void createDatasetVersionTest() { <line2> CreateDatasetVersion createDatasetVersionRequest = getDatasetVersionRequest(dataset.getId()); <line3> CreateDatasetVersion.Response createDatasetVersionResponse = <line4> datasetVersionServiceStub.createDatasetVersion(createDatasetVersionRequest); <line5> DatasetVersion datasetVersion2 = createDatasetVersionResponse.getDatasetVersion(); <line6> assertEquals( <line7> ""DatasetVersion datsetId not match with expected DatasetVersion datsetId"", <line8> dataset.getId(), <line9> datasetVersion2.getDatasetId()); <line10> DeleteDatasetVersion deleteDatasetVersionRequest = <line11> DeleteDatasetVersion.newBuilder().setId(datasetVersion2.getId()).build(); <line12> DeleteDatasetVersion.Response deleteDatasetVersionResponse = <line13> datasetVersionServiceStub.deleteDatasetVersion(deleteDatasetVersionRequest); <line14> LOGGER.info(""DeleteDatasetVersion deleted successfully""); <line15> LOGGER.info(deleteDatasetVersionResponse.toString()); <line16> createDatasetVersionRequest = getDatasetVersionRequest(dataset.getId()); <line17> createDatasetVersionRequest = <line18> createDatasetVersionRequest.toBuilder() <line19> .setDatasetBlob(CommitTest.getDatasetBlobFromPath(""datasetVersion"").getDataset()) <line20> .build(); <line21> createDatasetVersionResponse = <line22> datasetVersionServiceStub.createDatasetVersion(createDatasetVersionRequest); <line23> DatasetVersion datasetVersion = createDatasetVersionResponse.getDatasetVersion(); <line24> assertEquals( <line25> ""DatasetVersion datsetId not match with expected DatasetVersion datsetId"", <line26> createDatasetVersionRequest.getDatasetBlob(), <line27> datasetVersion.getDatasetBlob()); <line28> deleteDatasetVersionRequest = <line29> DeleteDatasetVersion.newBuilder().setId(datasetVersion.getId()).build(); <line30> deleteDatasetVersionResponse = <line31> datasetVersionServiceStub.deleteDatasetVersion(deleteDatasetVersionRequest); <line32> } <line33> } <line34> "	<line6>, <line24>, <line32>
6896	public class A { <line0> @Override <line1> public void deleted(String pid) { <line2> ServiceRegistration registration = providerRegistrations.remove(pid); <line3> if (registration != null) { <line4> registration.unregister(); <line5> try { <line6> ManagementFactory.getPlatformMBeanServer() <line7> .unregisterMBean(MoodleUserProviderFactory.getObjectName(pid)); <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> } <line13> 	<line2>, <line9>
6897	public class A { <line0> @Override <line1> public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) { <line2> try { <line3> sleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS); <line4> } catch (InterruptedException e) { <line5> Thread.currentThread().interrupt(); <line6> return false; <line7> } <line8> return true; <line9> } <line10> } <line11> 	<line6>
6898	public class A { <line0> private String convertSourceFileName(DataType sourceFileName) { <line1> if (sourceFileName instanceof Text) { <line2> return sourceFileName.toString(); <line3> } else { <line4> return sourceFileName.toString(); <line5> } <line6> } <line7> } <line8> 	<line4>
6899	public class A { <line0> private AuthenticationResult checkCode(AuthenticationSubject subject, String code) { <line1> EntityWithCredential resolved; <line2> try { <line3> resolved = identityResolver.resolveSubject(subject, IDENTITY_TYPES, credentialName); <line4> } catch (Exception e) { <line5> return new AuthenticationResult(Status.deny, null); <line6> } <line7> try { <line8> String dbCredential = resolved.getCredentialValue(); <line9> OTPCredentialDBState credState = JsonUtil.parse(dbCredential, OTPCredentialDBState.class); <line10> boolean valid = <line11> TOTPCodeVerificator.verifyCode( <line12> code, credState.secret, credState.otpParams, credentialConfig.allowedTimeDriftSteps); <line13> if (!valid) { <line14> return new AuthenticationResult(Status.deny, null); <line15> } <line16> AuthenticatedEntity ae = <line17> new AuthenticatedEntity( <line18> resolved.getEntityId(), <line19> subject, <line20> credState.outdated ? resolved.getCredentialName() : null); <line21> return new AuthenticationResult(Status.success, ae); <line22> } catch (Exception e) { <line23> return new AuthenticationResult(Status.deny, null); <line24> } <line25> } <line26> } <line27> 	<line5>, <line14>, <line23>
6900	"public class A { <line0> private ExtractFile getEdOrgExtractFile(final String edOrgId, final String deltaDate) { <line1> ExtractFile ef = null; <line2> Entity efEntity = <line3> getEdOrgExtractFileEntity(appAuthHelper.getApplicationId(), edOrgId, deltaDate); <line4> if (efEntity == null) { <line5> logSecurityEvent(""No bulk extract support for : "" + edOrgId); <line6> } else { <line7> ef = getExtractFile(efEntity); <line8> if (ef == null) { <line9> logSecurityEvent(""No bulk extract file found for : "" + edOrgId); <line10> } <line11> } <line12> return ef; <line13> } <line14> } <line15> "	<line6>, <line10>
6901	public class A { <line0> public void shutdown() { <line1> try { <line2> ldapService.stop(); <line3> service.shutdown(); <line4> if (workingDirectory.exists()) { <line5> FileUtils.deleteDirectory(workingDirectory); <line6> } <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	<line8>
6902	"public class A { <line0> @Override <line1> public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { <line2> Path relativePath = this.from.relativize(dir); <line3> if ("".git"".equals(relativePath.toString())) { <line4> return FileVisitResult.SKIP_SUBTREE; <line5> } <line6> Path targetPath = this.to.resolve(relativePath); <line7> if (!Files.exists(targetPath)) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> Files.createDirectory(targetPath); <line11> } else { <line12> if (log.isDebugEnabled()) { <line13> } <line14> if (FOLDERS_TO_DELETE.contains(targetPath.toFile().getName())) { <line15> if (log.isDebugEnabled()) { <line16> } <line17> deleteRecursively(targetPath); <line18> Files.createDirectory(targetPath); <line19> if (log.isDebugEnabled()) { <line20> } <line21> } <line22> } <line23> return FileVisitResult.CONTINUE; <line24> } <line25> } <line26> "	<line9>, <line13>, <line16>, <line20>
6903	"public class A { <line0> public Observable<Boolean> saveBBSCollection(final BBSCollectionSectionVO vo) { <line1> return RealmObservable.object( <line2> new Func1<Realm, Boolean>() { <line3> @Override <line4> public Boolean call(Realm realm) { <line5> try { <line6> String unitId = <line7> O2SDKManager.Companion.instance() <line8> .prefs() <line9> .getString(O2.INSTANCE.getPRE_BIND_UNIT_ID_KEY(), """"); <line10> BBSCollectionRealmObject object = new BBSCollectionRealmObject(); <line11> object.setId(vo.getId()); <line12> object.setSectionName(vo.getSectionName()); <line13> object.setSectionIcon(vo.getSectionIcon()); <line14> object.setCreateTime(vo.getCreateTime()); <line15> object.setUnitId(unitId); <line16> realm.copyToRealmOrUpdate(object); <line17> return true; <line18> } catch (Exception e) { <line19> return false; <line20> } <line21> } <line22> }); <line23> } <line24> } <line25> "	<line10>, <line19>
6904	public class A { <line0> public FeedMessage getFeedMessage(final String urlString, int timeoutSeconds) <line1> throws ClientProtocolException, IOException { <line2> CloseableHttpResponse response = null; <line3> try { <line4> response = getResponse(urlString, timeoutSeconds); <line5> HttpEntity entity = getEntity(response); <line6> InputStream content = entity.getContent(); <line7> try { <line8> FeedMessage msg = FeedMessage.parseFrom(content); <line9> return msg; <line10> } finally { <line11> content.close(); <line12> } <line13> } catch (Exception e) { <line14> throw e; <line15> } finally { <line16> if (response != null) { <line17> response.close(); <line18> } <line19> } <line20> } <line21> } <line22> 	<line14>
6905	"public class A { <line0> public static List<String> getVMCommand( <line1> Configuration conf, ApplicationId appid, PSAttemptId psAttemptId) { <line2> Vector<String> vargs = new Vector<String>(8); <line3> vargs.add(Environment.JAVA_HOME.$() + ""/bin/java""); <line4> String javaOpts = getChildJavaOpts(conf, appid, psAttemptId); <line5> String[] javaOptsSplit = javaOpts.split("" ""); <line6> for (int i = 0; i < javaOptsSplit.length; i++) { <line7> vargs.add(javaOptsSplit[i]); <line8> } <line9> Path childTmpDir = new Path(Environment.PWD.$(), YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR); <line10> vargs.add(""-Djava.io.tmpdir="" + childTmpDir); <line11> long logSize = 0; <line12> setupLog4jProperties(conf, vargs, logSize); <line13> String psClassName = conf.get(AngelConf.ANGEL_PS_CLASS, AngelConf.DEFAULT_ANGEL_PS_CLASS); <line14> vargs.add(psClassName); <line15> vargs.add(""1>"" + getTaskLogFile(TaskLog.LogName.STDOUT)); <line16> vargs.add(""2>"" + getTaskLogFile(TaskLog.LogName.STDERR)); <line17> StringBuilder mergedCommand = new StringBuilder(); <line18> for (CharSequence str : vargs) { <line19> mergedCommand.append(str).append("" ""); <line20> } <line21> Vector<String> vargsFinal = new Vector<String>(1); <line22> vargsFinal.add(mergedCommand.toString()); <line23> return vargsFinal; <line24> } <line25> } <line26> "	<line23>
6906	"public class A { <line0> private String applyRepositoryUpgradeScripts( <line1> Connection conn, <line2> String dataSourceName, <line3> String repositoryName, <line4> String fromVersion, <line5> String stage) <line6> throws Exception { <line7> Map<String, List<File>> upgradeScriptFiles = <line8> getRepositoryUpgradeScripts(dataSourceName, repositoryName, fromVersion, stage); <line9> Set<String> versions = upgradeScriptFiles.keySet(); <line10> String upgradedToVersion = null; <line11> if (versions.size() > 0) { <line12> for (String version : versions) { <line13> List<File> scriptFiles = upgradeScriptFiles.get(version); <line14> for (File file : scriptFiles) { <line15> if (file.getName().endsWith("".sql"")) { <line16> JDBCTools.runScript(conn, file); <line17> } <line18> } <line19> upgradedToVersion = version; <line20> } <line21> } <line22> return upgradedToVersion; <line23> } <line24> } <line25> "	<line13>, <line16>
6907	"public class A { <line0> @POST <line1> @Path(""submitAndSchedule/{extension-name}"") <line2> @Consumes({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.MULTIPART_FORM_DATA}) <line3> @Produces({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON}) <line4> public APIResult submitAndSchedule( <line5> @PathParam(""extension-name"") String extensionName, <line6> @Context HttpServletRequest request, <line7> @DefaultValue("""") @QueryParam(""doAs"") String doAsUser, <line8> @QueryParam(""jobName"") String jobName, <line9> @FormDataParam(""processes"") List<FormDataBodyPart> processForms, <line10> @FormDataParam(""feeds"") List<FormDataBodyPart> feedForms, <line11> @FormDataParam(""config"") InputStream config) { <line12> throw FalconWebException.newAPIException( <line13> ""submitAndSchedule is not supported on Server. Please run your "" + ""operation on Prism.""); <line14> } <line15> } <line16> "	<line12>
6908	"public class A { <line0> @Override <line1> public Serializable execute(final TaskHandlerActionContext<ActionContext> inActionContext) { <line2> Person ldapPerson = (Person) inActionContext.getActionContext().getParams(); <line3> UpdatePersonResponse response = personMapper.execute(ldapPerson); <line4> if (response.wasUserUpdated()) { <line5> inActionContext <line6> .getUserActionRequests() <line7> .add(new UserActionRequest(""cachePerson"", null, response.getPersonId())); <line8> } <line9> if (response.wasDisplayNameUpdated()) { <line10> inActionContext <line11> .getUserActionRequests() <line12> .addAll(personActivityCacheUpdater.getUpdateCacheRequests(null, response.getPersonId())); <line13> } <line14> return Boolean.TRUE; <line15> } <line16> } <line17> "	<line5>, <line10>
6909	public class A { <line0> public void persist(StgG20Scl transientInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().persist(transientInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
6910	public class A { <line0> @Override <line1> protected void setupMocks() { <line2> Mockito.when(dockerClient.logContainerCmd(anyString())).thenReturn(mockObject); <line3> Mockito.when(mockObject.exec(any())).thenReturn(callback); <line4> try { <line5> Mockito.when(callback.awaitCompletion()).thenReturn(callback); <line6> } catch (InterruptedException e) { <line7> } <line8> } <line9> } <line10> 	<line7>
6911	public class A { <line0> public void remove(String uuid) { <line1> try { <line2> CnATreeElement element = getElement(uuid); <line3> if (element != null) { <line4> remove(element); <line5> } <line6> } catch (Exception t) { <line7> } <line8> } <line9> } <line10> 	<line7>
6912	"public class A { <line0> public String getGitPath(String path) { <line1> Path gitPath = Paths.get(path); <line2> gitPath = gitPath.normalize(); <line3> try { <line4> gitPath = Paths.get(FILE_SEPARATOR).relativize(gitPath); <line5> } catch (IllegalArgumentException e) { <line6> } <line7> if (StringUtils.isEmpty(gitPath.toString())) { <line8> return "".""; <line9> } <line10> String toRet = gitPath.toString(); <line11> toRet = FilenameUtils.separatorsToUnix(toRet); <line12> return toRet; <line13> } <line14> } <line15> "	<line6>
6913	"public class A { <line0> @Override <line1> public Resource generate() { <line2> if (!WARestClient.isReady()) { <line3> throw new RuntimeException(""Syncope core is not yet ready""); <line4> } <line5> OIDCJWKSService service = waRestClient.getSyncopeClient().getService(OIDCJWKSService.class); <line6> OIDCJWKSTO jwksTO = null; <line7> try { <line8> jwksTO = service.get(); <line9> } catch (SyncopeClientException e) { <line10> if (e.getType() == ClientExceptionType.NotFound) { <line11> try { <line12> Response response = service.generate(size, algorithm); <line13> jwksTO = response.readEntity(OIDCJWKSTO.class); <line14> } catch (Exception ge) { <line15> } <line16> } else { <line17> } <line18> } <line19> if (jwksTO == null) { <line20> throw new RuntimeException(""Unable to determine OIDC JWKS resource""); <line21> } <line22> return new ByteArrayResource(jwksTO.getJson().getBytes(StandardCharsets.UTF_8), ""OIDC JWKS""); <line23> } <line24> } <line25> "	<line15>, <line17>
6914	"public class A { <line0> @After <line1> public void tearDown() { <line2> .$(""Tearing down test "") <line3> .$(getClass().getSimpleName()) <line4> .$('#') <line5> .$(testName.getMethodName()) <line6> .$(); <line7> engine.freeTableId(); <line8> engine.clear(); <line9> TestUtils.removeTestPath(root); <line10> configOverrideMaxUncommittedRows = -1; <line11> configOverrideCommitLag = -1; <line12> currentMicros = -1; <line13> } <line14> } <line15> "	<line2>
6915	public class A { <line0> private void basicPut(Object object) throws CacheException, InterruptedException { <line1> try { <line2> this.checkQueueSizeConstraint(); <line3> } catch (InterruptedException ie) { <line4> Thread.currentThread().interrupt(); <line5> this.region.getCache().getCancelCriterion().checkCancelInProgress(ie); <line6> } <line7> Conflatable event = (Conflatable) object; <line8> EventID eventId = event.getEventId(); <line9> ThreadIdentifier ti = getThreadIdentifier(eventId); <line10> long sequenceID = eventId.getSequenceID(); <line11> DispatchedAndCurrentEvents dace = (DispatchedAndCurrentEvents) this.eventsMap.get(ti); <line12> if (dace != null && dace.isGIIDace && puttingGIIDataInQueue.get()) { <line13> dace = null; <line14> } <line15> if (dace != null) { <line16> if (puttingGIIDataInQueue.get() || (sequenceID > dace.lastDispatchedSequenceId)) { <line17> if (!dace.putObject(event, sequenceID)) { <line18> if (!puttingGIIDataInQueue.get()) { <line19> this.put(object); <line20> } <line21> } else { <line22> if (logger.isTraceEnabled(LogMarker.BRIDGE_SERVER_VERBOSE)) { <line23> } <line24> } <line25> } else { <line26> if (logger.isDebugEnabled()) { <line27> } <line28> incrementTakeSidePutPermits(); <line29> } <line30> } else { <line31> dace = new DispatchedAndCurrentEvents(this); <line32> DispatchedAndCurrentEvents oldDace = <line33> (DispatchedAndCurrentEvents) this.eventsMap.putIfAbsent(ti, dace); <line34> if (oldDace != null) { <line35> dace = oldDace; <line36> } else { <line37> this.region.put(ti, dace.lastDispatchedSequenceId); <line38> this.stats.incThreadIdentifiers(); <line39> } <line40> if (!dace.putObject(event, sequenceID)) { <line41> this.put(object); <line42> } else { <line43> if (logger.isTraceEnabled(LogMarker.BRIDGE_SERVER_VERBOSE)) { <line44> } <line45> } <line46> } <line47> } <line48> } <line49> 	<line23>, <line27>, <line44>
6916	public class A { <line0> @Override <line1> public void initialize() { <line2> container.start(); <line3> registerProperties(); <line4> } <line5> } <line6> 	<line2>, <line4>
6917	"public class A { <line0> @Override <line1> protected boolean matchedWhitelist(MailAddress recipientMailAddress, Mail mail) <line2> throws MessagingException { <line3> Connection conn = null; <line4> PreparedStatement selectStmt = null; <line5> ResultSet selectRS = null; <line6> try { <line7> String recipientUser = recipientMailAddress.getLocalPart().toLowerCase(Locale.US); <line8> String recipientHost = recipientMailAddress.getDomain().asString(); <line9> if (conn == null) { <line10> conn = datasource.getConnection(); <line11> } <line12> List<String> nets = new ArrayList<>(); <line13> try { <line14> if (selectStmt == null) { <line15> selectStmt = conn.prepareStatement(selectNetworks); <line16> } <line17> selectStmt.setString(1, recipientUser); <line18> selectStmt.setString(2, recipientHost); <line19> selectRS = selectStmt.executeQuery(); <line20> while (selectRS.next()) { <line21> nets.add(selectRS.getString(1)); <line22> } <line23> } finally { <line24> jdbcUtil.closeJDBCResultSet(selectRS); <line25> jdbcUtil.closeJDBCStatement(selectStmt); <line26> } <line27> NetMatcher matcher = new NetMatcher(nets, dns); <line28> boolean matched = matcher.matchInetNetwork(mail.getRemoteAddr()); <line29> if (!matched) { <line30> try { <line31> selectStmt = conn.prepareStatement(selectNetworks); <line32> selectStmt.setString(1, ""*""); <line33> selectStmt.setString(2, recipientHost); <line34> selectRS = selectStmt.executeQuery(); <line35> nets = new ArrayList<>(); <line36> while (selectRS.next()) { <line37> nets.add(selectRS.getString(1)); <line38> } <line39> } finally { <line40> jdbcUtil.closeJDBCResultSet(selectRS); <line41> jdbcUtil.closeJDBCStatement(selectStmt); <line42> } <line43> matcher = new NetMatcher(nets, dns); <line44> matched = matcher.matchInetNetwork(mail.getRemoteAddr()); <line45> } <line46> return matched; <line47> } catch (SQLException sqle) { <line48> throw new MessagingException(""Exception thrown"", sqle); <line49> } finally { <line50> theJDBCUtil.closeJDBCConnection(conn); <line51> } <line52> } <line53> } <line54> "	<line48>
6918	"public class A { <line0> public boolean startBackupJob(final String jobId) { <line1> try { <line2> final HttpResponse response = post(String.format(""/jobs/%s?action=start"", jobId), null); <line3> return checkTaskStatus(response); <line4> } catch (final IOException e) { <line5> checkResponseTimeOut(e); <line6> } <line7> return false; <line8> } <line9> } <line10> "	<line1>, <line5>
6919	public class A { <line0> @Override <line1> public int createReplicaSet(ReplicaSet rs) { <line2> try { <line3> List<String> rsList = client.getChildren().forPath(replicaSetRoot); <line4> List<Integer> rsIDList = <line5> Lists.transform( <line6> rsList, <line7> new Function<String, Integer>() { <line8> @Nullable <line9> @Override <line10> public Integer apply(@Nullable String input) { <line11> Integer result; <line12> try { <line13> result = Integer.valueOf(input); <line14> } catch (Exception e) { <line15> result = 0; <line16> } <line17> return result; <line18> } <line19> }); <line20> int currMaxID = -1; <line21> if (rsIDList != null && !rsIDList.isEmpty()) { <line22> currMaxID = Collections.max(rsIDList); <line23> } <line24> int newReplicaSetID = currMaxID + 1; <line25> rs.setReplicaSetID(newReplicaSetID); <line26> String replicaSetPath = ZKPaths.makePath(replicaSetRoot, String.valueOf(newReplicaSetID)); <line27> client.create().creatingParentsIfNeeded().forPath(replicaSetPath, serializeReplicaSet(rs)); <line28> writeSuccess.getAndIncrement(); <line29> return newReplicaSetID; <line30> } catch (Exception e) { <line31> writeFail.getAndIncrement(); <line32> throw new StoreException(e); <line33> } <line34> } <line35> } <line36> 	<line25>, <line32>
6920	public class A { <line0> @Override <line1> public Entity createApplicationV2( <line2> String orgName, <line3> String name, <line4> UUID applicationId, <line5> Map<String, Object> properties, <line6> boolean forMigration) <line7> throws Exception { <line8> String appName = buildAppName(orgName, name); <line9> final UUID appId = applicationIdCache.getApplicationId(appName); <line10> if (appId != null) { <line11> throw new ApplicationAlreadyExistsException(name); <line12> } <line13> applicationId = applicationId == null ? UUIDGenerator.newTimeUUID() : applicationId; <line14> if (logger.isDebugEnabled()) { <line15> } <line16> return initializeApplicationV2(orgName, applicationId, appName, properties, forMigration); <line17> } <line18> } <line19> 	<line15>
6921	public class A { <line0> @Override <line1> public void handleError(@Nullable Throwable cause) { <line2> Closeables.closeQuietly(responseInfo); <line3> } <line4> } <line5> 	<line2>
6922	"public class A { <line0> @Override <line1> public void stop(Platform platform) throws Exception { <line2> if (!running.compareAndSet(true, false)) { <line3> throw new IllegalStateException(""ConsumeBenchWorker is not running.""); <line4> } <line5> doneFuture.complete(""""); <line6> executor.shutdownNow(); <line7> executor.awaitTermination(1, TimeUnit.DAYS); <line8> consumer.close(); <line9> this.consumer = null; <line10> this.executor = null; <line11> this.statusUpdater = null; <line12> this.statusUpdaterFuture = null; <line13> this.workerStatus = null; <line14> this.doneFuture = null; <line15> } <line16> } <line17> "	<line5>
6923	public class A { <line0> private JComboBox getOperationsBox() { <line1> JComboBox comboOpe = new JComboBox(); <line2> ArrayList<Operation> opeList = new ArrayList<>(); <line3> try { <line4> opeList.addAll(opeManager.getOperationAdm()); <line5> } catch (OHServiceException ex) { <line6> } <line7> comboOpe.addItem(null); <line8> for (org.isf.operation.model.Operation elem : opeList) { <line9> comboOpe.addItem(elem); <line10> } <line11> comboOpe.setEnabled(true); <line12> return comboOpe; <line13> } <line14> } <line15> 	<line6>
6924	public class A { <line0> @Override <line1> public void reportFillError(Throwable t) { <line2> lock(); <line3> try { <line4> error = t; <line5> done = true; <line6> pageCount = jasperPrint == null ? 0 : jasperPrint.getPages().size(); <line7> fillHandle = null; <line8> pageCondition.signalAll(); <line9> } finally { <line10> unlock(); <line11> } <line12> } <line13> } <line14> 	<line2>
6925	"public class A { <line0> @Override <line1> public void start() { <line2> int numCores = Runtime.getRuntime().availableProcessors(); <line3> int numWorkerThreads = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, numCores); <line4> workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_COMMIT_PROC_SHUTDOWN_TIMEOUT, 5000); <line5> initBatchSizes(); <line6> if (workerPool == null) { <line7> workerPool = new WorkerService(""CommitProcWork"", numWorkerThreads, true); <line8> } <line9> stopped = false; <line10> stoppedMainLoop = false; <line11> super.start(); <line12> } <line13> } <line14> "	<line6>
6926	public class A { <line0> private void createAuditMessage(AuditMessageType messageType, Map<String, String> data) { <line1> lock.lock(); <line2> try { <line3> AuditMessage auditMessage = new AuditMessage(DateUtil.now(), messageIndex, messageType, data); <line4> messages.add(auditMessage); <line5> messageIndex++; <line6> prune(); <line7> } finally { <line8> lock.unlock(); <line9> } <line10> } <line11> } <line12> 	<line6>
6927	public class A { <line0> private void processExecutionChangedEvent(SomfyTahomaEvent event) { <line1> if (FAILED_EVENT.equals(event.getNewState()) || COMPLETED_EVENT.equals(event.getNewState())) { <line2> unregisterExecution(event.getExecId()); <line3> } <line4> } <line5> } <line6> 	<line2>
6928	"public class A { <line0> @Override <line1> public int[] executeBatch(final String[] sql) throws SQLException { <line2> if (sql == null || sql.length == 0) { <line3> throw new NullPointerException(""SQL array must not be empty""); <line4> } <line5> if (logger.isDebugEnabled()) { <line6> } <line7> class BatchUpdateStatementCallback implements StatementCallback<int[]>, SqlProvider { <line8> private String currSql; <line9>  <line10> @Override <line11> public int[] doInStatement(final Statement stmt) throws SQLException { <line12> DatabaseMetaData dbmd = stmt.getConnection().getMetaData(); <line13> int[] rowsAffected = new int[sql.length]; <line14> if (dbmd.supportsBatchUpdates()) { <line15> for (String sqlStmt : sql) { <line16> this.currSql = sqlStmt; <line17> stmt.addBatch(sqlStmt); <line18> } <line19> rowsAffected = stmt.executeBatch(); <line20> } else { <line21> for (int i = 0; i < sql.length; i++) { <line22> this.currSql = sql[i]; <line23> if (!stmt.execute(sql[i])) { <line24> rowsAffected[i] = stmt.getUpdateCount(); <line25> } else { <line26> throw new SQLException(""Invalid batch SQL statement: "" + sql[i]); <line27> } <line28> } <line29> } <line30> return rowsAffected; <line31> } <line32>  <line33> @Override <line34> public String getSql() { <line35> return this.currSql; <line36> } <line37> } <line38> return this.execute(new BatchUpdateStatementCallback()); <line39> } <line40> } <line41> "	<line6>
6929	"public class A { <line0> protected void createJmxRemoteAccessFile(File directory) throws IOFailure { <line1> File jmxFile = new File(directory, Constants.JMX_ACCESS_FILE_NAME); <line2> try { <line3> PrintWriter jw = new PrintWriter(jmxFile, getTargetEncoding()); <line4> try { <line5> jw.print(ScriptConstants.JMXREMOTE_ACCESS_HEADER); <line6> StringBuilder logins = new StringBuilder(); <line7> logins.append(getMonitorUsername()); <line8> logins.append(getHeritrixUsername()); <line9> jw.print(logins.toString()); <line10> } finally { <line11> jw.close(); <line12> } <line13> } catch (IOException e) { <line14> throw new IOFailure(""Cannot create jmxremote.access file."", e); <line15> } <line16> } <line17> } <line18> "	<line14>
6930	"public class A { <line0> @Override <line1> public List<ColumnMetadata> getColumns( <line2> Connection conn, String catalogName, String schemaName, String tableName, String columnName) <line3> throws JdbcMetadataException { <line4> CheckArg.isNotNull(tableName, ""Table name""); <line5> List<ColumnMetadata> columnData = new LinkedList<ColumnMetadata>(); <line6> ResultSet columns = null; <line7> try { <line8> DatabaseMetaData dmd = conn.getMetaData(); <line9> if (catalogName == null) { <line10> catalogName = """"; <line11> } <line12> if (schemaName == null) { <line13> schemaName = """"; <line14> } <line15> columns = dmd.getColumns(catalogName, schemaName, tableName, columnName); <line16> Set<String> columnNames = columnsFor(columns); <line17> while (columns.next()) { <line18> ColumnMetadata column = <line19> new ColumnMetadata( <line20> columns.getString(""COLUMN_NAME""), <line21> columns.getInt(""DATA_TYPE""), <line22> columns.getString(""TYPE_NAME""), <line23> columns.getInt(""COLUMN_SIZE""), <line24> columns.getInt(""DECIMAL_DIGITS""), <line25> columns.getInt(""NUM_PREC_RADIX""), <line26> getNullableBoolean(columns, ""NULLABLE""), <line27> getStringIfPresent(columns, ""REMARKS"", columnNames), <line28> getStringIfPresent(columns, ""COLUMN_DEF"", columnNames), <line29> columns.getInt(""CHAR_OCTET_LENGTH""), <line30> columns.getInt(""ORDINAL_POSITION""), <line31> getStringIfPresent(columns, ""SCOPE_CATLOG"", columnNames), <line32> getStringIfPresent(columns, ""SCOPE_SCHEMA"", columnNames), <line33> getStringIfPresent(columns, ""SCOPE_TABLE"", columnNames), <line34> getIntegerIfPresent(columns, ""SOURCE_DATA_TYPE"", columnNames)); <line35> columnData.add(column); <line36> } <line37> return columnData; <line38> } catch (SQLException se) { <line39> throw new JdbcMetadataException(se); <line40> } finally { <line41> try { <line42> if (columns != null) { <line43> columns.close(); <line44> } <line45> } catch (Exception ignore) { <line46> } <line47> } <line48> } <line49> } <line50> "	<line46>
6931	public class A { <line0> public void update(Map<String, String> properties) { <line1> if (properties != null) { <line2> if (properties.containsKey(ATTRIBUTE_SEPARATOR)) { <line3> setAttributeSeparator(properties.get(ATTRIBUTE_SEPARATOR)); <line4> } <line5> if (properties.containsKey(EXPANSION_FILE_NAME)) { <line6> setExpansionFileName(properties.get(EXPANSION_FILE_NAME)); <line7> } <line8> } <line9> } <line10> } <line11> 	<line1>
6932	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> @DB <line3> public long submitAsyncJob(final AsyncJob job, final String syncObjType, final long syncObjId) { <line4> try { <line5> @SuppressWarnings(""rawtypes"") <line6> final GenericDao dao = GenericDaoBase.getDao(job.getClass()); <line7> if (dao == null) { <line8> throw new CloudRuntimeException( <line9> String.format( <line10> ""Failed to get dao from job's class=%s, for job id=%d, cmd=%s"", <line11> job.getClass(), job.getId(), job.getCmd())); <line12> } <line13> publishOnEventBus(job, ""submit""); <line14> if (!_vmInstanceDao.lockInLockTable(String.valueOf(syncObjId), VmJobLockTimeout.value())) { <line15> throw new CloudRuntimeException( <line16> ""Failed to acquire lock in submitting async job: "" <line17> + job.getCmd() <line18> + "" with timeout value = "" <line19> + VmJobLockTimeout.value()); <line20> } <line21> try { <line22> return Transaction.execute( <line23> new TransactionCallback<Long>() { <line24> @Override <line25> public Long doInTransaction(TransactionStatus status) { <line26> job.setInitMsid(getMsid()); <line27> dao.persist(job); <line28> syncAsyncJobExecution(job, syncObjType, syncObjId, 1); <line29> return job.getId(); <line30> } <line31> }); <line32> } finally { <line33> _vmInstanceDao.unlockFromLockTable(String.valueOf(syncObjId)); <line34> } <line35> } catch (Exception e) { <line36> String errMsg = <line37> ""Unable to schedule async job for command "" + job.getCmd() + "", unexpected exception.""; <line38> throw new CloudRuntimeException(errMsg); <line39> } <line40> } <line41> } <line42> "	<line38>
6933	"public class A { <line0> private static void logSlices(MetricSlice baseSlice, List<MetricSlice> slices) { <line1> final DateTimeFormatter formatter = DateTimeFormat.forStyle(""LL""); <line2> for (MetricSlice slice : slices) { <line3> } <line4> } <line5> } <line6> "	<line2>, <line3>
6934	public class A { <line0> public String getLogoutExternalUrl( <line1> CustomScriptConfiguration customScriptConfiguration, <line2> Map<String, String[]> requestParameters) { <line3> try { <line4> PersonAuthenticationType externalAuthenticator = <line5> (PersonAuthenticationType) customScriptConfiguration.getExternalType(); <line6> Map<String, SimpleCustomProperty> configurationAttributes = <line7> customScriptConfiguration.getConfigurationAttributes(); <line8> return externalAuthenticator.getLogoutExternalUrl(configurationAttributes, requestParameters); <line9> } catch (Exception ex) { <line10> saveScriptError(customScriptConfiguration.getCustomScript(), ex); <line11> } <line12> return null; <line13> } <line14> } <line15> 	<line4>, <line10>
6935	public class A { <line0> private Collection<UserGroup> searchBySPARQLQuery(String q, User user) { <line1> Collection<UserGroup> userGroups = new ArrayList<UserGroup>(); <line2> Search search = SearchFactory.create(); <line3> for (String uri : search.searchString(q, null, null, 0, -1).getResults()) { <line4> try { <line5> userGroups.add((UserGroup) READER.read(uri, user, new UserGroup())); <line6> } catch (ImejiException e) { <line7> } <line8> } <line9> return userGroups; <line10> } <line11> } <line12> 	<line7>
6936	"public class A { <line0> @SuppressWarnings(""java:S2274"") <line1> private ByteBuffer fetchResultAsync() throws IOException { <line2> synchronized (fetchResult) { <line3> fetchResult.set(null); <line4> try { <line5> sourceInfo <line6> .getCurAsyncClient(RaftServer.getReadOperationTimeoutMS()) <line7> .fetchSingleSeries(sourceInfo.getHeader(), sourceInfo.getReaderId(), handler); <line8> fetchResult.wait(RaftServer.getReadOperationTimeoutMS()); <line9> } catch (TException e) { <line10> if (!sourceInfo.switchNode(false, lastTimestamp)) { <line11> return null; <line12> } <line13> return fetchResultAsync(); <line14> } catch (InterruptedException e) { <line15> Thread.currentThread().interrupt(); <line16> return null; <line17> } <line18> } <line19> return fetchResult.get(); <line20> } <line21> } <line22> "	<line16>
6937	"public class A { <line0> @Test <line1> public void testGenerateGroupIdWithEntity() { <line2> app = <line3> ApplicationBuilder.newManagedApp( <line4> EntitySpec.create(TestApplication.class).displayName(""TistApp""), <line5> LocalManagementContextForTests.newInstance()); <line6> TestEntity child = <line7> app.createAndManageChild(EntitySpec.create(TestEntity.class).displayName(""TestEnt"")); <line8> ConfigBag cfg = new ConfigBag().configure(CloudLocationConfig.CALLER_CONTEXT, child); <line9> String result = new BasicCloudMachineNamer().generateNewGroupId(cfg); <line10> Assert.assertTrue(result.length() <= 60); <line11> String user = Strings.maxlen(System.getProperty(""user.name""), 4).toLowerCase(); <line12> Assert.assertTrue(result.indexOf(user) >= 0); <line13> Assert.assertTrue(result.indexOf(""-tistapp-"") >= 0); <line14> Assert.assertTrue(result.indexOf(""-testent-"") >= 0); <line15> Assert.assertTrue(result.indexOf(""-"" + Strings.maxlen(app.getId(), 4).toLowerCase()) >= 0); <line16> Assert.assertTrue(result.indexOf(""-"" + Strings.maxlen(child.getId(), 4).toLowerCase()) >= 0); <line17> } <line18> } <line19> "	<line10>
6938	public class A { <line0> @Override <line1> public boolean validate(Message query, Object context) { <line2> DataQuerySnapshot gdqt = (DataQuerySnapshot) query; <line3> SnapshotSchema schema = <line4> (SnapshotSchema) ((SchemaRegistry) context).getSchema(gdqt.getSchemaKeys()); <line5> Set<String> fields = schema.getValuesDescriptor().getFields().getFields(); <line6> if (!fields.containsAll(gdqt.getFields().getFields())) { <line7> return false; <line8> } <line9> if (gdqt.getFields().getFields().isEmpty()) { <line10> gdqt.setFieldsVal(new Fields(fields)); <line11> } <line12> return true; <line13> } <line14> } <line15> 	<line7>
6939	public class A { <line0> public void setProperty(String key, Object value) { <line1> ExecutionContextProperty property = this.properties.get(key); <line2> if (property == null) { <line3> newProperty(key).declare(); <line4> property = this.properties.get(key); <line5> } else if (property.isFinal()) { <line6> throw new PropertyIsFinalException(key); <line7> } <line8> property.setValue(value); <line9> } <line10> } <line11> 	<line3>
6940	"public class A { <line0> private void makeMemberOutOfSyncDueToDeletion( <line1> String memberLookupName, <line2> SourceGroupConfig<?> groupConfig, <line3> LimitReachedPolicy limitReachedPolicy) { <line4> if (_outOfSyncDueToDeletionTargets.contains(memberLookupName)) return; <line5> String backlogDroppedMsg = <line6> ""backlog for target "" <line7> + memberLookupName <line8> + "" is dropped due to backlog capacity reached ["" <line9> + groupConfig.getBacklogConfig().getLimit(memberLookupName) <line10> + ""]"" <line11> + (limitReachedPolicy == LimitReachedPolicy.DROP_UNTIL_RESYNC <line12> ? "", target will have to perform full recovery upon reconnection"" <line13> : "".""); <line14> logEventInHistory(memberLookupName, backlogDroppedMsg); <line15> if (_logger.isWarnEnabled()) { <line16> } <line17> _outOfSyncDueToDeletionTargets.add(memberLookupName); <line18> boolean backlogDroppedEntirely = true; <line19> String[] membersLookupNames = groupConfig.getMembersLookupNames(); <line20> for (String member : membersLookupNames) { <line21> if (!_outOfSyncDueToDeletionTargets.contains(member)) { <line22> backlogDroppedEntirely = false; <line23> break; <line24> } <line25> } <line26> _backlogDroppedEntirely = backlogDroppedEntirely; <line27> if (_backlogDroppedEntirely) { <line28> if (_logger.isInfoEnabled()) <line29> } <line30> } <line31> } <line32> "	<line16>, <line29>
6941	"public class A { <line0> public boolean dropRole(String roleName) throws SentryClientException { <line1> String dropRoleStmt = ""drop role "" + roleName; <line2> this.sentryJdbcTemplate.execute(dropRoleStmt); <line3> return true; <line4> } <line5> } <line6> "	<line3>
6942	"public class A { <line0> @SuppressWarnings(""PMD.ExcessiveParameterList"") <line1> @Override <line2> public void report( <line3> SortedMap<String, Gauge> gauges, <line4> SortedMap<String, Counter> counters, <line5> SortedMap<String, Histogram> histograms, <line6> SortedMap<String, Meter> meters, <line7> SortedMap<String, Timer> timers) { <line8> try { <line9> for (Map.Entry<String, Gauge> entry : gauges.entrySet()) { <line10> publishMetric(entry.getKey(), entry.getValue()); <line11> } <line12> for (Map.Entry<String, Counter> entry : counters.entrySet()) { <line13> publishMetric(entry.getKey(), entry.getValue()); <line14> } <line15> for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { <line16> publishMetric(entry.getKey(), entry.getValue()); <line17> } <line18> for (Map.Entry<String, Meter> entry : meters.entrySet()) { <line19> publishMetric(entry.getKey(), entry.getValue()); <line20> } <line21> for (Map.Entry<String, Timer> entry : timers.entrySet()) { <line22> publishMetric(entry.getKey(), entry.getValue()); <line23> } <line24> } catch (RuntimeException ex) { <line25> } <line26> } <line27> } <line28> "	<line25>
6943	"public class A { <line0> @Scheduled(fixedDelayString = ""${statistics.key.interval.delay:3600000}"") <line1> private void setLatestStatisticsTimeline() { <line2> Map<StatisticsEnum, StatisticsTimeline> latestStatisticsTimelineMap = <line3> new HashMap<StatisticsEnum, StatisticsTimeline>(); <line4> for (StatisticsEnum type : StatisticsEnum.values()) { <line5> StatisticsTimeline statisticsTimeline = <line6> statisticsManagerReadOnly.getStatisticsTimelineModel(type); <line7> latestStatisticsTimelineMap.put(type, statisticsTimeline); <line8> } <line9> if (!statisticsCache.containsKey(CACHE_TIMELINE_KEY)) { <line10> statisticsCache.put(CACHE_TIMELINE_KEY, latestStatisticsTimelineMap); <line11> } else { <line12> statisticsCache.replace(CACHE_TIMELINE_KEY, latestStatisticsTimelineMap); <line13> } <line14> } <line15> } <line16> "	<line2>, <line14>
6944	"public class A { <line0> private TrackJobResult copyTrack(final Track track) throws WorkflowOperationException { <line1> final Track copiedTrack = (Track) track.clone(); <line2> copiedTrack.setIdentifier(UUID.randomUUID().toString()); <line3> try { <line4> String targetFilename = copiedTrack.getIdentifier(); <line5> final String extension = FilenameUtils.getExtension(track.getURI().getPath()); <line6> if (!extension.isEmpty()) { <line7> targetFilename += ""."" + extension; <line8> } <line9> final URI newUri = <line10> workspace.put( <line11> track.getMediaPackage().getIdentifier().toString(), <line12> copiedTrack.getIdentifier(), <line13> targetFilename, <line14> workspace.read(track.getURI())); <line15> copiedTrack.setURI(newUri); <line16> } catch (IOException | NotFoundException e) { <line17> throw new WorkflowOperationException( <line18> String.format(""Error while copying track %s"", track.getIdentifier()), e); <line19> } <line20> return new TrackJobResult(copiedTrack, 0); <line21> } <line22> } <line23> "	<line1>
6945	"public class A { <line0> @Override <line1> public String getLogoutRedirectionUrl(WebContext context) { <line2> init(); <line3> final String state = RandomStringUtils.randomAlphanumeric(10); <line4> final String postLogoutRedirectUri = this.appConfiguration.getOpenIdPostLogoutRedirectUri(); <line5> String idToken = (String) context.getSessionAttribute(getName() + SESSION_ID_TOKEN_PARAMETER); <line6> if (idToken == null) { <line7> idToken = """"; <line8> } <line9> final EndSessionRequest endSessionRequest = <line10> new EndSessionRequest(idToken, postLogoutRedirectUri, state); <line11> final String redirectionUrl = <line12> this.openIdConfiguration.getEndSessionEndpoint() + ""?"" + endSessionRequest.getQueryString(); <line13> return redirectionUrl; <line14> } <line15> } <line16> "	<line13>
6946	"public class A { <line0> private static String transform(Bundle bundle) throws ModuleManagementException { <line1> try { <line2> PersistentBundle persistentBundle = ModuleUtils.persist(bundle); <line3> String newLocation = persistentBundle.getLocation(); <line4> return newLocation; <line5> } catch (ModuleManagementException e) { <line6> throw e; <line7> } catch (Exception e) { <line8> String msg = ""Unable to transform bundle "" + bundle + "". Cause: "" + e.getMessage(); <line9> throw new ModuleManagementException(msg, e); <line10> } <line11> } <line12> } <line13> "	<line4>, <line9>
6947	"public class A { <line0> public void configure(final Configuration config) throws ConfigurationException { <line1> try { <line2> setServerConfig(config); <line3> setAttachmentDir(config); <line4> setJWSDir(config); <line5> setSecurityProvider(config); <line6> setTransportName(config); <line7> setManagedServices(config); <line8> if (getLogger().isDebugEnabled()) { <line9> } <line10> } catch (final Exception e) { <line11> throw new ConfigurationException(""Error during configuration"", e); <line12> } <line13> } <line14> } <line15> "	<line9>
6948	"public class A { <line0> private void loadTAEParams() { <line1> String filename = ""org/openscience/cdk/qsar/descriptors/data/taepeptides.txt""; <line2> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line3> if (ins == null) { <line4> taeParams = null; <line5> return; <line6> } <line7> try { <line8> BufferedReader breader = new BufferedReader(new InputStreamReader(ins)); <line9> breader.readLine(); <line10> for (int i = 0; i < 60; i++) { <line11> String line = breader.readLine(); <line12> String[] components = line.split("",""); <line13> if (components.length != (ndesc + 1)) <line14> throw new CDKException(""TAE peptide data table seems to be corrupt""); <line15> String key = components[0].toLowerCase().trim(); <line16> Double[] data = new Double[ndesc]; <line17> for (int j = 1; j < components.length; j++) data[j - 1] = new Double(components[j]); <line18> taeParams.put(key, data); <line19> } <line20> } catch (IOException ioe) { <line21> ioe.printStackTrace(); <line22> taeParams = null; <line23> return; <line24> } catch (CDKException e) { <line25> e.printStackTrace(); <line26> taeParams = null; <line27> return; <line28> } <line29> } <line30> } <line31> "	<line4>, <line29>
6949	public class A { <line0> @Override <line1> public Iterator<ResultsGroup> iterator(long first, long count) { <line2> if (query == null) { <line3> pagesCacheModel.getObject().clear(); <line4> return IteratorUtils.emptyIterator(); <line5> } <line6> if (pagesCacheModel.getObject().containsPage(first, count)) { <line7> return pagesCacheModel.getObject().getPage(first, count).iterator(); <line8> } <line9> try { <line10> List<ResultsGroup> queryResults = <line11> searchService <line12> .query( <line13> user, project, query, document, annotationLayer, annotationFeature, first, count) <line14> .entrySet() <line15> .stream() <line16> .map(e -> new ResultsGroup(e.getKey(), e.getValue())) <line17> .collect(Collectors.toList()); <line18> pagesCacheModel.getObject().putPage(first, count, queryResults); <line19> return queryResults.iterator(); <line20> } catch (IOException | ExecutionException e) { <line21> return emptyIterator(); <line22> } <line23> } <line24> } <line25> 	<line21>
6950	public class A { <line0> private static @Nullable JAXBContext initJAXBContextTemplates() { <line1> try { <line2> return JAXBContext.newInstance(TemplateListModel.class); <line3> } catch (JAXBException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	<line4>
6951	"public class A { <line0> @ResponseBody <line1> @RequestMapping( <line2> value = ""/settings"", <line3> produces = MediaType.APPLICATION_JSON_VALUE, <line4> method = RequestMethod.GET) <line5> public List<UserSettingsPojo> getUserSettings( <line6> @RequestParam(name = ""uri"", required = false) String uri) { <line7> String username = SecurityContextHolder.getContext().getAuthentication().getName(); <line8> User user = userService.getByUsername(username); <line9> List<UserSettingsPojo> userSettings = new ArrayList<UserSettingsPojo>(); <line10> if (uri != null) { <line11> URI atomUri = null; <line12> try { <line13> atomUri = new URI(uri); <line14> for (UserAtom userAtom : user.getUserAtoms()) { <line15> if (userAtom.getUri().equals(atomUri)) { <line16> userSettings.add( <line17> new UserSettingsPojo( <line18> user.getUsername(), <line19> user.getEmail(), <line20> userAtom.getUri(), <line21> userAtom.isMatches(), <line22> userAtom.isRequests(), <line23> userAtom.isConversations())); <line24> break; <line25> } <line26> } <line27> } catch (URISyntaxException e) { <line28> } <line29> } else { <line30> for (UserAtom userAtom : user.getUserAtoms()) { <line31> if (userAtom.getState() != AtomState.DELETED) { <line32> userSettings.add( <line33> new UserSettingsPojo( <line34> user.getUsername(), <line35> user.getEmail(), <line36> userAtom.getUri(), <line37> userAtom.isMatches(), <line38> userAtom.isRequests(), <line39> userAtom.isConversations())); <line40> } <line41> } <line42> } <line43> return userSettings; <line44> } <line45> } <line46> "	<line7>, <line28>
6952	public class A { <line0> private void runAsyncImageBuild(Exchange exchange, Message message, DockerClient client) <line1> throws DockerException, InterruptedException { <line2> try (BuildImageCmd cmd = executeBuildImageRequest(client, message)) { <line3> BuildImageResultCallback item = <line4> cmd.exec( <line5> new BuildImageResultCallback() { <line6> @Override <line7> public void onNext(BuildResponseItem item) { <line8> super.onNext(item); <line9> exchange.getIn().setBody(item.getImageId()); <line10> } <line11> }); <line12> setResponse(exchange, item); <line13> } <line14> } <line15> } <line16> 	<line9>
6953	"public class A { <line0> public Date parseDate(String str) { <line1> SimpleDateFormat date; <line2> try { <line3> if (str.matches(""^....-..-..T..:..:..\\....Z$"")) { <line4> date = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'""); <line5> date.setTimeZone(TimeZone.getTimeZone(""GMT"")); <line6> return date.parse(str); <line7> } else if (str.matches(""^........T......Z$"")) { <line8> date = new SimpleDateFormat(""yyyyMMdd'T'HHmmss'Z'""); <line9> date.setTimeZone(TimeZone.getTimeZone(""GMT"")); <line10> return date.parse(str); <line11> } <line12> } catch (ParseException e) { <line13> } <line14> return null; <line15> } <line16> } <line17> "	<line13>
6954	public class A { <line0> public ZigBeeStatus permitJoin(final ZigBeeEndpointAddress destination, final int duration) { <line1> if (duration < 0 || duration >= 255) { <line2> return ZigBeeStatus.INVALID_ARGUMENTS; <line3> } <line4> ManagementPermitJoiningRequest command = new ManagementPermitJoiningRequest(duration, true); <line5> command.setDestinationAddress(destination); <line6> command.setSourceAddress(new ZigBeeEndpointAddress(0)); <line7> sendTransaction(command); <line8> if (ZigBeeBroadcastDestination.isBroadcast(destination.getAddress())) { <line9> command = new ManagementPermitJoiningRequest(duration, true); <line10> command.setDestinationAddress(new ZigBeeEndpointAddress(0)); <line11> command.setSourceAddress(new ZigBeeEndpointAddress(0)); <line12> sendTransaction(command); <line13> } <line14> return ZigBeeStatus.SUCCESS; <line15> } <line16> } <line17> 	<line2>, <line4>
6955	"public class A { <line0> @Test <line1> public void testInsufficientArgsLogsErrorForWarn() { <line2> String format = ""some message: %s, %d""; <line3> String param = ""blah""; <line4> assertLogLike( <line5> Level.SEVERE, <line6> ImmutableList.of(""Invalid format"", ""WARN"", format, param), <line7> IllegalArgumentException.class); <line8> assertLog(Level.WARNING, String.format(""'%s' [%s]"", format, param)); <line9> } <line10> } <line11> "	<line4>
6956	"public class A { <line0> public String save() throws Exception { <line1> user.setEnabled(true); <line2> user.addRole(roleManager.getRole(Constants.USER_ROLE)); <line3> try { <line4> user = userManager.saveUser(user); <line5> } catch (AccessDeniedException ade) { <line6> getResponse().sendError(HttpServletResponse.SC_FORBIDDEN); <line7> return null; <line8> } catch (UserExistsException e) { <line9> addMessage(""errors.existing.user"", new Object[] {user.getUsername(), user.getEmail()}); <line10> user.setPassword(user.getConfirmPassword()); <line11> return null; <line12> } <line13> addMessage(""user.registered""); <line14> getSession().setAttribute(Constants.REGISTERED, Boolean.TRUE); <line15> UsernamePasswordAuthenticationToken auth = <line16> new UsernamePasswordAuthenticationToken( <line17> user.getUsername(), user.getConfirmPassword(), user.getAuthorities()); <line18> auth.setDetails(user); <line19> SecurityContextHolder.getContext().setAuthentication(auth); <line20> message.setSubject(getText(""signup.email.subject"")); <line21> try { <line22> sendUserMessage(user, getText(""signup.email.message""), RequestUtil.getAppURL(getRequest())); <line23> } catch (MailException me) { <line24> addError(me.getMostSpecificCause().getMessage()); <line25> return null; <line26> } <line27> return ""home""; <line28> } <line29> } <line30> "	<line6>
6957	"public class A { <line0> @Override <line1> protected void validateConnection(Map<String, ConfigValue> configValues, Configuration config) { <line2> final ConfigValue databaseValue = <line3> configValues.get(RelationalDatabaseConnectorConfig.DATABASE_NAME.name()); <line4> if (!databaseValue.errorMessages().isEmpty()) { <line5> return; <line6> } <line7> final ConfigValue hostnameValue = <line8> configValues.get(RelationalDatabaseConnectorConfig.HOSTNAME.name()); <line9> final ConfigValue userValue = configValues.get(RelationalDatabaseConnectorConfig.USER.name()); <line10> OracleConnectorConfig connectorConfig = new OracleConnectorConfig(config); <line11> try (OracleConnection connection = <line12> new OracleConnection(connectorConfig.jdbcConfig(), () -> getClass().getClassLoader())) { <line13> } catch (SQLException | RuntimeException e) { <line14> hostnameValue.addErrorMessage(""Unable to connect: "" + e.getMessage()); <line15> } <line16> } <line17> } <line18> "	<line13>, <line14>
6958	"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> protected KStream<?, ?> getKStream( <line2> String inboundName, <line3> BindingProperties bindingProperties, <line4> KafkaStreamsConsumerProperties kafkaStreamsConsumerProperties, <line5> StreamsBuilder streamsBuilder, <line6> Serde<?> keySerde, <line7> Serde<?> valueSerde, <line8> Topology.AutoOffsetReset autoOffsetReset, <line9> boolean firstBuild) { <line10> if (firstBuild) { <line11> addStateStoreBeans(streamsBuilder); <line12> } <line13> final boolean nativeDecoding = <line14> this.bindingServiceProperties.getConsumerProperties(inboundName).isUseNativeDecoding(); <line15> if (nativeDecoding) { <line16> } else { <line17> } <line18> KStream<?, ?> stream; <line19> final Serde<?> valueSerdeToUse = <line20> StringUtils.hasText(kafkaStreamsConsumerProperties.getEventTypes()) <line21> ? new Serdes.BytesSerde() <line22> : valueSerde; <line23> final Consumed<?, ?> consumed = <line24> getConsumed(kafkaStreamsConsumerProperties, keySerde, valueSerdeToUse, autoOffsetReset); <line25> if (this.kafkaStreamsExtendedBindingProperties <line26> .getExtendedConsumerProperties(inboundName) <line27> .isDestinationIsPattern()) { <line28> final Pattern pattern = <line29> Pattern.compile(this.bindingServiceProperties.getBindingDestination(inboundName)); <line30> stream = streamsBuilder.stream(pattern, consumed); <line31> } else { <line32> String[] bindingTargets = <line33> StringUtils.commaDelimitedListToStringArray( <line34> this.bindingServiceProperties.getBindingDestination(inboundName)); <line35> stream = streamsBuilder.stream(Arrays.asList(bindingTargets), consumed); <line36> } <line37> if (StringUtils.hasText(kafkaStreamsConsumerProperties.getEventTypes())) { <line38> AtomicBoolean matched = new AtomicBoolean(); <line39> stream.process(() -> eventTypeProcessor(kafkaStreamsConsumerProperties, matched)); <line40> final KStream<?, ?>[] branch = stream.branch((key, value) -> matched.getAndSet(false)); <line41> final KStream<?, Object> deserializedKStream = <line42> branch[0].mapValues( <line43> value -> valueSerde.deserializer().deserialize(null, ((Bytes) value).get())); <line44> return getkStream(bindingProperties, deserializedKStream, nativeDecoding); <line45> } <line46> return getkStream(bindingProperties, stream, nativeDecoding); <line47> } <line48> } <line49> "	<line16>, <line17>
6959	public class A { <line0> public void invalidate(Connection affectedConnection, JMSException e) { <line1> if (isClosing()) { <line2> return; <line3> } <line4> synchronized (m_connectionFunction) { <line5> if (m_impl != affectedConnection) { <line6> return; <line7> } <line8> if (isClosing()) { <line9> return; <line10> } <line11> try { <line12> try { <line13> int n = m_sessionWrappers.size(); <line14> int i = 0; <line15> for (JmsSessionProviderWrapper s : m_sessionWrappers.keySet()) { <line16> i++; <line17> s.invalidate(); <line18> } <line19> } finally { <line20> if (m_impl != null) { <line21> try { <line22> m_impl.close(); <line23> } finally { <line24> m_impl = null; <line25> } <line26> } <line27> } <line28> } catch (JMSException e2) { <line29> BEANS.get(MomExceptionHandler.class).handle(e2); <line30> } <line31> } <line32> } <line33> } <line34> 	<line14>, <line17>, <line22>, <line23>
6960	public class A { <line0> private ManagerResponse exec(ManagerAction action) { <line1> if (factory == null) { <line2> return null; <line3> } <line4> try { <line5> connectManager(); <line6> ManagerResponse r = con.sendAction(action); <line7> if (r != null) { <line8> } <line9> return (r instanceof ManagerError) ? null : r; <line10> } catch (Exception e) { <line11> } <line12> return null; <line13> } <line14> } <line15> 	<line2>, <line8>, <line11>
6961	"public class A { <line0> protected JsonElement invokeRPC(String methodName, Object[] args) { <line1> int id = rand.nextInt(Integer.MAX_VALUE); <line2> JsonObject req = new JsonObject(); <line3> req.addProperty(""jsonrpc"", ""2.0""); <line4> req.addProperty(""id"", id); <line5> req.addProperty(""method"", methodName); <line6> JsonElement result = null; <line7> JsonArray params = new JsonArray(); <line8> if (args != null) { <line9> for (Object o : args) { <line10> params.add(gson.toJsonTree(o)); <line11> } <line12> } <line13> req.add(""params"", params); <line14> String requestData = req.toString(); <line15> String responseData = null; <line16> try { <line17> responseData = post(url, headers, requestData); <line18> } catch (Exception e) { <line19> } <line20> if (responseData != null) { <line21> JsonObject resp = (JsonObject) JsonParser.parseReader(new StringReader(responseData)); <line22> result = resp.get(""result""); <line23> JsonElement error = resp.get(""error""); <line24> if (error != null && !error.isJsonNull()) { <line25> if (error.isJsonPrimitive()) { <line26> } else if (error.isJsonObject()) { <line27> JsonObject o = error.getAsJsonObject(); <line28> Integer code = (o.has(""code"") ? o.get(""code"").getAsInt() : null); <line29> String message = (o.has(""message"") ? o.get(""message"").getAsString() : null); <line30> String data = <line31> (o.has(""data"") <line32> ? (o.get(""data"") instanceof JsonObject <line33> ? o.get(""data"").toString() <line34> : o.get(""data"").getAsString()) <line35> : null); <line36> } else { <line37> } <line38> } <line39> } <line40> return result; <line41> } <line42> } <line43> "	<line19>, <line21>, <line26>, <line36>, <line37>
6962	"public class A { <line0> public void process(final Exchange exchange) throws Exception { <line1> Message message = exchange.getIn(); <line2> WonMessage wonMessage = (WonMessage) message.getHeader(WonCamelConstants.MESSAGE_HEADER); <line3> URI senderSocket = wonMessage.getSenderSocketURIRequired(); <line4> URI recipientSocket = wonMessage.getRecipientSocketURIRequired(); <line5> Connection con = <line6> connectionRepository <line7> .findOneBySocketURIAndTargetSocketURIForUpdate(recipientSocket, senderSocket) <line8> .get(); <line9> entityManager.refresh(con); <line10> if (con.getState() != ConnectionState.CONNECTED) { <line11> throw new IllegalMessageForConnectionStateException( <line12> con.getConnectionURI(), ""CONNECTION_MESSAGE"", con.getState()); <line13> } <line14> if (logger.isDebugEnabled()) { <line15> if (!wonMessage.getForwardedMessageURIs().isEmpty()) { <line16> } <line17> } <line18> } <line19> } <line20> "	<line15>, <line16>
6963	public class A { <line0> private void onResponse(CoreEvent event, Throwable error) { <line1> if (event != null && successConsumer != null) { <line2> try { <line3> successConsumer.accept(event.getMessage()); <line4> } catch (Exception e) { <line5> } <line6> } else if (error != null && errorConsumer != null) { <line7> Exception exception = <line8> error instanceof Exception ? (Exception) error : new MessagingException(event, error); <line9> try { <line10> errorConsumer.accept(exception); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> } <line16> 	<line5>, <line12>
6964	"public class A { <line0> private VoLimitedTextField getJAgeToTextField() { <line1> if (jAgeToTextField == null) { <line2> jAgeToTextField = new VoLimitedTextField(3, 2); <line3> jAgeToTextField.setText(""0""); <line4> jAgeToTextField.setMaximumSize(new Dimension(100, 50)); <line5> ageTo = 0; <line6> jAgeToTextField.addFocusListener( <line7> new FocusListener() { <line8> @Override <line9> public void focusLost(FocusEvent e) { <line10> try { <line11> ageTo = Integer.parseInt(jAgeToTextField.getText()); <line12> if (ageTo < 0 || ageTo > 200) { <line13> jAgeToTextField.setText(""""); <line14> } <line15> } catch (NumberFormatException ex) { <line16> jAgeToTextField.setText(""""); <line17> } <line18> } <line19>  <line20> @Override <line21> public void focusGained(FocusEvent e) {} <line22> }); <line23> } <line24> return jAgeToTextField; <line25> } <line26> } <line27> "	<line14>
6965	"public class A { <line0> @Override <line1> public final void onMessage(final ObjectMessage message) { <line2> if (!isRunning()) { <line3> notifyError( <line4> ""Plugin \"""" <line5> + getName() <line6> + ""\"" receives a command while is not running. Turn on the plugin first ""); <line7> return; <line8> } <line9> Object payload; <line10> try { <line11> payload = message.getObject(); <line12> if (payload instanceof Command) { <line13> final Command command = (Command) payload; <line14> Protocol.ActuatorOnCommandRunnable action; <line15> lastDestination = message.getJMSReplyTo(); <line16> action = <line17> new Protocol.ActuatorOnCommandRunnable( <line18> command, message.getJMSReplyTo(), message.getJMSCorrelationID()); <line19> Protocol.ActuatorPerforms task = <line20> new Protocol.ActuatorPerforms( <line21> getApi().getAuth().pluginBindRunnablePrivileges(this, action)); <line22> task.start(); <line23> } else { <line24> if (payload instanceof EventTemplate) { <line25> final EventTemplate event = (EventTemplate) payload; <line26> Protocol.ActuatorOnEventRunnable r = new Protocol.ActuatorOnEventRunnable(event); <line27> Protocol.ActuatorPerforms task = <line28> new Protocol.ActuatorPerforms( <line29> getApi().getAuth().pluginBindRunnablePrivileges(this, r)); <line30> task.start(); <line31> } <line32> } <line33> } catch (JMSException ex) { <line34> } <line35> } <line36> } <line37> "	<line14>, <line34>
6966	public class A { <line0> private void tryToSend(final RequestContext requestContext) { <line1> if (requestContext.isDone()) { <line2> if (LOG.isTraceEnabled()) { <line3> } <line4> return; <line5> } <line6> final var calculateTimeout = requestContext.calculateTimeout(); <line7> if (calculateTimeout.toMillis() <= 0L) { <line8> if (LOG.isTraceEnabled()) { <line9> } <line10> return; <line11> } <line12> final var nodeAddress = requestContext.getNodeAddress(); <line13> if (nodeAddress == null) { <line14> if (requestContext.shouldRetry()) { <line15> if (LOG.isTraceEnabled()) { <line16> } <line17> actor.runDelayed(RETRY_DELAY, () -> tryToSend(requestContext)); <line18> } else { <line19> if (LOG.isTraceEnabled()) { <line20> } <line21> requestContext.completeExceptionally( <line22> new ConnectException( <line23> String.format( <line24> NO_REMOTE_ADDRESS_FOUND_ERROR_MESSAGE, requestContext.getTopicName()))); <line25> } <line26> return; <line27> } <line28> if (LOG.isTraceEnabled()) { <line29> } <line30> final var requestBytes = requestContext.getRequestBytes(); <line31> messagingService <line32> .sendAndReceive(nodeAddress, requestContext.getTopicName(), requestBytes, calculateTimeout) <line33> .whenComplete( <line34> (response, errorOnRequest) -> <line35> actor.run(() -> handleResponse(requestContext, response, errorOnRequest))); <line36> } <line37> } <line38> 	<line3>, <line9>, <line16>, <line20>, <line29>
6967	public class A { <line0> static Method findMethod(String className, String methodName, Class<?>... parameterTypes) { <line1> try { <line2> Class<?> aClass = Class.forName(className, false, TaskExecutors.class.getClassLoader()); <line3> Method method = aClass.getDeclaredMethod(methodName, parameterTypes); <line4> method.setAccessible(true); <line5> return method; <line6> } catch (Exception e) { <line7> return null; <line8> } <line9> } <line10> } <line11> 	<line7>
6968	public class A { <line0> @Activate <line1> public void activate(ComponentContext cc) throws Exception { <line2> BundleContext bundleCtx = cc.getBundleContext(); <line3> adminUserName = <line4> StringUtils.trimToNull(bundleCtx.getProperty(SecurityConstants.GLOBAL_ADMIN_USER_PROPERTY)); <line5> adminPassword = StringUtils.trimToNull(bundleCtx.getProperty(OPT_ADMIN_PASSWORD)); <line6> adminEmail = StringUtils.trimToNull(bundleCtx.getProperty(OPT_ADMIN_EMAIL)); <line7> adminRoles = StringUtils.trimToNull(bundleCtx.getProperty(OPT_ADMIN_ROLES)); <line8> if (DEFAULT_ADMIN_PASSWORD_CONFIGURATION.equals(adminPassword)) { <line9> } <line10> componentCtx = cc; <line11> for (final Organization organization : organizationDirectoryService.getOrganizations()) { <line12> createSystemAdministratorUserAndGroup(organization); <line13> } <line14> } <line15> } <line16> 	<line2>, <line9>
6969	"public class A { <line0> @Override <line1> public RestMethodResult doPost(final Map<String, Object> propertySet) throws FrameworkException { <line2> final GraphObject sourceNode = typedIdResource.getEntity(); <line3> RestMethodResult result = null; <line4> if (sourceNode != null && propertyKey != null && propertyKey instanceof RelationProperty) { <line5> final RelationProperty relationProperty = (RelationProperty) propertyKey; <line6> final Class sourceNodeType = sourceNode.getClass(); <line7> NodeInterface newNode = null; <line8> if (propertyKey.isReadOnly()) { <line9> return null; <line10> } <line11> final Notion notion = relationProperty.getNotion(); <line12> final PropertyKey primaryPropertyKey = notion.getPrimaryPropertyKey(); <line13> if (primaryPropertyKey != null <line14> && propertySet.containsKey(primaryPropertyKey.jsonName()) <line15> && propertySet.size() == 1) { <line16> } else { <line17> newNode = typeResource.createNode(propertySet); <line18> if (newNode != null) { <line19> relationProperty.addSingleElement(securityContext, sourceNode, newNode); <line20> } <line21> } <line22> if (newNode != null) { <line23> result = new RestMethodResult(HttpServletResponse.SC_CREATED); <line24> result.addHeader(""Location"", buildLocationHeader(newNode)); <line25> return result; <line26> } <line27> } else { <line28> this.isCollectionResource = false; <line29> final Class entityType = typedIdResource.getTypeResource().getEntityClass(); <line30> final String methodName = typeResource.getRawType(); <line31> try { <line32> final SchemaMethod method = SchemaMethodResource.findMethod(entityType, methodName); <line33> final String source = method.getProperty(SchemaMethod.source); <line34> result = <line35> SchemaMethodResource.invoke( <line36> securityContext, <line37> typedIdResource.getEntity(), <line38> source, <line39> propertySet, <line40> methodName, <line41> method.getUuid()); <line42> } catch (IllegalPathException ex) { <line43> try { <line44> result = <line45> SchemaMethodResource.wrapInResult( <line46> typedIdResource <line47> .getEntity() <line48> .invokeMethod( <line49> securityContext, methodName, propertySet, true, new EvaluationHints())); <line50> } catch (Throwable t) { <line51> } <line52> } <line53> } <line54> if (result == null) { <line55> throw new IllegalPathException(""Illegal path""); <line56> } else { <line57> return result; <line58> } <line59> } <line60> } <line61> "	<line9>, <line51>
6970	public class A { <line0> @Override <line1> public Void execute() { <line2> behaviourFilter.disableBehaviour(nodeRef, TYPE_DISPOSITION_ACTION_DEFINITION); <line3> try { <line4> if (nodeService.exists(nodeRef) <line5> && nodeService.hasAspect(nodeRef, ASPECT_UNPUBLISHED_UPDATE)) { <line6> if (logger.isDebugEnabled()) { <line7> } <line8> nodeService.setProperty(nodeRef, PROP_PUBLISH_IN_PROGRESS, false); <line9> } <line10> } finally { <line11> behaviourFilter.enableBehaviour(nodeRef, TYPE_DISPOSITION_ACTION_DEFINITION); <line12> } <line13> return null; <line14> } <line15> } <line16> 	<line7>
6971	public class A { <line0> @Override <line1> protected void handleJavaScriptException( <line2> ScriptException scriptException, boolean triggerOnError) { <line3> final InteractivePage page = scriptException.getPage(); <line4> if (triggerOnError && page != null) { <line5> final WebWindow window = page.getEnclosingWindow(); <line6> if (window != null) { <line7> final Window w = (Window) window.getScriptableObject(); <line8> if (w != null) { <line9> try { <line10> triggerOnError(w, scriptException); <line11> } catch (final Exception e) { <line12> handleJavaScriptException(new ScriptException(page, e, null), false); <line13> } <line14> } <line15> } <line16> } <line17> final JavaScriptErrorListener javaScriptErrorListener = <line18> getWebClient().getJavaScriptErrorListener(); <line19> if (javaScriptErrorListener != null) { <line20> javaScriptErrorListener.scriptException(page, scriptException); <line21> } <line22> if (getWebClient().getOptions().isThrowExceptionOnScriptError()) { <line23> throw scriptException; <line24> } <line25> } <line26> } <line27> 	<line25>
6972	"public class A { <line0> protected void init(StartupStrategy startupStrategy) { <line1> for (KieServerStateRepository repo : serverStateRepos) { <line2> if (repo.getClass().getSimpleName().equals(startupStrategy.getRepositoryType())) { <line3> this.repository = repo; <line4> break; <line5> } <line6> } <line7> this.context = new KieServerRegistryImpl(); <line8> this.context.registerIdentityProvider(new JACCIdentityProvider()); <line9> this.context.registerStateRepository(repository); <line10> ContainerLocatorProvider.get(); <line11> ContainerManager containerManager = getContainerManager(); <line12> KieServerState currentState = repository.load(KieServerEnvironment.getServerId()); <line13> List<KieServerExtension> extensions = sortKnownExtensions(); <line14> for (KieServerExtension extension : extensions) { <line15> if (!extension.isActive()) { <line16> continue; <line17> } <line18> try { <line19> extension.init(this, this.context); <line20> this.context.registerServerExtension(extension); <line21> if (extension.isInitialized()) { <line22> } else { <line23> } <line24> } catch (Exception e) { <line25> serverMessages.add( <line26> new Message( <line27> Severity.ERROR, <line28> ""Error when initializing server extension of type "" <line29> + extension <line30> + "" due to "" <line31> + e.getMessage())); <line32> } <line33> } <line34> policyManager = new PolicyManager(); <line35> policyManager.start(this, context); <line36> kieServerActive.set(true); <line37> eventSupport.fireBeforeServerStarted(this); <line38> startTimestamp = System.currentTimeMillis(); <line39> startupStrategy.startup(this, containerManager, currentState, kieServerActive); <line40> eventSupport.fireAfterServerStarted(this); <line41> } <line42> } <line43> "	<line1>, <line7>, <line15>, <line22>, <line23>, <line32>
6973	public class A { <line0> @PostConstruct <line1> public void init() { <line2> try { <line3> BooleanQuery.setMaxClauseCount(propertyService.get(LUCENE_BOOLEAN_QUERY_MAX_CLAUSE_COUNT)); <line4> } catch (PropertyServiceIncompleteRegistrationException e) { <line5> } catch (NullPointerException e) { <line6> } <line7> } <line8> } <line9> 	<line5>, <line6>
6974	"public class A { <line0> private JSONObject getTweets() throws IOException { <line1> currentRequest++; <line2> String url = getApiURL(lastMaxID - 1); <line3> Document doc = <line4> Http.url(url) <line5> .ignoreContentType() <line6> .header(""Authorization"", ""Bearer "" + accessToken) <line7> .header(""Content-Type"", ""application/x-www-form-urlencoded;charset=UTF-8"") <line8> .header(""User-agent"", ""ripe and zipe"") <line9> .get(); <line10> String body = doc.body().html().replaceAll(""&quot;"", ""\""""); <line11> Object jsonObj = new JSONTokener(body).nextValue(); <line12> JSONArray statuses; <line13> if (jsonObj instanceof JSONObject) { <line14> JSONObject json = (JSONObject) jsonObj; <line15> if (json.has(""errors"")) { <line16> String msg = json.getJSONObject(""errors"").getString(""message""); <line17> throw new IOException(""Twitter responded with errors: "" + msg); <line18> } <line19> statuses = json.getJSONArray(""statuses""); <line20> } else { <line21> statuses = (JSONArray) jsonObj; <line22> } <line23> JSONObject r = new JSONObject(); <line24> r.put(""tweets"", statuses); <line25> return r; <line26> } <line27> } <line28> "	<line3>
6975	public class A { <line0> public static boolean moduleHasModuleRequirements(String moduleName, Map<String, Object> groups) { <line1> Map<String, Object> dependeciesInfoOfGroupOfModule = <line2> YAMLgroupsOptimizerParser.getDependenciesInfoOfMemberName(moduleName, groups); <line3> if (dependeciesInfoOfGroupOfModule == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> return false; <line7> } <line8> if (dependeciesInfoOfGroupOfModule.size() > 0) { <line9> return true; <line10> } <line11> if (log.isDebugEnabled()) { <line12> } <line13> return false; <line14> } <line15> } <line16> 	<line5>, <line12>
6976	public class A { <line0> public static com.liferay.portal.reports.engine.console.model.EntrySoap[] getEntries( <line1> long groupId, <line2> String definitionName, <line3> String userName, <line4> java.util.Date createDateGT, <line5> java.util.Date createDateLT, <line6> boolean andSearch, <line7> int start, <line8> int end, <line9> com.liferay.portal.kernel.util.OrderByComparator< <line10> com.liferay.portal.reports.engine.console.model.Entry> <line11> orderByComparator) <line12> throws RemoteException { <line13> try { <line14> java.util.List<com.liferay.portal.reports.engine.console.model.Entry> returnValue = <line15> EntryServiceUtil.getEntries( <line16> groupId, <line17> definitionName, <line18> userName, <line19> createDateGT, <line20> createDateLT, <line21> andSearch, <line22> start, <line23> end, <line24> orderByComparator); <line25> return com.liferay.portal.reports.engine.console.model.EntrySoap.toSoapModels(returnValue); <line26> } catch (Exception exception) { <line27> throw new RemoteException(exception.getMessage()); <line28> } <line29> } <line30> } <line31> 	<line27>
6977	public class A { <line0> @Test <line1> public void intervalTest2() throws BackendException { <line2> String[][] values = generateValues(); <line3> loadValues(values); <line4> newTx(); <line5> Set<KeyColumn> deleted = deleteValues(7); <line6> clopen(); <line7> checkRandomSlices(values, deleted); <line8> } <line9> } <line10> 	<line3>
6978	"public class A { <line0> public void deactivate() { <line1> if (orb != null) { <line2> if (bindingPOA == null) { <line3> throw new CorbaBindingException(""Corba Port deactivation failed because the poa is null""); <line4> } <line5> try { <line6> bindingPOA.deactivate_object(objectId); <line7> } catch (ObjectNotActive ona) { <line8> } catch (Exception ex) { <line9> throw new CorbaBindingException(""Unable to deactivate CORBA servant"", ex); <line10> } <line11> } <line12> } <line13> } <line14> "	<line8>
6979	public class A { <line0> public Boolean isEnable1xPrefixes() { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> return raProperties.isEnable1xPrefixes(); <line4> } <line5> } <line6> 	<line2>
6980	"public class A { <line0> @Override <line1> public Response fetchPatients() { <line2> final Request request = this.container.getRequest(); <line3> final List<Object> eids = request.getProperties(""eid""); <line4> final List<Object> ids = request.getProperties(""id""); <line5> final ImmutableSet.Builder<PrimaryEntity> patientsBuilder = ImmutableSet.builder(); <line6> try { <line7> addEids(patientsBuilder, eids); <line8> addIds(patientsBuilder, ids); <line9> final String json = this.objectMapper.writeValueAsString(patientsBuilder.build()); <line10> return Response.ok(json, MediaType.APPLICATION_JSON_TYPE).build(); <line11> } catch (final JsonProcessingException ex) { <line12> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build(); <line13> } catch (final QueryException ex) { <line14> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build(); <line15> } <line16> } <line17> } <line18> "	<line5>, <line12>, <line14>
6981	public class A { <line0> private void logCache( <line1> String basicMsg, ParsedTemplate tmpl, String msg, Exception exc, boolean printStack) { <line2> String oldMsg; <line3> boolean isDebug = log.isDebugEnabled(); <line4> synchronized (errors) { <line5> oldMsg = errors.get(tmpl.metric.toString()); <line6> } <line7> if (!isDebug && (oldMsg != null) && oldMsg.equals(msg)) { <line8> return; <line9> } <line10> if (isDebug) { <line11> } else { <line12> if (printStack) { <line13> } <line14> } <line15> synchronized (errors) { <line16> errors.put(tmpl.metric.toString(), msg); <line17> } <line18> } <line19> } <line20> 	<line11>, <line12>, <line13>
6982	public class A { <line0> public static void setQueryLogLevelInfo(boolean queryLogLevelInfo) { <line1> assertUnlocked(); <line2> if (_log.isInfoEnabled()) { <line3> } <line4> _queryLogLevelInfo = queryLogLevelInfo; <line5> lock(); <line6> } <line7> } <line8> 	<line3>
6983	public class A { <line0> @Override <line1> public void initialize(IAsyncResultHandler<Void> startupHandler) { <line2> this.proxy = new EBRegistryProxy(vertx, address(), registryUuid); <line3> listenProxyHandler(startupHandler); <line4> } <line5> } <line6> 	<line2>
6984	public class A { <line0> @Override <line1> public Optional<Commit> commit(String commitComment) { <line2> final Set<String> idsToRegister = <line3> ImmutableSet.copyOf( <line4> newComponents.keySet().stream().filter(SnomedIdentifiers::isValid).iterator()); <line5> newComponents = newHashMap(); <line6> Optional<Commit> commit = getDelegate().commit(commitComment); <line7> final ISnomedIdentifierService cis = service(ISnomedIdentifierService.class); <line8> if (cis.importSupported()) { <line9> cis.register(idsToRegister); <line10> } <line11> return commit; <line12> } <line13> } <line14> 	<line6>
6985	"public class A { <line0> private Map<InternalDistributedMember, List<Integer>> buildNodeToBucketMapForBuckets( <line1> final Set<Integer> bucketIdsToConsider) throws QueryException { <line2> final HashMap<InternalDistributedMember, List<Integer>> ret = new HashMap<>(); <line3> if (bucketIdsToConsider.isEmpty()) { <line4> return ret; <line5> } <line6> List<Integer> bucketIds; <line7> if (query != null && query.isCqQuery()) { <line8> bucketIds = findPrimaryBucketOwners(bucketIdsToConsider, ret); <line9> } else { <line10> bucketIds = findBucketOwners(bucketIdsToConsider, ret); <line11> } <line12> if (bucketIds.size() != bucketIdsToConsider.size()) { <line13> bucketIdsToConsider.removeAll(bucketIds); <line14> throw new QueryException( <line15> ""Data loss detected, unable to find the hosting "" <line16> + "" node for some of the dataset. [dataset/bucket ids:"" <line17> + bucketIdsToConsider <line18> + ""]""); <line19> } <line20> if (logger.isDebugEnabled()) { <line21> } <line22> return ret; <line23> } <line24> } <line25> "	<line21>
6986	"public class A { <line0> protected void validateAttachmentContentType( <line1> SoapAttachment receivedAttachment, SoapAttachment controlAttachment) { <line2> if (!StringUtils.hasText(controlAttachment.getContentType())) { <line3> return; <line4> } <line5> if (receivedAttachment.getContentType() != null) { <line6> Assert.isTrue( <line7> controlAttachment.getContentType() != null, <line8> buildValidationErrorMessage( <line9> ""Values not equal for attachment contentType"", <line10> null, <line11> receivedAttachment.getContentType())); <line12> Assert.isTrue( <line13> receivedAttachment.getContentType().equals(controlAttachment.getContentType()), <line14> buildValidationErrorMessage( <line15> ""Values not equal for attachment contentType"", <line16> controlAttachment.getContentType(), <line17> receivedAttachment.getContentType())); <line18> } else { <line19> Assert.isTrue( <line20> controlAttachment.getContentType() == null <line21> || controlAttachment.getContentType().length() == 0, <line22> buildValidationErrorMessage( <line23> ""Values not equal for attachment contentType"", <line24> controlAttachment.getContentType(), <line25> null)); <line26> } <line27> if (log.isDebugEnabled()) { <line28> } <line29> } <line30> } <line31> "	<line28>
6987	"public class A { <line0> public static void mergeTags(HttpPrincipal httpPrincipal, long[] fromTagIds, long toTagId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey(AssetTagServiceUtil.class, ""mergeTags"", _mergeTagsParameterTypes21); <line5> MethodHandler methodHandler = new MethodHandler(methodKey, fromTagIds, toTagId); <line6> try { <line7> TunnelUtil.invoke(httpPrincipal, methodHandler); <line8> } catch (Exception exception) { <line9> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line10> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line11> } <line12> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line13> } <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	<line15>
6988	public class A { <line0> @Override <line1> public ODistributedTxContext popTxContext(final ODistributedRequestId requestId) { <line2> final ODistributedTxContext ctx = activeTxContexts.remove(requestId); <line3> return ctx; <line4> } <line5> } <line6> 	<line3>
6989	public class A { <line0> public void trace(final String message, final Throwable error) { <line1> } <line2> } <line3> 	<line1>
6990	"public class A { <line0> private boolean transferIfPossibleImpl(EmbeddedSingeUidSyncOpInfo oi) { <line1> if (!oi.canTransferToMainList(_currentGenerationId)) { <line2> if (getLogger().isDebugEnabled()) { <line3> getLogger() <line4> } <line5> return false; <line6> } <line7> synchronized (oi) { <line8> boolean relevant = <line9> _embeddedHandler.getGensHandler().isRelevant(oi.getOriginalOpInfo().getGenerationId()); <line10> boolean lockAcquired = false; <line11> try { <line12> if (relevant <line13> && oi.getOriginalOpInfo().getGenerationId() <line14> != _embeddedHandler.getMainSyncHandler().getCurrentGenerationId()) { <line15> _readLock.lock(); <line16> lockAcquired = true; <line17> if (_embeddedHandler.getMainSyncHandler().afterRecoveryStarted()) { <line18> if (getLogger().isDebugEnabled()) { <line19> getLogger() <line20> } <line21> relevant = false; <line22> } <line23> } <line24> boolean persist = <line25> relevant <line26> && !oi.isPersistedToMainList() <line27> && !oi.getOriginalOpInfo() <line28> .isConfirmedByRemote(_embeddedHandler.getMainSyncHandler()); <line29> boolean updateTransferredInfo = <line30> relevant <line31> && !oi.isPersistedToMainList() <line32> && oi.getOriginalOpInfo().getGenerationId() == _currentGenerationId; <line33> boolean addToMainList = <line34> persist && oi.getOriginalOpInfo().getGenerationId() == _currentGenerationId; <line35> if (oi.containsAnyPhantom() && oi.isPersistedToMainList()) { <line36> throw new RuntimeException( <line37> ""inconsistent state in EmbeddedSegment:transferIfPossibleImpl contains phantom &&"" <line38> + "" persisted to main list SINGLE-uid="" <line39> + oi.getOriginalOpInfo().getUid()); <line40> } <line41> if (!relevant || !addToMainList) { <line42> if (getLogger().isDebugEnabled()) { <line43> getLogger() <line44> } <line45> } <line46> if (persist) { <line47> _embeddedHandler <line48> .getMainSyncHandler() <line49> .onEmbeddedListRecordTransferStart( <line50> oi.getOriginalOpInfo(), <line51> oi.getOriginalOpInfo().getGenerationId() != _currentGenerationId); <line52> oi.setPersistedToMainList(); <line53> } <line54> if (oi.containsAnyPhantom()) { <line55> _embeddedHandler.getPhantomsHandler().removePhantom(oi, oi.getOriginalOpInfo().getUid()); <line56> } <line57> if (addToMainList) <line58> _embeddedHandler <line59> .getMainSyncHandler() <line60> .onEmbeddedListRecordTransferEnd(oi.getOriginalOpInfo()); <line61> if (updateTransferredInfo) _infoHandler.updateTranferredInfo(oi); <line62> } finally { <line63> if (lockAcquired) { <line64> _readLock.unlock(); <line65> } <line66> } <line67> } <line68> return true; <line69> } <line70> } <line71> "	<line4>, <line20>, <line44>
6991	"public class A { <line0> @PUT <line1> @Path(""/{webPushID}"") <line2> @Consumes(MediaType.APPLICATION_JSON) <line3> @Produces(MediaType.APPLICATION_JSON) <line4> public Response updateWebPushVariant( <line5> @PathParam(""pushAppID"") String pushApplicationID, <line6> @PathParam(""webPushID"") String webPushID, <line7> WebPushVariant updatedVariant) { <line8> final PushApplication application = <line9> getSearch().findByPushApplicationIDForDeveloper(pushApplicationID); <line10> if (application == null) { <line11> return Response.status(Response.Status.NOT_FOUND) <line12> .entity(ErrorBuilder.forPushApplications().notFound().build()) <line13> .build(); <line14> } <line15> var variant = variantService.findByVariantID(webPushID); <line16> if (variant != null) { <line17> if (!(variant instanceof WebPushVariant)) { <line18> return Response.status(Response.Status.NOT_FOUND) <line19> .entity(ErrorBuilder.forVariants().notFound().build()) <line20> .build(); <line21> } <line22> WebPushVariant webPushVariant = (WebPushVariant) variant; <line23> try { <line24> updatedVariant.merge(webPushVariant); <line25> validateModelClass(webPushVariant); <line26> } catch (ConstraintViolationException cve) { <line27> Response.ResponseBuilder builder = createBadRequestResponse(cve.getConstraintViolations()); <line28> return builder.build(); <line29> } <line30> variantService.updateVariant(webPushVariant); <line31> return Response.ok(webPushVariant).build(); <line32> } <line33> return Response.status(Response.Status.NOT_FOUND) <line34> .entity(ErrorBuilder.forVariants().notFound().build()) <line35> .build(); <line36> } <line37> } <line38> "	<line27>, <line30>
6992	public class A { <line0> @Override <line1> public void doExecute(TestContext context) { <line2> } <line3> } <line4> 	<line2>
6993	public class A { <line0> @Override <line1> public List<SourceRecord> poll() throws InterruptedException { <line2> Map<TableQuerier, Integer> consecutiveEmptyResults = <line3> tableQueue.stream().collect(Collectors.toMap(Function.identity(), (q) -> 0)); <line4> while (running.get()) { <line5> final TableQuerier querier = tableQueue.peek(); <line6> if (!querier.querying()) { <line7> final long nextUpdate = <line8> querier.getLastUpdate() + config.getInt(JdbcSourceTaskConfig.POLL_INTERVAL_MS_CONFIG); <line9> final long now = time.milliseconds(); <line10> final long sleepMs = Math.min(nextUpdate - now, 100); <line11> if (sleepMs > 0) { <line12> time.sleep(sleepMs); <line13> continue; <line14> } <line15> } <line16> final List<SourceRecord> results = new ArrayList<>(); <line17> try { <line18> querier.maybeStartQuery(cachedConnectionProvider.getConnection()); <line19> int batchMaxRows = config.getInt(JdbcSourceTaskConfig.BATCH_MAX_ROWS_CONFIG); <line20> boolean hadNext = true; <line21> while (results.size() < batchMaxRows && (hadNext = querier.next())) { <line22> results.add(querier.extractRecord()); <line23> } <line24> if (!hadNext) { <line25> resetAndRequeueHead(querier); <line26> } <line27> if (results.isEmpty()) { <line28> consecutiveEmptyResults.compute(querier, (k, v) -> v + 1); <line29> if (Collections.min(consecutiveEmptyResults.values()) <line30> >= CONSECUTIVE_EMPTY_RESULTS_BEFORE_RETURN) { <line31> return null; <line32> } else { <line33> continue; <line34> } <line35> } else { <line36> consecutiveEmptyResults.put(querier, 0); <line37> } <line38> return results; <line39> } catch (SQLException sqle) { <line40> resetAndRequeueHead(querier); <line41> return null; <line42> } catch (Throwable t) { <line43> resetAndRequeueHead(querier); <line44> closeResources(); <line45> throw t; <line46> } <line47> } <line48> final TableQuerier querier = tableQueue.peek(); <line49> if (querier != null) { <line50> resetAndRequeueHead(querier); <line51> } <line52> closeResources(); <line53> return null; <line54> } <line55> } <line56> 	<line2>, <line12>, <line18>, <line29>, <line31>, <line38>, <line40>
6994	public class A { <line0> @Override <line1> public void delete(ScriptKey scriptKey) { <line2> ScriptVersionKey scriptVersionKey = <line3> new ScriptVersionKey(new ScriptKey(scriptKey.getScriptId(), scriptKey.getScriptVersion())); <line4> ScriptVersionConfiguration.getInstance().delete(scriptVersionKey); <line5> ActionConfiguration.getInstance().deleteByScript(scriptKey); <line6> ScriptParameterConfiguration.getInstance().deleteByScript(scriptKey); <line7> ScriptLabelConfiguration.getInstance().deleteByScript(scriptKey); <line8> getDeleteStatement(scriptKey).ifPresent(getMetadataRepository()::executeUpdate); <line9> } <line10> } <line11> 	<line2>
6995	"public class A { <line0> @GET(path = ""/backend/jvm/capabilities"", permission = ""agent:jvm:capabilities"") <line1> String getCapabilities(@BindAgentId String agentId) throws Exception { <line2> checkNotNull(liveJvmService); <line3> Capabilities capabilities; <line4> try { <line5> capabilities = liveJvmService.getCapabilities(agentId); <line6> } catch (AgentNotConnectedException e) { <line7> return ""{\""agentNotConnected\"":true}""; <line8> } <line9> StringBuilder sb = new StringBuilder(); <line10> JsonGenerator jg = mapper.getFactory().createGenerator(CharStreams.asWriter(sb)); <line11> try { <line12> jg.writeStartObject(); <line13> writeAvailability(""threadCpuTime"", capabilities.getThreadCpuTime(), jg); <line14> writeAvailability(""threadContentionTime"", capabilities.getThreadContentionTime(), jg); <line15> writeAvailability(""threadAllocatedBytes"", capabilities.getThreadAllocatedBytes(), jg); <line16> jg.writeEndObject(); <line17> } finally { <line18> jg.close(); <line19> } <line20> return sb.toString(); <line21> } <line22> } <line23> "	<line7>
6996	"public class A { <line0> @Override <line1> void convertAsJson(final Message in) { <line2> final ObjectNode replacement = MAPPER.createObjectNode(); <line3> final ObjectNode parameters = replacement.putObject(""parameters""); <line4> final Integer status = in.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class); <line5> if (status != null) { <line6> parameters.put(""Status"", status); <line7> } <line8> final String contentType = in.getHeader(Exchange.CONTENT_TYPE, String.class); <line9> if (contentType != null) { <line10> parameters.put(""Content-Type"", contentType); <line11> } <line12> final String body = bodyAsString(in); <line13> if (body != null) { <line14> final JsonNode payload; <line15> try { <line16> payload = MAPPER.readTree(body); <line17> } catch (final IOException e) { <line18> return; <line19> } <line20> replacement.set(""body"", payload); <line21> } <line22> replaceBodyWith(in, replacement); <line23> } <line24> } <line25> "	<line18>
6997	"public class A { <line0> @Override <line1> public void save(Note note, AuthenticationInfo subject) throws IOException { <line2> String json = note.toJson(); <line3> ByteArrayOutputStream output = new ByteArrayOutputStream(); <line4> Writer writer = new OutputStreamWriter(output); <line5> writer.write(json); <line6> writer.close(); <line7> output.close(); <line8> byte[] buffer = output.toByteArray(); <line9> try { <line10> CloudFileDirectory dir = rootDir.getDirectoryReference(note.getId()); <line11> dir.createIfNotExists(); <line12> CloudFile cloudFile = dir.getFileReference(""note.json""); <line13> cloudFile.uploadFromByteArray(buffer, 0, buffer.length); <line14> } catch (URISyntaxException | StorageException e) { <line15> String msg = String.format(""Error saving notebook %s to Azure storage"", note.getId()); <line16> throw new IOException(msg, e); <line17> } <line18> } <line19> } <line20> "	<line16>
6998	"public class A { <line0> @Test( <line1> dataProvider = ""testName"", <line2> dependsOnMethods = {""createWithAuthRefs""}) <line3> public void readAndCheckAuthRefs(String testName) throws Exception { <line4> testSetup(STATUS_OK, ServiceRequestType.READ); <line5> CollectionObjectClient collectionObjectClient = new CollectionObjectClient(); <line6> Response res = collectionObjectClient.read(knownResourceId); <line7> try { <line8> assertStatusCode(res, testName); <line9> PoxPayloadIn input = new PoxPayloadIn((String) res.readEntity(String.class)); <line10> CollectionobjectsCommon collectionObject = <line11> (CollectionobjectsCommon) <line12> extractPart( <line13> input, collectionObjectClient.getCommonPartName(), CollectionobjectsCommon.class); <line14> Assert.assertNotNull(collectionObject); <line15> Assert.assertEquals(collectionObject.getOwners().getOwner().get(0), ownerRefName); <line16> Assert.assertEquals( <line17> collectionObject.getFieldCollectionSources().getFieldCollectionSource().get(0), <line18> fieldCollectionSourceRefName); <line19> Assert.assertEquals( <line20> collectionObject.getContentOrganizations().getContentOrganization().get(0), <line21> contentOrganizationRefName); <line22> Assert.assertEquals( <line23> collectionObject.getAssocEventOrganizations().getAssocEventOrganization().get(0), <line24> assocEventOrganizationRefName); <line25> } finally { <line26> if (res != null) { <line27> res.close(); <line28> } <line29> } <line30> res = collectionObjectClient.getAuthorityRefs(knownResourceId); <line31> AuthorityRefList list = null; <line32> try { <line33> assertStatusCode(res, testName); <line34> list = (AuthorityRefList) res.readEntity(AuthorityRefList.class); <line35> } finally { <line36> if (res != null) { <line37> res.close(); <line38> } <line39> } <line40> int expectAuthRefs = personIdsCreated.size() + orgIdsCreated.size(); <line41> List<AuthorityRefList.AuthorityRefItem> items = list.getAuthorityRefItem(); <line42> int numAuthRefsFound = items.size(); <line43> if (logger.isDebugEnabled()) { <line44> } <line45> boolean iterateThroughList = true; <line46> if (iterateThroughList && logger.isDebugEnabled()) { <line47> int i = 0; <line48> for (AuthorityRefList.AuthorityRefItem item : items) { <line49> i++; <line50> } <line51> } <line52> Assert.assertEquals( <line53> numAuthRefsFound, <line54> expectAuthRefs, <line55> ""Did not find all expected authority references! "" <line56> + ""Expected "" <line57> + expectAuthRefs <line58> + "", found "" <line59> + numAuthRefsFound); <line60> } <line61> } <line62> "	<line44>, <line45>, <line49>
6999	public class A { <line0> private void reportCrucialExceptions(Map<String, JournalException> crucialExceptions) <line1> throws JournalException { <line2> if (!crucialExceptions.isEmpty()) { <line3> JournalOperatingMode.setMode(JournalOperatingMode.READ_ONLY); <line4> } <line5> for (String transportName : crucialExceptions.keySet()) { <line6> JournalException e = crucialExceptions.get(transportName); <line7> } <line8> } <line9> } <line10> 	<line7>
7000	public class A { <line0> public boolean isDefinitionInputDisabled( <line1> boolean previewBeforeRestore, <line2> KaleoDefinitionVersion kaleoDefinitionVersion, <line3> PermissionChecker permissionChecker) { <line4> if (previewBeforeRestore) { <line5> return true; <line6> } <line7> if ((kaleoDefinitionVersion == null) <line8> && KaleoDesignerPermission.contains( <line9> permissionChecker, <line10> _themeDisplay.getCompanyGroupId(), <line11> KaleoDesignerActionKeys.ADD_NEW_WORKFLOW)) { <line12> return false; <line13> } <line14> try { <line15> if ((kaleoDefinitionVersion != null) <line16> && KaleoDefinitionVersionPermission.contains( <line17> permissionChecker, kaleoDefinitionVersion, ActionKeys.UPDATE)) { <line18> return false; <line19> } <line20> } catch (PortalException portalException) { <line21> if (_log.isDebugEnabled()) { <line22> } <line23> } <line24> return true; <line25> } <line26> } <line27> 	<line22>
7001	"public class A { <line0> public void addError(AuditEvent aEvt) { <line1> final SeverityLevel severityLevel = aEvt.getSeverityLevel(); <line2> if (mInitialized && !SeverityLevel.IGNORE.equals(severityLevel)) { <line3> final Log log = mLogFactory.getInstance(aEvt.getSourceName()); <line4> final String fileName = aEvt.getFileName(); <line5> final String message = aEvt.getMessage(); <line6> final int bufLen = message.length() + BUFFER_CUSHION; <line7> final StringBuffer sb = new StringBuffer(bufLen); <line8> sb.append(""Line: "").append(aEvt.getLine()); <line9> if (aEvt.getColumn() > 0) { <line10> sb.append("" Column: "").append(aEvt.getColumn()); <line11> } <line12> sb.append("" Message: "").append(message); <line13> if (aEvt.getSeverityLevel().equals(SeverityLevel.WARNING)) { <line14> } else if (aEvt.getSeverityLevel().equals(SeverityLevel.INFO)) { <line15> } else { <line16> } <line17> } <line18> } <line19> } <line20> "	<line14>, <line15>, <line16>
7002	"public class A { <line0> private void initOwnCloudInfo() { <line1> try { <line2> final Cloud ownCloud = commonDBService.getOwnCloud(sslEnabled); <line3> ownCloudName = ownCloud.getName(); <line4> ownCloudOperator = ownCloud.getOperator(); <line5> } catch (final DataNotFoundException ex) { <line6> if (!arrowheadContext.containsKey(CommonConstants.SERVER_COMMON_NAME)) { <line7> throw new ArrowheadException(""Server's certificate not found.""); <line8> } <line9> final String serverCN = (String) arrowheadContext.get(CommonConstants.SERVER_COMMON_NAME); <line10> final String[] serverFields = serverCN.split(""\\.""); <line11> ownCloudName = serverFields[1]; <line12> ownCloudOperator = serverFields[2]; <line13> } <line14> } <line15> } <line16> "	<line1>, <line6>
7003	"public class A { <line0> public Map<String, String> getQueryMap(@Nullable String query) { <line1> Map<String, String> map = new HashMap<>(); <line2> if (query != null) { <line3> String[] params = query.split(""&""); <line4> for (String param : params) { <line5> String[] elements = param.split(""=""); <line6> if (elements.length == 2) { <line7> String name = elements[0]; <line8> String value = """"; <line9> try { <line10> value = URLDecoder.decode(elements[1], ""UTF8""); <line11> } catch (UnsupportedEncodingException e) { <line12> } <line13> map.put(name, value); <line14> } <line15> } <line16> } <line17> return map; <line18> } <line19> } <line20> "	<line12>
7004	public class A { <line0> @Override <line1> public synchronized void stopBackgroundScanning() { <line2> ScheduledFuture<?> currentBackgroundScanningJob = backgroundScanningJob; <line3> if (currentBackgroundScanningJob != null && !currentBackgroundScanningJob.isCancelled()) { <line4> if (currentBackgroundScanningJob.cancel(true)) { <line5> backgroundScanningJob = null; <line6> } <line7> } <line8> } <line9> } <line10> 	<line2>, <line6>
7005	"public class A { <line0> private void assertDockerReachable(final int probePort) throws Exception { <line1> try (final DockerClient docker = getNewDockerClient()) { <line2> try { <line3> docker.inspectImage(BUSYBOX); <line4> } catch (ImageNotFoundException e) { <line5> docker.pull(BUSYBOX); <line6> } <line7> try { <line8> docker.inspectImage(ALPINE); <line9> } catch (ImageNotFoundException e) { <line10> docker.pull(ALPINE); <line11> } <line12> final HostConfig hostConfig = <line13> HostConfig.builder() <line14> .portBindings( <line15> ImmutableMap.of(""4711/tcp"", singletonList(PortBinding.of(""0.0.0.0"", probePort)))) <line16> .build(); <line17> final ContainerConfig config = <line18> ContainerConfig.builder() <line19> .image(BUSYBOX) <line20> .cmd(""nc"", ""-p"", ""4711"", ""-lle"", ""cat"") <line21> .exposedPorts(ImmutableSet.of(""4711/tcp"")) <line22> .hostConfig(hostConfig) <line23> .build(); <line24> final ContainerCreation creation = docker.createContainer(config, testTag + ""-probe""); <line25> final String containerId = creation.id(); <line26> docker.startContainer(containerId); <line27> Polling.await( <line28> 5, <line29> SECONDS, <line30> new Callable<Object>() { <line31> @Override <line32> public Object call() throws Exception { <line33> final ContainerInfo info = docker.inspectContainer(containerId); <line34> return info.state().running() ? true : null; <line35> } <line36> }); <line37> try { <line38> Polling.awaitUnchecked( <line39> 5, <line40> SECONDS, <line41> new Callable<Object>() { <line42> @Override <line43> public Object call() throws Exception { <line44> try (final Socket ignored = new Socket(DOCKER_HOST.address(), probePort)) { <line45> return true; <line46> } catch (IOException e) { <line47> return false; <line48> } <line49> } <line50> }); <line51> } catch (TimeoutException e) { <line52> fail( <line53> ""Please ensure that DOCKER_HOST is set to an address that where containers can "" <line54> + ""be reached. If docker is running in a local VM, DOCKER_HOST must be set to the "" <line55> + ""address of that VM. If docker can only be reached on a limited port range, "" <line56> + ""set the environment variable DOCKER_PORT_RANGE=start:end""); <line57> } <line58> docker.killContainer(containerId); <line59> } <line60> } <line61> } <line62> "	<line37>, <line44>
7006	"public class A { <line0> @Test <line1> @Ignore <line2> public void ensureInternalEndpointIsSecured() throws Throwable { <line3> final String connectorTasksEndpoint = <line4> connect.endpointForResource(String.format(""connectors/%s/tasks"", CONNECTOR_NAME)); <line5> final Map<String, String> emptyHeaders = new HashMap<>(); <line6> final Map<String, String> invalidSignatureHeaders = new HashMap<>(); <line7> invalidSignatureHeaders.put(SIGNATURE_HEADER, ""S2Fma2Flc3F1ZQ==""); <line8> invalidSignatureHeaders.put(SIGNATURE_ALGORITHM_HEADER, ""HmacSHA256""); <line9> assertEquals( <line10> BAD_REQUEST.getStatusCode(), <line11> connect.requestPost(connectorTasksEndpoint, ""[]"", emptyHeaders).getStatus()); <line12> assertEquals( <line13> FORBIDDEN.getStatusCode(), <line14> connect.requestPost(connectorTasksEndpoint, ""[]"", invalidSignatureHeaders).getStatus()); <line15> Map<String, String> connectorProps = new HashMap<>(); <line16> connectorProps.put(CONNECTOR_CLASS_CONFIG, MonitorableSinkConnector.class.getSimpleName()); <line17> connectorProps.put(TASKS_MAX_CONFIG, String.valueOf(1)); <line18> connectorProps.put(TOPICS_CONFIG, ""test-topic""); <line19> connectorProps.put(KEY_CONVERTER_CLASS_CONFIG, StringConverter.class.getName()); <line20> connectorProps.put(VALUE_CONVERTER_CLASS_CONFIG, StringConverter.class.getName()); <line21> StartAndStopLatch startLatch = connectorHandle.expectedStarts(1); <line22> connect.configureConnector(CONNECTOR_NAME, connectorProps); <line23> startLatch.await(CONNECTOR_SETUP_DURATION_MS, TimeUnit.MILLISECONDS); <line24> assertEquals( <line25> BAD_REQUEST.getStatusCode(), <line26> connect.requestPost(connectorTasksEndpoint, ""[]"", emptyHeaders).getStatus()); <line27> assertEquals( <line28> FORBIDDEN.getStatusCode(), <line29> connect.requestPost(connectorTasksEndpoint, ""[]"", invalidSignatureHeaders).getStatus()); <line30> } <line31> } <line32> "	<line9>, <line12>, <line21>, <line24>, <line27>
7007	"public class A { <line0> @Override <line1> public Map<String, Object> perform( <line2> EntityManager entityManager, <line3> int ciTypeId, <line4> String guid, <line5> AdmStateTransition transition, <line6> Map<String, Object> ciData, <line7> DynamicEntityHolder ciHolder, <line8> Date date) { <line9> SimpleDateFormat dateFmt = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); <line10> dateFmt.setTimeZone(TimeZone.getDefault()); <line11> if (ciHolder == null) { <line12> ciHolder = ciService.getCiHolder(ciTypeId, guid); <line13> } <line14> String fixedDate = (String) ciHolder.get(CmdbConstants.DEFAULT_FIELD_FIXED_DATE); <line15> if (!Strings.isNullOrEmpty(fixedDate)) { <line16> throw new InvalidArgumentException( <line17> String.format(""The Ci [%s] has been confirmed, can not be confirmed again."", guid)); <line18> } <line19> if (date != null) { <line20> fixedDate = dateFmt.format(date); <line21> } else { <line22> fixedDate = dateFmt.format(new Date()); <line23> } <line24> Map<String, Object> updateMap = Maps.newHashMap(); <line25> int targetState = transition.getTargetState(); <line26> MapUtils.putAll( <line27> updateMap, <line28> new Object[] { <line29> CmdbConstants.GUID, <line30> guid, <line31> CmdbConstants.DEFAULT_FIELD_FIXED_DATE, <line32> fixedDate, <line33> CmdbConstants.DEFAULT_FIELD_STATE, <line34> targetState <line35> }); <line36> ciHolder.update(updateMap, CmdbThreadLocal.getIntance().getCurrentUser(), entityManager); <line37> entityManager.merge(ciHolder.getEntityObj()); <line38> return ClassUtils.convertBeanToMap(ciHolder.getEntityObj(), ciHolder.getEntityMeta(), false); <line39> } <line40> } <line41> "	<line38>
7008	public class A { <line0> private void handleError( <line1> MailQueueItem queueItem, <line2> Mail mail, <line3> ImmutableList<MailAddress> originalRecipients, <line4> Exception processingException) { <line5> int failureCount = computeFailureCount(mail); <line6> queueItem.getMail().setRecipients(originalRecipients); <line7> try { <line8> if (failureCount > MAXIMUM_FAILURE_COUNT) { <line9> storeInErrorRepository(queueItem); <line10> } else { <line11> reEnqueue(queueItem, failureCount); <line12> } <line13> } catch (Exception nestedE) { <line14> nack(queueItem, processingException); <line15> } <line16> } <line17> } <line18> 	<line9>, <line11>, <line14>
7009	"public class A { <line0> void createPortForward(String vmName, int port) { <line1> if (!isPortForwarded(vmName, port)) { <line2> commandExecutor.exec( <line3> String.format( <line4> ""VBoxManage controlvm "" + vmName + "" natpf1 %d,tcp,127.0.0.1,%d,,%d"", <line5> port, <line6> port, <line7> port)); <line8> } <line9> } <line10> } <line11> "	<line2>
7010	public class A { <line0> @Test <line1> public void testZeroOnUpdate() throws Exception { <line2> factory = new FactoryBuilder.SingletonFactory<>(new TestPolicy(null, 0L, null)); <line3> startGrids(); <line4> for (final Integer key : keys()) { <line5> zeroOnUpdate(key); <line6> } <line7> } <line8> } <line9> 	<line5>
7011	public class A { <line0> private Set<IPAddress> getConfiguredDnsServers() { <line1> LinkedHashSet<IPAddress> serverList = new LinkedHashSet<>(); <line2> if (this.networkConfiguration != null <line3> && this.networkConfiguration.getNetInterfaceConfigs() != null) { <line4> List<NetInterfaceConfig<? extends NetInterfaceAddressConfig>> netInterfaceConfigs = <line5> this.networkConfiguration.getNetInterfaceConfigs(); <line6> for (NetInterfaceConfig<? extends NetInterfaceAddressConfig> netInterfaceConfig : <line7> netInterfaceConfigs) { <line8> if ((netInterfaceConfig.getType() == NetInterfaceType.ETHERNET <line9> || netInterfaceConfig.getType() == NetInterfaceType.WIFI <line10> || netInterfaceConfig.getType() == NetInterfaceType.MODEM) <line11> && isEnabledForWan(netInterfaceConfig)) { <line12> try { <line13> Set<IPAddress> servers = getConfiguredDnsServers(netInterfaceConfig); <line14> serverList.addAll(servers); <line15> } catch (KuraException e) { <line16> } <line17> } <line18> } <line19> } <line20> return serverList; <line21> } <line22> } <line23> 	<line14>, <line16>
7012	public class A { <line0> @BeforeClass <line1> public static void setUpClass() throws Exception { <line2> if (testDriver != null && !setUpClassCalled) { <line3> testDriver.setUpClass(); <line4> setUpClassCalled = true; <line5> } <line6> } <line7> } <line8> 	<line3>
7013	"public class A { <line0> @Override <line1> public File getObject() { <line2> String home = getPageBase().getMidpointConfiguration().getMidpointHome(); <line3> File f = new File(home, ""result""); <line4> DataOutputStream dos = null; <line5> try { <line6> dos = new DataOutputStream(new FileOutputStream(f)); <line7> dos.writeBytes(OperationResultPanel.this.getModel().getObject().getXml()); <line8> } catch (IOException e) { <line9> } finally { <line10> IOUtils.closeQuietly(dos); <line11> } <line12> return f; <line13> } <line14> } <line15> "	<line9>
7014	"public class A { <line0> public synchronized void updateContainerXMLTree(String spaceName, JSpaceAttributes spaceAttr) { <line1> if (m_rootSpaceElement == null) { <line2> if (_logger.isDebugEnabled()) { <line3> } <line4> return; <line5> } <line6> spaceAttr = (spaceAttr == null) ? new JSpaceAttributes() : spaceAttr; <line7> NodeList spaceNL = m_rootSpaceElement.getElementsByTagName(spaceName); <line8> for (int i = 0; i < spaceNL.getLength(); i++) m_rootSpaceElement.removeChild(spaceNL.item(i)); <line9> Element jspaceElement = m_containerFileDocument.createElement(spaceName); <line10> m_rootSpaceElement.appendChild(jspaceElement); <line11> m_rootSpaceElement.appendChild(jspaceElement); <line12> Element propertiesElem = m_containerFileDocument.createElement(SpaceURL.PROPERTIES_FILE_NAME); <line13> Element schemaElem = m_containerFileDocument.createElement(SCHEMA_ELEMENT); <line14> Text schemaText = null; <line15> if (spaceAttr.getSchemaName() != null) <line16> schemaText = m_containerFileDocument.createTextNode(spaceAttr.getSchemaName()); <line17> else schemaText = m_containerFileDocument.createTextNode(""""); <line18> Text propertiesText = null; <line19> if (spaceAttr.getCustomProperties() != null <line20> && spaceAttr.getCustomProperties().getProperty(SpaceURL.PROPERTIES_FILE_NAME) != null) <line21> propertiesText = <line22> m_containerFileDocument.createTextNode( <line23> spaceAttr.getCustomProperties().getProperty(SpaceURL.PROPERTIES_FILE_NAME)); <line24> else propertiesText = m_containerFileDocument.createTextNode(""""); <line25> jspaceElement.appendChild(schemaElem).appendChild(schemaText); <line26> jspaceElement.appendChild(propertiesElem).appendChild(propertiesText); <line27> Element isLoadOnStartupElem = <line28> m_containerFileDocument.createElement(Constants.IS_SPACE_LOAD_ON_STARTUP); <line29> Text isLoadOnStartupText = <line30> m_containerFileDocument.createTextNode(String.valueOf(spaceAttr.isLoadOnStartup())); <line31> jspaceElement.appendChild(isLoadOnStartupElem).appendChild(isLoadOnStartupText); <line32> saveState(); <line33> } <line34> } <line35> "	<line3>
7015	public class A { <line0> private String encryptData(String decryptedData) { <line1> long encStartTime = System.currentTimeMillis(); <line2> try { <line3> String encryptedData = encryptionService.encryptData(decryptedData, null); <line4> return encryptedData; <line5> } catch (Exception e) { <line6> throw new ProjectCommonException( <line7> ResponseCode.SERVER_ERROR.getErrorCode(), <line8> ResponseCode.userDataEncryptionError.getErrorMessage(), <line9> ResponseCode.userDataEncryptionError.getResponseCode()); <line10> } <line11> } <line12> } <line13> 	<line6>
7016	public class A { <line0> @Override <line1> public void afterConnectionEstablished(Session session) throws Exception { <line2> afterConnectionEstablishedLatch.countDown(); <line3> } <line4> } <line5> 	<line2>
7017	"public class A { <line0> @Override <line1> public void populateConfigJSONObject( <line2> JSONObject jsonObject, <line3> Map<String, Object> inputEditorTaglibAttributes, <line4> ThemeDisplay themeDisplay, <line5> RequestBackedPortletURLFactory requestBackedPortletURLFactory) { <line6> PortletDisplay portletDisplay = themeDisplay.getPortletDisplay(); <line7> try { <line8> BlogsPortletInstanceConfiguration blogsPortletInstanceConfiguration = <line9> portletDisplay.getPortletInstanceConfiguration(BlogsPortletInstanceConfiguration.class); <line10> if (!blogsPortletInstanceConfiguration.enableReadingTime()) { <line11> return; <line12> } <line13> } catch (ConfigurationException configurationException) { <line14> } <line15> String extraPlugins = jsonObject.getString(""extraPlugins""); <line16> if (Validator.isNotNull(extraPlugins)) { <line17> extraPlugins = extraPlugins + "",readingtime""; <line18> } else { <line19> extraPlugins = ""readingtime""; <line20> } <line21> jsonObject.put(""extraPlugins"", extraPlugins); <line22> _readingTimeConfigContributor.populateConfigJSONObject( <line23> jsonObject, inputEditorTaglibAttributes, themeDisplay, requestBackedPortletURLFactory); <line24> JSONObject readingTimeJSONObject = jsonObject.getJSONObject(""readingTime""); <line25> if (readingTimeJSONObject != null) { <line26> String namespace = <line27> GetterUtil.getString( <line28> inputEditorTaglibAttributes.get(""liferay-ui:input-editor:namespace"")); <line29> readingTimeJSONObject.put(""elementId"", namespace + ""readingTime""); <line30> } <line31> } <line32> } <line33> "	<line14>
7018	"public class A { <line0> @Override <line1> public List<TestCaseStep> getStepLibraryBySystemTestTestCase( <line2> String system, String test, String testcase) throws CerberusException { <line3> List<TestCaseStep> list = null; <line4> StringBuilder query = new StringBuilder(); <line5> query.append( <line6> ""SELECT tcs.test, tcs.testcase,tcs.stepId, tcs.sort, tcs.description FROM testcasestep"" <line7> + "" tcs ""); <line8> query.append(""join testcase tc on tc.test=tcs.test and tc.testcase=tcs.testcase ""); <line9> query.append(""join application app  on tc.application=app.application ""); <line10> query.append(""where tcs.islibrarystep IS true ""); <line11> if (system != null) { <line12> query.append(""and app.system = ? ""); <line13> } <line14> if (test != null) { <line15> query.append(""and tcs.test = ? ""); <line16> } <line17> if (testcase != null) { <line18> query.append(""and tcs.testcase = ? ""); <line19> } <line20> query.append(""order by tcs.test, tcs.testcase, tcs.sort""); <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> Connection connection = this.databaseSpring.connect(); <line24> try { <line25> PreparedStatement preStat = connection.prepareStatement(query.toString()); <line26> try { <line27> int i = 1; <line28> if (system != null) { <line29> preStat.setString(i++, system); <line30> } <line31> if (test != null) { <line32> preStat.setString(i++, test); <line33> } <line34> if (testcase != null) { <line35> preStat.setString(i++, testcase); <line36> } <line37> ResultSet resultSet = preStat.executeQuery(); <line38> list = new ArrayList<>(); <line39> try { <line40> while (resultSet.next()) { <line41> String t = resultSet.getString(""test""); <line42> String tc = resultSet.getString(""testcase""); <line43> int s = resultSet.getInt(""stepId""); <line44> int sort = resultSet.getInt(""sort""); <line45> String description = resultSet.getString(""description""); <line46> list.add( <line47> factoryTestCaseStep.create( <line48> t, <line49> tc, <line50> s, <line51> sort, <line52> null, <line53> null, <line54> null, <line55> null, <line56> null, <line57> null, <line58> description, <line59> false, <line60> null, <line61> null, <line62> 0, <line63> false, <line64> false, <line65> null, <line66> null, <line67> null, <line68> null)); <line69> } <line70> } catch (SQLException exception) { <line71> } finally { <line72> resultSet.close(); <line73> } <line74> } catch (SQLException exception) { <line75> } finally { <line76> preStat.close(); <line77> } <line78> } catch (SQLException exception) { <line79> } finally { <line80> try { <line81> if (connection != null) { <line82> connection.close(); <line83> } <line84> } catch (SQLException e) { <line85> } <line86> } <line87> return list; <line88> } <line89> } <line90> "	<line22>, <line71>, <line75>, <line79>, <line85>
7019	"public class A { <line0> public static <C extends RingElem<C>> List<GenWordPolynomial<C>> intersect( <line1> GenWordPolynomialRing<C> R, List<GenWordPolynomial<C>> F) { <line2> if (F == null || F.isEmpty()) { <line3> return F; <line4> } <line5> GenWordPolynomialRing<C> pfac = F.get(0).ring; <line6> assert pfac.alphabet.isSubFactory(R.alphabet) : ""pfac="" + pfac.alphabet + "", R="" + R.alphabet; <line7> List<GenWordPolynomial<C>> H = new ArrayList<GenWordPolynomial<C>>(F.size()); <line8> for (GenWordPolynomial<C> p : F) { <line9> if (p == null || p.isZERO()) { <line10> continue; <line11> } <line12> GenWordPolynomial<C> m = p.contract(R); <line13> if (logger.isDebugEnabled()) { <line14> } <line15> if (!m.isZERO()) { <line16> H.add(m); <line17> } <line18> } <line19> return H; <line20> } <line21> } <line22> "	<line14>
7020	"public class A { <line0> public void endCurrentTransaction() { <line1> try { <line2> Transaction transaction = tracer.currentTransaction(); <line3> if (transaction != null && ""messaging"".equals(transaction.getType())) { <line4> transaction.deactivate().end(); <line5> } <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> "	<line7>
7021	"public class A { <line0> @Override <line1> public Path read(Class<? extends Path> clazz, HttpInputMessage inputMessage) <line2> throws IOException, HttpMessageNotReadableException { <line3> InputStream inputStream = inputMessage.getBody(); <line4> Path fileDirectory = Files.createTempDirectory(null); <line5> Path tempFile = fileDirectory.resolve(fileName); <line6> tempFile = Files.createFile(tempFile); <line7> try (OutputStream outputStream = Files.newOutputStream(tempFile)) { <line8> long fileSize = IOUtils.copyLarge(inputStream, outputStream); <line9> long expectedSize = inputMessage.getHeaders().getContentLength(); <line10> if (fileSize != expectedSize) { <line11> throw new IOException( <line12> ""Error when writing remote file ["" <line13> + fileName <line14> + ""], to path ["" <line15> + tempFile <line16> + ""], expectedSize ["" <line17> + expectedSize <line18> + ""] != actual size ["" <line19> + fileSize <line20> + ""]""); <line21> } <line22> } <line23> return tempFile; <line24> } <line25> } <line26> "	<line3>
7022	public class A { <line0> private void processBuffer(final Connection connection) throws IOException { <line1> final ByteBuffer buffer = connection.getBuffer(); <line2> buffer.flip(); <line3> try { <line4> while ((buffer.position() + 4) < buffer.limit()) { <line5> buffer.mark(); <line6> if (!this.onBufferReceived(connection)) { <line7> return; <line8> } <line9> } <line10> buffer.mark(); <line11> buffer.compact(); <line12> } catch (final BufferUnderflowException ex) { <line13> buffer.reset(); <line14> buffer.compact(); <line15> } <line16> } <line17> } <line18> 	<line13>
7023	public class A { <line0> @Override <line1> public void process(AuditMessage auditMessage) { <line2> try { <line3> doProcess(auditMessage); <line4> } catch (CTTransactionException ctTransactionException) { <line5> throw ctTransactionException; <line6> } catch (Exception exception) { <line7> } <line8> } <line9> } <line10> 	<line7>
7024	public class A { <line0> private HttpServletRequest _encryptRequest( <line1> HttpServletRequest httpServletRequest, long companyId) { <line2> boolean encryptRequest = ParamUtil.getBoolean(httpServletRequest, WebKeys.ENCRYPT); <line3> if (!encryptRequest) { <line4> return httpServletRequest; <line5> } <line6> try { <line7> Company company = CompanyLocalServiceUtil.getCompanyById(companyId); <line8> httpServletRequest = new EncryptedServletRequest(httpServletRequest, company.getKeyObj()); <line9> } catch (Exception exception) { <line10> if (_log.isDebugEnabled()) { <line11> } <line12> } <line13> return httpServletRequest; <line14> } <line15> } <line16> 	<line11>
7025	"public class A { <line0> @Override <line1> public boolean init( <line2> @NotNull Session session, <line3> @NotNull Root root, <line4> @NotNull NamePathMapper namePathMapper, <line5> boolean isWorkspaceImport, <line6> int uuidBehavior, <line7> @NotNull ReferenceChangeTracker referenceTracker, <line8> @NotNull SecurityProvider securityProvider) { <line9> if (initialized) { <line10> throw new IllegalStateException(""Already initialized""); <line11> } <line12> try { <line13> ConfigurationParameters config = <line14> securityProvider.getConfiguration(AuthorizationConfiguration.class).getParameters(); <line15> supportedPaths = CugUtil.getSupportedPaths(config, mountInfoProvider); <line16> importBehavior = CugUtil.getImportBehavior(config); <line17> if (isWorkspaceImport) { <line18> PrincipalConfiguration pConfig = <line19> securityProvider.getConfiguration(PrincipalConfiguration.class); <line20> principalManager = pConfig.getPrincipalManager(root, namePathMapper); <line21> } else { <line22> principalManager = ((JackrabbitSession) session).getPrincipalManager(); <line23> } <line24> initialized = true; <line25> } catch (RepositoryException e) { <line26> } <line27> return initialized; <line28> } <line29> } <line30> "	<line26>
7026	"public class A { <line0> protected void informAdministrator(String errorMessage) { <line1> if (!_informAdministrator || !_log.isWarnEnabled()) { <line2> return; <line3> } <line4> _informAdministrator = false; <line5> StringBundler sb = new StringBundler(7); <line6> sb.append(""Liferay does not have the Xuggler native libraries ""); <line7> sb.append(""installed. In order to generate video and audio previews, ""); <line8> sb.append(""please follow the instructions for Xuggler in the Server ""); <line9> sb.append(""Administration section of the Control Panel at: ""); <line10> sb.append(""http://<server>/group/control_panel/manage/-/server""); <line11> sb.append(""/external-services. Warning: ""); <line12> sb.append(errorMessage); <line13> } <line14> } <line15> "	<line13>
7027	public class A { <line0> @Override <line1> public void stopService() throws Exception { <line2> if (configuration.isEmbeddedServerEnabled()) { <line3> if (null != syncTimer) { <line4> syncTimer.cancel(); <line5> syncTimer = null; <line6> } <line7> final ShutdownConfiguration cfg = new ShutdownConfiguration(); <line8> final Hashtable env = createContextEnv(); <line9> env.putAll(cfg.toJndiEnvironment()); <line10> new InitialDirContext(env); <line11> for (int retries = 0; retries <= 90; retries++) { <line12> Thread.sleep(TimeUnit.SECONDS.toMillis(1)); <line13> try { <line14> final ServerSocket socket = new ServerSocket(configuration.getEmbeddedLdapPort()); <line15> socket.close(); <line16> return; <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> } <line22> } <line23> 	<line3>, <line12>, <line18>
7028	public class A { <line0> public void destroyVirtualMachine(String virtualMachineId) { <line1> String destroyVirtualMachine = <line2> client.getVirtualMachineApi().destroyVirtualMachine(virtualMachineId); <line3> if (destroyVirtualMachine != null) { <line4> awaitCompletion(destroyVirtualMachine); <line5> } else { <line6> } <line7> } <line8> } <line9> 	<line4>, <line6>
7029	public class A { <line0> public boolean loadModelFromFilename(String file) { <line1> URL fileURL = null; <line2> try { <line3> fileURL = new URL(file); <line4> } catch (MalformedURLException e) { <line5> return false; <line6> } <line7> return loadModelFromURL(fileURL); <line8> } <line9> } <line10> 	<line5>
7030	public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public ServiceDefinitionResponseDTO createServiceDefinitionResponse( <line2> final String serviceDefinition) { <line3> final ServiceDefinition serviceDefinitionEntry = createServiceDefinition(serviceDefinition); <line4> return DTOConverter.convertServiceDefinitionToServiceDefinitionResponseDTO( <line5> serviceDefinitionEntry); <line6> } <line7> } <line8> 	<line3>
7031	"public class A { <line0> private InvocationResults updateComputedCurrentLocations(List<String> csids) { <line1> ResourceMap resourcemap = getResourceMap(); <line2> NuxeoBasedResource collectionObjectResource = <line3> (NuxeoBasedResource) resourcemap.get(CollectionObjectClient.SERVICE_NAME); <line4> NuxeoBasedResource movementResource = <line5> (NuxeoBasedResource) resourcemap.get(MovementClient.SERVICE_NAME); <line6> long numUpdated = 0; <line7> long processed = 0; <line8> long recordsToProcess = csids.size(); <line9> long logInterval = recordsToProcess / 10 + 2; <line10> try { <line11> for (String collectionObjectCsid : csids) { <line12> if (processed % logInterval == 0) { <line13> } <line14> processed++; <line15> if (!requestIsForInvocationModeNoContext()) { <line16> if (isRecordDeleted(collectionObjectResource, collectionObjectCsid)) { <line17> if (logger.isTraceEnabled()) { <line18> } <line19> continue; <line20> } <line21> } <line22> AbstractCommonList relatedMovements = <line23> getRelatedRecords(movementResource, collectionObjectCsid, EXCLUDE_DELETED); <line24> if (relatedMovements.getListItem().isEmpty()) { <line25> continue; <line26> } <line27> AbstractCommonList.ListItem mostRecentMovement = getMostRecentMovement(relatedMovements); <line28> if (mostRecentMovement == null) { <line29> continue; <line30> } <line31> numUpdated = <line32> updateCollectionObjectValues( <line33> collectionObjectResource, <line34> collectionObjectCsid, <line35> mostRecentMovement, <line36> resourcemap, <line37> numUpdated); <line38> } <line39> } catch (Exception e) { <line40> String errMsg = ""Error encountered in "" + CLASSNAME + "": "" + e.getLocalizedMessage() + "" ""; <line41> errMsg = <line42> errMsg <line43> + ""Successfully updated "" <line44> + numUpdated <line45> + "" CollectionObject record(s) prior to error.""; <line46> setErrorResult(errMsg); <line47> getResults().setNumAffected(numUpdated); <line48> return getResults(); <line49> } <line50> getResults().setNumAffected(numUpdated); <line51> return getResults(); <line52> } <line53> } <line54> "	<line13>, <line18>, <line46>, <line50>
7032	"public class A { <line0> public void onKapuaEvent(ServiceEvent kapuaEvent) throws KapuaException { <line1> if (kapuaEvent == null) {} <line2> if (""user"".equals(kapuaEvent.getService()) && ""delete"".equals(kapuaEvent.getOperation())) { <line3> deleteCredentialByUserId(kapuaEvent.getScopeId(), kapuaEvent.getEntityId()); <line4> } else if (""account"".equals(kapuaEvent.getService()) <line5> && ""delete"".equals(kapuaEvent.getOperation())) { <line6> deleteCredentialByAccountId(kapuaEvent.getScopeId(), kapuaEvent.getEntityId()); <line7> } <line8> } <line9> } <line10> "	<line2>
7033	public class A { <line0> @Override <line1> public void service(Mail mail) throws MessagingException { <line2> try { <line3> MimeMessage message = mail.getMessage(); <line4> message.writeTo(System.err); <line5> } catch (IOException ioe) { <line6> } <line7> } <line8> } <line9> 	<line6>
7034	"public class A { <line0> @Override <line1> public KBTemplate findByUUID_G(String uuid, long groupId) throws NoSuchTemplateException { <line2> KBTemplate kbTemplate = fetchByUUID_G(uuid, groupId); <line3> if (kbTemplate == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""uuid=""); <line7> sb.append(uuid); <line8> sb.append("", groupId=""); <line9> sb.append(groupId); <line10> sb.append(""}""); <line11> if (_log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchTemplateException(sb.toString()); <line14> } <line15> return kbTemplate; <line16> } <line17> } <line18> "	<line12>
7035	"public class A { <line0> static void banner(String text) { <line1> log.info(""""); <line2> log.info(repeat(""#"", 100)); <line3> } <line4> } <line5> "	<line3>
7036	"public class A { <line0> @Override <line1> public void redirectToMaster(RoutingContext rc) { <line2> HttpServerRequest request = rc.request(); <line3> String requestURI = request.uri(); <line4> HttpMethod method = request.method(); <line5> HttpServerResponse response = rc.response(); <line6> MasterServer master = coordinator.getMasterMember(); <line7> String host = master.getHost(); <line8> int port = master.getPort(); <line9> if (log.isDebugEnabled()) { <line10> } <line11> @SuppressWarnings(""deprecation"") <line12> HttpClientRequest forwardRequest = <line13> httpClient.request( <line14> method, <line15> port, <line16> host, <line17> requestURI, <line18> forwardResponse -> { <line19> response.setChunked(true); <line20> response.setStatusCode(forwardResponse.statusCode()); <line21> response.putHeader(MESH_FORWARDED_FROM_HEADER, master.getName()); <line22> forwardHeaders(response, forwardResponse); <line23> printHeaders(""Forward response headers"", response.headers()); <line24> Pump.pump(forwardResponse, response).setWriteQueueMaxSize(8192).start(); <line25> forwardResponse.endHandler(v -> response.end()); <line26> }); <line27> forwardHeaders(request, forwardRequest); <line28> forwardRequest.putHeader(MESH_DIRECT_HEADER, ""true""); <line29> forwardRequest.setChunked(true); <line30> if (request.isEnded()) { <line31> proxyEndHandler(forwardRequest, rc.getBody()); <line32> } else { <line33> request <line34> .exceptionHandler( <line35> .endHandler(v -> proxyEndHandler(forwardRequest, null)); <line36> Pump.pump(request, forwardRequest).setWriteQueueMaxSize(8192).start(); <line37> } <line38> } <line39> } <line40> "	<line10>, <line31>, <line35>
7037	"public class A { <line0> @Test <line1> public void givenHttpCallWithHeaderCertificateThenOK() { <line2> final SecureClientConfiguration configuration = <line3> changeConfigurationFile(INGEST_EXTERNAL_CLIENT_CONF_NOKEY); <line4> configuration.setServerPort(vitamServerTestRunner.getBusinessPort()); <line5> final VitamClientFactory<DefaultClient> factory = <line6> new VitamClientFactory<DefaultClient>(configuration, BASE_URI) { <line7> @Override <line8> public DefaultClient getClient() { <line9> return new DefaultClient(this); <line10> } <line11> }; <line12> try (final DefaultClient client = factory.getClient()) { <line13> MultivaluedHashMap<String, Object> headers = new MultivaluedHashMap<>(); <line14> List<Object> objectList = new ArrayList<>(); <line15> objectList.add(pem); <line16> headers.put(GlobalDataRest.X_SSL_CLIENT_CERT, objectList); <line17> client.checkStatus(headers); <line18> } catch (final VitamException e) { <line19> fail(""THIS SHOULD NOT RAIZED AN EXCEPTION""); <line20> } finally { <line21> try { <line22> factory.shutdown(); <line23> } catch (Exception e) { <line24> SysErrLogger.FAKE_LOGGER.ignoreLog(e); <line25> } <line26> } <line27> } <line28> } <line29> "	<line19>
7038	public class A { <line0> private static List<CloudOffer> getSuitableOffersOfModule( <line1> List<Map<String, Object>> listOptions, List<String> listOfferNames) { <line2> ArrayList<CloudOffer> listOffers = new ArrayList<CloudOffer>(); <line3> for (String offerName : listOfferNames) { <line4> CloudOffer offer = getAllCharacteristicsOfCloudOffer(offerName, listOptions); <line5> if (offer != null) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> listOffers.add(offer); <line9> } else { <line10> } <line11> } <line12> return listOffers; <line13> } <line14> } <line15> 	<line7>, <line10>
7039	"public class A { <line0> public JsonArray transformWord2Vec(String inputFrame, String model, int rowCount) <line1> throws InsightsCustomException { <line2> try { <line3> String url = h2oEndpoint + H2ORestApiUrls.TRANSFORM_WORD2VEC; <line4> JsonObject queryParams = new JsonObject(); <line5> queryParams.addProperty(""model"", model); <line6> queryParams.addProperty(""words_frame"", inputFrame + "".hex""); <line7> queryParams.addProperty(""aggregate_method"", ""AVERAGE""); <line8> String response = RestApiHandler.httpQueryParamRequest(url, queryParams, null, ""Get""); <line9> JsonObject payload = new Gson().fromJson(response, JsonObject.class); <line10> JsonObject vectors = payload.get(""vectors_frame"").getAsJsonObject(); <line11> String frameUrl = vectors.get(""URL"").getAsString(); <line12> url = h2oEndpoint + frameUrl; <line13> queryParams = new JsonObject(); <line14> queryParams.addProperty(""row_count"", rowCount); <line15> response = RestApiHandler.httpQueryParamRequest(url, queryParams, null, ""Get""); <line16> return getVectorColumns(response); <line17> } catch (Exception e) { <line18> throw new InsightsCustomException(e.getMessage()); <line19> } <line20> } <line21> } <line22> "	<line3>, <line18>
7040	public class A { <line0> public void stopHBaseCluster() throws IOException { <line1> if (hbaseCluster != null) { <line2> hbaseCluster.shutdown(); <line3> hbaseCluster.waitUntilShutDown(); <line4> hbaseCluster = null; <line5> } <line6> } <line7> } <line8> 	<line2>
7041	"public class A { <line0> private void migrateUserPermissions(User user, Map<String, Set<String>> migratableEntities) { <line1> migratableEntities.forEach( <line2> (entityID, permissions) -> { <line3> final GRNTypeCapability grnTypeCapability = <line4> GrantsMetaMigration.MIGRATION_MAP.get(permissions); <line5> if (grnTypeCapability != null) { <line6> final Capability capability = grnTypeCapability.capability; <line7> GRN targetGRN; <line8> if (permissions.stream().anyMatch(p -> p.contains(VIEW_READ))) { <line9> targetGRN = <line10> getViewGRNType(entityID).map(grnType -> grnType.toGRN(entityID)).orElse(null); <line11> } else { <line12> targetGRN = <line13> requireNonNull( <line14> grnTypeCapability.grnType, ""grnType cannot be null - this is a bug"") <line15> .toGRN(entityID); <line16> } <line17> if (targetGRN != null) { <line18> dbGrantService.ensure(grnRegistry.ofUser(user), capability, targetGRN, rootUsername); <line19> } <line20> final List<String> updatedPermissions = user.getPermissions(); <line21> updatedPermissions.removeAll( <line22> permissions.stream().map(p -> p + "":"" + entityID).collect(Collectors.toSet())); <line23> user.setPermissions(updatedPermissions); <line24> try { <line25> userService.save(user); <line26> } catch (ValidationException e) { <line27> } <line28> } else { <line29> } <line30> }); <line31> } <line32> } <line33> "	<line27>, <line28>, <line29>
7042	"public class A { <line0> private void reportMessageSizes(final Map<URI, URI> msgUris, String name) { <line1> int[] counter = new int[4]; <line2> Set<URI> keys = msgUris.keySet(); <line3> for (URI uri : keys) { <line4> Dataset dataset = <line5> getEventListenerContext().getLinkedDataSource().getDataForResource(uri, msgUris.get(uri)); <line6> record(dataset, counter); <line7> } <line8> String sizeInfo = <line9> ""\nSIZES for "" <line10> + name <line11> + "":\n"" <line12> + ""messages="" <line13> + counter[0] <line14> + "", named-graphs="" <line15> + counter[1] <line16> + "", "" <line17> + ""quads="" <line18> + counter[2] <line19> + "", bytes-in-Trig-UTF8="" <line20> + counter[3]; <line21> } <line22> } <line23> "	<line21>
7043	public class A { <line0> private void createNewID(Connection con, int type) throws SQLException { <line1> PreparedStatement pstmt = null; <line2> try { <line3> pstmt = con.prepareStatement(CREATE_ID); <line4> pstmt.setInt(1, type); <line5> pstmt.execute(); <line6> } finally { <line7> DbConnectionManager.closeStatement(pstmt); <line8> } <line9> } <line10> } <line11> 	<line1>
7044	public class A { <line0> private void optimizeTable(final MySQLTableOptimizer optimizer) { <line1> if (optimizer != null) { <line2> final boolean success = optimizer.optimizeTable(); <line3> } else { <line4> } <line5> } <line6> } <line7> 	<line3>, <line4>
7045	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public T mapBinLogEvent(Row row, Schema schema, DbusOpcode eventType) { <line3> Map<String, Object> keyValuePairs = new HashMap<String, Object>(); <line4> List<Column> columns = row.getColumns(); <line5> List<Schema.Field> orderedFields; <line6> try { <line7> orderedFields = <line8> SchemaHelper.getOrderedFieldsByMetaField( <line9> schema, <line10> ""dbFieldPosition"", <line11> new Comparator<String>() { <line12> public int compare(String o1, String o2) { <line13> Integer pos1 = Integer.parseInt(o1); <line14> Integer pos2 = Integer.parseInt(o2); <line15> return pos1.compareTo(pos2); <line16> } <line17> }); <line18> int cnt = 0; <line19> for (Schema.Field field : orderedFields) { <line20> Column column = null; <line21> if (cnt < columns.size()) { <line22> column = columns.get(cnt); <line23> } <line24> keyValuePairs.put( <line25> field.name(), column == null ? null : orToMysqlMapper.orToMysqlType(column)); <line26> cnt++; <line27> } <line28> return (T) <line29> new SourceEvent( <line30> keyValuePairs, <line31> getPkListFromSchema(schema), <line32> schema.getName(), <line33> schema.getNamespace(), <line34> eventType); <line35> } catch (Exception e) { <line36> } <line37> return null; <line38> } <line39> } <line40> "	<line36>
7046	public class A { <line0> public static void deletePageAttachments(long nodeId, String title) throws RemoteException { <line1> try { <line2> WikiPageServiceUtil.deletePageAttachments(nodeId, title); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	<line4>
7047	public class A { <line0> private void preprocessHiveTypes(PreprocessorContext context) { <line1> List<AtlasEntity> entities = context.getEntities(); <line2> if (entities != null) { <line3> for (int i = 0; i < entities.size(); i++) { <line4> AtlasEntity entity = entities.get(i); <line5> EntityPreprocessor preprocessor = <line6> EntityPreprocessor.getHivePreprocessor(entity.getTypeName()); <line7> if (preprocessor != null) { <line8> preprocessor.preprocess(entity, context); <line9> if (context.isIgnoredEntity(entity.getGuid())) { <line10> entities.remove(i--); <line11> } <line12> } <line13> } <line14> Map<String, AtlasEntity> referredEntities = context.getReferredEntities(); <line15> if (referredEntities != null) { <line16> for (Iterator<Map.Entry<String, AtlasEntity>> iter = referredEntities.entrySet().iterator(); <line17> iter.hasNext(); ) { <line18> AtlasEntity entity = iter.next().getValue(); <line19> EntityPreprocessor preprocessor = <line20> EntityPreprocessor.getHivePreprocessor(entity.getTypeName()); <line21> if (preprocessor != null) { <line22> preprocessor.preprocess(entity, context); <line23> if (context.isIgnoredEntity(entity.getGuid())) { <line24> iter.remove(); <line25> } <line26> } <line27> } <line28> } <line29> int ignoredEntities = context.getIgnoredEntities().size(); <line30> int prunedEntities = context.getPrunedEntities().size(); <line31> if (ignoredEntities > 0 || prunedEntities > 0) { <line32> } <line33> } <line34> } <line35> } <line36> 	<line32>
7048	public class A { <line0> private void processReceive(final CamelContext context, final WireEnvelope envelope) <line1> throws Exception { <line2> final String endpointUri = this.endpointUri; <line3> if (StringUtil.isNullOrEmpty(endpointUri)) { <line4> return; <line5> } <line6> processReceive(context, endpointUri, envelope); <line7> } <line8> } <line9> 	<line4>
7049	public class A { <line0> @Override <line1> public StreamDiscoverListsDTO execute(final Serializable inRequest) { <line2> repopulateTempWeekdaysSinceDateStrategy.execute(numberOfDaysOfWeekdayCountDataToGenerate); <line3> StreamDiscoverListsDTO result = new StreamDiscoverListsDTO(); <line4> result.setFeaturedStreams(featuredStreamDTOMapper.execute(null)); <line5> result.setMostActiveStreams(mostActiveStreamsMapper.execute(null)); <line6> result.setMostViewedStreams(mostViewedStreamsMapper.execute(null)); <line7> result.setMostFollowedStreams(mostFollowedStreamsMapper.execute(null)); <line8> result.setMostRecentStreams(mostRecentStreamsMapper.execute(null)); <line9> return result; <line10> } <line11> } <line12> 	<line2>, <line4>, <line5>, <line6>, <line7>, <line8>, <line9>
7050	public class A { <line0> @Override <line1> public MBThreadFlag remove(Serializable primaryKey) throws NoSuchThreadFlagException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> MBThreadFlag mbThreadFlag = (MBThreadFlag) session.get(MBThreadFlagImpl.class, primaryKey); <line6> if (mbThreadFlag == null) { <line7> if (_log.isDebugEnabled()) { <line8> } <line9> throw new NoSuchThreadFlagException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> return remove(mbThreadFlag); <line12> } catch (NoSuchThreadFlagException noSuchEntityException) { <line13> throw noSuchEntityException; <line14> } catch (Exception exception) { <line15> throw processException(exception); <line16> } finally { <line17> closeSession(session); <line18> } <line19> } <line20> } <line21> 	<line8>
7051	"public class A { <line0> public static com.liferay.knowledge.base.model.KBArticle getLatestKBArticle( <line1> HttpPrincipal httpPrincipal, long resourcePrimKey, int status) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> KBArticleServiceUtil.class, <line7> ""getLatestKBArticle"", <line8> _getLatestKBArticleParameterTypes26); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, resourcePrimKey, status); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.knowledge.base.model.KBArticle) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
7052	"public class A { <line0> public static void deleteCommerceBOMFolder(HttpPrincipal httpPrincipal, long commerceBOMFolderId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> CommerceBOMFolderServiceUtil.class, <line6> ""deleteCommerceBOMFolder"", <line7> _deleteCommerceBOMFolderParameterTypes1); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, commerceBOMFolderId); <line9> try { <line10> TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>
7053	"public class A { <line0> private void attemptCompositeUniqueSpProcessing( <line1> @Nonnull SearchParameterMap theParams, RequestDetails theRequest) { <line2> theParams.values().forEach(nextAndList -> ensureSubListsAreWritable(nextAndList)); <line3> List<RuntimeSearchParam> activeUniqueSearchParams = <line4> mySearchParamRegistry.getActiveUniqueSearchParams(myResourceName, theParams.keySet()); <line5> if (activeUniqueSearchParams.size() > 0) { <line6> StringBuilder sb = new StringBuilder(); <line7> sb.append(myResourceName); <line8> sb.append(""?""); <line9> boolean first = true; <line10> ArrayList<String> keys = new ArrayList<>(theParams.keySet()); <line11> Collections.sort(keys); <line12> for (String nextParamName : keys) { <line13> List<List<IQueryParameterType>> nextValues = theParams.get(nextParamName); <line14> nextParamName = UrlUtil.escapeUrlParam(nextParamName); <line15> if (nextValues.get(0).size() != 1) { <line16> sb = null; <line17> break; <line18> } <line19> RuntimeSearchParam nextParamDef = <line20> mySearchParamRegistry.getActiveSearchParam(myResourceName, nextParamName); <line21> if (nextParamDef.getParamType() == RestSearchParameterTypeEnum.REFERENCE) { <line22> ReferenceParam param = (ReferenceParam) nextValues.get(0).get(0); <line23> if (isBlank(param.getResourceType())) { <line24> sb = null; <line25> break; <line26> } <line27> } <line28> List<? extends IQueryParameterType> nextAnd = nextValues.remove(0); <line29> IQueryParameterType nextOr = nextAnd.remove(0); <line30> String nextOrValue = nextOr.getValueAsQueryToken(myContext); <line31> nextOrValue = UrlUtil.escapeUrlParam(nextOrValue); <line32> if (first) { <line33> first = false; <line34> } else { <line35> sb.append('&'); <line36> } <line37> sb.append(nextParamName).append('=').append(nextOrValue); <line38> } <line39> if (sb != null) { <line40> String indexString = sb.toString(); <line41> StorageProcessingMessage msg = <line42> new StorageProcessingMessage() <line43> .setMessage(""Using unique index for query for search: "" + indexString); <line44> HookParams params = <line45> new HookParams() <line46> .add(RequestDetails.class, theRequest) <line47> .addIfMatchesType(ServletRequestDetails.class, theRequest) <line48> .add(StorageProcessingMessage.class, msg); <line49> CompositeInterceptorBroadcaster.doCallHooks( <line50> myInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_INFO, params); <line51> addPredicateCompositeStringUnique(theParams, indexString, myRequestPartitionId); <line52> } <line53> } <line54> } <line55> } <line56> "	<line41>
7054	"public class A { <line0> @Test <line1> public void mysqlParse6() { <line2> final String jdbcUrl = <line3> CONNECTION_STRING <line4> + ""?useUnicode=true&characterEncoding=UTF-8&noAccessToProcedureBodies=true&autoDeserialize=true&elideSetAutoCommits=true&sessionVariables=time_zone='%2B09:00',tx_isolation='READ-COMMITTED'""; <line5> DatabaseInfo dbInfo = jdbcUrlParser.parse(jdbcUrl); <line6> Assert.assertTrue(dbInfo.isParsingComplete()); <line7> Assert.assertEquals(dbInfo.getType(), SERVICE_TYPE); <line8> Assert.assertEquals(dbInfo.getHost().get(0), IP_PORT); <line9> Assert.assertEquals(dbInfo.getDatabaseId(), DATABASE_ID); <line10> Assert.assertEquals(dbInfo.getUrl(), CONNECTION_STRING); <line11> } <line12> } <line13> "	<line11>
7055	public class A { <line0> private void logException(IOException e) { <line1> if (exceptionLogged) { <line2> return; <line3> } <line4> exceptionLogged = true; <line5> } <line6> } <line7> 	<line4>
7056	"public class A { <line0> HeartbeatMessage createHeartbeatMessage() { <line1> try { <line2> HeartbeatBean bean = heartbeatBeanRef.get(); <line3> if (bean == null) { <line4> readLock.lock(); <line5> try { <line6> bean = new HeartbeatBean(flowManager.getRootGroup(), isPrimary()); <line7> } finally { <line8> readLock.unlock(""createHeartbeatMessage""); <line9> } <line10> } <line11> final HeartbeatPayload hbPayload = new HeartbeatPayload(); <line12> hbPayload.setSystemStartTime(systemStartTime); <line13> hbPayload.setActiveThreadCount(getActiveThreadCount()); <line14> hbPayload.setRevisionUpdateCount(revisionManager.getRevisionUpdateCount()); <line15> final QueueSize queueSize = getTotalFlowFileCount(bean.getRootGroup()); <line16> hbPayload.setTotalFlowFileCount(queueSize.getObjectCount()); <line17> hbPayload.setTotalFlowFileBytes(queueSize.getByteCount()); <line18> hbPayload.setClusterStatus(clusterCoordinator.getConnectionStatuses()); <line19> final NodeIdentifier nodeId = getNodeId(); <line20> if (nodeId == null) { <line21> return null; <line22> } <line23> final Heartbeat heartbeat = new Heartbeat(nodeId, connectionStatus, hbPayload.marshal()); <line24> final HeartbeatMessage message = new HeartbeatMessage(); <line25> message.setHeartbeat(heartbeat); <line26> return message; <line27> } catch (final Throwable ex) { <line28> return null; <line29> } <line30> } <line31> } <line32> "	<line21>, <line26>, <line28>
7057	public class A { <line0> public void persist(TmpItvSel transientInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().persist(transientInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
7058	"public class A { <line0> @SuppressWarnings({""resource"", ""unused""}) <line1> public File writeToFile(String fileName, List<List<Object>> dataValues) { <line2> XSSFWorkbook workbook = new XSSFWorkbook(); <line3> XSSFSheet sheet = workbook.createSheet(""Data""); <line4> FileOutputStream out = null; <line5> File file = null; <line6> int rownum = 0; <line7> for (Object key : dataValues) { <line8> Row row = sheet.createRow(rownum); <line9> List<Object> objArr = dataValues.get(rownum); <line10> int cellnum = 0; <line11> for (Object obj : objArr) { <line12> Cell cell = row.createCell(cellnum++); <line13> if (obj instanceof String) { <line14> cell.setCellValue((String) obj); <line15> } else if (obj instanceof Integer) { <line16> cell.setCellValue((Integer) obj); <line17> } else if (obj instanceof List) { <line18> cell.setCellValue(getListValue(obj)); <line19> } else if (obj instanceof Double) { <line20> cell.setCellValue((Double) obj); <line21> } else { <line22> if (ProjectUtil.isNotNull(obj)) { <line23> cell.setCellValue(obj.toString()); <line24> } <line25> } <line26> } <line27> rownum++; <line28> } <line29> try { <line30> file = new File(fileName + "".xlsx""); <line31> out = new FileOutputStream(file); <line32> workbook.write(out); <line33> } catch (Exception e) { <line34> } finally { <line35> if (null != out) { <line36> try { <line37> out.close(); <line38> } catch (IOException e) { <line39> } <line40> } <line41> } <line42> return file; <line43> } <line44> } <line45> "	<line33>, <line34>, <line39>
7059	public class A { <line0> @Override <line1> protected void checkClient() throws KrbException { <line2> KdcReq request = getKdcReq(); <line3> PrincipalName clientPrincipal; <line4> if (isToken()) { <line5> clientPrincipal = new PrincipalName(getToken().getSubject()); <line6> } else { <line7> clientPrincipal = request.getReqBody().getCname(); <line8> } <line9> if (clientPrincipal == null) { <line10> throw new KrbException(KrbErrorCode.KDC_ERR_C_PRINCIPAL_UNKNOWN); <line11> } <line12> String clientRealm = request.getReqBody().getRealm(); <line13> if (clientRealm == null || clientRealm.isEmpty()) { <line14> clientRealm = getKdcContext().getKdcRealm(); <line15> } <line16> clientPrincipal.setRealm(clientRealm); <line17> setClientPrincipal(clientPrincipal); <line18> KrbIdentity clientEntry; <line19> if (isToken()) { <line20> clientEntry = new KrbIdentity(clientPrincipal.getName()); <line21> clientEntry.setExpireTime(new KerberosTime(getToken().getExpiredTime().getTime())); <line22> } else { <line23> clientEntry = getEntry(clientPrincipal.getName()); <line24> } <line25> if (clientEntry == null) { <line26> throw new KrbException(KrbErrorCode.KDC_ERR_C_PRINCIPAL_UNKNOWN); <line27> } <line28> if (isAnonymous()) { <line29> clientEntry.setPrincipal(new PrincipalName(clientPrincipal.getName(), NameType.NT_WELLKNOWN)); <line30> } <line31> setClientEntry(clientEntry); <line32> for (EncryptionType encType : request.getReqBody().getEtypes()) { <line33> if (clientEntry.getKeys().containsKey(encType)) { <line34> EncryptionKey clientKey = clientEntry.getKeys().get(encType); <line35> setClientKey(clientKey); <line36> break; <line37> } <line38> } <line39> } <line40> } <line41> 	<line5>, <line10>, <line26>
7060	"public class A { <line0> protected void assertNotSshable(Map<?, ?> machineConfig) { <line1> try { <line2> assertSshable(machineConfig); <line3> Assert.fail(""ssh should not have succeeded "" + machineConfig); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> "	<line5>
7061	public class A { <line0> @Override <line1> public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { <line2> if (LOGGER.isTraceEnabled()) { <line3> } <line4> try { <line5> long requestFlow = (long) ((ByteBuf) msg).readableBytes(); <line6> counterContainer.addRequestFlow(requestFlow); <line7> } catch (Throwable e) { <line8> } finally { <line9> ctx.fireChannelRead(msg); <line10> } <line11> } <line12> } <line13> 	<line3>, <line8>
7062	public class A { <line0> private ListenableFuture<Optional<String>> queryIseOnSgt( <line1> final IseContext iseContext, @Nonnull final Sgt sgt) { <line2> final ListenableFuture<Collection<SgtInfo>> sgtUpdateFu = <line3> iseSgtHarvester.harvestAll(iseContext); <line4> Futures.addCallback( <line5> sgtUpdateFu, <line6> new FutureCallback<Collection<SgtInfo>>() { <line7> @Override <line8> public void onSuccess(@Nullable final Collection<SgtInfo> result) { <line9> final Integer amount = Optional.ofNullable(result).map(Collection::size).orElse(0); <line10> } <line11>  <line12> @Override <line13> public void onFailure(final Throwable t) { <line14> } <line15> }, <line16> MoreExecutors.directExecutor()); <line17> return Futures.transform( <line18> sgtUpdateFu, <line19> new Function<Collection<SgtInfo>, Optional<String>>() { <line20> @Nullable <line21> @Override <line22> public Optional<String> apply(@Nullable final Collection<SgtInfo> input) { <line23> return Optional.ofNullable(input) <line24> .flatMap( <line25> safeInput -> <line26> safeInput.stream() <line27> .filter(sgtInfo -> sgt.equals(sgtInfo.getSgt())) <line28> .findFirst() <line29> .map(SgtInfo::getName)); <line30> } <line31> }, <line32> MoreExecutors.directExecutor()); <line33> } <line34> } <line35> 	<line10>, <line14>
7063	public class A { <line0> @Override <line1> public @Nullable ThingUID getThingUID(RemoteDevice device) { <line2> String manufacturer = device.getDetails().getManufacturerDetails().getManufacturer(); <line3> if (containsIgnoreCase(manufacturer, MANUFACTURER)) { <line4> String type = device.getType().getType(); <line5> if (containsIgnoreCase(type, UPNP_DEVICE_TYPE)) { <line6> return new ThingUID(THING_TYPE_KODI, device.getIdentity().getUdn().getIdentifierString()); <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	<line4>, <line6>
7064	public class A { <line0> public String getLocation(final String locationType) { <line1> String value = null; <line2> for (Location location : getLocations().getLocations()) { <line3> if (location.getName().name().trim().equalsIgnoreCase(locationType.trim().toLowerCase())) { <line4> value = location.getPath(); <line5> } <line6> } <line7> return value; <line8> } <line9> } <line10> 	<line7>
7065	"public class A { <line0> public void readFilmListe(String source, final ListeFilme listeFilme, int days) { <line1> try { <line2> listeFilme.clear(); <line3> notifyStart(source); <line4> checkDays(days); <line5> if (source.startsWith(""http"")) { <line6> final URL sourceUrl = new URL(source); <line7> processFromWeb(sourceUrl, listeFilme); <line8> } else processFromFile(source, listeFilme); <line9> } catch (MalformedURLException ex) { <line10> } <line11> if (MemoryUtils.isLowMemoryEnvironment()) DatenFilm.Database.createIndices(); <line12> notifyFertig(source, listeFilme); <line13> } <line14> } <line15> "	<line2>, <line10>
7066	public class A { <line0> public void setOccupancyGroups(List<OccupancyGroup> oGroupList) { <line1> this.oGroupList = oGroupList; <line2> if (areaMap != null) { <line3> processOccupancyGroups(); <line4> } <line5> } <line6> } <line7> 	<line1>
7067	public class A { <line0> protected void handleFailureMessage( <line1> final AppAnswerEvent event, final AppRequestEvent request, final Event.Type eventType) { <line2> try { <line3> setState(ClientRxSessionState.IDLE); <line4> } catch (Exception e) { <line5> if (logger.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> } <line10> 	<line6>
7068	public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent e) { <line2> TagFocusSelector tagFocusSelector = getActionFocusSelector(); <line3> SignalDocument signalDocument = tagFocusSelector.getActiveSignalDocument(); <line4> if (signalDocument == null) { <line5> return; <line6> } <line7> PositionedTag positionedTag = tagFocusSelector.getActiveTag(); <line8> if (positionedTag == null) { <line9> return; <line10> } <line11> TagDocument tagDocument = <line12> signalDocument.getTagDocuments().get(positionedTag.getTagPositionIndex()); <line13> boolean ok = editTagAnnotationDialog.showDialog(positionedTag.getTag(), true); <line14> if (!ok) { <line15> return; <line16> } <line17> StyledTagSet tagSet = tagDocument.getTagSet(); <line18> tagSet.editTag(positionedTag.getTag()); <line19> tagDocument.invalidate(); <line20> } <line21> } <line22> 	<line9>
7069	"public class A { <line0> @POST <line1> @Path(""/transfers/reply"") <line2> @Consumes(MediaType.APPLICATION_XML) <line3> @Produces(MediaType.APPLICATION_JSON) <line4> @Secured(permission = TRANSFERS_REPLY, description = ""Start transfer reply workflow."") <line5> public Response transferReply(InputStream transferReply) { <line6> try (AccessInternalClient client = accessInternalClientFactory.getClient()) { <line7> return client.startTransferReplyWorkflow(transferReply).toResponse(); <line8> } catch (Exception e) { <line9> return Response.status(Status.INTERNAL_SERVER_ERROR) <line10> .entity(getErrorEntity(Status.INTERNAL_SERVER_ERROR, e.getLocalizedMessage())) <line11> .build(); <line12> } <line13> } <line14> } <line15> "	<line9>
7070	public class A { <line0> @Override <line1> public Space apply(String id) { <line2> try { <line3> return retrieve(URI.create(id), Imeji.adminUser); <line4> } catch (ImejiException e) { <line5> } <line6> return null; <line7> } <line8> } <line9> 	<line5>
7071	"public class A { <line0> protected HiveMetaStoreClient getMetaStoreClient() { <line1> if (hiveClient == null) { <line2> try { <line3> HiveConf hiveConf = new HiveConf(); <line4> hiveConf.set(""hive.metastore.uris"", IMConfig.getProperty(""etl.hive-metastore-uris"")); <line5> hiveConf.set(""hive.exec.dynamic.partition.mode"", ""nonstrict""); <line6> hiveConf.set(""hive.exec.dynamic.partition"", ""true""); <line7> hiveConf.set(""hive.exec.max.dynamic.partitions.pernode"", ""1000""); <line8> hiveClient = new HiveMetaStoreClient(hiveConf); <line9> } catch (MetaException e) { <line10> throw new ETLException(e); <line11> } <line12> } <line13> return hiveClient; <line14> } <line15> } <line16> "	<line10>
7072	"public class A { <line0> private void processCategoryAnchor( <line1> AtlasGlossaryCategory storeObject, <line2> AtlasGlossaryCategory updatedCategory, <line3> RelationshipOperation op, <line4> Map<String, AtlasGlossaryCategory> impactedCategories) <line5> throws AtlasBaseException { <line6> if (Objects.isNull(updatedCategory.getAnchor()) && op != RelationshipOperation.DELETE) { <line7> throw new AtlasBaseException(AtlasErrorCode.MISSING_MANDATORY_ANCHOR); <line8> } <line9> AtlasGlossaryHeader existingAnchor = storeObject.getAnchor(); <line10> AtlasGlossaryHeader updatedCategoryAnchor = updatedCategory.getAnchor(); <line11> switch (op) { <line12> case CREATE: <line13> if (StringUtils.isEmpty(updatedCategoryAnchor.getGlossaryGuid())) { <line14> throw new AtlasBaseException(AtlasErrorCode.INVALID_NEW_ANCHOR_GUID); <line15> } else { <line16> if (DEBUG_ENABLED) { <line17> } <line18> String anchorGlossaryGuid = updatedCategory.getAnchor().getGlossaryGuid(); <line19> createRelationship( <line20> defineCategoryAnchorRelation(anchorGlossaryGuid, storeObject.getGuid())); <line21> } <line22> break; <line23> case UPDATE: <line24> if (!Objects.equals(existingAnchor, updatedCategoryAnchor)) { <line25> if (Objects.isNull(updatedCategory.getAnchor().getGlossaryGuid())) { <line26> throw new AtlasBaseException(AtlasErrorCode.INVALID_NEW_ANCHOR_GUID); <line27> } <line28> if (DEBUG_ENABLED) { <line29> } <line30> relationshipStore.deleteById(storeObject.getAnchor().getRelationGuid(), true); <line31> String anchorGlossaryGuid = updatedCategory.getAnchor().getGlossaryGuid(); <line32> AtlasGlossary glossary = dataAccess.load(getGlossarySkeleton(anchorGlossaryGuid)); <line33> storeObject.setQualifiedName(storeObject.getName() + ""@"" + glossary.getQualifiedName()); <line34> if (LOG.isDebugEnabled()) { <line35> } <line36> createRelationship( <line37> defineCategoryAnchorRelation( <line38> updatedCategory.getAnchor().getGlossaryGuid(), storeObject.getGuid())); <line39> updateChildCategories( <line40> storeObject, storeObject.getChildrenCategories(), impactedCategories, false); <line41> } <line42> break; <line43> case DELETE: <line44> if (Objects.nonNull(storeObject.getAnchor())) { <line45> if (DEBUG_ENABLED) { <line46> } <line47> relationshipStore.deleteById(storeObject.getAnchor().getRelationGuid(), true); <line48> } <line49> break; <line50> } <line51> } <line52> } <line53> "	<line17>, <line29>, <line35>, <line46>
7073	public class A { <line0> @Override <line1> public void endWindow() { <line2> super.endWindow(); <line3> if (++windowCount == logWindows) { <line4> long endTime = System.currentTimeMillis(); <line5> totalCount += tupleCount; <line6> windowCount = 0; <line7> beginTime = System.currentTimeMillis(); <line8> tupleCount = 0; <line9> } <line10> } <line11> } <line12> 	<line6>
7074	"public class A { <line0> @Override <line1> public List<FlightVo> convertFlightToFlightVo(List<Flight> flights) { <line2> List<FlightVo> flightVos = new ArrayList<>(); <line3> CountDownCalculator countDownCalculator = new CountDownCalculator(new Date()); <line4> for (Flight f : flights) { <line5> FlightVo vo = new FlightVo(); <line6> Date countDownToDate = f.getFlightCountDownView().getCountDownTimer(); <line7> CountDownVo countDownVo; <line8> if (countDownToDate == null) { <line9> countDownVo = <line10> new CountDownVo(""Error, no date provided (it is null)!"", false, Long.MIN_VALUE); <line11> } else { <line12> countDownVo = countDownCalculator.getCountDownFromDate(countDownToDate); <line13> } <line14> vo.setCountDown(countDownVo); <line15> vo.setDirection(f.getDirection()); <line16> List<CodeShareVo> codeshareList = new ArrayList<>(); <line17> BeanUtils.copyProperties(f, vo); <line18> BeanUtils.copyProperties(f.getMutableFlightDetails(), vo); <line19> Integer fuzzyHits = 0; <line20> if (f.getFlightHitsFuzzy() != null) { <line21> fuzzyHits = f.getFlightHitsFuzzy().getHitCount(); <line22> vo.setFuzzyHitCount(fuzzyHits); <line23> } <line24> if (f.getFlightHitsGraph() != null) { <line25> vo.setGraphHitCount(f.getFlightHitsGraph().getHitCount()); <line26> } <line27> if (f.getFlightHitsWatchlist() != null) { <line28> vo.setListHitCount(f.getFlightHitsWatchlist().getHitCount()); <line29> } <line30> if (f.getFlightHitsRule() != null) { <line31> vo.setRuleHitCount(f.getFlightHitsRule().getHitCount()); <line32> } <line33> if (f.getFlightHitsExternal() != null) { <line34> vo.setExternalHitCount(f.getFlightHitsExternal().getHitCount()); <line35> } <line36> if (f.getFlightPassengerCount() != null) { <line37> vo.setPassengerCount(f.getFlightPassengerCount().getPassengerCount()); <line38> } <line39> vo.setPaxWatchlistLinkHits(fuzzyHits.longValue()); <line40> List<CodeShareFlight> csl = flightRespository.getCodeSharesForFlight(f.getId()); <line41> for (CodeShareFlight cs : csl) { <line42> CodeShareVo codeshare = new CodeShareVo(); <line43> BeanUtils.copyProperties(cs, codeshare); <line44> codeshareList.add(codeshare); <line45> } <line46> vo.setCodeshares(codeshareList); <line47> flightVos.add(vo); <line48> } <line49> return flightVos; <line50> } <line51> } <line52> "	<line9>
7075	public class A { <line0> private boolean unlocked(Ignite ignite) { <line1> IgniteCache<Integer, Integer> cache = ignite.cache(DEFAULT_CACHE_NAME); <line2> for (Integer key : keys) { <line3> if (cache.isLocalLocked(key, false)) { <line4> return false; <line5> } <line6> } <line7> return true; <line8> } <line9> } <line10> 	<line4>
7076	"public class A { <line0> public JSONObject toJson() { <line1> JSONObject result = new JSONObject(); <line2> try { <line3> result.put(""id"", this.getId()); <line4> result.put(""level"", this.getLevel()); <line5> result.put(""fileDesc"", this.getFileDesc()); <line6> result.put(""fileName"", this.getFileName()); <line7> result.put(""fileType"", this.getFileType()); <line8> } catch (JSONException ex) { <line9> } <line10> return result; <line11> } <line12> } <line13> "	<line9>
7077	public class A { <line0> public NextState getScannerState(final ScannerContext instance) { <line1> if (!exception) { <line2> try { <line3> return (NextState) scannerState.get(instance); <line4> } catch (final Exception e) { <line5> exception = true; <line6> } <line7> } <line8> return NextState.MORE_VALUES; <line9> } <line10> } <line11> 	<line5>
7078	"public class A { <line0> private DataObjectAttrExecutor getDayProfileTablePassiveExecutor( <line1> final Set<DayProfileDto> dayProfileSet) { <line2> final AttributeAddress dayProfileTablePassive = <line3> new AttributeAddress(CLASS_ID, OBIS_CODE, ATTRIBUTE_ID_DAY_PROFILE_TABLE_PASSIVE); <line4> final DataObject dayArray = <line5> DataObject.newArrayData( <line6> this.configurationMapper.mapAsList(dayProfileSet, DataObject.class)); <line7> return new DataObjectAttrExecutor( <line8> ""DAYS"", <line9> dayProfileTablePassive, <line10> dayArray, <line11> CLASS_ID, <line12> OBIS_CODE, <line13> ATTRIBUTE_ID_DAY_PROFILE_TABLE_PASSIVE); <line14> } <line15> } <line16> "	<line7>
7079	public class A { <line0> private void processAddedTerminationPoints( <line1> final DataTreeModification<FlowCapableNodeConnector> modification) { <line2> final InstanceIdentifier<FlowCapableNodeConnector> iiToNodeInInventory = <line3> modification.getRootPath().getRootIdentifier(); <line4> TpId terminationPointIdInTopology = provideTopologyTerminationPointId(iiToNodeInInventory); <line5> if (terminationPointIdInTopology != null) { <line6> InstanceIdentifier<TerminationPoint> iiToTopologyTerminationPoint = <line7> provideIIToTopologyTerminationPoint(terminationPointIdInTopology, iiToNodeInInventory); <line8> TerminationPoint point = <line9> prepareTopologyTerminationPoint(terminationPointIdInTopology, iiToNodeInInventory); <line10> sendToTransactionChain(point, iiToTopologyTerminationPoint); <line11> removeLinks(modification.getRootNode().getDataAfter(), point); <line12> } else { <line13> } <line14> } <line15> } <line16> 	<line13>
7080	public class A { <line0> protected void processTerm( <line1> RawRecordContainer event, <line2> int position, <line3> String term, <line4> BloomFilter alreadyIndexedTerms, <line5> TaskInputOutputContext<KEYIN, ? extends RawRecordContainer, KEYOUT, VALUEOUT> context, <line6> ContextWriter<KEYOUT, VALUEOUT> contextWriter, <line7> String fieldName, <line8> String fieldNameToken, <line9> StatusReporter reporter) <line10> throws IOException, InterruptedException { <line11> if (context != null) { <line12> counters.increment(ContentIndexCounters.ALL_PROCESSED_COUNTER, reporter); <line13> } <line14> NormalizedFieldAndValue normFnV = new NormalizedFieldAndValue(fieldNameToken, term); <line15> Set<NormalizedContentInterface> ncis = this.ingestHelper.normalize(normFnV); <line16> for (NormalizedContentInterface nci : ncis) { <line17> if (!(nci instanceof NormalizedFieldAndValue)) { <line18> } <line19> NormalizedFieldAndValue nfv = (NormalizedFieldAndValue) nci; <line20> byte[] fieldVisibility = getVisibility(event, nfv); <line21> createShardEventColumn(event, contextWriter, context, nfv, this.shardId, fieldVisibility); <line22> TermAndZone indexedTermAndZone = <line23> new TermAndZone(nfv.getIndexedFieldValue(), nfv.getIndexedFieldName()); <line24> if ((tokenOffsetCache != null) && tokenOffsetCache.containsKey(indexedTermAndZone)) { <line25> if (log.isDebugEnabled()) { <line26> } <line27> counters.increment(ContentIndexCounters.TOKEN_OFFSET_CACHE_EXISTS, reporter); <line28> } else { <line29> createShardIndexColumns(event, contextWriter, context, nfv, this.shardId, fieldVisibility); <line30> } <line31> if (tokenOffsetCache != null) { <line32> OffsetList overflow = tokenOffsetCache.addOffset(indexedTermAndZone, position); <line33> if (overflow != null) { <line34> NormalizedFieldAndValue overflowNfv = <line35> new NormalizedFieldAndValue(overflow.termAndZone.zone, overflow.termAndZone.term); <line36> byte[] overflowFieldVisibility = getVisibility(event, overflowNfv); <line37> createTermFrequencyIndex( <line38> event, <line39> contextWriter, <line40> context, <line41> this.shardId, <line42> overflowNfv, <line43> overflow.offsets, <line44> overflowFieldVisibility, <line45> false); <line46> counters.increment(ContentIndexCounters.TOKENIZER_OFFSET_CACHE_OVERFLOWS, reporter); <line47> counters.incrementValue( <line48> ContentIndexCounters.TOKENIZER_OFFSET_CACHE_POSITIONS_OVERFLOWED, <line49> overflow.offsets.size(), <line50> reporter); <line51> } <line52> } else { <line53> createTermFrequencyIndex( <line54> event, <line55> contextWriter, <line56> context, <line57> this.shardId, <line58> nfv, <line59> Arrays.asList(position), <line60> fieldVisibility, <line61> false); <line62> } <line63> } <line64> } <line65> } <line66> 	<line18>, <line26>
7081	public class A { <line0> UserToken find(String token) { <line1> EntityManager em = daoManager.getEntityManagerFromFactory(); <line2> UserToken result = null; <line3> try { <line4> daoManager.startTransaction(em); <line5> result = em.find(UserTokenEntity.class, token); <line6> daoManager.commitTransaction(em); <line7> } catch (Exception e) { <line8> daoManager.rollBackTransaction(em); <line9> } finally { <line10> daoManager.closeEntityManager(em); <line11> } <line12> return result; <line13> } <line14> } <line15> 	<line9>
7082	"public class A { <line0> @Override <line1> public void addAttributes( <line2> Document document, DDMStructure ddmStructure, DDMFormValues ddmFormValues) { <line3> boolean legacyDDMIndexFieldsEnabled = isLegacyDDMIndexFieldsEnabled(); <line4> FieldArray fieldArray = (FieldArray) document.getField(DDM_FIELD_ARRAY); <line5> if ((fieldArray == null) && !legacyDDMIndexFieldsEnabled) { <line6> fieldArray = new FieldArray(DDM_FIELD_ARRAY); <line7> document.add(fieldArray); <line8> } <line9> Set<Locale> locales = ddmFormValues.getAvailableLocales(); <line10> Fields fields = toFields(ddmStructure, ddmFormValues); <line11> for (Field field : fields) { <line12> try { <line13> String indexType = ddmStructure.getFieldProperty(field.getName(), ""indexType""); <line14> if (Validator.isNull(indexType) || indexType.equals(""none"")) { <line15> continue; <line16> } <line17> DDMFormField ddmFormField = ddmStructure.getDDMFormField(field.getName()); <line18> String name = null; <line19> Serializable value = null; <line20> if (GetterUtil.getBoolean(ddmStructure.getFieldProperty(field.getName(), ""localizable""))) { <line21> for (Locale locale : locales) { <line22> name = <line23> encodeName( <line24> ddmStructure.getStructureId(), <line25> ddmFormField.getFieldReference(), <line26> locale, <line27> indexType); <line28> value = field.getValue(locale); <line29> if (legacyDDMIndexFieldsEnabled) { <line30> addToDocument(document, field, indexType, name, value); <line31> } else { <line32> fieldArray.addField(createField(ddmFormField, field, indexType, locale, name, value)); <line33> } <line34> } <line35> } else { <line36> name = <line37> encodeName( <line38> ddmStructure.getStructureId(), ddmFormField.getFieldReference(), null, indexType); <line39> value = field.getValue(ddmFormValues.getDefaultLocale()); <line40> if (legacyDDMIndexFieldsEnabled) { <line41> addToDocument(document, field, indexType, name, value); <line42> } else { <line43> fieldArray.addField(createField(ddmFormField, field, indexType, null, name, value)); <line44> } <line45> } <line46> } catch (Exception exception) { <line47> if (_log.isWarnEnabled()) { <line48> } <line49> } <line50> } <line51> } <line52> } <line53> "	<line48>
7083	"public class A { <line0> @Test(timeout = 20000) <line1> public void testIncomingExpiredMessageGetsFilteredAsync() throws Exception { <line2> try (TestAmqpPeer testPeer = new TestAmqpPeer(); ) { <line3> Connection connection = testFixture.establishConnecton(testPeer); <line4> connection.start(); <line5> testPeer.expectBegin(); <line6> Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line7> Queue queue = session.createQueue(""myQueue""); <line8> testPeer.expectReceiverAttach(); <line9> String expiredMessageContent = ""already-expired""; <line10> PropertiesDescribedType props = new PropertiesDescribedType(); <line11> props.setAbsoluteExpiryTime(new Date(System.currentTimeMillis() - 100)); <line12> testPeer.expectLinkFlowRespondWithTransfer( <line13> null, null, props, null, new AmqpValueDescribedType(expiredMessageContent)); <line14> final String liveMsgContent = ""valid""; <line15> testPeer.sendTransferToLastOpenedLinkOnLastOpenedSession( <line16> null, null, null, null, new AmqpValueDescribedType(liveMsgContent), 2); <line17> final MessageConsumer consumer = session.createConsumer(queue); <line18> ModifiedMatcher modified = new ModifiedMatcher(); <line19> modified.withDeliveryFailed(equalTo(true)); <line20> modified.withUndeliverableHere(equalTo(true)); <line21> testPeer.expectDisposition(true, modified, 1, 1); <line22> testPeer.expectDisposition(true, new AcceptedMatcher(), 2, 2); <line23> final CountDownLatch success = new CountDownLatch(1); <line24> final AtomicBoolean listenerFailure = new AtomicBoolean(); <line25> consumer.setMessageListener( <line26> new MessageListener() { <line27> @Override <line28> public void onMessage(Message incoming) { <line29> try { <line30> TextMessage textMessage = (TextMessage) incoming; <line31> if (liveMsgContent.equals(textMessage.getText())) { <line32> success.countDown(); <line33> } else { <line34> listenerFailure.set(true); <line35> } <line36> } catch (Exception e) { <line37> listenerFailure.set(true); <line38> } <line39> } <line40> }); <line41> assertTrue(""didn't get expected message"", success.await(5, TimeUnit.SECONDS)); <line42> assertFalse(""There was a failure in the listener, see logs"", listenerFailure.get()); <line43> testPeer.waitForAllHandlersToComplete(3000); <line44> testPeer.expectClose(); <line45> connection.close(); <line46> testPeer.waitForAllHandlersToComplete(3000); <line47> } <line48> } <line49> } <line50> "	<line35>, <line38>
7084	public class A { <line0> private <T> Mono<T> updateControllerAndRetry( <line1> RxDocumentServiceRequest request, Mono<T> nextRequestMono) { <line2> return this.shouldUpdateRequestController(request) <line3> .flatMap( <line4> shouldUpdate -> { <line5> if (shouldUpdate) { <line6> this.refreshRequestController(); <line7> return this.resolveRequestController() <line8> .flatMap( <line9> updatedController -> { <line10> if (updatedController.canHandleRequest(request)) { <line11> return updatedController <line12> .processRequest(request, nextRequestMono) <line13> .doOnError(throwable -> this.handleException(throwable)); <line14> } else { <line15> return nextRequestMono; <line16> } <line17> }); <line18> } else { <line19> return nextRequestMono; <line20> } <line21> }); <line22> } <line23> } <line24> 	<line15>
7085	"public class A { <line0> private void verifyExports( <line1> FileShare fs, <line2> FileExportUpdateParam param, <line3> String permissions, <line4> String securityType, <line5> String rootUserMapping, <line6> String path) { <line7> Boolean allowedPermission = false; <line8> for (Permissions me : Permissions.values()) { <line9> if (me.name().equalsIgnoreCase(permissions)) { <line10> allowedPermission = true; <line11> break; <line12> } <line13> } <line14> if (!allowedPermission) { <line15> throw APIException.badRequests.invalidPermissionType(permissions); <line16> } <line17> Boolean allowedsecurityType = false; <line18> for (SecurityTypes secType : SecurityTypes.values()) { <line19> if (secType.name().equalsIgnoreCase(securityType)) { <line20> allowedsecurityType = true; <line21> break; <line22> } <line23> } <line24> if (!allowedsecurityType) { <line25> throw APIException.badRequests.invalidSecurityType(securityType); <line26> } <line27> FSExportMap fsExports = fs.getFsExports(); <line28> URI id = fs.getId(); <line29> if (null != fsExports) { <line30> Iterator<FileExport> it = fs.getFsExports().values().iterator(); <line31> while (it.hasNext()) { <line32> FileExport fileExport = it.next(); <line33> boolean isAlreadyExportedToSameEndpoint = false; <line34> if (fileExport.getPath().equals(path)) { <line35> List<String> availableEndpoints = fileExport.getClients(); <line36> List<String> providedEndpoints = param.getAdd(); <line37> for (String providedEndpoint : providedEndpoints) { <line38> if (availableEndpoints.contains(providedEndpoint)) { <line39> isAlreadyExportedToSameEndpoint = true; <line40> break; <line41> } <line42> } <line43> if (isAlreadyExportedToSameEndpoint) { <line44> if (!fileExport.getPermissions().equals(permissions)) { <line45> throw APIException.badRequests.updatingFileSystemExportNotAllowed(""permission""); <line46> } <line47> if (!fileExport.getSecurityType().equals(securityType)) { <line48> throw APIException.badRequests.updatingFileSystemExportNotAllowed(""security type""); <line49> } <line50> if (!fileExport.getRootUserMapping().equals(rootUserMapping)) { <line51> throw APIException.badRequests.updatingFileSystemExportNotAllowed( <line52> ""root user mapping""); <line53> } <line54> } <line55> } <line56> } <line57> } <line58> } <line59> } <line60> "	<line44>
7086	"public class A { <line0> @RequestMapping(value = ""/updateMicromapperEnabled.action"", method = RequestMethod.POST) <line1> @ResponseBody <line2> public Map<String, Object> updateMicromapperEnabled( <line3> @RequestParam Boolean isMicromapperEnabled, @RequestParam String code) throws Exception { <line4> try { <line5> Collection collectionToUpdate = collectionService.findByCode(code); <line6> if (collectionToUpdate != null) { <line7> collectionToUpdate.setMicromappersEnabled(isMicromapperEnabled); <line8> collectionService.update(collectionToUpdate); <line9> } <line10> return getUIWrapper(null, true); <line11> } catch (Exception e) { <line12> return getUIWrapper( <line13> false, ""Unable to update micromapperEnabled for collection, code = "" + code); <line14> } <line15> } <line16> } <line17> "	<line12>
7087	"public class A { <line0> @Override <line1> public boolean processEvents(@SuppressWarnings(""rawtypes"") List<AsyncEvent> events) { <line2> changeTotalEvents(events.size()); <line3> if (!events.isEmpty()) { <line4> try { <line5> checkInitialized(events.get(0).getRegion()); <line6> } catch (RuntimeException ex) { <line7> changeFailedEvents(events.size()); <line8> return true; <line9> } <line10> } <line11> Boolean initialPdxReadSerialized = cache.getPdxReadSerializedOverride(); <line12> cache.setPdxReadSerializedOverride(true); <line13> try { <line14> processEventsList(events); <line15> } finally { <line16> cache.setPdxReadSerializedOverride(initialPdxReadSerialized); <line17> } <line18> return true; <line19> } <line20> } <line21> "	<line8>
7088	"public class A { <line0> @Override <line1> protected void doExecute() throws Exception { <line2> if (skip) { <line3> return; <line4> } <line5> if (isInstall) { <line6> installServerAssembly(); <line7> } else { <line8> checkServerHomeExists(); <line9> } <line10> boolean createServer = false; <line11> if (!serverDirectory.exists()) { <line12> createServer = true; <line13> } else if (refresh) { <line14> FileUtils.forceDelete(serverDirectory); <line15> createServer = true; <line16> } <line17> if (createServer) { <line18> ServerTask serverTask = initializeJava(); <line19> serverTask.setOperation(""create""); <line20> serverTask.setTemplate(template); <line21> serverTask.setNoPassword(noPassword); <line22> serverTask.execute(); <line23> } <line24> copyConfigFiles(); <line25> copyLibertySettings(); <line26> } <line27> } <line28> "	<line3>, <line8>, <line18>, <line23>
7089	public class A { <line0> public void postPreset(DecimalType command) { <line1> ContentItem item = null; <line2> try { <line3> item = handler.getPresetContainer().get(command.intValue()); <line4> postContentItem(item); <line5> } catch (NoPresetFoundException e) { <line6> } <line7> } <line8> } <line9> 	<line6>
7090	public class A { <line0> @Test <line1> public void test_02_long() { <line2> long seed = 20100614; <line3> int lenMask = 0xffff; <line4> int numTests = 10; <line5> randDnaSeqTest(numTests, lenMask, seed); <line6> } <line7> } <line8> 	<line2>
7091	public class A { <line0> @Override <line1> public void setFirewallPortForwardingConfiguration( <line2> List<FirewallPortForwardConfigIP<? extends IPAddress>> firewallConfiguration) <line3> throws KuraException { <line4> deleteAllPortForwardRules(); <line5> ArrayList<PortForwardRule> portForwardRules = new ArrayList<>(); <line6> for (FirewallPortForwardConfigIP<? extends IPAddress> portForwardEntry : <line7> firewallConfiguration) { <line8> if (portForwardEntry.getPermittedNetwork() == null <line9> || portForwardEntry.getPermittedNetwork().getIpAddress() == null) { <line10> try { <line11> portForwardEntry.setPermittedNetwork(getNetworkPair00()); <line12> } catch (UnknownHostException e) { <line13> } <line14> } <line15> PortForwardRule portForwardRule = <line16> new PortForwardRule() <line17> .inboundIface(portForwardEntry.getInboundInterface()) <line18> .outboundIface(portForwardEntry.getOutboundInterface()) <line19> .address(portForwardEntry.getAddress().getHostAddress()) <line20> .protocol(portForwardEntry.getProtocol().name()) <line21> .inPort(portForwardEntry.getInPort()) <line22> .outPort(portForwardEntry.getOutPort()) <line23> .masquerade(portForwardEntry.isMasquerade()) <line24> .permittedNetwork( <line25> portForwardEntry.getPermittedNetwork().getIpAddress().getHostAddress()) <line26> .permittedNetworkMask(portForwardEntry.getPermittedNetwork().getPrefix()) <line27> .permittedMAC(portForwardEntry.getPermittedMac()) <line28> .sourcePortRange(portForwardEntry.getSourcePortRange()); <line29> portForwardRules.add(portForwardRule); <line30> } <line31> addPortForwardRules(portForwardRules); <line32> } <line33> } <line34> 	<line4>, <line8>, <line13>
7092	public class A { <line0> @Override <line1> public void memberRemoved(MembershipEvent membershipEvent) { <line2> } <line3> } <line4> 	<line2>
7093	public class A { <line0> @Override <line1> public void dropIndex() { <line2> try { <line3> Path[] indexPaths = new Path[] {partitionIndexPath(metaClient), fileIdIndexPath(metaClient)}; <line4> for (Path indexPath : indexPaths) { <line5> if (metaClient.getFs().exists(indexPath)) { <line6> metaClient.getFs().delete(indexPath); <line7> } <line8> } <line9> } catch (IOException ioe) { <line10> throw new HoodieIOException(ioe.getMessage(), ioe); <line11> } <line12> } <line13> } <line14> 	<line6>
7094	"public class A { <line0> @GET <line1> @Path(""{token}/clone"") <line2> @Metric(HTTP_CLONE) <line3> public Response getClone(@Context ChannelHandlerContext ctx, @PathParam(""token"") String token) { <line4> blockingIOProcessor.executeDB( <line5> () -> { <line6> try { <line7> String json = dbManager.selectClonedProject(token); <line8> if (json == null) { <line9> json = fileManager.readClonedProjectFromDisk(token); <line10> } <line11> if (json == null) { <line12> ctx.writeAndFlush(serverError(""Requested QR not found.""), ctx.voidPromise()); <line13> } else { <line14> ctx.writeAndFlush(ok(json), ctx.voidPromise()); <line15> } <line16> } catch (Exception e) { <line17> ctx.writeAndFlush(serverError(""Error getting cloned project.""), ctx.voidPromise()); <line18> } <line19> }); <line20> return null; <line21> } <line22> } <line23> "	<line12>, <line17>
7095	public class A { <line0> @Override <line1> public List<NamedThing> getSchemaNames(RuntimeContainer container) throws IOException { <line2> List<NamedThing> result = new ArrayList<>(); <line3> try { <line4> AzureStorageTableService tableService = <line5> new AzureStorageTableService(getAzureConnection(container)); <line6> for (String t : tableService.listTables()) { <line7> result.add(new SimpleNamedThing(t, t)); <line8> } <line9> } catch (NoSuchElementException e) { <line10> if (properties.getConnectionProperties().authenticationType.getValue() <line11> != AuthType.ACTIVE_DIRECTORY_CLIENT_CREDENTIAL) { <line12> throw new ComponentException(e); <line13> } else { <line14> return Collections.emptyList(); <line15> } <line16> } catch (InvalidKeyException | URISyntaxException e) { <line17> throw new ComponentException(e); <line18> } <line19> return result; <line20> } <line21> } <line22> 	<line14>, <line17>
7096	public class A { <line0> void setDefault(SimpleEntry<String, String> keyValueDefault, String currentValue) { <line1> if (StringUtils.isNotEmpty(currentValue)) { <line2> return; <line3> } <line4> clearPropertyDirect(keyValueDefault.getKey()); <line5> addPropertyDirect(keyValueDefault.getKey(), keyValueDefault.getValue()); <line6> } <line7> } <line8> 	<line6>
7097	public class A { <line0> @Override <line1> public void setGlobalAlpha(final double globalAlpha) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> if (globalAlpha >= 0 && globalAlpha <= 1) { <line5> globalAlpha_ = (float) globalAlpha; <line6> final AlphaComposite composite = <line7> AlphaComposite.getInstance(AlphaComposite.SRC_OVER, globalAlpha_); <line8> graphics2D_.setComposite(composite); <line9> } <line10> } <line11> } <line12> 	<line3>
7098	"public class A { <line0> AgentServerHandler loadServerHandler(String jarPath) throws AgentLoaderException { <line1> AgentServerHandler handler = null; <line2> Class pluginClass = null; <line3> try { <line4> PluginLoader loader = PluginLoader.create(jarPath, _loader); <line5> PluginLoader.setClassLoader(loader); <line6> pluginClass = loader.loadPlugin(); <line7> handler = (AgentServerHandler) pluginClass.newInstance(); <line8> } catch (Exception e) { <line9> throw new AgentLoaderException(""Unable to load server handler "" + ""jar: "" + e.getMessage()); <line10> } finally { <line11> if (handler != null) { <line12> PluginLoader.resetClassLoader(handler); <line13> } <line14> } <line15> validateServerHandler(handler, pluginClass.getName()); <line16> return handler; <line17> } <line18> } <line19> "	<line9>
7099	public class A { <line0> @Override <line1> public void run() { <line2> final long start = System.currentTimeMillis(); <line3> try { <line4> checkThreads(); <line5> } catch (Throwable t) { <line6> } finally { <line7> } <line8> } <line9> } <line10> 	<line6>, <line7>
7100	"public class A { <line0> private void benchmarkAddExtendedDataRows( <line1> Random random, int vertexCount, int extendedDataRowCount) { <line2> double startTime = System.currentTimeMillis(); <line3> for (int i = 0; i < extendedDataRowCount; i++) { <line4> String row = ""row"" + i; <line5> String vertexId = ""v"" + random.nextInt(vertexCount); <line6> graph <line7> .prepareVertex(vertexId, VISIBILITY_A) <line8> .addExtendedData(""table1"", row, ""column1"", ""value1"", VISIBILITY_A) <line9> .save(AUTHORIZATIONS_ALL); <line10> } <line11> graph.flush(); <line12> double endTime = System.currentTimeMillis(); <line13> } <line14> } <line15> "	<line13>
7101	public class A { <line0> public GSSContext run() { <line1> try { <line2> GSSManager manager = GSSManager.getInstance(); <line3> GSSName peerName = manager.createName(servicePrincipalName, GSSName.NT_HOSTBASED_SERVICE); <line4> GSSContext context = manager.createContext(peerName, null, null, GSSContext.DEFAULT_LIFETIME); <line5> while (!context.isEstablished()) { <line6> context.initSecContext(socket.getInputStream(), socket.getOutputStream()); <line7> } <line8> return context; <line9> } catch (Exception e) { <line10> return null; <line11> } <line12> } <line13> } <line14> 	<line10>
7102	public class A { <line0> @Nonnull <line1> @Override <line2> public List<DiffFragment> compareChars( <line3> @Nonnull CharSequence text1, <line4> @Nonnull CharSequence text2, <line5> @Nonnull ComparisonPolicy policy, <line6> @Nonnull ProgressIndicator indicator) <line7> throws DiffTooBigException { <line8> if (policy == ComparisonPolicy.IGNORE_WHITESPACES) { <line9> return convertIntoDiffFragments(ByChar.compareIgnoreWhitespaces(text1, text2, indicator)); <line10> } <line11> if (policy == ComparisonPolicy.DEFAULT) { <line12> return convertIntoDiffFragments(ByChar.compareTwoStep(text1, text2, indicator)); <line13> } <line14> return convertIntoDiffFragments(ByChar.compareTwoStep(text1, text2, indicator)); <line15> } <line16> } <line17> 	<line14>
7103	"public class A { <line0> private List<ConfigSource> getConfigMapConfigSources(List<String> configMapNames) { <line1> List<ConfigSource> result = new ArrayList<>(configMapNames.size()); <line2> try { <line3> for (int i = 0; i < configMapNames.size(); i++) { <line4> String configMapName = configMapNames.get(i); <line5> if (log.isDebugEnabled()) { <line6> } <line7> ConfigMap configMap; <line8> String namespace; <line9> if (config.namespace.isPresent()) { <line10> namespace = config.namespace.get(); <line11> configMap = client.configMaps().inNamespace(namespace).withName(configMapName).get(); <line12> } else { <line13> namespace = client.getNamespace(); <line14> configMap = client.configMaps().withName(configMapName).get(); <line15> } <line16> if (configMap == null) { <line17> logMissingOrFail(configMapName, namespace, ""ConfigMap"", config.failOnMissingConfig); <line18> } else { <line19> result.addAll( <line20> configMapConfigSourceUtil.toConfigSources( <line21> configMap.getMetadata(), configMap.getData(), i)); <line22> if (log.isDebugEnabled()) { <line23> } <line24> } <line25> } <line26> return result; <line27> } catch (Exception e) { <line28> throw new RuntimeException( <line29> ""Unable to obtain configuration for ConfigMap objects from Kubernetes API Server at: "" <line30> + client.getConfiguration().getMasterUrl(), <line31> e); <line32> } <line33> } <line34> } <line35> "	<line6>, <line23>
7104	"public class A { <line0> private void verifyOutputSequenceFiles( <line1> FileSystem fs, Configuration conf, String dir, String prefix, List<String> bodies) <line2> throws IOException { <line3> int found = 0; <line4> int expected = bodies.size(); <line5> for (String outputFile : getAllFiles(dir)) { <line6> String name = (new File(outputFile)).getName(); <line7> if (name.startsWith(prefix)) { <line8> SequenceFile.Reader reader = new SequenceFile.Reader(fs, new Path(outputFile), conf); <line9> LongWritable key = new LongWritable(); <line10> BytesWritable value = new BytesWritable(); <line11> while (reader.next(key, value)) { <line12> String body = new String(value.getBytes(), 0, value.getLength()); <line13> if (bodies.contains(body)) { <line14> bodies.remove(body); <line15> found++; <line16> } <line17> } <line18> reader.close(); <line19> } <line20> } <line21> if (!bodies.isEmpty()) { <line22> for (String body : bodies) { <line23> } <line24> } <line25> Assert.assertTrue( <line26> ""Found = "" <line27> + found <line28> + "", Expected = "" <line29> + expected <line30> + "", Left = "" <line31> + bodies.size() <line32> + "" "" <line33> + bodies, <line34> bodies.size() == 0); <line35> } <line36> } <line37> "	<line14>, <line23>
7105	"public class A { <line0> public static void createIndices() { <line1> try (var connection = PooledDatabaseConnection.INSTANCE.getDataSource().getConnection(); <line2> var ignored = new SqlAutoSetAutoCommit(connection, false); <line3> var tm = new SqlAutoRollback(connection); <line4> var statement = connection.createStatement()) { <line5> statement.executeUpdate( <line6> ""CREATE INDEX IF NOT EXISTS IDX_DESC_ID ON mediathekview.description (id)""); <line7> statement.executeUpdate( <line8> ""CREATE INDEX IF NOT EXISTS IDX_WEBSITE_LINKS_ID ON mediathekview.website_links (id)""); <line9> tm.commit(); <line10> } catch (SQLException ex) { <line11> } <line12> } <line13> } <line14> "	<line1>, <line11>, <line12>
7106	public class A { <line0> static GbpAceBuilder allowExternalNetworksForEp( <line1> @Nonnull RendererEndpointKey rendEp, AccessListUtil.ACE_DIRECTION dir) { <line2> InetAddress byName; <line3> try { <line4> byName = InetAddress.getByName(substringBeforeSlash(rendEp.getAddress())); <line5> } catch (UnknownHostException e) { <line6> return null; <line7> } <line8> if (byName instanceof Inet4Address) { <line9> if (AccessListUtil.ACE_DIRECTION.INGRESS.equals(dir)) { <line10> return new GbpAceBuilder(PERMIT_EXTERNAL_INGRESS) <line11> .setIpAddresses(new Ipv4Prefix(rendEp.getAddress()), null) <line12> .setPermit(); <line13> } else { <line14> return new GbpAceBuilder(PERMIT_EXTERNAL_EGRESS) <line15> .setIpAddresses(null, new Ipv4Prefix(rendEp.getAddress())) <line16> .setPermit(); <line17> } <line18> } else if (byName instanceof Inet6Address) { <line19> if (AccessListUtil.ACE_DIRECTION.INGRESS.equals(dir)) { <line20> new GbpAceBuilder(PERMIT_EXTERNAL_INGRESS) <line21> .setIpAddresses(new Ipv6Prefix(rendEp.getAddress()), null) <line22> .setPermit(); <line23> } else { <line24> new GbpAceBuilder(PERMIT_EXTERNAL_EGRESS) <line25> .setIpAddresses(null, new Ipv6Prefix(rendEp.getAddress())) <line26> .setPermit(); <line27> } <line28> } <line29> return null; <line30> } <line31> } <line32> 	<line6>
7107	public class A { <line0> public URI getURI() { <line1> switch (this.uriType) { <line2> case BPELVAR: <line3> return null; <line4> case BOTH: <line5> try { <line6> return new URI(this.getURIPart()); <line7> } catch (final URISyntaxException e) { <line8> } <line9> default: <line10> return this.uri; <line11> } <line12> } <line13> } <line14> 	<line8>
7108	public class A { <line0> @Override <line1> public IntermediateResultsBlock callJob() throws Exception { <line2> int mergedBlocksNumber = 0; <line3> IntermediateResultsBlock mergedBlock = null; <line4> while ((queryEndTime > System.currentTimeMillis()) <line5> && (mergedBlocksNumber < operatorGroups.size())) { <line6> if (mergedBlock == null) { <line7> mergedBlock = <line8> (IntermediateResultsBlock) <line9> blockingQueue.poll( <line10> queryEndTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); <line11> if (mergedBlock != null) { <line12> mergedBlocksNumber++; <line13> } <line14> } else { <line15> IntermediateResultsBlock blockToMerge = <line16> (IntermediateResultsBlock) <line17> blockingQueue.poll( <line18> queryEndTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); <line19> if (blockToMerge != null) { <line20> try { <line21> CombineService.mergeTwoBlocks(_brokerRequest, mergedBlock, blockToMerge); <line22> } catch (Exception e) { <line23> mergedBlock <line24> .getExceptions() <line25> .add(QueryException.getException(QueryException.MERGE_RESPONSE_ERROR, e)); <line26> } <line27> mergedBlocksNumber++; <line28> } <line29> } <line30> } <line31> return mergedBlock; <line32> } <line33> } <line34> 	<line14>, <line21>, <line22>
7109	public class A { <line0> @Override <line1> public void timeoutExpired(Request request) { <line2> try { <line3> sendAndStateLock.lock(); <line4> handleEvent(new Event(Event.Type.FAILED_SEND_RECORD, createAccountRequest(request))); <line5> } catch (Exception e) { <line6> } finally { <line7> sendAndStateLock.unlock(); <line8> } <line9> } <line10> } <line11> 	<line6>
7110	public class A { <line0> public static EzspFrameResponse createHandler(int[] data) { <line1> int frameId; <line2> try { <line3> if (ezspVersion >= 8) { <line4> frameId = data[3] + (data[4] << 8); <line5> } else { <line6> if (data[2] != 0xFF) { <line7> frameId = data[2]; <line8> } else { <line9> frameId = data[4]; <line10> } <line11> } <line12> } catch (ArrayIndexOutOfBoundsException e) { <line13> return null; <line14> } <line15> Class<?> ezspClass = ezspHandlerMap.get(frameId); <line16> if (ezspClass == null) { <line17> return null; <line18> } <line19> Constructor<?> ctor; <line20> try { <line21> ctor = ezspClass.getConstructor(int[].class); <line22> EzspFrameResponse ezspFrame = (EzspFrameResponse) ctor.newInstance(data); <line23> return ezspFrame; <line24> } catch (SecurityException <line25> | NoSuchMethodException <line26> | IllegalArgumentException <line27> | InstantiationException <line28> | IllegalAccessException <line29> | InvocationTargetException e) { <line30> } <line31> return null; <line32> } <line33> } <line34> 	<line13>, <line30>
7111	"public class A { <line0> @Override <line1> public String get() { <line2> return AccessController.doPrivileged( <line3> (PrivilegedAction<String>) <line4> () -> { <line5> try { <line6> return resourceBundleLocator <line7> .getBundle(INTRIGUE_BASE_NAME) <line8> .getString(""validation.attribute.unsupported""); <line9> } catch (IOException e) { <line10> return DEFAULT_MESSAGE_FORMAT; <line11> } <line12> }); <line13> } <line14> } <line15> "	<line10>
7112	"public class A { <line0> public Config getConfig(String factoryPid, String identifier) throws IOException { <line1> try { <line2> Configuration[] configurations = <line3> configAdmin.listConfigurations(""(service.factoryPid="" + factoryPid + "")""); <line4> if (configurations != null) { <line5> for (Configuration configuration : configurations) { <line6> Object filename = configuration.getProperties().get(FELIX_FILEINSTALL_FILENAME); <line7> if (filename != null <line8> && filename.toString().endsWith(""/"" + factoryPid + ""-"" + identifier + "".cfg"")) { <line9> return new ConfigImpl(configuration, identifier); <line10> } <line11> } <line12> } <line13> } catch (InvalidSyntaxException e) { <line14> } <line15> Configuration result = configAdmin.createFactoryConfiguration(factoryPid, ""?""); <line16> return new ConfigImpl(result, identifier); <line17> } <line18> } <line19> "	<line14>
7113	public class A { <line0> @Override <line1> public void process(DistributionMessage msg) { <line2> if (msg instanceof MembershipViewReplyMessage) { <line3> PersistentMembershipView view = ((MembershipViewReplyMessage) msg).view; <line4> if (logger.isDebugEnabled()) { <line5> } <line6> if (view != null) { <line7> synchronized (this) { <line8> this.views.add(view); <line9> } <line10> } <line11> } <line12> super.process(msg); <line13> } <line14> } <line15> 	<line5>
7114	public class A { <line0> @Override <line1> public T localeResolver(LocaleResolver localeResolver) { <line2> if (LOG.isDebugEnabled()) { <line3> if (localeResolver != null) { <line4> } <line5> } <line6> this.localeResolver = localeResolver; <line7> return thisAsT(); <line8> } <line9> } <line10> 	<line4>
7115	public class A { <line0> public void checkPolicy() { <line1> } <line2> } <line3> 	<line1>
7116	"public class A { <line0> @Override <line1> public void execute() { <line2> try { <line3> HuiRelation relation = HUITypeFactory.getInstance().getRelation(linkId); <line4> String hql; <line5> if (PERSON_TYPE_IDS.contains(relation.getFrom())) { <line6> hql = HQL_FOR_LINK_DOWN_FROM_PERSON; <line7> } else if (PERSON_TYPE_IDS.contains(relation.getTo())) { <line8> hql = HQL_FOR_LINK_UP_FROM_PERSON; <line9> } else { <line10> throw new IllegalStateException( <line11> ""Unable to find assignee for task/control "" <line12> + uuid <line13> + "", unsupported relation type "" <line14> + linkId); <line15> } <line16> IBaseDao<Configuration, Serializable> dao = getDaoFactory().getDAO(Configuration.class); <line17> List<?> result = <line18> dao.findByQuery(hql, new String[] {uuid, linkId, Configuration.PROP_USERNAME}); <line19> if (result != null && !result.isEmpty()) { <line20> username = (String) result.get(0); <line21> } <line22> } catch (Exception t) { <line23> } <line24> } <line25> } <line26> "	<line23>
7117	"public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> SchedulableProgramType programType = node.getProgram().getProgramType(); <line3> String programName = node.getProgram().getProgramName(); <line4> String prettyProgramType = ProgramType.valueOf(programType.name()).getPrettyName(); <line5> ProgramWorkflowRunner programWorkflowRunner = <line6> workflowProgramRunnerFactory.getProgramWorkflowRunner( <line7> programType, token, node.getNodeId(), nodeStates); <line8> if (programWorkflowRunner == null) { <line9> throw new UnsupportedOperationException(""Operation not allowed.""); <line10> } <line11> Runnable programRunner = programWorkflowRunner.create(programName); <line12> programRunner.run(); <line13> return null; <line14> } <line15> } <line16> "	<line12>, <line13>
7118	public class A { <line0> private void runIndexing(Session upperSession, Tuple tuple) { <line1> initSession(upperSession); <line2> try { <line3> index(upperSession, entity(upperSession, tuple)); <line4> } catch (Throwable e) { <line5> errorHandler.handleException(log.massIndexerUnexpectedErrorMessage(), e); <line6> } finally { <line7> } <line8> } <line9> } <line10> 	<line7>
7119	public class A { <line0> @Override <line1> public FileVisitResult visitFile(final Path path, final BasicFileAttributes attrs) <line2> throws IOException { <line3> if (attrs.isDirectory()) { <line4> return FileVisitResult.CONTINUE; <line5> } <line6> final File file = path.toFile(); <line7> if (sectionName == null || !sectionName.equals(file.getParentFile().getName())) { <line8> return FileVisitResult.CONTINUE; <line9> } <line10> final String identifier = file.getName(); <line11> ResourceClaim resourceClaim = <line12> resourceClaimManager.getResourceClaim(containerName, sectionName, identifier); <line13> if (resourceClaim == null) { <line14> resourceClaim = <line15> resourceClaimManager.newResourceClaim( <line16> containerName, sectionName, identifier, false, false); <line17> } <line18> activeResourceClaims.add(resourceClaim); <line19> return FileVisitResult.CONTINUE; <line20> } <line21> } <line22> 	<line8>
7120	"public class A { <line0> public void delete(String filename) { <line1> File file = new File(filename); <line2> if (!file.delete()) { <line3> throw new IllegalStateException(""Unable to delete the following file: "" + filename); <line4> } <line5> } <line6> } <line7> "	<line3>
7121	public class A { <line0> private void invocationResponse2(String mexid, InvokeResponse responseChannel) { <line1> MessageExchangeDAO mex = _dao.getConnection().getMessageExchange(mexid); <line2> ProcessMessageExchangeEvent evt = new ProcessMessageExchangeEvent(); <line3> evt.setPortType(mex.getPortType()); <line4> evt.setMexId(mexid); <line5> evt.setOperation(mex.getOperation()); <line6> MessageExchange.Status status = MessageExchange.Status.valueOf(mex.getStatus()); <line7> switch (status) { <line8> case FAULT: <line9> evt.setAspect(ProcessMessageExchangeEvent.PARTNER_FAULT); <line10> responseChannel.onFault(); <line11> break; <line12> case RESPONSE: <line13> evt.setAspect(ProcessMessageExchangeEvent.PARTNER_OUTPUT); <line14> responseChannel.onResponse(); <line15> break; <line16> case FAILURE: <line17> evt.setAspect(ProcessMessageExchangeEvent.PARTNER_FAILURE); <line18> responseChannel.onFailure(); <line19> break; <line20> default: <line21> } <line22> sendEvent(evt); <line23> } <line24> } <line25> 	<line1>, <line21>
