	without_logging_code_index	label
5491	public class A { <line0> private void processResults(List<Result> results, File dumpDir, AtomicLong resultCount) { <line1> for (final Result result : results) { <line2> Metacard metacard = result.getMetacard(); <line3> try { <line4> exportMetacard(dumpDir, metacard, resultCount); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> } <line10> 	<line6>
5492	public class A { <line0> @Override <line1> public Map<String, String> getServerOpOptions( <line2> final String index, final String serverOpName, final ServerOpScope scope) { <line3> try { <line4> final IteratorSetting setting = <line5> connector <line6> .tableOperations() <line7> .getIteratorSetting(getQualifiedTableName(index), serverOpName, toAccumulo(scope)); <line8> if (setting != null) { <line9> return setting.getOptions(); <line10> } <line11> } catch (AccumuloSecurityException | AccumuloException | TableNotFoundException e) { <line12> } <line13> return Collections.emptyMap(); <line14> } <line15> } <line16> 	<line12>
5493	public class A { <line0> @Override <line1> public void endAddressScan() throws Exception { <line2> Map<SimpleString, Map<SimpleString, QueueConfiguration>> scannedAddresses = scanAddresses; <line3> this.scanAddresses = null; <line4> Stream<Binding> bindings = server.getPostOffice().getAllBindings(); <line5> bindings.forEach( <line6> (binding) -> { <line7> if (binding instanceof LocalQueueBinding) { <line8> LocalQueueBinding localQueueBinding = (LocalQueueBinding) binding; <line9> Map<SimpleString, QueueConfiguration> scannedQueues = <line10> scannedAddresses.get(localQueueBinding.getQueue().getAddress()); <line11> if (scannedQueues == null) { <line12> if (logger.isDebugEnabled()) { <line13> } <line14> try { <line15> deleteQueue( <line16> localQueueBinding.getQueue().getAddress(), <line17> localQueueBinding.getQueue().getName()); <line18> } catch (Exception e) { <line19> } <line20> } else { <line21> QueueConfiguration queueConfg = <line22> scannedQueues.get(localQueueBinding.getQueue().getName()); <line23> if (queueConfg == null) { <line24> if (logger.isDebugEnabled()) { <line25> } <line26> try { <line27> deleteQueue( <line28> localQueueBinding.getQueue().getAddress(), <line29> localQueueBinding.getQueue().getName()); <line30> } catch (Exception e) { <line31> } <line32> } <line33> } <line34> } <line35> }); <line36> } <line37> } <line38> 	<line13>, <line19>, <line25>, <line31>
5494	public class A { <line0> private NodeList getElementsByTagName(final QName qname) { <line1> try (final DBBroker broker = pool.getBroker()) { <line2> final MutableDocumentSet docs = new DefaultDocumentSet(); <line3> docs.add(this); <line4> final NewArrayNodeSet contextSet = new NewArrayNodeSet(); <line5> final ElementImpl root = ((ElementImpl) getDocumentElement()); <line6> contextSet.add(new NodeProxy(this, root.getNodeId(), root.getInternalAddress())); <line7> return broker <line8> .getStructuralIndex() <line9> .scanByType( <line10> ElementValue.ELEMENT, <line11> Constants.DESCENDANT_SELF_AXIS, <line12> new NameTest(Type.ELEMENT, qname), <line13> false, <line14> docs, <line15> contextSet, <line16> Expression.NO_CONTEXT_ID); <line17> } catch (final Exception e) { <line18> } <line19> return NodeSet.EMPTY_SET; <line20> } <line21> } <line22> 	<line18>
5495	public class A { <line0> @Override <line1> public void applicationStarted(ComponentContext context) throws Exception { <line2> super.applicationStarted(context); <line3> if (!tracerFactory.getRecordingState()) { <line4> } <line5> bindManagement(); <line6> Framework.addListener( <line7> new RuntimeServiceListener() { <line8> @Override <line9> public void handleEvent(RuntimeServiceEvent event) { <line10> if (event.id != RuntimeServiceEvent.RUNTIME_ABOUT_TO_STOP) { <line11> return; <line12> } <line13> Framework.removeListener(this); <line14> try { <line15> unBindManagement(); <line16> } catch (MalformedObjectNameException <line17> | NotCompliantMBeanException <line18> | InstanceAlreadyExistsException <line19> | MBeanRegistrationException <line20> | InstanceNotFoundException cause) { <line21> } <line22> } <line23> }); <line24> } <line25> } <line26> 	<line4>, <line21>
5496	"public class A { <line0> protected void logAndRegister(PigServer server, String query, int lineNumber) throws IOException { <line1> assert lineNumber > 0 : ""(lineNumber > 0) is false""; <line2> server.registerQuery(query, lineNumber); <line3> } <line4> } <line5> "	<line2>
5497	public class A { <line0> @javax.annotation.Nullable <line1> public List<String> findSuffixChildren(String key, int limit) { <line2> if (key == null || limit == 0) { <line3> return null; <line4> } <line5> RadixNode<T> currentNode = root; <line6> String remainingText = key.trim(); <line7> List<String> result = new LinkedList<String>(); <line8> do { <line9> boolean flag = false; <line10> for (RadixNode<T> child : currentNode.getChildren()) { <line11> if (child.getKey().charAt(0) == remainingText.charAt(0)) { <line12> flag = true; <line13> if (!remainingText.startsWith(child.getKey())) { <line14> return null; <line15> } <line16> if (StringUtils.equals(child.getKey(), remainingText)) { <line17> int counter = 0; <line18> for (RadixNode<T> suffixChild : child.getChildren()) { <line19> if (limit < 0 || counter < limit) { <line20> result.add(suffixChild.getKey()); <line21> } <line22> } <line23> return Collections.unmodifiableList(result); <line24> } <line25> remainingText = remainingText.substring(child.getKey().length()); <line26> currentNode = child; <line27> break; <line28> } <line29> } <line30> if (!flag) { <line31> return null; <line32> } <line33> } while (true); <line34> } <line35> } <line36> 	<line11>, <line12>
5498	public class A { <line0> @Override <line1> public void debug(String arg0) { <line2> if (debug) { <line3> } <line4> } <line5> } <line6> 	<line3>
5499	"public class A { <line0> @Test <line1> public void testNotPresent() { <line2> String msg = ""vacuum""; <line3> LogListener notPresent = LogListener.matches(msg).times(0).build(); <line4> log.registerListener(notPresent); <line5> assertTrue(notPresent.check()); <line6> assertFalse(notPresent.check()); <line7> } <line8> } <line9> "	<line5>, <line6>
5500	"public class A { <line0> public static String getJournalControlPanelLink( <line1> long folderId, long groupId, LiferayPortletResponse liferayPortletResponse) { <line2> if (liferayPortletResponse != null) { <line3> return PortletURLBuilder.createRenderURL(liferayPortletResponse) <line4> .setParameter(""folderId"", folderId) <line5> .setParameter(""groupId"", groupId) <line6> .buildString(); <line7> } <line8> try { <line9> String portletId = <line10> PortletProviderUtil.getPortletId( <line11> JournalArticle.class.getName(), PortletProvider.Action.EDIT); <line12> String articleURL = PortalUtil.getControlPanelFullURL(groupId, portletId, null); <line13> String namespace = PortalUtil.getPortletNamespace(JournalPortletKeys.JOURNAL); <line14> articleURL = HttpUtil.addParameter(articleURL, namespace + ""groupId"", groupId); <line15> return HttpUtil.addParameter(articleURL, namespace + ""folderId"", folderId); <line16> } catch (PortalException portalException) { <line17> } <line18> return StringPool.BLANK; <line19> } <line20> } <line21> "	<line17>
5501	public class A { <line0> private void ackSystemProperties() { <line1> assert log != null; <line2> if (log.isDebugEnabled() && S.includeSensitive()) <line3> for (Map.Entry<Object, Object> entry : snapshot().entrySet()) <line4> } <line5> } <line6> 	<line4>
5502	public class A { <line0> @Override <line1> public void prepareToStart() { <line2> try { <line3> submitter.prepareToStart(this); <line4> } catch (KaramelException ex) { <line5> machine <line6> .getGroup() <line7> .getCluster() <line8> .issueFailure(new Failure(Failure.Type.TASK_FAILED, uuid, ex.getMessage())); <line9> dagCallback.failed(ex.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line9>
5503	public class A { <line0> @Override <line1> public void shutdown() { <line2> if (connectCheckFuture != null) { <line3> connectCheckFuture.cancel(true); <line4> } <line5> if (managedChannel != null) { <line6> managedChannel.shutdownNow(); <line7> } <line8> } <line9> } <line10> 	<line8>
5504	public class A { <line0> @Override <line1> @GraphTransaction <line2> public AtlasRelationship getById(String guid) throws AtlasBaseException { <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> AtlasEdge edge = graphHelper.getEdgeForGUID(guid); <line6> AtlasRelationship ret = entityRetriever.mapEdgeToAtlasRelationship(edge); <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> return ret; <line10> } <line11> } <line12> 	<line4>, <line8>
5505	"public class A { <line0> @Test( <line1> groups = {""integration"", ""live""}, <line2> singleThreaded = true) <line3> public void testListSecurityGroups() throws Exception { <line4> skipIfSecurityGroupsNotSupported(); <line5> final long begin = new Date().getTime(); <line6> ComputeService computeService = view.getComputeService(); <line7> Optional<SecurityGroupExtension> securityGroupExtension = <line8> computeService.getSecurityGroupExtension(); <line9> assertTrue(securityGroupExtension.isPresent(), ""security extension was not present""); <line10> final SecurityGroupExtension security = securityGroupExtension.get(); <line11> Set<SecurityGroup> beforeAdd = security.listSecurityGroups(); <line12> int countBeforeAdd = beforeAdd.size(); <line13> String someUnlikelyName = String.valueOf(new Random().nextInt(1000000) + 1000000); <line14> final SecurityGroup testGroup = <line15> security.createSecurityGroup(someUnlikelyName, getNodeTemplate().getLocation()); <line16> try { <line17> verifyAndDeleteSecurityGroup(security, countBeforeAdd, testGroup); <line18> } catch (Exception e) { <line19> throw e; <line20> } <line21> final long end = new Date().getTime(); <line22> assertTrue(end - begin < TimeUnit.MINUTES.toMillis(5)); <line23> } <line24> } <line25> "	<line10>, <line13>, <line14>, <line19>
5506	public class A { <line0> @Test <line1> public void visitDeleteCommand() { <line2> DeleteCommand command = new DeleteCommand(remoteFactHandle, myEntryPoint); <line3> executeAndVerify( <line4> command, <line5> commandHandler::visit, <line6> () -> { <line7> verify(kieSessionMock, times(1)).getEntryPoint(eq(myEntryPoint)); <line8> verify(entryPointMock, times(1)).delete(eq(factHandleMock)); <line9> }); <line10> } <line11> } <line12> 	<line10>
5507	public class A { <line0> public ResponseEntity<Resource> exportCsvArchiveUnitsByCriteria( <line1> SearchCriteriaDto query, ExternalHttpContext context) { <line2> MultiValueMap<String, String> headers = buildSearchHeaders(context); <line3> final HttpEntity<SearchCriteriaDto> request = new HttpEntity<>(query, headers); <line4> final ResponseEntity<Resource> response = <line5> restTemplate.exchange( <line6> getUrl() + RestApi.EXPORT_CSV_SEARCH_PATH, HttpMethod.POST, request, Resource.class); <line7> return response; <line8> } <line9> } <line10> 	<line2>
5508	"public class A { <line0> public static List<ILibraryManager> setUp( <line1> boolean cleanup, <line2> String configFile, <line3> AsterixHyracksIntegrationUtil alternateIntegrationUtil, <line4> boolean startHdfs, <line5> List<Pair<IOption, Object>> opts) <line6> throws Exception { <line7> System.out.println(""Starting setup""); <line8> if (LOGGER.isInfoEnabled()) { <line9> } <line10> if (LOGGER.isInfoEnabled()) { <line11> } <line12> integrationUtil = alternateIntegrationUtil; <line13> if (opts != null) { <line14> for (Pair<IOption, Object> p : opts) { <line15> integrationUtil.addOption(p.getLeft(), p.getRight()); <line16> } <line17> } <line18> integrationUtil.init(cleanup, configFile); <line19> if (LOGGER.isInfoEnabled()) { <line20> } <line21> if (startHdfs) { <line22> HDFSCluster.getInstance().setup(); <line23> } <line24> System.setProperty( <line25> ExternalDataConstants.NODE_RESOLVER_FACTORY_PROPERTY, <line26> IdentitiyResolverFactory.class.getName()); <line27> FailedGroup = new TestGroup(); <line28> FailedGroup.setName(""failed""); <line29> List<ILibraryManager> libraryManagers = new ArrayList<>(); <line30> for (NodeControllerService nc : integrationUtil.ncs) { <line31> INcApplicationContext runtimeCtx = (INcApplicationContext) nc.getApplicationContext(); <line32> libraryManagers.add(runtimeCtx.getLibraryManager()); <line33> } <line34> return libraryManagers; <line35> } <line36> } <line37> "	<line9>, <line11>, <line20>
5509	"public class A { <line0> @Override <line1> public String calculateChecksum(URI file) throws CatalogIOException { <line2> String checksum; <line3> try { <line4> String[] command = {""md5sum"", file.getPath()}; <line5> Process p = Runtime.getRuntime().exec(command); <line6> BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream())); <line7> checksum = br.readLine(); <line8> if (p.waitFor() != 0) { <line9> br = new BufferedReader(new InputStreamReader(p.getErrorStream())); <line10> throw new CatalogIOException( <line11> ""md5sum failed with exit value : "" + p.exitValue() + "". ERROR: "" + br.readLine()); <line12> } <line13> } catch (IOException | InterruptedException e) { <line14> throw new CatalogIOException(""Checksum error in file "" + file, e); <line15> } <line16> return checksum.split("" "")[0]; <line17> } <line18> } <line19> "	<line5>, <line9>
5510	public class A { <line0> @Override <line1> public void onDisable() { <line2> for (final Player player : Bukkit.getOnlinePlayers()) { <line3> final Conversation conv = Conversation.getConversation(PlayerConverter.getID(player)); <line4> if (conv != null) { <line5> conv.suspend(); <line6> } <line7> player.closeInventory(); <line8> } <line9> saver.end(); <line10> Compatibility.disable(); <line11> database.closeConnection(); <line12> StaticEvents.stop(); <line13> playerHider.stop(); <line14> if (this.adventure != null) { <line15> this.adventure.close(); <line16> this.adventure = null; <line17> } <line18> rpgMenu.onDisable(); <line19> } <line20> } <line21> 	<line14>
5511	public class A { <line0> @Override <line1> public void destroy() throws Exception { <line2> sslCtx = null; <line3> ssl = null; <line4> updateThreadRunning.compareAndSet(true, false); <line5> nodeRefreshThread.interrupt(); <line6> try { <line7> nodeRefreshThread.join(); <line8> } catch (InterruptedException e) { <line9> Thread.currentThread().interrupt(); <line10> } <line11> nodeRefreshThread = null; <line12> } <line13> } <line14> 	<line2>
5512	"public class A { <line0> @Beta <line1> public void addToLocalUnpersistedTypeRegistry(RegisteredType type, boolean canForce) { <line2> Preconditions.checkNotNull(type); <line3> Preconditions.checkNotNull(type.getSymbolicName()); <line4> Preconditions.checkNotNull(type.getVersion()); <line5> Preconditions.checkNotNull(type.getId()); <line6> if (!type.getId().equals(type.getSymbolicName() + "":"" + type.getVersion())) <line7> Asserts.fail(""Registered type "" + type + "" has ID / symname mismatch""); <line8> RegisteredType oldType = mgmt.getTypeRegistry().get(type.getId()); <line9> if (oldType == null || canForce) { <line10> localRegisteredTypes.put(type.getId(), type); <line11> } else { <line12> if (oldType == type) { <line13> return; <line14> } <line15> throw new IllegalStateException( <line16> ""Cannot add "" + type + "" to catalog; different "" + oldType + "" is already present""); <line17> } <line18> } <line19> } <line20> "	<line10>
5513	"public class A { <line0> public StudyDashboardResponse studyDashboardInfo(String studyId) throws OrchestrationException { <line1> LOGGER.entry(""begin studyDashboardInfo()""); <line2> StudyDashboardResponse studyDashboardResponse = new StudyDashboardResponse(); <line3> try { <line4> studyDashboardResponse = dashboardMetaDataDao.studyDashboardInfo(studyId); <line5> } catch (Exception e) { <line6> } <line7> LOGGER.exit(""studyDashboardInfo() :: Ends""); <line8> return studyDashboardResponse; <line9> } <line10> } <line11> "	<line6>
5514	public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseSoap <line1> fetchByExternalReferenceCode(String externalReferenceCode, long companyId) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.inventory.model.CommerceInventoryWarehouse returnValue = <line5> CommerceInventoryWarehouseServiceUtil.fetchByExternalReferenceCode( <line6> externalReferenceCode, companyId); <line7> return com.liferay.commerce.inventory.model.CommerceInventoryWarehouseSoap.toSoapModel( <line8> returnValue); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line10>
5515	public class A { <line0> public static com.liferay.style.book.model.StyleBookEntrySoap copyStyleBookEntry( <line1> long groupId, <line2> long styleBookEntryId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws RemoteException { <line5> try { <line6> com.liferay.style.book.model.StyleBookEntry returnValue = <line7> StyleBookEntryServiceUtil.copyStyleBookEntry(groupId, styleBookEntryId, serviceContext); <line8> return com.liferay.style.book.model.StyleBookEntrySoap.toSoapModel(returnValue); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line10>
5516	public class A { <line0> protected void handleList() { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> Collection<String> commands = cliRunLookup.getCommands(); <line4> PrintStream writer = System.out; <line5> writer.println(getMessage(LIST_OPTION_OUTPUT)); <line6> for (String command : commands) { <line7> writer.println(HelpFormatter.GUTTER + command); <line8> } <line9> } <line10> } <line11> 	<line2>
5517	public class A { <line0> public int newReplicaRequest( <line1> String requesterLookupName, ReplicaRequestPacket replicaRequestPacket) { <line2> _lock.lock(); <line3> try { <line4> String channelName = <line5> XapExtensions.getInstance().getReplicationUtils().toChannelName(requesterLookupName); <line6> if (_logger.isDebugEnabled()) <line7> String groupName = replicaRequestPacket.getGroupName(); <line8> _replicationNode.onNewReplicaRequest( <line9> groupName, channelName, replicaRequestPacket.isSynchronizeRequest()); <line10> if (replicaRequestPacket.isSynchronizeRequest()) { <line11> IReplicationSourceGroup sourceGroup = _replicationNode.getReplicationSourceGroup(groupName); <line12> for (Iterator<Entry<Object, ReplicaRequestData>> iterator = <line13> _activeReplicaProcesses.entrySet().iterator(); <line14> iterator.hasNext(); ) { <line15> Entry<Object, ReplicaRequestData> next = iterator.next(); <line16> ReplicaRequestData requestData = next.getValue(); <line17> if (requestData.isSynchronizeReplica() <line18> && requestData.getGroupName().equals(groupName) <line19> && requestData.getOriginLookupName().equals(channelName)) { <line20> sourceGroup.stopSynchronization(channelName); <line21> iterator.remove(); <line22> } <line23> } <line24> boolean syncListRecovery = isDirectPersistencySyncReplicaRequest(replicaRequestPacket); <line25> sourceGroup.beginSynchronizing( <line26> channelName, replicaRequestPacket.getSourceUniqueId(), syncListRecovery); <line27> if (syncListRecovery) handleSyncList(replicaRequestPacket); <line28> } <line29> int contextId = _lastContextId++; <line30> _activeReplicaProcesses.put( <line31> contextId, <line32> new ReplicaRequestData( <line33> groupName, <line34> channelName, <line35> _replicaDataProducerBuilder.createProducer( <line36> replicaRequestPacket.getParameters(), contextId), <line37> replicaRequestPacket.isSynchronizeRequest())); <line38> if (_logger.isDebugEnabled()) <line39> return contextId; <line40> } finally { <line41> _lock.unlock(); <line42> } <line43> } <line44> } <line45> 	<line7>, <line39>
5518	"public class A { <line0> private Set<MappingAttributePathInstance> migrateMappingInputs( <line1> final Set<MappingAttributePathInstance> referenceInputMAPIs, <line2> final Map<AttributePath, AttributePath> attributePathAttributePathMap, <line3> final Map<String, String> attributePathStringsMap) <line4> throws DMPControllerException { <line5> if (referenceInputMAPIs == null) { <line6> return null; <line7> } <line8> final Set<MappingAttributePathInstance> newInputMAPIs = new LinkedHashSet<>(); <line9> for (final MappingAttributePathInstance referenceInputMAPI : referenceInputMAPIs) { <line10> final AttributePath referenceAP = referenceInputMAPI.getAttributePath(); <line11> final AttributePath newAttributePath = attributePathAttributePathMap.get(referenceAP); <line12> if (newAttributePath == null) { <line13> final String message = <line14> String.format( <line15> ""couldn't find new attribute path for reference attribute path '%s'"", <line16> referenceAP.getUuid()); <line17> throw new DMPControllerException(message); <line18> } <line19> final String newInputMAPIUuid = <line20> UUIDService.getUUID(MappingAttributePathInstance.class.getSimpleName()); <line21> final MappingAttributePathInstance newInputMAPI = <line22> new MappingAttributePathInstance(newInputMAPIUuid); <line23> newInputMAPI.setAttributePath(newAttributePath); <line24> newInputMAPI.setOrdinal(referenceInputMAPI.getOrdinal()); <line25> newInputMAPI.setName(referenceInputMAPI.getName()); <line26> migrateMappingInputFilter(referenceInputMAPI, newInputMAPI, attributePathStringsMap); <line27> newInputMAPIs.add(newInputMAPI); <line28> } <line29> return newInputMAPIs; <line30> } <line31> } <line32> "	<line17>
5519	public class A { <line0> protected boolean isValidChar(int codepoint) { <line1> Character.UnicodeBlock block = Character.UnicodeBlock.of(codepoint); <line2> return (!Character.isISOControl(codepoint)) <line3> && block != null <line4> && !Character.UnicodeBlock.SPECIALS.equals(block); <line5> } <line6> } <line7> 	<line2>
5520	public class A { <line0> @Override <line1> public void emitExportCreated(Consumer consumer) { <line2> } <line3> } <line4> 	<line2>
5521	public class A { <line0> public int executeUpdateDeleteQuery(String cqlQuery) { <line1> Session session = null; <line2> try { <line3> if (log.isInfoEnabled()) { <line4> } <line5> session = factory.getConnection(); <line6> KunderaCoreUtils.printQuery(cqlQuery, showQuery); <line7> session.execute(cqlQuery); <line8> } finally { <line9> } <line10> return 0; <line11> } <line12> } <line13> 	<line4>
5522	public class A { <line0> public void unbindRequestedFromServer(Unbind packet, Long serverSessionId) { <line1> if (logger.isDebugEnabled()) <line2> connectionsToServers.remove(serverSessionId); <line3> if (connectionsToServers.isEmpty()) { <line4> if (logger.isDebugEnabled()) <line5> for (Long key : customers.keySet()) customers.get(key).sendUnbindRequest(packet); <line6> MClientConnectionImpl mClientConnectionImpl = connectionsToServers.get(serverSessionId); <line7> if (logger.isDebugEnabled()) <line8> if (mClientConnectionImpl != null) { <line9> mClientConnectionImpl.sendUnbindResponse(packet.createResponse()); <line10> } <line11> } <line12> } <line13> } <line14> 	<line2>, <line5>, <line8>
5523	"public class A { <line0> public String echo(String input) { <line1> return ""Hello "" + input; <line2> } <line3> } <line4> "	<line1>
5524	public class A { <line0> @Override <line1> public void onStop() throws Exception { <line2> closeSinkHandlers(); <line3> } <line4> } <line5> 	<line2>
5525	public class A { <line0> public void runUpdateConflictOnUdp() throws Exception { <line1> do { <line2> Document conflictDocument = new Document(); <line3> conflictDocument.setId(UUID.randomUUID().toString()); <line4> conflictDocument = <line5> this.tryInsertDocument(clients.get(0), this.udpCollectionUri, conflictDocument, 0) <line6> .firstOrDefault(null) <line7> .toBlocking() <line8> .first(); <line9> TimeUnit.SECONDS.sleep(1); <line10> ArrayList<Observable<Document>> updateTask = new ArrayList<Observable<Document>>(); <line11> int index = 0; <line12> for (AsyncDocumentClient client : this.clients) { <line13> updateTask.add( <line14> this.tryUpdateDocument(client, this.udpCollectionUri, conflictDocument, index++)); <line15> } <line16> List<Document> conflictDocuments = <line17> Observable.merge(updateTask).toList().toBlocking().single(); <line18> if (conflictDocuments.size() > 1) { <line19> this.validateUDPAsync(this.clients, conflictDocuments); <line20> break; <line21> } else { <line22> } <line23> } while (true); <line24> } <line25> } <line26> 	<line10>, <line19>, <line22>
5526	"public class A { <line0> @Test <line1> public void testBasicCRUD() throws Exception { <line2> BookmarkManager bmgr = WebloggerFactory.getWeblogger().getBookmarkManager(); <line3> testWeblog = TestUtils.getManagedWebsite(testWeblog); <line4> WeblogBookmarkFolder root = bmgr.getDefaultFolder(testWeblog); <line5> assertEquals(1, testWeblog.getBookmarkFolders().size()); <line6> assertEquals(0, root.getBookmarks().size()); <line7> WeblogBookmarkFolder newFolder = <line8> new WeblogBookmarkFolder(""folderBasicCRUD"", TestUtils.getManagedWebsite(testWeblog)); <line9> bmgr.saveFolder(newFolder); <line10> TestUtils.endSession(true); <line11> testWeblog = TestUtils.getManagedWebsite(testWeblog); <line12> assertEquals(2, testWeblog.getBookmarkFolders().size()); <line13> WeblogBookmarkFolder folder = testWeblog.getBookmarkFolders().get(1); <line14> assertEquals(newFolder, folder); <line15> folder.setName(""folderTest1""); <line16> bmgr.saveFolder(folder); <line17> TestUtils.endSession(true); <line18> testWeblog = TestUtils.getManagedWebsite(testWeblog); <line19> folder = testWeblog.getBookmarkFolders().get(1); <line20> assertEquals(""folderTest1"", folder.getName()); <line21> bmgr.removeFolder(folder); <line22> TestUtils.endSession(true); <line23> testWeblog = TestUtils.getManagedWebsite(testWeblog); <line24> assertEquals(1, testWeblog.getBookmarkFolders().size()); <line25> folder = bmgr.getFolder(newFolder.getId()); <line26> assertNull(folder); <line27> } <line28> } <line29> "	<line2>, <line27>
5527	public class A { <line0> public void setVersion(String version) { <line1> configurationProperties.put(VERSION, version); <line2> } <line3> } <line4> 	<line2>
5528	public class A { <line0> @Override <line1> protected void startScan() { <line2> doRunRun(); <line3> } <line4> } <line5> 	<line2>
5529	public class A { <line0> private Single<ShouldRetryResult> shouldRetryOnEndpointFailureAsync( <line1> boolean isReadRequest, boolean forceRefresh) { <line2> if (!this.enableEndpointDiscovery || this.failoverRetryCount > MaxRetryCount) { <line3> return Single.just(ShouldRetryResult.noRetry()); <line4> } <line5> Completable refreshCompletion = this.refreshLocation(isReadRequest, forceRefresh); <line6> Duration retryDelay = Duration.ZERO; <line7> if (!isReadRequest) { <line8> if (this.failoverRetryCount > 1) { <line9> retryDelay = Duration.ofMillis(ClientRetryPolicy.RetryIntervalInMS); <line10> } <line11> } else { <line12> retryDelay = Duration.ofMillis(ClientRetryPolicy.RetryIntervalInMS); <line13> } <line14> return refreshCompletion.andThen(Single.just(ShouldRetryResult.retryAfter(retryDelay))); <line15> } <line16> } <line17> 	<line3>, <line8>
5530	public class A { <line0> private void clean(ModelSaveContext saveContext) { <line1> Path tmpPath = new Path(saveContext.getTmpSavePath()); <line2> try { <line3> FileSystem fs = tmpPath.getFileSystem(context.getConf()); <line4> boolean ret = fs.delete(tmpPath, true); <line5> if (ret) { <line6> } else { <line7> } <line8> } catch (Throwable e) { <line9> } <line10> } <line11> } <line12> 	<line6>, <line7>, <line9>
5531	public class A { <line0> public static void sqlLog(final String message) { <line1> } <line2> } <line3> 	<line1>
5532	public class A { <line0> public Map<String, Map<String, List<AttendanceStatisticalCycle>>> getCycleMapFormAllCycles( <line1> EntityManagerContainer emc, List<AttendanceStatisticalCycle> cycles, Boolean debugger) <line2> throws Exception { <line3> Map<String, Map<String, List<AttendanceStatisticalCycle>>> <line4> topUnitAttendanceStatisticalCycleMap = <line5> new ConcurrentHashMap<String, Map<String, List<AttendanceStatisticalCycle>>>(); <line6> Map<String, List<AttendanceStatisticalCycle>> unitAttendanceStatisticalCycleMap = null; <line7> List<AttendanceStatisticalCycle> unitCycles = null; <line8> if (cycles != null && cycles.size() > 0) { <line9> for (AttendanceStatisticalCycle cycle : cycles) { <line10> unitAttendanceStatisticalCycleMap = <line11> topUnitAttendanceStatisticalCycleMap.get(cycle.getTopUnitName()); <line12> if (unitAttendanceStatisticalCycleMap == null) { <line13> unitAttendanceStatisticalCycleMap = <line14> new ConcurrentHashMap<String, List<AttendanceStatisticalCycle>>(); <line15> topUnitAttendanceStatisticalCycleMap.put( <line16> cycle.getTopUnitName(), unitAttendanceStatisticalCycleMap); <line17> } <line18> unitCycles = unitAttendanceStatisticalCycleMap.get(cycle.getUnitName()); <line19> if (unitCycles == null) { <line20> unitCycles = new ArrayList<AttendanceStatisticalCycle>(); <line21> unitAttendanceStatisticalCycleMap.put(cycle.getUnitName(), unitCycles); <line22> } <line23> putDistinctCycleInList( <line24> cycle, <line25> new UnitCycleInfoEntity(cycle.getUnitName(), cycle.getTopUnitName(), unitCycles), <line26> topUnitAttendanceStatisticalCycleMap); <line27> } <line28> } else { <line29> } <line30> return topUnitAttendanceStatisticalCycleMap; <line31> } <line32> } <line33> 	<line29>
5533	"public class A { <line0> @Override <line1> @BeforeEach <line2> public void setUp() throws Exception { <line3> byte[] utf = payload.getBytes(""utf-8""); <line4> byte[] iso = payload.getBytes(""iso-8859-1""); <line5> for (byte b : utf) { <line6> } <line7> for (byte b : iso) { <line8> } <line9> super.setUp(); <line10> } <line11> } <line12> "	<line5>, <line6>, <line8>
5534	"public class A { <line0> @Override <line1> public CPDefinitionInventory findByCPDefinitionId(long CPDefinitionId) <line2> throws NoSuchCPDefinitionInventoryException { <line3> CPDefinitionInventory cpDefinitionInventory = fetchByCPDefinitionId(CPDefinitionId); <line4> if (cpDefinitionInventory == null) { <line5> StringBundler sb = new StringBundler(4); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""CPDefinitionId=""); <line8> sb.append(CPDefinitionId); <line9> sb.append(""}""); <line10> if (_log.isDebugEnabled()) { <line11> } <line12> throw new NoSuchCPDefinitionInventoryException(sb.toString()); <line13> } <line14> return cpDefinitionInventory; <line15> } <line16> } <line17> "	<line11>
5535	"public class A { <line0> public List<GenericEntity> getSessions(String token) { <line1> String url = getApiUrl() + SESSION_URL + ""?"" + Constants.LIMIT + ""="" + Constants.MAX_RESULTS; <line2> try { <line3> return createEntitiesFromAPI(url, token); <line4> } catch (JsonSyntaxException e) { <line5> return new ArrayList<GenericEntity>(); <line6> } <line7> } <line8> } <line9> "	<line5>
5536	public class A { <line0> private void tryPublishBirthCertificate() { <line1> try { <line2> publishBirthCertificate(); <line3> } catch (KuraException e) { <line4> } <line5> } <line6> } <line7> 	<line4>
5537	public class A { <line0> private void applyParameters(PreparedStatement statement, Vector<Column> columns) <line1> throws SQLException { <line2> Iterator<Column> iter = columns.iterator(); <line3> int var = 1; <line4> while (iter.hasNext()) { <line5> Column column = iter.next(); <line6> if (column.getParameter() != null) { <line7> if (column.getParameter() instanceof Integer) { <line8> statement.setInt(var, Integer.parseInt(column.getParameter().toString())); <line9> var++; <line10> } else if (column.getParameter() instanceof Boolean) { <line11> statement.setBoolean(var, new Boolean(column.getParameter().toString())); <line12> var++; <line13> } else if (column.getParameter() instanceof Double) { <line14> statement.setDouble(var, Double.parseDouble(column.getParameter().toString())); <line15> var++; <line16> } else if (column.getParameter() instanceof Float) { <line17> statement.setFloat(var, Float.parseFloat(column.getParameter().toString())); <line18> var++; <line19> } else if (column.getParameter() instanceof Timestamp) { <line20> statement.setTimestamp(var, (Timestamp) column.getParameter()); <line21> var++; <line22> } else if (column.getParameter() instanceof byte[]) { <line23> statement.setBytes(var, (byte[]) column.getParameter()); <line24> var++; <line25> } else { <line26> JdbcUtil.setParameter( <line27> statement, <line28> var, <line29> (String) column.getParameter(), <line30> getDbmsSupport().isParameterTypeMatchRequired()); <line31> var++; <line32> } <line33> } <line34> } <line35> } <line36> } <line37> 	<line8>, <line11>, <line14>, <line17>, <line20>, <line23>, <line26>
5538	public class A { <line0> public void attachDirty(SysExportItv instance) { <line1> try { <line2> sessionFactory.getCurrentSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
5539	public class A { <line0> private void executeAction(final List<NodeRef> actionNodes) { <line1> RetryingTransactionCallback<Boolean> processTranCB = <line2> () -> { <line3> for (NodeRef actionNode : actionNodes) { <line4> if (nodeService.exists(actionNode)) { <line5> final String dispAction = <line6> (String) <line7> nodeService.getProperty( <line8> actionNode, RecordsManagementModel.PROP_DISPOSITION_ACTION); <line9> if (dispAction != null && dispositionActions.contains(dispAction)) { <line10> ChildAssociationRef parent = nodeService.getPrimaryParent(actionNode); <line11> if (parent <line12> .getTypeQName() <line13> .equals(RecordsManagementModel.ASSOC_NEXT_DISPOSITION_ACTION)) { <line14> Map<String, Serializable> props = new HashMap<>(1); <line15> props.put( <line16> RMDispositionActionExecuterAbstractBase.PARAM_NO_ERROR_CHECK, Boolean.FALSE); <line17> try { <line18> recordsManagementActionService.executeRecordsManagementAction( <line19> parent.getParentRef(), dispAction, props); <line20> if (logger.isDebugEnabled()) { <line21> } <line22> } catch (AlfrescoRuntimeException exception) { <line23> if (logger.isDebugEnabled()) { <line24> } <line25> } <line26> } <line27> } <line28> } <line29> } <line30> return Boolean.TRUE; <line31> }; <line32> retryingTransactionHelper.doInTransaction(processTranCB, false, true); <line33> } <line34> } <line35> 	<line21>, <line24>
5540	public class A { <line0> private void uploadToFileExchange() { <line1> int bufferSize = 16384; <line2> try (InputStream is = new BufferedInputStream(new FileInputStream(targetFile), bufferSize)) { <line3> fileExchange.putFile(is, uploadURL); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	<line4>, <line5>
5541	public class A { <line0> @Override <line1> public Map<String, Map<String, ShardState>> shardServerLayoutState(String table) <line2> throws BlurException, TException { <line3> try { <line4> resetSearchers(); <line5> Map<String, Map<String, ShardState>> result = new TreeMap<String, Map<String, ShardState>>(); <line6> String nodeName = _indexServer.getNodeName(); <line7> Map<String, ShardState> stateMap = _indexServer.getShardState(table); <line8> for (Entry<String, ShardState> entry : stateMap.entrySet()) { <line9> result.put(entry.getKey(), newMap(nodeName, entry.getValue())); <line10> } <line11> return result; <line12> } catch (Exception e) { <line13> if (e instanceof BlurException) { <line14> throw (BlurException) e; <line15> } <line16> throw new BException(e.getMessage(), e); <line17> } <line18> } <line19> } <line20> 	<line13>
5542	public class A { <line0> public static void logAuditMessage(final AuditMessageType message) { <line1> if (CollectionUtils.isNotEmpty(message.getAuditSourceIdentification()) <line2> && message.getAuditSourceIdentification().get(0).getAuditSourceID() != null) { <line3> } else { <line4> } <line5> if (CollectionUtils.isNotEmpty(message.getActiveParticipant())) { <line6> if (message.getActiveParticipant().get(0).getUserID() != null) { <line7> } else { <line8> } <line9> if (message.getActiveParticipant().get(0).getUserName() != null) { <line10> } <line11> } <line12> if (CollectionUtils.isNotEmpty(message.getParticipantObjectIdentification()) <line13> && message.getParticipantObjectIdentification().get(0).getParticipantObjectID() != null) { <line14> } else { <line15> } <line16> } <line17> } <line18> 	<line1>, <line3>, <line4>, <line7>, <line8>, <line10>, <line14>, <line15>
5543	"public class A { <line0> public long waitForSpace(Duration maxWaitTime) <line1> throws InterruptedException, WindowClosedException, SocketTimeoutException { <line2> checkInitialized(""waitForSpace""); <line3> long available; <line4> synchronized (lock) { <line5> waitForCondition(SPACE_AVAILABLE_PREDICATE, maxWaitTime); <line6> available = size; <line7> } <line8> if (log.isDebugEnabled()) { <line9> } <line10> return available; <line11> } <line12> } <line13> "	<line9>
5544	public class A { <line0> @Override <line1> public boolean queueBuffers(Queue<AudioBuffer> audioBuffers) { <line2> if (!bound) { <line3> this.pendingBufferQueue = new LinkedList<>(audioBuffers); <line4> activeAudioFactory.audioCommandQueue(new AudioCommand(this, Audio.CMD_QUEUE_BUFFERS)); <line5> activeAudioFactory.getCommandThread().interrupt(); <line6> if (log.isDebugEnabled() && (audioBuffers.peek() != null)) { <line7> } <line8> return true; <line9> } else { <line10> if (audioBuffers.peek() != null) { <line11> } <line12> return false; <line13> } <line14> } <line15> } <line16> 	<line7>, <line11>
5545	"public class A { <line0> @Override <line1> public void notify( <line2> final String group, final String identifier, final String title, final String description) { <line3> if (filter.shouldSuppress()) { <line4> return; <line5> } <line6> final NSUserNotification notification = NSUserNotification.notification(); <line7> if (StringUtils.isNotBlank(identifier)) { <line8> if (notification.respondsToSelector(Foundation.selector(""setIdentifier:""))) { <line9> notification.setIdentifier(identifier); <line10> } <line11> if (StringUtils.isNotBlank(Path.getExtension(identifier))) { <line12> notification.setContentImage( <line13> IconCacheFactory.<NSImage>get().documentIcon(Path.getExtension(identifier), 32)); <line14> } <line15> } <line16> notification.setTitle(LocaleFactory.localizedString(title, ""Status"")); <line17> notification.setInformativeText(description); <line18> notification.setHasActionButton(false); <line19> center.scheduleNotification(notification); <line20> } <line21> } <line22> "	<line4>
5546	public class A { <line0> protected void transition(EventContext context, TaskState newState) { <line1> TaskState oldState = context.task.state; <line2> context.task.state = newState; <line3> if (newState.lifeCycleEvent != oldState.lifeCycleEvent) { <line4> context.controller.fireLifecycleChange(newState.lifeCycleEvent, context); <line5> } <line6> context.task.stateStartTime = System.currentTimeMillis(); <line7> } <line8> } <line9> 	<line2>
5547	public class A { <line0> @Override <line1> protected void run( <line2> Bootstrap<FoxtrotServerConfiguration> bootstrap, <line3> Namespace namespace, <line4> FoxtrotServerConfiguration configuration) <line5> throws Exception { <line6> ElasticsearchConfig esConfig = configuration.getElasticsearch(); <line7> ElasticsearchConnection connection = new ElasticsearchConnection(esConfig); <line8> connection.start(); <line9> ClusterHealthResponse clusterHealth = <line10> connection.getClient().admin().cluster().health(new ClusterHealthRequest()).actionGet(); <line11> int numDataNodes = clusterHealth.getNumberOfDataNodes(); <line12> int numReplicas = (numDataNodes < 2) ? 0 : 1; <line13> createMetaIndex(connection, ElasticsearchConsolePersistence.INDEX, numReplicas); <line14> createMetaIndex(connection, ElasticsearchConsolePersistence.INDEX_V2, numReplicas); <line15> createMetaIndex(connection, TableMapStore.TABLE_META_INDEX, numReplicas); <line16> createMetaIndex(connection, ElasticsearchConsolePersistence.INDEX_HISTORY, numReplicas); <line17> createMetaIndex(connection, FqlStoreServiceImpl.FQL_STORE_INDEX, numReplicas); <line18> PutIndexTemplateRequest putIndexTemplateRequest = <line19> ElasticsearchUtils.getClusterTemplateMapping(); <line20> PutIndexTemplateResponse response = <line21> connection.getClient().admin().indices().putTemplate(putIndexTemplateRequest).actionGet(); <line22> HBaseUtil.createTable(configuration.getHbase(), configuration.getHbase().getTableName()); <line23> } <line24> } <line25> 	<line13>, <line18>, <line22>
5548	public class A { <line0> @Override <line1> public RemoteType getRemoteType() throws IOException { <line2> return irca.getRemoteType(); <line3> } <line4> } <line5> 	<line2>
5549	"public class A { <line0> @Override <line1> public ReturnValue do_run() { <line2> QueryRunner runner = new QueryRunner(); <line3> try (Connection db = DBAccess.get().getDb()) { <line4> final List<Map<String, Object>> mapList = <line5> runner.query(db, ""select * from registration"", new MapListHandler()); <line6> for (Map<String, Object> row : mapList) { <line7> final String password = (String) row.get(""password""); <line8> if (!password.startsWith(""sha1:"")) { <line9> final int registrationId = (int) row.get(""registration_id""); <line10> final String hash = PasswordStorage.createHash(password); <line11> runner.update( <line12> db, <line13> ""update registration set password = '"" <line14> + hash <line15> + ""' where registration_id = "" <line16> + registrationId); <line17> } <line18> } <line19> } catch (SQLException e) { <line20> Logger.getLogger(RegistrationMigrationPlugin.class.getName()).log(Level.SEVERE, null, e); <line21> return new ReturnValue(ReturnValue.FAILURE); <line22> } catch (PasswordStorage.CannotPerformOperationException e) { <line23> Logger.getLogger(RegistrationMigrationPlugin.class.getName()).log(Level.SEVERE, null, e); <line24> return new ReturnValue(ReturnValue.FAILURE); <line25> } <line26> return new ReturnValue(); <line27> } <line28> } <line29> "	<line20>, <line23>
5550	"public class A { <line0> @Test <line1> public void testUserRolesUI() throws Exception { <line2> JSONObject userdata = <line3> tester.createUserWithRoles(jetty, tester.user88Create(), tester.roleCreate()); <line4> JSONObject userdata2 = <line5> tester.createUserWithRoles(jetty, tester.user88Create(), tester.role2Create()); <line6> HttpTester out = tester.POSTData(""/users/"", tester.makeRequest(userdata), jetty); <line7> String userid = out.getHeader(""Location""); <line8> out = tester.GETData(userid, jetty); <line9> String screenname = userdata2.getString(""userName""); <line10> userdata2.remove(""userName""); <line11> userdata2.put(""screenName"", screenname); <line12> userdata2.put(""userId"", userdata.getString(""userId"")); <line13> out = tester.PUTData(userid, tester.makeRequest(userdata2), jetty); <line14> out = tester.GETData(userid, jetty); <line15> JSONObject data = new JSONObject(out.getContent()); <line16> JSONArray roles = data.getJSONObject(""fields"").getJSONArray(""role""); <line17> String roles_id1 = <line18> ""/role/"" + userdata.getJSONArray(""role"").getJSONObject(0).getString(""roleId""); <line19> String roles_id2 = <line20> ""/role/"" + userdata2.getJSONArray(""role"").getJSONObject(0).getString(""roleId""); <line21> tester.DELETEData(roles_id1, jetty); <line22> tester.DELETEData(roles_id2, jetty); <line23> tester.DELETEData(userid, jetty); <line24> assertEquals( <line25> ""Should only be one role, if more then it didn't delete, if less then it didn't add"", <line26> 1, <line27> roles.length()); <line28> for (int i = 0; i < roles.length(); i++) { <line29> JSONObject role = roles.getJSONObject(i); <line30> if (!role.getString(""roleName"").equals(""ROLE_SPRING_ADMIN"")) { <line31> assertEquals( <line32> role.getString(""roleName""), <line33> userdata2.getJSONArray(""role"").getJSONObject(0).getString(""roleName"")); <line34> } <line35> } <line36> } <line37> } <line38> "	<line6>, <line8>
5551	public class A { <line0> @Override <line1> public Collection<SchemaVersionInfo> getAllVersions( <line2> String schemaBranchName, String schemaName, List<Byte> stateIds) <line3> throws SchemaNotFoundException, SchemaBranchNotFoundException { <line4> if (stateIds == null || stateIds.isEmpty()) return getAllVersions(schemaBranchName, schemaName); <line5> else <line6> return schemaVersionLifecycleManager.getAllVersions(schemaBranchName, schemaName, stateIds); <line7> } <line8> } <line9> 	<line4>
5552	public class A { <line0> public NmbNotiz merge(NmbNotiz detachedInstance) { <line1> try { <line2> NmbNotiz result = (NmbNotiz) getSession().merge(detachedInstance); <line3> return result; <line4> } catch (RuntimeException re) { <line5> throw re; <line6> } <line7> } <line8> } <line9> 	<line1>, <line3>, <line5>
5553	public class A { <line0> private final void updateDocuments(StagingArea staging, RevisionSearcher index) <line1> throws IOException { <line2> preUpdateDocuments(staging, index); <line3> doProcess(getChangeSetProcessors(staging, index), staging, index); <line4> postUpdateDocuments(staging, index); <line5> } <line6> } <line7> 	<line2>, <line5>
5554	"public class A { <line0> public void setAccessToken(String accessToken) throws ETSdkException { <line1> if (accessTokenElement != null) { <line2> accessTokenElement.removeContents(); <line3> try { <line4> accessTokenElement.addTextNode(accessToken); <line5> } catch (SOAPException ex) { <line6> throw new ETSdkException(""could not set access token"", ex); <line7> } <line8> } <line9> } <line10> } <line11> "	<line8>
5555	public class A { <line0> @Override <line1> public void applyAsync(final Connection conn, final Consumer<Boolean> function) { <line2> if (conn == null) { <line3> function.accept(false); <line4> } else { <line5> final SearchOperationHandle h = conn.operation(searchRequest); <line6> h.onResult(r -> function.accept(r.getResultCode() != null)); <line7> h.onException( <line8> e -> { <line9> function.accept(false); <line10> }); <line11> h.send(); <line12> } <line13> } <line14> } <line15> 	<line9>
5556	"public class A { <line0> @Override <line1> public void fileCreated(FileChangeEvent fileChangeEvent) throws Exception { <line2> FileObject obj = fileChangeEvent.getFile(); <line3> String dirPath = obj.getParent().getName().getPath(); <line4> if (dirPath.startsWith(monDir + ""/"" + archiveDirName)) { <line5> return; <line6> } <line7> if (obj.getType() == FileType.FOLDER) { <line8> return; <line9> } <line10> String fileName = obj.getName().getPath(); <line11> if (fileName.matches(filePattern)) { <line12> FileContent fc = obj.getContent(); <line13> putEligibleFileInfoInMap(fileName, fc); <line14> } <line15> } <line16> } <line17> "	<line3>, <line4>, <line12>, <line13>
5557	"public class A { <line0> @Test <line1> @Category(BoxSDKTest.class) <line2> public void testSharedFolder() throws BoxSDKServiceException { <line3> String testFolderId = testFolder.getID(); <line4> BoxFolder folder = <line5> boxSDKService.createSharedFolder(""testSharedFolder-"" + new Date().getTime(), testFolderId); <line6> BoxSharedLink sharedLink = folder.getInfo().getSharedLink(); <line7> assertNotNull(sharedLink); <line8> } <line9> } <line10> "	<line8>
5558	public class A { <line0> public synchronized boolean addReplicaTask(int replicaId) { <line1> if (!isLeader()) { <line2> return false; <line3> } <line4> if (getReplica(replicaId) == null) { <line5> return false; <line6> } <line7> replicateResponseQueue.put(new DelayedCommand(ONE_SECOND_NANO, replicaId)); <line8> return true; <line9> } <line10> } <line11> 	<line2>, <line5>
5559	public class A { <line0> public void initFixedThreadPool(Integer count) throws Exception { <line1> if (count == null || count < 1) { <line2> fixedSize = 1; <line3> } else { <line4> fixedSize = count; <line5> } <line6> } <line7> } <line8> 	<line6>
5560	"public class A { <line0> @ApiOperation( <line1> httpMethod = ""GET"", <line2> value = ""API to get all policies"", <line3> response = Page.class, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> @RequestMapping( <line6> path = ""/list"", <line7> method = RequestMethod.GET, <line8> produces = MediaType.APPLICATION_JSON_VALUE) <line9> public ResponseEntity<Object> getPolicies( <line10> @ApiParam(value = ""provide valid page number"", required = true) @RequestParam(""page"") <line11> Integer page, <line12> @ApiParam(value = ""provide valid page size"", required = true) @RequestParam(""size"") <line13> Integer size, <line14> @ApiParam(value = ""provide valid search term"", required = false) <line15> @RequestParam(defaultValue = """", name = ""searchTerm"", required = false) <line16> String searchTerm) { <line17> try { <line18> return ResponseUtils.buildSucessResponse( <line19> policyService.getPolicies(page, size, searchTerm.trim())); <line20> } catch (Exception exception) { <line21> return ResponseUtils.buildFailureResponse( <line22> new Exception(UNEXPECTED_ERROR_OCCURRED), exception.getMessage()); <line23> } <line24> } <line25> } <line26> "	<line21>
5561	public class A { <line0> public Rp getRpByClientId(String clientId) { <line1> for (Rp rp : rpCache.asMap().values()) { <line2> if (rp.getClientId().equalsIgnoreCase(clientId)) { <line3> return rp; <line4> } <line5> } <line6> return null; <line7> } <line8> } <line9> 	<line3>
5562	"public class A { <line0> private Holder<List<GetSchemaResponse>> getSchemas( <line1> String microserviceId, boolean withSchema, boolean global) { <line2> Holder<GetSchemasResponse> holder = new Holder<>(); <line3> IpPort ipPort = ipPortManager.getAvailableAddress(); <line4> Holder<List<GetSchemaResponse>> resultHolder = new Holder<>(); <line5> CountDownLatch countDownLatch = new CountDownLatch(1); <line6> String url = Const.REGISTRY_API.MICROSERVICE_ALL_SCHEMAs; <line7> RequestParam requestParam = new RequestParam(); <line8> if (withSchema) { <line9> url = Const.REGISTRY_API.MICROSERVICE_ALL_SCHEMAs + ""?withSchema=1""; <line10> } <line11> if (global) { <line12> requestParam.addQueryParam(""global"", ""true""); <line13> } <line14> restClientUtil.get( <line15> ipPort, <line16> String.format(url, microserviceId), <line17> requestParam, <line18> syncHandler(countDownLatch, GetSchemasResponse.class, holder)); <line19> try { <line20> countDownLatch.await(); <line21> } catch (Exception e) { <line22> } <line23> resultHolder.setStatusCode(holder.getStatusCode()).setThrowable(holder.getThrowable()); <line24> if (holder.value != null) { <line25> return resultHolder.setValue( <line26> holder.value.getSchema() != null ? holder.value.getSchema() : holder.value.getSchemas()); <line27> } <line28> return resultHolder; <line29> } <line30> } <line31> "	<line22>
5563	"public class A { <line0> @Override <line1> public void setup(OperatorContext context) { <line2> if (fieldmappingFile != null) { <line3> Configuration conf = new Configuration(); <line4> try { <line5> FileSystem fs = FileSystem.get(conf); <line6> Path filepath = new Path(fieldmappingFile); <line7> if (fs.exists(filepath)) { <line8> BufferedReader bfr = new BufferedReader(new InputStreamReader(fs.open(filepath))); <line9> String str; <line10> while ((str = bfr.readLine()) != null) { <line11> String[] temp = str.split(fieldmappingFileDelimiter); <line12> Field field = new Field(); <line13> field.setName(temp[0]); <line14> field.setType(temp[1]); <line15> getFields().add(field); <line16> } <line17> } else { <line18> } <line19> } catch (IOException ex) { <line20> DTThrowable.rethrow(ex); <line21> } <line22> } <line23> int countKeyValue = getFields().size(); <line24> properties = new String[countKeyValue]; <line25> processors = new CellProcessor[countKeyValue]; <line26> initialise(properties, processors); <line27> CsvPreference preference = <line28> new CsvPreference.Builder('""', fieldDelimiter, lineDelimiter).build(); <line29> csvReader = getReader(csvStringReader, preference); <line30> } <line31> } <line32> "	<line11>, <line18>
5564	public class A { <line0> public void broadcast(final byte[] bytes) { <line1> for (final Session session : sessions) { <line2> try { <line3> session.getRemote().sendBytes(ByteBuffer.wrap(bytes)); <line4> } catch (final IOException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>
5565	public class A { <line0> private boolean checkAndMoveApisFiles(File folder, File processedFolder) { <line1> try { <line2> if (!folder.isDirectory()) { <line3> return true; <line4> } <line5> for (final File fileEntry : folder.listFiles()) { <line6> if (!fileEntry.isDirectory()) { <line7> FileSystem fromFileSystem = FileSystems.getDefault(); <line8> FileSystem toFileSystem = FileSystems.getDefault(); <line9> Path moveFrom = fromFileSystem.getPath(fileEntry.getPath()); <line10> Path moveTo = <line11> toFileSystem.getPath( <line12> processedFolder.getPath() + File.separator + fileEntry.getName()); <line13> if (fileEntry.isFile()) { <line14> boolean fileEntryRenamed = fileEntry.renameTo(moveTo.toFile()); <line15> if (!fileEntryRenamed) { <line16> } <line17> } <line18> fromFileSystem.close(); <line19> toFileSystem.close(); <line20> } <line21> } <line22> } catch (Exception e) { <line23> handleExceptions(e); <line24> return false; <line25> } <line26> return true; <line27> } <line28> } <line29> 	<line2>, <line14>, <line16>, <line24>
5566	public class A { <line0> public static Map<String, DiscreteIndexType<?>> getFieldToDiscreteIndexTypeMap( <line1> Multimap<String, ?> fieldDatatypes) { <line2> Map<String, DiscreteIndexType<?>> fieldToDiscreteIndexTypeMap = new HashMap<>(); <line3> for (String field : fieldDatatypes.keySet()) { <line4> DiscreteIndexType discreteIndexType = null; <line5> for (Object typeObj : fieldDatatypes.get(field)) { <line6> Type type = null; <line7> if (typeObj instanceof Type) { <line8> type = (Type) typeObj; <line9> } else if (typeObj instanceof String) { <line10> try { <line11> type = Class.forName(typeObj.toString()).asSubclass(Type.class).newInstance(); <line12> } catch (Exception e) { <line13> if (log.isTraceEnabled()) <line14> } <line15> } <line16> if (type != null <line17> && type instanceof DiscreteIndexType <line18> && ((DiscreteIndexType) type).producesFixedLengthRanges()) { <line19> if (discreteIndexType == null) { <line20> discreteIndexType = (DiscreteIndexType) type; <line21> } else if (!discreteIndexType.getClass().equals(type.getClass())) { <line22> discreteIndexType = null; <line23> break; <line24> } <line25> } <line26> } <line27> if (discreteIndexType != null) fieldToDiscreteIndexTypeMap.put(field, discreteIndexType); <line28> } <line29> return fieldToDiscreteIndexTypeMap; <line30> } <line31> } <line32> 	<line14>
5567	"public class A { <line0> @Nullable <line1> private String verifyAndReturnError( <line2> final ProctorSpecification specification, <line3> final TestMatrixArtifact artifact, <line4> final String testName, <line5> final AppVersion appVersion) { <line6> try { <line7> final ProctorLoadResult result = <line8> verify(specification, artifact, testName, appVersion.toString()); <line9> if (result.hasInvalidTests()) { <line10> return getErrorMessage(appVersion, result); <line11> } <line12> return null; <line13> } catch (final Exception e) { <line14> return appVersion.toString() + "" failed. "" + e.getMessage(); <line15> } <line16> } <line17> } <line18> "	<line14>
5568	"public class A { <line0> @RequestHandler <line1> public void connect() { <line2> final XulDialog waitDialog = (XulDialog) document.getElementById(ANON_WAIT_DIALOG); <line3> try { <line4> if (selectedSchemaProvider == null) { <line5> throw new AggDesignerException(Messages.getString(""select_olap_model"")); <line6> } <line7> workspace.setApplicationUnlocked(false); <line8> new Thread() { <line9> @Override <line10> public void run() { <line11> try { <line12> while (waitDialog.isHidden()) { <line13> Thread.sleep(300); <line14> } <line15> ConnectionController.this.schema = <line16> selectedSchemaProvider.loadSchema(connectionModel.getCubeName()); <line17> } catch (Exception e) { <line18> } finally { <line19> waitDialog.hide(); <line20> } <line21> } <line22> }.start(); <line23> waitDialog.show(); <line24> if (schema == null) { <line25> throw new AggDesignerException(""Error loading Schema""); <line26> } <line27> connectionModel.setSchema(schema); <line28> outputService.init(schema); <line29> connectionModel.setSchemaUpToDate(true); <line30> workspace.setApplicationUnlocked(true); <line31> hideConnectionDialog(); <line32> } catch (Exception e) { <line33> if (!waitDialog.isHidden()) { <line34> waitDialog.hide(); <line35> } <line36> XulDialog connectErrorDialog = (XulDialog) document.getElementById(CONNECT_ERROR_DIALOG); <line37> Assert.notNull(connectErrorDialog, ""missing element from document""); <line38> XulTextbox connectErrorDialogMessage = <line39> (XulTextbox) document.getElementById(""connectErrorDialogMessage""); <line40> Assert.notNull(connectErrorDialogMessage, ""missing element from document""); <line41> connectErrorDialogMessage.setValue(e.getLocalizedMessage()); <line42> connectErrorDialog.show(); <line43> } <line44> } <line45> } <line46> "	<line18>, <line33>
5569	public class A { <line0> public void createAccount( <line1> String userNameAccount, <line2> String firstNameAccount, <line3> String lastNameAccount, <line4> String emailAccount, <line5> String userPasswordAccount, <line6> String adminPassword) { <line7> MembershipType membershipType; <line8> try { <line9> RequestLifeCycle.begin((ComponentRequestLifecycle) organizationService); <line10> MembershipTypeHandler membershipTypeHandler = organizationService.getMembershipTypeHandler(); <line11> UserHandler userHandler = organizationService.getUserHandler(); <line12> User user = userHandler.createUserInstance(userNameAccount); <line13> user.setPassword(userPasswordAccount); <line14> user.setFirstName(firstNameAccount); <line15> user.setLastName(lastNameAccount); <line16> user.setEmail(emailAccount); <line17> try { <line18> userHandler.createUser(user, true); <line19> } catch (Exception e) { <line20> } <line21> try { <line22> Group group = organizationService.getGroupHandler().findGroupById(PLATFORM_USERS_GROUP); <line23> membershipType = membershipTypeHandler.findMembershipType(MEMBERSHIP_TYPE_MANAGER); <line24> organizationService <line25> .getMembershipHandler() <line26> .linkMembership(user, group, membershipType, true); <line27> } catch (Exception e) { <line28> } <line29> try { <line30> Group group = <line31> organizationService.getGroupHandler().findGroupById(PLATFORM_WEB_CONTRIBUTORS_GROUP); <line32> membershipType = membershipTypeHandler.findMembershipType(MEMBERSHIP_TYPE_MANAGER); <line33> organizationService <line34> .getMembershipHandler() <line35> .linkMembership(user, group, membershipType, true); <line36> } catch (Exception e) { <line37> } <line38> try { <line39> Group group = <line40> organizationService.getGroupHandler().findGroupById(PLATFORM_DEVELOPERS_GROUP); <line41> membershipType = membershipTypeHandler.findMembershipType(MEMBERSHIP_TYPE_MANAGER); <line42> organizationService <line43> .getMembershipHandler() <line44> .linkMembership(user, group, membershipType, true); <line45> } catch (Exception e) { <line46> } <line47> try { <line48> Group group = <line49> organizationService.getGroupHandler().findGroupById(PLATFORM_PLATFORM_USERS_GROUP); <line50> membershipType = membershipTypeHandler.findMembershipType(MEMBERSHIP_TYPE_MANAGER); <line51> organizationService <line52> .getMembershipHandler() <line53> .linkMembership(user, group, membershipType, true); <line54> } catch (Exception e) { <line55> } <line56> try { <line57> User adminUser = userHandler.findUserByName(ADMIN_FIRST_NAME); <line58> adminUser.setPassword(adminPassword); <line59> organizationService.getUserHandler().saveUser(adminUser, false); <line60> } catch (Exception e) { <line61> } <line62> setSkipSetup(true); <line63> } finally { <line64> RequestLifeCycle.end(); <line65> } <line66> } <line67> } <line68> 	<line20>, <line28>, <line37>, <line46>, <line55>, <line61>
5570	public class A { <line0> public FirefoxProfileBuilder withJavaScriptErrorCollectorPlugin() { <line1> try { <line2> JavaScriptError.addExtension(firefoxProfile); <line3> } catch (IOException e) { <line4> } <line5> return this; <line6> } <line7> } <line8> 	<line4>
5571	public class A { <line0> public void handleMessage(int responseId, GeneratedMessageV3 message) { <line1> if (!state.checkState(SocketStateCode.RUN_DUPLEX)) { <line2> return; <line3> } <line4> if (isInfo) { <line5> } <line6> TBase tMessage = messageConverter.toMessage(message); <line7> try { <line8> byte[] serialize = <line9> SerializationUtils.serialize(tMessage, commandHeaderTBaseSerializerFactory); <line10> ResponsePacket responsePacket = new ResponsePacket(responseId, serialize); <line11> requestManager.messageReceived(responsePacket, agentInfo.toString()); <line12> } catch (TException e) { <line13> setFailMessageToFuture(responseId, e.getMessage()); <line14> } <line15> } <line16> } <line17> 	<line2>, <line5>
5572	public class A { <line0> @Override <line1> public void deleteContext(ServerContext serverContext, TProtocol input, TProtocol output) { <line2> _connections.decrementAndGet(); <line3> } <line4> } <line5> 	<line2>
5573	public class A { <line0> @Override <line1> protected int writeDirect(Object message) { <line2> try { <line3> if (!isRegisteredForWrite()) { <line4> return ((SocketChannel) channel).write((ByteBuffer) message); <line5> } else { <line6> return -1; <line7> } <line8> } catch (final IOException e) { <line9> processException(e); <line10> return -1; <line11> } <line12> } <line13> } <line14> 	<line9>
5574	public class A { <line0> public boolean isEmpty() { <line1> boolean e = params.isEmpty(); <line2> if (isTrace) { <line3> } <line4> return e; <line5> } <line6> } <line7> 	<line3>
5575	"public class A { <line0> private void setCompletionStatus( <line1> BulkUploadProcess bulkUploadProcess, <line2> List successList, <line3> List failureList, <line4> RequestContext context) { <line5> String logMessagePrefix = <line6> MessageFormat.format( <line7> ""BaseBulkUploadBackGroundJobActor:processBulkUpload:{0}: "", bulkUploadProcess.getId()); <line8> bulkUploadProcess.setSuccessResult(ProjectUtil.convertMapToJsonString(successList)); <line9> bulkUploadProcess.setFailureResult(ProjectUtil.convertMapToJsonString(failureList)); <line10> bulkUploadProcess.setStatus(ProjectUtil.BulkProcessStatus.COMPLETED.getValue()); <line11> BulkUploadProcessDao bulkUploadDao = new BulkUploadProcessDaoImpl(); <line12> bulkUploadDao.update(bulkUploadProcess, context); <line13> } <line14> } <line15> "	<line11>
5576	"public class A { <line0> @Override <line1> public BranchStatus branchRollback( <line2> BranchType branchType, String xid, long branchId, String resourceId, String applicationData) <line3> throws TransactionException { <line4> TCCResource tccResource = (TCCResource) tccResourceCache.get(resourceId); <line5> if (tccResource == null) { <line6> throw new ShouldNeverHappenException( <line7> String.format(""TCC resource is not exist, resourceId: %s"", resourceId)); <line8> } <line9> Object targetTCCBean = tccResource.getTargetBean(); <line10> Method rollbackMethod = tccResource.getRollbackMethod(); <line11> if (targetTCCBean == null || rollbackMethod == null) { <line12> throw new ShouldNeverHappenException( <line13> String.format(""TCC resource is not available, resourceId: %s"", resourceId)); <line14> } <line15> try { <line16> BusinessActionContext businessActionContext = <line17> getBusinessActionContext(xid, branchId, resourceId, applicationData); <line18> Object ret; <line19> boolean result; <line20> if (Boolean.TRUE.equals(businessActionContext.getActionContext(Constants.USE_TCC_FENCE))) { <line21> try { <line22> result = <line23> TCCFenceHandler.rollbackFence( <line24> rollbackMethod, targetTCCBean, businessActionContext, xid, branchId); <line25> } catch (FrameworkException | UndeclaredThrowableException e) { <line26> throw e.getCause(); <line27> } <line28> } else { <line29> ret = rollbackMethod.invoke(targetTCCBean, businessActionContext); <line30> if (ret != null) { <line31> if (ret instanceof TwoPhaseResult) { <line32> result = ((TwoPhaseResult) ret).isSuccess(); <line33> } else { <line34> result = (boolean) ret; <line35> } <line36> } else { <line37> result = true; <line38> } <line39> } <line40> return result <line41> ? BranchStatus.PhaseTwo_Rollbacked <line42> : BranchStatus.PhaseTwo_RollbackFailed_Retryable; <line43> } catch (Throwable t) { <line44> String msg = <line45> String.format(""rollback TCC resource error, resourceId: %s, xid: %s."", resourceId, xid); <line46> return BranchStatus.PhaseTwo_RollbackFailed_Retryable; <line47> } <line48> } <line49> } <line50> "	<line40>, <line46>
5577	public class A { <line0> @OnClose <line1> public void onClose(Session session, CloseReason closeReason) { <line2> } <line3> } <line4> 	<line2>
5578	"public class A { <line0> private org.apache.hadoop.conf.Configuration prepareRuntimeConfiguration() throws IOException { <line1> org.apache.hadoop.conf.Configuration runtimeConfig = <line2> HBaseConfigurationUtil.deserializeConfiguration( <line3> serializedConfig, HBaseConfigurationUtil.getHBaseConfiguration()); <line4> if (StringUtils.isNullOrWhitespaceOnly(runtimeConfig.get(HConstants.ZOOKEEPER_QUORUM))) { <line5> throw new IOException( <line6> ""Check HBase configuration failed, lost: '"" + HConstants.ZOOKEEPER_QUORUM + ""'!""); <line7> } <line8> return runtimeConfig; <line9> } <line10> } <line11> "	<line5>
5579	"public class A { <line0> @SuppressWarnings(""null"") <line1> private @Nullable Event getLastEvent(String id) { <line2> if (!zmAuth.isAuthorized()) { <line3> return null; <line4> } <line5> try { <line6> List<String> parameters = new ArrayList<>(); <line7> parameters.add(""sort=StartTime""); <line8> parameters.add(""direction=desc""); <line9> parameters.add(""limit=1""); <line10> String response = <line11> executeGet( <line12> buildUrlWithParameters( <line13> String.format(""/api/events/index/MonitorId:%s/Name!=:New%%20Event.json"", id), <line14> parameters)); <line15> EventsDTO events = GSON.fromJson(response, EventsDTO.class); <line16> if (events != null && events.eventsList != null && events.eventsList.size() == 1) { <line17> EventDTO e = events.eventsList.get(0).event; <line18> Event event = new Event(e.eventId, e.name, e.cause, e.notes, e.startTime, e.endTime); <line19> event.setFrames(e.frames); <line20> event.setAlarmFrames(e.alarmFrames); <line21> event.setLength(e.length); <line22> return event; <line23> } <line24> } catch (JsonSyntaxException e) { <line25> } <line26> return null; <line27> } <line28> } <line29> "	<line25>
5580	"public class A { <line0> public static void delete(final MCRDerivate mcrDerivate) <line1> throws MCRPersistenceException, MCRAccessException { <line2> MCRObjectID id = mcrDerivate.getId(); <line3> if (!MCRAccessManager.checkDerivateContentPermission(id, PERMISSION_DELETE)) { <line4> throw MCRAccessException.missingPermission( <line5> ""Delete derivate"", id.toString(), PERMISSION_DELETE); <line6> } <line7> MCRMarkManager.instance().mark(id, Operation.DELETE); <line8> MCRObjectID metaId = null; <line9> try { <line10> metaId = mcrDerivate.getDerivate().getMetaLink().getXLinkHrefID(); <line11> if (MCRMetadataManager.removeDerivateFromObject(metaId, id)) { <line12> } else { <line13> } <line14> } catch (final Exception e) { <line15> } <line16> if (mcrDerivate.getDerivate().getInternals() != null) { <line17> try { <line18> deleteDerivate(id.toString()); <line19> } catch (final Exception e) { <line20> throw new MCRPersistenceException(""Error while delete MCRDerivate "" + id + "" in IFS"", e); <line21> } <line22> } <line23> fireEvent(mcrDerivate, null, MCREvent.DELETE_EVENT); <line24> MCRMarkManager.instance().remove(id); <line25> } <line26> } <line27> "	<line12>, <line13>, <line15>, <line19>
5581	public class A { <line0> @Override <line1> public CommerceAddressRestriction findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchAddressRestrictionException { <line3> CommerceAddressRestriction commerceAddressRestriction = fetchByPrimaryKey(primaryKey); <line4> if (commerceAddressRestriction == null) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchAddressRestrictionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return commerceAddressRestriction; <line10> } <line11> } <line12> 	<line6>
5582	"public class A { <line0> private Response processJsonArray(final ArrayNode arrayNode) { <line1> final JsonArrayValueDeserializer deserializer = JsonArrayValueDeserializer.create(arrayNode); <line2> final String eventClassName = deserializer.getString(); <line3> final IRecordFactory<? extends IMonitoringRecord> recordFactory = <line4> this.recordFactories.get(eventClassName); <line5> try { <line6> final IMonitoringRecord event = recordFactory.create(deserializer); <line7> this.stage.getOutputPort().send(event); <line8> return NanoHTTPD.newFixedLengthResponse(Response.Status.ACCEPTED, MIME_PLAINTEXT, """"); <line9> } catch (final RecordInstantiationException ex) { <line10> return NanoHTTPD.newFixedLengthResponse( <line11> Response.Status.BAD_REQUEST, MIME_PLAINTEXT, ""Malformed data""); <line12> } <line13> } <line14> } <line15> "	<line10>
5583	public class A { <line0> public void introspectClass() { <line1> if (log.isDebugEnabled()) { <line2> } <line3> getFacetProcessor().process(introspectedClass, methodRemover, inspectedTypeSpec); <line4> final FacetsFacet facetsFacet = inspectedTypeSpec.getFacet(FacetsFacet.class); <line5> if (facetsFacet != null) { <line6> final Class<? extends FacetFactory>[] facetFactories = facetsFacet.facetFactories(); <line7> for (final Class<? extends FacetFactory> facetFactorie : facetFactories) { <line8> FacetFactory facetFactory; <line9> try { <line10> facetFactory = facetFactorie.newInstance(); <line11> } catch (final InstantiationException | IllegalAccessException e) { <line12> throw new UnrecoverableException(e); <line13> } <line14> getFacetProcessor().injectDependenciesInto(facetFactory); <line15> facetFactory.process( <line16> new ProcessClassContext(introspectedClass, methodRemover, inspectedTypeSpec)); <line17> } <line18> } <line19> } <line20> } <line21> 	<line2>
5584	"public class A { <line0> protected long[] doGetValueSizes( <line1> Connection conn, <line2> Statement stmt, <line3> int groupId, <line4> int[] dataIds, <line5> final Collection<String> columnNames) <line6> throws CacheException { <line7> String tableName = TableNames.getDataTableName(groupId); <line8> final String sql; <line9> if (dataIds.length == 1) { <line10> sql = getSQLGenerator().generateRetrieveValueSizes(dataIds[0], tableName, columnNames); <line11> } else { <line12> String joinTableName = <line13> getDatabaseTaskFactory() <line14> .getCreateIdJoinTableTask(dataIds, ColumnNames.JOIN_ID, ColumnNames.SEQUENCE) <line15> .run(conn, stmt); <line16> sql = getSQLGenerator().generateRetrieveValueSizes(joinTableName, tableName, columnNames); <line17> } <line18> ResultSet rs = getCacheUtilities().executeQuery(stmt, sql); <line19> try { <line20> return getCacheUtilities().convertResultSetToLongArray(rs); <line21> } catch (SQLException e) { <line22> throw new CacheException(""Failed to convert result set to long array: "" + e, e); <line23> } finally { <line24> try { <line25> rs.close(); <line26> } catch (SQLException e) { <line27> if (LOGGER.isTraceEnabled()) { <line28> } <line29> } <line30> } <line31> } <line32> } <line33> "	<line28>
5585	public class A { <line0> public static void error(Logger logger, String eventName, String format, Object arg) { <line1> } <line2> } <line3> 	<line1>
5586	"public class A { <line0> @Override <line1> public void testStarted(String host) { <line2> String reuseSSLContext = JMeterUtils.getProperty(""https.use.cached.ssl.context""); <line3> if (StringUtils.isEmpty(reuseSSLContext) || ""true"".equals(reuseSSLContext)) { <line4> } <line5> int startIndexAsInt = JMeterUtils.getPropDefault(KEY_STORE_START_INDEX, 0); <line6> int endIndexAsInt = JMeterUtils.getPropDefault(KEY_STORE_END_INDEX, -1); <line7> if (!StringUtils.isEmpty(this.startIndex)) { <line8> try { <line9> startIndexAsInt = Integer.parseInt(this.startIndex); <line10> } catch (NumberFormatException e) { <line11> } <line12> } <line13> if (!StringUtils.isEmpty(this.endIndex)) { <line14> try { <line15> endIndexAsInt = Integer.parseInt(this.endIndex); <line16> } catch (NumberFormatException e) { <line17> } <line18> } <line19> if (endIndexAsInt != -1 && startIndexAsInt > endIndexAsInt) { <line20> throw new JMeterStopTestException( <line21> ""Keystore Config error : Alias start index must be lower than Alias end index""); <line22> } <line23> String path = this.getPropertyAsString(""MS-KEYSTORE-FILE-PATH""); <line24> String password = this.getPropertyAsString(""MS-KEYSTORE-FILE-PASSWORD""); <line25> InputStream in = null; <line26> try { <line27> in = new FileInputStream(new File(path)); <line28> } catch (IOException e) { <line29> } <line30> SSLManager.getInstance() <line31> .configureKeystore( <line32> Boolean.parseBoolean(preload), <line33> startIndexAsInt, <line34> endIndexAsInt, <line35> clientCertAliasVarName, <line36> in, <line37> password); <line38> } <line39> } <line40> "	<line4>, <line11>, <line17>, <line23>, <line29>
5587	"public class A { <line0> public void validateScopeExpression(String scopeExpression) { <line1> if (StringUtils.isNotBlank(scopeExpression) <line2> && !expressionService.isExpressionValid(scopeExpression)) { <line3> throw errorResponseFactory.createWebApplicationException( <line4> BAD_REQUEST, <line5> UmaErrorResponseType.INVALID_SCOPE, <line6> ""Scope expression is invalid. Expression: "" + scopeExpression); <line7> } <line8> } <line9> } <line10> "	<line3>
5588	"public class A { <line0> public void switchOffGreenLed() { <line1> if (this.cc2650) { <line2> int value; <line3> String hexValue; <line4> try { <line5> value = <line6> Integer.parseInt( <line7> this.bluetoothGatt.readCharacteristicValue( <line8> TiSensorTagGatt.HANDLE_IO_SENSOR_VALUE_2650), <line9> 16) <line10> & 0xFD; <line11> hexValue = Integer.toHexString(value); <line12> this.bluetoothGatt.writeCharacteristicValue( <line13> TiSensorTagGatt.HANDLE_IO_SENSOR_VALUE_2650, <line14> hexValue.length() < 2 ? ""0"" + hexValue : hexValue); <line15> } catch (KuraException e) { <line16> } <line17> } else { <line18> } <line19> } <line20> } <line21> "	<line16>, <line18>
5589	public class A { <line0> public static void closeResultSet(ResultSet resultSet) { <line1> if (resultSet == null) { <line2> return; <line3> } <line4> try { <line5> resultSet.close(); <line6> } catch (SQLException e) { <line7> } <line8> } <line9> } <line10> 	<line7>
5590	public class A { <line0> public static Certificate changeToCertificate(X509Certificate x509Certificate) { <line1> Certificate certificate = new Certificate(); <line2> try { <line3> certificate.decode(x509Certificate.getEncoded()); <line4> } catch (IOException e) { <line5> } catch (CertificateEncodingException e) { <line6> } <line7> return certificate; <line8> } <line9> } <line10> 	<line5>, <line6>
5591	"public class A { <line0> @Disabled(""This is a manual test, by looking at the logs"") <line1> public void xxxtestLongShutdownOfThreadPool() throws Exception { <line2> final CountDownLatch latch = new CountDownLatch(1); <line3> ExecutorService pool = <line4> context.getExecutorServiceManager().newSingleThreadExecutor(this, ""Cool""); <line5> pool.execute( <line6> new Runnable() { <line7> @Override <line8> public void run() { <line9> try { <line10> latch.await(42, TimeUnit.SECONDS); <line11> } catch (InterruptedException e) { <line12> } <line13> } <line14> }); <line15> Thread.sleep(3000); <line16> context.getExecutorServiceManager().shutdown(pool); <line17> assertTrue(pool.isShutdown()); <line18> assertTrue(pool.isTerminated()); <line19> } <line20> } <line21> "	<line9>, <line13>
5592	public class A { <line0> @Override <line1> protected Stream<? extends DomainEventData<?>> readEventData( <line2> String aggregateIdentifier, long firstSequenceNumber) { <line3> EventChannel eventChannel = connectionManager.getConnection(context).eventChannel(); <line4> AggregateEventStream aggregateStream; <line5> if (firstSequenceNumber >= 0) { <line6> aggregateStream = eventChannel.openAggregateStream(aggregateIdentifier, firstSequenceNumber); <line7> } else if (firstSequenceNumber == ALLOW_SNAPSHOTS_MAGIC_VALUE && !snapshotFilterSet) { <line8> aggregateStream = eventChannel.openAggregateStream(aggregateIdentifier); <line9> } else { <line10> aggregateStream = eventChannel.openAggregateStream(aggregateIdentifier, WITHOUT_SNAPSHOTS); <line11> } <line12> return aggregateStream.asStream().map(GrpcBackedDomainEventData::new); <line13> } <line14> } <line15> 	<line3>
5593	public class A { <line0> public void handleMethod( <line1> String className, <line2> String methodName, <line3> int access, <line4> String params, <line5> String signature, <line6> String[] exceptions, <line7> String annotation) { <line8> } <line9> } <line10> 	<line8>
5594	"public class A { <line0> private synchronized void init() { <line1> if (stopped) { <line2> throw new RuntimeException(""Account monitor processing has been stopped""); <line3> } <line4> if (started) { <line5> return; <line6> } <line7> try { <line8> Runnable processingThread = <line9> new FundingMonitorProcessEventsThread(this, this.blockchain, this.accountService); <line10> if (!propertiesHolder.isLightClient()) { <line11> taskDispatchManager <line12> .newBackgroundDispatcher(""FundingMonitor"") <line13> .schedule( <line14> Task.builder() <line15> .name(""FundingMonitorThread"") <line16> .initialDelay(500) <line17> .delay(1000) <line18> .task(processingThread) <line19> .build()); <line20> } <line21> started = true; <line22> } catch (RuntimeException exc) { <line23> stopped = true; <line24> throw exc; <line25> } <line26> } <line27> } <line28> "	<line22>, <line24>
5595	public class A { <line0> @Override <line1> public final void debug() { <line2> if (LOGGER.isDebugEnabled()) { <line3> super.debugDefault(); <line4> } <line5> } <line6> } <line7> 	<line4>
5596	public class A { <line0> private boolean determineVacuumType( <line1> String path, <line2> String schema, <line3> String table, <line4> List<ConnectorVacuumTableInfo> tablesForVacuum, <line5> Map<String, String> parameters, <line6> HdfsEnvironment.HdfsContext hdfsContext) <line7> throws IOException { <line8> Path tablePath = new Path(path); <line9> AcidUtils.Directory dir = getDirectory(hdfsContext, tablePath); <line10> FileSystem fs = hdfsEnvironment.getFileSystem(hdfsContext, tablePath); <line11> boolean noBase = false; <line12> Path base = dir.getBaseDirectory(); <line13> long baseSize = 0; <line14> if (base != null) { <line15> baseSize += sumDirSize(fs, base); <line16> } <line17> List<HadoopShims.HdfsFileStatusWithId> originals = dir.getOriginalFiles(); <line18> for (HadoopShims.HdfsFileStatusWithId origStat : originals) { <line19> baseSize += origStat.getFileStatus().getLen(); <line20> } <line21> long deltaSize = 0; <line22> List<AcidUtils.ParsedDelta> deltas = dir.getCurrentDirectories(); <line23> for (AcidUtils.ParsedDelta delta : deltas) { <line24> deltaSize += sumDirSize(fs, delta.getPath()); <line25> } <line26> logStats(schema, table, baseSize, deltaSize, dir.getCurrentDirectories().size()); <line27> if (baseSize == 0 && deltaSize > 0) { <line28> noBase = true; <line29> } else { <line30> boolean bigEnough = (float) deltaSize / (float) baseSize > vacuumDeltaPercentThreshold; <line31> if (bigEnough) { <line32> ConnectorVacuumTableInfo vacuumTable = <line33> new ConnectorVacuumTableInfo(appendTableWithSchema(schema, table), true); <line34> tablesForVacuum.add(vacuumTable); <line35> return true; <line36> } <line37> } <line38> if (dir.getCurrentDirectories().size() > vacuumDeltaNumThreshold) { <line39> boolean isFull = false; <line40> if (AcidUtils.isInsertOnlyTable(parameters) || noBase) { <line41> isFull = true; <line42> } <line43> ConnectorVacuumTableInfo vacuumTable = <line44> new ConnectorVacuumTableInfo(appendTableWithSchema(schema, table), isFull); <line45> tablesForVacuum.add(vacuumTable); <line46> return true; <line47> } <line48> return false; <line49> } <line50> } <line51> 	<line8>
5597	public class A { <line0> public void attachClean(StgMUmsetzStat instance) { <line1> try { <line2> sessionFactory.getCurrentSession().lock(instance, LockMode.NONE); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
5598	public class A { <line0> @Override <line1> public void onClose(PartitionContext context, CloseReason reason) throws Exception { <line2> getLogger() <line3> } <line4> } <line5> 	<line3>
5599	public class A { <line0> public static UserGroup userGroupFromString(String s) { <line1> try { <line2> return UserGroup.valueOf(s); <line3> } catch (IllegalArgumentException e) { <line4> return UserGroup.USER; <line5> } <line6> } <line7> } <line8> 	<line4>
5600	"public class A { <line0> private void createErrorFile(File sentFile, String messageReceived) { <line1> File f = new File(this.failDir + sentFile.getName().replace("".txt"", """") + ""_ERROR.txt""); <line2> if (!f.exists()) { <line3> try { <line4> f.createNewFile(); <line5> FileWriter fstream = new FileWriter(f); <line6> BufferedWriter out = new BufferedWriter(fstream); <line7> out.write(messageReceived); <line8> out.close(); <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> } <line14> "	<line10>
5601	"public class A { <line0> public boolean checkExist(TableName htableName, CubeSegment segment) throws IOException { <line1> if (!htableExists(htableName)) { <line2> return false; <line3> } <line4> Table table = hbaseConn.getTable(htableName); <line5> HTableDescriptor tableDesc = table.getTableDescriptor(); <line6> if (segment.toString().equals(tableDesc.getValue(HTableSegmentTag))) { <line7> if (hbaseAdmin.isTableEnabled(htableName)) { <line8> return true; <line9> } else { <line10> hbaseAdmin.deleteTable(htableName); <line11> return false; <line12> } <line13> } <line14> throw new RuntimeException( <line15> ""htable name "" + htableName + "" has been used by "" + tableDesc.getValue(HTableSegmentTag)); <line16> } <line17> } <line18> "	<line11>
5602	public class A { <line0> long findConflict(List<Log> entries) { <line1> for (Log entry : entries) { <line2> if (!matchTerm(entry.getCurrLogTerm(), entry.getCurrLogIndex())) { <line3> if (entry.getCurrLogIndex() <= getLastLogIndex()) { <line4> } <line5> return entry.getCurrLogIndex(); <line6> } <line7> } <line8> return -1; <line9> } <line10> } <line11> 	<line4>
5603	public class A { <line0> public void mergeAllToZip( <line1> final FileSystem sourceFS, <line2> FileSystem targetFS, <line3> String targetPath, <line4> String downloadKey, <line5> ModalZipOutputStream.MODE mode) { <line6> Path outputPath = new Path(targetPath, downloadKey + ZIP_EXTENSION); <line7> try (FSDataOutputStream zipped = targetFS.create(outputPath, true); ) { <line8> if (ModalZipOutputStream.MODE.PRE_DEFLATED == mode) { <line9> try (ModalZipOutputStream zos = <line10> new ModalZipOutputStream(new BufferedOutputStream(zipped))) { <line11> for (ZipEntrySource source : sources) { <line12> zipPreDeflated(zos, sourceFS, source); <line13> } <line14> } <line15> } else { <line16> try (ZipOutputStream zos = new ZipOutputStream(zipped)) { <line17> for (ZipEntrySource source : sources) { <line18> zipDefault(zos, sourceFS, source); <line19> } <line20> } <line21> } <line22> } catch (Exception ex) { <line23> throw Throwables.propagate(ex); <line24> } <line25> } <line26> } <line27> 	<line23>
5604	"public class A { <line0> @Test <line1> public void testContextList() throws Exception { <line2> CamelContext context = new DefaultCamelContext(); <line3> context.setNameStrategy(new ExplicitCamelContextNameStrategy(""foobar"")); <line4> context.start(); <line5> CamelController controller = new DummyCamelController(context); <line6> OutputStream os = new ByteArrayOutputStream(); <line7> PrintStream ps = new PrintStream(os); <line8> ContextListCommand command = new ContextListCommand(); <line9> command.execute(controller, ps, null); <line10> String out = os.toString(); <line11> assertNotNull(out); <line12> assertTrue(out.contains(""foobar"")); <line13> assertTrue(out.contains(""Started"")); <line14> context.stop(); <line15> } <line16> } <line17> "	<line12>
5605	"public class A { <line0> @Override <line1> public void createContainer( <line2> String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) { <line3> Set<Class<?>> extraClasses = new HashSet<Class<?>>(); <line4> Collection<String> kbases = kieContainerInstance.getKieContainer().getKieBaseNames(); <line5> for (String kbase : kbases) { <line6> if (kbase.startsWith(""KiePMML"")) { <line7> continue; <line8> } <line9> kieContainerInstance.getKieContainer().getKieBase(kbase); <line10> } <line11> KieModuleMetaData metaData = <line12> (KieModuleMetaData) parameters.get(KieServerConstants.KIE_SERVER_PARAM_MODULE_METADATA); <line13> Collection<String> packages = metaData.getPackages(); <line14> for (String p : packages) { <line15> Collection<String> classes = metaData.getClasses(p); <line16> for (String c : classes) { <line17> String type = p + ""."" + c; <line18> try { <line19> Class<?> clazz = kieContainerInstance.getKieContainer().getClassLoader().loadClass(type); <line20> addExtraClass(extraClasses, clazz, filterRemoteable); <line21> } catch (ClassNotFoundException e) { <line22> } catch (Throwable e) { <line23> } <line24> } <line25> } <line26> kieContainerInstance.addExtraClasses(extraClasses); <line27> } <line28> } <line29> "	<line19>, <line21>, <line22>, <line23>
5606	public class A { <line0> @Override <line1> public boolean execute(Context context) throws Exception { <line2> boolean result = ERROR; <line3> Monitor monitor = MonitorFactory.start(COMMAND); <line4> try { <line5> Referential referential = (Referential) context.get(REFERENTIAL); <line6> processExtensions(referential); <line7> result = SUCCESS; <line8> } catch (Exception e) { <line9> throw e; <line10> } finally { <line11> } <line12> return result; <line13> } <line14> } <line15> 	<line9>, <line11>
5607	public class A { <line0> @Override <line1> public void expired() { <line2> if (jobLog.getEndTime() == null) { <line3> jobLog.setLastUpdated(ComponentUtil.getSystemHelper().getCurrentTimeAsLong()); <line4> if (logger.isDebugEnabled()) { <line5> } <line6> ComponentUtil.getComponent(JobLogBhv.class) <line7> .insertOrUpdate( <line8> jobLog, <line9> op -> { <line10> op.setRefreshPolicy(Constants.TRUE); <line11> }); <line12> } <line13> } <line14> } <line15> 	<line5>
5608	"public class A { <line0> @Deprecated <line1> public boolean checkSignals(JmriJFrame frame, LayoutEditor panel) { <line2> jmri.util.LoggingUtil.deprecationWarning(log, ""checkSignals""); <line3> if (panel == null) { <line4> return false; <line5> } <line6> if (initializationNeeded) { <line7> initializeBlocks(); <line8> } <line9> return true; <line10> } <line11> } <line12> "	<line4>
5609	public class A { <line0> private void notifyChannelEvtListener(UUID nodeId, Channel channel, Message initMsg) { <line1> if (log.isDebugEnabled()) <line2> CommunicationListener<Message> lsnr0 = lsnr; <line3> if (lsnr0 instanceof CommunicationListenerEx) <line4> ((CommunicationListenerEx<Message>) lsnr0).onChannelOpened(nodeId, initMsg, channel); <line5> } <line6> } <line7> 	<line2>
5610	public class A { <line0> public void greet(final int callCount) throws InterruptedException { <line1> final CountDownLatch done = new CountDownLatch(1); <line2> ClientResponseObserver< <line3> io.grpc.examples.manualflowcontrol.HelloRequest, <line4> io.grpc.examples.manualflowcontrol.HelloReply> <line5> clientResponseObserver = <line6> new ClientResponseObserver< <line7> io.grpc.examples.manualflowcontrol.HelloRequest, <line8> io.grpc.examples.manualflowcontrol.HelloReply>() { <line9> ClientCallStreamObserver<io.grpc.examples.manualflowcontrol.HelloRequest> <line10> requestStream; <line11>  <line12> @Override <line13> public void beforeStart( <line14> final ClientCallStreamObserver<io.grpc.examples.manualflowcontrol.HelloRequest> <line15> requestStream) { <line16> this.requestStream = requestStream; <line17> requestStream.disableAutoInboundFlowControl(); <line18> requestStream.setOnReadyHandler( <line19> new Runnable() { <line20> Iterator<String> iterator = names().iterator(); <line21>  <line22> @Override <line23> public void run() { <line24> int count = 0; <line25> while (requestStream.isReady()) { <line26> if (iterator.hasNext() && callCount > count) { <line27> String name = iterator.next(); <line28> io.grpc.examples.manualflowcontrol.HelloRequest request = <line29> io.grpc.examples.manualflowcontrol.HelloRequest.newBuilder() <line30> .setName(name) <line31> .build(); <line32> requestStream.onNext(request); <line33> count++; <line34> } else { <line35> requestStream.onCompleted(); <line36> } <line37> } <line38> } <line39> }); <line40> } <line41>  <line42> @Override <line43> public void onNext(io.grpc.examples.manualflowcontrol.HelloReply value) { <line44> requestStream.request(1); <line45> } <line46>  <line47> @Override <line48> public void onError(Throwable t) { <line49> t.printStackTrace(); <line50> done.countDown(); <line51> } <line52>  <line53> @Override <line54> public void onCompleted() { <line55> done.countDown(); <line56> } <line57> }; <line58> stub.sayHelloStreaming(clientResponseObserver); <line59> done.await(); <line60> } <line61> } <line62> 	<line28>, <line44>, <line55>
5611	public class A { <line0> private IPath bundlePath(Bundle bundle) { <line1> IPath path = binFolderPath(bundle); <line2> if (path == null) { <line3> try { <line4> path = new Path(FileLocator.getBundleFile(bundle).getAbsolutePath()); <line5> } catch (IOException e) { <line6> } <line7> } <line8> return path; <line9> } <line10> } <line11> 	<line6>
5612	"public class A { <line0> public GuiFragment getGuiFragment(String guiFragmentCode) { <line1> try { <line2> return this.getGuiFragmentManager().getGuiFragment(guiFragmentCode); <line3> } catch (Throwable t) { <line4> throw new RuntimeException(""error extracting gui fragment - code "" + guiFragmentCode, t); <line5> } <line6> } <line7> } <line8> "	<line4>
5613	"public class A { <line0> public synchronized void writeReports( <line1> String applicationName, <line2> @Nullable final String groupId, <line3> @Nullable final String artifactId, <line4> @Nullable final String version, <line5> @NotNull final File outputDir, <line6> String format, <line7> ExceptionCollection exceptions) <line8> throws ReportException { <line9> if (mode == Mode.EVIDENCE_COLLECTION) { <line10> throw new UnsupportedOperationException( <line11> ""Cannot generate report in evidence collection mode.""); <line12> } <line13> final DatabaseProperties prop = database.getDatabaseProperties(); <line14> final ReportGenerator r = <line15> new ReportGenerator( <line16> applicationName, <line17> groupId, <line18> artifactId, <line19> version, <line20> dependencies, <line21> getAnalyzers(), <line22> prop, <line23> settings, <line24> exceptions); <line25> try { <line26> r.write(outputDir.getAbsolutePath(), format); <line27> } catch (ReportException ex) { <line28> final String msg = String.format(""Error generating the report for %s"", applicationName); <line29> throw new ReportException(msg, ex); <line30> } <line31> } <line32> } <line33> "	<line29>
5614	public class A { <line0> public Map<String, ZNRecord> bucketize(ZNRecord record) { <line1> Map<String, ZNRecord> map = new HashMap<String, ZNRecord>(); <line2> if (_bucketSize == 0) { <line3> map.put(record.getId(), record); <line4> return map; <line5> } <line6> for (String partitionName : record.getListFields().keySet()) { <line7> String bucketName = getBucketName(partitionName); <line8> if (bucketName != null) { <line9> if (!map.containsKey(bucketName)) { <line10> map.put(bucketName, new ZNRecord(bucketName)); <line11> } <line12> ZNRecord bucketizedRecord = map.get(bucketName); <line13> bucketizedRecord.setListField(partitionName, record.getListField(partitionName)); <line14> } else { <line15> } <line16> } <line17> for (String partitionName : record.getMapFields().keySet()) { <line18> String bucketName = getBucketName(partitionName); <line19> if (bucketName != null) { <line20> if (!map.containsKey(bucketName)) { <line21> map.put(bucketName, new ZNRecord(bucketName)); <line22> } <line23> ZNRecord bucketizedRecord = map.get(bucketName); <line24> bucketizedRecord.setMapField(partitionName, record.getMapField(partitionName)); <line25> } else { <line26> } <line27> } <line28> for (ZNRecord bucketizedRecord : map.values()) { <line29> bucketizedRecord.setSimpleFields(record.getSimpleFields()); <line30> } <line31> return map; <line32> } <line33> } <line34> 	<line15>, <line26>
5615	"public class A { <line0> public void doTestUnknownAddressPlan(AddressSpace addressSpace, List<StageHolder> stageHolders) <line1> throws Exception { <line2> resourcesManager.createAddressSpace(addressSpace); <line3> do { <line4> List<StageHolder.Stage> stages = <line5> stageHolders.stream() <line6> .filter(StageHolder::hasStage) <line7> .map(StageHolder::popStage) <line8> .collect(Collectors.toList()); <line9> if (stages.isEmpty()) { <line10> break; <line11> } <line12> stages.stream() <line13> .map(StageHolder.Stage::getAddress) <line14> .forEach( <line15> address -> { <line16> Kubernetes.getInstance() <line17> .getAddressClient(address.getMetadata().getNamespace()) <line18> .createOrReplace(address); <line19> }); <line20> stages.forEach( <line21> s -> { <line22> AtomicReference<String> lastMatch = new AtomicReference<>(); <line23> boolean rv = <line24> TestUtils.waitUntilCondition( <line25> () -> { <line26> Address current = <line27> resourcesManager.getAddress( <line28> s.getAddress().getMetadata().getNamespace(), s.getAddress()); <line29> Matcher<Address> matcher = s.getMatcher(); <line30> boolean matches = matcher.matches(current); <line31> StringDescription desc = new StringDescription(); <line32> matcher.describeMismatch(current, desc); <line33> lastMatch.set(desc.toString()); <line34> if (matches) { <line35> } else { <line36> } <line37> return matches; <line38> }, <line39> Duration.ofMinutes(2), <line40> Duration.ofSeconds(10)); <line41> assertTrue( <line42> rv, <line43> String.format( <line44> ""address %s did not reach desired state : %s"", <line45> s.getAddress().getMetadata().getName(), lastMatch)); <line46> }); <line47> } while (true); <line48> } <line49> } <line50> "	<line4>, <line35>, <line36>
5616	"public class A { <line0> @Override <line1> protected void serviceStart() throws Exception { <line2> if (slowCheckEnable) { <line3> checker = <line4> new Thread( <line5> new Runnable() { <line6> @Override <line7> public void run() { <line8> int size = checkPolices.size(); <line9> while (!stopped.get() && !Thread.interrupted()) { <line10> for (int i = 0; i < size; i++) { <line11> List<Id> slowItems = checkPolices.get(i).check(context); <line12> handleSlowItems(slowItems); <line13> } <line14> try { <line15> Thread.sleep(checkIntervalMs); <line16> } catch (InterruptedException e) { <line17> } <line18> } <line19> } <line20> }); <line21> checker.setName(""slow-checker""); <line22> checker.start(); <line23> } <line24> } <line25> } <line26> "	<line2>, <line8>, <line17>
5617	"public class A { <line0> protected String render(String valueString, Locale locale) { <line1> if (Validator.isNotNull(valueString)) { <line2> try { <line3> return DateUtil.formatDate(""yyyy-MM-dd"", valueString, locale); <line4> } catch (ParseException parseException) { <line5> } <line6> } <line7> return StringPool.BLANK; <line8> } <line9> } <line10> "	<line5>
5618	"public class A { <line0> public static void main(final String[] args) throws Exception { <line1> URI uri; <line2> if (args.length > 0) { <line3> uri = new URI(args[0]); <line4> } else { <line5> uri = new URI(""http://192.168.1.101:8181/opendaylight-inventory:nodes""); <line6> } <line7> IClientMessageCallback messageCallback = new ClientMessageCallback(); <line8> WebSocketClient webSocketClient = new WebSocketClient(uri, messageCallback); <line9> webSocketClient.connect(); <line10> while (true) { <line11> BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); <line12> String input = br.readLine(); <line13> if (input.equals(""q"")) { <line14> input = br.readLine(); <line15> if (input.equals(""yes"") || input.isEmpty()) { <line16> webSocketClient.close(""opendaylight-inventory:nodes""); <line17> break; <line18> } <line19> } <line20> } <line21> } <line22> } <line23> "	<line14>
5619	"public class A { <line0> @RequestMapping(value = ""/findAll.action"", method = RequestMethod.GET) <line1> @ResponseBody <line2> public Map<String, Object> findAll( <line3> @RequestParam Integer start, <line4> @RequestParam Integer limit, <line5> @RequestParam Enum statusValue, <line6> @DefaultValue(""no"") @QueryParam(""trashed"") String trashed) <line7> throws Exception { <line8> start = (start != null) ? start : 0; <line9> limit = (limit != null) ? limit : 50; <line10> try { <line11> List<Collection> data = collectionService.findAllForPublic(start, limit, statusValue); <line12> return getUIWrapper(data, true); <line13> } catch (Exception e) { <line14> return getUIWrapper(false); <line15> } <line16> } <line17> } <line18> "	<line12>, <line14>
5620	"public class A { <line0> @Override <line1> public void doView(RenderRequest request, RenderResponse response) <line2> throws IOException, PortletException { <line3> try { <line4> PortletRequestDispatcher prDispatcher = <line5> getPortletContext().getRequestDispatcher(""/WEB-INF/pages/editors-admin.jsp""); <line6> prDispatcher.include(request, response); <line7> WebuiRequestContext context = WebuiRequestContext.getCurrentInstance(); <line8> CometdDocumentsService cometdService = <line9> ExoContainerContext.getCurrentContainer() <line10> .getComponentInstanceOfType(CometdDocumentsService.class); <line11> JavascriptManager js = <line12> ((WebuiRequestContext) WebuiRequestContext.getCurrentInstance()).getJavascriptManager(); <line13> CometdConfig cometdConf = <line14> new CometdConfig( <line15> cometdService.getCometdServerPath(), <line16> cometdService.getUserToken(context.getRemoteUser()), <line17> PortalContainer.getCurrentPortalContainerName()); <line18> DocumentService documentService = <line19> ExoContainerContext.getCurrentContainer() <line20> .getComponentInstanceOfType(DocumentService.class); <line21> long idleTimeout = documentService.getEditorsIdleTimeout(); <line22> js.require(""SHARED/editorsupport"", ""editorsupport"") <line23> .addScripts( <line24> ""editorsupport.initConfig('"" <line25> + context.getRemoteUser() <line26> + ""' ,"" <line27> + cometdConf.toJSON() <line28> + "", "" <line29> + getI18n(request.getLocale()) <line30> + "", "" <line31> + idleTimeout <line32> + "");""); <line33> } catch (Exception e) { <line34> } <line35> } <line36> } <line37> "	<line34>
5621	public class A { <line0> public void createAddressSpace(AddressSpace... addressSpaces) throws Exception { <line1> String operationID = <line2> TimeMeasuringSystem.startOperation(SystemtestsOperation.CREATE_ADDRESS_SPACE); <line3> for (AddressSpace addressSpace : addressSpaces) { <line4> if (!AddressSpaceUtils.existAddressSpace( <line5> addressSpace.getMetadata().getNamespace(), addressSpace.getMetadata().getName())) { <line6> kubernetes <line7> .getAddressSpaceClient(addressSpace.getMetadata().getNamespace()) <line8> .createOrReplace(addressSpace); <line9> } else { <line10> } <line11> } <line12> for (AddressSpace addressSpace : addressSpaces) { <line13> AddressSpaceUtils.waitForAddressSpaceReady(addressSpace); <line14> AddressSpaceUtils.syncAddressSpaceObject(addressSpace); <line15> } <line16> TimeMeasuringSystem.stopOperation(operationID); <line17> } <line18> } <line19> 	<line6>, <line10>
5622	"public class A { <line0> private void handleMessage(String data) { <line1> if (data.equals(""ACK"") || data.equals("""")) { <line2> return; <line3> } <line4> if (data.startsWith(ID + ':')) { <line5> String[] value = data.substring(3).split("",""); <line6> if (!hasProperties) { <line7> populateProperties(value); <line8> } <line9> DecimalType signalStrength = mapSignalStrength(Integer.parseInt(value[5])); <line10> updateState(CHANNEL_TYPE_RSSI, signalStrength); <line11> return; <line12> } <line13> IntesisBoxMessage message = IntesisBoxMessage.parse(data); <line14> if (message != null) { <line15> switch (message.getCommand()) { <line16> case LIMITS: <line17> String function = message.getFunction(); <line18> if (function.equals(""SETPTEMP"")) { <line19> List<Double> limits = <line20> message.getLimitsValue().stream() <line21> .map(l -> Double.valueOf(l) / 10.0d) <line22> .collect(Collectors.toList()); <line23> if (limits.size() == 2) { <line24> minTemp = limits.get(0); <line25> maxTemp = limits.get(1); <line26> } <line27> properties.put(""targetTemperature limits"", ""["" + minTemp + "","" + maxTemp + ""]""); <line28> addChannel(CHANNEL_TYPE_TARGETTEMP, ""Number:Temperature""); <line29> } else { <line30> switch (function) { <line31> case ""MODE"": <line32> properties.put(""supported modes"", message.getValue()); <line33> limits.put(CHANNEL_TYPE_MODE, message.getLimitsValue()); <line34> addChannel(CHANNEL_TYPE_MODE, ""String""); <line35> break; <line36> case ""FANSP"": <line37> properties.put(""supported fan levels"", message.getValue()); <line38> limits.put(CHANNEL_TYPE_FANSPEED, message.getLimitsValue()); <line39> addChannel(CHANNEL_TYPE_FANSPEED, ""String""); <line40> break; <line41> case ""VANEUD"": <line42> properties.put(""supported vane up/down modes"", message.getValue()); <line43> limits.put(CHANNEL_TYPE_VANESUD, message.getLimitsValue()); <line44> addChannel(CHANNEL_TYPE_VANESUD, ""String""); <line45> break; <line46> case ""VANELR"": <line47> properties.put(""supported vane left/right modes"", message.getValue()); <line48> limits.put(CHANNEL_TYPE_VANESLR, message.getLimitsValue()); <line49> addChannel(CHANNEL_TYPE_VANESLR, ""String""); <line50> break; <line51> } <line52> } <line53> updateProperties(properties); <line54> break; <line55> case CHN: <line56> receivedUpdate(message.getFunction(), message.getValue()); <line57> break; <line58> } <line59> } <line60> } <line61> } <line62> "	<line1>, <line17>, <line27>
5623	public class A { <line0> public static com.liferay.site.navigation.model.SiteNavigationMenuSoap addSiteNavigationMenu( <line1> long groupId, <line2> String name, <line3> int type, <line4> boolean auto, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws RemoteException { <line7> try { <line8> com.liferay.site.navigation.model.SiteNavigationMenu returnValue = <line9> SiteNavigationMenuServiceUtil.addSiteNavigationMenu( <line10> groupId, name, type, auto, serviceContext); <line11> return com.liferay.site.navigation.model.SiteNavigationMenuSoap.toSoapModel(returnValue); <line12> } catch (Exception exception) { <line13> throw new RemoteException(exception.getMessage()); <line14> } <line15> } <line16> } <line17> 	<line13>
5624	public class A { <line0> public long getUserCount() { <line1> long count = 0; <line2> try { <line3> Weblogger roller = WebloggerFactory.getWeblogger(); <line4> UserManager mgr = roller.getUserManager(); <line5> count = mgr.getUserCount(); <line6> } catch (WebloggerException e) { <line7> } <line8> return count; <line9> } <line10> } <line11> 	<line7>
5625	"public class A { <line0> @SuppressFBWarnings( <line1> value = {""PATH_TRAVERSAL_IN"", ""URLCONNECTION_SSRF_FD""}, <line2> justification = ""path provided by test; url provided by test"") <line3> private Map<?, ?> getStats() throws Exception { <line4> String uri = getCluster().getMiniDfs().getHttpUri(0); <line5> URL url = new URL(uri + ""/jmx""); <line6> String jsonString = FunctionalTestUtils.readWebPage(url).body(); <line7> Gson gson = new Gson(); <line8> Map<?, ?> jsonObject = gson.fromJson(jsonString, Map.class); <line9> List<?> beans = (List<?>) jsonObject.get(""beans""); <line10> for (Object bean : beans) { <line11> Map<?, ?> map = (Map<?, ?>) bean; <line12> if (map.get(""name"").toString().equals(""Hadoop:service=NameNode,name=NameNodeActivity"")) { <line13> return map; <line14> } <line15> } <line16> return new HashMap<>(0); <line17> } <line18> } <line19> "	<line6>
5626	"public class A { <line0> @Override <line1> public BatchPlannerPlan findByC_N(long companyId, String name) throws NoSuchPlanException { <line2> BatchPlannerPlan batchPlannerPlan = fetchByC_N(companyId, name); <line3> if (batchPlannerPlan == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""companyId=""); <line7> sb.append(companyId); <line8> sb.append("", name=""); <line9> sb.append(name); <line10> sb.append(""}""); <line11> if (_log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchPlanException(sb.toString()); <line14> } <line15> return batchPlannerPlan; <line16> } <line17> } <line18> "	<line12>
5627	"public class A { <line0> private static void removeIndex() { <line1> Region region = basicGetCache().getRegion(""portfolios""); <line2> if (region == null) { <line3> fail(""The region is not created properly""); <line4> } else { <line5> QueryService qs = basicGetCache().getQueryService(); <line6> if (qs != null) { <line7> try { <line8> Collection indexes = qs.getIndexes(region); <line9> if (indexes.isEmpty()) { <line10> return; <line11> } <line12> Iterator iter = indexes.iterator(); <line13> if (iter.hasNext()) { <line14> Index idx = (Index) (iter.next()); <line15> String name = idx.getName(); <line16> qs.removeIndex(idx); <line17> } <line18> } catch (Exception e) { <line19> Assert.fail(""Caught exception while trying to remove index"", e); <line20> } <line21> } else { <line22> fail(""Unable to obtain QueryService for the cache ""); <line23> } <line24> } <line25> } <line26> } <line27> "	<line5>, <line17>
5628	public class A { <line0> public static StellarFunction createFunction(Class<? extends StellarFunction> clazz) { <line1> try { <line2> return clazz.getConstructor().newInstance(); <line3> } catch (Exception e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	<line4>
5629	"public class A { <line0> public List<Map<String, Object>> search( <line1> final String queryString, <line2> final Set<AttributeType> queryAttributes, <line3> final Set<AttributeType> responseAttributes, <line4> final Set<ObjectType> objectTypes) <line5> throws IOException { <line6> return fullTextIndex.search( <line7> (final IndexReader indexReader, <line8> final TaxonomyReader taxonomyReader, <line9> final IndexSearcher indexSearcher) -> { <line10> final List<Map<String, Object>> results = Lists.newArrayList(); <line11> final Query query; <line12> try { <line13> if (objectTypes != null && !objectTypes.isEmpty()) { <line14> query = <line15> new BooleanQuery.Builder() <line16> .add(constructQuery(queryAttributes, queryString), BooleanClause.Occur.MUST) <line17> .add(constructQuery(objectTypes), BooleanClause.Occur.MUST) <line18> .build(); <line19> } else { <line20> query = constructQuery(queryAttributes, queryString); <line21> } <line22> } catch (ParseException e) { <line23> return Collections.emptyList(); <line24> } <line25> final TopFieldDocs topDocs = <line26> indexSearcher.search(query, MAX_SEARCH_RESULTS, SORT_BY_LOOKUP_KEY, true, true); <line27> for (ScoreDoc scoreDoc : topDocs.scoreDocs) { <line28> final Document doc = indexSearcher.doc(scoreDoc.doc); <line29> final Map<String, Object> result = Maps.newLinkedHashMap(); <line30> final RpslObject rpslObject; <line31> try { <line32> rpslObject = <line33> objectDao.getByKey( <line34> ObjectType.getByName(doc.get(FullTextIndex.OBJECT_TYPE_FIELD_NAME)), <line35> doc.get(FullTextIndex.LOOKUP_KEY_FIELD_NAME)); <line36> } catch (EmptyResultDataAccessException ex) { <line37> continue; <line38> } <line39> result.put(""key"", rpslObject.getKey().toString()); <line40> result.put(""type"", rpslObject.getType().getName()); <line41> for (final AttributeType attribute : responseAttributes) { <line42> final ObjectTemplate template = ObjectTemplate.getTemplate(rpslObject.getType()); <line43> if (template.getMultipleAttributes().contains(attribute)) { <line44> result.put(attribute.getName(), filterValues(attribute, rpslObject)); <line45> } else { <line46> result.put( <line47> attribute.getName(), <line48> filterValue( <line49> attribute, <line50> rpslObject.containsAttribute(attribute) <line51> ? rpslObject.findAttribute(attribute).getValue() <line52> : null)); <line53> } <line54> } <line55> results.add(result); <line56> } <line57> return results; <line58> }); <line59> } <line60> } <line61> "	<line23>, <line37>
5630	"public class A { <line0> @Override <line1> protected Collection<ComputeJobAdapter> split(int gridSize, Object arg) { <line2> Collection<ComputeJobAdapter> jobs = new ArrayList<>(gridSize); <line3> for (int i = 0; i < gridSize; i++) { <line4> jobs.add( <line5> new ComputeJobAdapter() { <line6> @TaskSessionResource private ComputeTaskSession taskSes; <line7> @JobContextResource private ComputeJobContext jobCtx; <line8> @LoggerResource private IgniteLogger log; <line9>  <line10> @Override <line11> public Serializable execute() { <line12> IgniteUuid jobId = jobCtx.getJobId(); <line13> String attr = (String) taskSes.getAttribute(jobId); <line14> assert attr != null : ""Attribute is null.""; <line15> assert attr.equals(""test-"" + jobId) : ""Attribute has incorrect value: "" + attr; <line16> return null; <line17> } <line18> }); <line19> } <line20> return jobs; <line21> } <line22> } <line23> "	<line16>
5631	"public class A { <line0> public static int getVocabularyRootCategoriesCount( <line1> HttpPrincipal httpPrincipal, long groupId, long vocabularyId) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> AssetCategoryServiceUtil.class, <line6> ""getVocabularyRootCategoriesCount"", <line7> _getVocabularyRootCategoriesCountParameterTypes23); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, vocabularyId); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> throw systemException; <line18> } <line19> } <line20> } <line21> "	<line17>
5632	public class A { <line0> private void handleZoneMembersCommand(Command command) throws SpeakerException { <line1> String[] memberNames = command.toString().split(bindingProperties.getZoneMemberSeparator()); <line2> List<String> memberIds = new ArrayList<>(); <line3> for (String memberName : memberNames) { <line4> memberIds.add(getHandlerIdByLabel(memberName.trim())); <line5> } <line6> createZoneInNewThread(memberIds); <line7> } <line8> } <line9> 	<line2>
5633	"public class A { <line0> protected String doTccActionLogStore( <line1> Method method, <line2> Object[] arguments, <line3> TwoPhaseBusinessAction businessAction, <line4> BusinessActionContext actionContext) { <line5> String actionName = actionContext.getActionName(); <line6> String xid = actionContext.getXid(); <line7> Map<String, Object> context = fetchActionRequestContext(method, arguments); <line8> context.put(Constants.ACTION_START_TIME, System.currentTimeMillis()); <line9> initBusinessContext(context, method, businessAction); <line10> initFrameworkContext(context); <line11> actionContext.setDelayReport(businessAction.isDelayReport()); <line12> actionContext.setActionContext(context); <line13> Map<String, Object> applicationContext = <line14> Collections.singletonMap(Constants.TCC_ACTION_CONTEXT, context); <line15> String applicationContextStr = JSON.toJSONString(applicationContext); <line16> try { <line17> Long branchId = <line18> DefaultResourceManager.get() <line19> .branchRegister(BranchType.TCC, actionName, null, xid, applicationContextStr, null); <line20> return String.valueOf(branchId); <line21> } catch (Throwable t) { <line22> String msg = String.format(""TCC branch Register error, xid: %s"", xid); <line23> throw new FrameworkException(t, msg); <line24> } <line25> } <line26> } <line27> "	<line23>
5634	"public class A { <line0> public static void fillSchemaServiceFromSchemaDecl() throws IOException { <line1> RDFUnitUtils.fillSchemaServiceFromResource(""org/aksw/rdfunit/configuration/schemaDecl.csv""); <line2> } <line3> } <line4> "	<line1>
5635	public class A { <line0> @Override <line1> public void postDirty(InstanceLifecycleEvent event) { <line2> } <line3> } <line4> 	<line2>
5636	public class A { <line0> public static MimeType createFromExtension(String fileExtension) throws MimeException { <line1> MimeType mimeType = ImageMime.checkForExtension(fileExtension); <line2> if (mimeType != null) { <line3> return mimeType; <line4> } <line5> mimeType = XMLMime.checkForExtension(fileExtension); <line6> if (mimeType != null) { <line7> return mimeType; <line8> } <line9> mimeType = TextMime.checkForExtension(fileExtension); <line10> if (mimeType != null) { <line11> return mimeType; <line12> } <line13> mimeType = ApplicationMime.checkForExtension(fileExtension); <line14> if (mimeType != null) { <line15> return mimeType; <line16> } <line17> return null; <line18> } <line19> } <line20> 	<line17>
5637	public class A { <line0> @Override <line1> public void debug(Object requester, String format, Object... args) { <line2> if (args != null && args[0] instanceof Throwable) <line3> } <line4> } <line5> 	<line3>
5638	public class A { <line0> @Override <line1> public void completed(final T result) { <line2> if (callback != null) { <line3> try { <line4> callback.completed(result); <line5> } catch (final Exception ex) { <line6> } <line7> } <line8> } <line9> } <line10> 	<line6>
5639	"public class A { <line0> @Override <line1> public List<ExecutionImpl> findControlExecution(final String uuidControl) { <line2> DetachedCriteria executionCrit = DetachedCriteria.forClass(ExecutionImpl.class); <line3> String processDefinitionId = findProcessDefinitionId(IControlExecutionProcess.KEY); <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> executionCrit.add(Restrictions.eq(""processDefinitionId"", processDefinitionId)); <line7> DetachedCriteria variableCrit = executionCrit.createCriteria(""variables""); <line8> variableCrit.add(Restrictions.eq(""key"", IGenericProcess.VAR_UUID)); <line9> variableCrit.add(Restrictions.eq(""string"", uuidControl)); <line10> return getJbpmExecutionDao().findByCriteria(executionCrit); <line11> } <line12> } <line13> "	<line5>
5640	public class A { <line0> public void init(FilterConfig arg0) throws ServletException { <line1> this.filterConfig = arg0; <line2> } <line3> } <line4> 	<line1>, <line2>
5641	public class A { <line0> private void onReceiveProcessorReportTaskStatusReq(ProcessorReportTaskStatusReq req) { <line1> int taskStatus = req.getStatus(); <line2> TaskTracker taskTracker = TaskTrackerPool.getTaskTrackerPool(req.getInstanceId()); <line3> if (TaskStatus.finishedStatus.contains(taskStatus)) { <line4> AskResponse askResponse = AskResponse.succeed(null); <line5> getSender().tell(askResponse, getSelf()); <line6> } <line7> if (taskTracker == null) { <line8> return; <line9> } <line10> if (ProcessorReportTaskStatusReq.BROADCAST.equals(req.getCmd())) { <line11> taskTracker.broadcast( <line12> taskStatus == TaskStatus.WORKER_PROCESS_SUCCESS.getValue(), <line13> req.getSubInstanceId(), <line14> req.getTaskId(), <line15> req.getResult()); <line16> } <line17> taskTracker.updateTaskStatus( <line18> req.getSubInstanceId(), req.getTaskId(), taskStatus, req.getReportTime(), req.getResult()); <line19> taskTracker.updateAppendedWfContext(req.getAppendedWfContext()); <line20> } <line21> } <line22> 	<line8>
5642	public class A { <line0> public Future<CommandResult> writeAttribute( <line1> final int attributeId, final ZclDataType dataType, final Object value) { <line2> final WriteAttributeRecord attributeIdentifier = new WriteAttributeRecord(); <line3> attributeIdentifier.setAttributeIdentifier(attributeId); <line4> attributeIdentifier.setAttributeDataType(dataType); <line5> attributeIdentifier.setAttributeValue(value); <line6> return writeAttributes(Collections.singletonList(attributeIdentifier)); <line7> } <line8> } <line9> 	<line2>
5643	public class A { <line0> private boolean noRoutingMatch( <line1> List<PartnerLinkMyRoleImpl> targets, <line2> MyRoleMessageExchangeImpl mex, <line3> boolean enqueue, <line4> boolean enqueueForFutureInstance) { <line5> boolean routed = false; <line6> List<PartnerLinkMyRoleImpl.RoutingInfo> routings = null; <line7> LinkedHashSet<ProcessInstanceDAO> intersectionInstanceSet = <line8> new LinkedHashSet<ProcessInstanceDAO>(); <line9> for (Iterator<PartnerLinkMyRoleImpl> targetItr = targets.iterator(); <line10> (targetItr.hasNext() && !routed); ) { <line11> PartnerLinkMyRoleImpl target = targetItr.next(); <line12> routings = target.findRoute(mex, enqueue || enqueueForFutureInstance); <line13> if (routings != null) { <line14> RoutingInfo routing = routings.get(routings.size() - 1); <line15> if (routing != null) { <line16> if (enqueueForFutureInstance && isActive()) { <line17> mex.getDAO().setProcess(getProcessDAO()); <line18> target.noRoutingMatch(mex, routing); <line19> routed = true; <line20> return routed; <line21> } <line22> if (enqueue) { <line23> for (Iterator<CorrelationKey> keyItr = routing.wholeKeySet.iterator(); <line24> (keyItr.hasNext() && !routed); ) { <line25> CorrelationKey key = keyItr.next(); <line26> Collection<ProcessInstanceDAO> instanceDaoList = <line27> getProcessDAO().findInstance(key, ProcessState.STATE_ACTIVE); <line28> if (!(instanceDaoList.isEmpty())) { <line29> if (!intersectionInstanceSet.isEmpty()) <line30> intersectionInstanceSet.retainAll(instanceDaoList); <line31> else intersectionInstanceSet.addAll(instanceDaoList); <line32> } <line33> } <line34> if (!(intersectionInstanceSet.isEmpty())) { <line35> ProcessInstanceDAO instance = intersectionInstanceSet.iterator().next(); <line36> mex.getDAO().setProcess(instance.getProcess()); <line37> CorrelatorDAO correlator = <line38> instance.getProcess().getCorrelator(routing.correlator.getCorrelatorId()); <line39> RoutingInfo matchedRouting = <line40> new RoutingInfo( <line41> routing.messageRoute, routing.matchedKeySet, correlator, routing.wholeKeySet); <line42> target.noRoutingMatch(mex, matchedRouting); <line43> routed = true; <line44> } <line45> } <line46> } <line47> } <line48> } <line49> return routed; <line50> } <line51> } <line52> 	<line20>, <line26>, <line32>, <line44>
5644	"public class A { <line0> @Override <line1> public void initialize(UimaContext context) throws ResourceInitializationException { <line2> super.initialize(context); <line3> modelProvider = <line4> new ModelProviderBase<Annotator>() { <line5> { <line6> setContextObject(IllinoisChunker.this); <line7> setDefault(LOCATION, NOT_REQUIRED); <line8> } <line9>  <line10> @Override <line11> protected ChunkerAnnotator produceResource(URL aUrl) throws IOException { <line12> if (!""en"".equals(getAggregatedProperties().getProperty(LANGUAGE))) { <line13> throw new IllegalArgumentException(""Only language [en] is supported""); <line14> } <line15> ChunkerAnnotator annotator = new ChunkerAnnotator(); <line16> SingletonTagset tags = new SingletonTagset(Chunk.class, ""conll2000""); <line17> try { <line18> Chunker chunker = (Chunker) FieldUtils.readField(annotator, ""tagger"", true); <line19> for (int i = 0; i < chunker.getLabelLexicon().size(); i++) { <line20> String tag = chunker.getLabelLexicon().lookupKey(i).getStringValue(); <line21> if (tag.length() > 1) { <line22> tag = tag.substring(2); <line23> tags.add(tag); <line24> } <line25> } <line26> } catch (IllegalAccessException e) { <line27> throw new IllegalStateException(e); <line28> } <line29> addTagset(tags); <line30> if (printTagSet) { <line31> } <line32> return annotator; <line33> } <line34> }; <line35> mappingProvider = new MappingProvider(); <line36> mappingProvider.setDefault(MappingProvider.LOCATION, chunkMappingLocation); <line37> mappingProvider.setDefault(MappingProvider.BASE_TYPE, Chunk.class.getName()); <line38> } <line39> } <line40> "	<line31>
5645	"public class A { <line0> public static String getHostname() { <line1> if (hostname == null) { <line2> final String hostname = <line3> Service.configuration != null ? Service.configuration.HOST_NAME : null; <line4> if (hostname != null && hostname.length() > 0) { <line5> Service.hostname = hostname; <line6> } else { <line7> try { <line8> Service.hostname = InetAddress.getLocalHost().getHostAddress(); <line9> } catch (UnknownHostException e) { <line10> Service.hostname = ""localhost""; <line11> } <line12> } <line13> } <line14> return hostname; <line15> } <line16> } <line17> "	<line10>
5646	public class A { <line0> @Override <line1> public void run() { <line2> DatagramSocket socket = getSocket(); <line3> if (socket != null) { <line4> receiveData(socket); <line5> } <line6> } <line7> } <line8> 	<line4>
5647	public class A { <line0> protected void handleTxExpires(Message message) { <line1> ClientRoSessionState state = sessionData.getClientRoSessionState(); <line2> if (isEventBased()) { <line3> int gatheredRequestedAction = sessionData.getGatheredRequestedAction(); <line4> if (gatheredRequestedAction == CHECK_BALANCE || gatheredRequestedAction == PRICE_ENQUIRY) { <line5> context.indicateServiceError(this); <line6> setState(ClientRoSessionState.IDLE); <line7> } else if (gatheredRequestedAction == DIRECT_DEBITING) { <line8> if (sessionData.getGatheredDDFH() == DDFH_TERMINATE_OR_BUFFER) { <line9> sessionData.setBuffer((Request) message); <line10> setState(ClientRoSessionState.IDLE, false); <line11> } else { <line12> context.grantAccessOnTxExpire(this); <line13> setState(ClientRoSessionState.PENDING_EVENT); <line14> } <line15> } else if (gatheredRequestedAction == REFUND_ACCOUNT) { <line16> message.setReTransmitted(true); <line17> sessionData.setBuffer((Request) message); <line18> setState(ClientRoSessionState.IDLE, false); <line19> } <line20> } else { <line21> switch (state) { <line22> case PENDING_INITIAL: <line23> switch (getLocalCCFH()) { <line24> case CCFH_CONTINUE: <line25> case CCFH_RETRY_AND_TERMINATE: <line26> context.grantAccessOnTxExpire(this); <line27> break; <line28> case CCFH_TERMINATE: <line29> context.denyAccessOnTxExpire(this); <line30> setState(ClientRoSessionState.IDLE, true); <line31> break; <line32> default: <line33> break; <line34> } <line35> break; <line36> case PENDING_UPDATE: <line37> switch (getLocalCCFH()) { <line38> case CCFH_CONTINUE: <line39> case CCFH_RETRY_AND_TERMINATE: <line40> context.grantAccessOnTxExpire(this); <line41> break; <line42> case CCFH_TERMINATE: <line43> context.denyAccessOnTxExpire(this); <line44> setState(ClientRoSessionState.IDLE, true); <line45> break; <line46> default: <line47> break; <line48> } <line49> break; <line50> default: <line51> break; <line52> } <line53> } <line54> } <line55> } <line56> 	<line33>, <line47>, <line51>
5648	"public class A { <line0> private Report exportFolders( <line1> List<AIP> aips, <line2> StorageService storage, <line3> ModelService model, <line4> IndexService index, <line5> Report report, <line6> JobPluginInfo jobPluginInfo, <line7> Job job) { <line8> try { <line9> FileStorageService localStorage = <line10> new FileStorageService(Paths.get(outputFolder), false, null, false); <line11> for (AIP aip : aips) { <line12> String error = null; <line13> StoragePath aipPath = ModelUtils.getAIPStoragePath(aip.getId()); <line14> try { <line15> localStorage.copy(storage, aipPath, DefaultStoragePath.parse(aip.getId())); <line16> } catch (AlreadyExistsException e) { <line17> if (removeIfAlreadyExists) { <line18> try { <line19> localStorage.deleteResource(DefaultStoragePath.parse(aip.getId())); <line20> localStorage.copy(storage, aipPath, DefaultStoragePath.parse(aip.getId())); <line21> } catch (AlreadyExistsException e2) { <line22> error = ""Error removing/creating folder "" + aipPath.toString(); <line23> } <line24> } else { <line25> error = ""Folder "" + aipPath.toString() + "" already exists.""; <line26> } <line27> } <line28> Report reportItem = <line29> PluginHelper.initPluginReportItem(this, aip.getId(), AIP.class, AIPState.ACTIVE); <line30> if (error != null) { <line31> reportItem <line32> .setPluginState(PluginState.FAILURE) <line33> .setPluginDetails(""Export AIP did not end successfully: "" + error); <line34> jobPluginInfo.incrementObjectsProcessedWithFailure(); <line35> } else { <line36> reportItem <line37> .setPluginState(PluginState.SUCCESS) <line38> .setPluginDetails(""Export AIP ended successfully""); <line39> jobPluginInfo.incrementObjectsProcessedWithSuccess(); <line40> } <line41> report.addReport(reportItem); <line42> PluginHelper.updatePartialJobReport(this, model, reportItem, true, job); <line43> try { <line44> boolean notify = true; <line45> PluginHelper.createPluginEvent( <line46> this, aip.getId(), model, index, reportItem.getPluginState(), """", notify); <line47> } catch (ValidationException <line48> | RequestNotValidException <line49> | NotFoundException <line50> | GenericException <line51> | AuthorizationDeniedException <line52> | AlreadyExistsException e) { <line53> } <line54> } <line55> } catch (GenericException <line56> | RequestNotValidException <line57> | AuthorizationDeniedException <line58> | NotFoundException e) { <line59> } <line60> return report; <line61> } <line62> } <line63> "	<line12>, <line53>, <line59>
5649	public class A { <line0> protected final synchronized void replaceOnscreen(List<E> onscreen, boolean forcePreRender) { <line1> if (ourRendererUpdatesPaused) { <line2> return; <line3> } <line4> Collection<E> drawable = New.collection(onscreen.size()); <line5> Collection<E> pickable = New.collection(onscreen.size()); <line6> for (E geom : onscreen) { <line7> if (!(geom.getRenderProperties() instanceof BaseRenderProperties) <line8> || ((BaseRenderProperties) geom.getRenderProperties()).isDrawable()) { <line9> drawable.add(geom); <line10> } <line11> if (!(geom.getRenderProperties() instanceof BaseRenderProperties) <line12> || ((BaseRenderProperties) geom.getRenderProperties()).isPickable()) { <line13> pickable.add(geom); <line14> } <line15> } <line16> CollectionUtilities.trimToSize(drawable); <line17> CollectionUtilities.trimToSize(pickable); <line18> Lock readLock = myProjectionChangeLock.readLock(); <line19> readLock.lock(); <line20> try { <line21> Projection projection = getProjectionSnapshot(); <line22> if (isOnscreenDirty() <line23> || myProjectionDirty <line24> || forcePreRender <line25> || drawable.size() != myOnscreenDrawableGeometries.size() <line26> || pickable.size() != myOnscreenPickableGeometries.size() <line27> || !drawable.equals(myOnscreenDrawableGeometries) <line28> || !pickable.equals(myOnscreenPickableGeometries)) { <line29> if (!sensitiveToProjectionChanges() <line30> || myProjectionSyncManager.isProjectionCurrent(projection)) { <line31> myRenderer.preRender( <line32> onscreen, drawable, pickable, getPickManager(), getDataRetriever(), projection); <line33> myProjectionDirty = false; <line34> myOnscreenDrawableGeometries = drawable; <line35> myOnscreenPickableGeometries = pickable; <line36> } <line37> myOnscreenDirty = false; <line38> } <line39> } catch (RuntimeException e) { <line40> throw e; <line41> } finally { <line42> readLock.unlock(); <line43> } <line44> myRepaintListener.repaint(); <line45> myPickManagerGeometryRemover.gather(); <line46> } <line47> } <line48> 	<line40>
5650	"public class A { <line0> protected Response createJsonResponse(CellBaseDataResponse queryResponse) { <line1> try { <line2> String value = jsonObjectWriter.writeValueAsString(queryResponse); <line3> ResponseBuilder ok = Response.ok(value, MediaType.APPLICATION_JSON_TYPE.withCharset(""utf-8"")); <line4> return buildResponse(ok); <line5> } catch (JsonProcessingException e) { <line6> e.printStackTrace(); <line7> return createErrorResponse( <line8> """", ""Error parsing QueryResponse object:\n"" + Arrays.toString(e.getStackTrace())); <line9> } <line10> } <line11> } <line12> "	<line7>
5651	public class A { <line0> @Override <line1> public Answer execute( <line2> final OvsDestroyBridgeCommand command, <line3> final LibvirtComputingResource libvirtComputingResource) { <line4> final boolean result = libvirtComputingResource.destroyTunnelNetwork(command.getBridgeName()); <line5> if (!result) { <line6> } <line7> return new Answer(command, result, null); <line8> } <line9> } <line10> 	<line6>
5652	public class A { <line0> @Override <line1> public void destroyContainerSession( <line2> ContainerSessionID containerSessionID, PlanSessionID sessionID) throws RemoteException { <line3> diskManagerInterface.destroyContainerSession(containerSessionID, sessionID); <line4> } <line5> } <line6> 	<line3>
5653	public class A { <line0> public void shutdown() { <line1> try { <line2> shutdownInternal(); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	<line4>
5654	public class A { <line0> protected void joinThreadFrom(Set<DynamicThread> threadSet) { <line1> DynamicThread[] threads = threadSet.toArray(new DynamicThread[0]); <line2> if (threads.length > 0 && threads[0] != null) { <line3> DynamicThread thread = threads[0]; <line4> if (thread.getOSThread() != null) { <line5> try { <line6> thread.getOSThread().join(WAIT_TO_DIE); <line7> } catch (InterruptedException e) { <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	<line4>, <line8>, <line10>
5655	public class A { <line0> @Override <line1> public void run() { <line2> while (running) { <line3> try { <line4> if (connection == null) { <line5> connection = serverSocket.accept(); <line6> inStream = new DataInputViewStreamWrapper(this.connection.getInputStream()); <line7> outStream = new DataOutputViewStreamWrapper(this.connection.getOutputStream()); <line8> } <line9> CollectCoordinationRequest request = new CollectCoordinationRequest(inStream); <line10> String requestVersion = request.getVersion(); <line11> long requestOffset = request.getOffset(); <line12> if (LOG.isDebugEnabled()) { <line13> } <line14> if (!version.equals(requestVersion) || requestOffset < offset) { <line15> sendBackResults(Collections.emptyList()); <line16> continue; <line17> } <line18> List<byte[]> nextBatch = new ArrayList<>(); <line19> bufferLock.lock(); <line20> try { <line21> int ackedNum = (int) (requestOffset - offset); <line22> for (int i = 0; i < ackedNum && !buffer.isEmpty(); i++) { <line23> byte[] removed = buffer.removeFirst(); <line24> currentBufferBytes -= removed.length; <line25> offset++; <line26> } <line27> long totalBytes = 0; <line28> for (byte[] value : buffer) { <line29> if (totalBytes + value.length <= maxBytesPerBatch) { <line30> nextBatch.add(value); <line31> totalBytes += value.length; <line32> } else { <line33> break; <line34> } <line35> } <line36> if (currentBufferBytes + invokingRecordBytes <= bufferSizeLimitBytes) { <line37> bufferCanAddNextResultCondition.signal(); <line38> } <line39> } finally { <line40> bufferLock.unlock(); <line41> } <line42> sendBackResults(nextBatch); <line43> } catch (Exception e) { <line44> if (LOG.isDebugEnabled()) { <line45> } <line46> closeCurrentConnection(); <line47> } <line48> } <line49> } <line50> } <line51> 	<line8>, <line13>, <line15>, <line45>
5656	"public class A { <line0> @Override <line1> protected void initPostprocessor(String instance, YConfiguration config) { <line2> Map<String, Object> m = null; <line3> if (config == null) { <line4> m = new HashMap<>(); <line5> config = YConfiguration.wrap(m); <line6> } else if (!config.containsKey(""commandPostprocessorClassName"")) { <line7> m = config.getRoot(); <line8> } <line9> if (m != null) { <line10> m.put(""commandPostprocessorClassName"", IssCommandPostprocessor.class.getName()); <line11> } <line12> super.initPostprocessor(instance, config); <line13> } <line14> } <line15> "	<line10>
5657	public class A { <line0> void abortMultipartUpload(String uploadId) throws AmazonClientException { <line1> mClient.abortMultipartUpload(new AbortMultipartUploadRequest(mBucket, key, uploadId)); <line2> } <line3> } <line4> 	<line1>
5658	public class A { <line0> @Override <line1> public byte[] getRequestDataAsArrayOfBytes() { <line2> Packet request = new Packet(new byte[66]); <line3> reqSessionID = (reqSessionID + 1) & 0xffff; <line4> request.setTwoByteValue(0, reqSessionID); <line5> request.setOneByteValue(2, reqCommandOriginator); <line6> request.setOneByteValue(3, reqPriorityLevel); <line7> request.setOneByteValue(4, reqParameterActive); <line8> request.setOneByteValue(5, reqFPI1); <line9> request.setOneByteValue(6, reqFPI2); <line10> request.setTwoByteValue(7, reqMainParameter); <line11> request.setOneByteValue(41, reqIndexArrayCount); <line12> request.setOneByteValue(42, reqIndexArray01); <line13> request.setOneByteValue(62, reqPriorityLevelLock); <line14> request.setOneByteValue(63, reqPL03); <line15> request.setOneByteValue(64, reqPL47); <line16> request.setOneByteValue(65, reqLockTime); <line17> requestData = request.toByteArray(); <line18> return requestData; <line19> } <line20> } <line21> 	<line17>, <line18>
5659	public class A { <line0> private static List<RootCauseEntityFormatter> makeRootCauseFormatters( <line1> RootCauseConfiguration config) throws Exception { <line2> List<RootCauseEntityFormatter> formatters = new ArrayList<>(); <line3> if (config.getFormatters() != null) { <line4> for (String className : config.getFormatters()) { <line5> try { <line6> formatters.add(FormatterLoader.fromClassName(className)); <line7> } catch (ClassNotFoundException e) { <line8> } <line9> } <line10> } <line11> formatters.add(new DefaultEntityFormatter()); <line12> return formatters; <line13> } <line14> } <line15> 	<line8>
5660	public class A { <line0> public void init() { <line1> ConfigDirectory.init(); <line2> SpringHelper.setApplicationContext(applicationContext); <line3> WSEngine.setWorkerFactory( <line4> new WorkerFactory() { <line5> @Override <line6> public Worker build(Class<? extends Worker> workerClass, String identifier) { <line7> String[] beanNames = applicationContext.getBeanNamesForType(workerClass); <line8> if (beanNames == null || beanNames.length == 0) { <line9> return (Worker) ReflectionUtilities.newInstance(workerClass, identifier); <line10> } <line11> if (beanNames.length > 1) { <line12> } <line13> return (Worker) applicationContext.getBean(beanNames[0], identifier); <line14> } <line15> }); <line16> ServiceConfigurer.setApplicationContext(applicationContext); <line17> } <line18> } <line19> 	<line9>, <line12>
5661	"public class A { <line0> @SuppressWarnings({""checkstyle:IllegalThrows"", ""checkstyle:avoidHidingCauseException""}) <line1> @Test(expected = RuntimeException.class) <line2> public void testCreateInterrupted() throws Throwable { <line3> final Future<?> testFuture = <line4> Executors.newSingleThreadExecutor() <line5> .submit( <line6> () -> { <line7> final ListenableFuture<DOMRpcResult> interruptedFuture = <line8> mock(ListenableFuture.class); <line9> try { <line10> when(interruptedFuture.get()) <line11> .thenThrow(new InterruptedException(""interrupted"")); <line12> doReturn(FluentFuture.from(interruptedFuture)) <line13> .when(rpc) <line14> .invokeRpc(eq(NETCONF_GET_QNAME), any()); <line15> NetconfStateSchemas.create(rpc, CAPS, deviceId, schemaContext); <line16> } catch (final InterruptedException | ExecutionException e) { <line17> } <line18> }); <line19> try { <line20> testFuture.get(3, TimeUnit.SECONDS); <line21> } catch (final ExecutionException e) { <line22> throw e.getCause(); <line23> } <line24> } <line25> } <line26> "	<line17>
5662	public class A { <line0> LinkedHashMap<PeerStatus, Double> buildWeightedPeerMap( <line1> final Set<PeerStatus> statuses, final TransferDirection direction) { <line2> final Map<PeerStatus, Double> peerWorkloads = createDestinationMap(statuses, direction); <line3> if (!peerWorkloads.isEmpty()) { <line4> LinkedHashMap<PeerStatus, Double> sortedPeerWorkloads = sortMapByWeight(peerWorkloads); <line5> printDistributionStatistics(sortedPeerWorkloads, direction); <line6> return sortedPeerWorkloads; <line7> } else { <line8> return new LinkedHashMap<>(); <line9> } <line10> } <line11> } <line12> 	<line8>
5663	public class A { <line0> public void attachDirty(MsRaBehand instance) { <line1> try { <line2> sessionFactory.getCurrentSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
5664	public class A { <line0> @Override <line1> public Serializable onBeforeSave(final Session session, final Object obj) { <line2> if (obj instanceof PFUserDO) { <line3> final PFUserDO user = (PFUserDO) obj; <line4> return save(user, user.getRights()); <line5> } else if (obj instanceof AbstractRechnungDO) { <line6> final AbstractRechnungDO rechnung = (AbstractRechnungDO) obj; <line7> final List<? extends AbstractRechnungsPositionDO> positions = <line8> rechnung.getAbstractPositionen(); <line9> final KontoDO konto = rechnung.getKonto(); <line10> if (konto != null) { <line11> save(konto); <line12> rechnung.setKonto(null); <line13> } <line14> if (rechnung instanceof RechnungDO) { <line15> ((RechnungDO) rechnung).setPositionen(null); <line16> } else { <line17> ((EingangsrechnungDO) rechnung).setPositionen(null); <line18> } <line19> final Serializable id = save(rechnung); <line20> if (konto != null) { <line21> rechnung.setKonto(konto); <line22> } <line23> if (positions != null) { <line24> for (final AbstractRechnungsPositionDO pos : positions) { <line25> if (pos.getKostZuweisungen() != null) { <line26> final List<KostZuweisungDO> zuweisungen = pos.getKostZuweisungen(); <line27> pos.setKostZuweisungen(null); <line28> save(pos); <line29> rechnung.addPosition(pos); <line30> if (zuweisungen != null) { <line31> for (final KostZuweisungDO zuweisung : zuweisungen) { <line32> pos.addKostZuweisung(zuweisung); <line33> save(zuweisung); <line34> } <line35> } <line36> } <line37> } <line38> } <line39> return id; <line40> } else if (obj instanceof AuftragDO) { <line41> final AuftragDO auftrag = (AuftragDO) obj; <line42> return save(auftrag, auftrag.getPositionenIncludingDeleted()); <line43> } <line44> if (plugins != null) { <line45> for (final AbstractPlugin plugin : plugins) { <line46> try { <line47> plugin.onBeforeRestore(this, obj); <line48> } catch (final Exception ex) { <line49> } <line50> } <line51> } <line52> for (final XmlDumpHook xmlDumpHook : xmlDumpHooks) { <line53> try { <line54> xmlDumpHook.onBeforeRestore(userXmlPreferencesDao, this, obj); <line55> } catch (final Exception ex) { <line56> } <line57> } <line58> return super.onBeforeSave(session, obj); <line59> } <line60> } <line61> 	<line2>, <line49>, <line56>
5665	public class A { <line0> private void initStack() { <line1> if (log.isInfoEnabled()) { <line2> } <line3> InputStream is = null; <line4> try { <line5> dictionary.parseDictionary( <line6> this.getClass().getClassLoader().getResourceAsStream(dictionaryFile)); <line7> this.stack = new StackImpl(); <line8> is = this.getClass().getClassLoader().getResourceAsStream(configFile); <line9> Configuration config = new XMLConfiguration(is); <line10> factory = stack.init(config); <line11> if (log.isInfoEnabled()) { <line12> } <line13> Set<org.jdiameter.api.ApplicationId> appIds = <line14> stack.getMetaData().getLocalPeer().getCommonApplications(); <line15> for (org.jdiameter.api.ApplicationId x : appIds) { <line16> } <line17> is.close(); <line18> Network network = stack.unwrap(Network.class); <line19> network.addNetworkReqListener( <line20> new NetworkReqListener() { <line21> @Override <line22> public Answer processRequest(Request request) { <line23> return null; <line24> } <line25> }, <line26> this.authAppId); <line27> } catch (Exception e) { <line28> e.printStackTrace(); <line29> if (this.stack != null) { <line30> this.stack.destroy(); <line31> } <line32> if (is != null) { <line33> try { <line34> is.close(); <line35> } catch (IOException e1) { <line36> e1.printStackTrace(); <line37> } <line38> } <line39> return; <line40> } <line41> MetaData metaData = stack.getMetaData(); <line42> if (metaData.getStackType() != StackType.TYPE_SERVER || metaData.getMinorVersion() <= 0) { <line43> stack.destroy(); <line44> if (log.isEnabledFor(org.apache.log4j.Level.ERROR)) { <line45> } <line46> return; <line47> } <line48> try { <line49> if (log.isInfoEnabled()) { <line50> } <line51> stack.start(); <line52> if (log.isInfoEnabled()) { <line53> } <line54> } catch (Exception e) { <line55> e.printStackTrace(); <line56> stack.destroy(); <line57> return; <line58> } <line59> if (log.isInfoEnabled()) { <line60> } <line61> } <line62> } <line63> 	<line2>, <line7>, <line12>, <line15>, <line16>, <line45>, <line50>, <line53>, <line60>
5666	public class A { <line0> @Override <line1> @Transactional <line2> public void run() { <line3> try { <line4> runInternal(); <line5> } catch (Exception ex) { <line6> throw ex; <line7> } <line8> } <line9> } <line10> 	<line6>
5667	"public class A { <line0> public void run() throws PerfCakeException { <line1> if (log.isTraceEnabled()) { <line2> } <line3> if (receiver != null) { <line4> if (correlator == null) { <line5> throw new PerfCakeException(""A correlator must be set in order to use a receiver.""); <line6> } <line7> receiver.setCorrelator(correlator); <line8> receiver.start(); <line9> } <line10> if (validationManager.isEnabled()) { <line11> validationManager.startValidation(); <line12> } <line13> try { <line14> generator.generate(); <line15> } catch (final Exception e) { <line16> throw new PerfCakeException(""Error generating messages: "", e); <line17> } <line18> } <line19> } <line20> "	<line2>
5668	public class A { <line0> @Override <line1> public boolean toggleBrokenOnlyMode() { <line2> brokenOnlyMode = !brokenOnlyMode; <line3> if (brokenOnlyMode) { <line4> } else { <line5> } <line6> for (TestListener i : testListeners) { <line7> i.setBrokenOnly(brokenOnlyMode); <line8> } <line9> return brokenOnlyMode; <line10> } <line11> } <line12> 	<line4>, <line5>
5669	"public class A { <line0> @Test <line1> public void incorrectExecuteQueryStatement() { <line2> SessionPool pool = new SessionPool(""127.0.0.1"", 6667, ""root"", ""root"", 3); <line3> ExecutorService service = Executors.newFixedThreadPool(10); <line4> write10Data(pool, true); <line5> for (int i = 0; i < 10; i++) { <line6> final int no = i; <line7> service.submit( <line8> () -> { <line9> try { <line10> SessionDataSetWrapper wrapper = <line11> pool.executeQueryStatement(""select * from root.sg1.d1 where time = "" + no); <line12> } catch (IoTDBConnectionException | StatementExecutionException e) { <line13> fail(e.getMessage()); <line14> } <line15> }); <line16> } <line17> service.shutdown(); <line18> try { <line19> assertFalse(service.awaitTermination(3, TimeUnit.SECONDS)); <line20> assertEquals(0, pool.currentAvailableSize()); <line21> assertTrue(pool.currentOccupiedSize() <= 3); <line22> } catch (InterruptedException e) { <line23> fail(e.getMessage()); <line24> } finally { <line25> pool.close(); <line26> } <line27> } <line28> } <line29> "	<line23>
5670	public class A { <line0> @Override <line1> public void deleted(String pid) { <line2> ConfigurationHolder configurationHolder = _configurationHolderByPid.remove(pid); <line3> if (configurationHolder == null) { <line4> if (_log.isWarnEnabled()) { <line5> } <line6> return; <line7> } <line8> SamlProviderConfiguration samlProviderConfiguration = <line9> configurationHolder.getSamlProviderConfiguration(); <line10> _configurationHolderByCompanyId.remove(samlProviderConfiguration.companyId()); <line11> } <line12> } <line13> 	<line5>
5671	public class A { <line0> @Override <line1> public void close() { <line2> try { <line3> eventReader.close(); <line4> } catch (final Exception e2) { <line5> } <line6> IOUtils.closeQuietly(fileStream); <line7> } <line8> } <line9> 	<line5>
5672	public class A { <line0> public CubeInstance findLatestSnapshot( <line1> List<RealizationEntry> realizationEntries, <line2> String lookupTableName, <line3> CubeInstance cubeInstance) { <line4> CubeInstance cube = null; <line5> try { <line6> if (!realizationEntries.isEmpty()) { <line7> long maxBuildTime = Long.MIN_VALUE; <line8> RealizationRegistry registry = RealizationRegistry.getInstance(config); <line9> for (RealizationEntry entry : realizationEntries) { <line10> IRealization realization = <line11> registry.getRealization(entry.getType(), entry.getRealization()); <line12> if (realization != null && realization.isReady() && realization instanceof CubeInstance) { <line13> CubeInstance current = (CubeInstance) realization; <line14> if (current.getDescriptor().findDimensionByTable(lookupTableName) != null) { <line15> CubeSegment segment = current.getLatestReadySegment(); <line16> if (segment != null) { <line17> long latestBuildTime = segment.getLastBuildTime(); <line18> if (latestBuildTime > maxBuildTime) { <line19> maxBuildTime = latestBuildTime; <line20> cube = current; <line21> } <line22> } <line23> } <line24> } <line25> } <line26> } <line27> } catch (Exception e) { <line28> throw e; <line29> } <line30> if (!cubeInstance.equals(cube)) { <line31> } <line32> return cube == null ? cubeInstance : cube; <line33> } <line34> } <line35> 	<line28>, <line31>
5673	"public class A { <line0> @Test <line1> public void testComposition1() { <line2> final Jsons.Obj j = <line3> append( <line4> obj(p(""name"", ""Karl""), p(""city"", ""Paris""), p(""remove_me"", ZERO_VAL)), <line5> obj(p(""age"", 79))); <line6> final JsonPath p = JsonPath.from(toJson(j)); <line7> assertEquals(""Karl"", p.get(""name"")); <line8> assertEquals(""Paris"", p.get(""city"")); <line9> assertNull(p.get(""remove_me"")); <line10> assertEquals(new Integer(79), p.get(""age"")); <line11> } <line12> } <line13> "	<line7>
5674	public class A { <line0> @Override <line1> public void sessionClosed(final IoSession session) { <line2> } <line3> } <line4> 	<line2>
5675	public class A { <line0> private static int checkNoticeFile( <line1> Multimap<String, IncludedDependency> modulesWithShadedDependencies, Path noticeFile) <line2> throws IOException { <line3> int severeIssueCount = 0; <line4> String moduleName = getModuleFromNoticeFile(noticeFile); <line5> List<String> noticeContents = Files.readAllLines(noticeFile); <line6> if (noticeContents.isEmpty()) { <line7> severeIssueCount++; <line8> } <line9> if (!noticeContents.get(0).equals(moduleName)) { <line10> } <line11> Set<IncludedDependency> declaredDependencies = new HashSet<>(); <line12> for (String line : noticeContents) { <line13> Matcher noticeDependencyMatcher = NOTICE_DEPENDENCY_PATTERN.matcher(line); <line14> if (noticeDependencyMatcher.find()) { <line15> String groupId = noticeDependencyMatcher.group(1); <line16> String artifactId = noticeDependencyMatcher.group(2); <line17> String version = noticeDependencyMatcher.group(3); <line18> if (groupId == null && artifactId == null && version == null) { <line19> groupId = noticeDependencyMatcher.group(5); <line20> artifactId = noticeDependencyMatcher.group(6); <line21> version = noticeDependencyMatcher.group(7); <line22> } <line23> IncludedDependency toAdd = IncludedDependency.create(groupId, artifactId, version); <line24> if (!declaredDependencies.add(toAdd)) { <line25> severeIssueCount++; <line26> } <line27> } <line28> } <line29> Collection<IncludedDependency> expectedDependencies = <line30> modulesWithShadedDependencies.get(moduleName); <line31> for (IncludedDependency expectedDependency : expectedDependencies) { <line32> if (!declaredDependencies.contains(expectedDependency)) { <line33> severeIssueCount++; <line34> } <line35> } <line36> boolean moduleDefinesExcessDependencies = <line37> MODULES_DEFINING_EXCESS_DEPENDENCIES.contains(moduleName); <line38> for (IncludedDependency declaredDependency : declaredDependencies) { <line39> if (!expectedDependencies.contains(declaredDependency)) { <line40> if (moduleDefinesExcessDependencies) { <line41> } else { <line42> } <line43> } <line44> } <line45> return severeIssueCount; <line46> } <line47> } <line48> 	<line7>, <line10>, <line25>, <line33>, <line41>, <line42>
5676	"public class A { <line0> @Override <line1> public void contextDestroyed(ServletContextEvent servletContextEvent) { <line2> Repository jcrRepository = PentahoSystem.get(Repository.class, ""jcrRepository"", null); <line3> if (jcrRepository == null) { <line4> return; <line5> } <line6> if (!(jcrRepository instanceof JackrabbitRepository)) { <line7> return; <line8> } <line9> ((JackrabbitRepository) jcrRepository).shutdown(); <line10> } <line11> } <line12> "	<line4>, <line7>
5677	public class A { <line0> public void releaseForConnection() { <line1> } <line2> } <line3> 	<line1>
5678	"public class A { <line0> @Test <line1> public void write_COMSEG() throws IOException, FileNotFoundException { <line2> if (!isJp2KakDriverAvailable) return; <line3> final File inputFile = TestData.file(this, testFileName); <line4> Assert.assertTrue(inputFile.exists()); <line5> final File outputFile1 = TestData.temp(this, ""COMSEG-.jp2"", deleteTempFilesOnExit); <line6> final File outputFile2 = TestData.temp(this, ""NO-COMSEG-.jp2"", deleteTempFilesOnExit); <line7> final ParameterBlockJAI pbjImageRead = new ParameterBlockJAI(""ImageRead""); <line8> pbjImageRead.setParameter(""Input"", inputFile); <line9> if (ENABLE_SUBSAMPLING) { <line10> ImageReadParam readParam = new ImageReadParam(); <line11> readParam.setSourceSubsampling(4, 4, 0, 0); <line12> pbjImageRead.setParameter(""readParam"", readParam); <line13> } <line14> pbjImageRead.setParameter(""Reader"", new JP2GDALKakaduImageReaderSpi().createReaderInstance()); <line15> RenderedOp image = JAI.create(""ImageRead"", pbjImageRead); <line16> final ParameterBlockJAI pbjImageWrite = new ParameterBlockJAI(""ImageWrite""); <line17> pbjImageWrite.setParameter(""Output"", new FileImageOutputStreamExtImpl(outputFile1)); <line18> ImageWriter writer = new JP2GDALKakaduImageWriterSpi().createWriterInstance(); <line19> pbjImageWrite.setParameter(""Writer"", writer); <line20> pbjImageWrite.addSource(image); <line21> ImageWriteParam param = writer.getDefaultWriteParam(); <line22> ((JP2GDALKakaduImageWriteParam) param).setComseg(""YES""); <line23> pbjImageWrite.setParameter(""writeParam"", param); <line24> final RenderedOp op = JAI.create(""ImageWrite"", pbjImageWrite); <line25> final ParameterBlockJAI pbjImageWrite2 = new ParameterBlockJAI(""ImageWrite""); <line26> pbjImageWrite2.setParameter(""Output"", new FileImageOutputStreamExtImpl(outputFile2)); <line27> ImageWriter writer2 = new JP2GDALKakaduImageWriterSpi().createWriterInstance(); <line28> pbjImageWrite2.setParameter(""Writer"", writer2); <line29> pbjImageWrite2.addSource(image); <line30> ImageWriteParam param2 = writer2.getDefaultWriteParam(); <line31> ((JP2GDALKakaduImageWriteParam) param2).setComseg(""NO""); <line32> pbjImageWrite2.setParameter(""writeParam"", param2); <line33> final RenderedOp op2 = JAI.create(""ImageWrite"", pbjImageWrite2); <line34> } <line35> } <line36> "	<line3>
5679	public class A { <line0> public String getPrivateKey() { <line1> RSAPrivateKeyHolder keyHolder = keyProvider.getPrivateKey(); <line2> if (keyHolder == null) { <line3> return null; <line4> } <line5> try { <line6> return SshKeyGen.toPEM(keyProvider.getPrivateKey().getKey()); <line7> } catch (Exception e) { <line8> return null; <line9> } <line10> } <line11> } <line12> 	<line8>
5680	public class A { <line0> @Test <line1> public void get() { <line2> Module module = ESSuiteTest.moduleDao.get(ESSuiteTest.MODULE_ID_1); <line3> assertEquals(ESSuiteTest.MODULE_GROUPID, module.getGroupId()); <line4> } <line5> } <line6> 	<line2>, <line3>
5681	"public class A { <line0> private static void downloadAndUnzip() throws IOException { <line1> String dataPath = new File(dataDir).getAbsolutePath(); <line2> File zipFile = new File(dataPath, ""ridership.zip""); <line3> FileUtils.copyURLToFile(new URL(downloadLink), zipFile); <line4> if (!Helper.getCheckSum(zipFile.getAbsolutePath()) <line5> .equalsIgnoreCase(Helper.getPropValues(""dataset.ridership.demand.hash""))) { <line6> System.exit(0); <line7> } <line8> ArchiveUtils.unzipFileTo(zipFile.getAbsolutePath(), dataPath); <line9> } <line10> } <line11> "	<line3>, <line6>, <line8>
5682	public class A { <line0> @Override <line1> public void partyAction(Action action) { <line2> } <line3> } <line4> 	<line2>
5683	"public class A { <line0> public void throwDebugInfo() { <line1> if (debugBufferSize == 0) return; <line2> String prefix = MULTI_THREAD ? ""["" + currentThread().getId() + ""] "" : """"; <line3> } <line4> } <line5> "	<line3>
5684	public class A { <line0> public final Response putAttributeOfNode(final Map<String, String> attributes) { <line1> Response resp = new Response(Response.OK, null); <line2> if (attributes == null || attributes.size() == 0) { <line3> return resp; <line4> } <line5> try { <line6> Map<String, Node> nodes = this.getNodes(); <line7> if (nodes.size() == 0) { <line8> return resp; <line9> } <line10> for (String nodeId : nodes.keySet()) { <line11> Node node = nodes.get(nodeId); <line12> boolean update = false; <line13> for (String attrKey : attributes.keySet()) { <line14> if (!node.getAttributes().containsKey(attrKey) <line15> || node.getAttribute(attrKey).equals(attributes.get(attrKey))) { <line16> continue; <line17> } <line18> update = true; <line19> node.putAttribute(attrKey, attributes.get(attrKey)); <line20> } <line21> if (update) { <line22> this.putNode(node); <line23> } <line24> } <line25> } catch (Exception e) { <line26> return new Response(Response.INTERNAL_SERVER_ERROR, null); <line27> } <line28> return resp; <line29> } <line30> } <line31> 	<line1>, <line26>
5685	"public class A { <line0> private String toEndPoint(NodeSource nodeSource) { <line1> try { <line2> if (nodeSource.getRedirect() != null) { <line3> final URI uri = nodeSource.getAddr(); <line4> if (uri != null) { <line5> return HostAndPort.toHostAndPortString(uri.getHost(), uri.getPort()); <line6> } <line7> } else if (nodeSource.getRedisClient() != null) { <line8> final InetSocketAddress address = nodeSource.getRedisClient().getAddr(); <line9> return HostAndPort.toHostAndPortString(address.getHostString(), address.getPort()); <line10> } else { <line11> final MasterSlaveEntry entry = nodeSource.getEntry(); <line12> if (entry != null) { <line13> if (entry.getClient() != null) { <line14> final InetSocketAddress address = entry.getClient().getAddr(); <line15> return HostAndPort.toHostAndPortString(address.getHostString(), address.getPort()); <line16> } <line17> } else if (nodeSource.getSlot() != null) { <line18> return ""slot="" + nodeSource.getSlot(); <line19> } <line20> } <line21> } catch (Exception ignored) { <line22> if (isDebug) { <line23> } <line24> } <line25> return ""Unknown""; <line26> } <line27> } <line28> "	<line23>
5686	public class A { <line0> @Override <line1> public synchronized void shutdown() { <line2> try { <line3> if (open) { <line4> open = false; <line5> writer.close(); <line6> } <line7> } catch (IOException e) { <line8> } <line9> } <line10> } <line11> 	<line8>
5687	public class A { <line0> @Override <line1> public ReadingPublisher<Ec3kReading> createPublisher() { <line2> ReadingPublisher<Ec3kReading> publisher = <line3> new ReadingPublisher<Ec3kReading>() { <line4> @Override <line5> public void publish(Ec3kReading reading) { <line6> if (reading != null && getThing().getStatus() == ThingStatus.ONLINE) { <line7> BigDecimal currentWatt = <line8> new BigDecimal(reading.getCurrentWatt()).setScale(1, RoundingMode.HALF_UP); <line9> BigDecimal maxWatt = <line10> new BigDecimal(reading.getMaxWatt()).setScale(1, RoundingMode.HALF_UP); <line11> updateState(CURRENT_POWER_CHANNEL, new QuantityType<>(currentWatt, Units.WATT)); <line12> updateState(MAX_POWER_CHANNEL, new QuantityType<>(maxWatt, Units.WATT)); <line13> updateState( <line14> CONSUMPTION_CHANNEL, <line15> new QuantityType<>(reading.getConsumptionTotal(), Units.WATT_HOUR)); <line16> updateState( <line17> APPLIANCE_TIME_CHANNEL, <line18> new QuantityType<>(reading.getApplianceTime(), Units.HOUR)); <line19> updateState( <line20> SENSOR_TIME_CHANNEL, new QuantityType<>(reading.getSensorTime(), Units.HOUR)); <line21> updateState(RESETS_CHANNEL, new DecimalType(reading.getResets())); <line22> } <line23> } <line24>  <line25> @Override <line26> public void dispose() {} <line27> }; <line28> BufferedSensorConfig cfg = getConfigAs(BufferedSensorConfig.class); <line29> if (cfg.bufferSize > 1 && cfg.updateInterval > 0) { <line30> publisher = <line31> new RollingAveragePublisher<Ec3kReading>( <line32> cfg.bufferSize, cfg.updateInterval, publisher, scheduler) { <line33> @Override <line34> public RollingReadingAverage<Ec3kReading> createRollingReadingAverage(int bufferSize) { <line35> return new Ec3kRollingReadingAverage(bufferSize); <line36> } <line37> }; <line38> } <line39> return publisher; <line40> } <line41> } <line42> 	<line11>
5688	public class A { <line0> @PostConstruct <line1> public void configure() { <line2> if (EJB_METHOD.equals(START_METHOD)) { <line3> if (!startableBeans.isUnsatisfied()) { <line4> for (Startable startableBean : startableBeans) { <line5> startableBean.start(); <line6> } <line7> } <line8> } <line9> } <line10> } <line11> 	<line3>, <line8>
5689	public class A { <line0> public void pkgList() { <line1> pkgList(getPkgList()); <line2> } <line3> } <line4> 	<line1>
5690	"public class A { <line0> @Override <line1> public RequestCtx handleRequest(HttpServletRequest request, HttpServletResponse response) <line2> throws IOException, ServletException { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> String asOfDateTime = request.getParameter(""asOfDateTime""); <line6> if (!isDate(asOfDateTime)) { <line7> asOfDateTime = null; <line8> } <line9> RequestCtx req = null; <line10> Map<URI, AttributeValue> actions = new HashMap<URI, AttributeValue>(); <line11> Map<URI, AttributeValue> resAttr; <line12> try { <line13> String[] parts = getPathParts(request); <line14> resAttr = ResourceAttributes.getResources(parts); <line15> if (asOfDateTime != null && !asOfDateTime.isEmpty()) { <line16> resAttr.put( <line17> Constants.DATASTREAM.AS_OF_DATETIME.getURI(), <line18> DateTimeAttribute.getInstance(asOfDateTime)); <line19> } <line20> actions.put( <line21> Constants.ACTION.ID.getURI(), Constants.ACTION.GET_OBJECT_PROFILE.getStringAttribute()); <line22> actions.put(Constants.ACTION.API.getURI(), Constants.ACTION.APIA.getStringAttribute()); <line23> req = <line24> getContextHandler() <line25> .buildRequest(getSubjects(request), actions, resAttr, getEnvironment(request)); <line26> String pid = resAttr.get(Constants.OBJECT.PID.getURI()).toString(); <line27> LogUtil.statLog(request.getRemoteUser(), Constants.ACTION.GET_OBJECT_PROFILE.uri, pid, null); <line28> } catch (Exception e) { <line29> throw new ServletException(e.getMessage(), e); <line30> } <line31> return req; <line32> } <line33> } <line34> "	<line4>, <line29>
5691	public class A { <line0> protected void startNewExperiment() throws OpenbciCommunicationException { <line1> StartEEGSignalRequest request = new StartEEGSignalRequest(experimentDescriptor); <line2> ObciPullSocket pullSocket = new ObciPullSocket(EXPERIMENT_START_TIMEOUT_MILIS); <line3> request.setClientPushAddress(pullSocket.getAddressLocal()); <line4> Helper.sendRequestAndParseResponse( <line5> request, <line6> Helper.getOpenBCIIpAddress(), <line7> Helper.getOpenbciPort(), <line8> MessageType.REQUEST_OK_RESPONSE); <line9> StartEEGSignalResponse response = <line10> (StartEEGSignalResponse) <line11> pullSocket.getAndParsePushPullResponse(MessageType.START_EEG_SIGNAL_RESPONSE); <line12> pullSocket.close(); <line13> String exp_id = response.getSender(); <line14> experimentDescriptor.setId(exp_id); <line15> getExperimentContact(); <line16> } <line17> } <line18> 	<line14>
5692	public class A { <line0> @Override <line1> public ListExchangesResponseMessageType listExchanges(ListExchangesRequestMessageType request) { <line2> ListExchangesResponseMessageType response = new ListExchangesResponseMessageType(); <line3> response <line4> .getExchangesList() <line5> .addAll(copyExchangeTypeList(getExchangeManager().getAllExchanges())); <line6> return response; <line7> } <line8> } <line9> 	<line2>
5693	"public class A { <line0> @Override <line1> public List<AtlasVertex> execute() { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> List<AtlasVertex> ret = new ArrayList<>(); <line5> AtlasPerfTracer perf = null; <line6> if (AtlasPerfTracer.isPerfTraceEnabled(PERF_LOG)) { <line7> perf = <line8> AtlasPerfTracer.getPerfTracer( <line9> PERF_LOG, ""FullTextSearchProcessor.execute("" + context + "")""); <line10> } <line11> try { <line12> final int limit = context.getSearchParameters().getLimit(); <line13> final boolean activeOnly = context.getSearchParameters().getExcludeDeletedEntities(); <line14> final Integer marker = context.getMarker(); <line15> final int startIdx = marker != null ? marker : context.getSearchParameters().getOffset(); <line16> int qryOffset = marker != null ? marker : 0; <line17> int resultIdx = qryOffset; <line18> LinkedHashMap<Integer, AtlasVertex> offsetEntityVertexMap = new LinkedHashMap<>(); <line19> for (; ret.size() < limit; qryOffset += limit) { <line20> offsetEntityVertexMap.clear(); <line21> if (context.terminateSearch()) { <line22> break; <line23> } <line24> Iterator<AtlasIndexQuery.Result> idxQueryResult = indexQuery.vertices(qryOffset, limit); <line25> final boolean isLastResultPage; <line26> int resultCount = 0; <line27> while (idxQueryResult.hasNext()) { <line28> AtlasVertex vertex = idxQueryResult.next().getVertex(); <line29> resultCount++; <line30> if (!AtlasGraphUtilsV2.isEntityVertex(vertex)) { <line31> if (LOG.isDebugEnabled()) { <line32> } <line33> continue; <line34> } <line35> if (activeOnly && AtlasGraphUtilsV2.getState(vertex) != AtlasEntity.Status.ACTIVE) { <line36> continue; <line37> } <line38> offsetEntityVertexMap.put((qryOffset + resultCount) - 1, vertex); <line39> } <line40> isLastResultPage = resultCount < limit; <line41> offsetEntityVertexMap = super.filter(offsetEntityVertexMap); <line42> resultIdx = <line43> collectResultVertices(ret, startIdx, limit, resultIdx, offsetEntityVertexMap, marker); <line44> if (isLastResultPage) { <line45> resultIdx = SearchContext.MarkerUtil.MARKER_END - 1; <line46> break; <line47> } <line48> } <line49> if (marker != null) { <line50> nextOffset = resultIdx + 1; <line51> } <line52> } finally { <line53> AtlasPerfTracer.log(perf); <line54> } <line55> if (LOG.isDebugEnabled()) { <line56> } <line57> return ret; <line58> } <line59> } <line60> "	<line3>, <line22>, <line32>, <line56>
5694	public class A { <line0> public static int getCPMeasurementUnitsCount(long companyId) throws RemoteException { <line1> try { <line2> int returnValue = CPMeasurementUnitServiceUtil.getCPMeasurementUnitsCount(companyId); <line3> return returnValue; <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>
5695	public class A { <line0> private void logDeletedHost() { <line1> } <line2> } <line3> 	<line1>
5696	public class A { <line0> private void increaseShiroGlobalSessionTimeout(final DefaultSecurityManager shiroManager) { <line1> SessionManager sessionManager = shiroManager.getSessionManager(); <line2> if (DefaultSessionManager.class.isInstance(sessionManager)) { <line3> DefaultSessionManager defaultSessionManager = (DefaultSessionManager) sessionManager; <line4> defaultSessionManager.setGlobalSessionTimeout(Long.MAX_VALUE); <line5> long value = defaultSessionManager.getGlobalSessionTimeout(); <line6> if (value != Long.MAX_VALUE) { <line7> } <line8> } else { <line9> } <line10> } <line11> } <line12> 	<line7>, <line9>
5697	public class A { <line0> @Override <line1> public void install(File artifact) throws Exception { <line2> InputStream is = new FileInputStream(artifact); <line3> String template = IOUtils.toString(is); <line4> templates.put(artifact.getName(), template); <line5> } <line6> } <line7> 	<line5>
5698	"public class A { <line0> @Test <line1> void parse() throws Exception { <line2> JavaClassSource clazz = <line3> (JavaClassSource) <line4> Roaster.parse( <line5> new File( <line6> ""src/test/java/org/apache/camel/parser/java/MyFieldMethodCallRouteBuilder.java"")); <line7> MethodSource<JavaClassSource> method = clazz.getMethod(""configure""); <line8> List<ParserResult> list = CamelJavaParserHelper.parseCamelConsumerUris(method, true, true); <line9> for (ParserResult result : list) { <line10> } <line11> assertEquals(""netty-http:http://0.0.0.0:{{port}}/foo"", list.get(0).getElement()); <line12> assertEquals(""netty-http:http://0.0.0.0:{{getNextPort}}/bar"", list.get(1).getElement()); <line13> list = CamelJavaParserHelper.parseCamelProducerUris(method, true, true); <line14> for (ParserResult result : list) { <line15> } <line16> assertEquals(""mock:input1"", list.get(0).getElement()); <line17> assertEquals(""netty-http:http://0.0.0.0:{{getNextPort}}/bar"", list.get(1).getElement()); <line18> assertEquals(""mock:input2"", list.get(2).getElement()); <line19> } <line20> } <line21> "	<line10>, <line15>
5699	public class A { <line0> private void responseOK(DatagramSocket socket, T remoteHostAddress) { <line1> try { <line2> byte[] okBytes = NetworkAvailabilityCheckPacket.DATA_OK; <line3> DatagramPacket pongPacket = new DatagramPacket(okBytes, okBytes.length, remoteHostAddress); <line4> socket.send(pongPacket); <line5> } catch (IOException e) { <line6> if (logger.isWarnEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
5700	public class A { <line0> @Override <line1> public Object invoke(Method method, Object[] args) throws Exception { <line2> Method member = methodsMap.get(method); <line3> if (member == null) { <line4> return method.invoke(serviceClassInstance, args); <line5> } <line6> IRulesRuntimeContext context = (IRulesRuntimeContext) args[0]; <line7> Object[] methodArgs = ArrayUtils.remove(args, 0); <line8> applyRulesRuntimeContext(serviceClassInstance, context); <line9> return member.invoke(serviceClassInstance, methodArgs); <line10> } <line11> } <line12> 	<line4>, <line6>
5701	"public class A { <line0> @Execute <line1> public JsonResponse<ApiResult> post$doc(final EditBody body) { <line2> validateApi(body, messages -> {}); <line3> if (body.doc == null) { <line4> throwValidationErrorApi( <line5> messages -> messages.addErrorsCrudFailedToCreateCrudTable(GLOBAL, ""doc is required"")); <line6> } <line7> validateFields(body, this::throwValidationErrorApi); <line8> body.crudMode = CrudMode.EDIT; <line9> final Map<String, Object> doc = <line10> getDoc(body) <line11> .map( <line12> entity -> { <line13> final String index = fessConfig.getIndexDocumentUpdateIndex(); <line14> try { <line15> entity.putAll(fessConfig.convertToStorableDoc(body.doc)); <line16> final String newId = ComponentUtil.getCrawlingInfoHelper().generateId(entity); <line17> final String oldId = (String) entity.get(fessConfig.getIndexFieldId()); <line18> if (!newId.equals(oldId)) { <line19> entity.put(fessConfig.getIndexFieldId(), newId); <line20> entity.remove(fessConfig.getIndexFieldVersion()); <line21> final Number seqNo = (Number) entity.remove(fessConfig.getIndexFieldSeqNo()); <line22> final Number primaryTerm = <line23> (Number) entity.remove(fessConfig.getIndexFieldPrimaryTerm()); <line24> if (seqNo != null && primaryTerm != null && oldId != null) { <line25> searchEngineClient.delete(index, oldId, seqNo, primaryTerm); <line26> } <line27> } <line28> searchEngineClient.store(index, entity); <line29> saveInfo(messages -> messages.addSuccessCrudUpdateCrudTable(GLOBAL)); <line30> } catch (final Exception e) { <line31> throwValidationErrorApi( <line32> messages -> <line33> messages.addErrorsCrudFailedToUpdateCrudTable( <line34> GLOBAL, buildThrowableMessage(e))); <line35> } <line36> return entity; <line37> }) <line38> .orElseGet( <line39> () -> { <line40> throwValidationErrorApi( <line41> messages -> <line42> messages.addErrorsCrudCouldNotFindCrudTable(GLOBAL, body.doc.toString())); <line43> return null; <line44> }); <line45> return asJson( <line46> new ApiUpdateResponse() <line47> .id(doc.get(fessConfig.getIndexFieldDocId()).toString()) <line48> .created(false) <line49> .status(Status.OK) <line50> .result()); <line51> } <line52> } <line53> "	<line31>
5702	public class A { <line0> @Override <line1> public PatchStatus applyPatch(TypeDefPatch patch) throws AtlasBaseException { <line2> String typeName = patch.getTypeName(); <line3> AtlasBaseTypeDef typeDef = typeRegistry.getTypeDefByName(typeName); <line4> PatchStatus ret; <line5> if (typeDef == null) { <line6> throw new AtlasBaseException( <line7> AtlasErrorCode.PATCH_FOR_UNKNOWN_TYPE, patch.getAction(), typeName); <line8> } <line9> if (isPatchApplicable(patch, typeDef)) { <line10> if (typeDef.getClass().equals(AtlasEntityDef.class)) { <line11> AtlasEntityDef updatedDef = new AtlasEntityDef((AtlasEntityDef) typeDef); <line12> for (AtlasAttributeDef attributeDef : patch.getAttributeDefs()) { <line13> updatedDef.addAttribute(attributeDef); <line14> } <line15> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line16> typeDefStore.updateEntityDefByName(typeName, updatedDef); <line17> ret = APPLIED; <line18> } else if (typeDef.getClass().equals(AtlasClassificationDef.class)) { <line19> AtlasClassificationDef updatedDef = <line20> new AtlasClassificationDef((AtlasClassificationDef) typeDef); <line21> for (AtlasAttributeDef attributeDef : patch.getAttributeDefs()) { <line22> updatedDef.addAttribute(attributeDef); <line23> } <line24> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line25> typeDefStore.updateClassificationDefByName(typeName, updatedDef); <line26> ret = APPLIED; <line27> } else if (typeDef.getClass().equals(AtlasStructDef.class)) { <line28> AtlasStructDef updatedDef = new AtlasStructDef((AtlasStructDef) typeDef); <line29> for (AtlasAttributeDef attributeDef : patch.getAttributeDefs()) { <line30> updatedDef.addAttribute(attributeDef); <line31> } <line32> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line33> typeDefStore.updateStructDefByName(typeName, updatedDef); <line34> ret = APPLIED; <line35> } else { <line36> throw new AtlasBaseException( <line37> AtlasErrorCode.PATCH_NOT_APPLICABLE_FOR_TYPE, <line38> patch.getAction(), <line39> typeDef.getClass().getSimpleName()); <line40> } <line41> } else { <line42> ret = SKIPPED; <line43> } <line44> return ret; <line45> } <line46> } <line47> 	<line42>
5703	public class A { <line0> @Override <line1> public void execute(ImmutableMultimap<String, String> arg0, PrintWriter arg1) throws Exception { <line2> try { <line3> List<CollectionReferenceDescription> discoveredCollections = <line4> collectionReferenceService.getAllIndicesAsCollections(); <line5> List<CollectionReferenceDescription> existingCollections; <line6> try { <line7> existingCollections = <line8> collectionReferenceService.describeAllCollections( <line9> collectionReferenceService.getAllCollectionReferences(Optional.empty()), <line10> Optional.empty()); <line11> } catch (Exception e) { <line12> existingCollections = new ArrayList<>(); <line13> } <line14> for (CollectionReferenceDescription collection : discoveredCollections) { <line15> if (!existingCollections.contains(collection)) { <line16> CollectionReferenceDescription collectionToAdd = checkCollectionValidity(collection); <line17> if (collectionToAdd != null) { <line18> collectionReferenceService.putCollectionReference(collectionToAdd); <line19> } <line20> } <line21> } <line22> } catch (ArlasConfigurationException e) { <line23> } <line24> } <line25> } <line26> 	<line23>
5704	"public class A { <line0> @Override <line1> public void initialize(InitializeParams params, ServerCapabilities cap) { <line2> this.hasDynamicCompletionRegistration = <line3> SimpleLanguageServer.safeGet( <line4> false, <line5> () -> <line6> params <line7> .getCapabilities() <line8> .getTextDocument() <line9> .getCompletion() <line10> .getDynamicRegistration()); <line11> List<String> allTiggerChars = getMergedTriggerCharacters(); <line12> if (!hasDynamicCompletionRegistration || allTiggerChars == null) { <line13> CompletionOptions completionProvider = new CompletionOptions(); <line14> completionProvider.setResolveProvider(server.hasLazyCompletionResolver()); <line15> completionProvider.setTriggerCharacters(getMergedTriggerCharacters()); <line16> cap.setCompletionProvider(completionProvider); <line17> } else { <line18> server <line19> .onInitialized( <line20> Mono.fromCallable( <line21> () -> { <line22> List<Registration> registrations = new ArrayList<>(); <line23> for (Entry<String, String> entry : <line24> props.getCompletionTriggerCharacters().entrySet()) { <line25> String languageId = entry.getKey(); <line26> String triggerCharsString = entry.getValue(); <line27> Registration r = <line28> new Registration(UUID.randomUUID().toString(), ""textDocument/completion""); <line29> CompletionRegistrationOptions registerOptions = <line30> new CompletionRegistrationOptions(); <line31> registerOptions.setResolveProvider(server.hasLazyCompletionResolver()); <line32> registerOptions.setTriggerCharacters(toTriggerChars(triggerCharsString)); <line33> DocumentFilter df = new DocumentFilter(); <line34> df.setLanguage(languageId); <line35> registerOptions.setDocumentSelector(ImmutableList.of(df)); <line36> r.setRegisterOptions(registerOptions); <line37> registrations.add(r); <line38> } <line39> RegistrationParams regParams = new RegistrationParams(registrations); <line40> return Mono.fromFuture(server.getClient().registerCapability(regParams)); <line41> })) <line42> .toFuture(); <line43> } <line44> } <line45> } <line46> "	<line11>, <line17>, <line40>
5705	public class A { <line0> private void basicProcess(final DistributionManager dm) { <line1> boolean replied = false; <line2> try { <line3> DLockService svc = DLockService.getInternalServiceNamed(this.serviceName); <line4> if (svc != null && svc.isCurrentlyOrIsMakingLockGrantor()) { <line5> DLockGrantor grantor = DLockGrantor.waitForGrantor(svc); <line6> if (grantor != null) { <line7> grantor.handleDepartureOf(getSender()); <line8> if (!grantor.isDestroyed()) { <line9> reply(NonGrantorDestroyedReplyMessage.OK, dm); <line10> replied = true; <line11> } <line12> } <line13> } <line14> } catch (InterruptedException e) { <line15> Thread.currentThread().interrupt(); <line16> if (logger.isTraceEnabled(LogMarker.DLS_VERBOSE)) { <line17> } <line18> } catch (LockServiceDestroyedException e) { <line19> if (logger.isTraceEnabled(LogMarker.DLS_VERBOSE)) { <line20> } <line21> } catch (LockGrantorDestroyedException e) { <line22> if (logger.isTraceEnabled(LogMarker.DLS_VERBOSE)) { <line23> } <line24> } finally { <line25> if (!replied) { <line26> reply(NonGrantorDestroyedReplyMessage.NOT_GRANTOR, dm); <line27> } <line28> } <line29> } <line30> } <line31> 	<line17>, <line20>, <line23>
5706	"public class A { <line0> private static List<SourceCheck> _getSourceChecks( <line1> SourceFormatterConfiguration sourceFormatterConfiguration, <line2> String sourceProcessorName, <line3> Map<String, Properties> propertiesMap, <line4> List<String> filterCheckNames, <line5> List<String> filterCheckCategoryNames, <line6> List<String> skipCheckNames, <line7> boolean portalSource, <line8> boolean subrepository, <line9> boolean includeModuleChecks) <line10> throws Exception { <line11> List<SourceCheck> sourceChecks = new ArrayList<>(); <line12> List<SourceCheckConfiguration> sourceCheckConfigurations = <line13> sourceFormatterConfiguration.getSourceCheckConfigurations(sourceProcessorName); <line14> if (sourceCheckConfigurations == null) { <line15> return sourceChecks; <line16> } <line17> JSONObject excludesJSONObject = SourceFormatterCheckUtil.getExcludesJSONObject(propertiesMap); <line18> for (SourceCheckConfiguration sourceCheckConfiguration : sourceCheckConfigurations) { <line19> String sourceCheckName = <line20> SourceFormatterUtil.getSimpleName(sourceCheckConfiguration.getName()); <line21> if ((!filterCheckCategoryNames.isEmpty() || !filterCheckNames.isEmpty()) <line22> && !filterCheckCategoryNames.contains(sourceCheckConfiguration.getCategory()) <line23> && !filterCheckNames.contains(sourceCheckName)) { <line24> continue; <line25> } <line26> sourceCheckName = ""com.liferay.source.formatter.checks."" + sourceCheckName; <line27> Class<?> sourceCheckClass = null; <line28> try { <line29> sourceCheckClass = Class.forName(sourceCheckName); <line30> } catch (ClassNotFoundException classNotFoundException) { <line31> if (_log.isDebugEnabled()) { <line32> } <line33> SourceFormatterUtil.printError( <line34> ""sourcechecks.xml"", ""sourcechecks.xml: Class "" + sourceCheckName + "" cannot be found""); <line35> continue; <line36> } <line37> Constructor<?> declaredConstructor = sourceCheckClass.getDeclaredConstructor(); <line38> Object instance = declaredConstructor.newInstance(); <line39> if (!(instance instanceof SourceCheck)) { <line40> continue; <line41> } <line42> SourceCheck sourceCheck = (SourceCheck) instance; <line43> if ((!portalSource && !subrepository && sourceCheck.isLiferaySourceCheck()) <line44> || (!includeModuleChecks && sourceCheck.isModuleSourceCheck())) { <line45> continue; <line46> } <line47> Class<?> clazz = sourceCheck.getClass(); <line48> if (skipCheckNames.contains(clazz.getSimpleName())) { <line49> continue; <line50> } <line51> if (excludesJSONObject.length() != 0) { <line52> sourceCheck.setExcludes(excludesJSONObject.toString()); <line53> } <line54> JSONObject attributesJSONObject = <line55> _getAttributesJSONObject(propertiesMap, clazz.getSimpleName(), sourceCheckConfiguration); <line56> if (attributesJSONObject.length() != 0) { <line57> sourceCheck.setAttributes(attributesJSONObject.toString()); <line58> } <line59> sourceChecks.add(sourceCheck); <line60> } <line61> return sourceChecks; <line62> } <line63> } <line64> "	<line32>
5707	public class A { <line0> @Override <line1> public void onDropTable(DropTableEvent tableEvent) throws MetaException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> try { <line5> activatePluginClassLoader(); <line6> atlasMetastoreHookImpl.onDropTable(tableEvent); <line7> } finally { <line8> deactivatePluginClassLoader(); <line9> } <line10> if (LOG.isDebugEnabled()) { <line11> } <line12> } <line13> } <line14> 	<line3>, <line11>
5708	"public class A { <line0> private static boolean generatedShadersTooLarge( <line1> ShaderJobFileOperations fileOps, <line2> File preparedReferenceShaderJobFile, <line3> File variantShaderJobFile, <line4> Optional<Float> maxFactor, <line5> Optional<Integer> maxBytes, <line6> boolean verbose) { <line7> for (ShaderKind shaderKind : ShaderKind.values()) { <line8> if (fileOps.doesShaderExist(preparedReferenceShaderJobFile, shaderKind)) { <line9> assert fileOps.doesShaderExist(variantShaderJobFile, shaderKind); <line10> final long numBytesReference = <line11> fileOps.getShaderLength(preparedReferenceShaderJobFile, shaderKind); <line12> final long numBytesVariant = fileOps.getShaderLength(variantShaderJobFile, shaderKind); <line13> final String logMessagePrefix = <line14> ""Discarding "" <line15> + shaderKind.getFileExtension() <line16> + "" shader of size "" <line17> + numBytesVariant <line18> + "" bytes; ""; <line19> if (maxFactor.isPresent() && numBytesVariant > maxFactor.get() * numBytesReference) { <line20> if (verbose) { <line21> } <line22> return true; <line23> } <line24> if (maxBytes.isPresent() && numBytesVariant > maxBytes.get()) { <line25> if (verbose) { <line26> } <line27> return true; <line28> } <line29> } <line30> } <line31> return false; <line32> } <line33> } <line34> "	<line21>, <line26>
5709	public class A { <line0> @Override <line1> public boolean loadOrgData() { <line2> if (!enabled) { <line3> throw new LoadSourceDisabledException(getSourceName()); <line4> } <line5> return importData(); <line6> } <line7> } <line8> 	<line5>
5710	public class A { <line0> public static void main(String args[]) { <line1> url = args[0]; <line2> topic = args[1]; <line3> try { <line4> noOfEvents = Long.parseLong(args[2]); <line5> elapsedCount = Integer.parseInt(args[3]); <line6> noOfPublishers = Integer.parseInt(args[4]); <line7> KafkaClient kafkaClient = new KafkaClient(); <line8> kafkaClient.start(); <line9> } catch (NumberFormatException e) { <line10> } <line11> } <line12> } <line13> 	<line1>, <line10>
5711	public class A { <line0> public void run() { <line1> Configuration configuration = StockTickerEPLUtil.getConfiguration(); <line2> EPCompiled compiled = StockTickerEPLUtil.compileEPL(configuration); <line3> EPRuntime runtime = EPRuntimeProvider.getRuntime(runtimeURI, configuration); <line4> runtime.initialize(); <line5> StockTickerEPLUtil.deploy(runtime, compiled); <line6> StockTickerEventGenerator generator = new StockTickerEventGenerator(); <line7> LinkedList stream = generator.makeEventStream(1000000, 500000, 100, 25, 30, 48, 52, false); <line8> for (Object theEvent : stream) { <line9> runtime.getEventService().sendEventBean(theEvent, theEvent.getClass().getSimpleName()); <line10> if (continuousSimulation) { <line11> try { <line12> Thread.sleep(200); <line13> } catch (InterruptedException e) { <line14> break; <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	<line3>, <line5>, <line6>, <line8>, <line14>, <line18>
5712	"public class A { <line0> protected VDI getVDIbyUuid(final Connection conn, final String uuid) { <line1> try { <line2> return VDI.getByUuid(conn, uuid); <line3> } catch (final Exception e) { <line4> final String msg = <line5> ""Catch Exception "" <line6> + e.getClass().getName() <line7> + "" :VDI getByUuid for uuid: "" <line8> + uuid <line9> + "" failed due to "" <line10> + e.toString(); <line11> throw new CloudRuntimeException(msg, e); <line12> } <line13> } <line14> } <line15> "	<line11>
5713	"public class A { <line0> public static synchronized void addDocuments(AbstractPolicyStore policyStore, boolean reload) <line1> throws PolicyStoreException, FileNotFoundException { <line2> if (policyStore.policiesLoaded) return; <line3> File[] files = PopulatePolicyDatabase.getPolicyFiles(); <line4> if (files.length == 0) { <line5> return; <line6> } <line7> PolicyUtils utils = new PolicyUtils(); <line8> StringBuilder failedPolicies = new StringBuilder(); <line9> for (File f : files) { <line10> try { <line11> String policyID = utils.getPolicyName(f); <line12> if (policyStore instanceof FedoraPolicyStore) { <line13> if (policyID.contains("":"")) { <line14> policyID = policyID.replace("":"", ""%3A""); <line15> } <line16> policyID = FedoraPolicyStore.FESL_BOOTSTRAP_POLICY_NAMESPACE + "":"" + policyID; <line17> } <line18> if (policyStore.contains(policyID) && !reload) { <line19> if (LOGGER.isDebugEnabled()) { <line20> } <line21> } else { <line22> AbstractPolicyStore.policyNames.add(policyStore.addPolicy(f, policyID)); <line23> } <line24> } catch (MelcoePDPException e) { <line25> failedPolicies.append(f.getName() + ""\n""); <line26> } <line27> } <line28> if (failedPolicies.length() != 0) { <line29> throw new PolicyStoreException( <line30> ""Failed to load some bootstrap policies: "" + failedPolicies.toString()); <line31> } <line32> policyStore.policiesLoaded = true; <line33> } <line34> } <line35> "	<line20>, <line25>
5714	public class A { <line0> public void stateChanged(Enum oldState, Enum newState) { <line1> if (session.isStateless() && newState == IDLE) { <line2> session.release(); <line3> } <line4> if (log.isInfoEnabled()) { <line5> } <line6> } <line7> } <line8> 	<line5>
5715	"public class A { <line0> public static Collection<PartitionOwner> balancePartitionsAcrossWorkers( <line1> Configuration conf, <line2> Collection<PartitionOwner> partitionOwners, <line3> Collection<PartitionStats> allPartitionStats, <line4> Collection<WorkerInfo> availableWorkerInfos) { <line5> String balanceAlgorithm = conf.get(PARTITION_BALANCE_ALGORITHM, STATIC_BALANCE_ALGORITHM); <line6> if (LOG.isInfoEnabled()) { <line7> } <line8> BalanceValue balanceValue = BalanceValue.UNSET; <line9> if (balanceAlgorithm.equals(STATIC_BALANCE_ALGORITHM)) { <line10> return partitionOwners; <line11> } else if (balanceAlgorithm.equals(EGDE_BALANCE_ALGORITHM)) { <line12> balanceValue = BalanceValue.EDGES; <line13> } else if (balanceAlgorithm.equals(VERTICES_BALANCE_ALGORITHM)) { <line14> balanceValue = BalanceValue.VERTICES; <line15> } else { <line16> throw new IllegalArgumentException( <line17> ""balancePartitionsAcrossWorkers: Illegal balance "" + ""algorithm - "" + balanceAlgorithm); <line18> } <line19> Map<Integer, PartitionStats> idStatMap = new HashMap<Integer, PartitionStats>(); <line20> for (PartitionStats partitionStats : allPartitionStats) { <line21> if (idStatMap.put(partitionStats.getPartitionId(), partitionStats) != null) { <line22> throw new IllegalStateException( <line23> ""balancePartitionsAcrossWorkers: Duplicate partition id "" + ""for "" + partitionStats); <line24> } <line25> } <line26> Map<PartitionOwner, PartitionStats> ownerStatsMap = <line27> new HashMap<PartitionOwner, PartitionStats>(); <line28> for (PartitionOwner partitionOwner : partitionOwners) { <line29> PartitionStats partitionStats = idStatMap.get(partitionOwner.getPartitionId()); <line30> if (partitionStats == null) { <line31> throw new IllegalStateException( <line32> ""balancePartitionsAcrossWorkers: Missing partition "" + ""stats for "" + partitionOwner); <line33> } <line34> if (ownerStatsMap.put(partitionOwner, partitionStats) != null) { <line35> throw new IllegalStateException( <line36> ""balancePartitionsAcrossWorkers: Duplicate partition "" + ""owner "" + partitionOwner); <line37> } <line38> } <line39> if (ownerStatsMap.size() != partitionOwners.size()) { <line40> throw new IllegalStateException( <line41> ""balancePartitionsAcrossWorkers: ownerStats count = "" <line42> + ownerStatsMap.size() <line43> + "", partitionOwners count = "" <line44> + partitionOwners.size() <line45> + "" and should match.""); <line46> } <line47> List<WorkerInfoAssignments> workerInfoAssignmentsList = <line48> new ArrayList<WorkerInfoAssignments>(availableWorkerInfos.size()); <line49> for (WorkerInfo workerInfo : availableWorkerInfos) { <line50> workerInfoAssignmentsList.add( <line51> new WorkerInfoAssignments(workerInfo, balanceValue, ownerStatsMap)); <line52> } <line53> List<PartitionOwner> partitionOwnerList = new ArrayList<PartitionOwner>(partitionOwners); <line54> Collections.sort( <line55> partitionOwnerList, <line56> Collections.reverseOrder(new PartitionOwnerComparator(ownerStatsMap, balanceValue))); <line57> PriorityQueue<WorkerInfoAssignments> minQueue = <line58> new PriorityQueue<WorkerInfoAssignments>(workerInfoAssignmentsList); <line59> for (PartitionOwner partitionOwner : partitionOwnerList) { <line60> WorkerInfoAssignments chosenWorker = minQueue.remove(); <line61> chosenWorker.assignPartitionOwner(partitionOwner); <line62> minQueue.add(chosenWorker); <line63> } <line64> return partitionOwnerList; <line65> } <line66> } <line67> "	<line7>
5716	"public class A { <line0> @Override <line1> public void execute(Arguments arguments) throws Exception { <line2> ProgramId programId = arguments.getId(); <line3> Preconditions.checkArgument( <line4> programLifecycleService.getProgramSpecification(programId) != null, <line5> ""Cannot start %s because it does not exist."", <line6> programId); <line7> try { <line8> ProgramStatus currentStatus = programLifecycleService.getProgramStatus(programId); <line9> if (currentStatus != ProgramStatus.STOPPED) { <line10> return; <line11> } <line12> programLifecycleService.run(programId, Collections.emptyMap(), false); <line13> } catch (ConflictException e) { <line14> } catch (NotFoundException e) { <line15> throw new IllegalArgumentException( <line16> String.format(""Cannot start %s because it does not exist."", programId), e); <line17> } <line18> } <line19> } <line20> "	<line10>
5717	"public class A { <line0> public synchronized void update( <line1> int requestVersion, MetadataResponse response, boolean isPartialUpdate, long nowMs) { <line2> Objects.requireNonNull(response, ""Metadata response cannot be null""); <line3> if (isClosed()) throw new IllegalStateException(""Update requested after metadata close""); <line4> this.needPartialUpdate = requestVersion < this.requestVersion; <line5> this.lastRefreshMs = nowMs; <line6> this.updateVersion += 1; <line7> if (!isPartialUpdate) { <line8> this.needFullUpdate = false; <line9> this.lastSuccessfulRefreshMs = nowMs; <line10> } <line11> String previousClusterId = cache.clusterResource().clusterId(); <line12> this.cache = handleMetadataResponse(response, isPartialUpdate, nowMs); <line13> Cluster cluster = cache.cluster(); <line14> maybeSetMetadataError(cluster); <line15> this.lastSeenLeaderEpochs.keySet().removeIf(tp -> !retainTopic(tp.topic(), false, nowMs)); <line16> String newClusterId = cache.clusterResource().clusterId(); <line17> if (!Objects.equals(previousClusterId, newClusterId)) { <line18> } <line19> clusterResourceListeners.onUpdate(cache.clusterResource()); <line20> } <line21> } <line22> "	<line18>, <line20>
5718	"public class A { <line0> @Override <line1> public void reactivationByEmail(String email) throws ApsSystemException { <line2> try { <line3> Collection<String> usernames = this.getUsernamesByEmail(email); <line4> Iterator<String> usernamesIter = usernames.iterator(); <line5> while (usernamesIter.hasNext()) { <line6> String userName = (String) usernamesIter.next(); <line7> this.reactivationByUserName(userName); <line8> } <line9> } catch (Throwable t) { <line10> throw new ApsSystemException(""Error in request for Account Reactivation"", t); <line11> } <line12> } <line13> } <line14> "	<line10>
5719	"public class A { <line0> public int runGenerator( <line1> int numMappers, <line2> long numNodes, <line3> Path tmpOutput, <line4> Integer width, <line5> Integer wrapMultiplier, <line6> Integer numWalkers) <line7> throws Exception { <line8> createSchema(); <line9> job = Job.getInstance(getConf()); <line10> job.setJobName(""Link Generator""); <line11> job.setNumReduceTasks(0); <line12> job.setJarByClass(getClass()); <line13> FileInputFormat.setInputPaths(job, tmpOutput); <line14> job.setInputFormatClass(OneFilePerMapperSFIF.class); <line15> job.setOutputKeyClass(NullWritable.class); <line16> job.setOutputValueClass(NullWritable.class); <line17> setJobConf(job, numMappers, numNodes, width, wrapMultiplier, numWalkers); <line18> setMapperForGenerator(job); <line19> job.setOutputFormatClass(NullOutputFormat.class); <line20> job.getConfiguration().setBoolean(""mapreduce.map.speculative"", false); <line21> TableMapReduceUtil.addDependencyJars(job); <line22> TableMapReduceUtil.addDependencyJarsForClasses(job.getConfiguration(), AbstractHBaseTool.class); <line23> TableMapReduceUtil.initCredentials(job); <line24> boolean success = jobCompletion(job); <line25> return success ? 0 : 1; <line26> } <line27> } <line28> "	<line8>
5720	public class A { <line0> @Override <line1> @PostMapping <line2> public OwnerDto create(@Valid final @RequestBody OwnerDto dto) { <line3> return internalOwnerService.create(dto); <line4> } <line5> } <line6> 	<line3>
5721	"public class A { <line0> @Override <line1> public <T extends Resource> Collection<T> deserialize( <line2> String xml, String serviceIdentifier, String path, Class<T> returnType) { <line3> Collection<T> resources = new ArrayList<T>(); <line4> InputSource is = new InputSource(new StringReader(xml)); <line5> try { <line6> NodeList parSNodes = <line7> (NodeList) xpf.newXPath().evaluate(xpathExpr, is, XPathConstants.NODESET); <line8> for (int i = 0; i < parSNodes.getLength(); i++) { <line9> String placeId = null; <line10> String topn = null; <line11> String cf = null; <line12> String vote = null; <line13> Node parS = parSNodes.item(i); <line14> NodeList parList = parS.getChildNodes(); <line15> for (int j = 0; j < parList.getLength(); j++) { <line16> Node par = parList.item(j); <line17> String content = par.getTextContent(); <line18> if (content != null && !content.equalsIgnoreCase(""\n"")) { <line19> NamedNodeMap map = par.getAttributes(); <line20> Node n = map.getNamedItem(""n""); <line21> String value = n.getNodeValue(); <line22> if (value.equalsIgnoreCase(""item_id"")) placeId = content; <line23> else if (value.equalsIgnoreCase(""recs:vote"")) vote = content; <line24> else if (value.equalsIgnoreCase(""recs:engine:topn"")) topn = content; <line25> else if (value.equalsIgnoreCase(""recs:engine:cf"")) cf = content; <line26> } <line27> } <line28> Location l = createLocation(placeId, vote, topn, cf); <line29> resources.add((T) l); <line30> } <line31> } catch (XPathExpressionException e) { <line32> } <line33> return resources; <line34> } <line35> } <line36> "	<line32>
5722	"public class A { <line0> @JsxFunction <line1> public int moveEnd(final String unit, final Object count) { <line2> if (!""character"".equals(unit)) { <line3> if (LOG.isWarnEnabled()) { <line4> } <line5> return 0; <line6> } <line7> int c = 1; <line8> if (!Undefined.isUndefined(count)) { <line9> c = (int) Context.toNumber(count); <line10> } <line11> if (range_.getStartContainer() == range_.getEndContainer() <line12> && range_.getStartContainer() instanceof SelectableTextInput) { <line13> final SelectableTextInput input = (SelectableTextInput) range_.getStartContainer(); <line14> c = constrainMoveBy(c, range_.getEndOffset(), input.getText().length()); <line15> range_.setEnd(input, range_.getEndOffset() + c); <line16> } <line17> return c; <line18> } <line19> } <line20> "	<line4>
5723	public class A { <line0> private GlobalSystemData loadGlobalData() throws EngineException { <line1> Stopwatch watch = Stopwatch.createStarted(); <line2> GlobalSystemData ret = <line3> GlobalSystemData.builder() <line4> .withAttributeTypes(attributeTypeDAO.getAllAsMap()) <line5> .withAttributeClasses(acDB.getAllAsMap()) <line6> .withGroups(groupDAO.getAllAsMap()) <line7> .withCredentials(credentialRepository.getCredentialDefinitions()) <line8> .withCredentialRequirements(getCredentialRequirements()) <line9> .withEnquiryForms(enquiryDB.getAllAsMap()) <line10> .build(); <line11> return ret; <line12> } <line13> } <line14> 	<line11>
5724	public class A { <line0> private void readTokens() { <line1> int nRead; <line2> String tags = null; <line3> try { <line4> char[] buff = new char[1 * 1024]; <line5> StringBuilder buffer = new StringBuilder(); <line6> while ((nRead = input.read(buff, 0, buff.length)) != -1) { <line7> buffer.append(buff, 0, nRead); <line8> } <line9> tags = buffer.toString(); <line10> } catch (IOException e) { <line11> } <line12> if (tags != null && !tags.isEmpty()) { <line13> int iValue = tags.indexOf(TagsBridge.VALUE); <line14> if (iValue > 0) { <line15> String tag = tags.substring(0, iValue); <line16> String value = tags.substring(iValue + TagsBridge.VALUE.length()); <line17> String token = tag + SEPARATOR + value; <line18> tokens = new String[2]; <line19> tokens[0] = tag; <line20> tokens[1] = token; <line21> } else { <line22> tokens = new String[1]; <line23> tokens[0] = tags; <line24> } <line25> } <line26> } <line27> } <line28> 	<line11>
5725	"public class A { <line0> public boolean sendMessage(String email, String subject, String text) { <line1> if (email.isEmpty()) { <line2> return false; <line3> } <line4> Client client = Client.create(); <line5> client.addFilter(new HTTPBasicAuthFilter(""api"", config.getMailgunApiKey())); <line6> String domain = config.getMailgunDomain(); <line7> WebResource webResource = client.resource(""https://api.mailgun.net/v3/"" + domain + ""/messages""); <line8> MultivaluedMapImpl formData = new MultivaluedMapImpl(); <line9> formData.add(""from"", ""XMage <postmaster@"" + domain + '>'); <line10> formData.add(""to"", email); <line11> formData.add(""subject"", subject); <line12> formData.add(""text"", text); <line13> ClientResponse response = <line14> webResource <line15> .type(MediaType.APPLICATION_FORM_URLENCODED) <line16> .post(ClientResponse.class, formData); <line17> boolean succeeded = response.getStatus() == 200; <line18> if (!succeeded) { <line19> } <line20> return succeeded; <line21> } <line22> } <line23> "	<line2>, <line19>
5726	public class A { <line0> public void removeAndNotifyKeys(Object[] keys) { <line1> final boolean isTraceEnabled = logger.isTraceEnabled(); <line2> synchronized (allKeysMap) { <line3> for (Object key : keys) { <line4> LockObject lockValue = allKeysMap.remove(key); <line5> if (lockValue != null) { <line6> synchronized (lockValue) { <line7> lockValue.setRemoved(); <line8> if (isTraceEnabled) { <line9> long waitTime = System.currentTimeMillis() - lockValue.lockedTimeStamp; <line10> } <line11> if (lockValue.isSomeoneWaiting()) { <line12> lockValue.notifyAll(); <line13> } <line14> } <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	<line10>
5727	"public class A { <line0> @Override <line1> public List<InputSplit> getSplits(JobContext context) throws IOException { <line2> long start = System.currentTimeMillis(); <line3> Configuration conf = context.getConfiguration(); <line4> ImageInputFormatContext ifContext = ImageInputFormatContext.load(conf); <line5> int zoom = ifContext.getZoomLevel(); <line6> int tilesize = ifContext.getTileSize(); <line7> HdfsMrsImageDataProvider dp = createHdfsMrsImageDataProvider(context.getConfiguration()); <line8> Path inputWithZoom = new Path(dp.getResourcePath(true), """" + zoom); <line9> MrsPyramidMetadataReader metadataReader = dp.getMetadataReader(); <line10> MrsPyramidMetadata metadata = metadataReader.read(); <line11> org.mrgeo.hdfs.tile.FileSplit fsplit = createFileSplit(); <line12> fsplit.readSplits(inputWithZoom); <line13> FileSplitInfo[] splits = (FileSplitInfo[]) fsplit.getSplits(); <line14> List<InputSplit> result = new ArrayList<>(splits.length); <line15> Bounds requestedBounds = ifContext.getBounds(); <line16> for (FileSplitInfo split : splits) { <line17> Path part = new Path(inputWithZoom, split.getName()); <line18> Path dataFile = new Path(part, MapFile.DATA_FILE_NAME); <line19> long endTileId = split.getEndId(); <line20> long startTileId = split.getStartId(); <line21> if (requestedBounds != null) { <line22> Tile startTile = TMSUtils.tileid(startTileId, zoom); <line23> Bounds startTileBounds = TMSUtils.tileBounds(startTile, zoom, tilesize); <line24> Tile endTile = TMSUtils.tileid(endTileId, zoom); <line25> Bounds endTileBounds = TMSUtils.tileBounds(endTile, zoom, tilesize); <line26> if (startTileBounds.s > requestedBounds.n || endTileBounds.n < requestedBounds.s) { <line27> } else { <line28> result.add( <line29> new TiledInputSplit( <line30> new FileSplit(dataFile, 0, 0, null), <line31> startTileId, <line32> endTileId, <line33> zoom, <line34> metadata.getTilesize())); <line35> } <line36> } else { <line37> result.add( <line38> new TiledInputSplit( <line39> new FileSplit(dataFile, 0, 0, null), <line40> startTileId, <line41> endTileId, <line42> zoom, <line43> metadata.getTilesize())); <line44> } <line45> } <line46> long end = System.currentTimeMillis(); <line47> return result; <line48> } <line49> } <line50> "	<line47>
5728	"public class A { <line0> @Override <line1> public Tuple exec(Tuple input) throws IOException { <line2> if (input == null || input.size() == 0) { <line3> return null; <line4> } <line5> try { <line6> Object obj = null; <line7> try { <line8> obj = (DataByteArray) input.get(1); <line9> } catch (ExecException e) { <line10> throw e; <line11> } <line12> DataByteArray dba = null; <line13> try { <line14> dba = (DataByteArray) obj; <line15> } catch (Exception e) { <line16> throw e; <line17> } <line18> DocumentMetadata dm = null; <line19> try { <line20> dm = DocumentMetadata.parseFrom(dba.get()); <line21> } catch (Exception e) { <line22> throw e; <line23> } <line24> String key = dm.getKey(); <line25> String titles; <line26> String abstracts; <line27> List<String> titleList = new ArrayList<String>(); <line28> for (TextWithLanguage title : dm.getBasicMetadata().getTitleList()) { <line29> titleList.add(title.getText()); <line30> } <line31> titles = Joiner.on("" "").join(titleList); <line32> List<String> abstractsList = new ArrayList<String>(); <line33> for (TextWithLanguage documentAbstract : dm.getBasicMetadata().getTitleList()) { <line34> abstractsList.add(documentAbstract.getText()); <line35> } <line36> abstracts = Joiner.on("" "").join(abstractsList); <line37> List<String> allKeywords = new ArrayList<String>(); <line38> for (KeywordsList keywordsList : dm.getKeywordsList()) { <line39> allKeywords.addAll(keywordsList.getKeywordsList()); <line40> } <line41> String[] to = new String[] {key, titles, abstracts, Joiner.on("" "").join(allKeywords)}; <line42> Tuple t = TupleFactory.getInstance().newTuple(Arrays.asList(to)); <line43> return t; <line44> } catch (Exception e) { <line45> throw new IOException( <line46> ""Caught exception processing input row:\n"" + StackTraceExtractor.getStackTrace(e)); <line47> } <line48> } <line49> } <line50> "	<line10>, <line16>, <line22>, <line45>
5729	public class A { <line0> @Test <line1> public void generateJavaNestedCompPropClassNames() { <line2> Set<ComponentDefinition> allComponents = getComponentService().getAllComponents(); <line3> for (ComponentDefinition cd : allComponents) { <line4> ComponentProperties props = cd.createProperties(); <line5> String javaCode = PropertiesTestUtils.generatedNestedComponentCompatibilitiesJavaCode(props); <line6> } <line7> } <line8> } <line9> 	<line6>
5730	"public class A { <line0> @Override <line1> public List<TestCaseExecutionQueue> findTestCaseExecutionInQueuebyTag(String tag) <line2> throws CerberusException { <line3> boolean throwEx = false; <line4> final StringBuilder query = <line5> new StringBuilder(""select exq.*, tec.*, app.* from ( select exq.* "") <line6> .append(""from testcaseexecutionqueue exq "") <line7> .append(""where exq.tag = ? "") <line8> .append("" order by exq.test, exq.testcase, exq.ID desc) as exq "") <line9> .append( <line10> ""LEFT JOIN testcase tec on exq.Test = tec.Test and exq.TestCase = tec.TestCase "") <line11> .append(""LEFT JOIN application app ON tec.application = app.application "") <line12> .append(""GROUP BY exq.test, exq.testcase, exq.Environment, exq.Browser, exq.Country ""); <line13> List<TestCaseExecutionQueue> testCaseExecutionInQueueList = <line14> new ArrayList<TestCaseExecutionQueue>(); <line15> Connection connection = this.databaseSpring.connect(); <line16> try { <line17> PreparedStatement preStat = connection.prepareStatement(query.toString()); <line18> preStat.setString(1, tag); <line19> try { <line20> ResultSet resultSet = preStat.executeQuery(); <line21> try { <line22> while (resultSet.next()) { <line23> testCaseExecutionInQueueList.add(this.loadWithDependenciesFromResultSet(resultSet)); <line24> } <line25> } catch (SQLException exception) { <line26> testCaseExecutionInQueueList = null; <line27> } catch (FactoryCreationException ex) { <line28> } finally { <line29> resultSet.close(); <line30> } <line31> } catch (SQLException exception) { <line32> testCaseExecutionInQueueList = null; <line33> } finally { <line34> preStat.close(); <line35> } <line36> } catch (SQLException exception) { <line37> testCaseExecutionInQueueList = null; <line38> } finally { <line39> try { <line40> if (connection != null) { <line41> connection.close(); <line42> } <line43> } catch (SQLException e) { <line44> } <line45> } <line46> if (throwEx) { <line47> throw new CerberusException(new MessageGeneral(MessageGeneralEnum.NO_DATA_FOUND)); <line48> } <line49> return testCaseExecutionInQueueList; <line50> } <line51> } <line52> "	<line26>, <line28>, <line32>, <line37>, <line44>
5731	"public class A { <line0> @Override <line1> public KeyManager[] createKeyManagers() { <line2> KeyInfoManager keyInfoManager = null; <line3> try { <line4> keyInfoManager = getKeyInfoManager(getKeyStoreParameters()); <line5> KeyStore ks = loadKeyStore(keyStoreParameters, keyInfoManager); <line6> KeyManagerFactory kmfactory = <line7> KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); <line8> String keyStorePassword = keyInfoManager.getKeyStorePassword(); <line9> kmfactory.init(ks, keyStorePassword != null ? keyStorePassword.toCharArray() : null); <line10> return kmfactory.getKeyManagers(); <line11> } catch (Throwable e) { <line12> throw new AlfrescoRuntimeException(""Unable to create key manager"", e); <line13> } finally { <line14> if (keyInfoManager != null) { <line15> keyInfoManager.clear(); <line16> } <line17> } <line18> } <line19> } <line20> "	<line6>
5732	public class A { <line0> protected boolean verifyContextNotStarted() { <line1> if (muleContext != null <line2> && muleContext.getLifecycleManager().isPhaseComplete(Startable.PHASE_NAME)) { <line3> return false; <line4> } else { <line5> return true; <line6> } <line7> } <line8> } <line9> 	<line3>
5733	public class A { <line0> public int readReportTempFileAndSave(String fileName, int reportID) throws IOException { <line1> int reportId = 0; <line2> try { <line3> File reportTempFile = new File(classLoader.getResource(fileName).getFile()); <line4> String reportTempJson = new String(Files.readAllBytes(reportTempFile.toPath())); <line5> reportId = saveReportTemplate(reportTempJson, reportID); <line6> reportIdList.add(reportId); <line7> } catch (IOException e) { <line8> } <line9> return reportId; <line10> } <line11> } <line12> 	<line8>
5734	"public class A { <line0> @Override <line1> public Answer ComputeChecksum(ComputeChecksumCommand cmd) { <line2> TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.SIMULATOR_DB); <line3> try { <line4> txn.start(); <line5> MockVolumeVO volume = _mockVolumeDao.findByName(cmd.getTemplatePath()); <line6> if (volume == null) { <line7> return new Answer(cmd, false, ""cant' find volume:"" + cmd.getTemplatePath()); <line8> } <line9> String md5 = null; <line10> try { <line11> MessageDigest md = MessageDigest.getInstance(""md5""); <line12> md5 = <line13> String.format(""%032x"", new BigInteger(1, md.digest(cmd.getTemplatePath().getBytes()))); <line14> } catch (NoSuchAlgorithmException e) { <line15> } <line16> txn.commit(); <line17> return new Answer(cmd, true, md5); <line18> } finally { <line19> txn.close(); <line20> txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB); <line21> txn.close(); <line22> } <line23> } <line24> } <line25> "	<line15>
5735	public class A { <line0> public Map<String, Double> safeGetStat( <line1> Set<String> fields, Set<String> dataTypes, Date start, Date end) { <line2> try { <line3> return getStat(fields, dataTypes, start, end); <line4> } catch (Exception e) { <line5> if (log.isDebugEnabled()) <line6> return EMPTY_STATS; <line7> } <line8> } <line9> } <line10> 	<line6>
5736	public class A { <line0> @Override <line1> public JSONArray apply(InputStream input) { <line2> try { <line3> String result = new String(ByteStreams.toByteArray(input), StandardCharsets.UTF_8); <line4> return new JSONArray(result); <line5> } catch (Exception e) { <line6> throw Throwables.propagate(e); <line7> } <line8> } <line9> } <line10> 	<line4>
5737	public class A { <line0> public static boolean compareDecrypted(byte[] decrypted, byte[] clientRandom, boolean silent) { <line1> if (decrypted.length <= SSL2ByteLength.MAC_DATA + SSL2ByteLength.MESSAGE_TYPE) { <line2> return false; <line3> } <line4> int typeOffset = SSL2ByteLength.MAC_DATA; <line5> if (decrypted[typeOffset] != HandshakeMessageType.SSL2_SERVER_VERIFY.getValue()) { <line6> if (!silent) { <line7> } <line8> return false; <line9> } <line10> int challengeOffset = typeOffset + SSL2ByteLength.MESSAGE_TYPE; <line11> byte[] decryptedChallenge = Arrays.copyOfRange(decrypted, challengeOffset, decrypted.length); <line12> return Arrays.equals(decryptedChallenge, clientRandom); <line13> } <line14> } <line15> 	<line2>, <line7>
5738	"public class A { <line0> @GET <line1> @Path(""{transactionId}"") <line2> public Response getTransactionStatus(@PathParam(""transactionId"") final String txId) { <line3> final Transaction tx; <line4> try { <line5> tx = txManager.get(txId); <line6> } catch (final TransactionNotFoundException e) { <line7> return Response.status(Status.NOT_FOUND).build(); <line8> } catch (final TransactionClosedException e) { <line9> return Response.status(Status.GONE) <line10> .entity(e.getMessage()) <line11> .type(TEXT_PLAIN_WITH_CHARSET) <line12> .build(); <line13> } <line14> return Response.status(Status.NO_CONTENT) <line15> .header(ATOMIC_EXPIRES_HEADER, EXPIRES_RFC_1123_FORMATTER.format(tx.getExpires())) <line16> .build(); <line17> } <line18> } <line19> "	<line14>
5739	"public class A { <line0> @Override <line1> public OutputStream createOutputStream(long offset) throws IOException { <line2> final Page origPage = page; <line3> OutputStream out = <line4> new ByteArrayOutputStream() { <line5> @Override <line6> public void flush() throws IOException { <line7> final String source = toString(); <line8> final App app = StructrApp.getInstance(); <line9> try (Tx tx = app.tx()) { <line10> Page modifiedPage = <line11> Importer.parsePageFromSource( <line12> page.getSecurityContext(), source, ""__FTP_Temporary_Page__""); <line13> final List<InvertibleModificationOperation> changeSet = <line14> Importer.diffNodes(origPage, modifiedPage); <line15> for (final InvertibleModificationOperation op : changeSet) { <line16> op.apply(app, origPage, modifiedPage); <line17> } <line18> app.delete(modifiedPage); <line19> tx.success(); <line20> } catch (FrameworkException fex) { <line21> } <line22> super.flush(); <line23> } <line24> }; <line25> return out; <line26> } <line27> } <line28> "	<line21>
5740	"public class A { <line0> private Provider initSecurityProvider(String providerName) { <line1> switch (providerName) { <line2> case ""BC"": <line3> Security.addProvider(new BouncyCastleProvider()); <line4> return Security.getProvider(providerName); <line5> default: <line6> throw new SecurityException(""Unknown security provider:"" + provider); <line7> } <line8> } <line9> } <line10> "	<line6>
5741	"public class A { <line0> public void onArmSync( <line1> Myo myo, long timestamp, Arm arm, XDirection xDirection, WarmupState warmupState) { <line2> whichArm = arm; <line3> invoke(""publishArmSync"", arm); <line4> } <line5> } <line6> "	<line2>
5742	public class A { <line0> private void setCollectionValue(Object entity, Object thriftColumnValue, Attribute attribute) { <line1> try { <line2> ByteBuffer valueByteBuffer = ByteBuffer.wrap((byte[]) thriftColumnValue); <line3> if (Collection.class.isAssignableFrom(((Field) attribute.getJavaMember()).getType())) { <line4> Class<?> genericClass = <line5> PropertyAccessorHelper.getGenericClass((Field) attribute.getJavaMember()); <line6> PropertyAccessorHelper.set( <line7> entity, <line8> (Field) attribute.getJavaMember(), <line9> CassandraDataTranslator.decompose( <line10> ((Field) attribute.getJavaMember()).getType(), <line11> valueByteBuffer, <line12> genericClass, <line13> true)); <line14> } else if (((Field) attribute.getJavaMember()).getType().isAssignableFrom(Map.class)) { <line15> List<Class<?>> mapGenericClasses = <line16> PropertyAccessorHelper.getGenericClasses((Field) attribute.getJavaMember()); <line17> PropertyAccessorHelper.set( <line18> entity, <line19> (Field) attribute.getJavaMember(), <line20> CassandraDataTranslator.decompose( <line21> ((Field) attribute.getJavaMember()).getType(), <line22> valueByteBuffer, <line23> mapGenericClasses, <line24> true)); <line25> } <line26> } catch (Exception e) { <line27> throw new PersistenceException(e); <line28> } <line29> } <line30> } <line31> 	<line27>
5743	"public class A { <line0> public void handle(Class<?> annotatedType) { <line1> if (!(Converter.class.isAssignableFrom(annotatedType))) { <line2> throw new VRaptorException(""converter does not implement Converter""); <line3> } <line4> if (BaseComponents.getBundledConverters().contains(annotatedType)) { <line5> return; <line6> } <line7> @SuppressWarnings(""unchecked"") <line8> Class<? extends Converter<?>> converterType = (Class<? extends Converter<?>>) annotatedType; <line9> converters.register(converterType); <line10> } <line11> } <line12> "	<line5>
5744	public class A { <line0> @Override <line1> public synchronized void storePlanDeploymentInfo(PlanDeploymentInfo info) { <line2> this.em.getTransaction().begin(); <line3> final PlanDeploymentInfo storedPlan = <line4> this.getPlanDeploymentInfo(info.getCsarID(), info.getRelPath()); <line5> if (storedPlan != null) { <line6> final PlanDeploymentState storedPlanDeployState = storedPlan.getDeploymentState(); <line7> final PlanDeploymentState newPlanDeployState = info.getDeploymentState(); <line8> if (storedPlanDeployState.equals(PlanDeploymentState.PLAN_DEPLOYED) <line9> && newPlanDeployState.equals(PlanDeploymentState.PLAN_UNDEPLOYING)) { <line10> storedPlan.setAttempt(0); <line11> } <line12> storedPlan.setDeploymentState(newPlanDeployState); <line13> info = storedPlan; <line14> } <line15> if (info.getDeploymentState().equals(PlanDeploymentState.PLAN_DEPLOYING) <line16> || info.getDeploymentState().equals(PlanDeploymentState.PLAN_UNDEPLOYING)) { <line17> info.setAttempt(info.getAttempt() + 1); <line18> } <line19> this.em.persist(info); <line20> this.em.getTransaction().commit(); <line21> } <line22> } <line23> 	<line2>, <line6>, <line10>, <line17>, <line21>
5745	"public class A { <line0> @Override <line1> public Object getProperty(Map context, Object target, Object key) throws OgnlException { <line2> if (!ReflectionContextState.isGettingByKeyProperty(context) <line3> && !key.equals(KEY_PROPERTY_FOR_CREATION)) { <line4> return super.getProperty(context, target, key); <line5> } else { <line6> ReflectionContextState.setGettingByKeyProperty(context, false); <line7> } <line8> Collection c = (Collection) target; <line9> Class lastBeanClass = ReflectionContextState.getLastBeanClassAccessed(context); <line10> String lastPropertyClass = ReflectionContextState.getLastBeanPropertyAccessed(context); <line11> if (lastBeanClass == null || lastPropertyClass == null) { <line12> ReflectionContextState.updateCurrentPropertyPath(context, key); <line13> return super.getProperty(context, target, key); <line14> } <line15> String keyProperty = objectTypeDeterminer.getKeyProperty(lastBeanClass, lastPropertyClass); <line16> Class collClass = objectTypeDeterminer.getElementClass(lastBeanClass, lastPropertyClass, key); <line17> Class keyType; <line18> Class toGetTypeFrom = (collClass != null) ? collClass : c.iterator().next().getClass(); <line19> try { <line20> keyType = OgnlRuntime.getPropertyDescriptor(toGetTypeFrom, keyProperty).getPropertyType(); <line21> } catch (Exception exc) { <line22> throw new OgnlException(""Error getting property descriptor: "" + exc.getMessage()); <line23> } <line24> if (ReflectionContextState.isCreatingNullObjects(context)) { <line25> Map collMap = getSetMap(context, c, keyProperty); <line26> if (key.toString().equals(KEY_PROPERTY_FOR_CREATION)) { <line27> return collMap.get(null); <line28> } <line29> Object realKey = xworkConverter.convertValue(context, key, keyType); <line30> Object value = collMap.get(realKey); <line31> if (value == null <line32> && ReflectionContextState.isCreatingNullObjects(context) <line33> && objectTypeDeterminer.shouldCreateIfNew( <line34> lastBeanClass, lastPropertyClass, c, keyProperty, false)) { <line35> try { <line36> value = objectFactory.buildBean(collClass, context); <line37> _accessor.setProperty(context, value, keyProperty, realKey); <line38> c.add(value); <line39> collMap.put(realKey, value); <line40> } catch (Exception exc) { <line41> throw new OgnlException(""Error adding new element to collection"", exc); <line42> } <line43> } <line44> return value; <line45> } else { <line46> if (key.toString().equals(KEY_PROPERTY_FOR_CREATION)) { <line47> return null; <line48> } <line49> Object realKey = xworkConverter.convertValue(context, key, keyType); <line50> return getPropertyThroughIteration(context, c, keyProperty, realKey); <line51> } <line52> } <line53> } <line54> "	<line2>
5746	"public class A { <line0> public void setUp() throws Exception { <line1> if (sharedTime == null) currentTime = new AtomicLong(System.currentTimeMillis()); <line2> ticker = <line3> new Ticker() { <line4> @Override <line5> public long read() { <line6> if (sharedTime != null) return sharedTime.get(); <line7> return currentTime.get(); <line8> } <line9> }; <line10> nodeName = ""node "" + nodes.size(); <line11> mgmt = newLocalManagementContext(); <line12> ownNodeId = mgmt.getManagementNodeId(); <line13> objectStore = new ListeningObjectStore(newPersistenceObjectStore()); <line14> objectStore.injectManagementContext(mgmt); <line15> objectStore.prepareForSharedUse(PersistMode.CLEAN, HighAvailabilityMode.DISABLED); <line16> persister = new ManagementPlaneSyncRecordPersisterToObjectStore(mgmt, objectStore, classLoader); <line17> ((ManagementPlaneSyncRecordPersisterToObjectStore) persister).preferRemoteTimestampInMemento(); <line18> BrooklynMementoPersisterToObjectStore persisterObj = <line19> new BrooklynMementoPersisterToObjectStore( <line20> objectStore, mgmt.getBrooklynProperties(), classLoader); <line21> mgmt.getRebindManager() <line22> .setPersister(persisterObj, PersistenceExceptionHandlerImpl.builder().build()); <line23> ha = <line24> ((HighAvailabilityManagerImpl) mgmt.getHighAvailabilityManager()) <line25> .setPollPeriod(Duration.PRACTICALLY_FOREVER) <line26> .setHeartbeatTimeout(Duration.THIRTY_SECONDS) <line27> .setLocalTicker(ticker) <line28> .setRemoteTicker(ticker) <line29> .setPersister(persister); <line30> } <line31> } <line32> "	<line30>
5747	"public class A { <line0> public static String httpQueryParamRequest( <line1> String url, JsonObject queryParams, Map<String, String> headers, String action) <line2> throws InsightsCustomException { <line3> String data = null; <line4> Builder invocationBuilder = null; <line5> Response response = null; <line6> WebTarget webTarget = null; <line7> try { <line8> webTarget = client.target(url); <line9> if (queryParams != null && !queryParams.entrySet().isEmpty()) { <line10> Set<Entry<String, JsonElement>> entitySet = queryParams.entrySet(); <line11> for (Entry<String, JsonElement> entity : entitySet) { <line12> String key = entity.getKey(); <line13> webTarget = webTarget.queryParam(key, queryParams.get(key).getAsString()); <line14> } <line15> } <line16> invocationBuilder = webTarget.request(); <line17> if (headers != null && !headers.isEmpty()) { <line18> for (Map.Entry<String, String> entry : headers.entrySet()) { <line19> invocationBuilder = invocationBuilder.header(entry.getKey(), entry.getValue()); <line20> } <line21> } <line22> if (HttpMethod.POST.equalsIgnoreCase(action)) { <line23> response = invocationBuilder.post(null, Response.class); <line24> } else if (HttpMethod.GET.equalsIgnoreCase(action)) { <line25> response = invocationBuilder.get(Response.class); <line26> } <line27> if (response != null) { <line28> data = response.readEntity(String.class); <line29> if (response.getStatus() == 404) { <line30> JsonObject errorResponse = new JsonObject(); <line31> errorResponse.addProperty(""status"", response.getStatus()); <line32> errorResponse.addProperty(""data"", data); <line33> throw new RestAPI404Exception(errorResponse.toString()); <line34> } else if (!(response.getStatus() == 200 || response.getStatus() == 204)) { <line35> throw new InsightsCustomException( <line36> ""Failed : HTTP error code.. : "" + response.getStatus() + "" message "" + data); <line37> } <line38> } <line39> } catch (ProcessingException e) { <line40> throw e; <line41> } catch (RestAPI404Exception e) { <line42> throw new RestAPI404Exception(e.getMessage()); <line43> } catch (Exception e) { <line44> throw new InsightsCustomException(e.getMessage()); <line45> } finally { <line46> if (response != null) { <line47> response.close(); <line48> } <line49> } <line50> return data; <line51> } <line52> } <line53> "	<line30>, <line40>, <line42>, <line44>
5748	public class A { <line0> private KeyStore keystore() { <line1> try { <line2> return SelfSignedCertificate.keystore(); <line3> } catch (Throwable e) { <line4> e.printStackTrace(); <line5> if (logger.isTraceEnabled()) { <line6> } else if (logger.isInfoEnabled()) { <line7> } <line8> try { <line9> return BouncyCastleSelfSignedCertificate.keystore(); <line10> } catch (Throwable t) { <line11> } <line12> } <line13> return null; <line14> } <line15> } <line16> 	<line6>, <line7>, <line11>
5749	public class A { <line0> @Override <line1> public void stop(int stateCode) throws AngelException { <line2> stopService(); <line3> if (master != null) { <line4> try { <line5> master.stop( <line6> null, <line7> ClientMasterServiceProtos.StopRequest.newBuilder().setExitStatus(stateCode).build()); <line8> } catch (Throwable e) { <line9> kill(); <line10> } <line11> } else { <line12> kill(); <line13> } <line14> close(); <line15> } <line16> } <line17> 	<line2>, <line5>, <line9>, <line12>
5750	"public class A { <line0> @Override <line1> public Observable<Order> getOrderChanges(CurrencyPair currencyPair, Object... args) { <line2> if (!containsPair(service.getProduct().getOrders(), currencyPair)) <line3> throw new UnsupportedOperationException( <line4> String.format(""The currency pair %s is not subscribed for orders"", currencyPair)); <line5> if (!service.isAuthenticated()) { <line6> throw new ExchangeSecurityException(""Not authenticated""); <line7> } <line8> if (!orderChangesWarningLogged) { <line9> orderChangesWarningLogged = true; <line10> } <line11> return service <line12> .getRawWebSocketTransactions(currencyPair, true) <line13> .filter(s -> s.getUserId() != null) <line14> .map(CoinbaseProStreamingAdapters::adaptOrder); <line15> } <line16> } <line17> "	<line9>
5751	"public class A { <line0> @Override <line1> public void rollback() { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> boolean finalResult = false; <line5> final DistributionManager dm = getCache().getDistributionManager(); <line6> try { <line7> Set<DistributedMember> txRemoteParticpants = getTxRemoteParticpants(dm); <line8> DistTXRollbackMessage.DistTxRollbackReplyProcessor processor = <line9> new DistTXRollbackMessage.DistTxRollbackReplyProcessor( <line10> this.getTxId(), dm, txRemoteParticpants, target2realDeals); <line11> processor.enableSevereAlertProcessing(); <line12> final DistTXRollbackMessage rollbackMsg = <line13> new DistTXRollbackMessage(this.getTxId(), this.onBehalfOfClientMember, processor); <line14> for (DistributedMember remoteNode : txRemoteParticpants) { <line15> DistTXCoordinatorInterface remoteTXStateStub = target2realDeals.get(remoteNode); <line16> if (remoteTXStateStub.isTxState()) { <line17> throw new UnsupportedOperationInTransactionException( <line18> String.format( <line19> ""Expected %s during a distributed transaction but got %s"", <line20> ""DistPeerTXStateStub"", remoteTXStateStub.getClass().getSimpleName())); <line21> } <line22> try { <line23> remoteTXStateStub.setRollbackMessage(rollbackMsg, dm); <line24> remoteTXStateStub.rollback(); <line25> } finally { <line26> remoteTXStateStub.setRollbackMessage(null, null); <line27> remoteTXStateStub.finalCleanup(); <line28> } <line29> if (logger.isDebugEnabled()) { <line30> } <line31> } <line32> DistTXCoordinatorInterface localTXState = target2realDeals.get(dm.getId()); <line33> if (localTXState != null) { <line34> if (!localTXState.isTxState()) { <line35> throw new UnsupportedOperationInTransactionException( <line36> String.format( <line37> ""Expected %s during a distributed transaction but got %s"", <line38> ""DistTXStateOnCoordinator"", localTXState.getClass().getSimpleName())); <line39> } <line40> localTXState.rollback(); <line41> boolean localResult = localTXState.getRollbackResponse(); <line42> if (logger.isDebugEnabled()) { <line43> } <line44> finalResult = finalResult && localResult; <line45> } <line46> { <line47> dm.getCancelCriterion().checkCancelInProgress(null); <line48> processor.waitForPrecommitCompletion(); <line49> Map<DistributedMember, Boolean> remoteResults = processor.getRollbackResponseMap(); <line50> for (Entry<DistributedMember, Boolean> e : remoteResults.entrySet()) { <line51> DistributedMember target = e.getKey(); <line52> Boolean remoteResult = e.getValue(); <line53> if (logger.isDebugEnabled()) { <line54> } <line55> finalResult = finalResult && remoteResult; <line56> } <line57> } <line58> } finally { <line59> inProgress = false; <line60> } <line61> if (logger.isDebugEnabled()) { <line62> } <line63> } <line64> } <line65> "	<line3>, <line30>, <line43>, <line54>, <line62>
5752	public class A { <line0> public org.talend.mdm.webservice.WSRoutingOrderV2PK executeRoutingOrderV2Asynchronously( <line1> org.talend.mdm.webservice.WSExecuteRoutingOrderV2Asynchronously arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSRoutingOrderV2PK _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	<line2>
5753	public class A { <line0> private void update() { <line1> if (this.working) { <line2> return; <line3> } <line4> boolean state = isReady(); <line5> triggerUpdate(state); <line6> } <line7> } <line8> 	<line1>, <line2>
5754	"public class A { <line0> protected ClinicalDocument loadDocument(InputStream inputStream, Boolean skipValidation) { <line1> ClinicalDocument cd = null; <line2> try { <line3> cd = CDAUtil.load(inputStream); <line4> if (!skipValidation && !CDAUtil.validate(cd, new CDAValidationHandler())) { <line5> throw new ProcessException(""Failed to validate CDA document""); <line6> } <line7> } catch (Exception e) { <line8> throw new ProcessException(""Failed to load CDA document"", e); <line9> } <line10> return cd; <line11> } <line12> } <line13> "	<line5>, <line8>
5755	public class A { <line0> public void metaKeyDown() { <line1> if (metaKeyDown) return; <line2> newActions().keyDown(Keys.META).perform(); <line3> metaKeyDown = true; <line4> } <line5> } <line6> 	<line4>
5756	public class A { <line0> private static void handleLoopException(Throwable t) { <line1> try { <line2> Thread.sleep(1000); <line3> } catch (InterruptedException e) { <line4> } <line5> } <line6> } <line7> 	<line1>
5757	public class A { <line0> public boolean isSequenceDeployed(String backEndUrl, String sessionCookie, String sequenceName) <line1> throws SequenceEditorException, RemoteException { <line2> SequenceAdminServiceClient sequenceAdminServiceClient = <line3> new SequenceAdminServiceClient(backEndUrl, sessionCookie); <line4> boolean isSequenceExist = false; <line5> Calendar startTime = Calendar.getInstance(); <line6> long time; <line7> while ((time = (Calendar.getInstance().getTimeInMillis() - startTime.getTimeInMillis())) <line8> < SERVICE_DEPLOYMENT_DELAY) { <line9> String[] sequences = sequenceAdminServiceClient.getSequences(); <line10> if (sequences != null && sequences.length > 0) { <line11> for (String sequence : sequences) { <line12> if (sequence.equals(sequenceName)) { <line13> isSequenceExist = true; <line14> break; <line15> } <line16> } <line17> } <line18> if (isSequenceExist) { <line19> break; <line20> } <line21> try { <line22> Thread.sleep(500); <line23> } catch (InterruptedException e) { <line24> } <line25> } <line26> return isSequenceExist; <line27> } <line28> } <line29> 	<line4>, <line14>
5758	"public class A { <line0> @Override <line1> public void onAfterTransport(BootEvent event) { <line2> Microservice microservice = RegistrationManager.INSTANCE.getMicroservice(); <line3> String swaggerSchema = ""http""; <line4> for (String endpoint : microservice.getInstance().getEndpoints()) { <line5> if (endpoint.startsWith(""rest://"") && endpoint.indexOf(""sslEnabled=true"") > 0) { <line6> swaggerSchema = ""https""; <line7> } <line8> } <line9> MicroserviceMeta microserviceMeta = event.getScbEngine().getProducerMicroserviceMeta(); <line10> for (SchemaMeta schemaMeta : microserviceMeta.getSchemaMetas().values()) { <line11> Swagger swagger = schemaMeta.getSwagger(); <line12> swagger.addScheme(Scheme.forValue(swaggerSchema)); <line13> String content = SwaggerUtils.swaggerToString(swagger); <line14> RegistrationManager.INSTANCE.addSchema(schemaMeta.getSchemaId(), content); <line15> } <line16> saveBasePaths(microserviceMeta); <line17> } <line18> } <line19> "	<line14>
5759	public class A { <line0> public void write(byte[] data) throws Exception { <line1> if (debug && debugTX) { <line2> String dataString = StringUtil.byteArrayToIntString(data); <line3> } <line4> port.writeBytes(data); <line5> } <line6> } <line7> 	<line3>
5760	public class A { <line0> @Override <line1> protected final void disposeInternal() { <line2> disposePlannerInternal(); <line3> try { <line4> interceptDisposePlanner(); <line5> } catch (Exception t) { <line6> } <line7> super.disposeInternal(); <line8> } <line9> } <line10> 	<line6>
5761	"public class A { <line0> public void pushWithTopicsContext2() throws MessageException { <line1> TopicKey topicKey = new TopicKey(getTopicsContextAddress2()); <line2> getTopicsContext() <line3> .publish(topicKey, MessageFormat.format(""data from subtopic 2 #{0}"", ++update2)); <line4> } <line5> } <line6> "	<line4>
5762	"public class A { <line0> public synchronized Tag irodsFunctionIncludingAllDataInStream( <line1> final IRodsPI irodsPI, <line2> final long byteStreamLength, <line3> final InputStream byteStream, <line4> final ConnectionProgressStatusListener connectionProgressStatusListener) <line5> throws JargonException { <line6> if (irodsPI == null) { <line7> throw new IllegalArgumentException(""null irodsPI""); <line8> } <line9> if (byteStream == null) { <line10> throw new IllegalArgumentException(""null byteStream""); <line11> } <line12> try { <line13> int length = 0; <line14> String message = irodsPI.getParsedTags(); <line15> if (message != null) { <line16> length = message.getBytes(getEncoding()).length; <line17> } <line18> sendHeader(IRODSConstants.RODS_API_REQ, length, 0, byteStreamLength, irodsPI.getApiNumber()); <line19> irodsConnection.send(message); <line20> if (byteStreamLength > 0) { <line21> irodsConnection.send(byteStream, byteStreamLength, connectionProgressStatusListener); <line22> byteStream.close(); <line23> } else { <line24> irodsConnection.flush(); <line25> } <line26> } catch (UnsupportedEncodingException e) { <line27> throw new JargonException(e); <line28> } catch (IOException e) { <line29> disconnectWithForce(); <line30> throw new JargonException(e); <line31> } <line32> return readMessage(); <line33> } <line34> } <line35> "	<line12>, <line18>, <line24>, <line27>, <line29>, <line32>
5763	"public class A { <line0> private Set<StandardPredicate> loadData(DataStore dataStore) { <line1> Set<StandardPredicate> closedPredicates; <line2> try { <line3> String path = parsedOptions.getOptionValue(CommandLineLoader.OPTION_DATA); <line4> closedPredicates = <line5> DataLoader.load( <line6> dataStore, path, parsedOptions.hasOption(CommandLineLoader.OPTION_INT_IDS)); <line7> } catch (ConfigurationException | FileNotFoundException ex) { <line8> throw new RuntimeException(""Failed to load data."", ex); <line9> } <line10> return closedPredicates; <line11> } <line12> } <line13> "	<line1>, <line10>
5764	"public class A { <line0> public Object[] deserializeRecord() throws HyracksDataException { <line1> int start = <line2> frameTupleAccessor.getTupleStartOffset(tIndex) + frameTupleAccessor.getFieldSlotsLength(); <line3> bbis.setByteBuffer(buffer, start); <line4> Object[] record = new Object[recordDescriptor.getFieldCount()]; <line5> for (int i = 0; i < record.length; ++i) { <line6> Object instance = recordDescriptor.getFields()[i].deserialize(di); <line7> if (LOGGER.isTraceEnabled()) { <line8> } <line9> record[i] = instance; <line10> if (FrameConstants.DEBUG_FRAME_IO) { <line11> try { <line12> if (di.readInt() != FrameConstants.FRAME_FIELD_MAGIC) { <line13> throw new HyracksDataException(""Field magic mismatch""); <line14> } <line15> } catch (IOException e) { <line16> e.printStackTrace(); <line17> } <line18> } <line19> } <line20> if (LOGGER.isTraceEnabled()) { <line21> } <line22> ++tIndex; <line23> return record; <line24> } <line25> } <line26> "	<line8>, <line21>
5765	public class A { <line0> @NotNull <line1> private LoadedStream loadEpisode( <line2> @NotNull EpisodeId id, <line3> @NotNull AudioQualityPicker audioQualityPicker, <line4> boolean preload, <line5> @Nullable HaltListener haltListener) <line6> throws IOException, MercuryClient.MercuryException, CdnManager.CdnException { <line7> Metadata.Episode episode = session.api().getMetadata4Episode(id); <line8> if (episode.hasExternalUrl()) { <line9> return CdnFeedHelper.loadEpisodeExternal(session, episode, haltListener); <line10> } else { <line11> Metadata.AudioFile file = audioQualityPicker.getFile(episode.getAudioList()); <line12> if (file == null) { <line13> throw new FeederException(); <line14> } <line15> return loadStream(file, null, episode, preload, haltListener); <line16> } <line17> } <line18> } <line19> 	<line13>
5766	"public class A { <line0> @Test <line1> public void testGetUserInfo() throws Exception { <line2> final com.box.sdk.BoxUser.Info result = requestBody(""direct://GETUSERINFO"", testUser.getID()); <line3> assertNotNull(result, ""getUserInfo result""); <line4> } <line5> } <line6> "	<line4>
5767	public class A { <line0> @Override <line1> public void geoServerAddWorkspaceCommand( <line2> final org.locationtech.geowave.service.grpc.protobuf <line3> .GeoServerAddWorkspaceCommandParametersProtos <line4> request, <line5> final StreamObserver< <line6> org.locationtech.geowave.service.grpc.protobuf.GeoWaveReturnTypesProtos <line7> .StringResponseProtos> <line8> responseObserver) { <line9> final GeoServerAddWorkspaceCommand cmd = new GeoServerAddWorkspaceCommand(); <line10> final Map<FieldDescriptor, Object> m = request.getAllFields(); <line11> GeoWaveGrpcServiceCommandUtil.setGrpcToCommandFields(m, cmd); <line12> final File configFile = GeoWaveGrpcServiceOptions.geowaveConfigFile; <line13> final OperationParams params = new ManualOperationParams(); <line14> params.getContext().put(ConfigOptions.PROPERTIES_FILE_CONTEXT, configFile); <line15> cmd.prepare(params); <line16> try { <line17> final String result = cmd.computeResults(params); <line18> final StringResponseProtos resp = <line19> StringResponseProtos.newBuilder().setResponseValue(result).build(); <line20> responseObserver.onNext(resp); <line21> responseObserver.onCompleted(); <line22> } catch (final Exception e) { <line23> responseObserver.onError(e); <line24> } <line25> } <line26> } <line27> 	<line16>, <line23>
5768	public class A { <line0> static void runDefer(int top) { <line1> DeferStack<Runnable> sg = getNonExceptionStack(); <line2> int count = sg.size() - top; <line3> for (int i = 0; i < count; i++) { <line4> try { <line5> Runnable r = sg.pop(); <line6> r.run(); <line7> } catch (Throwable e) { <line8> } <line9> } <line10> } <line11> } <line12> 	<line8>
5769	"public class A { <line0> public SysExportZos findById(sernet.gs.reveng.SysExportZosId id) { <line1> try { <line2> SysExportZos instance = <line3> (SysExportZos) <line4> sessionFactory.getCurrentSession().get(""sernet.gs.reveng.SysExportZos"", id); <line5> if (instance == null) { <line6> } else { <line7> } <line8> return instance; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	<line1>, <line6>, <line7>, <line10>
5770	"public class A { <line0> public Future<Set<String>> resolveGroupMembers( <line1> final String tenantId, final Set<String> viaGroups, final SpanContext spanContext) { <line2> final Span span = <line3> TracingHelper.buildChildSpan( <line4> this.tracer, spanContext, ""resolve group members"", getClass().getSimpleName()) <line5> .withTag(TracingHelper.TAG_TENANT_ID, tenantId) <line6> .withTag(""via_groups"", String.join("", "", viaGroups)) <line7> .start(); <line8> final var expanded = <line9> this.resolveGroupsStatement.expand( <line10> params -> { <line11> params.put(""tenant_id"", tenantId); <line12> params.put(""group_ids"", convertToArrayValue(viaGroups)); <line13> }); <line14> return expanded <line15> .query(this.client) <line16> .flatMap( <line17> r -> { <line18> final var entries = r.getRows(true); <line19> span.log(Map.of(""event"", ""read result"", ""rows"", entries.size())); <line20> return Future.succeededFuture( <line21> entries.stream() <line22> .map(o -> o.getString(""device_id"")) <line23> .filter(Objects::nonNull) <line24> .collect(Collectors.toSet())); <line25> }) <line26> .onComplete(x -> span.finish()); <line27> } <line28> } <line29> "	<line14>, <line15>
5771	"public class A { <line0> private TestCaseExecutionData property_getFromHtml( <line1> TestCaseExecutionData testCaseExecutionData, <line2> TestCaseExecution tCExecution, <line3> TestCaseCountryProperties testCaseCountryProperty, <line4> boolean forceCalculation) { <line5> if (tCExecution.getAppTypeEngine().equals(Application.TYPE_APK) <line6> || tCExecution.getAppTypeEngine().equals(Application.TYPE_IPA) <line7> || tCExecution.getAppTypeEngine().equals(Application.TYPE_GUI)) { <line8> try { <line9> Identifier identifier = <line10> identifierService.convertStringToIdentifier(testCaseExecutionData.getValue1()); <line11> String valueFromHTML = <line12> this.webdriverService.getValueFromHTML(tCExecution.getSession(), identifier); <line13> if (valueFromHTML != null) { <line14> testCaseExecutionData.setValue(valueFromHTML); <line15> MessageEvent res = new MessageEvent(MessageEventEnum.PROPERTY_SUCCESS_HTML); <line16> res.setDescription( <line17> res.getDescription().replace(""%ELEMENT%"", testCaseExecutionData.getValue1())); <line18> res.setDescription(res.getDescription().replace(""%VALUE%"", valueFromHTML)); <line19> testCaseExecutionData.setPropertyResultMessage(res); <line20> } <line21> } catch (NoSuchElementException exception) { <line22> MessageEvent res = <line23> new MessageEvent(MessageEventEnum.PROPERTY_FAILED_HTML_ELEMENTDONOTEXIST); <line24> res.setDescription( <line25> res.getDescription().replace(""%ELEMENT%"", testCaseExecutionData.getValue1())); <line26> testCaseExecutionData.setPropertyResultMessage(res); <line27> } <line28> } else { <line29> MessageEvent res = new MessageEvent(MessageEventEnum.PROPERTY_FAILED_FEATURENOTSUPPORTED); <line30> res.setDescription(res.getDescription().replace(""%APPTYPE%"", tCExecution.getAppTypeEngine())); <line31> res.setDescription( <line32> res.getDescription().replace(""%PROPTYPE%"", testCaseExecutionData.getType())); <line33> } <line34> return testCaseExecutionData; <line35> } <line36> } <line37> "	<line22>
5772	"public class A { <line0> @GetMapping(RestApi.DOWNLOAD_ARCHIVE_UNIT + CommonConstants.PATH_ID) <line1> @Secured(ServicesData.ROLE_GET_ARCHIVE) <line2> public ResponseEntity<Resource> downloadObjectFromUnit( <line3> final @PathVariable(""id"") String id, <line4> final @RequestParam(""usage"") String usage, <line5> final @RequestParam(""version"") Integer version) { <line6> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line7> return archivesSearchExternalService.downloadObjectFromUnit(id, usage, version); <line8> } <line9> } <line10> "	<line6>
5773	public class A { <line0> public static boolean registerNewPublicEncodingProvider(Class<?> clazz, String functionName) { <line1> try { <line2> var method = clazz.getDeclaredMethod(functionName, String.class, String.class); <line3> if (!Modifier.isStatic(method.getModifiers())) return false; <line4> if (!method.getReturnType().isAssignableFrom(PublicKey.class)) return false; <line5> externalPublicProviders.add(method); <line6> return true; <line7> } catch (NoSuchMethodException | SecurityException e) { <line8> return false; <line9> } <line10> } <line11> } <line12> 	<line8>
5774	"public class A { <line0> public void destroy() throws CrafterException { <line1> boolean locked; <line2> try { <line3> locked = shutdownLock.tryLock(shutdownTimeout, TimeUnit.MINUTES); <line4> try { <line5> if (!locked) { <line6> } else { <line7> } <line8> state = State.DESTROYED; <line9> publishEvent(new SiteContextDestroyedEvent(this)); <line10> maintenanceTaskExecutor.shutdownNow(); <line11> storeService.destroyContext(context); <line12> if (scheduler != null) { <line13> try { <line14> scheduler.shutdown(); <line15> } catch (SchedulerException e) { <line16> throw new CrafterException(""Unable to shutdown scheduler"", e); <line17> } <line18> } <line19> if (applicationContext != null) { <line20> try { <line21> applicationContext.close(); <line22> } catch (Exception e) { <line23> throw new CrafterException(""Unable to close application context"", e); <line24> } <line25> } <line26> if (classLoader != null) { <line27> try { <line28> classLoader.close(); <line29> } catch (Exception e) { <line30> throw new CrafterException(""Unable to close class loader"", e); <line31> } <line32> } <line33> } catch (Exception e) { <line34> } finally { <line35> if (locked) { <line36> shutdownLock.unlock(); <line37> } <line38> } <line39> } catch (InterruptedException e) { <line40> throw new CrafterException(""Unable to destroy context"", e); <line41> } <line42> } <line43> } <line44> "	<line3>, <line6>, <line7>, <line34>, <line36>
5775	public class A { <line0> private void initListenersOnWorker(WorkerState workerState) { <line1> CreatedListener createdListener = <line2> new CreatedListener() { <line3> @Override <line4> public void created(Object key, Object value) { <line5> if (sleepTime > 0) Utils.sleep(sleepTime); <line6> if (key instanceof TimestampKey) { <line7> statistics <line8> .message() <line9> .times(((TimestampKey) key).getTimestamp(), TimeService.currentTimeMillis()) <line10> .record(CREATED); <line11> } <line12> } <line13> }; <line14> workerState.put(CREATED.name, createdListener); <line15> EvictedListener evictedListener = <line16> new EvictedListener() { <line17> @Override <line18> public void evicted(Object key, Object value) { <line19> if (sleepTime > 0) Utils.sleep(sleepTime); <line20> if (key instanceof TimestampKey) { <line21> statistics <line22> .message() <line23> .times(((TimestampKey) key).getTimestamp(), TimeService.currentTimeMillis()) <line24> .record(EVICTED); <line25> } <line26> } <line27> }; <line28> workerState.put(EVICTED.name, evictedListener); <line29> RemovedListener removedListener = <line30> new RemovedListener() { <line31> @Override <line32> public void removed(Object key, Object value) { <line33> if (sleepTime > 0) Utils.sleep(sleepTime); <line34> if (key instanceof TimestampKey) { <line35> statistics <line36> .message() <line37> .times(((TimestampKey) key).getTimestamp(), TimeService.currentTimeMillis()) <line38> .record(REMOVED); <line39> } <line40> } <line41> }; <line42> workerState.put(REMOVED.name, removedListener); <line43> UpdatedListener updatedListener = <line44> new UpdatedListener() { <line45> @Override <line46> public void updated(Object key, Object value) { <line47> if (sleepTime > 0) Utils.sleep(sleepTime); <line48> if (key instanceof TimestampKey) { <line49> statistics <line50> .message() <line51> .times(((TimestampKey) key).getTimestamp(), TimeService.currentTimeMillis()) <line52> .record(UPDATED); <line53> } <line54> } <line55> }; <line56> workerState.put(UPDATED.name, updatedListener); <line57> ExpiredListener expiredListener = <line58> new ExpiredListener() { <line59> @Override <line60> public void expired(Object key, Object value) { <line61> if (sleepTime > 0) Utils.sleep(sleepTime); <line62> if (key instanceof TimestampKey) { <line63> statistics <line64> .message() <line65> .times(((TimestampKey) key).getTimestamp(), TimeService.currentTimeMillis()) <line66> .record(EXPIRED); <line67> } <line68> } <line69> }; <line70> workerState.put(EXPIRED.name, expiredListener); <line71> } <line72> } <line73> 	<line12>, <line26>, <line40>, <line54>, <line68>
5776	public class A { <line0> @Override <line1> public DataSmResult onAcceptDataSm(DataSm dataSm, Session source) throws ProcessRequestException { <line2> MessageId messageId = messageIDGenerator.newMessageId(); <line3> OptionalParameter.Message_payload messagePayload = <line4> (OptionalParameter.Message_payload) <line5> dataSm.getOptionalParameter(OptionalParameter.Tag.MESSAGE_PAYLOAD); <line6> requestCounter.incrementAndGet(); <line7> DataSmResult dataSmResult = new DataSmResult(messageId, new OptionalParameter[] {}); <line8> return dataSmResult; <line9> } <line10> } <line11> 	<line6>
5777	public class A { <line0> @Override <line1> public void before(Object target, Object arg0) { <line2> final InterceptorScopeInvocation transaction = scope.getCurrentInvocation(); <line3> if (transaction.tryEnter(policy)) { <line4> try { <line5> this.interceptor.before(target, arg0); <line6> } catch (Throwable t) { <line7> exceptionHandler.handleException(t); <line8> } <line9> } else { <line10> if (debugEnabled) { <line11> } <line12> } <line13> } <line14> } <line15> 	<line11>
5778	public class A { <line0> protected boolean handleRequestInternal(HttpServletRequest req, HttpServletResponse resp) <line1> throws IOException { <line2> if (BEANS.get(ServletFilterHelper.class).redirectIncompleteBasePath(req, resp, true)) { <line3> return true; <line4> } <line5> long start = System.nanoTime(); <line6> try { <line7> if (!PathValidator.isValid(req.getPathInfo())) { <line8> resp.sendError(HttpServletResponse.SC_BAD_REQUEST); <line9> return true; <line10> } <line11> for (IUiServletRequestHandler handler : handlers) { <line12> if (handler.handle(req, resp)) { <line13> return true; <line14> } <line15> } <line16> return false; <line17> } catch (Exception t) { <line18> resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); <line19> return true; <line20> } finally { <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> } <line24> } <line25> } <line26> 	<line8>, <line11>, <line18>, <line22>
5779	"public class A { <line0> static HTTPAuthNTokens getHTTPCredentials( <line1> String authorizationHeader, Logger log, boolean urlEncoded) { <line2> if (authorizationHeader == null) return null; <line3> if (!authorizationHeader.startsWith(""Basic "")) return null; <line4> String encoded = authorizationHeader.substring(6); <line5> String decoded = <line6> new String( <line7> Base64.decode(encoded.getBytes(StandardCharsets.US_ASCII)), StandardCharsets.US_ASCII); <line8> if (decoded.isEmpty()) { <line9> return null; <line10> } <line11> int colon = decoded.indexOf(':'); <line12> String[] split; <line13> if (colon == -1) { <line14> split = new String[] {decoded}; <line15> } else { <line16> if (colon < decoded.length() - 1) <line17> split = new String[] {decoded.substring(0, colon), decoded.substring(colon + 1)}; <line18> else split = new String[] {decoded.substring(0, colon), """"}; <line19> } <line20> String username = urlDecodeIfNeeded(split[0], urlEncoded); <line21> String secret = split.length == 1 ? null : urlDecodeIfNeeded(split[1], urlEncoded); <line22> return new HTTPAuthNTokens(username, secret); <line23> } <line24> } <line25> "	<line9>
5780	public class A { <line0> @Override <line1> public Boolean addFavoriteStation(RadioStation newFavoriteStation) throws ApplicationException { <line2> throw new UnsupportedOperationException(); <line3> } <line4> } <line5> 	<line2>
5781	"public class A { <line0> private List<InputType> generateInput(String key, String value) { <line1> List<InputType> inputs = New.list(); <line2> String[] values = new String[] {value}; <line3> if (""BBOX"".equalsIgnoreCase(key)) { <line4> values = value.split("" ""); <line5> } else if (""FILTER"".equalsIgnoreCase(key)) { <line6> try { <line7> values[0] = FilterCreator.bboxToFilterString(value); <line8> } catch (IllegalArgumentException | JAXBException e) { <line9> } <line10> } <line11> for (String aValue : values) { <line12> InputType input = new InputType(); <line13> CodeType inputIdentifier = new CodeType(); <line14> inputIdentifier.setValue(key); <line15> input.setIdentifier(inputIdentifier); <line16> DataType data = new DataType(); <line17> LiteralDataType literal = new LiteralDataType(); <line18> literal.setValue(aValue); <line19> data.setLiteralData(literal); <line20> input.setData(data); <line21> inputs.add(input); <line22> } <line23> return inputs; <line24> } <line25> } <line26> "	<line9>
5782	public class A { <line0> public synchronized void setBitstring(@Nonnull String aspect, @Nonnull String bitString) { <line1> if (aspectToOutput.containsKey(aspect)) { <line2> aspectToOutput.remove(aspect); <line3> } <line4> char[] bitArray = bitString.toCharArray(); <line5> aspectToOutput.put(aspect, bitArray); <line6> } <line7> } <line8> 	<line2>
5783	"public class A { <line0> public static StatelessBootstrap bootstrap( <line1> final StatelessEngineConfiguration engineConfiguration, final ClassLoader rootClassLoader) <line2> throws IOException { <line3> final File narDirectory = engineConfiguration.getNarDirectory(); <line4> final File workingDirectory = engineConfiguration.getWorkingDirectory(); <line5> if (!workingDirectory.exists() && !workingDirectory.mkdirs()) { <line6> throw new IOException( <line7> ""Working Directory "" + workingDirectory + "" does not exist and could not be created""); <line8> } <line9> final Bundle systemBundle = <line10> SystemBundle.create(narDirectory.getAbsolutePath(), ClassLoader.getSystemClassLoader()); <line11> final File frameworkWorkingDir = new File(workingDirectory, ""nifi-framework""); <line12> final File extensionsWorkingDir = new File(workingDirectory, ""extensions""); <line13> final List<Path> narDirectories = Collections.singletonList(narDirectory.toPath()); <line14> final long unpackStart = System.currentTimeMillis(); <line15> final Predicate<BundleCoordinate> narFilter = coordinate -> true; <line16> NarUnpackLock.lock(); <line17> try { <line18> NarUnpacker.unpackNars( <line19> systemBundle, <line20> frameworkWorkingDir, <line21> extensionsWorkingDir, <line22> null, <line23> narDirectories, <line24> false, <line25> NarClassLoaders.FRAMEWORK_NAR_ID, <line26> false, <line27> false, <line28> narFilter); <line29> } finally { <line30> NarUnpackLock.unlock(); <line31> } <line32> final long unpackMillis = System.currentTimeMillis() - unpackStart; <line33> final File statelessNarWorkingDir = locateStatelessNarWorkingDirectory(extensionsWorkingDir); <line34> final File statelessNarInf = new File(statelessNarWorkingDir, ""NAR-INF""); <line35> final File statelessNarDependencies = new File(statelessNarInf, ""bundled-dependencies""); <line36> final File[] statelessNarContents = statelessNarDependencies.listFiles(); <line37> if (statelessNarContents == null || statelessNarContents.length == 0) { <line38> throw new IOException( <line39> ""Could not access contents of Stateless NAR dependencies at "" + statelessNarDependencies); <line40> } <line41> final URL[] urls = new URL[statelessNarContents.length]; <line42> for (int i = 0; i < statelessNarContents.length; i++) { <line43> final File dependency = statelessNarContents[i]; <line44> final URL url = dependency.toURI().toURL(); <line45> urls[i] = url; <line46> } <line47> final URLClassLoader statelessClassLoader = new URLClassLoader(urls, rootClassLoader); <line48> Thread.currentThread().setContextClassLoader(statelessClassLoader); <line49> return new StatelessBootstrap(statelessClassLoader, engineConfiguration); <line50> } <line51> } <line52> "	<line33>
5784	public class A { <line0> public void addSeenUrl(String url, int docId) { <line1> String canonicalUrl = URLCanonicalizer.getCanonicalURL(url); <line2> if (canonicalUrl == null) { <line3> } else { <line4> try { <line5> docIdServer.addUrlAndDocId(canonicalUrl, docId); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line3>, <line7>
5785	public class A { <line0> public void addPart(final Part part) { <line1> parameters.add(part); <line2> } <line3> } <line4> 	<line1>
5786	"public class A { <line0> public boolean checkReferrer(HttpServletRequest request) { <line1> SystemConfigsDao dao = SystemConfigsDao.get(); <line2> SystemConfigsEntity config = <line3> dao.selectOnKey(WebConfig.KEY_SYSTEM_URL, AppConfig.get().getSystemName()); <line4> if (config == null) { <line5> return true; <line6> } <line7> String url = config.getConfigValue(); <line8> String referrer = request.getHeader(""REFERER""); <line9> if (StringUtils.isNotEmpty(referrer) && referrer.startsWith(url)) { <line10> return true; <line11> } <line12> return false; <line13> } <line14> } <line15> "	<line12>
5787	public class A { <line0> private void validateCron(String cron) { <line1> try { <line2> CronExpression.validateExpression(cron); <line3> } catch (ParseException e) { <line4> throw new JobException(e); <line5> } <line6> } <line7> } <line8> 	<line4>
5788	"public class A { <line0> @Override <line1> public void get(ServiceContext ctx, String id, DocumentHandler handler) <line2> throws DocumentNotFoundException, DocumentException { <line3> DocumentFilter docFilter = handler.getDocumentFilter(); <line4> if (docFilter == null) { <line5> docFilter = handler.createDocumentFilter(); <line6> } <line7> JPATransactionContext jpaConnectionContext = (JPATransactionContext) ctx.openConnection(); <line8> try { <line9> handler.prepare(Action.GET); <line10> Object o = null; <line11> String whereClause = "" where id = :id""; <line12> HashMap<String, Object> params = new HashMap<String, Object>(); <line13> params.put(""id"", id); <line14> o = <line15> JpaStorageUtils.getEntity( <line16> ""org.collectionspace.services.account.Tenant"", whereClause, params); <line17> if (null == o) { <line18> String msg = ""Could not find entity with id="" + id; <line19> throw new DocumentNotFoundException(msg); <line20> } <line21> DocumentWrapper<Object> wrapDoc = new DocumentWrapperImpl<Object>(o); <line22> handler.handle(Action.GET, wrapDoc); <line23> handler.complete(Action.GET, wrapDoc); <line24> } catch (DocumentException de) { <line25> throw de; <line26> } catch (Exception e) { <line27> if (logger.isDebugEnabled()) { <line28> } <line29> throw new DocumentException(e); <line30> } finally { <line31> ctx.closeConnection(); <line32> } <line33> } <line34> } <line35> "	<line28>
5789	public class A { <line0> @Override <line1> public ExecutionResults execute(CommandContext ctx) throws InterruptedException { <line2> Thread.sleep(10000L); <line3> ExecutionResults executionResults = new ExecutionResults(); <line4> return executionResults; <line5> } <line6> } <line7> 	<line2>, <line3>
5790	"public class A { <line0> @RequestMapping( <line1> value = ""/run"", <line2> method = {RequestMethod.POST, RequestMethod.PUT}) <line3> @PreAuthorize(""hasRole('ALL') or hasRole('F_PREDICTOR_RUN')"") <line4> public void runPredictors( <line5> @RequestParam Date startDate, <line6> @RequestParam Date endDate, <line7> TranslateParams translateParams, <line8> HttpServletRequest request, <line9> HttpServletResponse response) <line10> throws Exception { <line11> int count = 0; <line12> List<Predictor> allPredictors = predictorService.getAllPredictors(); <line13> for (Predictor predictor : allPredictors) { <line14> try { <line15> PredictionSummary predictionSummary = new PredictionSummary(); <line16> predictionService.predict(predictor, startDate, endDate, predictionSummary); <line17> count += predictionSummary.getPredictions(); <line18> } catch (Exception ex) { <line19> webMessageService.send( <line20> WebMessageUtils.conflict(""Unable to predict "" + predictor.getName(), ex.getMessage()), <line21> response, <line22> request); <line23> return; <line24> } <line25> } <line26> webMessageService.send( <line27> WebMessageUtils.ok(""Generated "" + count + "" predictions""), response, request); <line28> } <line29> } <line30> "	<line19>
5791	"public class A { <line0> @PayloadRoot( <line1> localPart = ""UpdateDeviceSslCertificationRequest"", <line2> namespace = DEVICE_MANAGEMENT_NAMESPACE) <line3> @ResponsePayload <line4> public UpdateDeviceSslCertificationAsyncResponse updateDeviceSslCertification( <line5> @OrganisationIdentification final String organisationIdentification, <line6> @RequestPayload final UpdateDeviceSslCertificationRequest request, <line7> @MessagePriority final String messagePriority) <line8> throws OsgpException { <line9> final UpdateDeviceSslCertificationAsyncResponse response = <line10> new UpdateDeviceSslCertificationAsyncResponse(); <line11> try { <line12> final Certification certification = <line13> this.deviceManagementMapper.map(request.getCertification(), Certification.class); <line14> final String correlationUid = <line15> this.deviceManagementService.enqueueUpdateDeviceSslCertificationRequest( <line16> organisationIdentification, <line17> request.getDeviceIdentification(), <line18> certification, <line19> MessagePriorityEnum.getMessagePriority(messagePriority)); <line20> final AsyncResponse asyncResponse = new AsyncResponse(); <line21> asyncResponse.setCorrelationUid(correlationUid); <line22> asyncResponse.setDeviceId(request.getDeviceIdentification()); <line23> response.setAsyncResponse(asyncResponse); <line24> } catch (final ConstraintViolationException e) { <line25> throw new FunctionalException( <line26> FunctionalExceptionType.VALIDATION_ERROR, <line27> ComponentType.WS_CORE, <line28> new ValidationException(e.getConstraintViolations())); <line29> } catch (final Exception e) { <line30> this.handleException(e); <line31> } <line32> return response; <line33> } <line34> } <line35> "	<line9>
5792	public class A { <line0> private void sendTimeoutNowRequest(int transferee) throws TransportException { <line1> TimeoutNowRequest request = new TimeoutNowRequest(topicPartitionGroup, currentTerm); <line2> JoyQueueHeader header = <line3> new JoyQueueHeader(Direction.REQUEST, CommandType.RAFT_TIMEOUT_NOW_REQUEST); <line4> sendCommand( <line5> getReplica(transferee).getAddress(), <line6> new Command(header, request), <line7> electionConfig.getSendCommandTimeout(), <line8> new TimeoutNowRequestCallback()); <line9> } <line10> } <line11> 	<line1>
5793	"public class A { <line0> @Override <line1> public CreateVfModuleResponse createVfModule(String aaiVnfId, CreateVfModuleRequest req) <line2> throws VnfAdapterClientException { <line3> try { <line4> return new AdapterRestClient(this.props, this.getUri(""/"" + aaiVnfId + ""/vf-modules"").build()) <line5> .post(req, CreateVfModuleResponse.class); <line6> } catch (InternalServerErrorException e) { <line7> throw new VnfAdapterClientException(e.getMessage()); <line8> } <line9> } <line10> } <line11> "	<line7>
5794	"public class A { <line0> private String extractContextKey(WebappLoader webappLoader) { <line1> final String defaultContextName = """"; <line2> try { <line3> Container container = extractContext(webappLoader); <line4> if (container instanceof Context) { <line5> Context context = (Context) container; <line6> String contextName = context.getName(); <line7> Host host = (Host) container.getParent(); <line8> Engine engine = (Engine) host.getParent(); <line9> StringBuilder sb = new StringBuilder(); <line10> sb.append(engine.getName()).append(""/"").append(host.getName()); <line11> if (!contextName.startsWith(""/"")) { <line12> sb.append('/'); <line13> } <line14> sb.append(contextName); <line15> return sb.toString(); <line16> } <line17> } catch (Exception e) { <line18> } <line19> return defaultContextName; <line20> } <line21> } <line22> "	<line18>
5795	public class A { <line0> private void addRemoveStatements(Set<Statement> toAdd, Set<Statement> toRemove) <line1> throws IOException { <line2> luceneIndex.begin(); <line3> try { <line4> luceneIndex.addRemoveStatements(toAdd, toRemove); <line5> luceneIndex.commit(); <line6> } catch (IOException e) { <line7> luceneIndex.rollback(); <line8> throw e; <line9> } <line10> } <line11> } <line12> 	<line2>, <line7>
5796	"public class A { <line0> private boolean save(LocalDocument d, boolean partialUpdate) throws IOException, JsonException { <line1> boolean hasId = d.getID() != null; <line2> String s; <line3> long start = System.currentTimeMillis(); <line4> if (partialUpdate) { <line5> s = d.modifiedFieldsToJson(); <line6> } else { <line7> s = d.toJson(); <line8> } <line9> long startPost = System.currentTimeMillis(); <line10> HttpResponse response = core.post(getWriteUrl(partialUpdate), s); <line11> if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { <line12> if (!hasId) { <line13> LocalDocument updated = new LocalDocument(EntityUtils.toString(response.getEntity())); <line14> d.putAll(updated); <line15> } else { <line16> EntityUtils.consume(response.getEntity()); <line17> } <line18> if (isPerformanceLogging()) { <line19> long end = System.currentTimeMillis(); <line20> DocumentID<Local> docId = d.getID(); <line21> } <line22> return true; <line23> } <line24> logUnexpected(""save(partial="" + partialUpdate + "")"", response); <line25> return false; <line26> } <line27> } <line28> "	<line21>
5797	public class A { <line0> private boolean checkCountry(TestCaseExecution tCExecution) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> if (testCaseCountryService.exist( <line4> tCExecution.getTest(), tCExecution.getTestCase(), tCExecution.getCountry())) { <line5> return true; <line6> } else { <line7> message = new MessageGeneral(MessageGeneralEnum.VALIDATION_FAILED_COUNTRY_NOTDEFINED); <line8> return false; <line9> } <line10> } <line11> } <line12> 	<line2>
5798	"public class A { <line0> public static int getCPInstancesCount(HttpPrincipal httpPrincipal, long groupId, int status) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> CPInstanceServiceUtil.class, <line6> ""getCPInstancesCount"", <line7> _getCPInstancesCountParameterTypes13); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, status); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> return ((Integer) returnObj).intValue(); <line19> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	<line20>
5799	"public class A { <line0> @Test <line1> public void test04NumberFilter() { <line2> filterAndCheck( <line3> service.things(), <line4> ""properties/int eq "" + THINGS.get(2).getProperties().get(""int""), <line5> getFromList(THINGS, 2)); <line6> filterAndCheck( <line7> service.observations(), <line8> ""parameters/int eq "" + OBSERVATIONS.get(2).getParameters().get(""int""), <line9> getFromList(OBSERVATIONS, 2)); <line10> filterAndCheck(service.things(), ""properties/int gt 9"", getFromList(THINGS, 2, 3)); <line11> filterAndCheck( <line12> service.observations(), ""parameters/int gt 8"", getFromList(OBSERVATIONS, 9, 10, 11, 12)); <line13> filterAndCheck(service.things(), ""properties/int lt 9"", getFromList(THINGS, 0)); <line14> filterAndCheck( <line15> service.observations(), <line16> ""parameters/int lt 8"", <line17> getFromList(OBSERVATIONS, 0, 1, 2, 3, 4, 5, 6, 7)); <line18> filterAndCheck(service.things(), ""properties/intArray[1] gt 10"", getFromList(THINGS, 2, 3)); <line19> filterAndCheck( <line20> service.observations(), <line21> ""parameters/intArray[1] gt 9"", <line22> getFromList(OBSERVATIONS, 9, 10, 11, 12)); <line23> filterAndCheck(service.things(), ""properties/intArray[1] lt 10"", getFromList(THINGS, 0)); <line24> filterAndCheck( <line25> service.observations(), <line26> ""parameters/intArray[1] lt 9"", <line27> getFromList(OBSERVATIONS, 0, 1, 2, 3, 4, 5, 6, 7)); <line28> filterAndCheck( <line29> service.things(), ""properties/intIntArray[1][0] gt 10"", getFromList(THINGS, 2, 3)); <line30> filterAndCheck( <line31> service.observations(), <line32> ""parameters/intIntArray[1][0] gt 9"", <line33> getFromList(OBSERVATIONS, 9, 10, 11, 12)); <line34> filterAndCheck( <line35> service.things(), ""properties/objArray[1]/intArray[0] gt 10"", getFromList(THINGS, 2, 3)); <line36> filterAndCheck( <line37> service.observations(), <line38> ""parameters/objArray[1]/intArray[0] gt 9"", <line39> getFromList(OBSERVATIONS, 9, 10, 11, 12)); <line40> } <line41> } <line42> "	<line2>
5800	"public class A { <line0> public static Collection<Class<?>> discover(final String scanPath) { <line1> if (StringUtils.isBlank(scanPath)) { <line2> throw new IllegalStateException(""Please specify the [scanPath]""); <line3> } <line4> final Collection<Class<?>> ret = new HashSet<>(); <line5> final String[] splitPaths = scanPath.split("",""); <line6> final String[] paths = ArrayUtils.concatenate(splitPaths, BUILT_IN_COMPONENT_PKGS); <line7> final Set<URL> urls = new LinkedHashSet<>(); <line8> for (String path : paths) { <line9> path = path.replaceAll(""\\."", ""/"") + ""/**/*.class""; <line10> urls.addAll(ClassPathResolver.getResources(path)); <line11> } <line12> try { <line13> for (final URL url : urls) { <line14> final DataInputStream classInputStream = new DataInputStream(url.openStream()); <line15> final ClassFile classFile = new ClassFile(classInputStream); <line16> final String className = classFile.getName(); <line17> final AnnotationsAttribute annotationsAttribute = <line18> (AnnotationsAttribute) classFile.getAttribute(AnnotationsAttribute.visibleTag); <line19> if (null == annotationsAttribute) { <line20> LOGGER.log(Level.TRACE, ""The class [name={}] is not a bean"", className); <line21> continue; <line22> } <line23> final ConstPool constPool = classFile.getConstPool(); <line24> final Annotation[] annotations = annotationsAttribute.getAnnotations(); <line25> boolean maybeBeanClass = false; <line26> for (final Annotation annotation : annotations) { <line27> final String typeName = annotation.getTypeName(); <line28> if (typeName.equals(Singleton.class.getName())) { <line29> maybeBeanClass = true; <line30> break; <line31> } <line32> if (typeName.equals(Service.class.getName()) <line33> || typeName.equals(Repository.class.getName())) { <line34> final Annotation singletonAnnotation = <line35> new Annotation(Singleton.class.getName(), constPool); <line36> annotationsAttribute.addAnnotation(singletonAnnotation); <line37> classFile.addAttribute(annotationsAttribute); <line38> classFile.setVersionToJava5(); <line39> maybeBeanClass = true; <line40> break; <line41> } <line42> } <line43> if (maybeBeanClass) { <line44> Class<?> clz = null; <line45> try { <line46> clz = Thread.currentThread().getContextClassLoader().loadClass(className); <line47> } catch (final ClassNotFoundException e) { <line48> LOGGER.log(Level.ERROR, ""Loads class ["" + className + ""] failed"", e); <line49> } <line50> ret.add(clz); <line51> } <line52> } <line53> } catch (final Exception e) { <line54> LOGGER.log(Level.ERROR, ""Load classes failed"", e); <line55> } <line56> return ret; <line57> } <line58> } <line59> "	<line4>
5801	"public class A { <line0> @Test(enabled = false) <line1> public void testRandomIdRandomness() { <line2> int collisionTestCnt = 100000; <line3> int sampleSize = 2000; <line4> int duplicateTests = 0; <line5> for (int testIdx = 0; testIdx < collisionTestCnt; testIdx++) { <line6> Set<String> randomIds = new HashSet<String>(); <line7> for (int sampleCnt = 0; sampleCnt < sampleSize; sampleCnt++) { <line8> if (!randomIds.add(Identifiers.makeRandomId(4))) { <line9> duplicateTests++; <line10> break; <line11> } <line12> } <line13> } <line14> double probability = ((double) duplicateTests) * 100 / collisionTestCnt; <line15> Assert.assertEquals( <line16> probability, <line17> 15, <line18> 0.5d, <line19> ""Expected probability of collision with id of length 4 and 2000 samples is 15%.""); <line20> } <line21> } <line22> "	<line15>
5802	"public class A { <line0> public static List<String> generate( <line1> int recordCount, long startTime, long endTime, String tableName, String prj) { <line2> Preconditions.checkArgument(startTime < endTime); <line3> Preconditions.checkArgument(recordCount > 0); <line4> KylinConfig kylinConfig = KylinConfig.getInstanceFromEnv(); <line5> TableDesc tableDesc = <line6> TableMetadataManager.getInstance(kylinConfig).getTableDesc(tableName, prj); <line7> SortedMultiset<Long> times = TreeMultiset.create(); <line8> Random r = new Random(); <line9> for (int i = 0; i < recordCount; i++) { <line10> long t = startTime + (long) ((endTime - startTime) * r.nextDouble()); <line11> times.add(t); <line12> } <line13> List<String> ret = Lists.newArrayList(); <line14> HashMap<String, String> kvs = Maps.newHashMap(); <line15> HashMap<String, Integer> itemCategory = Maps.newHashMap(); <line16> for (long time : times) { <line17> kvs.clear(); <line18> kvs.put(COLUMN_TIMESTAMP, String.valueOf(time)); <line19> for (ColumnDesc columnDesc : tableDesc.getColumns()) { <line20> String lowerCaseColumnName = columnDesc.getName().toLowerCase(Locale.ROOT); <line21> DataType dataType = columnDesc.getType(); <line22> if (dataType.isDateTimeFamily()) { <line23> continue; <line24> } else if (dataType.isStringFamily()) { <line25> char c = (char) ('A' + (int) (26 * r.nextDouble())); <line26> kvs.put(lowerCaseColumnName, String.valueOf(c)); <line27> } else if (dataType.isIntegerFamily()) { <line28> int v; <line29> if (COLUMN_CATEGORY.equals(lowerCaseColumnName)) { <line30> String itm = kvs.get(COLUMN_ITEM); <line31> if (itemCategory.get(itm) == null) { <line32> v = r.nextInt(10); <line33> itemCategory.put(itm, v); <line34> } else { <line35> v = itemCategory.get(itm); <line36> } <line37> } else { <line38> v = r.nextInt(10000); <line39> } <line40> kvs.put(lowerCaseColumnName, String.valueOf(v)); <line41> } else if (dataType.isNumberFamily()) { <line42> String v = String.format(Locale.ROOT, ""%.4f"", r.nextDouble() * 100); <line43> kvs.put(lowerCaseColumnName, v); <line44> } <line45> } <line46> try { <line47> ret.add(mapper.writeValueAsString(kvs)); <line48> } catch (JsonProcessingException e) { <line49> } <line50> } <line51> return ret; <line52> } <line53> } <line54> "	<line49>
5803	"public class A { <line0> private Object unionToMongo( <line1> final String docf, <line2> final Schema fieldSchema, <line3> final DocumentFieldType storeType, <line4> final Object value) { <line5> Object result; <line6> Type type0 = fieldSchema.getTypes().get(0).getType(); <line7> Type type1 = fieldSchema.getTypes().get(1).getType(); <line8> if (!type0.equals(type1) && (type0.equals(Type.NULL) || type1.equals(Type.NULL))) { <line9> Schema innerSchema = fieldSchema.getTypes().get(1); <line10> result = toDocument(docf, innerSchema, type1, storeType, value); <line11> } else { <line12> throw new IllegalStateException( <line13> ""MongoStore doesn't support 3 types union field yet. Please update your mapping""); <line14> } <line15> return result; <line16> } <line17> } <line18> "	<line10>
5804	public class A { <line0> @Override <line1> public void terminate( <line2> BatchRunContext batchRunContext, <line3> List<String> all, <line4> long errors, <line5> long unhandled_errors, <line6> long total, <line7> long processed) { <line8> long success = total - errors - unhandled_errors; <line9> if (errors > 0) { <line10> } <line11> if (unhandled_errors > 0) { <line12> } <line13> } <line14> } <line15> 	<line9>, <line10>, <line12>, <line13>
5805	public class A { <line0> public void start() throws Exception { <line1> m_started = true; <line2> } <line3> } <line4> 	<line1>
5806	"public class A { <line0> public void activate(boolean b) { <line1> if (b) { <line2> if (myThread == null) { <line3> active = true; <line4> myThread = <line5> new Thread(this, String.format(""%s.%s.checkpoint"", watchDogTimerName, checkPointName)); <line6> myThread.start(); <line7> } <line8> } else { <line9> if (myThread != null) { <line10> active = false; <line11> myThread = null; <line12> } <line13> } <line14> } <line15> } <line16> "	<line3>
5807	public class A { <line0> protected void handleAspUp(ASPUp aspUp) { <line1> if (aspFactoryImpl.getFunctionality() == Functionality.SGW <line2> || (aspFactoryImpl.getFunctionality() == Functionality.AS <line3> && aspFactoryImpl.getExchangeType() == ExchangeType.DE) <line4> || (aspFactoryImpl.getFunctionality() == Functionality.IPSP <line5> && aspFactoryImpl.getExchangeType() == ExchangeType.DE) <line6> || (aspFactoryImpl.getFunctionality() == Functionality.IPSP <line7> && aspFactoryImpl.getExchangeType() == ExchangeType.SE <line8> && aspFactoryImpl.getIpspType() == IPSPType.SERVER)) { <line9> ASPUpAck aspUpAck = <line10> (ASPUpAck) <line11> this.aspFactoryImpl.messageFactory.createMessage( <line12> MessageClass.ASP_STATE_MAINTENANCE, MessageType.ASP_UP_ACK); <line13> ASPIdentifier aspId = aspUp.getASPIdentifier(); <line14> aspUpAck.setASPIdentifier(aspId); <line15> this.aspFactoryImpl.write(aspUpAck); <line16> for (FastList.Node<Asp> n = this.aspFactoryImpl.aspList.head(), <line17> end = this.aspFactoryImpl.aspList.tail(); <line18> (n = n.getNext()) != end; ) { <line19> AspImpl aspImpl = (AspImpl) n.getValue(); <line20> aspImpl.setASPIdentifier(aspUp.getASPIdentifier()); <line21> FSM aspPeerFSM = aspImpl.getPeerFSM(); <line22> if (aspPeerFSM == null) { <line23> return; <line24> } <line25> if (AspState.getState(aspPeerFSM.getState().getName()) == AspState.ACTIVE) { <line26> ErrorCode errorCodeObj = <line27> this.aspFactoryImpl.parameterFactory.createErrorCode(ErrorCode.Unexpected_Message); <line28> this.sendError(aspImpl.getAs().getRoutingContext(), errorCodeObj); <line29> } <line30> try { <line31> aspPeerFSM.setAttribute(FSM.ATTRIBUTE_MESSAGE, aspUp); <line32> aspPeerFSM.signal(TransitionState.ASP_UP); <line33> FSM asLocalFSM = ((AsImpl) aspImpl.getAs()).getLocalFSM(); <line34> asLocalFSM.setAttribute(AsImpl.ATTRIBUTE_ASP, aspImpl); <line35> asLocalFSM.signal(TransitionState.ASP_UP); <line36> } catch (UnknownTransitionException e) { <line37> } <line38> } <line39> } else { <line40> ErrorCode errorCodeObj = <line41> this.aspFactoryImpl.parameterFactory.createErrorCode(ErrorCode.Unexpected_Message); <line42> sendError(null, errorCodeObj); <line43> } <line44> } <line45> } <line46> 	<line23>, <line37>
5808	public class A { <line0> @Override <line1> public ClientMessage receive(final long timeout) throws ActiveMQException { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> ClientMessage msg = receive(timeout, false); <line5> if (msg == null && !closed) { <line6> if (logger.isTraceEnabled()) { <line7> } <line8> msg = receive(0, true); <line9> } <line10> if (logger.isTraceEnabled()) { <line11> } <line12> return msg; <line13> } <line14> } <line15> 	<line3>, <line7>, <line11>
5809	public class A { <line0> @Override <line1> public void setEnvironment(Environment environment) { <line2> List<String> profiles = Arrays.asList(environment.getActiveProfiles()); <line3> if (profiles.contains(DISABLE_SSL_CLIENT_POSTGRES)) { <line4> } <line5> } <line6> } <line7> 	<line3>, <line4>
5810	public class A { <line0> @Override <line1> public void onError(Throwable throwable) { <line2> XdsSchedulerManager.getInstance().startApplicationPolicyDiscoveryScheduling(); <line3> nack(throwable); <line4> } <line5> } <line6> 	<line2>
5811	public class A { <line0> @Before <line1> public void clearZkDir() throws IOException { <line2> File zkDirFile = new File(zkDir); <line3> FileUtils.deleteDirectory(zkDirFile); <line4> zkDirFile.mkdirs(); <line5> } <line6> } <line7> 	<line2>
5812	"public class A { <line0> @Override <line1> public void run() { <line2> long currentTime = 0L; <line3> long lastCleanup = 0L; <line4> long lastDiscovery = 0L; <line5> while (running) { <line6> try { <line7> currentTime = System.currentTimeMillis(); <line8> while (!inputQueue.isEmpty() <line9> && currentTime < lastDiscovery + discoveryInterval <line10> && currentTime < lastCleanup + discoveryIntervalStep) { <line11> currentTime = System.currentTimeMillis(); <line12> final Envelope envelope = inputQueue.poll(); <line13> if (envelope != null) { <line14> final AbstractMessage message = envelope.getMessage(); <line15> onMessage(message); <line16> final String ackKey = message.getId() + ""-ack""; <line17> if (getData(ackKey) == null) { <line18> message.onMessage(this, envelope.getPeer()); <line19> broadcast(message); <line20> setData(ackKey, true); <line21> } <line22> } <line23> } <line24> if (currentTime > lastDiscovery + discoveryInterval) { <line25> lastDiscovery = currentTime; <line26> send( <line27> new PeerInfo(getPublicKey(), repository.getUuid(), initialPeer, START_PORT), <line28> new Discovery(getContentHash())); <line29> if (discoveryInterval < finalDiscoveryInterval) { <line30> discoveryInterval += discoveryIntervalStep; <line31> } <line32> } <line33> if (currentTime > lastCleanup + discoveryIntervalStep) { <line34> lastCleanup = currentTime; <line35> for (final Iterator<PeerInfo> it = peers.values().iterator(); it.hasNext(); ) { <line36> final PeerInfo peer = it.next(); <line37> final long time = <line38> peer.getLastSeen() + finalDiscoveryInterval + (discoveryIntervalStep * 2); <line39> if (currentTime > time) { <line40> onRemovePeer(peer); <line41> it.remove(); <line42> } <line43> } <line44> } <line45> Thread.sleep(10L); <line46> } catch (Throwable t) { <line47> } <line48> } <line49> executorService.shutdownNow(); <line50> } <line51> } <line52> "	<line47>
5813	public class A { <line0> @Override <line1> public Integer insert(Registration registration, WorkflowRun workflowRun) { <line2> if (registration == null) { <line3> } else if (registration.isLIMSAdmin() || workflowRun.givesPermission(registration)) { <line4> return insert(workflowRun); <line5> } else { <line6> } <line7> return null; <line8> } <line9> } <line10> 	<line3>, <line4>, <line6>
5814	public class A { <line0> @Override <line1> public List<Notification> getNotifications(List<String> notificationIds) { <line2> return notificationStore <line3> .map(s -> s.getNotifications(notificationIds)) <line4> .orElse(Collections.emptyList()); <line5> } <line6> } <line7> 	<line2>
5815	public class A { <line0> @Override <line1> public synchronized void purge() { <line2> try { <line3> consumers.stop(); <line4> consumers.start(); <line5> } catch (Exception e) { <line6> } <line7> if (statistics != null) { <line8> statistics.clear(); <line9> } <line10> } <line11> } <line12> 	<line6>
5816	"public class A { <line0> @Override <line1> public void stop() { <line2> if (logger.isDebugEnabled()) { <line3> final ArrayList<MatcherTimer> matcherTimers = <line4> new ArrayList<>(ElasticApmAgent.getMatcherTimers()); <line5> Collections.sort(matcherTimers); <line6> StringBuilder sb = <line7> new StringBuilder() <line8> .append(""Total time spent matching: "") <line9> .append(String.format(""%,d"", ElasticApmAgent.getTotalMatcherTime())) <line10> .append(""ns"") <line11> .append('\n') <line12> .append(MatcherTimer.getTableHeader()) <line13> .append('\n'); <line14> for (MatcherTimer matcherTimer : matcherTimers) { <line15> sb.append(matcherTimer.toString()).append('\n'); <line16> } <line17> } <line18> } <line19> } <line20> "	<line17>
5817	public class A { <line0> protected void postStartCustom() { <line1> boolean result = false; <line2> result |= tryCheckStartPid(); <line3> result |= tryCheckStartService(); <line4> result |= tryCheckStartWindowsService(); <line5> if (!result) { <line6> } <line7> entity().sensors().set(SoftwareProcess.SERVICE_UP, true); <line8> } <line9> } <line10> 	<line6>
5818	"public class A { <line0> public void delegate(String action, Database db, MolgenisRequest request, OutputStream out) <line1> throws HandleRequestDelegationException { <line2> try { <line3> try { <line4> db.beginTx(); <line5> Method m = this.getClass().getMethod(action, Database.class, MolgenisRequest.class); <line6> m.invoke(this, db, request); <line7> if (db.inTx()) db.commitTx(); <line8> } catch (NoSuchMethodException e1) { <line9> if (out != null) <line10> try { <line11> Method m = <line12> this.getClass() <line13> .getMethod(action, Database.class, MolgenisRequest.class, OutputStream.class); <line14> m.invoke(this, db, request, out); <line15> if (db.inTx()) db.commitTx(); <line16> } catch (Exception e) { <line17> this.getModel().setMessages(new ScreenMessage(""Unknown action: "" + action, false)); <line18> e.printStackTrace(); <line19> db.rollbackTx(); <line20> } <line21> } catch (Exception e) { <line22> e.printStackTrace(); <line23> this.getModel().setMessages(new ScreenMessage(e.getCause().getMessage(), false)); <line24> db.rollbackTx(); <line25> } <line26> } catch (DatabaseException e) { <line27> e.printStackTrace(); <line28> } <line29> } <line30> } <line31> "	<line5>, <line7>, <line9>, <line11>, <line15>, <line18>, <line22>
5819	"public class A { <line0> @Test( <line1> groups = {""Phase 1 Shape""}, <line2> description = ""extra columns"", <line3> priority = 243) <line4> public void verifyTest_2_8() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""shape_8"", GTFS_1_GTFS_Common_11, SEVERITY.WARNING, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 2, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""shapes.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(1), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	<line5>
5820	public class A { <line0> @Override <line1> public void put( <line2> final LogicalDatastoreType store, <line3> final YangInstanceIdentifier path, <line4> final NormalizedNode<?, ?> data) { <line5> checkOpen(); <line6> processTransactionOperation(facade -> facade.put(store, path, data)); <line7> } <line8> } <line9> 	<line6>
5821	public class A { <line0> private static EEffect getConditionAsEffect(ServiceConditionEnumeration condition) { <line1> switch (condition) { <line2> case CANCELLED: <line3> case NO_SERVICE: <line4> return EEffect.NO_SERVICE; <line5> case DELAYED: <line6> return EEffect.SIGNIFICANT_DELAYS; <line7> case DIVERTED: <line8> return EEffect.DETOUR; <line9> case ADDITIONAL_SERVICE: <line10> case EXTENDED_SERVICE: <line11> case SHUTTLE_SERVICE: <line12> case SPECIAL_SERVICE: <line13> case REPLACEMENT_SERVICE: <line14> return EEffect.ADDITIONAL_SERVICE; <line15> case DISRUPTED: <line16> case INTERMITTENT_SERVICE: <line17> case SHORT_FORMED_SERVICE: <line18> return EEffect.REDUCED_SERVICE; <line19> case ALTERED: <line20> case ARRIVES_EARLY: <line21> case REPLACEMENT_TRANSPORT: <line22> case SPLITTING_TRAIN: <line23> return EEffect.MODIFIED_SERVICE; <line24> case ON_TIME: <line25> case FULL_LENGTH_SERVICE: <line26> case NORMAL_SERVICE: <line27> return EEffect.OTHER_EFFECT; <line28> case UNDEFINED_SERVICE_INFORMATION: <line29> case UNKNOWN: <line30> return EEffect.UNKNOWN_EFFECT; <line31> default: <line32> return EEffect.UNKNOWN_EFFECT; <line33> } <line34> } <line35> } <line36> 	<line32>
5822	"public class A { <line0> @Override <line1> public List<ConfidenceData> getDataAfterTimestampGranularityInBin( <line2> String crisisCode, <line3> String attributeCode, <line4> String labelCode, <line5> Long timestamp, <line6> Long granularity, <line7> Integer bin) { <line8> Criteria criteria = getCurrentSession().createCriteria(ConfidenceData.class); <line9> Criterion criterion = <line10> Restrictions.conjunction() <line11> .add(Restrictions.eq(""crisisCode"", crisisCode)) <line12> .add(Restrictions.eq(""attributeCode"", attributeCode)) <line13> .add(Restrictions.eq(""labelCode"", labelCode)) <line14> .add(Restrictions.ge(""timestamp"", timestamp)) <line15> .add(Restrictions.eq(""granularity"", granularity)) <line16> .add(Restrictions.eq(""bin"", bin)); <line17> criteria.add(criterion); <line18> try { <line19> List<ConfidenceData> objList = (List<ConfidenceData>) criteria.list(); <line20> return objList; <line21> } catch (HibernateException e) { <line22> e.printStackTrace(); <line23> } <line24> return null; <line25> } <line26> } <line27> "	<line22>
5823	public class A { <line0> @Override <line1> public void disconnect(int disconnectCause) <line2> throws InternalException, IllegalDiameterStateException { <line3> super.disconnect(disconnectCause); <line4> if (getState(PeerState.class) != PeerState.DOWN) { <line5> stopping = true; <line6> try { <line7> FsmEvent event = new FsmEvent(STOP_EVENT); <line8> event.setData(disconnectCause); <line9> fsm.handleEvent(event); <line10> } catch (OverloadException e) { <line11> stopping = false; <line12> } <line13> } <line14> } <line15> } <line16> 	<line12>
5824	public class A { <line0> private Document filterBeforeDiff(Document document, List<XMLDiffFilter> filters) { <line1> for (XMLDiffFilter filter : filters) { <line2> try { <line3> filter.before(document); <line4> } catch (Exception e) { <line5> } <line6> } <line7> return document; <line8> } <line9> } <line10> 	<line5>
5825	"public class A { <line0> @GET <line1> @Path(""/users/{id}"") <line2> @Timed <line3> public Response getUser(@PathParam(""id"") Long userId, @Context SecurityContext securityContext) { <line4> if (!SecurityUtil.hasRole(authorizer, securityContext, ROLE_SECURITY_ADMIN)) { <line5> } <line6> User user = catalogService.getUser(userId); <line7> if (user != null) { <line8> return WSUtils.respondEntity(user, OK); <line9> } <line10> throw EntityNotFoundException.byId(userId.toString()); <line11> } <line12> } <line13> "	<line5>
5826	public class A { <line0> private void closeConnection(Connection c) { <line1> try { <line2> c.close(); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	<line4>
5827	public class A { <line0> @Override <line1> @GraphTransaction <line2> public BulkImportResponse bulkCreateOrUpdateBusinessAttributes( <line3> InputStream inputStream, String fileName) throws AtlasBaseException { <line4> BulkImportResponse ret = new BulkImportResponse(); <line5> if (StringUtils.isBlank(fileName)) { <line6> throw new AtlasBaseException(AtlasErrorCode.FILE_NAME_NOT_FOUND, fileName); <line7> } <line8> List<String[]> fileData = FileUtils.readFileData(fileName, inputStream); <line9> Map<String, AtlasEntity> attributesToAssociate = getBusinessMetadataDefList(fileData, ret); <line10> for (AtlasEntity entity : attributesToAssociate.values()) { <line11> Map<String, Map<String, Object>> businessAttributes = entity.getBusinessAttributes(); <line12> String guid = entity.getGuid(); <line13> try { <line14> addOrUpdateBusinessAttributes(guid, businessAttributes, true); <line15> ret.addToSuccessImportInfoList(new ImportInfo(guid, businessAttributes.toString())); <line16> } catch (Exception e) { <line17> ret.addToFailedImportInfoList( <line18> new ImportInfo(guid, businessAttributes.toString(), FAILED, e.getMessage())); <line19> } <line20> } <line21> return ret; <line22> } <line23> } <line24> 	<line17>
5828	"public class A { <line0> @Override <line1> public void addTestData(URI file, String datatype, Set<String> indexes) throws IOException { <line2> Assert.assertFalse( <line3> ""datatype has already been configured("" + datatype + "")"", <line4> this.rawData.containsKey(datatype)); <line5> try (final Reader reader = Files.newBufferedReader(Paths.get(file)); <line6> final CSVReader csv = new CSVReader(reader)) { <line7> String[] data; <line8> int count = 0; <line9> Set<RawData> ipData = new HashSet<>(); <line10> while (null != (data = csv.readNext())) { <line11> final RawData raw = new IpAddrRawData(datatype, data); <line12> ipData.add(raw); <line13> count++; <line14> } <line15> this.rawData.put(datatype, ipData); <line16> this.rawDataIndex.put(datatype, indexes); <line17> } <line18> } <line19> } <line20> "	<line17>
5829	public class A { <line0> @Override <line1> public void stop() { <line2> try { <line3> shardingTreeCacheService.shutdown(); <line4> namespaceShardingService.shutdown(); <line5> } catch (InterruptedException e) { <line6> Thread.currentThread().interrupt(); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	<line6>, <line8>
5830	"public class A { <line0> private void exportEntitlements(File baseDir, Consumer consumer) <line1> throws IOException, ExportCreationException { <line2> File entCertDir = new File(baseDir.getCanonicalPath(), ""entitlements""); <line3> entCertDir.mkdir(); <line4> for (Entitlement ent : entitlementCurator.listByConsumer(consumer)) { <line5> if (ent.isDirty()) { <line6> throw new ExportCreationException(""Attempted to export dirty entitlements""); <line7> } <line8> if (!this.exportRules.canExport(ent)) { <line9> continue; <line10> } <line11> File file = new File(entCertDir.getCanonicalPath(), ent.getId() + "".json""); <line12> try (FileWriter writer = new FileWriter(file)) { <line13> entExporter.export(mapper, writer, ent); <line14> } <line15> } <line16> } <line17> } <line18> "	<line6>, <line9>, <line11>
5831	public class A { <line0> void handleParkedCallGiveUpEvent(ParkedCallGiveUpEvent event) { <line1> AsteriskChannelImpl channel = getChannelImplByNameAndActive(event.getParkeeChannel()); <line2> if (channel == null) { <line3> return; <line4> } <line5> Extension wasParkedAt = channel.getParkedAt(); <line6> if (wasParkedAt == null) { <line7> return; <line8> } <line9> try (LockCloser closer = channel.withLock()) { <line10> channel.setParkedAt(null, null); <line11> } <line12> } <line13> } <line14> 	<line3>, <line7>, <line12>
5832	public class A { <line0> @Override <line1> public CommercePriceList remove(Serializable primaryKey) throws NoSuchPriceListException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> CommercePriceList commercePriceList = <line6> (CommercePriceList) session.get(CommercePriceListImpl.class, primaryKey); <line7> if (commercePriceList == null) { <line8> if (_log.isDebugEnabled()) { <line9> } <line10> throw new NoSuchPriceListException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line11> } <line12> return remove(commercePriceList); <line13> } catch (NoSuchPriceListException noSuchEntityException) { <line14> throw noSuchEntityException; <line15> } catch (Exception exception) { <line16> throw processException(exception); <line17> } finally { <line18> closeSession(session); <line19> } <line20> } <line21> } <line22> 	<line9>
5833	"public class A { <line0> private Set<Map<String, String>> buildFilterSolutionSet() throws IOException { <line1> StopWatch stopWatch = new StopWatch(); <line2> stopWatch.start(); <line3> Set<Map<String, String>> matchSet = <line4> Match.match(this.matchThreshold.floatValue(), this.scoreJena); <line5> Set<Map<String, String>> solSet = getNewSolSet(); <line6> if (matchSet.isEmpty()) { <line7> } else { <line8> Map<String, String> tempMap; <line9> for (Map<String, String> entry : matchSet) { <line10> String sinputuri = entry.get(""sInputURI""); <line11> String svivouri = entry.get(""sVivoURI""); <line12> tempMap = new HashMap<String, String>(); <line13> tempMap.put(""sInput"", sinputuri); <line14> Resource sInput = this.inputJena.getJenaModel().getResource(sinputuri); <line15> tempMap.put(""sVivo"", svivouri); <line16> Resource sVivo = this.vivoJena.getJenaModel().getResource(svivouri); <line17> for (String runName : this.vivoPredicates.keySet()) { <line18> Property os_runName = <line19> this.inputJena.getJenaModel().getProperty(this.inputPredicates.get(runName)); <line20> Statement os_stmnt = sInput.getProperty(os_runName); <line21> RDFNode os = null; <line22> if (os_stmnt != null) { <line23> os = os_stmnt.getObject(); <line24> } <line25> Property op_runName = <line26> this.vivoJena.getJenaModel().getProperty(this.vivoPredicates.get(runName)); <line27> Statement op_stmnt = sVivo.getProperty(op_runName); <line28> RDFNode op = null; <line29> if (op_stmnt != null) { <line30> op = op_stmnt.getObject(); <line31> } <line32> addRunName(tempMap, runName, os, op); <line33> } <line34> solSet.add(tempMap); <line35> } <line36> } <line37> stopWatch.stop(); <line38> return solSet; <line39> } <line40> } <line41> "	<line3>, <line7>, <line8>, <line12>, <line38>
5834	public class A { <line0> @Override <line1> public void doAction() { <line2> try { <line3> markDone(); <line4> getHolder().stop(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	<line6>
5835	"public class A { <line0> private Map<String, Object> downloadFilesInFolder(String path) throws DropboxException { <line1> try { <line2> ListFolderResult folderResult = client.files().listFolder(path.equals(""/"") ? """" : path); <line3> Map<String, Object> returnMap = new LinkedHashMap<>(); <line4> for (Metadata entry : folderResult.getEntries()) { <line5> returnMap.put( <line6> entry.getPathDisplay(), downloadSingleFile(entry.getPathDisplay()).getValue()); <line7> } <line8> return returnMap; <line9> } catch (ListFolderErrorException e) { <line10> try { <line11> DbxDownloader<FileMetadata> listing = client.files().download(path); <line12> if (listing == null) { <line13> return Collections.emptyMap(); <line14> } else { <line15> Map.Entry<String, Object> entry = downloadSingleFile(path); <line16> return Collections.singletonMap(entry.getKey(), entry.getValue()); <line17> } <line18> } catch (DbxException dbxException) { <line19> throw new DropboxException(dbxException); <line20> } <line21> } catch (DbxException e) { <line22> throw new DropboxException(e); <line23> } <line24> } <line25> } <line26> "	<line15>
5836	"public class A { <line0> @Before <line1> public void copyTestResources() throws IOException { <line2> Path testResourceTarget = rootTmpDir.resolve(""resources""); <line3> if (Files.notExists(testResourceTarget)) { <line4> Files.createDirectory(testResourceTarget); <line5> } <line6> String currentTestName = getCurrentTestName(); <line7> currentTestResourceDir = testResourceTarget.resolve(currentTestName); <line8> String url = getUrl(""samples"", currentTestName); <line9> Path from = Paths.get(url); <line10> if (Files.exists(from)) { <line11> } else { <line12> from = DEFAULT_RESOURCES; <line13> } <line14> copyDirs(from, currentTestResourceDir); <line15> } <line16> } <line17> "	<line7>, <line11>, <line12>, <line15>
5837	"public class A { <line0> protected Map<String, DfForeignKeyMeta> filterSameStructureForeignKey( <line1> Map<String, DfForeignKeyMeta> fkMap) { <line2> final Map<String, DfForeignKeyMeta> filteredFKMap = newLinkedHashMap(); <line3> final Map<Map<String, Object>, Object> checkMap = newLinkedHashMap(); <line4> final Object dummyObj = new Object(); <line5> for (Entry<String, DfForeignKeyMeta> entry : fkMap.entrySet()) { <line6> final String foreinKeyName = entry.getKey(); <line7> final DfForeignKeyMeta metaInfo = entry.getValue(); <line8> final Map<String, Object> checkKey = newLinkedHashMap(); <line9> checkKey.put(metaInfo.getForeignTableIdentityName(), dummyObj); <line10> checkKey.put(""columnNameMap:"" + metaInfo.getColumnNameMap(), dummyObj); <line11> if (checkMap.containsKey(checkKey)) { <line12> String msg = <line13> ""*The same-structural foreign key was found: skipped="" + foreinKeyName + "":"" + checkKey; <line14> } else { <line15> checkMap.put(checkKey, dummyObj); <line16> filteredFKMap.put(foreinKeyName, metaInfo); <line17> } <line18> } <line19> return filteredFKMap; <line20> } <line21> } <line22> "	<line14>
5838	"public class A { <line0> protected void loadDataSet(Repository rep, String datasetFile) <line1> throws RDFParseException, RepositoryException, IOException { <line2> InputStream dataset = SPARQLServerBaseTest.class.getResourceAsStream(datasetFile); <line3> boolean needToShutdown = false; <line4> if (!rep.isInitialized()) { <line5> rep.init(); <line6> needToShutdown = true; <line7> } <line8> RepositoryConnection con = rep.getConnection(); <line9> try { <line10> con.clear(); <line11> con.add(dataset, """", Rio.getParserFormatForFileName(datasetFile).get()); <line12> } finally { <line13> dataset.close(); <line14> con.close(); <line15> if (needToShutdown) { <line16> rep.shutDown(); <line17> } <line18> } <line19> } <line20> } <line21> "	<line2>, <line19>
5839	public class A { <line0> public static boolean checkExists(CuratorFramework curator, String crawlId) { <line1> try { <line2> return curator.checkExists().forPath(crawlId) != null; <line3> } catch (Exception ex) { <line4> } <line5> return false; <line6> } <line7> } <line8> 	<line4>
5840	public class A { <line0> private ActionResponse executeRefreshActions(IProtocolSessionManager protocolSessionManager) <line1> throws ActionException { <line2> ActionResponse refreshResponse = ActionResponse.okResponse(QueueConstants.REFRESH); <line3> for (IAction action : queue) { <line4> ActionResponse actionResponse = action.execute(protocolSessionManager); <line5> if (actionResponse.getStatus() == ActionResponse.STATUS.ERROR) { <line6> return actionResponse; <line7> } <line8> } <line9> return refreshResponse; <line10> } <line11> } <line12> 	<line4>
5841	public class A { <line0> @Override <line1> public boolean exists() { <line2> try { <line3> return fs.exists(hdfsPath); <line4> } catch (IOException e) { <line5> return false; <line6> } <line7> } <line8> } <line9> 	<line5>
5842	public class A { <line0> private void updateSasLogicalInterconnectFirmware() { <line1> SasLogicalInterconnect interconnect = client.getByName(SAS_LOGICAL_INTERCONNECT_NAME).get(0); <line2> SasLiFirmware firmware = new SasLiFirmware(); <line3> firmware.setCommand(Command.Stage); <line4> firmware.setForce(false); <line5> firmware.setSppUri( <line6> fwClient.getByName(FirmwareDriverClientSample.FIRMWARE_DRIVER_NAME).get(0).getUri()); <line7> TaskResource task = this.client.updateFirmware(interconnect.getResourceId(), firmware); <line8> } <line9> } <line10> 	<line8>
5843	"public class A { <line0> private void retrievePatToken() throws UmaProtectionException { <line1> this.umaPat = null; <line2> if (umaMetadata == null) { <line3> return; <line4> } <line5> String umaClientKeyStoreFile = getClientKeyStoreFile(); <line6> String umaClientKeyStorePassword = getClientKeyStorePassword(); <line7> if (StringHelper.isEmpty(umaClientKeyStoreFile) <line8> || StringHelper.isEmpty(umaClientKeyStorePassword)) { <line9> throw new UmaProtectionException(""UMA JKS keystore path or password is empty""); <line10> } <line11> if (umaClientKeyStorePassword != null) { <line12> try { <line13> umaClientKeyStorePassword = encryptionService.decrypt(umaClientKeyStorePassword); <line14> } catch (EncryptionException ex) { <line15> } <line16> } <line17> try { <line18> this.umaPat = <line19> UmaClient.requestPat( <line20> umaMetadata.getTokenEndpoint(), <line21> umaClientKeyStoreFile, <line22> umaClientKeyStorePassword, <line23> getClientId(), <line24> getClientKeyId()); <line25> if (this.umaPat == null) { <line26> this.umaPatAccessTokenExpiration = 0l; <line27> } else { <line28> this.umaPatAccessTokenExpiration = <line29> computeAccessTokenExpirationTime(this.umaPat.getExpiresIn()); <line30> } <line31> } catch (Exception ex) { <line32> throw new UmaProtectionException(""Failed to obtain valid UMA PAT token"", ex); <line33> } <line34> if ((this.umaPat == null) || (this.umaPat.getAccessToken() == null)) { <line35> throw new UmaProtectionException(""Failed to obtain valid UMA PAT token""); <line36> } <line37> } <line38> } <line39> "	<line15>
5844	"public class A { <line0> @Override <line1> public void generate(Model model, MolgenisOptions options) throws Exception { <line2> Template template = createTemplate(getClass().getSimpleName() + "".sql.ftl""); <line3> Map<String, Object> templateArgs = createTemplateArguments(options); <line4> File target = new File(this.getSqlPath(options) + ""/count_per_table.sql""); <line5> boolean created = target.getParentFile().mkdirs(); <line6> if (!created && !target.getParentFile().exists()) { <line7> throw new IOException(""could not create "" + target.getParentFile()); <line8> } <line9> templateArgs.put(""model"", model); <line10> OutputStream targetOut = new FileOutputStream(target); <line11> template.process(templateArgs, new OutputStreamWriter(targetOut, Charset.forName(""UTF-8""))); <line12> targetOut.close(); <line13> } <line14> } <line15> "	<line13>
5845	public class A { <line0> private T decode(Object value) { <line1> if (value == null) return defaultValue; <line2> if (enumClass.isAssignableFrom(value.getClass())) { <line3> return (T) value; <line4> } <line5> String s; <line6> if (!(value instanceof String)) { <line7> s = value.toString(); <line8> } else { <line9> s = (String) value; <line10> } <line11> try { <line12> return Enum.valueOf(enumClass, s); <line13> } catch (Exception e) { <line14> return defaultValue; <line15> } <line16> } <line17> } <line18> 	<line14>
5846	"public class A { <line0> private MongoClient resolveMongoConnection() { <line1> MongoClient mongoClient; <line2> if (this.hosts != null) { <line3> String credentials = username == null ? """" : username; <line4> if (!credentials.equals("""")) { <line5> credentials += this.password == null ? ""@"" : "":"" + password + ""@""; <line6> } <line7> mongoClient = MongoClients.create(String.format(""mongodb://%s%s"", credentials, hosts)); <line8> } else { <line9> mongoClient = <line10> CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class); <line11> } <line12> return mongoClient; <line13> } <line14> } <line15> "	<line8>, <line11>
5847	public class A { <line0> public OrchestrationContextBuilder createOrchestrationContextBuilder( <line1> NhincConstants.GATEWAY_API_LEVEL apiLevel) { <line2> switch (apiLevel) { <line3> case LEVEL_g0: <line4> return new OutboundPatientDiscoveryDeferredRequestOrchestrationContextBuilder_g0(); <line5> default: <line6> return new OutboundPatientDiscoveryDeferredRequestOrchestrationContextBuilder_g0(); <line7> } <line8> } <line9> } <line10> 	<line6>
5848	"public class A { <line0> @Override <line1> public void run() { <line2> while (!stopped && !queryPurger.isInterrupted()) { <line3> try { <line4> Iterator<FinishedQuery> iter = finishedQueries.iterator(); <line5> FinishedQuery finished; <line6> while (iter.hasNext()) { <line7> finished = iter.next(); <line8> if (finished.canBePurged()) { <line9> try { <line10> persistQuery(finished); <line11> iter.remove(); <line12> } catch (Exception e) { <line13> continue; <line14> } finally { <line15> if (!finished.getCtx().isQueryClosedOnDriver()) { <line16> try { <line17> if (finished.getCtx().getSelectedDriver() != null) { <line18> finished.getCtx().getSelectedDriver().closeQuery(finished.getQueryHandle()); <line19> } <line20> finished.getCtx().setQueryClosedOnDriver(true); <line21> } catch (Exception e) { <line22> } <line23> processWaitingQueriesAsync(finished.ctx); <line24> } <line25> } <line26> synchronized (finished.ctx) { <line27> finished.ctx.setFinishedQueryPersisted(true); <line28> allQueries.remove(finished.getQueryHandle()); <line29> resultSets.remove(finished.getQueryHandle()); <line30> } <line31> fireStatusChangeEvent( <line32> finished.getCtx(), <line33> new QueryStatus(1f, null, CLOSED, ""Query purged"", false, null, null, null), <line34> finished.getCtx().getStatus()); <line35> try { <line36> lensServerDao.deleteActiveQuery(finished.getCtx()); <line37> } catch (LensException e) { <line38> incrCounter(ACTIVE_QUERY_DELETE_ERROR_COUNTER); <line39> } <line40> } <line41> } <line42> Thread.sleep(purgeInterval); <line43> } catch (InterruptedException e) { <line44> } catch (Throwable e) { <line45> incrCounter(QUERY_PURGER_COUNTER); <line46> } <line47> } <line48> } <line49> } <line50> "	<line2>, <line13>, <line22>, <line28>, <line40>, <line44>, <line45>, <line48>
5849	public class A { <line0> @Override <line1> public void shutdown() { <line2> try { <line3> failureManager.stop(); <line4> super.shutdown(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	<line6>
5850	public class A { <line0> private void loadPlugin(URLClassLoader pluginClassLoader) { <line1> ServiceLoader<Plugin> serviceLoader = ServiceLoader.load(Plugin.class, pluginClassLoader); <line2> List<Plugin> plugins = ImmutableList.copyOf(serviceLoader); <line3> if (plugins.isEmpty()) { <line4> } <line5> for (Plugin plugin : plugins) { <line6> installPlugin(plugin); <line7> } <line8> } <line9> } <line10> 	<line4>, <line6>
5851	"public class A { <line0> private Map<String, Invoker<T>> toInvokers(List<URL> urls) { <line1> Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>(); <line2> if (urls == null || urls.size() == 0) { <line3> return newUrlInvokerMap; <line4> } <line5> Set<String> keys = new HashSet<String>(); <line6> String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY); <line7> for (URL providerUrl : urls) { <line8> if (queryProtocols != null && queryProtocols.length() > 0) { <line9> boolean accept = false; <line10> String[] acceptProtocols = queryProtocols.split("",""); <line11> for (String acceptProtocol : acceptProtocols) { <line12> if (providerUrl.getProtocol().equals(acceptProtocol)) { <line13> accept = true; <line14> break; <line15> } <line16> } <line17> if (!accept) { <line18> continue; <line19> } <line20> } <line21> if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) { <line22> continue; <line23> } <line24> if (!ExtensionLoader.getExtensionLoader(Protocol.class) <line25> .hasExtension(providerUrl.getProtocol())) { <line26> continue; <line27> } <line28> URL url = mergeUrl(providerUrl); <line29> String key = url.toFullString(); <line30> if (keys.contains(key)) { <line31> continue; <line32> } <line33> keys.add(key); <line34> Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; <line35> Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key); <line36> if (invoker == null) { <line37> try { <line38> boolean enabled = true; <line39> if (url.hasParameter(Constants.DISABLED_KEY)) { <line40> enabled = !url.getParameter(Constants.DISABLED_KEY, false); <line41> } else { <line42> enabled = url.getParameter(Constants.ENABLED_KEY, true); <line43> } <line44> if (enabled) { <line45> invoker = new InvokerDelegete<T>(protocol.refer(serviceType, url), url, providerUrl); <line46> } <line47> } catch (Throwable t) { <line48> } <line49> if (invoker != null) { <line50> newUrlInvokerMap.put(key, invoker); <line51> } <line52> } else { <line53> newUrlInvokerMap.put(key, invoker); <line54> } <line55> } <line56> keys.clear(); <line57> return newUrlInvokerMap; <line58> } <line59> } <line60> "	<line26>, <line48>
5852	"public class A { <line0> public JiraResponse delete(String resource, Map<String, Object> parameters) throws IOException { <line1> try { <line2> URIBuilder builder = new URIBuilder(hostPort + resource); <line3> for (Map.Entry<String, Object> entry : parameters.entrySet()) { <line4> builder.addParameter(entry.getKey(), entry.getValue().toString()); <line5> } <line6> URI uri = builder.build(); <line7> Request delete = Request.Delete(uri); <line8> for (Header header : headers) { <line9> delete.addHeader(header); <line10> } <line11> executor.clearCookies(); <line12> Response response = executor.execute(delete); <line13> HttpResponse httpResponse = response.returnResponse(); <line14> StatusLine statusLine = httpResponse.getStatusLine(); <line15> int statusCode = statusLine.getStatusCode(); <line16> HttpEntity entity = httpResponse.getEntity(); <line17> String entityBody = """"; <line18> if (entity != null && statusCode != SC_UNAUTHORIZED) { <line19> entityBody = EntityUtils.toString(entity); <line20> } <line21> return new JiraResponse(statusCode, entityBody); <line22> } catch (URISyntaxException e) { <line23> throw new IOException(""Wrong URI"", e); <line24> } <line25> } <line26> } <line27> "	<line23>
5853	"public class A { <line0> @Override <line1> public void contextInitialized(javax.servlet.ServletContextEvent sce) { <line2> try { <line3> System.setProperty(""org.apache.cxf.Logger"", ""org.apache.cxf.common.logging.Log4jLogger""); <line4> String contextPath = sce.getServletContext().getContextPath(); <line5> MiscUtils.addLoggingOverrideConfiguration(contextPath); <line6> LocaleUtils.BASE_NAME = ""oscarResources""; <line7> OscarProperties properties = OscarProperties.getInstance(); <line8> String vmstatLoggingPeriod = properties.getProperty(""VMSTAT_LOGGING_PERIOD""); <line9> VmStat.startContinuousLogging(Long.parseLong(vmstatLoggingPeriod)); <line10> MiscUtilsOld.setShutdownSignaled(false); <line11> MiscUtilsOld.registerShutdownHook(); <line12> createOscarProgramIfNecessary(); <line13> CaisiIntegratorUpdateTask.startTask(); <line14> OscarJobUtils.initializeJobExecutionFramework(); <line15> WaitListEmailThread.startTaskIfEnabled(); <line16> loadCaches(); <line17> HRMFixMissingReportHelper hrmFixer = new HRMFixMissingReportHelper(); <line18> try { <line19> hrmFixer.fixIt(); <line20> } catch (Exception e) { <line21> } <line22> } catch (Exception e) { <line23> throw (new RuntimeException(e)); <line24> } <line25> } <line26> } <line27> "	<line5>, <line17>, <line21>, <line23>
5854	"public class A { <line0> @Override <line1> public Map<String, List<ReferenceTablesBo>> getreferenceListByCategory() { <line2> logger.entry(""StudyServiceImpl - getreferenceListByCategory() - Starts""); <line3> HashMap<String, List<ReferenceTablesBo>> referenceMap = null; <line4> try { <line5> referenceMap = studyDAO.getreferenceListByCategory(); <line6> } catch (Exception e) { <line7> } <line8> logger.exit(""StudyServiceImpl - getreferenceListByCategory() - Ends""); <line9> return referenceMap; <line10> } <line11> } <line12> "	<line7>
5855	public class A { <line0> @Override <line1> public void run() { <line2> final ConfigStatusInfo info = getConfigStatus(configStatusSource.entityId, null); <line3> if (info != null) { <line4> if (eventPublisher != null) { <line5> eventPublisher.post(new ConfigStatusInfoEvent(configStatusSource.getTopic(), info)); <line6> } else { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
5856	"public class A { <line0> private void writeToFile(String message) { <line1> try { <line2> out.write(message + ""\n""); <line3> itemsWrittenToFile++; <line4> isTimeToCreateNewFile(); <line5> } catch (IOException ex) { <line6> } <line7> JsonDeserializer jsd = new JsonDeserializer(); <line8> ClassifiedTweet tweet = jsd.getClassifiedTweet(message); <line9> if (null == tweet) { <line10> } else { <line11> if (null == tweet.getLabelName_1() && tweet.getNominalLabels().isEmpty()) {} <line12> } <line13> } <line14> } <line15> "	<line6>
5857	public class A { <line0> @Override <line1> public void postProcessEnvironment( <line2> ConfigurableEnvironment environment, SpringApplication application) { <line3> WebApplicationType webApplicationType = application.getWebApplicationType(); <line4> if (!WebApplicationType.NONE.equals(webApplicationType)) { <line5> if (logger.isDebugEnabled()) { <line6> } <line7> return; <line8> } <line9> MutablePropertySources propertySources = environment.getPropertySources(); <line10> Map<String, Object> defaultProperties = createDefaultProperties(environment); <line11> if (!CollectionUtils.isEmpty(defaultProperties)) { <line12> addOrReplace(propertySources, defaultProperties); <line13> } <line14> } <line15> } <line16> 	<line6>
5858	"public class A { <line0> @RequestMapping( <line1> value = """", <line2> method = RequestMethod.POST, <line3> consumes = {""application/json;charset=UTF-8""}, <line4> produces = {""application/json;charset=UTF-8""}) <line5> public ResponseEntity<Space> createSpace( <line6> @RequestBody Space space, <line7> @ApiIgnore @RequestHeader(value = Constants.HTTP_TENANT_HEADER, required = false) <line8> String tenant) { <line9> final StopWatch sw = <line10> new StopWatch( <line11> ""Create space ["" <line12> + (space == null ? null : space.getSpaceName()) <line13> + ""] "" <line14> + ""for tenant token ["" <line15> + tenant <line16> + ""] "") <line17> .start(); <line18> try { <line19> if (space == null) { <line20> return new ResponseEntity<Space>(HttpStatus.BAD_REQUEST); <line21> } else if (!space.hasNameAndDescription()) { <line22> return new ResponseEntity<Space>(HttpStatus.BAD_REQUEST); <line23> } else if (space.isReadOnly()) { <line24> return new ResponseEntity<Space>(HttpStatus.BAD_REQUEST); <line25> } <line26> Tenant t = null; <line27> try { <line28> t = this.tenantRepository.getTenant(tenant); <line29> } catch (EntityNotFoundException enfe) { <line30> return new ResponseEntity<Space>(HttpStatus.NOT_FOUND); <line31> } catch (Exception e) { <line32> return new ResponseEntity<Space>(HttpStatus.NOT_FOUND); <line33> } <line34> if (space.isDefault() && this.spaceRepository.findDefault(t.getTenantToken()) != null) { <line35> return new ResponseEntity<Space>(HttpStatus.BAD_REQUEST); <line36> } <line37> space.setTenant(t); <line38> space.setSpaceToken(TokenUtil.generateToken()); <line39> this.spaceRepository.customSave(space); <line40> sw.stop(); <line41> return new ResponseEntity<Space>(space, HttpStatus.CREATED); <line42> } catch (Exception enfe) { <line43> sw.stop(enfe); <line44> return new ResponseEntity<Space>(HttpStatus.INTERNAL_SERVER_ERROR); <line45> } <line46> } <line47> } <line48> "	<line20>, <line22>, <line24>, <line30>, <line32>, <line35>
5859	public class A { <line0> @Override <line1> public void register(final NetworkService service) { <line2> try { <line3> unregister(service); <line4> ServiceInstance<Void> instance = <line5> ServiceInstance.<Void>builder() <line6> .name(service.getType().name()) <line7> .address(service.getAddress()) <line8> .build(); <line9> discovery.registerService(instance); <line10> } catch (KeymasterException e) { <line11> throw e; <line12> } catch (Exception e) { <line13> throw new KeymasterException(e); <line14> } <line15> } <line16> } <line17> 	<line13>
5860	public class A { <line0> private static void setMessageAnnotationMapOnProtonMessage( <line1> MessageImpl protonMessage, <line2> DeviceOperations deviceOperationType, <line3> String deviceTwinMessageVersion) { <line4> Map<Symbol, Object> messageAnnotationsMap = new HashMap<>(); <line5> switch (deviceOperationType) { <line6> case DEVICE_OPERATION_TWIN_GET_REQUEST: <line7> messageAnnotationsMap.put( <line8> Symbol.valueOf(MESSAGE_ANNOTATION_FIELD_KEY_OPERATION), <line9> MESSAGE_ANNOTATION_FIELD_VALUE_GET); <line10> break; <line11> case DEVICE_OPERATION_TWIN_UPDATE_REPORTED_PROPERTIES_REQUEST: <line12> messageAnnotationsMap.put( <line13> Symbol.valueOf(MESSAGE_ANNOTATION_FIELD_KEY_OPERATION), <line14> MESSAGE_ANNOTATION_FIELD_VALUE_PATCH); <line15> messageAnnotationsMap.put( <line16> Symbol.valueOf(MESSAGE_ANNOTATION_FIELD_KEY_RESOURCE), <line17> MESSAGE_ANNOTATION_FIELD_VALUE_PROPERTIES_REPORTED); <line18> if (deviceTwinMessageVersion != null) { <line19> try { <line20> messageAnnotationsMap.put( <line21> Symbol.valueOf(MESSAGE_ANNOTATION_FIELD_KEY_VERSION), <line22> Long.parseLong(deviceTwinMessageVersion)); <line23> } catch (NumberFormatException e) { <line24> } <line25> } <line26> break; <line27> case DEVICE_OPERATION_TWIN_SUBSCRIBE_DESIRED_PROPERTIES_REQUEST: <line28> messageAnnotationsMap.put( <line29> Symbol.valueOf(MESSAGE_ANNOTATION_FIELD_KEY_OPERATION), <line30> MESSAGE_ANNOTATION_FIELD_VALUE_PUT); <line31> messageAnnotationsMap.put( <line32> Symbol.valueOf(MESSAGE_ANNOTATION_FIELD_KEY_RESOURCE), <line33> MESSAGE_ANNOTATION_FIELD_VALUE_NOTIFICATIONS_TWIN_PROPERTIES_DESIRED); <line34> break; <line35> case DEVICE_OPERATION_TWIN_UNSUBSCRIBE_DESIRED_PROPERTIES_REQUEST: <line36> messageAnnotationsMap.put( <line37> Symbol.valueOf(MESSAGE_ANNOTATION_FIELD_KEY_OPERATION), <line38> MESSAGE_ANNOTATION_FIELD_VALUE_DELETE); <line39> messageAnnotationsMap.put( <line40> Symbol.valueOf(MESSAGE_ANNOTATION_FIELD_KEY_RESOURCE), <line41> MESSAGE_ANNOTATION_FIELD_VALUE_NOTIFICATIONS_TWIN_PROPERTIES_DESIRED); <line42> break; <line43> default: <line44> } <line45> if (protonMessage.getMessageAnnotations() != null <line46> && protonMessage.getMessageAnnotations().getValue() != null) { <line47> messageAnnotationsMap.putAll(protonMessage.getMessageAnnotations().getValue()); <line48> } <line49> MessageAnnotations messageAnnotations = new MessageAnnotations(messageAnnotationsMap); <line50> protonMessage.setMessageAnnotations(messageAnnotations); <line51> } <line52> } <line53> 	<line24>, <line44>
5861	"public class A { <line0> public AuthenticationResponse login(String username, String password) throws CatalogException { <line1> ParamUtils.checkParameter(username, ""userId""); <line2> ParamUtils.checkParameter(password, ""password""); <line3> String authId = null; <line4> AuthenticationResponse response = null; <line5> for (Map.Entry<String, AuthenticationManager> entry : authenticationManagerMap.entrySet()) { <line6> AuthenticationManager authenticationManager = entry.getValue(); <line7> try { <line8> response = authenticationManager.authenticate(username, password); <line9> authId = entry.getKey(); <line10> break; <line11> } catch (CatalogAuthenticationException e) { <line12> } <line13> } <line14> if (response == null) { <line15> auditManager.auditUser( <line16> username, <line17> Enums.Action.LOGIN, <line18> username, <line19> new AuditRecord.Status( <line20> AuditRecord.Status.Result.ERROR, new Error(0, """", ""Incorrect user or password.""))); <line21> throw CatalogAuthenticationException.incorrectUserOrPassword(); <line22> } <line23> auditManager.auditUser( <line24> username, <line25> Enums.Action.LOGIN, <line26> username, <line27> new AuditRecord.Status(AuditRecord.Status.Result.SUCCESS)); <line28> String userId = authenticationManagerMap.get(authId).getUserId(response.getToken()); <line29> if (!INTERNAL_AUTHORIZATION.equals(authId)) { <line30> try { <line31> userDBAdaptor.checkId(userId); <line32> } catch (CatalogDBException e) { <line33> User user = <line34> authenticationManagerMap <line35> .get(authId) <line36> .getRemoteUserInformation(Collections.singletonList(userId)) <line37> .get(0); <line38> String rootToken = <line39> authenticationManagerMap.get(INTERNAL_AUTHORIZATION).createToken(OPENCGA); <line40> create(user, null, rootToken); <line41> } <line42> try { <line43> List<String> remoteGroups = <line44> authenticationManagerMap.get(authId).getRemoteGroups(response.getToken()); <line45> studyDBAdaptor.resyncUserWithSyncedGroups(userId, remoteGroups, authId); <line46> } catch (CatalogException e) { <line47> } <line48> } <line49> return response; <line50> } <line51> } <line52> "	<line12>, <line47>
5862	public class A { <line0> public int cancel() { <line1> return 0; <line2> } <line3> } <line4> 	<line1>
5863	"public class A { <line0> private ProjectInstance deserializeProjectDesc(ProjectRequest projectRequest) { <line1> ProjectInstance projectDesc = null; <line2> try { <line3> projectDesc = JsonUtil.readValue(projectRequest.getProjectDescData(), ProjectInstance.class); <line4> } catch (Exception e) { <line5> throw new InternalErrorException(""Failed to deal with the request:"" + e.getMessage(), e); <line6> } <line7> return projectDesc; <line8> } <line9> } <line10> "	<line3>, <line5>
5864	"public class A { <line0> private List<Robot> sendGetRobots(String accessToken) { <line1> Properties headers = new Properties(); <line2> headers.setProperty(""Accept"", ""application/vnd.neato.nucleo.v1""); <line3> headers.setProperty(""Authorization"", ""Token token="" + accessToken); <line4> try { <line5> String resultString = <line6> HttpUtil.executeUrl( <line7> ""GET"", <line8> ""https://beehive.neatocloud.com/dashboard"", <line9> headers, <line10> null, <line11> ""application/json"", <line12> 20000); <line13> Gson gson = new Gson(); <line14> NeatoAccountInformation accountInformation = <line15> gson.fromJson(resultString, NeatoAccountInformation.class); <line16> return accountInformation.getRobots(); <line17> } catch (IOException e) { <line18> updateStatus( <line19> ThingStatus.OFFLINE, <line20> ThingStatusDetail.COMMUNICATION_ERROR, <line21> ""Error attempting to find robots registered to account""); <line22> return new ArrayList<>(); <line23> } <line24> } <line25> } <line26> "	<line16>, <line18>
5865	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> try { <line4> if (lookupBlockchainProcessor().isDownloading()) { <line5> return; <line6> } <line7> Peer peer = peers.getAnyPeer(PeerState.CONNECTED, true); <line8> if (peer == null) { <line9> return; <line10> } <line11> GetUnconfirmedTransactionsRequest request = <line12> new GetUnconfirmedTransactionsRequest(blockchainConfig.getChain().getChainId()); <line13> List<String> exclude = new ArrayList<>(); <line14> memPool <line15> .getAllProcessedIds() <line16> .forEach(transactionId -> exclude.add(Long.toUnsignedString(transactionId))); <line17> Collections.sort(exclude); <line18> request.setExclude(exclude); <line19> GetUnconfirmedTransactionsResponse response = <line20> peer.send(request, new GetUnconfirmedTransactionsResponseParser()); <line21> if (response == null || CollectionUtil.isEmpty(response.unconfirmedTransactions)) { <line22> return; <line23> } <line24> try { <line25> List<Transaction> transactions = <line26> response.unconfirmedTransactions.stream() <line27> .map(dtoConverter::convert) <line28> .collect(Collectors.toList()); <line29> transactionProcessor.processPeerTransactions(transactions); <line30> } catch (AplException.NotValidException | RuntimeException e) { <line31> peer.blacklist(e); <line32> } <line33> } catch (Exception e) { <line34> } <line35> } catch (Throwable t) { <line36> t.printStackTrace(); <line37> System.exit(1); <line38> } <line39> } <line40> } <line41> 	<line29>, <line34>, <line36>
5866	"public class A { <line0> @Override <line1> public void run() { <line2> Random rnd = new Random(); <line3> try { <line4> Ignite ignite = startClientGrid(SRV_CNT + idx); <line5> assertTrue(ignite.configuration().isClientMode()); <line6> for (int i = 0; i < CACHES / 2; i++) { <line7> String cacheName = ""cache-"" + rnd.nextInt(CACHES); <line8> IgniteCache<Object, Object> cache = getCache(ignite, cacheName); <line9> cache.put(ignite.cluster().localNode().id(), UUID.randomUUID()); <line10> IgniteAtomicSequence seq = ignite.atomicSequence(""seq-"" + rnd.nextInt(20), 0, true); <line11> seq.getAndIncrement(); <line12> } <line13> while (!stopped) { <line14> IgniteCache<Object, Object> cache = getCache(ignite, ""cache-"" + rnd.nextInt(CACHES)); <line15> int val = Math.abs(rnd.nextInt(100)); <line16> if (val >= 0 && val < 40) cache.containsKey(ignite.cluster().localNode().id()); <line17> else if (val >= 40 && val < 80) cache.get(ignite.cluster().localNode().id()); <line18> else cache.put(ignite.cluster().localNode().id(), UUID.randomUUID()); <line19> Thread.sleep(10); <line20> } <line21> } catch (Exception e) { <line22> failed.set(true); <line23> } <line24> } <line25> } <line26> "	<line22>
5867	public class A { <line0> @Override <line1> public boolean startEnforcement(String agreementId) { <line2> IEnforcementJob job = enforcementJobDAO.getByAgreementId(agreementId); <line3> if (job == null) { <line4> return false; <line5> } <line6> job.setEnabled(true); <line7> enforcementJobDAO.save(job); <line8> IAgreement agreement = agreementDAO.getByAgreementId(agreementId); <line9> for (IGuaranteeTerm term : agreement.getGuaranteeTerms()) { <line10> if (term.getStatus() == null <line11> || GuaranteeTermStatusEnum.NON_DETERMINED.equals(term.getStatus())) { <line12> term.setStatus(GuaranteeTermStatusEnum.FULFILLED); <line13> } <line14> guaranteeTermDAO.save(term); <line15> } <line16> return true; <line17> } <line18> } <line19> 	<line2>
5868	"public class A { <line0> @Override <line1> public void execute() throws ResourceAllocationException { <line2> try { <line3> validateParameters(); <line4> VirtualMachineTemplate template = _templateService.registerTemplate(this); <line5> if (template != null) { <line6> ListResponse<TemplateResponse> response = new ListResponse<TemplateResponse>(); <line7> List<TemplateResponse> templateResponses = <line8> _responseGenerator.createTemplateResponses( <line9> getResponseView(), template, getZoneIds(), false); <line10> response.setResponses(templateResponses); <line11> response.setResponseName(getCommandName()); <line12> setResponseObject(response); <line13> } else { <line14> throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to register template""); <line15> } <line16> } catch (URISyntaxException ex1) { <line17> throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ex1.getMessage()); <line18> } <line19> } <line20> } <line21> "	<line17>
5869	public class A { <line0> public static String getOwnerName(final File file) { <line1> try { <line2> final Path path = Paths.get(file.getAbsolutePath()); <line3> final FileOwnerAttributeView ownerAttributeView = <line4> Files.getFileAttributeView(path, FileOwnerAttributeView.class); <line5> return ownerAttributeView != null ? ownerAttributeView.getOwner().getName() : null; <line6> } catch (Exception e) { <line7> return null; <line8> } <line9> } <line10> } <line11> 	<line7>
5870	public class A { <line0> @Override <line1> public Set<BookieId> onClusterChanged( <line2> Set<BookieId> writableBookies, Set<BookieId> readOnlyBookies) { <line3> rwLock.writeLock().lock(); <line4> try { <line5> ImmutableSet<BookieId> joinedBookies, leftBookies, deadBookies; <line6> Set<BookieId> oldBookieSet = knownBookies.keySet(); <line7> leftBookies = Sets.difference(oldBookieSet, writableBookies).immutableCopy(); <line8> joinedBookies = Sets.difference(writableBookies, oldBookieSet).immutableCopy(); <line9> deadBookies = Sets.difference(leftBookies, readOnlyBookies).immutableCopy(); <line10> handleBookiesThatLeft(leftBookies); <line11> handleBookiesThatJoined(joinedBookies); <line12> if (this.isWeighted && (leftBookies.size() > 0 || joinedBookies.size() > 0)) { <line13> this.weightedSelection.updateMap(this.bookieInfoMap); <line14> } <line15> if (!readOnlyBookies.isEmpty()) { <line16> this.readOnlyBookies = ImmutableSet.copyOf(readOnlyBookies); <line17> } <line18> return deadBookies; <line19> } finally { <line20> rwLock.writeLock().unlock(); <line21> } <line22> } <line23> } <line24> 	<line10>
5871	"public class A { <line0> public void start() { <line1> try (MDCCloseable mdc = Logging.withPrefixCloseable(RpcClientFactory.LOG_PREFIX)) { <line2> kafkaConfig.clear(); <line3> kafkaConfig.put(ConsumerConfig.GROUP_ID_CONFIG, SystemInfoUtils.getInstanceId()); <line4> kafkaConfig.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, ""1000""); <line5> kafkaConfig.put( <line6> ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, <line7> StringDeserializer.class.getCanonicalName()); <line8> kafkaConfig.put( <line9> ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, <line10> ByteArrayDeserializer.class.getCanonicalName()); <line11> kafkaConfig.put( <line12> ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName()); <line13> kafkaConfig.put( <line14> ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, <line15> ByteArraySerializer.class.getCanonicalName()); <line16> KafkaConfigProvider kafkaConfigProvider = <line17> new OnmsKafkaConfigProvider(KafkaRpcConstants.KAFKA_RPC_CONFIG_SYS_PROP_PREFIX); <line18> kafkaConfig.putAll(kafkaConfigProvider.getProperties()); <line19> producer = new KafkaProducer<>(kafkaConfig); <line20> startKafkaConsumer(); <line21> metricsReporter = JmxReporter.forRegistry(getMetrics()).inDomain(JMX_DOMAIN_RPC).build(); <line22> metricsReporter.start(); <line23> tracerRegistry.init(SystemInfoUtils.getInstanceId()); <line24> tracer = tracerRegistry.getTracer(); <line25> timerExecutor.execute( <line26> () -> { <line27> while (true) { <line28> try { <line29> ResponseCallback responseCb = delayQueue.take(); <line30> if (!responseCb.isProcessed()) { <line31> responseHandlerExecutor.execute(() -> responseCb.sendResponse(null)); <line32> } <line33> } catch (InterruptedException e) { <line34> break; <line35> } catch (Exception e) { <line36> } <line37> } <line38> }); <line39> } <line40> } <line41> } <line42> "	<line20>, <line21>, <line31>, <line34>, <line36>, <line39>
5872	public class A { <line0> Future<ReconciliationState> zkScalingCheck() { <line1> return zkScaler(zkCluster.getReplicas()) <line2> .compose( <line3> zkScaler -> { <line4> Promise<ReconciliationState> scalingPromise = Promise.promise(); <line5> zkScaler <line6> .scale(zkCluster.getReplicas()) <line7> .onComplete( <line8> res -> { <line9> zkScaler.close(); <line10> if (res.succeeded()) { <line11> scalingPromise.complete(this); <line12> } else { <line13> scalingPromise.fail(res.cause()); <line14> } <line15> }); <line16> return scalingPromise.future(); <line17> }); <line18> } <line19> } <line20> 	<line1>, <line13>
5873	public class A { <line0> protected Map<String, Object> ingest( <line1> final AccessResult<String> accessResult, final Map<String, Object> map) { <line2> if (ingestFactory == null) { <line3> return map; <line4> } <line5> Map<String, Object> target = map; <line6> for (final Ingester ingester : ingestFactory.getIngesters()) { <line7> try { <line8> target = ingester.process(target, accessResult); <line9> } catch (final Exception e) { <line10> } <line11> } <line12> return target; <line13> } <line14> } <line15> 	<line10>
5874	public class A { <line0> @Override <line1> public void log(final LogItem logItem) { <line2> this.logItemRequestMessageSender.send(logItem); <line3> } <line4> } <line5> 	<line2>
5875	public class A { <line0> static void waitTillCondition( <line1> Function<Boolean, Boolean> condition, Future dsFuture, long timeoutInSecs) throws Exception { <line2> Future<Boolean> res = <line3> Executors.newSingleThreadExecutor() <line4> .submit( <line5> () -> { <line6> boolean ret = false; <line7> while (!ret && !dsFuture.isDone()) { <line8> try { <line9> Thread.sleep(3000); <line10> ret = condition.apply(true); <line11> } catch (Throwable error) { <line12> ret = false; <line13> } <line14> } <line15> return true; <line16> }); <line17> res.get(timeoutInSecs, TimeUnit.SECONDS); <line18> } <line19> } <line20> 	<line12>
5876	"public class A { <line0> @Override <line1> public Observable<JobStatus> getStatus(final UUID applicationId, UUID jobId) { <line2> Preconditions.checkNotNull(applicationId, ""app id is null""); <line3> Preconditions.checkNotNull(jobId, ""job id is null""); <line4> return Observable.create( <line5> subscriber -> { <line6> final String jobString = StringUtils.sanitizeUUID(jobId); <line7> Id appId = CpNamingUtils.generateApplicationId(applicationId); <line8> final MapManager mapManager = <line9> mapManagerFactory.createMapManager(new MapScopeImpl(appId, ""status"")); <line10> try { <line11> String statusVal = mapManager.getString(jobString + statusKey); <line12> if (statusVal == null) { <line13> subscriber.onCompleted(); <line14> } else { <line15> final Map<String, Object> data = <line16> MAPPER.readValue(mapManager.getString(jobString + dataKey), Map.class); <line17> final Status status = Status.valueOf(statusVal); <line18> subscriber.onNext(new JobStatus(jobId, status, data)); <line19> } <line20> subscriber.onCompleted(); <line21> } catch (Exception e) { <line22> throw new RuntimeException(e); <line23> } <line24> }); <line25> } <line26> } <line27> "	<line22>
5877	"public class A { <line0> public void cleanIntpContext(String nodeId) { <line1> String keyPrex = nodeId + ""@""; <line2> for (Map.Entry<String, InterpreterContext> entity : noteParagraphId2IntpContext.entrySet()) { <line3> String key = entity.getKey(); <line4> if (key.contains(keyPrex)) { <line5> noteParagraphId2IntpContext.remove(key); <line6> } <line7> } <line8> } <line9> } <line10> "	<line5>
5878	public class A { <line0> @Override <line1> public Part getPart(String name) { <line2> Optional<FileUpload> upload = <line3> context.fileUploads().stream() <line4> .filter(fileUpload -> fileUpload.name().equals(name)) <line5> .findFirst(); <line6> if (!upload.isPresent()) { <line7> return null; <line8> } <line9> final FileUpload fileUpload = upload.get(); <line10> return new FileUploadPart(fileUpload); <line11> } <line12> } <line13> 	<line7>
5879	public class A { <line0> private void mockSendRPCTasks( <line1> ExecutorService rpcExecutor, int rpcNum, SegmentQueryResult.Builder builder, int resultSize) { <line2> List<Future> futures = Lists.newArrayList(); <line3> for (int i = 0; i < rpcNum; i++) { <line4> Future future = rpcExecutor.submit(new MockRPCTask(resultSize, 10, builder)); <line5> futures.add(future); <line6> } <line7> for (Future future : futures) { <line8> try { <line9> future.get(); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> } <line15> 	<line11>
5880	"public class A { <line0> @Override <line1> public boolean checkAndMutate( <line2> final byte[] row, <line3> final byte[] family, <line4> final byte[] qualifier, <line5> final CompareFilter.CompareOp compareOp, <line6> final byte[] value, <line7> final RowMutations rm) <line8> throws IOException { <line9> ConditionalRowMutation request = <line10> new CheckAndMutateUtil.RequestBuilder(hbaseAdapter, row, family) <line11> .qualifier(qualifier) <line12> .ifMatches(compareOp, value) <line13> .withMutations(rm) <line14> .build(); <line15> return checkAndMutate(row, request, ""checkAndMutate""); <line16> } <line17> } <line18> "	<line9>
5881	"public class A { <line0> private synchronized void onNotification(Notification notification) { <line1> if (""com.sun.management.gc.notification"".equals(notification.getType())) { <line2> GarbageCollectionNotificationInfo info = <line3> new GarbageCollectionNotificationInfo((CompositeData) notification.getUserData()); <line4> if (info.isMajorGc()) { <line5> majorGcCount.incrementAndGet(); <line6> majorGcTime.addAndGet(info.getDurationMs()); <line7> majorGc.add(info.getDurationMs(), MILLISECONDS); <line8> long applicationRuntime = max(0, info.getStartTime() - lastGcEndTime); <line9> lastGcEndTime = info.getEndTime(); <line10> } else if (info.isMinorGc()) { <line11> minorGc.add(info.getDurationMs(), MILLISECONDS); <line12> } <line13> } <line14> } <line15> } <line16> "	<line10>, <line12>
5882	public class A { <line0> public org.apache.thrift.async.AsyncMethodCallback<RemoteApplicationResult> getResultHandler( <line1> final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, <line2> final int seqid) { <line3> final org.apache.thrift.AsyncProcessFunction fcall = this; <line4> return new org.apache.thrift.async.AsyncMethodCallback<RemoteApplicationResult>() { <line5> public void onComplete(RemoteApplicationResult o) { <line6> unloadApplication_result result = new unloadApplication_result(); <line7> result.success = o; <line8> try { <line9> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line10> } catch (org.apache.thrift.transport.TTransportException e) { <line11> fb.close(); <line12> } catch (java.lang.Exception e) { <line13> onError(e); <line14> } <line15> } <line16>  <line17> public void onError(java.lang.Exception e) { <line18> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line19> org.apache.thrift.TSerializable msg; <line20> unloadApplication_result result = new unloadApplication_result(); <line21> if (e instanceof InterpreterRPCException) { <line22> result.ex = (InterpreterRPCException) e; <line23> result.setExIsSet(true); <line24> msg = result; <line25> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line26> fb.close(); <line27> return; <line28> } else if (e instanceof org.apache.thrift.TApplicationException) { <line29> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line30> msg = (org.apache.thrift.TApplicationException) e; <line31> } else { <line32> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line33> msg = <line34> new org.apache.thrift.TApplicationException( <line35> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line36> } <line37> try { <line38> fcall.sendResponse(fb, msg, msgType, seqid); <line39> } catch (java.lang.Exception ex) { <line40> fb.close(); <line41> } <line42> } <line43> }; <line44> } <line45> } <line46> 	<line11>, <line13>, <line26>, <line29>, <line32>, <line40>
5883	"public class A { <line0> @Override <line1> public void onBeforeRemove(DDMFormInstance ddmFormInstance) throws ModelListenerException { <line2> try { <line3> DDMFormInstanceReport ddmFormInstanceReport = <line4> ddmFormInstanceReportLocalService.getFormInstanceReportByFormInstanceId( <line5> ddmFormInstance.getFormInstanceId()); <line6> TransactionCommitCallbackUtil.registerCallback( <line7> () -> { <line8> _ddmFormInstanceReportPortalExecutor.execute( <line9> () -> <line10> ddmFormInstanceReportLocalService.deleteDDMFormInstanceReport( <line11> ddmFormInstanceReport.getFormInstanceReportId())); <line12> return null; <line13> }); <line14> } catch (Exception exception) { <line15> if (_log.isWarnEnabled()) { <line16> StringBundler sb = new StringBundler(4); <line17> sb.append(""Unable to update dynamic data mapping form ""); <line18> sb.append(""instance report for dynamic data mapping form ""); <line19> sb.append(""instance ""); <line20> sb.append(ddmFormInstance.getFormInstanceId()); <line21> } <line22> } <line23> } <line24> } <line25> "	<line21>
5884	"public class A { <line0> @Override <line1> public void endElement(final String uri, final String localName, final String name) <line2> throws SAXException { <line3> if (name.toLowerCase().startsWith(""x-"")) { <line4> } else { <line5> super.endElement(m_xmlns, localName, name); <line6> } <line7> } <line8> } <line9> "	<line4>
5885	"public class A { <line0> @Activate <line1> public void activate(Map<String, Object> properties) { <line2> Object portletName = properties.get(""javax.portlet.name""); <line3> } <line4> } <line5> "	<line3>
5886	"public class A { <line0> @SuppressWarnings(""Duplicates"") <line1> public void assertExpected(BlockingQueue<Frame> framesQueue, List<Frame> expect) <line2> throws InterruptedException { <line3> int expectedCount = expect.size(); <line4> String prefix; <line5> for (int i = 0; i < expectedCount; i++) { <line6> prefix = ""Frame["" + i + ""]""; <line7> Frame expected = expect.get(i); <line8> Frame actual = framesQueue.poll(3, TimeUnit.SECONDS); <line9> assertThat(prefix + "".poll"", actual, notNullValue()); <line10> if (logger.isDebugEnabled()) { <line11> if (actual.getOpCode() == OpCode.CLOSE) <line12> } <line13> assertThat( <line14> prefix + "".opcode"", <line15> OpCode.name(actual.getOpCode()), <line16> is(OpCode.name(expected.getOpCode()))); <line17> prefix += ""(op="" + actual.getOpCode() + "","" + (actual.isFin() ? """" : ""!"") + ""fin)""; <line18> if (expected.getOpCode() == OpCode.CLOSE) { <line19> CloseStatus expectedClose = new CloseStatus(expected.getPayload()); <line20> CloseStatus actualClose = new CloseStatus(actual.getPayload()); <line21> assertThat(prefix + "".code"", actualClose.getCode(), is(expectedClose.getCode())); <line22> } else if (expected.hasPayload()) { <line23> if (expected.getOpCode() == OpCode.TEXT) { <line24> String expectedText = expected.getPayloadAsUTF8(); <line25> String actualText = actual.getPayloadAsUTF8(); <line26> assertThat(prefix + "".text-payload"", actualText, is(expectedText)); <line27> } else { <line28> ByteBufferAssert.assertEquals( <line29> prefix + "".payload"", expected.getPayload(), actual.getPayload()); <line30> } <line31> } else { <line32> assertThat(prefix + "".payloadLength"", actual.getPayloadLength(), is(0)); <line33> } <line34> } <line35> } <line36> } <line37> "	<line12>
5887	"public class A { <line0> @Override <line1> public void process(Exchange exchange) <line2> throws CatalogTransformerException, MimeTypeParseException, IOException { <line3> Message in = exchange.getIn(); <line4> String transformerId = in.getHeader(CatalogComponent.ID_PARAMETER, String.class); <line5> String mimeType = in.getHeader(CatalogComponent.MIME_TYPE_PARAMETER, String.class); <line6> if (transformerId != null) { <line7> in.removeHeader(CatalogComponent.ID_PARAMETER); <line8> } else { <line9> transformerId = endpoint.getTransformerId(); <line10> } <line11> if (mimeType != null) { <line12> in.removeHeader(CatalogComponent.MIME_TYPE_PARAMETER); <line13> } else { <line14> mimeType = endpoint.getMimeType(); <line15> } <line16> MimeTypeToTransformerMapper mapper = endpoint.getComponent().getMimeTypeToTransformerMapper(); <line17> Object metacard; <line18> if (mapper != null) { <line19> metacard = transform(in, mimeType, transformerId, mapper); <line20> } else { <line21> throw new CatalogTransformerException(""Did not find a MimeTypeToTransformerMapper service""); <line22> } <line23> in.setBody(metacard); <line24> } <line25> } <line26> "	<line3>, <line7>, <line9>, <line11>, <line14>, <line16>, <line19>, <line21>, <line24>
5888	"public class A { <line0> public List<ActivityFrequencyScheduleBean> getQuestionnaireFrequencyDetailsForWeekly( <line1> QuestionnairesDto questionaire, List<ActivityFrequencyScheduleBean> runDetailsBean) <line2> throws DAOException { <line3> LOGGER.entry(""begin getQuestionnaireFrequencyDetailsForWeekly()""); <line4> try { <line5> if (StringUtils.isNotEmpty(questionaire.getStudyLifetimeStart()) <line6> && StringUtils.isNotEmpty(questionaire.getStudyLifetimeEnd()) <line7> && StringUtils.isNotEmpty(questionaire.getDayOfTheWeek())) { <line8> Integer repeatCount = <line9> ((questionaire.getRepeatQuestionnaire() == null) <line10> || (questionaire.getRepeatQuestionnaire() == 0)) <line11> ? 1 <line12> : questionaire.getRepeatQuestionnaire(); <line13> String questionaireDay = questionaire.getDayOfTheWeek(); <line14> String questionaireStartDate = questionaire.getStudyLifetimeStart(); <line15> while (repeatCount > 0) { <line16> ActivityFrequencyScheduleBean weeklyBean = new ActivityFrequencyScheduleBean(); <line17> String questionaireEndDate; <line18> String day = """"; <line19> String weekEndDate; <line20> boolean flag = false; <line21> boolean skipLoop = false; <line22> if (questionaireDay.equalsIgnoreCase( <line23> StudyMetaDataUtil.getDayByDate(questionaireStartDate))) { <line24> day = questionaireDay; <line25> } <line26> if (!questionaireDay.equalsIgnoreCase(day)) { <line27> while (!questionaireDay.equalsIgnoreCase(day)) { <line28> questionaireStartDate = StudyMetaDataUtil.addDaysToDate(questionaireStartDate, 1); <line29> day = StudyMetaDataUtil.getDayByDate(questionaireStartDate); <line30> } <line31> } <line32> weekEndDate = StudyMetaDataUtil.addWeeksToDate(questionaireStartDate, 1); <line33> if ((StudyMetaDataConstants.SDF_DATE <line34> .parse(StudyMetaDataUtil.getCurrentDate()) <line35> .equals(StudyMetaDataConstants.SDF_DATE.parse(weekEndDate))) <line36> || (StudyMetaDataConstants.SDF_DATE <line37> .parse(StudyMetaDataUtil.getCurrentDate()) <line38> .before(StudyMetaDataConstants.SDF_DATE.parse(weekEndDate)))) { <line39> flag = true; <line40> } <line41> if (flag) { <line42> questionaireEndDate = weekEndDate; <line43> if ((StudyMetaDataConstants.SDF_DATE <line44> .parse(weekEndDate) <line45> .equals( <line46> StudyMetaDataConstants.SDF_DATE.parse(questionaire.getStudyLifetimeEnd()))) <line47> || (StudyMetaDataConstants.SDF_DATE <line48> .parse(weekEndDate) <line49> .after( <line50> StudyMetaDataConstants.SDF_DATE.parse( <line51> questionaire.getStudyLifetimeEnd())))) { <line52> questionaireEndDate = questionaire.getStudyLifetimeEnd(); <line53> skipLoop = true; <line54> } <line55> weeklyBean.setStartTime(questionaireStartDate); <line56> weeklyBean.setEndTime(questionaireEndDate); <line57> runDetailsBean.add(weeklyBean); <line58> if (skipLoop) { <line59> break; <line60> } <line61> } <line62> questionaireStartDate = weekEndDate; <line63> questionaireDay = day; <line64> repeatCount--; <line65> } <line66> } <line67> } catch (Exception e) { <line68> } <line69> LOGGER.exit(""getQuestionnaireFrequencyDetailsForWeekly() :: Ends""); <line70> return runDetailsBean; <line71> } <line72> } <line73> "	<line68>
5889	public class A { <line0> @ExceptionHandler(AuthorizationException.class) <line1> @ResponseStatus(value = HttpStatus.UNAUTHORIZED) <line2> public ErrorResponse handleUnauthenticatedException(AuthorizationException ex) { <line3> return new ErrorResponse(ErrorCode.UNAUTHORIZED); <line4> } <line5> } <line6> 	<line3>
5890	public class A { <line0> @Override <line1> public FileVisitResult visitFileFailed(Path file, IOException ioe) throws IOException { <line2> if (ioe instanceof AccessDeniedException) { <line3> } else { <line4> throw ioe; <line5> } <line6> return CONTINUE; <line7> } <line8> } <line9> 	<line3>
5891	public class A { <line0> @Activate <line1> void activate(BundleContext bundleContext, Map<String, Object> newConfigProperties) <line2> throws IOException { <line3> mapper.configure(MapperFeature.PROPAGATE_TRANSIENT_MARKER, true); <line4> mapper.addMixIn(RepositoryAddress.class, RepositoryAddressMixin.class); <line5> SimpleModule module = new SimpleModule(); <line6> module.addSerializer(DefaultWorkspaceFilter.class, new DefaultWorkspaceFilterSerializer()); <line7> module.addDeserializer(WorkspaceFilter.class, new WorkspaceFilterDeserializer()); <line8> mapper.registerModule(module); <line9> mapper.addMixIn(SimpleCredentials.class, SimpleCredentialsMixin.class); <line10> mapper.addMixIn(ConnectionOptions.class, ConnectionOptionsMixin.class); <line11> mapper.addMixIn(RepositoryCopier.class, RepositoryCopierMixin.class); <line12> this.dataFile = bundleContext.getDataFile(TASKS_DATA_FILE_NAME); <line13> this.configuration = configurationAdmin.getConfiguration(PID); <line14> try { <line15> tasks = loadTasks((String) newConfigProperties.get(PROP_TASKS_SERIALIZATION), dataFile); <line16> } catch (IOException e) { <line17> tasks = new TreeMap<>(); <line18> } <line19> } <line20> } <line21> 	<line17>
5892	"public class A { <line0> @Test <line1> public void testF31Miles() { <line2> setup(VehicleType.CONVENTIONAL.toString(), true); <line3> String content = FileReader.readFileInString(""src/test/resources/responses/F31/status.json""); <line4> assertTrue( <line5> testVehicle( <line6> content, <line7> STATUS_CONV + DOORS + RANGE_CONV + POSITION + SERVICE_AVAILABLE + CHECK_EMPTY, <line8> Optional.empty())); <line9> } <line10> } <line11> "	<line2>
5893	public class A { <line0> public static void recalculateAIPsList(IngestStepBundle bundle, IngestStep step) { <line1> bundle.getAips().clear(); <line2> Set<String> aipsToReturn = new HashSet<>(); <line3> Set<String> transferredResourceAips; <line4> List<String> transferredResourcesToRemoveFromjobPluginInfo = new ArrayList<>(); <line5> boolean oneTransferredResourceAipFailed; <line6> IngestJobPluginInfo jobPluginInfo = bundle.getJobPluginInfo(); <line7> for (Map.Entry<String, Map<String, Report>> transferredResourcejobPluginInfoEntry : <line8> jobPluginInfo.getReportsFromBeingProcessed().entrySet()) { <line9> String transferredResourceId = transferredResourcejobPluginInfoEntry.getKey(); <line10> transferredResourceAips = new HashSet<>(); <line11> oneTransferredResourceAipFailed = false; <line12> if (jobPluginInfo.getAipIds(transferredResourceId) != null) { <line13> for (String aipId : jobPluginInfo.getAipIds(transferredResourceId)) { <line14> Report aipReport = transferredResourcejobPluginInfoEntry.getValue().get(aipId); <line15> if (step.isMandatory() && aipReport.getPluginState() == PluginState.FAILURE) { <line16> oneTransferredResourceAipFailed = true; <line17> break; <line18> } else { <line19> transferredResourceAips.add(aipId); <line20> } <line21> } <line22> if (oneTransferredResourceAipFailed) { <line23> jobPluginInfo.incrementObjectsProcessedWithFailure(); <line24> jobPluginInfo.failOtherTransferredResourceAIPs( <line25> bundle.getModel(), bundle.getIndex(), transferredResourceId); <line26> transferredResourcesToRemoveFromjobPluginInfo.add(transferredResourceId); <line27> } else { <line28> aipsToReturn.addAll(transferredResourceAips); <line29> } <line30> } <line31> } <line32> if (step.isMandatory() && step.removesAips()) { <line33> for (String transferredResourceId : transferredResourcesToRemoveFromjobPluginInfo) { <line34> jobPluginInfo.remove(transferredResourceId); <line35> } <line36> } <line37> for (String aipId : aipsToReturn) { <line38> try { <line39> bundle.getAips().add(bundle.getModel().retrieveAIP(aipId)); <line40> } catch (RequestNotValidException <line41> | NotFoundException <line42> | GenericException <line43> | AuthorizationDeniedException e) { <line44> } <line45> } <line46> } <line47> } <line48> 	<line16>, <line23>, <line44>
5894	public class A { <line0> private TemplateStatus setupDatabaseTemplate( <line1> final TemplateStatus status, final Path profileTemplate, final Path databasePath) { <line2> TemplateStatus result = status; <line3> if (status != TemplateStatus.NO_TEMPLATE) { <line4> try { <line5> unpackProfileTemplate(profileTemplate, databasePath); <line6> } catch (IOException e) { <line7> result = TemplateStatus.NO_TEMPLATE; <line8> } <line9> } <line10> return result; <line11> } <line12> } <line13> 	<line7>
5895	public class A { <line0> protected IRequestHandler mapExpectedExceptions(Exception e, final Application application) { <line1> if (e instanceof StalePageException) { <line2> return new RenderPageRequestHandler(new PageProvider(((StalePageException) e).getPage())); <line3> } else if (e instanceof PageExpiredException) { <line4> return createPageRequestHandler( <line5> new PageProvider(Application.get().getApplicationSettings().getPageExpiredErrorPage())); <line6> } else if (e instanceof AuthorizationException <line7> || e instanceof ListenerInvocationNotAllowedException) { <line8> return createPageRequestHandler( <line9> new PageProvider(Application.get().getApplicationSettings().getAccessDeniedPage())); <line10> } else if (e instanceof ResponseIOException) { <line11> return new EmptyRequestHandler(); <line12> } else if (e instanceof PackageResource.PackageResourceBlockedException <line13> && application.usesDeploymentConfig()) { <line14> return new ErrorCodeRequestHandler(404); <line15> } <line16> return null; <line17> } <line18> } <line19> 	<line11>, <line14>
5896	"public class A { <line0> @Test <line1> public void crudTestWithES() { <line2> PersonRedis person2 = preparePerson(""Amit"", ""2"", 40); <line3> em.persist(person2); <line4> waitThread(10); <line5> PersonRedis fetchPerson = em.find(PersonRedis.class, ""2""); <line6> Assert.assertEquals(""2"", fetchPerson.getPersonId()); <line7> Assert.assertEquals(""Amit"", fetchPerson.getPersonName()); <line8> Assert.assertEquals(40, fetchPerson.getAge().intValue()); <line9> fetchPerson.setAge(50); <line10> em.merge(fetchPerson); <line11> fetchPerson = em.find(PersonRedis.class, ""2""); <line12> Assert.assertEquals(""2"", fetchPerson.getPersonId()); <line13> Assert.assertEquals(""Amit"", fetchPerson.getPersonName()); <line14> Assert.assertEquals(50, fetchPerson.getAge().intValue()); <line15> em.remove(fetchPerson); <line16> fetchPerson = null; <line17> fetchPerson = em.find(PersonRedis.class, ""2""); <line18> Assert.assertNull(fetchPerson); <line19> } <line20> } <line21> "	<line2>
5897	"public class A { <line0> @Override <line1> protected void doService(HttpServletRequest request, HttpServletResponse response) <line2> throws ServletException, IOException { <line3> HttpConsumer consumer = getServletResolveConsumerStrategy().resolve(request, getConsumers()); <line4> if (consumer == null) { <line5> response.sendError(HttpServletResponse.SC_NOT_FOUND); <line6> return; <line7> } <line8> if (consumer.isSuspended()) { <line9> response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE); <line10> return; <line11> } <line12> if (consumer.getEndpoint().getHttpMethodRestrict() != null <line13> && !consumer.getEndpoint().getHttpMethodRestrict().equals(request.getMethod())) { <line14> response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED); <line15> return; <line16> } <line17> if (""TRACE"".equals(request.getMethod()) && !consumer.isTraceEnabled()) { <line18> response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED); <line19> return; <line20> } <line21> if (!(consumer instanceof WebsocketConsumer)) { <line22> response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE); <line23> return; <line24> } <line25> ((WebsocketConsumer) consumer).service(request, response); <line26> } <line27> } <line28> "	<line3>, <line5>, <line9>, <line22>, <line25>
5898	public class A { <line0> @Override <line1> public <T> List<T> query(Class<T> model, QueryRequest request) { <line2> request.setModelClassName(model.getName()); <line3> return edbConverter.convertEDBObjectsToModelObjects(model, edbService.query(request)); <line4> } <line5> } <line6> 	<line2>
5899	public class A { <line0> public void destroy() { <line1> try { <line2> if (mBeanServer != null) { <line3> mBeanServer.unregisterMBean(objectName); <line4> } <line5> } catch (Throwable t) { <line6> } <line7> } <line8> } <line9> 	<line3>, <line6>
5900	public class A { <line0> private void refreshAllTasks() { <line1> final List<DataSourceInfoModel> dataSources = <line2> dataSourceConfigStore.findDataSourceInfos(DataSourceInfoStatus.ONLINE, namespace); <line3> if (dataSources.isEmpty()) return; <line4> dataSourceInfoMap.clear(); <line5> loadTasksFromDB(dataSources); <line6> shutdownOfflineTasks(); <line7> } <line8> } <line9> 	<line3>
5901	public class A { <line0> @Override <line1> public void export() { <line2> if (this.processing.compareAndSet(false, true)) { <line3> long latestTimestamp = System.currentTimeMillis(); <line4> try { <line5> exportGroups(); <line6> } catch (Exception ex) { <line7> } finally { <line8> this.latestTimestamp = new Date(latestTimestamp); <line9> flushQuietly(); <line10> this.processing.set(false); <line11> } <line12> } <line13> } <line14> } <line15> 	<line7>
5902	"public class A { <line0> public void actionPerformed(ActionEvent ev) { <line1> try { <line2> synchronized (document) { <line3> document.replace(0, document.getLength(), """", null); <line4> } <line5> } catch (BadLocationException ex) { <line6> } <line7> lockedCaretPosition = 0; <line8> } <line9> } <line10> "	<line6>
5903	public class A { <line0> public static boolean registerDriver(Driver driver) { <line1> try { <line2> DriverManager.registerDriver(driver); <line3> try { <line4> MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer(); <line5> ObjectName objectName = new ObjectName(MBEAN_NAME); <line6> if (!mbeanServer.isRegistered(objectName)) { <line7> mbeanServer.registerMBean(instance, objectName); <line8> } <line9> } catch (Throwable ex) { <line10> if (LOG == null) { <line11> LOG = LogFactory.getLog(DruidDriver.class); <line12> } <line13> } <line14> return true; <line15> } catch (Exception e) { <line16> if (LOG == null) { <line17> LOG = LogFactory.getLog(DruidDriver.class); <line18> } <line19> } <line20> return false; <line21> } <line22> } <line23> 	<line13>, <line19>
5904	"public class A { <line0> @Test <line1> public void put2() { <line2> final ArrayQueue<String> queue = new ArrayQueue<>(3); <line3> new Thread( <line4> () -> { <line5> try { <line6> } catch (Exception e) { <line7> } <line8> }) <line9> .start(); <line10> queue.put(""123""); <line11> queue.put(""1234""); <line12> queue.put(""12345""); <line13> queue.put(""123456""); <line14> while (!queue.isEmpty()) { <line15> } <line16> } <line17> } <line18> "	<line6>, <line14>, <line15>
5905	"public class A { <line0> private SslContextFactory createSslContextFactory(Ssl properties) { <line1> final SslContextFactory.Server contextFactory = new SslContextFactory.Server(); <line2> if (properties.getClientAuth() == Ssl.ClientAuth.NEED) { <line3> contextFactory.setNeedClientAuth(true); <line4> } else { <line5> contextFactory.setWantClientAuth(true); <line6> } <line7> if (StringUtils.isNotBlank(properties.getKeyStore())) { <line8> contextFactory.setKeyStorePath(properties.getKeyStore()); <line9> } <line10> if (StringUtils.isNotBlank(properties.getKeyStoreType())) { <line11> contextFactory.setKeyStoreType(properties.getKeyStoreType()); <line12> } <line13> final String keystorePassword = properties.getKeyStorePassword(); <line14> final String keyPassword = properties.getKeyPassword(); <line15> if (StringUtils.isEmpty(keystorePassword)) { <line16> throw new IllegalArgumentException(""The keystore password cannot be null or empty""); <line17> } else { <line18> final String defaultKeyPassword = <line19> (StringUtils.isBlank(keyPassword)) ? keystorePassword : keyPassword; <line20> contextFactory.setKeyStorePassword(keystorePassword); <line21> contextFactory.setKeyManagerPassword(defaultKeyPassword); <line22> } <line23> if (StringUtils.isNotBlank(properties.getTrustStore())) { <line24> contextFactory.setTrustStorePath(properties.getTrustStore()); <line25> } <line26> if (StringUtils.isNotBlank(properties.getTrustStoreType())) { <line27> contextFactory.setTrustStoreType(properties.getTrustStoreType()); <line28> } <line29> if (StringUtils.isNotBlank(properties.getTrustStorePassword())) { <line30> contextFactory.setTrustStorePassword(properties.getTrustStorePassword()); <line31> } <line32> return contextFactory; <line33> } <line34> } <line35> "	<line3>, <line5>
5906	public class A { <line0> private void finalizeSpan(final Trace trace, String methodUri, Throwable throwable) { <line1> try { <line2> finalizeSpanEvent(trace, null, throwable); <line3> SpanRecorder recorder = trace.getSpanRecorder(); <line4> recorder.recordRpcName(methodUri); <line5> } catch (Throwable t) { <line6> } finally { <line7> trace.close(); <line8> } <line9> } <line10> } <line11> 	<line6>
5907	public class A { <line0> public void initializeFeedEventStatistics() { <line1> String backupLocation = <line2> ConfigurationProperties.getInstance().getFeedEventStatisticsBackupLocation(); <line3> if (backupLocation != null) { <line4> FeedEventStatistics.getInstance().setBackupLocation(backupLocation); <line5> } <line6> boolean success = FeedEventStatistics.getInstance().loadBackup(); <line7> if (success) { <line8> } else { <line9> } <line10> } <line11> } <line12> 	<line8>, <line9>
5908	public class A { <line0> @Override <line1> public DataType getHiveResultType(Object[] constantArguments, DataType[] argTypes) { <line2> try { <line3> ObjectInspector[] argumentInspectors = <line4> HiveInspectors.toInspectors(hiveShim, constantArguments, argTypes); <line5> return HiveTypeUtil.toFlinkType( <line6> hiveFunctionWrapper.createFunction().initialize(argumentInspectors)); <line7> } catch (UDFArgumentException e) { <line8> throw new FlinkHiveUDFException(e); <line9> } <line10> } <line11> } <line12> 	<line2>
5909	"public class A { <line0> private void loadRelations() throws FileNotFoundException, IOException { <line1> AtomicInteger counter = new AtomicInteger(0); <line2> try (BufferedReader reader = new BufferedReader(new FileReader(relationshipFile))) { <line3> reader <line4> .lines() <line5> .forEach( <line6> line -> { <line7> String[] tokens = line.split(UMLS_DELIMITER); <line8> String aui1 = tokens[1]; <line9> String rela = tokens[7]; <line10> String aui2 = tokens[5]; <line11> String rg = tokens[12]; <line12> String dir = tokens[13]; <line13> String suppress = tokens[14]; <line14> if (!""N"".equals(dir) && !""O"".equals(suppress)) { <line15> String scui1 = auiToScuiMap.get(aui1); <line16> String scui2 = auiToScuiMap.get(aui2); <line17> if (scui1 != null && scui2 != null) { <line18> Vertex v1 = vertexMap.get(scui1); <line19> Vertex v2 = vertexMap.get(scui2); <line20> if (v1 != null && v2 != null) { <line21> String label = toLabel(rela); <line22> if (labelFilter.accept(label)) { <line23> if (janusGraph.getEdgeLabel(label) == null) { <line24> JanusGraphManagement management = janusGraph.openManagement(); <line25> management.makeEdgeLabel(label).make(); <line26> management.commit(); <line27> } <line28> Edge e = g.V(v2).addE(label).to(v1).next(); <line29> if (!"""".equals(rg)) { <line30> g.E(e).property(""group"", rg).next(); <line31> } <line32> } <line33> } <line34> if ((counter.get() % 10000) == 0) { <line35> g.tx().commit(); <line36> } <line37> counter.getAndIncrement(); <line38> } <line39> } <line40> }); <line41> g.tx().commit(); <line42> } <line43> } <line44> } <line45> "	<line1>, <line24>, <line35>, <line42>
5910	"public class A { <line0> private void deconfigureLogging(OutputStream os) { <line1> if (_debug) return; <line2> try { <line3> os.flush(); <line4> os.close(); <line5> } catch (Exception any) { <line6> } <line7> org.apache.log4j.Logger logger = org.apache.log4j.Logger.getRootLogger(); <line8> logger.removeAppender(""bundlebuilder.out""); <line9> } <line10> } <line11> "	<line2>, <line6>
5911	public class A { <line0> @Override <line1> public final <T extends WorkerResourceDescription> void handleDependencyFreeActions( <line2> List<AllocatableAction> dataFreeActions, <line3> List<AllocatableAction> resourceFreeActions, <line4> List<AllocatableAction> blockedCandidates, <line5> ResourceScheduler<T> resource) { <line6> if (DEBUG) { <line7> } <line8> manageUpgradedActions(resource); <line9> if (resource.canRunSomething()) { <line10> this.availableWorkers.add(resource); <line11> } <line12> purgeFreeActions(dataFreeActions, resourceFreeActions, blockedCandidates, resource); <line13> tryToLaunchFreeActions(dataFreeActions, resourceFreeActions, blockedCandidates, resource); <line14> } <line15> } <line16> 	<line7>
5912	"public class A { <line0> @RequestMapping( <line1> value = ""/getConfig"", <line2> method = {RequestMethod.GET}, <line3> produces = {""application/json""}) <line4> @ResponseBody <line5> public List<StreamingConfig> getStreamings( <line6> @RequestParam(value = ""table"", required = false) String table, <line7> @RequestParam(value = ""project"", required = false) String project, <line8> @RequestParam(value = ""limit"", required = false) Integer limit, <line9> @RequestParam(value = ""offset"", required = false) Integer offset) { <line10> try { <line11> return streamingService.getStreamingConfigs(table, project, limit, offset); <line12> } catch (IOException e) { <line13> throw new InternalErrorException( <line14> ""Failed to deal with the request: "" + e.getLocalizedMessage(), e); <line15> } <line16> } <line17> } <line18> "	<line13>
5913	public class A { <line0> public void signalConnectionLost(final RtuDevice rtu) { <line1> final GetDataResponseDto dataResponse = <line2> new GetDataResponseDto( <line3> Arrays.asList( <line4> new GetDataSystemIdentifierDto( <line5> SYSTEM_ID, <line6> SYSTEM_TYPE, <line7> Arrays.asList( <line8> new MeasurementDto( <line9> MEASUREMENT_ID, <line10> MEASUREMENT_NODE, <line11> 0, <line12> new DateTime(DateTimeZone.UTC), <line13> MEASUREMENT_VALUE_ALARM_ON)))), <line14> null); <line15> final String correlationUid = this.createCorrelationUid(rtu); <line16> final String organisationIdentification = rtu.getOwner().getOrganisationIdentification(); <line17> final String deviceIdentification = rtu.getDeviceIdentification(); <line18> final CorrelationIds ids = <line19> new CorrelationIds(organisationIdentification, deviceIdentification, correlationUid); <line20> this.adHocManagementService.handleInternalDataResponse( <line21> dataResponse, ids, DeviceFunction.GET_DATA.toString()); <line22> } <line23> } <line24> 	<line1>
5914	public class A { <line0> private T checkHealthyAndRetry(T resource, long endTimeMs) throws TimeoutException, IOException { <line1> if (isHealthy(resource)) { <line2> return resource; <line3> } else { <line4> remove(resource); <line5> closeResource(resource); <line6> return acquire(endTimeMs - mClock.millis(), TimeUnit.MILLISECONDS); <line7> } <line8> } <line9> } <line10> 	<line4>
5915	"public class A { <line0> private List<String> getAndCreateDependencies( <line1> FileSystem sourceFS, <line2> String prefix, <line3> OozieClient targetOC, <line4> String bundleId, <line5> boolean dataFlag, <line6> String entityName) <line7> throws OozieClientException, IOException { <line8> List<String> missingDependencies = OozieUtil.getMissingDependencies(targetOC, bundleId); <line9> for (int i = 0; i < 10 && missingDependencies == null; ++i) { <line10> TimeUtil.sleepSeconds(30); <line11> missingDependencies = OozieUtil.getMissingDependencies(targetOC, bundleId); <line12> } <line13> Assert.assertNotNull(missingDependencies, ""Missing dependencies not found.""); <line14> for (String dependency : missingDependencies) { <line15> } <line16> HadoopUtil.createFolders(sourceFS, prefix, missingDependencies); <line17> if (dataFlag) { <line18> int tempCount = 1; <line19> for (String location : missingDependencies) { <line20> if (tempCount == 1) { <line21> HadoopUtil.copyDataToFolder( <line22> sourceFS, location, OSUtil.concat(OSUtil.NORMAL_INPUT, ""dataFile.xml"")); <line23> tempCount++; <line24> } <line25> } <line26> } <line27> InstanceUtil.waitTillInstanceReachState( <line28> targetOC, entityName, 1, CoordinatorAction.Status.SUCCEEDED, EntityType.FEED); <line29> int tempCounter = 1; <line30> for (String dependency : missingDependencies) { <line31> if (tempCounter == 1) { <line32> HadoopUtil.copyDataToFolder( <line33> sourceFS, dependency, OSUtil.concat(OSUtil.NORMAL_INPUT, ""dataFile.properties"")); <line34> } <line35> tempCounter++; <line36> } <line37> return missingDependencies; <line38> } <line39> } <line40> "	<line11>, <line15>, <line21>, <line32>
5916	public class A { <line0> @Override <line1> public FileVisitResult postVisitDirectory(final Path dir, final IOException e) <line2> throws IOException { <line3> if (e != null) { <line4> } <line5> deleteEmptyDirectory(dir); <line6> return FileVisitResult.CONTINUE; <line7> } <line8> } <line9> 	<line4>
5917	"public class A { <line0> private JButton getButtonDelete() { <line1> if (buttonDelete == null) { <line2> buttonDelete = new JButton(MessageBundle.getMessage(""angal.common.delete.btn"")); <line3> buttonDelete.setMnemonic(MessageBundle.getMnemonic(""angal.common.delete.btn.key"")); <line4> buttonDelete.addActionListener( <line5> new ActionListener() { <line6> public void actionPerformed(ActionEvent event) { <line7> if (jTable.getSelectedRow() < 0) { <line8> } else { <line9> Laboratory lab = (Laboratory) (model.getValueAt(jTable.getSelectedRow(), -1)); <line10> int n = <line11> JOptionPane.showConfirmDialog( <line12> LabBrowser.this, <line13> getLabMessage(lab), <line14> MessageBundle.getMessage(""angal.hospital""), <line15> JOptionPane.YES_NO_OPTION); <line16> if (n == JOptionPane.YES_OPTION) { <line17> boolean deleted; <line18> try { <line19> deleted = labManager.deleteLaboratory(lab); <line20> } catch (OHServiceException e) { <line21> deleted = false; <line22> OHServiceExceptionUtil.showMessages(e); <line23> } <line24> if (deleted) { <line25> pLabs.remove(jTable.getSelectedRow()); <line26> model.fireTableDataChanged(); <line27> jTable.updateUI(); <line28> } <line29> } <line30> } <line31> } <line32> }); <line33> } <line34> return buttonDelete; <line35> } <line36> } <line37> "	<line8>
5918	public class A { <line0> public String getJsonErrorResponse(IErrorType type) { <line1> final DefaultErrorResponse response = getErrorResponse(type); <line2> JsonErrorResponse jsonErrorResponse = new JsonErrorResponse(response); <line3> try { <line4> final ObjectMapper mapper = <line5> Util.createJsonMapper().configure(SerializationFeature.WRAP_ROOT_VALUE, false); <line6> return mapper.writeValueAsString(jsonErrorResponse); <line7> } catch (IOException ex) { <line8> return null; <line9> } <line10> } <line11> } <line12> 	<line8>
5919	"public class A { <line0> @RequestMapping( <line1> value = ""/checkCompatibility/hiveTable"", <line2> method = {RequestMethod.POST}) <line3> @ResponseBody <line4> public void checkHiveTableCompatibility(@RequestBody CompatibilityCheckRequest request) { <line5> try { <line6> List<TableDesc> tableDescList = deserializeTableDescList(request); <line7> for (TableDesc tableDesc : tableDescList) { <line8> tableService.checkHiveTableCompatibility(request.getProjectName(), tableDesc); <line9> } <line10> } catch (Exception e) { <line11> throw new ConflictException(e.getMessage(), e); <line12> } <line13> } <line14> } <line15> "	<line8>, <line9>, <line11>
5920	"public class A { <line0> @Override <line1> public void contextDestroyed(ServletContextEvent sce) { <line2> try { <line3> startupServices.destroy(); <line4> } catch (FalconException e) { <line5> } <line6> StringBuilder buffer = new StringBuilder(); <line7> buffer.append(""\n############################################""); <line8> buffer.append(""\n         Falcon Server (SHUTDOWN)            ""); <line9> buffer.append(""\n############################################""); <line10> } <line11> } <line12> "	<line5>, <line10>
5921	public class A { <line0> @Override <line1> public Character getEndInsertionCode() { <line2> return super.getEndInsertionCode(); <line3> } <line4> } <line5> 	<line2>
5922	public class A { <line0> @Test <line1> public void testAbstractScriptExecutorNetstat() throws ExecutionException, InterruptedException { <line2> List<String> lines = new NetstatScriptExecutor().execute().get(); <line3> for (String line : lines) { <line4> } <line5> } <line6> } <line7> 	<line4>
5923	"public class A { <line0> private String getTargetURI(String checkEnvironment) { <line1> String targetURI = """"; <line2> try { <line3> List<Map<String, String>> components = _configurationServiceClient.getItems(""config""); <line4> if (components == null) { <line5> } <line6> for (Map<String, String> component : components) { <line7> if (checkEnvironment.equals(""staging"") && ""apiStaging"".equals(component.get(""key""))) { <line8> targetURI = component.get(""value""); <line9> } else if (checkEnvironment.equals(""prod"") && ""apiProd"".equals(component.get(""key""))) { <line10> targetURI = component.get(""value""); <line11> } <line12> } <line13> } catch (Exception e) { <line14> e.printStackTrace(); <line15> } <line16> return targetURI; <line17> } <line18> } <line19> "	<line2>, <line5>, <line7>, <line8>, <line10>, <line14>
5924	"public class A { <line0> public static void handleActualRequest( <line1> CORSConfiguration corsConfiguration, <line2> HttpServletRequest request, <line3> HttpServletResponse response) { <line4> HTTP_LOGGER.debugf(""Processing CORS Actual Request to path [%s]."", request.getRequestURI()); <line5> final String requestOrigin = request.getHeader(ORIGIN); <line6> if (requestOrigin == null) { <line7> throw new RuntimeException(""CORS origin header is null""); <line8> } <line9> Set<String> allowedOrigins = corsConfiguration.getAllowedOrigins(); <line10> if (allowedOrigins == null <line11> || (!allowedOrigins.contains(requestOrigin) <line12> && !allowedOrigins.contains(ACCESS_CONTROL_ALLOW_ORIGIN_WILDCARD) <line13> && !corsConfiguration.isAllowAnyOrigin())) { <line14> throw new RuntimeException(""CORS origin denied "" + requestOrigin); <line15> } <line16> if (!corsConfiguration.isAllowAnyMethod()) { <line17> final String method = request.getMethod().toUpperCase(); <line18> Set<String> allowedMethods = corsConfiguration.getAllowedMethods(); <line19> if (!allowedMethods.contains(method)) { <line20> throw new RuntimeException(""Unsupported HTTP method "" + method); <line21> } <line22> } <line23> if (corsConfiguration.isAllowCredentials()) { <line24> response.addHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, ""true""); <line25> response.addHeader(ACCESS_CONTROL_ALLOW_ORIGIN, requestOrigin); <line26> } else { <line27> if (corsConfiguration.isAllowAnyOrigin()) { <line28> response.addHeader(ACCESS_CONTROL_ALLOW_ORIGIN, ACCESS_CONTROL_ALLOW_ORIGIN_WILDCARD); <line29> } else { <line30> response.addHeader(ACCESS_CONTROL_ALLOW_ORIGIN, requestOrigin); <line31> } <line32> } <line33> Set<String> exposedHeaders = corsConfiguration.getExposedHeaders(); <line34> if (exposedHeaders != null && !exposedHeaders.isEmpty()) { <line35> response.addHeader(ACCESS_CONTROL_EXPOSE_HEADERS, CorsUtil.join(exposedHeaders)); <line36> } <line37> } <line38> } <line39> "	<line7>, <line14>, <line20>
5925	public class A { <line0> private SimpleConsumer createConsumer(TopicPartition topicPartition) { <line1> HostAndPort leader = findLeader(topicPartition); <line2> if (leader == null) { <line3> return null; <line4> } <line5> final String clientName = getClientName(topicPartition); <line6> return createConsumer(leader.getHost(), leader.getPort(), clientName); <line7> } <line8> } <line9> 	<line3>, <line5>
5926	"public class A { <line0> @Override <line1> protected void bufferToBeReturned(ByteBuffer justAllocated) { <line2> BufferReference ref = new BufferReference(justAllocated, garbageCollectedBuffers); <line3> BufferMetadata metadata = new BufferMetadata(justAllocated.capacity()); <line4> if (buffersInFlight.put(ref, metadata) != null) <line5> throw new IllegalStateException( <line6> ""allocated buffer identity "" + ref.hashCode + "" already registered as in use?!""); <line7> } <line8> } <line9> "	<line7>
5927	public class A { <line0> private ImmutableMap<Integer, Integer> buildIdx2Idx() { <line1> final Builder<Integer, Integer> builder = ImmutableMap.builder(); <line2> int i = 0; <line3> for (FAIRecord record : faiRecords) { <line4> final Integer id = refDict.getContigNameToID().get(record.name); <line5> if (id == null) { <line6> } else { <line7> builder.put(id, i); <line8> } <line9> ++i; <line10> } <line11> return builder.build(); <line12> } <line13> } <line14> 	<line6>
5928	public class A { <line0> public final Map<String, Link> getLinks() { <line1> String path = LINKS_PATH; <line2> Response resp = getObjectToNetwork(this.networkId, path); <line3> if (resp == null) { <line4> return null; <line5> } <line6> try { <line7> return resp.getBodyAsMap(Link.class); <line8> } catch (Exception e) { <line9> return null; <line10> } <line11> } <line12> } <line13> 	<line2>, <line9>
5929	"public class A { <line0> private void testThreading(int nTables, int nIterations, double[] lf) throws Exception { <line1> if (null == lf) { <line2> lf = new double[nTables]; <line3> Arrays.fill(lf, 1d); <line4> } else { <line5> assert lf.length == nTables; <line6> } <line7> for (int n = 1; n < nTables; n++) { <line8> lf[n] += lf[n - 1]; <line9> } <line10> final double[] loadFactors = lf; <line11> final double accLoadFactors = loadFactors[nTables - 1]; <line12> Random random = new Random(0); <line13> int[] countByTable = new int[nTables]; <line14> long[] maxTimestampByTable = new long[nTables]; <line15> final long initialTimestampNanos = 1465839830100400200L; <line16> final long timestampIncrementInNanos = 1000; <line17> Arrays.fill(maxTimestampByTable, initialTimestampNanos); <line18> runInContext( <line19> () -> { <line20> int nTablesSelected = 0; <line21> int nTotalUpdates = 0; <line22> for (int nIter = 0; nIter < nIterations; nIter++) { <line23> int nLines = random.nextInt(50) + 1; <line24> recvBuffer = """"; <line25> for (int nLine = 0; nLine < nLines; nLine++) { <line26> int nTable; <line27> if (nTablesSelected < nTables) { <line28> nTable = nTablesSelected++; <line29> } else { <line30> double tableSelector = random.nextDouble() * accLoadFactors; <line31> nTable = nTables; <line32> while (--nTable > 0) { <line33> if (tableSelector > loadFactors[nTable - 1]) { <line34> break; <line35> } <line36> } <line37> } <line38> long timestamp = maxTimestampByTable[nTable]; <line39> maxTimestampByTable[nTable] += timestampIncrementInNanos; <line40> double temperature = 50.0 + (random.nextInt(500) / 10.0); <line41> recvBuffer += <line42> ""weather"" <line43> + nTable <line44> + "",location=us-midwest temperature="" <line45> + temperature <line46> + "" "" <line47> + timestamp <line48> + ""\n""; <line49> countByTable[nTable]++; <line50> nTotalUpdates++; <line51> } <line52> do { <line53> handleContextIO(); <line54> } while (recvBuffer.length() > 0); <line55> } <line56> waitForIOCompletion(); <line57> rebalanceNLoadCheckCycles = scheduler.getNLoadCheckCycles(); <line58> rebalanceNRebalances = scheduler.getNRebalances(); <line59> rebalanceLoadByThread = scheduler.getLoadByThread(); <line60> closeContext(); <line61> .$(""Completed "") <line62> .$(nTotalUpdates) <line63> .$("" measurements with "") <line64> .$(nTables) <line65> .$("" measurement types processed by "") <line66> .$(nWriterThreads) <line67> .$("" threads. "") <line68> .$(rebalanceNLoadCheckCycles) <line69> .$("" load checks lead to "") <line70> .$(rebalanceNRebalances) <line71> .$("" load rebalancing operations"") <line72> .$(); <line73> for (int nTable = 0; nTable < nTables; nTable++) { <line74> assertTableCount( <line75> ""weather"" + nTable, <line76> countByTable[nTable], <line77> maxTimestampByTable[nTable] - timestampIncrementInNanos); <line78> } <line79> }); <line80> } <line81> } <line82> "	<line61>
5930	public class A { <line0> @Override <line1> public List<SingularityRequestHistory> getRequestHistory( <line2> String requestId, <line3> Optional<Long> createdBefore, <line4> Optional<Long> createdAfter, <line5> Optional<OrderDirection> orderDirection, <line6> Integer limitStart, <line7> Integer limitCount) { <line8> List<SingularityRequestHistory> singularityRequestHistoryList = <line9> history.getRequestHistory( <line10> requestId, <line11> createdBefore, <line12> createdAfter, <line13> getOrderDirection(orderDirection), <line14> limitStart, <line15> limitCount); <line16> if (LOG.isTraceEnabled()) { <line17> } <line18> return singularityRequestHistoryList; <line19> } <line20> } <line21> 	<line17>
5931	public class A { <line0> @Override <line1> public synchronized void validate() throws ValidationException { <line2> try { <line3> super.validate(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	<line5>
5932	"public class A { <line0> @Override <line1> public synchronized List<Voice> getVoices() { <line2> try { <line3> if (voices == null || voices.size() == 0) { <line4> loadVoices(); <line5> } <line6> if (defaultVoice == null) { <line7> setDefaultVoice(); <line8> } <line9> List<Voice> vs = new ArrayList<Voice>(voices.size()); <line10> for (Voice v : voices.values()) { <line11> vs.add(v); <line12> } <line13> invoke(""publishVoices"", vs); <line14> return vs; <line15> } catch (Exception e) { <line16> error(""%s"", e.getMessage()); <line17> } <line18> return new ArrayList<Voice>(); <line19> } <line20> } <line21> "	<line4>, <line5>, <line17>
5933	public class A { <line0> private synchronized PulseaudioBridgeHandler getPulseaudioBridgeHandler() { <line1> if (this.bridgeHandler == null) { <line2> Bridge bridge = getBridge(); <line3> if (bridge == null) { <line4> return null; <line5> } <line6> ThingHandler handler = bridge.getHandler(); <line7> if (handler instanceof PulseaudioBridgeHandler) { <line8> this.bridgeHandler = (PulseaudioBridgeHandler) handler; <line9> this.bridgeHandler.registerDeviceStatusListener(this); <line10> } else { <line11> return null; <line12> } <line13> } <line14> return this.bridgeHandler; <line15> } <line16> } <line17> 	<line4>, <line11>
5934	"public class A { <line0> @Test <line1> public void runIntegrationTests() { <line2> String[] args = {}; <line3> String[] engines; <line4> String defaultEngine = System.getProperty(""ai.djl.default_engine""); <line5> if (defaultEngine == null) { <line6> if (System.getProperty(""os.name"").startsWith(""Win"")) { <line7> engines = new String[] {""MXNet""}; <line8> } else { <line9> engines = new String[] {""MXNet"", ""PyTorch"", ""TensorFlow""}; <line10> } <line11> } else { <line12> engines = new String[] {defaultEngine}; <line13> } <line14> for (String engine : engines) { <line15> System.setProperty(""ai.djl.default_engine"", engine); <line16> Assert.assertTrue(new IntegrationTest(IntegrationTest.class).runTests(args)); <line17> if (CudaUtils.hasCuda()) { <line18> break; <line19> } <line20> } <line21> } <line22> } <line23> "	<line16>
5935	public class A { <line0> private void encrypPassword(RedisConfiguration redisConfiguration) { <line1> try { <line2> String password = redisConfiguration.getPassword(); <line3> if (StringUtils.isNotBlank(password)) { <line4> redisConfiguration.setPassword(stringEncrypter.encrypt(password)); <line5> } <line6> } catch (StringEncrypter.EncryptionException e) { <line7> } <line8> } <line9> } <line10> 	<line5>, <line7>
5936	public class A { <line0> @VisibleForTesting <line1> protected void connect() { <line2> this.status = Status.CONNECTING; <line3> netClientWrapper.connect( <line4> endpoint.isSslEnabled(), <line5> socketAddress.getPort(), <line6> socketAddress.getHostString(), <line7> ar -> { <line8> if (ar.succeeded()) { <line9> onConnectSuccess(ar.result()); <line10> return; <line11> } <line12> onConnectFailed(ar.cause()); <line13> }); <line14> } <line15> } <line16> 	<line3>
5937	public class A { <line0> public void completed(final HttpResponse response) { <line1> int statusCode = response.getStatusLine().getStatusCode(); <line2> if (statusCode >= 200 && statusCode < 300) { <line3> callback.onSuccess(); <line4> } else { <line5> callback.onFailure(statusCode); <line6> } <line7> } <line8> } <line9> 	<line5>
5938	public class A { <line0> public static Date parseImportDate(String dateString) { <line1> try { <line2> Date resultDate = validDate(dateFormat__ddMMyyyyHHmmss, dateString); <line3> if (resultDate != null) { <line4> return resultDate; <line5> } <line6> resultDate = validDate(dateFormat__ddMMyyyy, dateString); <line7> if (resultDate != null) { <line8> return resultDate; <line9> } <line10> resultDate = validDate(dateString); <line11> if (dateString != null) { <line12> return resultDate; <line13> } <line14> } catch (Exception e) { <line15> } <line16> return null; <line17> } <line18> } <line19> 	<line14>, <line15>
5939	"public class A { <line0> public static void createTermFrequencyVectors( <line1> Path input, <line2> Path output, <line3> String tfVectorsFolderName, <line4> Configuration baseConf, <line5> int minSupport, <line6> int maxNGramSize, <line7> float minLLRValue, <line8> float normPower, <line9> boolean logNormalize, <line10> int numReducers, <line11> int chunkSizeInMegabytes, <line12> boolean sequentialAccess, <line13> boolean namedVectors) <line14> throws IOException, InterruptedException, ClassNotFoundException { <line15> Preconditions.checkArgument( <line16> normPower == PartialVectorMerger.NO_NORMALIZING || normPower >= 0, <line17> ""If specified normPower must be nonnegative"", <line18> normPower); <line19> Preconditions.checkArgument( <line20> normPower == PartialVectorMerger.NO_NORMALIZING <line21> || (normPower > 1 && !Double.isInfinite(normPower)) <line22> || !logNormalize, <line23> ""normPower must be > 1 and not infinite if log normalization is chosen"", <line24> normPower); <line25> if (chunkSizeInMegabytes < MIN_CHUNKSIZE) { <line26> chunkSizeInMegabytes = MIN_CHUNKSIZE; <line27> } else if (chunkSizeInMegabytes > MAX_CHUNKSIZE) { <line28> chunkSizeInMegabytes = MAX_CHUNKSIZE; <line29> } <line30> if (minSupport < 0) { <line31> minSupport = DEFAULT_MIN_SUPPORT; <line32> } <line33> Path dictionaryJobPath = new Path(output, DICTIONARY_JOB_FOLDER); <line34> int[] maxTermDimension = new int[1]; <line35> List<Path> dictionaryChunks; <line36> if (maxNGramSize == 1) { <line37> startWordCounting(input, dictionaryJobPath, baseConf, minSupport); <line38> dictionaryChunks = <line39> createDictionaryChunks( <line40> dictionaryJobPath, output, baseConf, chunkSizeInMegabytes, maxTermDimension); <line41> } else { <line42> CollocDriver.generateAllGrams( <line43> input, dictionaryJobPath, baseConf, maxNGramSize, minSupport, minLLRValue, numReducers); <line44> dictionaryChunks = <line45> createDictionaryChunks( <line46> new Path( <line47> new Path(output, DICTIONARY_JOB_FOLDER), CollocDriver.NGRAM_OUTPUT_DIRECTORY), <line48> output, <line49> baseConf, <line50> chunkSizeInMegabytes, <line51> maxTermDimension); <line52> } <line53> int partialVectorIndex = 0; <line54> Collection<Path> partialVectorPaths = Lists.newArrayList(); <line55> for (Path dictionaryChunk : dictionaryChunks) { <line56> Path partialVectorOutputPath = new Path(output, VECTOR_OUTPUT_FOLDER + partialVectorIndex++); <line57> partialVectorPaths.add(partialVectorOutputPath); <line58> makePartialVectors( <line59> input, <line60> baseConf, <line61> maxNGramSize, <line62> dictionaryChunk, <line63> partialVectorOutputPath, <line64> maxTermDimension[0], <line65> sequentialAccess, <line66> namedVectors, <line67> numReducers); <line68> } <line69> Configuration conf = new Configuration(baseConf); <line70> Path outputDir = new Path(output, tfVectorsFolderName); <line71> PartialVectorMerger.mergePartialVectors( <line72> partialVectorPaths, <line73> outputDir, <line74> conf, <line75> normPower, <line76> logNormalize, <line77> maxTermDimension[0], <line78> sequentialAccess, <line79> namedVectors, <line80> numReducers); <line81> HadoopUtil.delete(conf, partialVectorPaths); <line82> } <line83> } <line84> "	<line34>
5940	"public class A { <line0> public static com.liferay.commerce.product.model.CommerceCatalog fetchCommerceCatalog( <line1> HttpPrincipal httpPrincipal, long commerceCatalogId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceCatalogServiceUtil.class, <line7> ""fetchCommerceCatalog"", <line8> _fetchCommerceCatalogParameterTypes3); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceCatalogId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.product.model.CommerceCatalog) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
5941	public class A { <line0> public void executeScriptTemplate(String scriptTemplateLocation, Map<String, Object> values) { <line1> final List<SimpleStatement> statements = <line2> buildStatements(loadScriptAsLines(scriptTemplateLocation, values)); <line3> for (SimpleStatement statement : statements) { <line4> if (isDMLStatement(statement)) { <line5> } else { <line6> } <line7> session.execute(statement); <line8> } <line9> } <line10> } <line11> 	<line5>, <line6>
5942	public class A { <line0> @Override <line1> public void rollback() { <line2> transactionContext.rollbackTransaction(); <line3> } <line4> } <line5> 	<line2>
5943	public class A { <line0> private boolean isIndexSearchable(FilterCriteria filterCriteria, AtlasStructType structType) <line1> throws AtlasBaseException { <line2> String attributeName = filterCriteria.getAttributeName(); <line3> String attributeValue = filterCriteria.getAttributeValue(); <line4> AtlasType attributeType = structType.getAttributeType(attributeName); <line5> String typeName = attributeType.getTypeName(); <line6> String qualifiedName = structType.getVertexPropertyName(attributeName); <line7> Set<String> indexedKeys = context.getIndexedKeys(); <line8> boolean ret = indexedKeys != null && indexedKeys.contains(qualifiedName); <line9> SearchParameters.Operator operator = filterCriteria.getOperator(); <line10> AtlasStructDef.AtlasAttributeDef.IndexType indexType = <line11> structType.getAttributeDef(attributeName).getIndexType(); <line12> if (ret) { <line13> if (AtlasBaseTypeDef.ATLAS_TYPE_STRING.equals(typeName)) { <line14> if (operator == SearchParameters.Operator.NEQ <line15> || operator == SearchParameters.Operator.NOT_CONTAINS) { <line16> if (LOG.isDebugEnabled()) { <line17> } <line18> ret = false; <line19> } else if (operator == SearchParameters.Operator.CONTAINS <line20> && AtlasAttribute.hastokenizeChar(attributeValue) <line21> && indexType == null) { <line22> if (LOG.isDebugEnabled()) { <line23> } <line24> ret = false; <line25> } <line26> } <line27> } <line28> if (LOG.isDebugEnabled()) { <line29> if (!ret) { <line30> } <line31> } <line32> return ret; <line33> } <line34> } <line35> 	<line17>, <line23>, <line30>
5944	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public List<PieSectionDataModel> getClonedSections() { <line2> final long startTime = System.currentTimeMillis(); <line3> List<PieSectionDataModel> binClones = null; <line4> try { <line5> final ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line6> new ObjectOutputStream(baos).writeObject(getSections()); <line7> final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); <line8> binClones = (List<PieSectionDataModel>) new ObjectInputStream(bais).readObject(); <line9> } catch (final Exception e) { <line10> final String msg = ""Exception while cloning pie sections: "" + e.getMessage(); <line11> throw new IllegalStateException(msg); <line12> } <line13> final long endTime = System.currentTimeMillis(); <line14> final long durationTime = endTime - startTime; <line15> return binClones; <line16> } <line17> } <line18> "	<line2>, <line11>, <line15>
5945	public class A { <line0> private void initializeNewConnection(final Provider provider) { <line1> serializer.execute( <line2> () -> { <line3> lock.writeLock().lock(); <line4> try { <line5> if (closingConnection.get() || closed.get() || failed.get()) { <line6> try { <line7> provider.close(); <line8> } catch (Throwable ignore) { <line9> } <line10> return; <line11> } <line12> FailoverProvider.this.provider = provider; <line13> provider.setProviderListener(FailoverProvider.this); <line14> connectedURI = provider.getRemoteURI(); <line15> if (reconnectControl.isRecoveryRequired()) { <line16> try { <line17> listener.onConnectionRecovery(provider); <line18> } finally { <line19> processAlternates(provider.getAlternateURIs()); <line20> } <line21> FailoverProvider.this.messageFactory.set(provider.getMessageFactory()); <line22> listener.onConnectionRecovered(provider); <line23> listener.onConnectionRestored(provider.getRemoteURI()); <line24> final List<FailoverRequest> pending = <line25> new ArrayList<FailoverRequest>(requests.values()); <line26> for (FailoverRequest request : pending) { <line27> if (!request.isComplete()) { <line28> request.run(); <line29> } <line30> } <line31> reconnectControl.connectionEstablished(); <line32> } else { <line33> processAlternates(provider.getAlternateURIs()); <line34> final List<FailoverRequest> pending = <line35> new ArrayList<FailoverRequest>(requests.values()); <line36> for (FailoverRequest request : pending) { <line37> if (!request.isComplete()) { <line38> request.run(); <line39> } <line40> } <line41> } <line42> if (requestTimeoutTask != null) { <line43> requestTimeoutTask.cancel(false); <line44> requestTimeoutTask = null; <line45> } <line46> } catch (Throwable error) { <line47> handleProviderFailure( <line48> provider, ProviderExceptionSupport.createOrPassthroughFatal(error)); <line49> } finally { <line50> lock.writeLock().unlock(); <line51> } <line52> }); <line53> } <line54> } <line55> 	<line9>, <line16>, <line47>
5946	public class A { <line0> private int calculateMaxPort(int maxProject, int maxResources) { <line1> int maxFinal = -1; <line2> if (maxProject < 0) { <line3> if (maxResources < 0) { <line4> } else { <line5> maxFinal = maxResources; <line6> } <line7> } else { <line8> if (maxResources < 0) { <line9> maxFinal = maxProject; <line10> } else { <line11> if (maxProject < maxResources) { <line12> maxFinal = maxProject; <line13> } else { <line14> maxFinal = maxResources; <line15> } <line16> } <line17> } <line18> return maxFinal; <line19> } <line20> } <line21> 	<line4>, <line5>, <line14>
5947	"public class A { <line0> protected void exportFoxml(Foxml foxml) { <line1> try { <line2> DigitalObject foxmlPeri = this.createDigitalObject(foxml); <line3> Element re = createRelsExtElement(foxml.getRe()); <line4> DatastreamType relsExtStream = this.createRelsExtStream(re); <line5> addCheckedDataStream(foxmlPeri, relsExtStream); <line6> if (foxml.getOcr() != null) { <line7> addCheckedDataStream( <line8> foxmlPeri, createEncodedStream(STREAM_ID_TXT, ""text/plain"", foxml.getOcr())); <line9> } <line10> if (foxml.getStruct() != null) { <line11> addCheckedDataStream( <line12> foxmlPeri, <line13> createEncodedStream( <line14> ""STRUCT_MAP"", <line15> ""text/xml"", <line16> ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n<parts>\n"" <line17> + foxml.getStruct() <line18> + ""</parts>\n"")); <line19> } <line20> this.marshalDigitalObject(foxmlPeri); <line21> } catch (ServiceException ex) { <line22> throw ex; <line23> } <line24> } <line25> } <line26> "	<line22>
5948	public class A { <line0> @Override <line1> public void processReplaceSmResp(Command pduHeader, byte[] pdu, ResponseHandler responseHandler) <line2> throws IOException { <line3> PendingResponse<Command> pendingResp = <line4> responseHandler.removeSentItem(pduHeader.getSequenceNumber()); <line5> if (pendingResp != null) { <line6> ReplaceSmResp resp = pduDecomposer.replaceSmResp(pdu); <line7> pendingResp.done(resp); <line8> } else { <line9> } <line10> } <line11> } <line12> 	<line9>
5949	"public class A { <line0> protected boolean checkRegNodeAndWaitExpired(String regPath) throws IOException { <line1> final CountDownLatch prevNodeLatch = new CountDownLatch(1); <line2> Watcher zkPrevRegNodewatcher = <line3> new Watcher() { <line4> @Override <line5> public void process(WatchedEvent event) { <line6> if (EventType.NodeDeleted == event.getType()) { <line7> prevNodeLatch.countDown(); <line8> } <line9> } <line10> }; <line11> try { <line12> Stat stat = zk.exists(regPath, zkPrevRegNodewatcher); <line13> if (null != stat) { <line14> if (stat.getEphemeralOwner() != zk.getSessionId()) { <line15> if (!prevNodeLatch.await(zkTimeoutMs, TimeUnit.MILLISECONDS)) { <line16> throw new NodeExistsException(regPath); <line17> } else { <line18> return false; <line19> } <line20> } <line21> return true; <line22> } else { <line23> return false; <line24> } <line25> } catch (KeeperException ke) { <line26> throw new IOException( <line27> ""ZK exception checking and wait ephemeral znode "" + regPath + "" expired"", ke); <line28> } catch (InterruptedException ie) { <line29> Thread.currentThread().interrupt(); <line30> throw new IOException( <line31> ""Interrupted checking and wait ephemeral znode "" + regPath + "" expired"", ie); <line32> } <line33> } <line34> } <line35> "	<line15>, <line26>, <line30>
5950	"public class A { <line0> public static void main(String[] args) throws IOException { <line1> if (args.length != 2) { <line2> System.out.println(""usage: report redis-url report-name""); <line3> System.exit(1); <line4> } <line5> try (RedisUserReportMap reportMap = <line6> new RedisUserReportMap( <line7> new PropertiesProvider( <line8> new HashMap<String, String>() { <line9> { <line10> put(""redisAddress"", args[0]); <line11> } <line12> }), <line13> args[1])) { <line14> reportMap.forEach( <line15> (path, report) -> { <line16> if (report.getException().isPresent()) { <line17> StringWriter sw = new StringWriter(); <line18> PrintWriter pw = new PrintWriter(sw); <line19> report.getException().get().printStackTrace(pw); <line20> } <line21> }); <line22> } <line23> } <line24> } <line25> "	<line20>
5951	public class A { <line0> @Override <line1> protected void setUp() throws Exception { <line2> server = createServer(); <line3> if (server != null) { <line4> server.setAcceptListener( <line5> new TransportAcceptListener() { <line6> @Override <line7> public void onAccept(Transport transport) { <line8> consumer = transport; <line9> consumer.setTransportListener(UdpTestSupport.this); <line10> try { <line11> consumer.start(); <line12> } catch (Exception e) { <line13> throw new RuntimeException(e); <line14> } <line15> } <line16>  <line17> @Override <line18> public void onAcceptError(Exception error) {} <line19> }); <line20> server.start(); <line21> } <line22> consumer = createConsumer(); <line23> if (consumer != null) { <line24> consumer.setTransportListener(this); <line25> consumer.start(); <line26> } <line27> producer = createProducer(); <line28> producer.setTransportListener( <line29> new TransportListener() { <line30> @Override <line31> public void onCommand(Object command) { <line32> } <line33>  <line34> @Override <line35> public void onException(IOException error) { <line36> error.printStackTrace(); <line37> } <line38>  <line39> @Override <line40> public void transportInterupted() {} <line41>  <line42> @Override <line43> public void transportResumed() {} <line44> }); <line45> producer.start(); <line46> } <line47> } <line48> 	<line32>, <line36>
5952	"public class A { <line0> public static <T> T readValue(String content, Class<T> valueType) throws GenericRestException { <line1> try { <line2> return defaultMapper.readValue(content, valueType); <line3> } catch (JsonMappingException e) { <line4> String line = ""unknown""; <line5> String column = ""unknown""; <line6> if (e.getLocation() != null) { <line7> line = String.valueOf(e.getLocation().getLineNr()); <line8> column = String.valueOf(e.getLocation().getColumnNr()); <line9> } <line10> String field = """"; <line11> if (e.getPath() != null && e.getPath().size() >= 1) { <line12> field = e.getPath().get(0).getFieldName(); <line13> } <line14> throw new GenericRestException( <line15> BAD_REQUEST, ""error_json_structure_invalid"", line, column, field, e.getOriginalMessage()); <line16> } catch (JsonParseException e) { <line17> String msg = e.getOriginalMessage(); <line18> String line = ""unknown""; <line19> String column = ""unknown""; <line20> if (e.getLocation() != null) { <line21> line = String.valueOf(e.getLocation().getLineNr()); <line22> column = String.valueOf(e.getLocation().getColumnNr()); <line23> } <line24> throw new GenericRestException(BAD_REQUEST, ""error_json_malformed"", line, column, msg); <line25> } catch (Exception e) { <line26> throw new GenericRestException(BAD_REQUEST, ""error_json_parse"", e); <line27> } <line28> } <line29> } <line30> "	<line4>
5953	public class A { <line0> private void readHDF5File() throws Exception { <line1> FileFormat fileFormat = FileFormat.getFileFormat(FileFormat.FILE_TYPE_HDF5); <line2> if (fileFormat == null) { <line3> return; <line4> } <line5> FileFormat testFile = fileFormat.createInstance(fname, FileFormat.WRITE); <line6> org.junit.Assert.assertNotNull(testFile); <line7> org.junit.Assert.assertEquals(testFile.exists(), true); <line8> testFile.open(); <line9> Group root = <line10> (Group) ((javax.swing.tree.DefaultMutableTreeNode) testFile.getRootNode()).getUserObject(); <line11> Dataset dataset = (Dataset) root.getMemberList().get(0); <line12> int[] dataRead = (int[]) dataset.read(); <line13> org.junit.Assert.assertEquals(dataRead.length, 200); <line14> org.junit.Assert.assertEquals(dataRead[0], 1000); <line15> org.junit.Assert.assertEquals(dataRead[1], 1001); <line16> for (int i = 0; i < 20; i++) { <line17> for (int j = 0; j < 10; j++) { <line18> dataRead[i * 10 + j]++; <line19> } <line20> } <line21> dataset.write(dataRead); <line22> int[] dataModified = (int[]) dataset.read(); <line23> org.junit.Assert.assertEquals(dataModified.length, 200); <line24> org.junit.Assert.assertEquals(dataModified[0], 1001); <line25> org.junit.Assert.assertEquals(dataModified[1], 1002); <line26> testFile.close(); <line27> } <line28> } <line29> 	<line3>
5954	public class A { <line0> public String doHttpGet(String url, Map<String, String> headers) { <line1> try { <line2> HttpClient client = HttpClientBuilder.create().build(); <line3> HttpGet httpget = new HttpGet(url); <line4> for (Map.Entry<String, String> entry : headers.entrySet()) { <line5> httpget.addHeader(entry.getKey(), entry.getValue()); <line6> } <line7> HttpResponse httpresponse = client.execute(httpget); <line8> if (httpresponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { <line9> return EntityUtils.toString(httpresponse.getEntity()); <line10> } <line11> } catch (org.apache.http.ParseException parseException) { <line12> } catch (IOException ioException) { <line13> } <line14> return null; <line15> } <line16> } <line17> 	<line12>, <line13>
5955	"public class A { <line0> @RequestMapping(value = ""/file/logs/trigger"") <line1> public String trigger() { <line2> return TraceContext.traceId(); <line3> } <line4> } <line5> "	<line2>
5956	"public class A { <line0> @Test <line1> public void addAndRest() { <line2> if (token == null) { <line3> return; <line4> } else { <line5> DirCache dirCache = gitUtils.add(LOCALPATH, ""/aa/bb/log4j.properties""); <line6> assertEquals(1, dirCache.getEntryCount()); <line7> gitUtils.reset(LOCALPATH, ""/aa/bb/log4j.properties""); <line8> } <line9> } <line10> } <line11> "	<line3>
5957	"public class A { <line0> @Override <line1> public synchronized void update(WireGraphConfiguration newConfiguration) throws KuraException { <line2> if (this.wireComponentServiceTracker != null) { <line3> this.wireComponentServiceTracker.close(); <line4> this.wireComponentServiceTracker = null; <line5> } <line6> final WireGraphConfiguration currentGraphConfiguration = get(); <line7> final List<WireComponentConfiguration> currentWireComponents = <line8> currentGraphConfiguration.getWireComponentConfigurations(); <line9> List<ComponentConfiguration> componentConfigurations = new ArrayList<>(); <line10> List<WireComponentConfiguration> newWireComponentConfigurations = <line11> newConfiguration.getWireComponentConfigurations(); <line12> Set<MultiportWireConfiguration> newWires = <line13> new HashSet<>(newConfiguration.getWireConfigurations()); <line14> Set<String> componentsToDeletePids = <line15> getComponentsToDelete(currentWireComponents, newWireComponentConfigurations); <line16> for (final String pid : componentsToDeletePids) { <line17> this.configurationService.deleteFactoryConfiguration(pid, false); <line18> } <line19> deleteNoLongerExistingWires(newWires, componentsToDeletePids); <line20> List<WireComponentConfiguration> componentsToCreate = <line21> getComponentsToCreate(currentWireComponents, newWireComponentConfigurations); <line22> List<String> createdPids = new ArrayList<>(); <line23> for (WireComponentConfiguration componentToCreate : componentsToCreate) { <line24> final ComponentConfiguration configToCreate = componentToCreate.getConfiguration(); <line25> final Map<String, Object> wireComponentProps = componentToCreate.getProperties(); <line26> final Map<String, Object> configurationProps = configToCreate.getConfigurationProperties(); <line27> String factoryPid = (String) configurationProps.get(SERVICE_FACTORYPID); <line28> configurationProps.put( <line29> Constants.RECEIVER_PORT_COUNT_PROP_NAME.value(), <line30> wireComponentProps.get(""inputPortCount"")); <line31> configurationProps.put( <line32> Constants.EMITTER_PORT_COUNT_PROP_NAME.value(), <line33> wireComponentProps.get(""outputPortCount"")); <line34> try { <line35> this.configurationService.createFactoryConfiguration( <line36> factoryPid, configToCreate.getPid(), configurationProps, false); <line37> } catch (Exception e) { <line38> deleteConfigurations(createdPids); <line39> throw e; <line40> } <line41> createdPids.add(configToCreate.getPid()); <line42> } <line43> List<WireComponentConfiguration> componentsToUpdate = <line44> getComponentsToUpdate(newWireComponentConfigurations, componentsToCreate); <line45> for (WireComponentConfiguration componentToUpdate : componentsToUpdate) { <line46> componentConfigurations.add(componentToUpdate.getConfiguration()); <line47> } <line48> String jsonConfig = marshal(newConfiguration); <line49> ComponentConfiguration wireGraphServiceComponentConfig = <line50> this.configurationService.getComponentConfiguration(CONF_PID); <line51> wireGraphServiceComponentConfig <line52> .getConfigurationProperties() <line53> .put(NEW_WIRE_GRAPH_PROPERTY, jsonConfig); <line54> componentConfigurations.add(wireGraphServiceComponentConfig); <line55> this.configurationService.updateConfigurations(componentConfigurations, true); <line56> } <line57> } <line58> "	<line2>, <line6>
5958	public class A { <line0> private void afterLog() { <line1> AnnotationVisitor<Value> annotationVisitor = new AnnotationVisitor<>(Value.class); <line2> annotationVisitor.visit(this, new LoggingEvent(this.logger)); <line3> } <line4> } <line5> 	<line1>
5959	"public class A { <line0> public List<AsyncMsgRecord> queryForExpired(Date timestamp) { <line1> List<AsyncMsgRecord> asyncMsgRecs = null; <line2> Session sess = null; <line3> try { <line4> sess = getSession(); <line5> if (sess != null) { <line6> Query query = sess.getNamedQuery(""queryForExpired""); <line7> query.setParameter(""CreationTime"", timestamp); <line8> asyncMsgRecs = query.list(); <line9> } else { <line10> } <line11> if (LOG.isDebugEnabled()) { <line12> } <line13> } finally { <line14> if (sess != null) { <line15> try { <line16> sess.close(); <line17> } catch (HibernateException he) { <line18> } <line19> } <line20> } <line21> return asyncMsgRecs; <line22> } <line23> } <line24> "	<line1>, <line10>, <line12>, <line18>
5960	public class A { <line0> public void destroy() { <line1> runnable.destroy(); <line2> try { <line3> serversocket.close(); <line4> } catch (IOException e) { <line5> } <line6> socketThread.interrupt(); <line7> try { <line8> socketThread.join(10000); <line9> } catch (InterruptedException e) { <line10> } <line11> } <line12> } <line13> 	<line1>, <line2>, <line5>, <line6>, <line10>
5961	public class A { <line0> public static void sendActivationNotification(User user, Locale locale, boolean invitation) { <line1> try { <line2> emailClient.sendMail( <line3> Imeji.CONFIG.getContactEmail(), <line4> null, <line5> EmailMessages.getEmailOnAccountActivation_Subject(user, locale), <line6> EmailMessages.getEmailOnAccountActivation_Body(user, locale, invitation)); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	<line8>
5962	"public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (command instanceof RefreshType) { <line3> JsonObject message = getXiaomiBridgeHandler().getDeferredMessage(getItemId()); <line4> if (message != null) { <line5> String cmd = message.get(""cmd"").getAsString(); <line6> onItemUpdate(getItemId(), cmd, message); <line7> } <line8> return; <line9> } <line10> execute(channelUID, command); <line11> } <line12> } <line13> "	<line2>, <line6>
5963	public class A { <line0> @Override <line1> public void closed(RemoteOutputStreamServer stream, boolean clean) { <line2> try { <line3> stream.close(true); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	<line5>
5964	public class A { <line0> synchronized void processRemoveRequest(ID mbr) { <line1> if (waiting) { <line2> pendingRemovals.add(mbr); <line3> checkIfDone(); <line4> } <line5> } <line6> } <line7> 	<line2>
5965	"public class A { <line0> private Map<String, String> loadDCATPrefixes() { <line1> HashMap<String, String> prefixes = new HashMap<String, String>(); <line2> Closer closer = Closer.create(); <line3> try { <line4> InputStreamUtils streamUtils = new InputStreamUtils(); <line5> InputStream configStream = streamUtils.classpathStream(PREFIXES_PROPERTIES); <line6> if (configStream == null) { <line7> } else { <line8> Properties properties = new Properties(); <line9> properties.load(configStream); <line10> for (Map.Entry<Object, Object> entry : properties.entrySet()) { <line11> String key = StringUtils.trim((String) entry.getKey()); <line12> String value = StringUtils.trim((String) entry.getValue()); <line13> if (key != null && value != null) { <line14> prefixes.put(key, value); <line15> } else { <line16> throw new InvalidConfigException( <line17> InvalidConfigException.TYPE.INVALID_PROPERTIES_FILE, <line18> ""Invalid properties file: "" + PREFIXES_PROPERTIES); <line19> } <line20> } <line21> } <line22> } catch (Exception e) { <line23> e.printStackTrace(); <line24> } finally { <line25> try { <line26> closer.close(); <line27> } catch (IOException e) { <line28> } <line29> } <line30> return prefixes; <line31> } <line32> } <line33> "	<line7>, <line21>, <line28>
5966	public class A { <line0> @Override <line1> public void println(final Object obj) { <line2> if (obj != null) { <line3> printBuilder.append(obj.toString()); <line4> } <line5> printBuilder.setLength(0); <line6> } <line7> } <line8> 	<line5>
5967	public class A { <line0> @Override <line1> public String handleException(BackgroundTask backgroundTask, Exception exception) { <line2> Map<String, Serializable> taskContextMap = backgroundTask.getTaskContextMap(); <line3> long fileEntryId = <line4> GetterUtil.getLong(taskContextMap.get(GoogleDriveBackgroundTaskConstants.FILE_ENTRY_ID)); <line5> try { <line6> _dlOpenerFileEntryReferenceLocalService.deleteDLOpenerFileEntryReference( <line7> DLOpenerGoogleDriveConstants.GOOGLE_DRIVE_REFERENCE_TYPE, <line8> _dlAppLocalService.getFileEntry(fileEntryId)); <line9> } catch (PortalException portalException) { <line10> } <line11> return StringPool.BLANK; <line12> } <line13> } <line14> 	<line10>
5968	public class A { <line0> @Override <line1> public void doInit(final Properties messageAttributes) throws PerfCakeException { <line2> final String currentTarget = safeGetTarget(messageAttributes); <line3> isDebugEnabled = log.isDebugEnabled(); <line4> if (isDebugEnabled) { <line5> } <line6> } <line7> } <line8> 	<line5>
5969	"public class A { <line0> public static void main(String[] args) throws IOException { <line1> Config config = ConfigUtils.createConfig(); <line2> config <line3> .plans() <line4> .setInputFile( <line5> ""../shared-svn/projects/episim/matsim-files/snz/BerlinV2/episim-input/be_v2_snz_entirePopulation_emptyPlans_withDistricts.xml.gz""); <line6> Scenario scenario = ScenarioUtils.loadScenario(config); <line7> Table table; <line8> { <line9> Map<String, Double> freq = new TreeMap<>(); <line10> for (Person person : scenario.getPopulation().getPersons().values()) { <line11> String age = Integer.toString((int) person.getAttributes().getAttribute(""age"")); <line12> Double sum = freq.computeIfAbsent(age, (a) -> 0.); <line13> freq.put(age, sum + 0.02); <line14> } <line15> final StringColumn ageColumn = StringColumn.create(""age"", freq.keySet()); <line16> final DoubleColumn freqInPop = DoubleColumn.create(""freqInPop * 0.02"", freq.values()); <line17> table = Table.create(""table"").addColumns(ageColumn, freqInPop); <line18> } <line19> Table table2; <line20> final String ageFreqInInfections = ""ageFreqInInfections""; <line21> { <line22> Map<String, Double> freq2 = new TreeMap<>(); <line23> Reader in = new FileReader(base + ""infectionEvents.txt""); <line24> Iterable<CSVRecord> records = <line25> CSVFormat.RFC4180.withFirstRecordAsHeader().withDelimiter('\t').parse(in); <line26> for (CSVRecord record : records) { <line27> String infected = record.get(""infected""); <line28> Person person = scenario.getPopulation().getPersons().get(Id.createPersonId(infected)); <line29> if (person == null) { <line30> } <line31> Gbl.assertNotNull(person); <line32> String age = Integer.toString((int) person.getAttributes().getAttribute(""age"")); <line33> Double sum = freq2.computeIfAbsent(age, (a) -> 0.); <line34> freq2.put(age, sum + 1); <line35> } <line36> final StringColumn ageColumn = StringColumn.create(""age"", freq2.keySet()); <line37> final DoubleColumn freqInPop = DoubleColumn.create(ageFreqInInfections, freq2.values()); <line38> table2 = Table.create(""table"").addColumns(ageColumn, freqInPop); <line39> } <line40> Table result = new DataFrameJoiner(table, ""age"").fullOuter(table2); <line41> Layout.BarMode barMode = Layout.BarMode.GROUP; <line42> Figure fig = <line43> VerticalBarPlot.create( <line44> ""title"", result, ""age"", barMode, ""freqInPop * 0.02"", ageFreqInInfections); <line45> Layout layout = Layout.builder().width(800).height(500).build(); <line46> fig.setLayout(layout); <line47> Plot.show(fig, ""divname""); <line48> } <line49> } <line50> "	<line30>
5970	public class A { <line0> protected static BlockingQueue<String> getQueue(String queueName) { <line1> HttpServletRequest req = ElementsThreadLocals.getHttpServletRequest(); <line2> if (req == null) { <line3> return new LinkedBlockingQueue<>(); <line4> } <line5> HttpSession session = req.getSession(); <line6> BlockingQueue<String> infoQueue; <line7> synchronized (session) { <line8> infoQueue = (BlockingQueue) session.getAttribute(queueName); <line9> if (infoQueue == null) { <line10> infoQueue = new LinkedBlockingQueue<String>(); <line11> session.setAttribute(queueName, infoQueue); <line12> } <line13> } <line14> return infoQueue; <line15> } <line16> } <line17> 	<line3>
5971	"public class A { <line0> public void init() throws LensException { <line1> final int maxPoolSize = parseInt(getConf().get(JDBC_POOL_MAX_SIZE.getConfigKey())); <line2> final int maxConcurrentQueries = <line3> parseInt( <line4> getConf().get(MaxConcurrentDriverQueriesConstraintFactory.MAX_CONCURRENT_QUERIES_KEY)); <line5> checkState( <line6> maxPoolSize >= maxConcurrentQueries, <line7> ""maxPoolSize:"" + maxPoolSize + "" maxConcurrentQueries:"" + maxConcurrentQueries); <line8> queryContextMap = new ConcurrentHashMap<>(); <line9> asyncQueryPool = <line10> Executors.newCachedThreadPool( <line11> new ThreadFactory() { <line12> @Override <line13> public Thread newThread(Runnable runnable) { <line14> Thread th = new Thread(runnable); <line15> th.setName(""lens-driver-jdbc-"" + THID.incrementAndGet()); <line16> return th; <line17> } <line18> }); <line19> Class<? extends ConnectionProvider> cpClass = <line20> getConf() <line21> .getClass( <line22> JDBC_CONNECTION_PROVIDER, <line23> DataSourceConnectionProvider.class, <line24> ConnectionProvider.class); <line25> try { <line26> connectionProvider = cpClass.newInstance(); <line27> estimateConnectionProvider = cpClass.newInstance(); <line28> } catch (Exception e) { <line29> throw new LensException(e); <line30> } <line31> this.logSegregationContext = new MappedDiagnosticLogSegregationContext(); <line32> this.isStatementCancelSupported = <line33> getConf().getBoolean(STATEMENT_CANCEL_SUPPORTED, DEFAULT_STATEMENT_CANCEL_SUPPORTED); <line34> } <line35> } <line36> "	<line29>
5972	public class A { <line0> public Map<String, Object> getStructure(final int threshold) { <line1> int level = 0; <line2> int exceptionCount = 0; <line3> while (reader.hasNext() && analysisCount < threshold && exceptionCount < XML_MAX_EXCEPTIONS) { <line4> try { <line5> final XMLEvent event = reader.nextEvent(); <line6> final String tagName = getTagName(event); <line7> switch (event.getEventType()) { <line8> case XMLEvent.START_ELEMENT: <line9> current = new Element(current, tagName, level++); <line10> current.attributes.addAll(getAttributes(event.asStartElement())); <line11> break; <line12> case XMLEvent.END_ELEMENT: <line13> current = current.parent; <line14> level--; <line15> if (current != null && current.level == 0) { <line16> analyze(current, structure); <line17> analysisCount++; <line18> } <line19> break; <line20> } <line21> } catch (XMLStreamException strex) { <line22> exceptionCount++; <line23> } <line24> } <line25> if (exceptionCount == XML_MAX_EXCEPTIONS) { <line26> } <line27> return structure; <line28> } <line29> } <line30> 	<line22>, <line26>
5973	"public class A { <line0> public static List<Property> select( <line1> EntityManager em, final String mediaPackageId, final String namespace) { <line2> TypedQuery<PropertyDto> query = <line3> em.createNamedQuery(""Property.selectByMediaPackageAndNamespace"", PropertyDto.class) <line4> .setParameter(""mediaPackageId"", mediaPackageId) <line5> .setParameter(""namespace"", namespace); <line6> return query.getResultList().parallelStream() <line7> .map(PropertyDto::toProperty) <line8> .collect(Collectors.toList()); <line9> } <line10> } <line11> "	<line6>
5974	public class A { <line0> @Override <line1> public void handle(IdentificationRequest request) throws IOException { <line2> if (request.getClass().isAssignableFrom(FileSystemIdentificationRequest.class)) { <line3> FileSystemIdentificationRequest req = (FileSystemIdentificationRequest) request; <line4> Iso9660FileSystem fileSystem = new Iso9660FileSystem(req.getFile().toFile(), true); <line5> ISOImageArchiveWalker walker = <line6> new ISOImageArchiveWalker( <line7> droid, factory, resultHandler, fileSystem, request.getIdentifier()); <line8> walker.walk(fileSystem); <line9> } else { <line10> } <line11> } <line12> } <line13> 	<line10>
5975	"public class A { <line0> @Override <line1> public void init(String serviceName, String appId, String configPropertyPrefix) { <line2> super.init(serviceName, appId, configPropertyPrefix); <line3> try { <line4> gson = <line5> new GsonBuilder().setDateFormat(""yyyyMMdd-HH:mm:ss.SSS-Z"").setPrettyPrinting().create(); <line6> } catch (Throwable excp) { <line7> } <line8> } <line9> } <line10> "	<line7>
5976	public class A { <line0> private CSVRecordReader getCSVRecordReader(String file) throws IOException, URISyntaxException { <line1> InputSplit split = ColumnBasedHandlerTestUtil.getSplit(file); <line2> TaskAttemptContext ctx = new TaskAttemptContextImpl(conf, new TaskAttemptID()); <line3> TypeRegistry.reset(); <line4> TypeRegistry.getInstance(ctx.getConfiguration()); <line5> CSVRecordReader reader = new CSVRecordReader(); <line6> reader.initialize(split, ctx); <line7> return reader; <line8> } <line9> } <line10> 	<line5>
5977	"public class A { <line0> @Test <line1> public void testSearchCreator() throws Exception { <line2> String id1 = <line3> addItem( <line4> ""title:testTemplateFilter"", <line5> ""contents:testTemplateFilter"", <line6> 0, <line7> TemplateLogic.TYPE_ID_KNOWLEDGE, <line8> 100, <line9> DateUtils.now(), <line10> null, <line11> null, <line12> null); <line13> String id2 = <line14> addItem( <line15> ""title:testTemplateFilter"", <line16> ""contents:testTemplateFilter"", <line17> 0, <line18> TemplateLogic.TYPE_ID_EVENT, <line19> 101, <line20> DateUtils.now(), <line21> null, <line22> null, <line23> null); <line24> String id3 = <line25> addItem( <line26> ""title:testTemplateFilter"", <line27> ""contents:testTemplateFilter"", <line28> 0, <line29> TemplateLogic.TYPE_ID_BOOKMARK, <line30> 102, <line31> DateUtils.now(), <line32> null, <line33> null, <line34> null); <line35> Searcher searcher = Container.getComp(Searcher.class); <line36> SearchingValue searchingValue = new SearchingValue(); <line37> searchingValue.addCreator(100); <line38> List<SearchResultValue> results = searcher.search(searchingValue, 1); <line39> for (SearchResultValue searchResultValue : results) { <line40> } <line41> assertEquals(1, results.size()); <line42> SearchResultValue result = results.get(0); <line43> assertEquals(id1, result.getId()); <line44> } <line45> } <line46> "	<line40>
5978	"public class A { <line0> @Override <line1> protected String stopProcessesAtMachine(ConfigBag parameters) { <line2> entity().sensors().set(Attributes.SERVICE_UP, false); <line3> Integer pid = entity().getAttribute(Attributes.PID); <line4> if (pid == null) { <line5> return ""No pid -- is it running?""; <line6> } <line7> DynamicTasks.queue( <line8> SshEffectorTasks.ssh(""cd "" + dir(entity) + ""/*"", ""./support-files/mysql.server stop"") <line9> .summary(""stop mysql"")); <line10> return ""submitted stop""; <line11> } <line12> } <line13> "	<line5>
5979	"public class A { <line0> @Test <line1> public void testAvroCompression() throws Exception { <line2> Map<String, String> props = createProps(); <line3> props.put(HdfsSinkConnectorConfig.AVRO_CODEC_CONFIG, ""snappy""); <line4> HdfsSinkConnectorConfig connectorConfig = new HdfsSinkConnectorConfig(props); <line5> DataWriter hdfsWriter = new DataWriter(connectorConfig, context, avroData); <line6> partitioner = hdfsWriter.getPartitioner(); <line7> hdfsWriter.recover(TOPIC_PARTITION); <line8> List<SinkRecord> sinkRecords = createSinkRecords(7); <line9> hdfsWriter.write(sinkRecords); <line10> hdfsWriter.close(); <line11> hdfsWriter.stop(); <line12> long[] validOffsets = {0, 3, 6}; <line13> verify(sinkRecords, validOffsets); <line14> List<String> filenames = getExpectedFiles(validOffsets, TOPIC_PARTITION); <line15> for (String filename : filenames) { <line16> Path p = new Path(filename); <line17> try (FSDataInputStream stream = fs.open(p)) { <line18> int size = (int) fs.getFileStatus(p).getLen(); <line19> ByteBuffer buffer = ByteBuffer.allocate(size); <line20> if (stream.read(buffer) <= 0) { <line21> } <line22> String fileContents = new String(buffer.array()); <line23> int index; <line24> assertTrue( <line25> (index = fileContents.indexOf(""avro.codec"")) > 0 <line26> && fileContents.indexOf(""snappy"", index) > 0); <line27> } <line28> } <line29> } <line30> } <line31> "	<line21>
5980	"public class A { <line0> public static com.liferay.commerce.product.model.CommerceCatalog addCommerceCatalog( <line1> HttpPrincipal httpPrincipal, <line2> String externalReferenceCode, <line3> String name, <line4> String commerceCurrencyCode, <line5> String catalogDefaultLanguageId, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> CommerceCatalogServiceUtil.class, <line12> ""addCommerceCatalog"", <line13> _addCommerceCatalogParameterTypes0); <line14> MethodHandler methodHandler = <line15> new MethodHandler( <line16> methodKey, <line17> externalReferenceCode, <line18> name, <line19> commerceCurrencyCode, <line20> catalogDefaultLanguageId, <line21> serviceContext); <line22> Object returnObj = null; <line23> try { <line24> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line25> } catch (Exception exception) { <line26> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line27> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line28> } <line29> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line30> } <line31> return (com.liferay.commerce.product.model.CommerceCatalog) returnObj; <line32> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line33> throw systemException; <line34> } <line35> } <line36> } <line37> "	<line33>
5981	"public class A { <line0> @Override <line1> public void doRouteStatusChange(DocumentRouteStatusChange statusChangeEvent) { <line2> super.doRouteStatusChange(statusChangeEvent); <line3> String newRouteStatus = statusChangeEvent.getNewRouteStatus(); <line4> if (newRouteStatus.equalsIgnoreCase(KFSConstants.DocumentStatusCodes.PROCESSED) <line5> || newRouteStatus.equalsIgnoreCase(KFSConstants.DocumentStatusCodes.FINAL)) { <line6> try { <line7> updateContractsGrantsInvoiceDocument(); <line8> } catch (WorkflowException ex) { <line9> throw new RuntimeException( <line10> ""Could not update Contracts & Grants Invoice Document for Final Billed Indicator"" <line11> + "" Document"", <line12> ex); <line13> } <line14> } <line15> } <line16> } <line17> "	<line9>
5982	public class A { <line0> @Override <line1> public ChannelHandler call() throws Exception { <line2> try { <line3> return new SslHandler(createSslEngine(input)); <line4> } catch (SSLException e) { <line5> throw e; <line6> } <line7> } <line8> } <line9> 	<line5>
5983	"public class A { <line0> @Override <line1> protected void beginNodesRestart() { <line2> stopRestartThread.set(false); <line3> nodeRestartFut = <line4> GridTestUtils.runAsync( <line5> new Callable<Void>() { <line6> @Override <line7> public Void call() throws Exception { <line8> while (!stopRestartThread.get() && System.currentTimeMillis() < endTime) { <line9> for (int i = GRID_CNT - RESTARTED_NODE_CNT; i < GRID_CNT; ++i) stopGrid(i); <line10> Thread.sleep(500); <line11> for (int i = GRID_CNT - RESTARTED_NODE_CNT; i < GRID_CNT; ++i) startGrid(i); <line12> awaitPartitionMapExchange(); <line13> GridTestUtils.waitForCondition( <line14> new GridAbsPredicate() { <line15> @Override <line16> public boolean apply() { <line17> return !stopRestartThread.get(); <line18> } <line19> }, <line20> RESTART_TIMEOUT); <line21> } <line22> return null; <line23> } <line24> }, <line25> ""restart-node""); <line26> } <line27> } <line28> "	<line9>
5984	"public class A { <line0> @Test <line1> public void shouldVerifyWithUnknown() { <line2> PayPalStatusVerifier mockStatusVerifier = new MockStatusVerifier(); <line3> PayPalVerificationService verificationService = <line4> new PayPalVerificationService( <line5> ""dummyAddress"", <line6> new PayPalProcessorsFactory(MockVerifiedPayPalProcessor.class), <line7> new TestErrorHandler(), <line8> mockStatusVerifier); <line9> HashMap<String, String[]> parametersMap = new HashMap<String, String[]>(); <line10> parametersMap.put( <line11> RequestParameters.Parameter.payment_status.toString(), new String[] {""UNKNOWN""}); <line12> PayPalStatus status = <line13> verificationService.verify(new RequestParameters(new RequestMock(parametersMap))); <line14> assertThat(status.isUnknown()).isTrue(); <line15> } <line16> } <line17> "	<line2>
5985	"public class A { <line0> @VisibleForTesting <line1> static synchronized File dumpHeap(File directory) <line2> throws MalformedObjectNameException, InstanceNotFoundException, ReflectionException, <line3> MBeanException, IOException { <line4> boolean liveObjectsOnly = false; <line5> File fileName = new File(directory, ""heap_dump.hprof""); <line6> if (fileName.exists() && !fileName.delete()) { <line7> throw new IOException(""heap_dump.hprof already existed and couldn't be deleted!""); <line8> } <line9> MBeanServer mbs = ManagementFactory.getPlatformMBeanServer(); <line10> ObjectName oname = new ObjectName(""com.sun.management:type=HotSpotDiagnostic""); <line11> Object[] parameters = {fileName.getPath(), liveObjectsOnly}; <line12> String[] signatures = {String.class.getName(), boolean.class.getName()}; <line13> mbs.invoke(oname, ""dumpHeap"", parameters, signatures); <line14> if (java.nio.file.FileSystems.getDefault().supportedFileAttributeViews().contains(""posix"")) { <line15> Files.setPosixFilePermissions( <line16> fileName.toPath(), <line17> ImmutableSet.of( <line18> PosixFilePermission.OWNER_READ, <line19> PosixFilePermission.GROUP_READ, <line20> PosixFilePermission.OTHERS_READ)); <line21> } else { <line22> fileName.setReadable(true, true); <line23> } <line24> return fileName; <line25> } <line26> } <line27> "	<line24>
5986	public class A { <line0> protected Signature invokeSigningProcess() { <line1> signatureParameters.setSigningCertificate(signatureToken.getCertificate()); <line2> byte[] dataToSign = getSignatureFinalizer().getDataToBeSigned(); <line3> Signature result = null; <line4> byte[] signatureValue = null; <line5> try { <line6> signatureValue = signatureToken.sign(signatureParameters.getDigestAlgorithm(), dataToSign); <line7> result = finalizeSignature(signatureValue); <line8> } catch (TechnicalException e) { <line9> String dataToSignHex = Helper.bytesToHex(dataToSign, AsicSignatureFinalizer.HEX_MAX_LENGTH); <line10> String signatureValueHex = <line11> signatureValue == null <line12> ? null <line13> : Helper.bytesToHex(signatureValue, AsicSignatureFinalizer.HEX_MAX_LENGTH); <line14> } <line15> return result; <line16> } <line17> } <line18> 	<line1>, <line14>
5987	"public class A { <line0> private void performUpdateDaysSinceLastImportBatch( <line1> DataRoot dataRoot, <line2> final int fetchSize, <line3> int offset, <line4> AtomicInteger updatedDocs, <line5> final LocalDate nowDate) <line6> throws SolrServerException, DocumentStoreException, IOException { <line7> int updatedInBatch = 0; <line8> final SolrQuery query = createOldRecordsQuery(dataRoot); <line9> query.setStart(offset); <line10> query.setRows(fetchSize); <line11> for (SolrDocument doc : solrBridge.getClient().query(query).getResults()) { <line12> updatedInBatch++; <line13> String recordId = (String) doc.getFieldValue(fieldNameService.getFieldName(FieldKey.ID)); <line14> Date lastImportDate = <line15> (Date) doc.getFieldValue(fieldNameService.getFieldName(FieldKey.LAST_SEEN)); <line16> LocalDate oldDate = lastImportDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDate(); <line17> long daysSinceLastSeen = DAYS.between(oldDate, nowDate); <line18> SolrInputDocument updateDoc = new SolrInputDocument(); <line19> updateDoc.setField(fieldNameService.getFieldName(FieldKey.ID), recordId); <line20> final Map<String, Long> partialUpdateMap = Collections.singletonMap(""set"", daysSinceLastSeen); <line21> updateDoc.setField( <line22> fieldNameService.getFieldName(FieldKey.DAYS_SINCE_LAST_SEEN), partialUpdateMap); <line23> solrBridge.addDocument(updateDoc); <line24> final Throwable error = solrBridge.popError(); <line25> if (error != null) { <line26> throw new DocumentStoreException(error); <line27> } <line28> } <line29> final int totalUpdated = updatedDocs.addAndGet(updatedInBatch); <line30> } <line31> } <line32> "	<line30>
5988	"public class A { <line0> @Override <line1> public String doNodes(Node node, Item item) throws IOException { <line2> if (node == null) { <line3> return null; <line4> } <line5> Node e = getElement(node); <line6> NodeList nl = e.getChildNodes(); <line7> int len = nl.getLength(); <line8> String sfxfield = """"; <line9> int i = 0; <line10> while ((i < len) && StringUtils.isEmpty(sfxfield)) { <line11> Node nd = nl.item(i); <line12> if ((nd == null) || isEmptyTextNode(nd)) { <line13> i++; <line14> continue; <line15> } <line16> String tagName = nd.getNodeName(); <line17> if (tagName.equals(""query-pairs"")) { <line18> sfxfield = processFields(nd, item); <line19> } <line20> i++; <line21> } <line22> return sfxfield; <line23> } <line24> } <line25> "	<line3>, <line22>
5989	"public class A { <line0> private void checkHierarchy(MCRMODSWrapper mods) throws MCRPersistenceException { <line1> final MCRObjectID modsId = Objects.requireNonNull(mods.getMCRObject().getId()); <line2> final List<Element> relatedItemLeaves = <line3> mods.getElements("".//mods:relatedItem[not(mods:relatedItem)]""); <line4> try { <line5> relatedItemLeaves.forEach(e -> checkHierarchy(e, new HashSet<>(Set.of(modsId)))); <line6> } catch (MCRPersistenceException e) { <line7> throw new MCRPersistenceException( <line8> ""Hierarchy of mods:relatedItem in "" + modsId + "" contains circuits."", e); <line9> } <line10> } <line11> } <line12> "	<line2>
5990	"public class A { <line0> @Override <line1> public void createState(State state) throws DocumentException { <line2> String id = (String) state.get(KEY_ID); <line3> if (log.isTraceEnabled()) { <line4> } <line5> if (states.containsKey(id)) { <line6> throw new DocumentException(""Already exists: "" + id); <line7> } <line8> state = StateHelper.deepCopy(state, true); <line9> StateHelper.resetDeltas(state); <line10> states.put(id, state); <line11> } <line12> } <line13> "	<line4>
5991	public class A { <line0> @Override <line1> public boolean isWorkDone() { <line2> synchronized (getMonitor()) { <line3> for (Bot bot : getBots()) { <line4> if (!bot.isWorkDone()) { <line5> return false; <line6> } <line7> } <line8> } <line9> return true; <line10> } <line11> } <line12> 	<line2>, <line5>, <line9>
5992	"public class A { <line0> @Override <line1> public Representation get() { <line2> StringRepresentation presentation = null; <line3> try { <line4> String clusterName = (String) getRequest().getAttributes().get(""clusterName""); <line5> presentation = getInstancesRepresentation(clusterName); <line6> } catch (Exception e) { <line7> String error = ClusterRepresentationUtil.getErrorAsJsonStringFromException(e); <line8> presentation = new StringRepresentation(error, MediaType.APPLICATION_JSON); <line9> } <line10> return presentation; <line11> } <line12> } <line13> "	<line9>
5993	"public class A { <line0> @Override <line1> public String getDiscussionPath() { <line2> if (_wikiGroupServiceOverriddenConfiguration == null) { <line3> try { <line4> _wikiGroupServiceOverriddenConfiguration = <line5> ConfigurationProviderUtil.getConfiguration( <line6> WikiGroupServiceOverriddenConfiguration.class, <line7> new GroupServiceSettingsLocator(_page.getGroupId(), WikiConstants.SERVICE_NAME)); <line8> } catch (Exception exception) { <line9> return null; <line10> } <line11> } <line12> if (_wikiGroupServiceOverriddenConfiguration.pageCommentsEnabled()) { <line13> return ""edit_page_discussion""; <line14> } <line15> return null; <line16> } <line17> } <line18> "	<line9>
5994	public class A { <line0> private Pair<Filter, Set<String>> buildFromFIQL(final ReconQuery reconQuery) { <line1> Filter filter = null; <line2> Set<String> moreAttrsToGet = new HashSet<>(); <line3> if (reconQuery.getMoreAttrsToGet() != null) { <line4> moreAttrsToGet.addAll(reconQuery.getMoreAttrsToGet()); <line5> } <line6> if (StringUtils.isNotBlank(reconQuery.getFiql())) { <line7> try { <line8> FilterVisitor visitor = new FilterVisitor(); <line9> SearchCondition<SearchBean> sc = <line10> searchContext.getCondition(reconQuery.getFiql(), SearchBean.class); <line11> sc.accept(visitor); <line12> filter = visitor.getQuery(); <line13> moreAttrsToGet.addAll(visitor.getAttrs()); <line14> } catch (Exception e) { <line15> SyncopeClientException sce = <line16> SyncopeClientException.build(ClientExceptionType.InvalidSearchExpression); <line17> sce.getElements().add(reconQuery.getFiql()); <line18> sce.getElements().add(ExceptionUtils.getRootCauseMessage(e)); <line19> throw sce; <line20> } <line21> } <line22> return Pair.of(filter, moreAttrsToGet); <line23> } <line24> } <line25> 	<line15>
5995	"public class A { <line0> protected void replaceDBAndTableNames(HiveConf metastoreConf, ASTNode tree) { <line1> if (tree == null) { <line2> return; <line3> } <line4> if (TOK_TABREF == tree.getToken().getType()) { <line5> String alias; <line6> String tblName = null; <line7> Table tbl = null; <line8> ASTNode tabNameChild = (ASTNode) tree.getChild(0); <line9> if (TOK_TABNAME == tabNameChild.getToken().getType()) { <line10> try { <line11> if (tabNameChild.getChildCount() == 2) { <line12> ASTNode dbIdentifier = (ASTNode) tabNameChild.getChild(0); <line13> ASTNode tableIdentifier = (ASTNode) tabNameChild.getChild(1); <line14> tblName = tableIdentifier.getText(); <line15> String lensTable = dbIdentifier.getText() + ""."" + tblName; <line16> tbl = CubeMetastoreClient.getInstance(metastoreConf).getHiveTable(lensTable); <line17> String table = getUnderlyingTableName(tbl); <line18> String db = getUnderlyingDBName(tbl); <line19> if (""default"".equalsIgnoreCase(db)) { <line20> tabNameChild.deleteChild(0); <line21> } else if (StringUtils.isNotBlank(db)) { <line22> dbIdentifier.getToken().setText(db); <line23> } <line24> if (StringUtils.isNotBlank(table)) { <line25> tableIdentifier.getToken().setText(table); <line26> } <line27> } else { <line28> ASTNode tableIdentifier = (ASTNode) tabNameChild.getChild(0); <line29> tblName = tableIdentifier.getText(); <line30> tbl = CubeMetastoreClient.getInstance(metastoreConf).getHiveTable(tblName); <line31> String table = getUnderlyingTableName(tbl); <line32> if (StringUtils.isNotBlank(table)) { <line33> tableIdentifier.getToken().setText(table); <line34> } <line35> String dbName = getUnderlyingDBName(tbl); <line36> if (StringUtils.isNotBlank(dbName) && !""default"".equalsIgnoreCase(dbName)) { <line37> ASTNode dbIdentifier = new ASTNode(new CommonToken(HiveParser.Identifier, dbName)); <line38> dbIdentifier.setParent(tabNameChild); <line39> tabNameChild.insertChild(0, dbIdentifier); <line40> } <line41> } <line42> } catch (LensException | HiveException e) { <line43> } <line44> } <line45> if (tree.getChildCount() == 2) { <line46> alias = tree.getChild(1).getText(); <line47> } else { <line48> alias = tblName; <line49> } <line50> if (StringUtils.isNotBlank(alias)) { <line51> alias = alias.toLowerCase(); <line52> if (!aliasToNativeTableInfo.containsKey(alias)) { <line53> if (tbl != null) { <line54> aliasToNativeTableInfo.put(alias, new NativeTableInfo(tbl)); <line55> } <line56> } <line57> } <line58> } else { <line59> for (int i = 0; i < tree.getChildCount(); i++) { <line60> replaceDBAndTableNames(metastoreConf, (ASTNode) tree.getChild(i)); <line61> } <line62> } <line63> } <line64> } <line65> "	<line43>
5996	"public class A { <line0> private void delete() throws IOException { <line1> try { <line2> FileSessionProvider.invalidate(path, file); <line3> } catch (IOException e) { <line4> throw e; <line5> } <line6> close(); <line7> if (path.delete() == false) { <line8> throw new IOException( <line9> MessageFormat.format( <line10> ""Failed to delete session object (id=\""{0}\"", path=\""{1}\"")"", id, path)); <line11> } <line12> } <line13> } <line14> "	<line4>, <line7>, <line8>
5997	"public class A { <line0> @Override <line1> public void service(HttpServletRequest request, HttpServletResponse response) <line2> throws ServletException, IOException { <line3> String resourcePath = request.getRequestURI().substring(request.getContextPath().length() + 1); <line4> InputStream in = null; <line5> try { <line6> if (resourcePath.startsWith(""generated-res"")) { <line7> URLConnection conn = <line8> MolgenisOriginalStyle.class.getResource(resourcePath.substring(10)).openConnection(); <line9> in = new BufferedInputStream(conn.getInputStream()); <line10> response.setHeader(""Cache-Control"", ""max-age=0""); <line11> OutputStream out = response.getOutputStream(); <line12> byte[] buffer = new byte[2048]; <line13> for (; ; ) { <line14> int nBytes = in.read(buffer); <line15> if (nBytes <= 0) break; <line16> out.write(buffer, 0, nBytes); <line17> } <line18> out.flush(); <line19> out.close(); <line20> } <line21> } catch (Exception e) { <line22> e.printStackTrace(); <line23> } finally { <line24> IOUtils.closeQuietly(in); <line25> } <line26> } <line27> } <line28> "	<line23>
5998	public class A { <line0> @Test <line1> public void a_aVerifyConnection() { <line2> VerifyConnectionResponse response = <line3> projectServiceStub.verifyConnection(Empty.newBuilder().build()); <line4> assertTrue(response.getStatus()); <line5> } <line6> } <line7> 	<line2>, <line5>
5999	public class A { <line0> public void start() throws Exception { <line1> if (server == null) { <line2> Vertx vertx = hostConfiguration.getVertx(); <line3> Router router = hostConfiguration.getRouter(); <line4> HttpServerOptions options = hostConfiguration.getServerOptions(); <line5> SSLContextParameters sslContextParameters = hostConfiguration.getSslContextParameters(); <line6> if (sslContextParameters != null) { <line7> if (options == null) { <line8> options = new HttpServerOptions(); <line9> } <line10> VertxWebsocketHelper.setupSSLOptions(sslContextParameters, options); <line11> } <line12> if (options != null) { <line13> server = vertx.createHttpServer(options); <line14> } else { <line15> server = vertx.createHttpServer(); <line16> } <line17> CompletableFuture<Void> future = new CompletableFuture<>(); <line18> server <line19> .requestHandler(router) <line20> .listen( <line21> hostKey.getPort(), <line22> hostKey.getHost(), <line23> result -> { <line24> if (!result.failed()) { <line25> port = result.result().actualPort(); <line26> future.complete(null); <line27> } else { <line28> future.completeExceptionally(result.cause()); <line29> } <line30> }); <line31> future.get(); <line32> } <line33> } <line34> } <line35> 	<line27>
6000	public class A { <line0> private void cleanUpTmpFile(Path tmpFile) { <line1> if (tmpFile == null) { <line2> return; <line3> } <line4> try { <line5> Files.deleteIfExists(tmpFile); <line6> } catch (IOException ignored) { <line7> } <line8> } <line9> } <line10> 	<line7>
6001	public class A { <line0> @Override <line1> public int read(byte[] b, int off, int len) throws IOException { <line2> if (endedAndEmpty()) { <line3> return -1; <line4> } <line5> if (log.isDebugEnabled()) { <line6> } <line7> int bufLen, byteCount; <line8> synchronized (bufferLock) { <line9> bufLen = buffer.length(); <line10> } <line11> if (bufLen == 0) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> bufferChanged$.firstOrError().blockingGet(); <line15> } <line16> synchronized (bufferLock) { <line17> bufLen = buffer.length(); <line18> byteCount = Math.min(len, bufLen); <line19> sliceBuffer(byteCount).getByteBuf().getBytes(0, b, off, byteCount); <line20> } <line21> if (log.isDebugEnabled()) { <line22> } <line23> return byteCount; <line24> } <line25> } <line26> 	<line3>, <line6>, <line13>, <line22>
6002	public class A { <line0> @Override <line1> public void processResponse( <line2> final Response response, final ObjectOutputStream out, final ProtocolMetaData metaData) <line3> throws Exception { <line4> if (null != response) { <line5> if (ClusterResponse.class.isInstance(response)) { <line6> final ClusterResponse res = (ClusterResponse) response; <line7> try { <line8> res.setMetaData(metaData); <line9> res.writeExternal(out); <line10> } catch (IOException e) { <line11> throw e; <line12> } <line13> } else { <line14> } <line15> } <line16> } <line17> } <line18> 	<line11>, <line14>
6003	public class A { <line0> public Criteria getSeriesCriteriaFor( <line1> String procedure, String observableProperty, String featureOfInterest, Session session) { <line2> final Criteria c = createCriteriaFor(procedure, observableProperty, featureOfInterest, session); <line3> return c; <line4> } <line5> } <line6> 	<line3>
6004	public class A { <line0> @Override <line1> public List<HistoricItem> doGetHistItemFilterQuery( <line2> Item item, <line3> FilterCriteria filter, <line4> int numberDecimalcount, <line5> String table, <line6> String name, <line7> ZoneId timeZone) { <line8> String sql = histItemFilterQueryProvider(filter, numberDecimalcount, table, name, timeZone); <line9> List<Object[]> m = Yank.queryObjectArrays(sql, null); <line10> String itemName = item.getName(); <line11> Unit<? extends Quantity<?>> unit = <line12> item instanceof NumberItem ? ((NumberItem) item).getUnit() : null; <line13> return m.stream() <line14> .map( <line15> o -> { <line16> return new JdbcHistoricItem(itemName, getState(item, unit, o[1]), objectAsDate(o[0])); <line17> }) <line18> .collect(Collectors.<HistoricItem>toList()); <line19> } <line20> } <line21> 	<line10>, <line16>
6005	public class A { <line0> @Override <line1> public void onResponse(T response, Map<String, String> responseHeaders) { <line2> this.response = response; <line3> if (LOG.isDebugEnabled()) { <line4> if (response instanceof ClientEntitySet) { <line5> } else if (response instanceof ClientEntity) { <line6> } else { <line7> } <line8> } <line9> latch.countDown(); <line10> } <line11> } <line12> 	<line5>, <line6>, <line7>
6006	"public class A { <line0> @Override <line1> public void execute(AjaxRequestTarget target, IModel<User> parameter) { <line2> try { <line3> UserGroup userGroup = UserGroupDetailUsersPanel.this.getModelObject(); <line4> User user = parameter.getObject(); <line5> userGroupService.removeUser(userGroup, user); <line6> Session.get().success(getString(""common.success"")); <line7> throw new RestartResponseException(getPage()); <line8> } catch (RestartResponseException e) { <line9> throw e; <line10> } catch (Exception e) { <line11> FeedbackUtils.refreshFeedback(target, getPage()); <line12> } <line13> } <line14> } <line15> "	<line11>
6007	public class A { <line0> @Override <line1> public GetLocationOfCurrentStationReturned getLocationOfCurrentStation() { <line2> throw new UnsupportedOperationException(); <line3> } <line4> } <line5> 	<line2>
6008	public class A { <line0> public static Integer initPreparedStatementsCacheSize(ConfigMap configMap) { <line1> return configMap.getTypedOr(PREPARED_STATEMENTS_CACHE_SIZE, DEFAULT_LRU_CACHE_SIZE); <line2> } <line3> } <line4> 	<line1>
6009	"public class A { <line0> @Override <line1> public ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException { <line2> String sql = ""SELECT DISTINCT name FROM "" + catalog + "".dbo.sysusers where suid > 0""; <line3> ResultSet rs = null; <line4> PreparedStatement stmt = null; <line5> List<String[]> list = new ArrayList<String[]>(); <line6> try { <line7> stmt = connection.prepareStatement(sql); <line8> rs = stmt.executeQuery(); <line9> while (rs.next()) { <line10> String name = rs.getString(""name""); <line11> String[] r = new String[] {name.trim()}; <line12> list.add(r); <line13> } <line14> } catch (SQLException e) { <line15> throw new RuntimeException(e); <line16> } finally { <line17> try { <line18> if (rs != null) { <line19> rs.close(); <line20> } <line21> if (stmt != null) { <line22> stmt.close(); <line23> } <line24> } catch (Exception e) { <line25> } <line26> } <line27> SybaseResultSet tableResultSet = new SybaseResultSet(); <line28> tableResultSet.setMetadata(new String[] {""TABLE_SCHEM""}); <line29> tableResultSet.setData(list); <line30> return tableResultSet; <line31> } <line32> } <line33> "	<line25>
6010	"public class A { <line0> @Override <line1> public void enforceListDatastreams(Context context, String pid, Date asOfDate) <line2> throws AuthzException { <line3> try { <line4> String target = Constants.ACTION.LIST_DATASTREAMS.uri; <line5> context.setActionAttributes(null); <line6> MultiValueMap<URI> resourceAttributes = new MultiValueMap<URI>(); <line7> try { <line8> resourceAttributes.set( <line9> Constants.RESOURCE.AS_OF_DATETIME.attributeId, ensureDate(asOfDate, context)); <line10> } catch (Exception e) { <line11> context.setResourceAttributes(null); <line12> throw new AuthzOperationalException( <line13> target + "" couldn't set "" + Constants.RESOURCE.AS_OF_DATETIME.uri, e); <line14> } <line15> context.setResourceAttributes(resourceAttributes); <line16> xacmlPep.enforce( <line17> context.getSubjectValue(Constants.SUBJECT.LOGIN_ID.uri), <line18> target, <line19> Constants.ACTION.APIA.uri, <line20> pid, <line21> extractNamespace(pid), <line22> context); <line23> } finally { <line24> } <line25> } <line26> } <line27> "	<line4>, <line24>
6011	public class A { <line0> private void ensureSuccessWhenReleasedToPool(Channel channel, Future<Void> released) { <line1> if (released.isSuccess()) { <line2> } else { <line3> } <line4> } <line5> } <line6> 	<line2>, <line3>
6012	public class A { <line0> @Override <line1> public void applicationAdded(SpaceLifeCycleEvent event) { <line2> } <line3> } <line4> 	<line2>
6013	public class A { <line0> protected FinancialSystemMaintenanceDocument getParentMaintDoc() { <line1> DocumentService documentService = SpringContext.getBean(DocumentService.class); <line2> try { <line3> return (FinancialSystemMaintenanceDocument) <line4> documentService.getByDocumentHeaderId(getDocumentNumber()); <line5> } catch (WorkflowException e) { <line6> } <line7> return null; <line8> } <line9> } <line10> 	<line6>
6014	public class A { <line0> @Override <line1> protected void onCompleteFailure(Throwable x) { <line2> lease.recycle(); <line3> Throwable closed; <line4> Set<Entry> allEntries; <line5> try (AutoLock l = lock.lock()) { <line6> closed = terminated; <line7> terminated = x; <line8> if (LOG.isDebugEnabled()) <line9> allEntries = new HashSet<>(entries); <line10> entries.clear(); <line11> } <line12> allEntries.addAll(processedEntries); <line13> processedEntries.clear(); <line14> allEntries.addAll(pendingEntries); <line15> pendingEntries.clear(); <line16> allEntries.forEach(entry -> entry.failed(x)); <line17> if (closed == null) session.onWriteFailure(x); <line18> } <line19> } <line20> 	<line9>
6015	public class A { <line0> @Override <line1> protected synchronized void stopScan() { <line2> dsmrBridgeHandler.setLenientMode(false); <line3> super.stopScan(); <line4> dsmrBridgeHandler.unregisterDSMRMeterListener(this); <line5> } <line6> } <line7> 	<line2>
6016	"public class A { <line0> public static TokenResponse getTokenResponse( <line1> String googleClientID, String googleClientSecret, String code, String redirectUri) { <line2> final AuthorizationCodeFlow flow = <line3> new AuthorizationCodeFlow.Builder( <line4> BearerToken.authorizationHeaderAccessMethod(), <line5> TokenResource.HTTP_TRANSPORT, <line6> TokenResource.JSON_FACTORY, <line7> new GenericUrl(GoogleHelper.GOOGLE_ENCODED_URL), <line8> new ClientParametersAuthentication(googleClientID, googleClientSecret), <line9> googleClientID, <line10> GoogleHelper.GOOGLE_AUTHORIZATION_SERVICE_ENCODED_URL) <line11> .build(); <line12> try { <line13> return flow.newTokenRequest(code) <line14> .setRedirectUri(redirectUri) <line15> .setRequestInitializer(request -> request.getHeaders().setAccept(""application/json"")) <line16> .execute(); <line17> } catch (IOException e) { <line18> throw new CustomWebApplicationException( <line19> ""Could not retrieve google token based on code"", HttpStatus.SC_BAD_REQUEST); <line20> } <line21> } <line22> } <line23> "	<line18>
6017	"public class A { <line0> public void dealNotifications() { <line1> DimeExternalNotification externalNotififcation = notifierManager.popExternalNotification(); <line2> if (externalNotififcation != null) { <line3> DimeServiceAdapter adapter = null; <line4> DimeExternalNotification tmpNotification; <line5> String senderURI = externalNotififcation.getSender(); <line6> String targetURI = externalNotififcation.getTarget(); <line7> Tenant tenant = TenantHelper.getTenant(externalNotififcation.getTenant()); <line8> try { <line9> String senderName = credentialStore.getUsername(senderURI, targetURI, tenant); <line10> String targetName = credentialStore.getNameSaid(senderURI, targetURI, tenant); <line11> try { <line12> adapter = (DimeServiceAdapter) serviceGateway.getDimeServiceAdapter(senderName); <line13> } catch (ServiceNotAvailableException e) { <line14> } <line15> tmpNotification = <line16> new DimeExternalNotification( <line17> targetName, <line18> senderName, <line19> externalNotififcation.getOperation(), <line20> externalNotififcation.getItemID(), <line21> externalNotififcation.getName(), <line22> externalNotififcation.getItemType(), <line23> null); <line24> adapter.set(""/notification"", tmpNotification); <line25> } catch (Exception e) { <line26> } <line27> } <line28> } <line29> } <line30> "	<line1>, <line2>, <line14>, <line24>, <line26>
6018	public class A { <line0> @Override <line1> public void close() { <line2> isRunning.compareAndSet(true, false); <line3> } <line4> } <line5> 	<line3>
6019	public class A { <line0> private int addDevicesForTenant(final JsonObject tenant) { <line1> final String tenantId = tenant.getString(RegistryManagementConstants.FIELD_TENANT); <line2> if (tenantId == null) { <line3> return 0; <line4> } <line5> int count = 0; <line6> final ConcurrentMap<String, FileBasedDeviceDto> deviceMap = new ConcurrentHashMap<>(); <line7> for (final Object deviceObj : tenant.getJsonArray(RegistryManagementConstants.FIELD_DEVICES)) { <line8> if (deviceObj instanceof JsonObject) { <line9> final JsonObject entry = (JsonObject) deviceObj; <line10> final String deviceId = entry.getString(RegistrationConstants.FIELD_PAYLOAD_DEVICE_ID); <line11> if (deviceId != null) { <line12> final FileBasedDeviceDto deviceDto = <line13> FileBasedDeviceDto.forRead(tenantId, deviceId, entry); <line14> deviceMap.put(deviceId, deviceDto); <line15> count++; <line16> } <line17> } <line18> } <line19> identities.put(tenantId, deviceMap); <line20> return count; <line21> } <line22> } <line23> 	<line3>, <line6>, <line12>, <line20>
6020	public class A { <line0> @Override <line1> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <line2> throws IOException, ServletException { <line3> HttpServletRequest req = (HttpServletRequest) request; <line4> String requestURI = req.getRequestURI(); <line5> if (isUriNotProtected(requestURI)) { <line6> chain.doFilter(request, response); <line7> return; <line8> } <line9> String xhrToken = req.getHeader(GlobalDataRest.X_CSRF_TOKEN); <line10> String sessionId = req.getRequestedSessionId(); <line11> String token = tokenMap.get(sessionId); <line12> if (sessionId != null && token != null && token.equals(xhrToken)) { <line13> deleteTokenWhenLogout(req, sessionId); <line14> chain.doFilter(request, response); <line15> } else { <line16> deleteTokenWhenLogout(req, sessionId); <line17> final HttpServletResponse newResponse = (HttpServletResponse) response; <line18> newResponse.sendError( <line19> Status.FORBIDDEN.getStatusCode(), CSRF_STATE_TOKEN_DOES_NOT_MATCH_ONE_PROVIDED); <line20> StreamUtils.closeSilently(request.getInputStream()); <line21> } <line22> } <line23> } <line24> 	<line17>
6021	public class A { <line0> protected DatagramSocket sendDiscoveryPacket() throws IOException { <line1> final DatagramSocket ds = new DatagramSocket(null); <line2> ds.setBroadcast(true); <line3> ds.setSoTimeout(UDP_PACKET_TIMEOUT_MS); <line4> ds.send(discoverPacket); <line5> return ds; <line6> } <line7> } <line8> 	<line5>
6022	public class A { <line0> public CreateVersionPage inputVersionId(final String versionId) { <line1> enterText(getVersionIdField(), versionId); <line2> return new CreateVersionPage(getDriver()); <line3> } <line4> } <line5> 	<line1>
6023	public class A { <line0> public void unjoin(String invokerRemoteAddress, String remoteAddress) { <line1> String rmiAddress = getRmiAddress(remoteAddress); <line2> try { <line3> RemoteCommunication ske = null; <line4> ske = (RemoteCommunication) Naming.lookup(rmiAddress); <line5> ske.remoteUnjoin(invokerRemoteAddress, remoteAddress); <line6> } catch (Exception ex) { <line7> } <line8> } <line9> } <line10> 	<line1>, <line7>
6024	"public class A { <line0> protected void onRead(ByteBuffer byteBuffer) { <line1> try { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> int byteCount = getByteCount(byteBuffer); <line5> while (byteCount > 0) { <line6> byte[] message = new byte[byteCount]; <line7> byteBuffer.get(message, 0, byteCount); <line8> if (logger.isTraceEnabled()) { <line9> } <line10> String strippedBuffer = stripByteCount(ByteBuffer.wrap(message)); <line11> if (strippedBuffer != null) { <line12> String strippedMessage = strippedBuffer.split(""\0"")[0]; <line13> if (strippedMessage.contains(""RESULT OK"")) { <line14> parseOKMessage(strippedMessage); <line15> } <line16> if (strippedMessage.contains(""RCV_HEX"")) { <line17> parseHexMessage(strippedMessage); <line18> } <line19> if (strippedMessage.contains(""RCV_COM"")) { <line20> parseIRDBMessage(strippedMessage); <line21> } <line22> byteCount = getByteCount(byteBuffer); <line23> } else { <line24> } <line25> } <line26> } catch (Exception e) { <line27> } <line28> } <line29> } <line30> "	<line3>, <line9>, <line24>, <line27>
6025	public class A { <line0> @VisibleForTesting <line1> static int getThreadCount(@Nullable final String threadCountArg) { <line2> final int availableThreads = Runtime.getRuntime().availableProcessors(); <line3> if (threadCountArg == null) { <line4> return availableThreads; <line5> } <line6> try { <line7> final int numThreads = Integer.parseInt(threadCountArg); <line8> if (numThreads <= 0) { <line9> throw new NumberFormatException(); <line10> } <line11> return numThreads; <line12> } catch (NumberFormatException e) { <line13> return availableThreads; <line14> } <line15> } <line16> } <line17> 	<line13>
6026	"public class A { <line0> private void sendObject(final Object object, final Logger logger) { <line1> if (logger.isInfoEnabled()) { <line2> final JsonObject log = new JsonObject(); <line3> log.addProperty(""appName"", appName); <line4> log.addProperty(""host"", localHostName); <line5> log.add(""event"", GSON.toJsonTree(object)); <line6> } <line7> } <line8> } <line9> "	<line6>
6027	public class A { <line0> private boolean processEvents() { <line1> return hztx.runInTransactionRet( <line2> () -> { <line3> TransactionContext hzContext = HzTransactionTL.getHzContext(); <line4> TransactionalQueue<RDBMSEventsBatch> queue = hzContext.getQueue(RDBMS_EVENTS_QUEUE); <line5> RDBMSEventsBatch batch = null; <line6> do { <line7> try { <line8> batch = queue.poll(250, TimeUnit.MILLISECONDS); <line9> } catch (HazelcastException | InterruptedException e) { <line10> return queue.size() > 0; <line11> } catch (HazelcastInstanceNotActiveException e) { <line12> return false; <line13> } <line14> } while (batch == null && !stopped.get()); <line15> if (batch != null) processSingleBatch(batch); <line16> return queue.size() > 0; <line17> }); <line18> } <line19> } <line20> 	<line10>, <line12>
6028	"public class A { <line0> @Override <line1> public final void doGet(HttpServletRequest request, HttpServletResponse response) <line2> throws IOException { <line3> try { <line4> String source = request.getParameter(""source""); <line5> if (Source.local_client.name().equals(source)) { <line6> renderLocalClient(request, response); <line7> } else if (Source.hnr_client.name().equals(source)) { <line8> renderHnrClient(request, response); <line9> } else if (Source.integrator_client.name().equals(source)) { <line10> renderIntegratorClient(request, response); <line11> } else if (Source.signature_preview.name().equals(source)) { <line12> renderSignaturePreview(request, response); <line13> } else if (Source.signature_stored.name().equals(source)) { <line14> renderSignatureStored(request, response); <line15> } else if (Source.clinic_logo.name().equals(source)) { <line16> renderClinicLogoStored(request, response); <line17> } else { <line18> throw (new IllegalArgumentException(""Unknown source type : "" + source)); <line19> } <line20> } catch (Exception e) { <line21> if (e.getCause() instanceof SocketException) { <line22> } else { <line23> response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); <line24> } <line25> } <line26> } <line27> } <line28> "	<line22>, <line23>
6029	public class A { <line0> @Override <line1> public ReadingPublisher<Pca301Reading> createPublisher() { <line2> return new ReadingPublisher<Pca301Reading>() { <line3> @Override <line4> public void publish(Pca301Reading reading) { <line5> if (reading != null) { <line6> channel.set(reading.getChannel()); <line7> BigDecimal current = <line8> new BigDecimal(reading.getCurrent()).setScale(1, RoundingMode.HALF_UP); <line9> state = reading.isOn() ? OnOffType.ON : OnOffType.OFF; <line10> updateState(CURRENT_POWER_CHANNEL, new QuantityType<>(current, Units.WATT)); <line11> updateState(CONSUMPTION_CHANNEL, new QuantityType<>(reading.getTotal(), Units.WATT_HOUR)); <line12> updateState(SWITCHING_STATE_CHANNEL, state); <line13> } <line14> } <line15>  <line16> @Override <line17> public void dispose() {} <line18> }; <line19> } <line20> } <line21> 	<line13>
6030	"public class A { <line0> @Override <line1> public void instantiateServiceInstance() { <line2> if (monitor.enterIf(isStartable)) { <line3> try { <line4> state = STARTING; <line5> delegate.instantiateServiceInstance(); <line6> state = RUNNING; <line7> } finally { <line8> monitor.leave(); <line9> } <line10> } else { <line11> throw new IllegalStateException(""Service "" + this + "" has already been started""); <line12> } <line13> } <line14> } <line15> "	<line4>
6031	public class A { <line0> boolean detectContentChanged() { <line1> File targetFile = new File(filePath); <line2> if (!targetFile.exists()) { <line3> if (lastModifiedTimestamp == 0) { <line4> return false; <line5> } else { <line6> lastModifiedTimestamp = 0; <line7> return true; <line8> } <line9> } else { <line10> long lastModified = targetFile.lastModified(); <line11> if (lastModified != lastModifiedTimestamp) { <line12> try (FileInputStream fileInputStream = new FileInputStream(targetFile)) { <line13> byte[] b = new byte[1024]; <line14> ByteArrayOutputStream os = new ByteArrayOutputStream(); <line15> int c; <line16> while ((c = fileInputStream.read(b)) != -1) { <line17> os.write(b, 0, c); <line18> } <line19> byte[] newContent = os.toByteArray(); <line20> if (!Arrays.equals(newContent, fileContent)) { <line21> fileContent = newContent; <line22> return true; <line23> } else { <line24> return false; <line25> } <line26> } catch (FileNotFoundException e) { <line27> } catch (IOException e) { <line28> } finally { <line29> lastModifiedTimestamp = lastModified; <line30> } <line31> } <line32> return false; <line33> } <line34> } <line35> } <line36> 	<line27>, <line28>
6032	public class A { <line0> private Geometry getBounds(List<Metacard> metacards) { <line1> if (metacards != null) { <line2> List<Geometry> geometries = new ArrayList<Geometry>(); <line3> for (Metacard card : metacards) { <line4> if (null != card.getLocation()) { <line5> Geometry geo = XmlNode.readGeometry(card.getLocation()); <line6> if (null != geo) { <line7> geometries.add(geo); <line8> } <line9> } <line10> } <line11> return new GeometryCollection(geometries.toArray(new Geometry[0]), new GeometryFactory()); <line12> } else { <line13> return null; <line14> } <line15> } <line16> } <line17> 	<line13>
6033	public class A { <line0> public boolean hasReadAuthorization(Set<String> userAndRoles, String noteId) { <line1> if (conf.isAnonymousAllowed()) { <line2> return true; <line3> } <line4> if (userAndRoles == null) { <line5> return false; <line6> } <line7> return isReader(noteId, userAndRoles); <line8> } <line9> } <line10> 	<line2>
6034	"public class A { <line0> private void sendDhtNearResponse( <line1> final GridDhtAtomicAbstractUpdateRequest req, GridDhtAtomicNearResponse nearRes) { <line2> try { <line3> ClusterNode node = ctx.discovery().node(req.nearNodeId()); <line4> if (node == null) <line5> throw new ClusterTopologyCheckedException(""Node failed: "" + req.nearNodeId()); <line6> if (node.isLocal()) processDhtAtomicNearResponse(node.id(), nearRes); <line7> else ctx.io().send(node, nearRes, ctx.ioPolicy()); <line8> if (msgLog.isDebugEnabled()) { <line9> } <line10> } catch (ClusterTopologyCheckedException ignored) { <line11> if (msgLog.isDebugEnabled()) { <line12> } <line13> } catch (IgniteCheckedException e) { <line14> } <line15> } <line16> } <line17> "	<line9>, <line12>, <line14>
6035	"public class A { <line0> public static SAXReader getSAXReader(final EntityResolver resolver) { <line1> SAXReader reader = new SAXReader(); <line2> if (resolver != null) { <line3> reader.setEntityResolver(resolver); <line4> } <line5> try { <line6> reader.setFeature(FEATURE_SECURE_PROCESSING, true); <line7> reader.setFeature(""http://xml.org/sax/features/external-general-entities"", false); <line8> reader.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false); <line9> reader.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false); <line10> } catch (SAXException e) { <line11> } <line12> reader.setIncludeExternalDTDDeclarations(false); <line13> reader.setIncludeInternalDTDDeclarations(false); <line14> return reader; <line15> } <line16> } <line17> "	<line11>
6036	public class A { <line0> public void markForDeletion(Application app, DataLocation loc, boolean enableReuse) { <line1> Semaphore sem = new Semaphore(0); <line2> if (enableReuse) { <line3> Semaphore semWait = new Semaphore(0); <line4> WaitForDataReadyToDeleteRequest request = <line5> new WaitForDataReadyToDeleteRequest(app, loc, sem, semWait); <line6> if (!this.requestQueue.offer(request)) { <line7> } <line8> sem.acquireUninterruptibly(); <line9> int nPermits = request.getNumPermits(); <line10> if (nPermits > 0) { <line11> semWait.acquireUninterruptibly(nPermits); <line12> } <line13> } <line14> if (!this.requestQueue.offer(new DeleteFileRequest(app, loc, sem, !enableReuse))) { <line15> } <line16> if (enableReuse) { <line17> sem.acquireUninterruptibly(); <line18> } <line19> } <line20> } <line21> 	<line1>, <line7>, <line8>, <line11>, <line14>, <line15>, <line17>, <line18>
6037	"public class A { <line0> @ApiOperation(value = ""Create ontology"") <line1> @PostMapping <line2> @ResponseStatus(HttpStatus.CREATED) <line3> public OntologyDto create(@Valid @RequestBody OntologyDto ontologyDto) { <line4> return service.create(buildUiHttpContext(), ontologyDto); <line5> } <line6> } <line7> "	<line4>
6038	public class A { <line0> @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) <line1> public void onEvent(ServerInfoRequestEvent event) { <line2> String quickShareFilename = quickShareBean != null ? quickShareBean.filename() : null; <line3> EventBus.getDefault().post(new ServerInfoResponseEvent(quickShareFilename)); <line4> } <line5> } <line6> 	<line2>
6039	public class A { <line0> @Override <line1> public void install() { <line2> DownloadResolver resolver = Entities.newDownloader(this); <line3> List<String> urls = resolver.getTargets(); <line4> String saveAs = resolver.getFilename(); <line5> OsDetails osDetails = getMachine().getMachineDetails().getOsDetails(); <line6> if (osDetails.isLinux()) { <line7> List<String> commands = installLinux(urls, saveAs); <line8> newScript(INSTALLING).body.append(commands).execute(); <line9> } <line10> } <line11> } <line12> 	<line6>
6040	"public class A { <line0> private void updateErrorStateInArchivalRecord(JsonObject messageJson) { <line1> if (messageJson.has(DataArchivalConstants.ARCHIVALNAME)) { <line2> if (!messageJson.get(DataArchivalConstants.ARCHIVALNAME).getAsString().isEmpty()) { <line3> if (messageJson.has(DataArchivalConstants.TASK) <line4> && ""remove_container"" <line5> .equalsIgnoreCase(messageJson.get(DataArchivalConstants.TASK).getAsString())) { <line6> dataArchivalConfigDal.updateArchivalStatus( <line7> messageJson.get(DataArchivalConstants.ARCHIVALNAME).getAsString(), <line8> DataArchivalStatus.ERROR_REMOVE_CONTAINER.toString()); <line9> } else { <line10> dataArchivalConfigDal.updateArchivalStatus( <line11> messageJson.get(DataArchivalConstants.ARCHIVALNAME).getAsString(), <line12> DataArchivalStatus.ERROR.toString()); <line13> } <line14> } else { <line15> } <line16> } else { <line17> } <line18> } <line19> } <line20> "	<line15>, <line17>
6041	"public class A { <line0> private void initialize() throws Exception { <line1> setServerRootDir(); <line2> readAndSetServicesConfig(); <line3> AuthN.setDataSource(JDBCTools.getDataSource(JDBCTools.CSPACE_DATASOURCE_NAME)); <line4> propagateConfiguredProperties(); <line5> createOrUpdateNuxeoDatasourceConfigFiles(); <line6> createOrUpdateNuxeoRepositoryConfigFiles(); <line7> createOrUpdateNuxeoElasticsearchConfigFiles(); <line8> HashSet<String> dbsCheckedOrCreated = createNuxeoDatabases(); <line9> String[] dataSourceNames = { <line10> JDBCTools.NUXEO_DATASOURCE_NAME, JDBCTools.NUXEO_READER_DATASOURCE_NAME <line11> }; <line12> updateInitializationScript( <line13> getNuxeoDatabasesDropScriptFilename(), dbsCheckedOrCreated, dataSourceNames); <line14> if (getClientType().equals(ClientType.JAVA)) { <line15> nuxeoConnector = NuxeoConnectorEmbedded.getInstance(); <line16> mirrorToStdOut(""\nStarting Nuxeo platform...""); <line17> nuxeoConnector.initialize( <line18> getServerRootDir(), <line19> getServicesConfigReader().getConfiguration().getRepositoryClient(), <line20> ServiceMain.servletContext); <line21> mirrorToStdOut(""Nuxeo platform started successfully.\n""); <line22> } else { <line23> throw new RuntimeException( <line24> ""Unknown CollectionSpace services client type: "" + getClientType()); <line25> } <line26> initializeEventListeners(); <line27> String cspaceDatabaseName = getCspaceDatabaseName(); <line28> Hashtable<String, TenantBindingType> tenantBindings = <line29> tenantBindingConfigReader.getTenantBindings(); <line30> for (String tenantId : tenantBindings.keySet()) { <line31> TenantBindingType tenantBinding = tenantBindings.get(tenantId); <line32> String persistedMD5Hash = <line33> AuthorizationCommon.getPersistedMD5Hash(tenantId, cspaceDatabaseName); <line34> String currentMD5Hash = tenantBinding.getConfigMD5Hash(); <line35> AuthorizationCommon.setTenantConfigMD5Hash(tenantId, currentMD5Hash); <line36> tenantBinding.setConfigChangedSinceLastStart( <line37> hasConfigChanged(tenantBinding, persistedMD5Hash, currentMD5Hash)); <line38> } <line39> JPATransactionContext jpaTransactionContext = new JPATransactionContext(); <line40> try { <line41> jpaTransactionContext.beginTransaction(); <line42> DatabaseProductType databaseProductType = <line43> JDBCTools.getDatabaseProductType(JDBCTools.CSPACE_DATASOURCE_NAME, cspaceDatabaseName); <line44> AuthorizationCommon.createTenants( <line45> tenantBindingConfigReader, databaseProductType, cspaceDatabaseName); <line46> AuthorizationCommon.createDefaultWorkflowPermissions( <line47> jpaTransactionContext, <line48> tenantBindingConfigReader, <line49> databaseProductType, <line50> cspaceDatabaseName); <line51> AuthorizationCommon.createDefaultAccounts( <line52> tenantBindingConfigReader, databaseProductType, cspaceDatabaseName); <line53> AuthorizationCommon.persistTenantBindingsMD5Hash( <line54> tenantBindingConfigReader, databaseProductType, cspaceDatabaseName); <line55> jpaTransactionContext.commitTransaction(); <line56> } catch (Exception e) { <line57> throw e; <line58> } finally { <line59> jpaTransactionContext.close(); <line60> } <line61> showTenantStatus(); <line62> } <line63> } <line64> "	<line57>
6042	"public class A { <line0> private ExecutorService initializeClientQueueInitializerThreadPool() { <line1> return CoreLoggingExecutors.newThreadPoolWithSynchronousFeed( <line2> CLIENT_QUEUE_INITIALIZATION_POOL_SIZE, <line3> 60000, <line4> MILLISECONDS, <line5> ""Client Queue Initialization Thread "", <line6> command -> { <line7> try { <line8> command.run(); <line9> } catch (CancelException e) { <line10> } <line11> }, <line12> getStats().getCnxPoolHelper(), <line13> getThreadMonitorObj()); <line14> } <line15> } <line16> "	<line10>
6043	"public class A { <line0> public void attach(ServoController controller, int sensorPin) { <line1> try { <line2> if (controller == null) { <line3> error(""setting null as controller""); <line4> return; <line5> } <line6> if (isAttached) { <line7> return; <line8> } <line9> this.sensorPin = sensorPin; <line10> controller.attach(controller); <line11> this.controller = controller; <line12> controllerName = this.controller.getName(); <line13> isAttached = true; <line14> broadcastState(); <line15> } catch (Exception e) { <line16> error(e); <line17> } <line18> } <line19> } <line20> "	<line7>, <line11>
6044	public class A { <line0> public static DottedQuad createArbitraryBitMask(final byte[] bitmask) { <line1> if (bitmask == null) { <line2> return IPV4_BITMASKS[IPV4_ADDRESS_LENGTH]; <line3> } <line4> final String hostAddress; <line5> try { <line6> hostAddress = InetAddress.getByAddress(bitmask).getHostAddress(); <line7> } catch (UnknownHostException e) { <line8> return null; <line9> } <line10> return new DottedQuad(hostAddress); <line11> } <line12> } <line13> 	<line8>
6045	"public class A { <line0> protected void initializeConnection(final IRODSAccount irodsAccount) throws JargonException { <line1> if (irodsAccount == null) { <line2> throw new JargonException(""no irods account specified, cannot connect""); <line3> } <line4> if (irodsProtocolManager == null) { <line5> throw new JargonException(""null irods connection manager""); <line6> } <line7> connect(irodsAccount); <line8> setConnected(true); <line9> initializeIdentifier(irodsAccount); <line10> } <line11> } <line12> "	<line1>, <line2>, <line5>, <line7>
6046	"public class A { <line0> @Override <line1> public void run(Browser browser) throws Exception { <line2> String name = browser.getId(); <line3> try { <line4> WebRtcEndpoint viewerWebRtcEp = new WebRtcEndpoint.Builder(mp).build(); <line5> masterWebRtcEp.connect(viewerWebRtcEp); <line6> LatencyController cs = new LatencyController(""Latency control on "" + name, monitor); <line7> getPage(name).subscribeEvents(""playing""); <line8> getPage(name).initWebRtc(viewerWebRtcEp, WebRtcChannel.VIDEO_ONLY, WebRtcMode.RCV_ONLY); <line9> cs.checkLatency(playTime, TimeUnit.MILLISECONDS, getPresenter(), getPage(name)); <line10> } catch (Throwable e) { <line11> throw e; <line12> } <line13> } <line14> } <line15> "	<line7>, <line11>
6047	public class A { <line0> private void forwardRequestWithoutAuthorizationCheck( <line1> HttpServletRequest req, HttpServletResponse res, FilterChain chain) <line2> throws IOException, ServletException { <line3> chain.doFilter(req, res); <line4> } <line5> } <line6> 	<line3>
6048	"public class A { <line0> private <T extends HttpRequestBase> HttpResponse doRequestJson( <line1> Class<T> requestType, <line2> String requestUrl, <line3> String adminUser, <line4> String adminPassword, <line5> JSONObject requestParams) <line6> throws InstantiationException, IllegalAccessException { <line7> AlfrescoHttpClient client = alfrescoHttpClientFactory.getObject(); <line8> T request = requestType.newInstance(); <line9> try { <line10> request.setURI(new URI(requestUrl)); <line11> request.setHeader(""Content-Type"", ""application/json""); <line12> if (requestParams != null && request instanceof HttpEntityEnclosingRequestBase) { <line13> ((HttpEntityEnclosingRequestBase) request) <line14> .setEntity(new StringEntity(requestParams.toString())); <line15> } <line16> HttpResponse httpResponse = client.execute(adminUser, adminPassword, request); <line17> return httpResponse; <line18> } catch (UnsupportedEncodingException | URISyntaxException error1) { <line19> } finally { <line20> if (request != null) { <line21> request.releaseConnection(); <line22> } <line23> client.close(); <line24> } <line25> return null; <line26> } <line27> } <line28> "	<line16>, <line17>, <line19>
6049	"public class A { <line0> public boolean addConfig(String name, YamlParser config) { <line1> if (name.length() <line2> > AUTO_DISCOVERY_PREFIX.length() + AD_MAX_NAME_LEN + AD_MAX_MAG_INSTANCES + 2) { <line3> return false; <line4> } <line5> String patternText = <line6> AUTO_DISCOVERY_PREFIX <line7> + ""(.{1,"" <line8> + AD_MAX_NAME_LEN <line9> + ""})_(\\d{0,"" <line10> + AD_MAX_MAG_INSTANCES <line11> + ""})""; <line12> Pattern pattern = Pattern.compile(patternText); <line13> Matcher matcher = pattern.matcher(name); <line14> if (!matcher.find()) { <line15> return false; <line16> } <line17> String check = matcher.group(1); <line18> if (this.configs.containsKey(check)) { <line19> return false; <line20> } <line21> this.adPipeConfigs.put(name, config); <line22> this.setReinit(true); <line23> return true; <line24> } <line25> } <line26> "	<line3>, <line15>, <line19>
6050	"public class A { <line0> protected List<SafariResumedVisit> getResumedHistory( <line1> Connection connection, Metadata metadata, ParseContext context) throws SQLException { <line2> List<SafariResumedVisit> resumedHistory = new LinkedList<SafariResumedVisit>(); <line3> Statement st = null; <line4> try { <line5> st = connection.createStatement(); <line6> String sql = <line7> ""SELECT history_items.id, title, history_items.url, history_items.visit_count, ((latest +"" <line8> + "" 978307200)*1000) FROM history_items INNER JOIN (SELECT history_item, title,"" <line9> + "" MAX(visit_time) AS latest FROM history_visits GROUP BY history_item) ON"" <line10> + "" history_items.id = history_item ORDER BY history_items.visit_count DESC""; <line11> ResultSet rs = st.executeQuery(sql); <line12> while (rs.next()) { <line13> resumedHistory.add( <line14> new SafariResumedVisit( <line15> rs.getLong(1), rs.getString(2), rs.getString(3), rs.getLong(4), rs.getLong(5))); <line16> } <line17> } finally { <line18> if (st != null) st.close(); <line19> } <line20> return resumedHistory; <line21> } <line22> } <line23> "	<line11>
6051	public class A { <line0> @Override <line1> protected byte[] serializeBytes() { <line2> writeContentType(record); <line3> writeProtocolVersion(record); <line4> if (record.getEpoch() != null) { <line5> appendInt(record.getEpoch().getValue(), RecordByteLength.DTLS_EPOCH); <line6> appendBigInteger( <line7> record.getSequenceNumber().getValue(), RecordByteLength.DTLS_SEQUENCE_NUMBER); <line8> } <line9> writeLength(record); <line10> writeProtocolMessageBytes(record); <line11> return getAlreadySerialized(); <line12> } <line13> } <line14> 	<line2>
6052	public class A { <line0> public void registerSemProviders(InjectingContainer container, SemRegistrar registrar) { <line1> try { <line2> final SemContributor contributor = instantiate(implementation, container); <line3> contributor.registerSemProviders(registrar); <line4> } catch (ClassNotFoundException e) { <line5> } <line6> } <line7> } <line8> 	<line5>
6053	public class A { <line0> @Override <line1> protected void onEvent(org.apache.stratos.messaging.event.Event event) { <line2> MemberGradientOfLoadAverageEvent memberGradientOfLoadAverageEvent = <line3> (MemberGradientOfLoadAverageEvent) event; <line4> String memberId = memberGradientOfLoadAverageEvent.getMemberId(); <line5> Member member = getMemberByMemberId(memberId); <line6> if (null == member) { <line7> if (log.isDebugEnabled()) { <line8> } <line9> return; <line10> } <line11> if (!member.isActive()) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> return; <line15> } <line16> AutoscalerContext asCtx = AutoscalerContext.getInstance(); <line17> ClusterMonitor monitor; <line18> String clusterId = member.getClusterId(); <line19> monitor = asCtx.getClusterMonitor(clusterId); <line20> if (null == monitor) { <line21> if (log.isDebugEnabled()) { <line22> } <line23> return; <line24> } <line25> monitor.handleMemberGradientOfLoadAverageEvent(memberGradientOfLoadAverageEvent); <line26> } <line27> } <line28> 	<line8>, <line13>, <line22>
6054	"public class A { <line0> @Override <line1> public void open() { <line2> AbstractOutputWriter writer = getWriter(); <line3> if (writer != null) { <line4> writer.open(); <line5> } <line6> if (dataPurgeConfig != null) { <line7> purgeFuture = purgeData(); <line8> } else { <line9> purgeFuture = CompletableFuture.completedFuture(null); <line10> } <line11> LinkedList<TokenIndex> vt = new LinkedList<>(); <line12> String[] ft = new String[path.length]; <line13> for (int i = 0; i < ft.length; i++) { <line14> if (path[i].startsWith(""[["") && path[i].endsWith(""]]"")) { <line15> String tok = path[i].substring(2, path[i].length() - 2); <line16> if (tok.equals(""job"")) { <line17> path[i] = config.jobId; <line18> } else if (tok.startsWith(""node"")) { <line19> if (tok.startsWith(""nodes"")) { <line20> path[i] = Integer.toString(config.nodeCount); <line21> } else { <line22> path[i] = Integer.toString(config.node); <line23> } <line24> int cp = tok.indexOf("":""); <line25> if (cp > 0) { <line26> path[i] = padleft(path[i], Integer.parseInt(tok.substring(cp + 1))); <line27> } <line28> } <line29> } <line30> if (path[i].startsWith(""{{"") && path[i].endsWith(""}}"")) { <line31> String tok = path[i].substring(2, path[i].length() - 2); <line32> vt.add(new TokenIndex(getFormat().getField(tok), i)); <line33> } <line34> ft[i] = path[i]; <line35> } <line36> varToken = vt.toArray(new TokenIndex[vt.size()]); <line37> fileToken = ft; <line38> } <line39> } <line40> "	<line2>, <line35>, <line36>
6055	public class A { <line0> @Override <line1> public void commit(long txid) { <line2> validateCommitTxid(txid); <line3> try { <line4> if (!pendingCommit.isEmpty()) { <line5> applyPendingStateToHBase(pendingCommit); <line6> } else { <line7> } <line8> txIds.put(COMMIT_TXID_KEY, String.valueOf(txid).getBytes()); <line9> mutateRow(txidNamespace, columnFamily, txIds); <line10> deleteRow(prepareNamespace); <line11> pendingCommit = EMPTY_PENDING_COMMIT_MAP; <line12> } catch (Exception e) { <line13> throw new RuntimeException(e); <line14> } <line15> } <line16> } <line17> 	<line2>, <line7>
6056	"public class A { <line0> public void addFakeClients( <line1> int numFakeClients, <line2> final int bandwidht, <line3> final MediaPipeline mainPipeline, <line4> final WebRtcEndpoint inputWebRtc, <line5> long timeBetweenClientMs, <line6> final SystemMonitorManager monitor, <line7> final WebRtcConnector connector) { <line8> if (kurentoClient == null) { <line9> throw new KurentoException(""Fake kurentoClient for is not defined.""); <line10> } else { <line11> final MediaPipeline fakePipeline = kurentoClient.createMediaPipeline(); <line12> for (int i = 0; i < numFakeClients; i++) { <line13> new Thread() { <line14> @Override <line15> public void run() { <line16> final WebRtcEndpoint fakeOutputWebRtc = <line17> new WebRtcEndpoint.Builder(mainPipeline).build(); <line18> final WebRtcEndpoint fakeBrowser = new WebRtcEndpoint.Builder(fakePipeline).build(); <line19> if (bandwidht != -1) { <line20> fakeOutputWebRtc.setMaxVideoSendBandwidth(bandwidht); <line21> fakeOutputWebRtc.setMinVideoSendBandwidth(bandwidht); <line22> fakeBrowser.setMaxVideoRecvBandwidth(bandwidht); <line23> } <line24> fakeOutputWebRtc.addIceCandidateFoundListener( <line25> new EventListener<IceCandidateFoundEvent>() { <line26> @Override <line27> public void onEvent(IceCandidateFoundEvent event) { <line28> fakeBrowser.addIceCandidate(event.getCandidate()); <line29> } <line30> }); <line31> fakeBrowser.addIceCandidateFoundListener( <line32> new EventListener<IceCandidateFoundEvent>() { <line33> @Override <line34> public void onEvent(IceCandidateFoundEvent event) { <line35> fakeOutputWebRtc.addIceCandidate(event.getCandidate()); <line36> } <line37> }); <line38> String sdpOffer = fakeBrowser.generateOffer(); <line39> String sdpAnswer = fakeOutputWebRtc.processOffer(sdpOffer); <line40> fakeBrowser.processAnswer(sdpAnswer); <line41> fakeOutputWebRtc.gatherCandidates(); <line42> fakeBrowser.gatherCandidates(); <line43> if (connector == null) { <line44> inputWebRtc.connect(fakeOutputWebRtc); <line45> } else { <line46> connector.connect(inputWebRtc, fakeOutputWebRtc); <line47> } <line48> fakeWebRtcList.add(fakeOutputWebRtc); <line49> fakeBrowserList.add(fakeBrowser); <line50> fakeMediaPipelineList.add(fakePipeline); <line51> } <line52> }.start(); <line53> if (monitor != null) { <line54> monitor.incrementNumClients(); <line55> } <line56> waitMs(timeBetweenClientMs); <line57> } <line58> } <line59> } <line60> } <line61> "	<line11>, <line13>
6057	"public class A { <line0> protected int getBase(final String name) { <line1> Layout layout = null; <line2> String family = getLogoFamily(); <line3> String block = name.split(""\\."")[0]; <line4> Map<?, Layout> memory = LOGO_MEMORY_BLOCK.get(family); <line5> if (isValid(name) && !block.isEmpty() && (memory != null)) { <line6> if (Character.isDigit(block.charAt(1))) { <line7> layout = memory.get(block.substring(0, 1)); <line8> } else if (Character.isDigit(block.charAt(2))) { <line9> layout = memory.get(block.substring(0, 2)); <line10> } else if (Character.isDigit(block.charAt(3))) { <line11> layout = memory.get(block.substring(0, 3)); <line12> } <line13> } <line14> return layout != null ? layout.address : INVALID; <line15> } <line16> } <line17> "	<line3>
6058	public class A { <line0> @Override <line1> public void persistRawDocumentContentFromFile( <line2> HRawDocument rawDocument, File fromFile, String extension) { <line3> String fileName = generateFileNameFor(rawDocument, extension); <line4> rawDocument.setFileId(fileName); <line5> File newFile = getFileForName(fileName); <line6> try { <line7> FileUtils.copyFile(fromFile, newFile); <line8> } catch (IOException e) { <line9> throw new RuntimeException(e); <line10> } <line11> GlobalDocumentId globalId = getGlobalId(rawDocument); <line12> virusScanner.scan(newFile, globalId.toString()); <line13> } <line14> } <line15> 	<line12>
6059	public class A { <line0> public static void flushSession() { <line1> getContextDAO().flushSession(); <line2> } <line3> } <line4> 	<line1>
6060	"public class A { <line0> @Override <line1> public void refresh(Collection<Refreshable> alreadyRefreshed) { <line2> if (alreadyRefreshed == null || !alreadyRefreshed.contains(this)) { <line3> try { <line4> long t1 = System.currentTimeMillis(); <line5> refreshItemIDs(); <line6> refreshUserIDs(); <line7> long t2 = System.currentTimeMillis(); <line8> } catch (IOException e) { <line9> throw new IllegalStateException(""Could not reload DataModel"", e); <line10> } <line11> } <line12> } <line13> } <line14> "	<line4>, <line8>
6061	"public class A { <line0> public void setAsText(String text) throws IllegalArgumentException { <line1> ProgramWorkflowService pws = Context.getProgramWorkflowService(); <line2> if (StringUtils.hasText(text)) { <line3> try { <line4> setValue(pws.getStateByUuid(text)); <line5> } catch (Exception ex) { <line6> ProgramWorkflowState s = pws.getStateByUuid(text); <line7> setValue(s); <line8> if (s == null) { <line9> throw new IllegalArgumentException( <line10> ""Program Workflow State not found: "" + ex.getMessage()); <line11> } <line12> } <line13> } else { <line14> setValue(null); <line15> } <line16> } <line17> } <line18> "	<line9>
6062	"public class A { <line0> @PUT <line1> @Path(""{pathId : .+}/acl"") <line2> @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line3> @StatusCodes({ <line4> @ResponseCode(code = 200, condition = ""Successfully saved file.""), <line5> @ResponseCode( <line6> code = 403, <line7> condition = ""Failed to save acls due to missing or incorrect properties.""), <line8> @ResponseCode(code = 400, condition = ""Failed to save acls due to malformed xml.""), <line9> @ResponseCode(code = 500, condition = ""Failed to save acls due to another error."") <line10> }) <line11> public Response setFileAcls(@PathParam(""pathId"") String pathId, RepositoryFileAclDto acl) { <line12> try { <line13> if (validateUsersAndRoles(acl)) { <line14> fileService.setFileAcls(pathId, acl); <line15> return buildOkResponse(); <line16> } else { <line17> return buildStatusResponse(Response.Status.FORBIDDEN); <line18> } <line19> } catch (Exception exception) { <line20> return buildStatusResponse(Response.Status.INTERNAL_SERVER_ERROR); <line21> } <line22> } <line23> } <line24> "	<line17>, <line20>
6063	public class A { <line0> @Override <line1> public void errorUknown(final AnalysisJob job, final Throwable throwable) { <line2> } <line3> } <line4> 	<line2>
6064	"public class A { <line0> private void index() { <line1> try { <line2> Model dbpedia = ModelFactory.createDefaultModel(); <line3> dbpedia.read( <line4> this.getClass().getClassLoader().getResource(""dbpedia_2015-10.owl"").getPath(), ""RDF/XML""); <line5> StmtIterator stmts = dbpedia.listStatements(null, RDFS.label, (RDFNode) null); <line6> while (stmts.hasNext()) { <line7> final Statement stmt = stmts.next(); <line8> RDFNode label = stmt.getObject(); <line9> if (label.asLiteral().getLanguage().equals(""en"")) { <line10> addDocumentToIndex(stmt.getSubject(), ""rdfs:label"", label.asLiteral().getString()); <line11> NodeIterator comment = dbpedia.listObjectsOfProperty(stmt.getSubject(), RDFS.comment); <line12> while (comment.hasNext()) { <line13> RDFNode next = comment.next(); <line14> if (next.asLiteral().getLanguage().equals(""en"")) { <line15> addDocumentToIndex(stmt.getSubject(), ""rdfs:comment"", next.asLiteral().getString()); <line16> } <line17> } <line18> } <line19> } <line20> iwriter.commit(); <line21> iwriter.close(); <line22> } catch (IOException e) { <line23> } <line24> } <line25> } <line26> "	<line23>
6065	public class A { <line0> public Operation findOperation(String strOp) { <line1> Operations operations = tool.getOperations(); <line2> for (Operation op : operations.getOperation()) { <line3> if (op.getName().equals(strOp)) { <line4> return op; <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	<line1>, <line3>
6066	"public class A { <line0> @Override <line1> @UnitOfWork(readOnly = true) <line2> @SuppressWarnings(""JdkObsolete"") <line3> public LookBackAnswer getLookBackAnswer( <line4> ExplanationOfBenefit explanationOfBenefit, <line5> String organizationNPI, <line6> String practitionerNPI, <line7> long withinMonth) { <line8> MDC.put(EOB_ID, explanationOfBenefit.getId()); <line9> YearMonth billingPeriod = <line10> Optional.of(explanationOfBenefit) <line11> .map(ExplanationOfBenefit::getBillablePeriod) <line12> .map(Period::getEnd) <line13> .map( <line14> date -> <line15> YearMonth.from(date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate())) <line16> .orElse(null); <line17> String eobOrganizationNPI = <line18> Optional.of(explanationOfBenefit) <line19> .map(ExplanationOfBenefit::getOrganization) <line20> .map(Reference::getIdentifier) <line21> .filter(i -> DPCIdentifierSystem.NPPES.getSystem().equals(i.getSystem())) <line22> .map(Identifier::getValue) <line23> .orElse(null); <line24> Pair<String, Set<String>> npis = extractProviderNPIs(explanationOfBenefit); <line25> Set<String> allNPIs = new HashSet<>(npis.getRight()); <line26> allNPIs.add(npis.getLeft()); <line27> LookBackAnswer lookBackAnswer = <line28> new LookBackAnswer( <line29> practitionerNPI, organizationNPI, withinMonth, operationsConfig.getLookBackDate()) <line30> .addEobBillingPeriod(billingPeriod) <line31> .addEobOrganization(eobOrganizationNPI) <line32> .addEobProviders(allNPIs); <line33> MDC.remove(EOB_ID); <line34> return lookBackAnswer; <line35> } <line36> } <line37> "	<line33>
6067	"public class A { <line0> @Override <line1> public Boolean call() { <line2> if (isActive.compareAndSet(false, true)) { <line3> if (log.isDebugEnabled()) { <line4> } <line5> while (isActive.get()) { <line6> TaskHolder taskHolder = null; <line7> long delay = 0; <line8> try { <line9> taskHolder = taskHolderQueue.take(); <line10> Task.TaskHint hint = taskHolder.executeTask(); <line11> if (hint == Task.TaskHint.IDLE) { <line12> delay = idleWaitTimeMillis; <line13> } <line14> } catch (InterruptedException e) { <line15> Thread.currentThread().interrupt(); <line16> if (isActive.get()) { <line17> taskExceptionHandler.handleException(e, ""null""); <line18> } <line19> } catch (Throwable throwable) { <line20> String id; <line21> if (null != taskHolder) { <line22> id = taskHolder.getId(); <line23> } else { <line24> id = ""null""; <line25> } <line26> taskExceptionHandler.handleException(throwable, id); <line27> } finally { <line28> if (null != taskHolder) { <line29> if (taskHolder.isDisabled()) { <line30> taskHolder.onRemoveTask(); <line31> } else { <line32> taskHolder.setDelay(delay, TimeUnit.MILLISECONDS); <line33> taskHolderQueue.put(taskHolder); <line34> } <line35> } <line36> } <line37> } <line38> } else { <line39> throw new IllegalStateException(""Task processor is already running""); <line40> } <line41> return true; <line42> } <line43> } <line44> "	<line4>, <line38>, <line39>
6068	public class A { <line0> private void createTable(TableName tableName) throws Exception { <line1> long startTime, endTime; <line2> TableDescriptorBuilder builder = TableDescriptorBuilder.newBuilder(tableName); <line3> TableDescriptor desc = builder.build(); <line4> ColumnFamilyDescriptorBuilder cbuilder = <line5> ColumnFamilyDescriptorBuilder.newBuilder(COLUMN_NAME.getBytes(Charset.defaultCharset())); <line6> ColumnFamilyDescriptor[] columns = new ColumnFamilyDescriptor[] {cbuilder.build()}; <line7> startTime = System.currentTimeMillis(); <line8> HBaseTestingUtility.createPreSplitLoadTestTable( <line9> util.getConfiguration(), desc, columns, regionsCountPerServer); <line10> util.waitTableAvailable(tableName); <line11> endTime = System.currentTimeMillis(); <line12> } <line13> } <line14> 	<line7>, <line12>
6069	public class A { <line0> public Node parse(InputSource source) throws IOException, SAXException { <line1> try (AutoLock l = _lock.lock()) { <line2> _dtd = null; <line3> Handler handler = new Handler(); <line4> XMLReader reader = _parser.getXMLReader(); <line5> reader.setContentHandler(handler); <line6> reader.setErrorHandler(handler); <line7> reader.setEntityResolver(handler); <line8> if (LOG.isDebugEnabled()) <line9> _parser.parse(source, handler); <line10> if (handler._error != null) throw handler._error; <line11> Node doc = (Node) handler._top.get(0); <line12> handler.clear(); <line13> return doc; <line14> } <line15> } <line16> } <line17> 	<line9>
6070	"public class A { <line0> public void run() { <line1> workerState = STATE_STARTED; <line2> activeTaskCount++; <line3> int messageCount = 0; <line4> if (log.isDebugEnabled()) { <line5> } <line6> try { <line7> while (isActive() <line8> && (getMaxMessagesPerTask() < 0 || messageCount < getMaxMessagesPerTask()) <line9> && (getConcurrentConsumers() == 1 || idleExecutionCount < getIdleTaskExecutionLimit())) { <line10> UserTransaction ut = null; <line11> try { <line12> if (transactionality == BaseConstants.TRANSACTION_JTA) { <line13> ut = getUserTransaction(); <line14> if (ut.getStatus() == Status.STATUS_NO_TRANSACTION) { <line15> ut.begin(); <line16> } <line17> } <line18> } catch (NotSupportedException e) { <line19> handleException(""Listener Task is already associated with a transaction"", e); <line20> } catch (SystemException e) { <line21> handleException(""Error starting a JTA transaction"", e); <line22> } <line23> Message message = receiveMessage(); <line24> if (log.isTraceEnabled()) { <line25> if (message != null) { <line26> try { <line27> } catch (JMSException ignore) { <line28> } <line29> } else { <line30> } <line31> } <line32> if (message != null) { <line33> idle = false; <line34> idleExecutionCount = 0; <line35> messageCount++; <line36> scheduleNewTaskIfAppropriate(); <line37> handleMessage(message, ut); <line38> } else { <line39> idle = true; <line40> idleExecutionCount++; <line41> } <line42> } <line43> } finally { <line44> if (log.isTraceEnabled()) { <line45> } else if (log.isDebugEnabled()) { <line46> } <line47> closeConsumer(true); <line48> closeSession(true); <line49> closeConnection(); <line50> workerState = STATE_STOPPED; <line51> activeTaskCount--; <line52> synchronized (pollingTasks) { <line53> pollingTasks.remove(this); <line54> } <line55> if (!isOnExceptionError) { <line56> scheduleNewTaskIfAppropriate(); <line57> } <line58> } <line59> } <line60> } <line61> "	<line5>, <line27>, <line30>, <line45>, <line46>
6071	"public class A { <line0> private void transformGefaehrdung( <line1> Group<?> group, List<CnATreeElement> elements, Gefaehrdung gefaehrdung) { <line2> BpThreat bpThreat = new BpThreat(group); <line3> bpThreat.setTitel(gefaehrdung.getId() + "" "" + gefaehrdung.getTitel()); <line4> try { <line5> String description = HtmlWriter.getHtml(gefaehrdung); <line6> bpThreat.setObjectBrowserDescription(description); <line7> } catch (GSServiceException e) { <line8> } <line9> elements.add(bpThreat); <line10> } <line11> } <line12> "	<line8>
6072	"public class A { <line0> @Override <line1> public String retrieveRootNodeID(String ownerID) throws MCRPersistenceException { <line2> EntityManager em = MCREntityManagerProvider.getCurrentEntityManager(); <line3> TypedQuery<String> rootQuery = em.createNamedQuery(""MCRFSNODES.getRootID"", String.class); <line4> rootQuery.setParameter(""owner"", ownerID); <line5> try { <line6> return rootQuery.getSingleResult(); <line7> } catch (NoResultException e) { <line8> return null; <line9> } <line10> } <line11> } <line12> "	<line8>
6073	"public class A { <line0> @SuppressWarnings({""unchecked"", ""null""}) <line1> public static String getFirstMemberName(Object group) { <line2> List<String> listNames = YAMLgroupsOptimizerParser.getListOfMemberNames(group); <line3> if (listNames != null) { <line4> return listNames.get(0); <line5> } else { <line6> return null; <line7> } <line8> } <line9> } <line10> "	<line6>
6074	"public class A { <line0> public Store connect() { <line1> Properties props = System.getProperties(); <line2> props.setProperty(""mail.store.protocol"", ""imaps""); <line3> Session session = Session.getDefaultInstance(props, null); <line4> Store store = null; <line5> try { <line6> store = session.getStore(""imaps""); <line7> } catch (NoSuchProviderException e) { <line8> e.printStackTrace(); <line9> } <line10> try { <line11> store.connect(getEmailServer(), getUsername(), getPassword()); <line12> } catch (MessagingException e) { <line13> e.printStackTrace(); <line14> return null; <line15> } <line16> return store; <line17> } <line18> } <line19> "	<line8>, <line13>
6075	public class A { <line0> private void dispatchMessage(final Message msg) { <line1> currentMessage = msg; <line2> incomingMessages.mark(); <line3> if (LOG.isTraceEnabled()) { <line4> } <line5> try (final Timer.Context ignored = processTime.time()) { <line6> handleMessage(msg); <line7> if (LOG.isTraceEnabled()) { <line8> } <line9> } catch (Exception e) { <line10> if (LOG.isDebugEnabled()) { <line11> } else { <line12> } <line13> } finally { <line14> currentMessage = null; <line15> outgoingMessages.mark(); <line16> } <line17> } <line18> } <line19> 	<line4>, <line8>, <line11>, <line12>
6076	"public class A { <line0> protected void logProblem(String type, Object val) { <line1> if (lastWasProblem && currentProblemLoggedAsWarning) { <line2> if (log.isTraceEnabled()) <line3> } else { <line4> long nowTime = System.currentTimeMillis(); <line5> Long currentProblemStartTimeCache = currentProblemStartTime; <line6> long expiryTime = <line7> (lastSuccessTime != null && !isTransitioningOrStopped()) <line8> ? lastSuccessTime + config.getLogWarningGraceTime().toMilliseconds() <line9> : (currentProblemStartTimeCache != null) <line10> ? currentProblemStartTimeCache <line11> + config.getLogWarningGraceTimeOnStartup().toMilliseconds() <line12> : nowTime + config.getLogWarningGraceTimeOnStartup().toMilliseconds(); <line13> if (!lastWasProblem) { <line14> if (expiryTime <= nowTime) { <line15> currentProblemLoggedAsWarning = true; <line16> if (entity == null || !Entities.isNoLongerManaged(entity)) { <line17> } else { <line18> } <line19> if (log.isDebugEnabled() && val instanceof Throwable) <line20> log.debug( <line21> ""Trace for "" + type + "" reading "" + getBriefDescription() + "": "" + val, <line22> (Throwable) val); <line23> } else { <line24> if (log.isDebugEnabled()) <line25> } <line26> lastWasProblem = true; <line27> currentProblemStartTime = nowTime; <line28> } else { <line29> if (expiryTime <= nowTime) { <line30> currentProblemLoggedAsWarning = true; <line31> if (log.isDebugEnabled() && val instanceof Throwable) <line32> } else { <line33> if (log.isDebugEnabled()) <line34> } <line35> } <line36> } <line37> } <line38> } <line39> "	<line3>, <line17>, <line18>, <line25>, <line31>, <line32>, <line34>
6077	"public class A { <line0> @Test <line1> public void testAckBatchSize() throws Exception { <line2> ActiveMQServer server = createServer(false); <line3> server.start(); <line4> int numMessages = 100; <line5> int originalSize = getMessageEncodeSize(addressA); <line6> ServerLocator locator = <line7> createInVMNonHALocator() <line8> .setAckBatchSize(numMessages * originalSize) <line9> .setBlockOnAcknowledge(true); <line10> ClientSessionFactory cf = createSessionFactory(locator); <line11> ClientSession sendSession = cf.createSession(false, true, true); <line12> ClientSession session = cf.createSession(false, true, true); <line13> session.createQueue(new QueueConfiguration(queueA).setAddress(addressA).setDurable(false)); <line14> ClientProducer cp = sendSession.createProducer(addressA); <line15> for (int i = 0; i < numMessages; i++) { <line16> ClientMessage message = (ClientMessage) sendSession.createMessage(false).setAddress(addressA); <line17> Assert.assertEquals(originalSize, message.getEncodeSize()); <line18> cp.send(message); <line19> Assert.assertEquals(originalSize, message.getEncodeSize()); <line20> } <line21> ClientConsumer consumer = session.createConsumer(queueA); <line22> session.start(); <line23> for (int i = 0; i < numMessages - 1; i++) { <line24> ClientMessage m = consumer.receive(5000); <line25> Assert.assertEquals(0, m.getPropertyNames().size()); <line26> Assert.assertEquals(""expected to be "" + originalSize, originalSize, m.getEncodeSize()); <line27> m.acknowledge(); <line28> } <line29> ClientMessage m = consumer.receive(5000); <line30> Queue q = (Queue) server.getPostOffice().getBinding(queueA).getBindable(); <line31> Assert.assertEquals(numMessages, q.getDeliveringCount()); <line32> m.acknowledge(); <line33> Assert.assertEquals(0, q.getDeliveringCount()); <line34> sendSession.close(); <line35> session.close(); <line36> } <line37> } <line38> "	<line24>
6078	"public class A { <line0> private <T> ServiceBag<?> _getServiceBag(ServiceWrapper<T> serviceWrapper) <line1> throws NoSuchMethodException { <line2> Class<?> clazz = serviceWrapper.getClass(); <line3> Method method = clazz.getMethod(""getWrappedService"", new Class<?>[0]); <line4> Class<?> serviceTypeClass = method.getReturnType(); <line5> Object service = null; <line6> ServiceReference<?> serviceReference = null; <line7> Registry registry = RegistryUtil.getRegistry(); <line8> try { <line9> service = PortalBeanLocatorUtil.locate(serviceTypeClass.getName()); <line10> } catch (BeanLocatorException beanLocatorException) { <line11> if (_log.isDebugEnabled()) { <line12> } <line13> serviceReference = registry.getServiceReference(serviceTypeClass); <line14> service = registry.getService(serviceReference); <line15> } <line16> Object serviceProxy = service; <line17> if (!ProxyUtil.isProxyClass(serviceProxy.getClass())) { <line18> if (serviceReference != null) { <line19> registry.ungetService(serviceReference); <line20> } <line21> return null; <line22> } <line23> ClassLoader classLoader = clazz.getClassLoader(); <line24> try { <line25> AopInvocationHandler aopInvocationHandler = <line26> ProxyUtil.fetchInvocationHandler(serviceProxy, AopInvocationHandler.class); <line27> serviceWrapper.setWrappedService((T) aopInvocationHandler.getTarget()); <line28> return new ServiceBag<>(classLoader, aopInvocationHandler, serviceTypeClass, serviceWrapper); <line29> } finally { <line30> if (serviceReference != null) { <line31> registry.ungetService(serviceReference); <line32> } <line33> } <line34> } <line35> } <line36> "	<line12>, <line18>
6079	public class A { <line0> private synchronized void countBytesSynchronized(final DataUtil.IteratorWithNumBytes iterator) { <line1> try { <line2> serBytes += iterator.getNumSerializedBytes(); <line3> } catch (final DataUtil.IteratorWithNumBytes.NumBytesNotSupportedException e) { <line4> serBytes = -1; <line5> } catch (final IllegalStateException e) { <line6> } <line7> try { <line8> encodedBytes += iterator.getNumEncodedBytes(); <line9> } catch (final DataUtil.IteratorWithNumBytes.NumBytesNotSupportedException e) { <line10> encodedBytes = -1; <line11> } catch (final IllegalStateException e) { <line12> } <line13> } <line14> } <line15> 	<line6>, <line12>
6080	"public class A { <line0> private void unlock(int dsId, int entityHashValue, byte lockMode, long jobSlot) <line1> throws ACIDException { <line2> log(""unlock"", dsId, entityHashValue, lockMode, null); <line3> stats.unlock(); <line4> ResourceGroup group = table.get(dsId, entityHashValue); <line5> group.getLatch(); <line6> try { <line7> long resource = findResourceInGroup(group, dsId, entityHashValue); <line8> if (resource < 0) { <line9> throw new IllegalStateException( <line10> ""resource ("" + dsId + "",  "" + entityHashValue + "") not found""); <line11> } <line12> if (CHECK_CONSISTENCY) { <line13> assertLocksCanBefoundInJobQueue(); <line14> } <line15> long holder = removeLastHolder(resource, jobSlot, lockMode); <line16> if (DEBUG_MODE) { <line17> } <line18> reqArenaMgr.deallocate(holder); <line19> if (resourceNotUsed(resource)) { <line20> long prev = group.firstResourceIndex; <line21> if (prev == resource) { <line22> group.firstResourceIndex = resArenaMgr.getNext(resource); <line23> } else { <line24> while (resArenaMgr.getNext(prev) != resource) { <line25> prev = resArenaMgr.getNext(prev); <line26> } <line27> resArenaMgr.setNext(prev, resArenaMgr.getNext(resource)); <line28> } <line29> if (DEBUG_MODE) { <line30> } <line31> resArenaMgr.deallocate(resource); <line32> } else { <line33> final int oldMaxMode = resArenaMgr.getMaxMode(resource); <line34> final int newMaxMode = determineNewMaxMode(resource, oldMaxMode); <line35> resArenaMgr.setMaxMode(resource, newMaxMode); <line36> group.wakeUp(); <line37> } <line38> } finally { <line39> group.releaseLatch(); <line40> } <line41> } <line42> } <line43> "	<line17>, <line30>
6081	public class A { <line0> @Test <line1> public void logTest() { <line2> Log log = LogFactory.get(); <line3> } <line4> } <line5> 	<line3>
6082	public class A { <line0> private int makeGetRequestHttp2(String url) throws Exception { <line1> HTTP2Client http2Client = new HTTP2Client(); <line2> HttpClient httpClient = new HttpClient(new HttpClientTransportOverHTTP2(http2Client)); <line3> httpClient.start(); <line4> int statusCode = httpClient.GET(url).getStatus(); <line5> httpClient.stop(); <line6> return statusCode; <line7> } <line8> } <line9> 	<line1>
6083	"public class A { <line0> private Set<String> getPasswordHashAlgorithms() { <line1> Set<String> hashAlgos = new HashSet<>(); <line2> boolean enmasseRealmsFound = false; <line3> KeycloakSession keycloakSession = keycloakSessionFactory.create(); <line4> KeycloakTransactionManager transactionManager = keycloakSession.getTransactionManager(); <line5> transactionManager.begin(); <line6> try { <line7> List<RealmModel> realms = keycloakSession.realms().getRealms(); <line8> for (RealmModel realm : realms) { <line9> if (realm.getAttribute(""enmasse-realm"", Boolean.FALSE)) { <line10> enmasseRealmsFound = true; <line11> hashAlgos.add(realm.getPasswordPolicy().getHashAlgorithm()); <line12> } <line13> } <line14> } finally { <line15> transactionManager.commit(); <line16> keycloakSession.close(); <line17> } <line18> if (!enmasseRealmsFound) { <line19> } <line20> return hashAlgos; <line21> } <line22> } <line23> "	<line19>
6084	public class A { <line0> @Override <line1> public void doRun() { <line2> final DateTime now = Tools.nowUTC(); <line3> final int secondOfMinute = now.getSecondOfMinute(); <line4> if (secondOfMinute == 0) { <line5> final long currentInputBytes = inputCounter.getCount(); <line6> final long currentOutputBytes = outputCounter.getCount(); <line7> final long currentDecodedBytes = decodedCounter.getCount(); <line8> final long inputLastMinute = currentInputBytes - previousInputBytes; <line9> previousInputBytes = currentInputBytes; <line10> final long outputBytesLastMinute = currentOutputBytes - previousOutputBytes; <line11> previousOutputBytes = currentOutputBytes; <line12> final long decodedBytesLastMinute = currentDecodedBytes - previousDecodedBytes; <line13> previousDecodedBytes = currentDecodedBytes; <line14> if (LOG.isDebugEnabled()) { <line15> final Size in = Size.bytes(inputLastMinute); <line16> final Size out = Size.bytes(outputBytesLastMinute); <line17> final Size decoded = Size.bytes(decodedBytesLastMinute); <line18> } <line19> final DateTime previousMinute = now.minusMinutes(1); <line20> trafficService.updateTraffic( <line21> previousMinute, nodeId, inputLastMinute, outputBytesLastMinute, decodedBytesLastMinute); <line22> } <line23> } <line24> } <line25> 	<line5>, <line18>
6085	"public class A { <line0> public Properties createPropertySource(String name, String datasourceName) { <line1> JdbcFacade ibisProp = <line2> (JdbcFacade) <line3> applicationContext <line4> .getAutowireCapableBeanFactory() <line5> .autowire(JdbcFacade.class, AutowireCapableBeanFactory.AUTOWIRE_BY_NAME, false); <line6> ibisProp.setDatasourceName(datasourceName); <line7> ibisProp.setName(""retrieveJdbcPropertiesFromDatabase""); <line8> try { <line9> ibisProp.configure(); <line10> } catch (ConfigurationException e) { <line11> } <line12> try (Connection conn = ibisProp.getConnection()) { <line13> if (ibisProp.getDbmsSupport().isTablePresent(conn, ""IBISPROP"")) { <line14> Properties properties = executePropertiesQuery(conn); <line15> if (properties.size() > 0) { <line16> return properties; <line17> } else { <line18> } <line19> } else { <line20> } <line21> } catch (SQLException e) { <line22> } catch (Exception e) { <line23> } <line24> return null; <line25> } <line26> } <line27> "	<line6>, <line11>, <line16>, <line18>, <line20>, <line22>, <line23>
6086	"public class A { <line0> public void restore(RequestContext context, String contextKey, String protocol) { <line1> if (contextKey != null) { <line2> @SuppressWarnings(""unchecked"") <line3> Map<String, Object> signinParams = <line4> (Map<String, Object>) WebUtils.getAttributeFromExternalContext(context, contextKey); <line5> if (signinParams != null) { <line6> String value = (String) signinParams.get(IdpConstants.HOME_REALM); <line7> if (value != null) { <line8> WebUtils.putAttributeInFlowScope(context, IdpConstants.HOME_REALM, value); <line9> } <line10> value = (String) signinParams.get(IdpConstants.REALM); <line11> if (value != null) { <line12> WebUtils.putAttributeInFlowScope(context, IdpConstants.REALM, value); <line13> } <line14> value = (String) signinParams.get(IdpConstants.RETURN_ADDRESS); <line15> if (value != null) { <line16> WebUtils.putAttributeInFlowScope(context, IdpConstants.RETURN_ADDRESS, value); <line17> } <line18> value = (String) signinParams.get(IdpConstants.CONTEXT); <line19> if (value != null) { <line20> WebUtils.putAttributeInFlowScope(context, IdpConstants.CONTEXT, value); <line21> } <line22> if (""wsfed"".equals(protocol)) { <line23> WebUtils.removeAttributeFromFlowScope(context, FederationConstants.PARAM_CONTEXT); <line24> } else if (""samlsso"".equals(protocol)) { <line25> SAMLAuthnRequest authnRequest = <line26> (SAMLAuthnRequest) signinParams.get(IdpConstants.SAML_AUTHN_REQUEST); <line27> if (authnRequest != null) { <line28> WebUtils.putAttributeInFlowScope( <line29> context, IdpConstants.SAML_AUTHN_REQUEST, authnRequest); <line30> } <line31> } <line32> } else { <line33> } <line34> WebUtils.removeAttributeFromFlowScope(context, contextKey); <line35> } else { <line36> } <line37> } <line38> } <line39> "	<line6>, <line24>, <line33>, <line36>
6087	public class A { <line0> @Override <line1> public void deserialize(PacketBuffer buffer, int protocolID) { <line2> this.requestId = buffer.readSignedVarInt(); <line3> if (this.requestId != 0) { <line4> int length = buffer.readUnsignedVarInt(); <line5> this.changeSlot = new ChangeSlot[length]; <line6> for (int i = 0; i < length; i++) { <line7> this.changeSlot[i] = new ChangeSlot(); <line8> this.changeSlot[i].deserialize(buffer); <line9> } <line10> } <line11> this.type = buffer.readUnsignedVarInt(); <line12> this.hasItemstackIDs = buffer.readBoolean(); <line13> int actionCount = buffer.readUnsignedVarInt(); <line14> this.actions = new NetworkTransaction[actionCount]; <line15> for (int i = 0; i < actionCount; i++) { <line16> NetworkTransaction networkTransaction = new NetworkTransaction(); <line17> networkTransaction.deserialize(buffer, this.hasItemstackIDs); <line18> this.actions[i] = networkTransaction; <line19> } <line20> switch (this.type) { <line21> case TYPE_NORMAL: <line22> case TYPE_MISMATCH: <line23> break; <line24> case TYPE_USE_ITEM: <line25> this.actionType = buffer.readUnsignedVarInt(); <line26> this.blockPosition = readBlockPosition(buffer); <line27> this.face = readBlockFace(buffer); <line28> this.hotbarSlot = buffer.readSignedVarInt(); <line29> this.itemInHand = readItemStack(buffer); <line30> this.playerPosition = <line31> new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line32> this.clickPosition = <line33> new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line34> this.blockRuntimeID = buffer.readUnsignedVarInt(); <line35> break; <line36> case TYPE_USE_ITEM_ON_ENTITY: <line37> this.entityId = buffer.readUnsignedVarLong(); <line38> this.actionType = buffer.readUnsignedVarInt(); <line39> this.hotbarSlot = buffer.readSignedVarInt(); <line40> this.itemInHand = readItemStack(buffer); <line41> this.vector1 = new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line42> this.vector2 = new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line43> break; <line44> case TYPE_RELEASE_ITEM: <line45> this.actionType = buffer.readUnsignedVarInt(); <line46> this.hotbarSlot = buffer.readSignedVarInt(); <line47> this.itemInHand = readItemStack(buffer); <line48> this.playerPosition = <line49> new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line50> break; <line51> default: <line52> } <line53> } <line54> } <line55> 	<line52>
6088	public class A { <line0> private void loadProjectModels(final Mode mode, final String preselectedModelName) { <line1> final GetProjectModels command; <line2> if (mode == Mode.TEST_PROJECT) { <line3> command = <line4> new GetProjectModels(ProjectModelDTO.Mode.WITH_VISIBILITIES, ProjectModelStatus.DRAFT); <line5> } else { <line6> command = new GetProjectModels(ProjectModelDTO.Mode.WITH_VISIBILITIES); <line7> } <line8> dispatch.execute( <line9> command, <line10> new CommandResultHandler<ListResult<ProjectModelDTO>>() { <line11> @Override <line12> public void onCommandFailure(final Throwable e) { <line13> if (Log.isErrorEnabled()) { <line14> } <line15> hideView(); <line16> } <line17>  <line18> @Override <line19> public void onCommandSuccess(final ListResult<ProjectModelDTO> result) { <line20> if (result.isEmpty()) { <line21> hideView(); <line22> return; <line23> } <line24> view.getModelsField().getStore().add(result.getList()); <line25> view.getModelsField().getStore().commitChanges(); <line26> if (preselectedModelName != null) { <line27> for (final ProjectModelDTO projectModel : result.getList()) { <line28> if (preselectedModelName.equals(projectModel.getName())) { <line29> view.getModelsField().setValue(projectModel); <line30> } <line31> } <line32> } <line33> } <line34> }, <line35> view.getCreateButton()); <line36> } <line37> } <line38> 	<line14>, <line15>, <line21>
6089	"public class A { <line0> public JasperReportResultDto getGenericReportWardVisitPdf( <line1> String wardID, Date date, String jasperFileName) throws OHServiceException { <line2> try { <line3> HashMap<String, Object> parameters = getHospitalParameters(); <line4> addBundleParameter(jasperFileName, parameters); <line5> parameters.put(""wardID"", String.valueOf(wardID)); <line6> parameters.put(""date"", date); <line7> String pdfFilename = <line8> ""rpt/PDF/"" <line9> + jasperFileName <line10> + ""_"" <line11> + String.valueOf(wardID) <line12> + ""_"" <line13> + TimeTools.formatDateTime(date, ""yyyyMMdd"") <line14> + "".pdf""; <line15> JasperReportResultDto result = <line16> generateJasperReport(compileJasperFilename(jasperFileName), pdfFilename, parameters); <line17> JasperExportManager.exportReportToPdfFile(result.getJasperPrint(), pdfFilename); <line18> return result; <line19> } catch (OHServiceException e) { <line20> throw e; <line21> } catch (Exception e) { <line22> throw new OHServiceException( <line23> e, <line24> new OHExceptionMessage( <line25> MessageBundle.getMessage(""angal.common.error.title""), <line26> MessageBundle.getMessage(""angal.stat.reporterror""), <line27> OHSeverityLevel.ERROR)); <line28> } <line29> } <line30> } <line31> "	<line22>
6090	"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> @Test <line2> public void testMD5ChkSum() throws Exception { <line3> AmazonS3 s3Client = S3Utilities.createS3Client(new ExtractionOptions(""foo"")); <line4> Bucket bucket = null; <line5> try { <line6> bucket = DataSetTestUtilities.createTestBucket(s3Client); <line7> ExtractionOptions options = new ExtractionOptions(bucket.getName()); <line8> DataSetManifest manifest = <line9> new DataSetManifest( <line10> Instant.now(), <line11> 0, <line12> new DataSetManifestEntry(""beneficiaries.rif"", RifFileType.BENEFICIARY)); <line13> s3Client.putObject(DataSetTestUtilities.createPutRequest(bucket, manifest)); <line14> s3Client.putObject( <line15> DataSetTestUtilities.createPutRequest( <line16> bucket, <line17> manifest, <line18> manifest.getEntries().get(0), <line19> StaticRifResource.SAMPLE_A_BENES.getResourceUrl())); <line20> GetObjectRequest objectRequest = <line21> new GetObjectRequest( <line22> bucket.getName(), <line23> String.format( <line24> ""%s/%s/%s"", <line25> CcwRifLoadJob.S3_PREFIX_PENDING_DATA_SETS, <line26> manifest.getEntries().get(0).getParentManifest().getTimestampText(), <line27> manifest.getEntries().get(0).getName())); <line28> Path localTempFile = Files.createTempFile(""data-pipeline-s3-temp"", "".rif""); <line29> s3TaskManager = <line30> new S3TaskManager(new MetricRegistry(), new ExtractionOptions(options.getS3BucketName())); <line31> Download downloadHandle = <line32> s3TaskManager.getS3TransferManager().download(objectRequest, localTempFile.toFile()); <line33> downloadHandle.waitForCompletion(); <line34> InputStream downloadedInputStream = new FileInputStream(localTempFile.toString()); <line35> String generatedMD5ChkSum = ManifestEntryDownloadTask.computeMD5ChkSum(downloadedInputStream); <line36> String downloadedFileMD5ChkSum = <line37> downloadHandle.getObjectMetadata().getUserMetaDataOf(""md5chksum""); <line38> Assert.assertEquals( <line39> ""Checksum doesn't match on downloaded file "" + objectRequest.getKey(), <line40> downloadedFileMD5ChkSum, <line41> generatedMD5ChkSum); <line42> } catch (IOException e) { <line43> throw new UncheckedIOException(e); <line44> } catch (AmazonClientException e) { <line45> throw new AwsFailureException(e); <line46> } catch (InterruptedException e) { <line47> throw new BadCodeMonkeyException(e); <line48> } finally { <line49> if (bucket != null) DataSetTestUtilities.deleteObjectsAndBucket(s3Client, bucket); <line50> } <line51> } <line52> } <line53> "	<line8>, <line31>, <line36>, <line38>, <line42>
6091	public class A { <line0> public static void handle(Throwable t) throws GwtKuraException { <line1> t.printStackTrace(); <line2> throw GwtKuraException.internalError(t, t.getLocalizedMessage()); <line3> } <line4> } <line5> 	<line2>
6092	"public class A { <line0> private File getFileCopyThumbnail(Document srcDocument, Account owner, ThumbnailType kind) { <line1> FileMetaDataKind fileMetaDataKind = ThumbnailType.toFileMetaDataKind(kind); <line2> try (InputStream inputStream = <line3> getThumbnailByteSource(srcDocument, kind, fileMetaDataKind).openBufferedStream()) { <line4> if (inputStream != null) { <line5> File tempThumbFile = null; <line6> tempThumbFile = File.createTempFile(""linthumbnail"", owner + ""_thumb.png""); <line7> tempThumbFile.createNewFile(); <line8> try (FileOutputStream fos = new FileOutputStream(tempThumbFile)) { <line9> IOUtils.copyAndCloseInput(inputStream, fos); <line10> return tempThumbFile; <line11> } <line12> } <line13> } catch (IOException e1) { <line14> throw new TechnicalException( <line15> TechnicalErrorCode.COULD_NOT_INSERT_DOCUMENT, <line16> ""Can not store file when creating document entry.""); <line17> } <line18> return null; <line19> } <line20> } <line21> "	<line14>
6093	public class A { <line0> @Override <line1> public ServiceAdapter makeServiceAdapter(String adapterName) throws Exception { <line2> try { <line3> if (supportedAdapters.containsKey(adapterName) || isHiddenServiceAdapter(adapterName)) { <line4> ServiceAdapter adapter = <line5> (ServiceAdapter) this.loadedAdapters.get(adapterName).newInstance(); <line6> adapter.initFromMetaData(this.getServiceMetadata(adapterName, adapter.getIdentifier())); <line7> return adapter; <line8> } else { <line9> return null; <line10> } <line11> } catch (NullPointerException ex) { <line12> return null; <line13> } <line14> } <line15> } <line16> 	<line12>
6094	public class A { <line0> private void writeTestFile(File file) { <line1> File parent = file.getAbsoluteFile().getParentFile(); <line2> if (!parent.exists()) { <line3> if (!parent.mkdirs()) { <line4> } <line5> } <line6> try (FileOutputStream fos = new FileOutputStream(file); <line7> OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8.name())) { <line8> osw.append(sb); <line9> } catch (FileNotFoundException e) { <line10> } catch (UnsupportedEncodingException e) { <line11> } catch (IOException e) { <line12> } <line13> } <line14> } <line15> 	<line4>, <line10>, <line11>, <line12>
6095	"public class A { <line0> @Override <line1> public void refresh(final List<String> inContents, final List<HashTag> inHashTags) { <line2> List<String> contents = new ArrayList<String>(); <line3> for (String content : inContents) { <line4> if (!content.startsWith(""#"")) { <line5> content = ""#"" + content.toLowerCase(); <line6> } else { <line7> content = content.toLowerCase(); <line8> } <line9> contents.add(content); <line10> } <line11> List<HashTag> foundHashTags = <line12> getEntityManager() <line13> .createQuery(""FROM HashTag WHERE content IN (:contents)"") <line14> .setParameter(""contents"", contents) <line15> .getResultList(); <line16> inHashTags.clear(); <line17> inHashTags.addAll(foundHashTags); <line18> for (String content : inContents) { <line19> if (isHashTagInCollection(content, foundHashTags)) { <line20> if (log.isTraceEnabled()) { <line21> } <line22> continue; <line23> } <line24> if (log.isTraceEnabled()) { <line25> } <line26> HashTag ht = new HashTag(content); <line27> getEntityManager().persist(ht); <line28> inHashTags.add(ht); <line29> } <line30> } <line31> } <line32> "	<line21>, <line25>
6096	public class A { <line0> public void createSubscription( <line1> String subscriptionProject, String subscription, String topicProject, String topic) <line2> throws IOException { <line3> ProjectSubscriptionName subscriptionName = <line4> ProjectSubscriptionName.newBuilder() <line5> .setProject(subscriptionProject) <line6> .setSubscription(subscription) <line7> .build(); <line8> deleteSubscription(subscriptionName); <line9> TopicName topicName = TopicName.of(topicProject, topic); <line10> PushConfig pushConfig = PushConfig.getDefaultInstance(); <line11> getSubscriptionAdminClient() <line12> .createSubscription(subscriptionName, topicName, pushConfig, 1) <line13> .isInitialized(); <line14> } <line15> } <line16> 	<line11>
6097	public class A { <line0> public void onStopTrackingTouch(SeekBar bar) { <line1> mDragging = false; <line2> setProgress(); <line3> updatePausePlay(); <line4> show(); <line5> mHandler.sendEmptyMessage(SHOW_PROGRESS); <line6> try { <line7> if (mPlayer != null) { <line8> endPos = mPlayer.getCurrentPosition(); <line9> mPlayer.callPlayerSeeked(startPos, endPos, false); <line10> } <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> 	<line9>, <line12>
6098	public class A { <line0> @Override <line1> public XMLNode writeAnnotation(SBase contextObject, XMLNode xmlNode) { <line2> if (contextObject.isSetAnnotation() <line3> && (contextObject.isSetHistory() || contextObject.getCVTermCount() > 0)) { <line4> return writeSBMLRDF(contextObject, xmlNode); <line5> } <line6> return xmlNode; <line7> } <line8> } <line9> 	<line2>
6099	"public class A { <line0> public static void main(String[] args) { <line1> ConfigurableApplicationContext context = <line2> new ClassPathXmlApplicationContext(""/META-INF/spring/integration/http-outbound-config.xml""); <line3> RequestGateway requestGateway = context.getBean(""requestGateway"", RequestGateway.class); <line4> String reply = requestGateway.echo(""Hello""); <line5> context.close(); <line6> } <line7> } <line8> "	<line5>
6100	public class A { <line0> private void handleSourceStateChangedEvent(SharedDataIteratorSource<T> sender) { <line1> SQLQuery<T> query = _sourcesToQuery.remove(sender); <line2> if (_logger.isTraceEnabled()) <line3> if (query != null) _queryToSources.remove(query); <line4> } <line5> } <line6> 	<line3>
6101	public class A { <line0> @Override <line1> public void addHighPriorityJob(SensorJob sensorJob) { <line2> if (sensorJob == null) { <line3> return; <line4> } <line5> addSensorJobToCircuitScheduler(sensorJob); <line6> } <line7> } <line8> 	<line6>
6102	"public class A { <line0> @Override <line1> public Bytes testMessageContent(int current) { <line2> try (ByteArrayOutputStream out = new ByteArrayOutputStream()) { <line3> ZipOutputStream zip = new ZipOutputStream(out); <line4> ZipEntry entry = new ZipEntry(""test""); <line5> zip.putNextEntry(entry); <line6> zip.write(""hello test"".getBytes()); <line7> zip.closeEntry(); <line8> zip.finish(); <line9> return Bytes.wrap(out.toByteArray()); <line10> } catch (IOException e) { <line11> fail(""I/O error writing zip entry""); <line12> } <line13> return null; <line14> } <line15> } <line16> "	<line11>
6103	public class A { <line0> @Deprecated <line1> public void logMessageStatusUpdateRecord( <line2> Message message, <line3> Level level, <line4> Class classInfo, <line5> String additionalInfo, <line6> HelixDataAccessor accessor) { <line7> try { <line8> ZNRecord record = createMessageStatusUpdateRecord(message, level, classInfo, additionalInfo); <line9> publishStatusUpdateRecord( <line10> record, <line11> message, <line12> level, <line13> accessor, <line14> message.getTgtName().equalsIgnoreCase(InstanceType.CONTROLLER.name())); <line15> } catch (Exception e) { <line16> } <line17> } <line18> } <line19> 	<line16>
6104	public class A { <line0> private String readExtendedMetadata(UserDefinedFileAttributeView view, String name) <line1> throws IOException { <line2> try { <line3> ByteBuffer bb = ByteBuffer.allocate(view.size(name)); <line4> view.read(name, bb); <line5> bb.flip(); <line6> CharBuffer buffer = Charset.defaultCharset().decode(bb); <line7> return buffer.toString(); <line8> } catch (IllegalArgumentException | FileSystemException e) { <line9> throw new IOException(ERROR_MSG_NOT_SUPPORTED, e); <line10> } <line11> } <line12> } <line13> 	<line9>
6105	"public class A { <line0> @Override <line1> public byte[] get(List<Range> rangeList) { <line2> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line3> try { <line4> file.download(out, listener, rangeList); <line5> } catch (HttpException ex) { <line6> } catch (CancelledException ex) { <line7> throw new RuntimeException( <line8> ""Cancelled, which is odd because no progress listener was provided""); <line9> } <line10> byte[] bytes = out.toByteArray(); <line11> int expectedLength = calcExpectedLength(rangeList); <line12> numBytes += bytes.length; <line13> return bytes; <line14> } <line15> } <line16> "	<line2>
6106	public class A { <line0> public void send(final String cmd, final String value) { <line1> try { <line2> sendCommand(new EiscpMessage.MessageBuilder().command(cmd).value(value).build()); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	<line4>
6107	public class A { <line0> protected final void log(String text, String arg1, String arg2) { <line1> } <line2> } <line3> 	<line1>
6108	"public class A { <line0> public void cleanup(final Date expirationDate) { <line1> logger.addNewLogLine( <line2> ""Start actual password reset clean up with expiration date: "" + expirationDate); <line3> BatchOperation<PasswordResetRequest> passwordResetRequestBatchService = <line4> new ProcessBatchOperation<PasswordResetRequest>() { <line5> @Override <line6> public void performAction(List<PasswordResetRequest> entries) { <line7> for (PasswordResetRequest passwordResetRequest : entries) { <line8> try { <line9> logger.addNewLogLine( <line10> ""Removing PasswordResetRequest"" <line11> + passwordResetRequest.getOxGuid() <line12> + "" , create date :"" <line13> + passwordResetRequest.getCreationDate()); <line14> removePasswordResetRequest(passwordResetRequest); <line15> } catch (Exception ex) { <line16> } <line17> } <line18> } <line19> }; <line20> getExpiredPasswordResetRequests( <line21> passwordResetRequestBatchService, <line22> expirationDate, <line23> new String[] {""oxGuid"", ""creationDate""}, <line24> 0, <line25> CleanerTimer.BATCH_SIZE); <line26> logger.addNewLogLine(""Password reset clean up done at: "" + new Date()); <line27> } <line28> } <line29> "	<line9>, <line16>
6109	"public class A { <line0> private int findChromosomeID(BPTreeNode thisNode, String chromKey) { <line1> int chromID = -1; <line2> if (thisNode.isLeaf()) { <line3> int nLeaves = thisNode.getItemCount(); <line4> for (int index = 0; index < nLeaves; ++index) { <line5> BPTreeLeafNodeItem leaf = (BPTreeLeafNodeItem) thisNode.getItem(index); <line6> if (leaf == null) { <line7> throw new RuntimeException(""Error reading B+ tree leaf nodes, corruption suspected""); <line8> } <line9> if (leaf.chromKeysMatch(chromKey)) { <line10> chromID = leaf.getChromID(); <line11> break; <line12> } <line13> } <line14> } else { <line15> int nNodes = thisNode.getItemCount(); <line16> for (int index = 0; index < nNodes; ++index) { <line17> BPTreeChildNodeItem childItem = (BPTreeChildNodeItem) thisNode.getItem(index); <line18> BPTreeNode childNode = childItem.getChildNode(); <line19> String lowestKey = childNode.getLowestChromKey(); <line20> String highestKey = childNode.getHighestChromKey(); <line21> if (chromKey.compareTo(lowestKey) >= 0 && chromKey.compareTo(highestKey) <= 0) { <line22> chromID = findChromosomeID(childNode, chromKey); <line23> if (chromID >= 0) break; <line24> } <line25> } <line26> } <line27> return chromID; <line28> } <line29> } <line30> "	<line7>
6110	"public class A { <line0> @Override <line1> public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) <line2> throws TasteException { <line3> Preconditions.checkArgument(howMany >= 1, ""howMany must be at least 1""); <line4> PreferenceArray preferencesFromUser = getDataModel().getPreferencesFromUser(userID); <line5> FastIDSet possibleItemIDs = getAllOtherItems(userID, preferencesFromUser); <line6> TopItems.Estimator<Long> estimator = new Estimator(); <line7> List<RecommendedItem> topItems = <line8> TopItems.getTopItems(howMany, possibleItemIDs.iterator(), rescorer, estimator); <line9> return topItems; <line10> } <line11> } <line12> "	<line4>, <line9>
6111	public class A { <line0> protected void invalidateLocally(Integer bucketId, EntryEventImpl event) <line1> throws EntryNotFoundException, PrimaryBucketException, ForceReattemptException { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> final BucketRegion bucketRegion = getInitializedBucketForId(event.getKey(), bucketId); <line5> try { <line6> event.setRegion(bucketRegion); <line7> event.setOldValueFromRegion(); <line8> bucketRegion.basicInvalidate(event); <line9> bucketRegion.checkReadiness(); <line10> } catch (RegionDestroyedException rde) { <line11> checkRegionDestroyedOnBucket(bucketRegion, event.isOriginRemote(), rde); <line12> } <line13> } <line14> } <line15> 	<line3>
6112	"public class A { <line0> public void deploy(final BeanContext beanContext) throws OpenEJBException { <line1> final Data data = new Data(beanContext); <line2> beanContext.setContainerData(data); <line3> beanContext.set(EJBContext.class, this.sessionContext); <line4> if (StatsInterceptor.isStatsActivated()) { <line5> final StatsInterceptor stats = new StatsInterceptor(beanContext.getBeanClass()); <line6> beanContext.addFirstSystemInterceptor(stats); <line7> final ObjectNameBuilder jmxName = new ObjectNameBuilder(""openejb.management""); <line8> jmxName.set(""J2EEServer"", ""openejb""); <line9> jmxName.set(""J2EEApplication"", null); <line10> jmxName.set(""EJBModule"", beanContext.getModuleID()); <line11> jmxName.set(""SingletonSessionBean"", beanContext.getEjbName()); <line12> jmxName.set(""name"", beanContext.getEjbName()); <line13> jmxName.set(""j2eeType"", ""Invocations""); <line14> final MBeanServer server = LocalMBeanServer.get(); <line15> try { <line16> final ObjectName objectName = jmxName.build(); <line17> if (server.isRegistered(objectName)) { <line18> server.unregisterMBean(objectName); <line19> } <line20> server.registerMBean(new ManagedMBean(stats), objectName); <line21> data.add(objectName); <line22> } catch (final Exception e) { <line23> } <line24> } <line25> try { <line26> final Context context = beanContext.getJndiEnc(); <line27> context.bind(""comp/EJBContext"", sessionContext); <line28> context.bind(""comp/WebServiceContext"", webServiceContext); <line29> context.bind(""comp/TimerService"", new TimerServiceWrapper()); <line30> } catch (final NamingException e) { <line31> throw new OpenEJBException(""Failed to bind EJBContext/WebServiceContext/TimerService"", e); <line32> } <line33> } <line34> } <line35> "	<line23>
6113	"public class A { <line0> public Object createComplexChildObject( <line1> Object parentObject, SegmentContext segmentContext, Class<?> clazz) throws AtlasException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> try { <line5> Method setterMethod = resolveSetterMethod(parentObject, segmentContext, null); <line6> Object targetObject = instantiateObject(clazz); <line7> setterMethod.setAccessible(true); <line8> setterMethod.invoke(parentObject, targetObject); <line9> return targetObject; <line10> } catch (Exception e) { <line11> try { <line12> java.lang.reflect.Field field = <line13> resolveField(parentObject.getClass(), segmentContext.getName()); <line14> field.setAccessible(true); <line15> Object targetObject = instantiateObject(clazz); <line16> field.set(parentObject, targetObject); <line17> return targetObject; <line18> } catch (Exception e2) { <line19> String parentClassName = parentObject == null ? null : parentObject.getClass().getName(); <line20> throw new AtlasException( <line21> ""Unable to create value for segment: "" <line22> + segmentContext.getExpression() <line23> + "" parentObject: "" <line24> + parentClassName, <line25> e2); <line26> } <line27> } <line28> } <line29> } <line30> "	<line3>
6114	"public class A { <line0> protected void internalSetOffloadPolicies( <line1> AsyncResponse asyncResponse, OffloadPolicies offloadPolicies) { <line2> validateNamespacePolicyOperation(namespaceName, PolicyName.OFFLOAD, PolicyOperation.WRITE); <line3> validatePoliciesReadOnlyAccess(); <line4> validateOffloadPolicies(offloadPolicies); <line5> try { <line6> final String path = path(POLICIES, namespaceName.toString()); <line7> namespaceResources() <line8> .setAsync( <line9> path, <line10> (policies) -> { <line11> if (Objects.equals( <line12> offloadPolicies.getManagedLedgerOffloadDeletionLagInMillis(), <line13> OffloadPolicies.DEFAULT_OFFLOAD_DELETION_LAG_IN_MILLIS)) { <line14> offloadPolicies.setManagedLedgerOffloadDeletionLagInMillis( <line15> policies.offload_deletion_lag_ms); <line16> } else { <line17> policies.offload_deletion_lag_ms = <line18> offloadPolicies.getManagedLedgerOffloadDeletionLagInMillis(); <line19> } <line20> if (Objects.equals( <line21> offloadPolicies.getManagedLedgerOffloadThresholdInBytes(), <line22> OffloadPolicies.DEFAULT_OFFLOAD_THRESHOLD_IN_BYTES)) { <line23> offloadPolicies.setManagedLedgerOffloadThresholdInBytes( <line24> policies.offload_threshold); <line25> } else { <line26> policies.offload_threshold = <line27> offloadPolicies.getManagedLedgerOffloadThresholdInBytes(); <line28> } <line29> policies.offload_policies = offloadPolicies; <line30> return policies; <line31> }) <line32> .thenApply( <line33> r -> { <line34> asyncResponse.resume(Response.noContent().build()); <line35> return null; <line36> }) <line37> .exceptionally( <line38> e -> { <line39> asyncResponse.resume(new RestException(e)); <line40> return null; <line41> }); <line42> } catch (Exception e) { <line43> asyncResponse.resume( <line44> e.getCause() instanceof NotFoundException <line45> ? new RestException(Status.CONFLICT, ""Concurrent modification"") <line46> : new RestException(e)); <line47> } <line48> } <line49> } <line50> "	<line34>, <line39>, <line43>
6115	"public class A { <line0> private Role createRoleFromRequestBody(ServletInputStream is) <line1> throws IOException, IllegalArgumentException { <line2> try { <line3> String strRole = FileUtils.asString(is); <line4> JSONObject json = new JSONObject(strRole); <line5> String commonName = RequestUtil.getFieldValue(json, RoleSchema.COMMON_NAME_KEY); <line6> if (commonName == null) { <line7> throw new IllegalArgumentException(RoleSchema.COMMON_NAME_KEY + "" is required""); <line8> } <line9> commonName = commonName.toUpperCase(); <line10> Pattern p = Pattern.compile(""[A-Z0-9_-]+""); <line11> if (!p.matcher(commonName).matches()) <line12> throw new IllegalArgumentException( <line13> RoleSchema.COMMON_NAME_KEY <line14> + "" should only contain uppercased letters, digits, dashes and underscores""); <line15> String description = RequestUtil.getFieldValue(json, RoleSchema.DESCRIPTION_KEY); <line16> Boolean isFavorite = RequestUtil.getBooleanFieldValue(json, RoleSchema.FAVORITE_JSON_KEY); <line17> Role role = RoleFactory.create(commonName, description, isFavorite); <line18> return role; <line19> } catch (IllegalArgumentException e) { <line20> throw e; <line21> } catch (Exception e) { <line22> throw new IOException(e); <line23> } <line24> } <line25> } <line26> "	<line22>
6116	"public class A { <line0> private ChannelControlBlock createChannel(int idx) throws NetException { <line1> if (idx > MuxDemuxCommand.MAX_CHANNEL_ID) { <line2> throw new NetException(""Channel Id > "" + MuxDemuxCommand.MAX_CHANNEL_ID + "" being opened""); <line3> } <line4> if (idx >= ccbArray.length) { <line5> expand(idx); <line6> } <line7> if (ccbArray[idx] != null) { <line8> assert ccbArray[idx].completelyClosed() : ccbArray[idx].toString(); <line9> if (ccbArray[idx].completelyClosed()) { <line10> if (LOGGER.isTraceEnabled()) { <line11> } <line12> freeChannel(ccbArray[idx]); <line13> } <line14> } <line15> assert idx < ccbArray.length; <line16> assert !allocationBitmap.get(idx); <line17> IChannelInterfaceFactory channelInterfaceFactory = mConn.getChannelInterfaceFactory(); <line18> ChannelControlBlock channel = new ChannelControlBlock(this, idx, channelInterfaceFactory); <line19> ccbArray[idx] = channel; <line20> allocationBitmap.set(idx); <line21> ++openChannelCount; <line22> return channel; <line23> } <line24> } <line25> "	<line11>
6117	"public class A { <line0> @Override <line1> public Optional<Account> updateAccount(Account account) throws IOException { <line2> String url = buildCanvasUrl(""accounts/"" + account.getId(), Collections.emptyMap()); <line3> Response response = <line4> canvasMessenger.sendJsonPutToCanvas(oauthToken, url, account.toJsonObject(serializeNulls)); <line5> return responseParser.parseToObject(Account.class, response); <line6> } <line7> } <line8> "	<line2>
6118	public class A { <line0> @Override <line1> public List<String> getAll(BatchRunContext batchRunContext) { <line2> SystemAccount actor = getSystemAccount(); <line3> List<String> allShareEntries = service.findAllToPurge(actor, actor); <line4> return allShareEntries; <line5> } <line6> } <line7> 	<line2>, <line4>
6119	public class A { <line0> @Override <line1> public CPInstanceOptionValueRel findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchCPInstanceOptionValueRelException { <line3> CPInstanceOptionValueRel cpInstanceOptionValueRel = fetchByPrimaryKey(primaryKey); <line4> if (cpInstanceOptionValueRel == null) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchCPInstanceOptionValueRelException( <line8> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line9> } <line10> return cpInstanceOptionValueRel; <line11> } <line12> } <line13> 	<line6>
6120	public class A { <line0> @Override <line1> public Enumerable<Object[]> scan(final DataContext root) { <line2> final FluentIterable<Object[]> results = <line3> FluentIterable.from(rootSchema.getSubSchemaNames()) <line4> .transformAndConcat( <line5> new Function<String, Iterable<Object[]>>() { <line6> @Override <line7> public Iterable<Object[]> apply(final String schemaName) { <line8> final SchemaPlus subSchema = rootSchema.getSubSchema(schemaName); <line9> final JavaTypeFactoryImpl typeFactory = new JavaTypeFactoryImpl(TYPE_SYSTEM); <line10> final AuthenticationResult authenticationResult = <line11> (AuthenticationResult) <line12> root.get(PlannerContext.DATA_CTX_AUTHENTICATION_RESULT); <line13> final Set<String> authorizedTableNames = <line14> getAuthorizedTableNamesFromSubSchema(subSchema, authenticationResult); <line15> final Set<String> authorizedFunctionNames = <line16> getAuthorizedFunctionNamesFromSubSchema(subSchema, authenticationResult); <line17> return Iterables.concat( <line18> Iterables.filter( <line19> Iterables.concat( <line20> FluentIterable.from(authorizedTableNames) <line21> .transform( <line22> new Function<String, Iterable<Object[]>>() { <line23> @Override <line24> public Iterable<Object[]> apply(final String tableName) { <line25> return generateColumnMetadata( <line26> schemaName, <line27> tableName, <line28> subSchema.getTable(tableName), <line29> typeFactory); <line30> } <line31> }), <line32> FluentIterable.from(authorizedFunctionNames) <line33> .transform( <line34> new Function<String, Iterable<Object[]>>() { <line35> @Override <line36> public Iterable<Object[]> apply( <line37> final String functionName) { <line38> final TableMacro viewMacro = <line39> getView(subSchema, functionName); <line40> if (viewMacro == null) { <line41> return null; <line42> } <line43> try { <line44> return generateColumnMetadata( <line45> schemaName, <line46> functionName, <line47> viewMacro.apply(ImmutableList.of()), <line48> typeFactory); <line49> } catch (Exception e) { <line50> return null; <line51> } <line52> } <line53> })), <line54> Predicates.notNull())); <line55> } <line56> }); <line57> return Linq4j.asEnumerable(results); <line58> } <line59> } <line60> 	<line50>
6121	public class A { <line0> private int cacheMessages(FacesContext context) { <line1> int cachedCount = 0; <line2> Iterator<String> clientIdsWithMessages = context.getClientIdsWithMessages(); <line3> while (clientIdsWithMessages.hasNext()) { <line4> String clientId = clientIdsWithMessages.next(); <line5> Iterator<FacesMessage> iterator = context.getMessages(clientId); <line6> Collection<FacesMessage> cachedMessages = getMessageCache(context).get(clientId); <line7> if (cachedMessages == null) { <line8> cachedMessages = new ArrayList<FacesMessage>(); <line9> getMessageCache(context).put(clientId, cachedMessages); <line10> } <line11> while (iterator.hasNext()) { <line12> FacesMessage facesMessage = iterator.next(); <line13> if (cachedMessages.add(facesMessage)) { <line14> cachedCount++; <line15> } <line16> } <line17> } <line18> return cachedCount; <line19> } <line20> } <line21> 	<line18>
6122	"public class A { <line0> @Override <line1> public void init() throws DBException { <line2> String debug = getProperties().getProperty(""googledatastore.debug"", null); <line3> if (null != debug && ""true"".equalsIgnoreCase(debug)) { <line4> logger.setLevel(Level.DEBUG); <line5> } <line6> String skipIndexString = getProperties().getProperty(""googledatastore.skipIndex"", null); <line7> if (null != skipIndexString && ""false"".equalsIgnoreCase(skipIndexString)) { <line8> skipIndex = false; <line9> } <line10> String datasetId = getProperties().getProperty(""googledatastore.datasetId"", null); <line11> if (datasetId == null) { <line12> throw new DBException(""Required property \""datasetId\"" missing.""); <line13> } <line14> String privateKeyFile = getProperties().getProperty(""googledatastore.privateKeyFile"", null); <line15> String serviceAccountEmail = <line16> getProperties().getProperty(""googledatastore.serviceAccountEmail"", null); <line17> String readConsistencyConfig = <line18> getProperties().getProperty(""googledatastore.readConsistency"", null); <line19> if (readConsistencyConfig != null) { <line20> try { <line21> this.readConsistency = ReadConsistency.valueOf(readConsistencyConfig.trim().toUpperCase()); <line22> } catch (IllegalArgumentException e) { <line23> throw new DBException( <line24> ""Invalid read consistency specified: "" <line25> + readConsistencyConfig <line26> + "". Expecting STRONG or EVENTUAL.""); <line27> } <line28> } <line29> String entityGroupingConfig = <line30> getProperties().getProperty(""googledatastore.entityGroupingMode"", null); <line31> if (entityGroupingConfig != null) { <line32> try { <line33> this.entityGroupingMode = <line34> EntityGroupingMode.valueOf(entityGroupingConfig.trim().toUpperCase()); <line35> } catch (IllegalArgumentException e) { <line36> throw new DBException( <line37> ""Invalid entity grouping mode specified: "" <line38> + entityGroupingConfig <line39> + "". Expecting ONE_ENTITY_PER_GROUP or "" <line40> + ""MULTI_ENTITY_PER_GROUP.""); <line41> } <line42> } <line43> this.rootEntityName = <line44> getProperties().getProperty(""googledatastore.rootEntityName"", ""YCSB_ROOT_ENTITY""); <line45> try { <line46> DatastoreOptions.Builder options = new DatastoreOptions.Builder(); <line47> Credential credential = GoogleCredential.getApplicationDefault(); <line48> if (serviceAccountEmail != null && privateKeyFile != null) { <line49> credential = <line50> DatastoreHelper.getServiceAccountCredential(serviceAccountEmail, privateKeyFile); <line51> } else { <line52> } <line53> datastore = <line54> DatastoreFactory.get() <line55> .create(options.credential(credential).projectId(datasetId).build()); <line56> } catch (GeneralSecurityException exception) { <line57> throw new DBException( <line58> ""Security error connecting to the datastore: "" + exception.getMessage(), exception); <line59> } catch (IOException exception) { <line60> throw new DBException( <line61> ""I/O error connecting to the datastore: "" + exception.getMessage(), exception); <line62> } <line63> } <line64> } <line65> "	<line51>, <line52>, <line63>
6123	public class A { <line0> @Override <line1> public void accept(Map<UUID, Long> datasetsCitation, Map<UUID, License> datasetLicenses) { <line2> if (datasetsCitation == null || datasetsCitation.isEmpty()) { <line3> } <line4> try { <line5> downloadService.createUsages(downloadKey, datasetsCitation); <line6> } catch (Exception e) { <line7> } <line8> try { <line9> datasetLicenses.values().forEach(licenseSelector::collectLicense); <line10> Download download = downloadService.get(downloadKey); <line11> download.setLicense(licenseSelector.getSelectedLicense()); <line12> downloadService.update(download); <line13> } catch (Exception ex) { <line14> } <line15> } <line16> } <line17> 	<line3>, <line7>, <line14>
6124	"public class A { <line0> @Test <line1> public void testAdHocProcess() throws Exception { <line2> kruntime = createKogitoProcessRuntime(""BPMN2-AdHocProcess.bpmn2""); <line3> KogitoProcessInstance processInstance = kruntime.startProcess(""AdHocProcess""); <line4> assertEquals(KogitoProcessInstance.STATE_ACTIVE, processInstance.getState()); <line5> kruntime <line6> .getKogitoWorkItemManager() <line7> .registerWorkItemHandler(""Human Task"", new DoNothingWorkItemHandler()); <line8> kruntime.signalEvent(""Task1"", null, processInstance.getStringId()); <line9> assertProcessInstanceActive(processInstance); <line10> kruntime.signalEvent(""User1"", null, processInstance.getStringId()); <line11> assertProcessInstanceActive(processInstance); <line12> kruntime.getKieSession().insert(new Person()); <line13> kruntime.signalEvent(""Task3"", null, processInstance.getStringId()); <line14> assertProcessInstanceFinished(processInstance, kruntime); <line15> } <line16> } <line17> "	<line8>
6125	public class A { <line0> private CheckExistingSegmentIdResult checkAndGetExistingSegmentId( <line1> final Query<Map<String, Object>> query, <line2> final Interval interval, <line3> final String sequenceName, <line4> final @Nullable String previousSegmentId, <line5> final Pair<String, String>... queryVars) <line6> throws IOException { <line7> Query<Map<String, Object>> boundQuery = query; <line8> for (Pair<String, String> var : queryVars) { <line9> boundQuery = boundQuery.bind(var.lhs, var.rhs); <line10> } <line11> final List<byte[]> existingBytes = boundQuery.map(ByteArrayMapper.FIRST).list(); <line12> if (!existingBytes.isEmpty()) { <line13> final SegmentIdWithShardSpec existingIdentifier = <line14> jsonMapper.readValue( <line15> Iterables.getOnlyElement(existingBytes), SegmentIdWithShardSpec.class); <line16> if (existingIdentifier.getInterval().getStartMillis() == interval.getStartMillis() <line17> && existingIdentifier.getInterval().getEndMillis() == interval.getEndMillis()) { <line18> if (previousSegmentId == null) { <line19> } else { <line20> } <line21> return new CheckExistingSegmentIdResult(true, existingIdentifier); <line22> } else { <line23> if (previousSegmentId == null) { <line24> } else { <line25> } <line26> return new CheckExistingSegmentIdResult(true, null); <line27> } <line28> } <line29> return new CheckExistingSegmentIdResult(false, null); <line30> } <line31> } <line32> 	<line19>, <line20>, <line24>, <line25>
6126	"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> synchronized (HadoopLaunchHandler.this) { <line4> if (clusterState != ClusterState.UP && clusterState != ClusterState.IDLE) { <line5> return; <line6> } <line7> while (!workflowItemQueue.isEmpty()) { <line8> HadoopWorkflowItem workflowItem; <line9> workflowItem = workflowItemQueue.get(0); <line10> workflowItem <line11> .getJobConfig() <line12> .set( <line13> ""yarn.resourcemanager.hostname"", <line14> configuration.get(""yarn.resourcemanager.hostname"")); <line15> workflowItem <line16> .getJobConfig() <line17> .set( <line18> ""yarn.resourcemanager.address"", <line19> configuration.get(""yarn.resourcemanager.address"")); <line20> workflowItem <line21> .getJobConfig() <line22> .set( <line23> ""mapreduce.jobhistory.address"", <line24> configuration.get(""mapreduce.jobhistory.address"")); <line25> workflowItem <line26> .getJobConfig() <line27> .set( <line28> ""mapreduce.jobhistory.webapp.address"", <line29> configuration.get(""mapreduce.jobhistory.webapp.address"")); <line30> workflowItem <line31> .getJobConfig() <line32> .set(""yarn.log.server.url"", configuration.get(""yarn.log.server.url"")); <line33> workflowItem.getJobConfig().unset(""yarn.resourcemanager.scheduler.address""); <line34> workflowItem.getJobConfig().unset(""yarn.resourcemanager.resource-tracker.address""); <line35> workflowItem.getJobConfig().unset(""yarn.resourcemanager.admin.address""); <line36> workflowItem.submitInternal(); <line37> workflowItemQueue.remove(0); <line38> if (workflowItemQueue.isEmpty()) { <line39> break; <line40> } <line41> } <line42> clusterState = ClusterState.UP; <line43> } <line44> } catch (WorkflowException e) { <line45> LOG.warning(""SubmitTask error: "" + e); <line46> synchronized (HadoopLaunchHandler.this) { <line47> clusterState = ClusterState.UNKNOWN; <line48> hadoopProcessingService.getTimer().schedule(new ClusterStopTask(), 0); <line49> } <line50> } finally { <line51> } <line52> } <line53> } <line54> "	<line2>, <line51>
6127	"public class A { <line0> public String getMonthOfBirth() { <line1> try { <line2> Date d = formatter.parse(getDob()); <line3> calendar.setTime(d); <line4> String value = String.valueOf(calendar.get(Calendar.MONTH) + 1); <line5> if (value.length() == 1) { <line6> value = ""0"" + value; <line7> } <line8> return value; <line9> } catch (Exception e) { <line10> } <line11> return null; <line12> } <line13> } <line14> "	<line10>
6128	public class A { <line0> private static CredentialsProvider getCredentialsProvider( <line1> ElasticsearchClientConfig esClientConfig) { <line2> Optional<Entry<String, String>> credentials = esClientConfig.getCredentials(); <line3> if (credentials.isPresent()) { <line4> final CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); <line5> UsernamePasswordCredentials upcredentials = <line6> new UsernamePasswordCredentials(credentials.get().getKey(), credentials.get().getValue()); <line7> credentialsProvider.setCredentials(AuthScope.ANY, upcredentials); <line8> return credentialsProvider; <line9> } else { <line10> return null; <line11> } <line12> } <line13> } <line14> 	<line4>, <line10>
6129	"public class A { <line0> public StringApiResponse deleteIdeaInstance(Properties properties) throws Throwable { <line1> StringApiResponse response = new StringApiResponse(); <line2> try { <line3> String code = properties.getProperty(""code""); <line4> if (StringUtils.isNotBlank(code)) { <line5> code = URLDecoder.decode(code, ""UTF-8""); <line6> } <line7> IdeaInstance clone = this.getIdeaInstanceManager().getIdeaInstance(code); <line8> if (null == clone) { <line9> throw new ApiException( <line10> IApiErrorCodes.API_VALIDATION_ERROR, <line11> ""No ideaInstance found with id "" + code, <line12> Response.Status.CONFLICT); <line13> } <line14> IPage page = this.getPageWithInstance(code); <line15> if (null != page) { <line16> throw new ApiException( <line17> IApiErrorCodes.API_VALIDATION_ERROR, <line18> ""Cannod dete the intance with code '"" <line19> + code <line20> + ""'. It's published in page "" <line21> + page.getCode(), <line22> Response.Status.CONFLICT); <line23> } <line24> this.getIdeaInstanceManager().deleteIdeaInstance(code); <line25> response.setResult(IResponseBuilder.SUCCESS, null); <line26> } catch (ApiException ae) { <line27> response.addErrors(ae.getErrors()); <line28> response.setResult(IResponseBuilder.FAILURE, null); <line29> } catch (Throwable t) { <line30> throw t; <line31> } <line32> return response; <line33> } <line34> } <line35> "	<line30>
6130	"public class A { <line0> private void fetchTrustStore() { <line1> try { <line2> truststores = setColorCodingStyle(service.fetchTrustStores(), trustStoreColorCodeList); <line3> } catch (CertificateManagerException e) { <line4> HelperUtil.addMessageError(TRUST_STORE_MSG, ""Unable to fetch certificate details""); <line5> } <line6> } <line7> } <line8> "	<line4>
6131	"public class A { <line0> @PostMapping( <line1> value = RestEndpoints.DATASETS, <line2> consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE}) <line3> @ResponseStatus(HttpStatus.CREATED) <line4> @ResponseBody <line5> public Dataset createDataset( <line6> @RequestHeader(""Authorization"") String authorization, @RequestBody Dataset dataset) <line7> throws GenericMetisException { <line8> MetisUser metisUser = authenticationClient.getUserByAccessTokenInHeader(authorization); <line9> Dataset createdDataset = datasetService.createDataset(metisUser, dataset); <line10> return createdDataset; <line11> } <line12> } <line13> "	<line10>
6132	public class A { <line0> @Override <line1> public void recordSqlParsingResult(ParsingResult parsingResult, String bindValue) { <line2> if (parsingResult == null) { <line3> return; <line4> } <line5> final boolean isNewCache = sqlMetaDataService.cacheSql(parsingResult); <line6> if (isDebug) { <line7> if (isNewCache) { <line8> } else { <line9> } <line10> } <line11> String output = defaultString2(parsingResult.getOutput(), null); <line12> bindValue = defaultString2(bindValue, null); <line13> final IntStringStringValue sqlValue = <line14> new IntStringStringValue(parsingResult.getId(), output, bindValue); <line15> recordSqlParam(sqlValue); <line16> } <line17> } <line18> 	<line8>, <line9>
6133	public class A { <line0> private boolean waitForTaskExecution(Long taskID) throws InterruptedException { <line1> int retries = 0; <line2> while (retries < MAX_RETRIES_BEFORE_FAIL && !hasTaskExecuted(taskID)) { <line3> retries++; <line4> Thread.sleep(WAIT_TIME); <line5> } <line6> if (retries == MAX_RETRIES_BEFORE_FAIL) { <line7> return false; <line8> } <line9> getLogger() <line10> return true; <line11> } <line12> } <line13> 	<line1>, <line7>, <line10>
6134	"public class A { <line0> @Override <line1> public Response getRecordsByIdsWithSpecifiedColumns( <line2> String keyspaceName, <line3> String tableName, <line4> List<String> properties, <line5> List<String> ids, <line6> RequestContext context) { <line7> Response response; <line8> try { <line9> Builder selectBuilder; <line10> if (CollectionUtils.isNotEmpty(properties)) { <line11> selectBuilder = QueryBuilder.select(properties.toArray(new String[properties.size()])); <line12> } else { <line13> } <line14> response = executeSelectQuery(keyspaceName, tableName, ids, selectBuilder, """", context); <line15> } catch (Exception e) { <line16> throw new ProjectCommonException( <line17> ResponseCode.SERVER_ERROR.getErrorCode(), <line18> ResponseCode.SERVER_ERROR.getErrorMessage(), <line19> ResponseCode.SERVER_ERROR.getResponseCode()); <line20> } <line21> return response; <line22> } <line23> } <line24> "	<line13>, <line16>
6135	public class A { <line0> @Override <line1> public Boolean call() throws Exception { <line2> try { <line3> status[0] = db.command(command); <line4> return true; <line5> } catch (Exception e) { <line6> return false; <line7> } <line8> } <line9> } <line10> 	<line6>
6136	public class A { <line0> public void setClientCustomization() { <line1> MidPointPrincipal principal = SecurityUtils.getPrincipalUser(); <line2> if (principal == null) { <line3> return; <line4> } <line5> setLocale(WebModelServiceUtils.getLocale()); <line6> ClientProperties props = WebSession.get().getClientInfo().getProperties(); <line7> props.setTimeZone(WebModelServiceUtils.getTimezone()); <line8> } <line9> } <line10> 	<line6>, <line8>
6137	public class A { <line0> private boolean splitAndRelease(Segment segmentToSplit) { <line1> transactionManager.executeInTransaction( <line2> () -> { <line3> TrackingToken tokenToSplit = tokenStore.fetchToken(name, segmentToSplit.getSegmentId()); <line4> TrackerStatus[] splitStatuses = TrackerStatus.split(segmentToSplit, tokenToSplit); <line5> tokenStore.initializeSegment( <line6> splitStatuses[1].getTrackingToken(), <line7> name, <line8> splitStatuses[1].getSegment().getSegmentId()); <line9> tokenStore.releaseClaim(name, splitStatuses[0].getSegment().getSegmentId()); <line10> }); <line11> return true; <line12> } <line13> } <line14> 	<line10>
6138	"public class A { <line0> protected void internalSetRetention(RetentionPolicies retention) { <line1> validateRetentionPolicies(retention); <line2> validateNamespacePolicyOperation(namespaceName, PolicyName.RETENTION, PolicyOperation.WRITE); <line3> validatePoliciesReadOnlyAccess(); <line4> try { <line5> final String path = path(POLICIES, namespaceName.toString()); <line6> Policies policies = <line7> namespaceResources() <line8> .get(path) <line9> .orElseThrow( <line10> () -> new RestException(Status.NOT_FOUND, ""Namespace policies does not exist"")); <line11> if (!checkQuotas(policies, retention)) { <line12> new RestException( <line13> Status.PRECONDITION_FAILED, <line14> ""Retention Quota must exceed configured backlog quota for namespace.""); <line15> } <line16> policies.retention_policies = retention; <line17> namespaceResources().set(path, p -> policies); <line18> } catch (RestException pfe) { <line19> throw pfe; <line20> } catch (Exception e) { <line21> throw new RestException(e); <line22> } <line23> } <line24> } <line25> "	<line12>, <line18>, <line21>
6139	public class A { <line0> @Override <line1> public void onDataTreeChanged( <line2> @Nonnull <line3> final Collection<DataTreeModification<EndpointForwardingTemplateBySubnet>> collection) { <line4> for (DataTreeModification<EndpointForwardingTemplateBySubnet> change : collection) { <line5> final InstanceIdentifier<EndpointForwardingTemplateBySubnet> changePath = <line6> change.getRootPath().getRootIdentifier(); <line7> final IpPrefix changeKey = <line8> changePath.firstKeyOf(EndpointForwardingTemplateBySubnet.class).getIpPrefix(); <line9> SxpListenerUtil.updateCachedDao(templateCachedDao, changeKey, change); <line10> final EndpointForwardingTemplateBySubnet epForwardingTemplate = <line11> change.getRootNode().getDataAfter(); <line12> if (epForwardingTemplate == null) { <line13> } else { <line14> processWithEPTemplates(epForwardingTemplate); <line15> } <line16> } <line17> } <line18> } <line19> 	<line5>, <line13>
6140	"public class A { <line0> @Override <line1> public void update(Map<String, String> metadata, boolean forceUpdate) <line2> throws StorageContainerException { <line3> long containerId = containerData.getContainerID(); <line4> if (!containerData.isValid()) { <line5> throw new StorageContainerException( <line6> ""Invalid container data. "" + ""ContainerID: "" + containerId, INVALID_CONTAINER_STATE); <line7> } <line8> if (!forceUpdate && !containerData.isOpen()) { <line9> throw new StorageContainerException( <line10> ""Updating a closed container without force option is not allowed. "" <line11> + ""ContainerID: "" <line12> + containerId, <line13> UNSUPPORTED_REQUEST); <line14> } <line15> Map<String, String> oldMetadata = containerData.getMetadata(); <line16> try { <line17> writeLock(); <line18> for (Map.Entry<String, String> entry : metadata.entrySet()) { <line19> containerData.addMetadata(entry.getKey(), entry.getValue()); <line20> } <line21> File containerFile = getContainerFile(); <line22> updateContainerFile(containerFile); <line23> } catch (StorageContainerException ex) { <line24> containerData.setMetadata(oldMetadata); <line25> throw ex; <line26> } finally { <line27> writeUnlock(); <line28> } <line29> } <line30> } <line31> "	<line5>
6141	"public class A { <line0> @Override <line1> public boolean doMonitor(ServiceEmitter emitter) { <line2> try { <line3> ProcCpu procCpu = sigar.getProcCpu(currentProcessId); <line4> final ServiceMetricEvent.Builder builder = builder(); <line5> MonitorUtils.addDimensionsToBuilder(builder, dimensions); <line6> Map<String, Long> procDiff = <line7> diff.to( <line8> ""proc/cpu"", <line9> ImmutableMap.of( <line10> ""jvm/cpu/total"", <line11> procCpu.getTotal(), <line12> ""jvm/cpu/sys"", <line13> procCpu.getSys(), <line14> ""jvm/cpu/user"", <line15> procCpu.getUser())); <line16> if (procDiff != null) { <line17> for (Map.Entry<String, Long> entry : procDiff.entrySet()) { <line18> emitter.emit(builder.build(entry.getKey(), entry.getValue())); <line19> } <line20> } <line21> emitter.emit(builder.build(""jvm/cpu/percent"", procCpu.getPercent())); <line22> } catch (SigarException e) { <line23> } <line24> return true; <line25> } <line26> } <line27> "	<line23>
6142	"public class A { <line0> private String getWindowsPath(String path) { <line1> String newStr = """"; <line2> char[] strArr = path.toCharArray(); <line3> for (int i = 0; i < strArr.length; i++) { <line4> if (strArr[i] == '/') { <line5> newStr += ""\\""; <line6> } else { <line7> newStr += strArr[i]; <line8> } <line9> } <line10> if (debug) { <line11> } <line12> return newStr; <line13> } <line14> } <line15> "	<line11>
6143	public class A { <line0> public static long getDefaultPlid(long groupId, long scopeGroupId, String portletId) <line1> throws RemoteException { <line2> try { <line3> long returnValue = LayoutServiceUtil.getDefaultPlid(groupId, scopeGroupId, portletId); <line4> return returnValue; <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>
6144	public class A { <line0> private CalculatedDesiredPoolSize calculateDesiredPoolSize(long currentPoolSize) { <line1> long now = System.currentTimeMillis(); <line2> WindowSummary downsizeSummary = <line3> recentDesiredResizes.summarizeWindow(getResizeDownStabilizationDelay()); <line4> WindowSummary upsizeSummary = <line5> recentDesiredResizes.summarizeWindow(getResizeUpStabilizationDelay()); <line6> long maxDesiredPoolSize = upsizeSummary.min; <line7> boolean stableForGrowing = upsizeSummary.stableForGrowth; <line8> long minDesiredPoolSize = downsizeSummary.max; <line9> boolean stableForShrinking = downsizeSummary.stableForShrinking; <line10> long desiredPoolSize; <line11> boolean stable; <line12> if (currentPoolSize < maxDesiredPoolSize) { <line13> desiredPoolSize = maxDesiredPoolSize; <line14> stable = stableForGrowing; <line15> } else if (currentPoolSize > minDesiredPoolSize) { <line16> desiredPoolSize = minDesiredPoolSize; <line17> stable = stableForShrinking; <line18> } else { <line19> desiredPoolSize = currentPoolSize; <line20> stable = stableForGrowing && stableForShrinking; <line21> } <line22> if (LOG.isTraceEnabled()) <line23> return new CalculatedDesiredPoolSize(desiredPoolSize, stable); <line24> } <line25> } <line26> 	<line23>
6145	public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> switch (channelUID.getId()) { <line3> case CHANNEL_UNIT_LEVEL: <line4> handleUnitLevel(channelUID, command); <line5> break; <line6> default: <line7> super.handleCommand(channelUID, command); <line8> } <line9> } <line10> } <line11> 	<line2>, <line7>
6146	"public class A { <line0> public boolean attachConfigDriveToMigratedVm(Connection conn, String vmName, String ipAddr) { <line1> try { <line2> Set<VM> vms = VM.getByNameLabel(conn, vmName); <line3> SR sr = getSRByNameLabel(conn, vmName + VM_NAME_ISO_SUFFIX); <line4> Set<VDI> vdis = VDI.getByNameLabel(conn, vmName + VM_FILE_ISO_SUFFIX); <line5> if (vdis.isEmpty()) { <line6> return false; <line7> } <line8> VDI configdriveVdi = null; <line9> for (VDI vdi : vdis) { <line10> SR vdiSr = vdi.getSR(conn); <line11> if (vdiSr.getUuid(conn).equals(sr.getUuid(conn))) { <line12> configdriveVdi = vdi; <line13> } else { <line14> vdi.destroy(conn); <line15> } <line16> } <line17> if (configdriveVdi == null) { <line18> return false; <line19> } <line20> for (VM vm : vms) { <line21> VBD.Record cfgDriveVbdr = new VBD.Record(); <line22> cfgDriveVbdr.VM = vm; <line23> cfgDriveVbdr.empty = true; <line24> cfgDriveVbdr.bootable = false; <line25> cfgDriveVbdr.userdevice = ""autodetect""; <line26> cfgDriveVbdr.mode = Types.VbdMode.RO; <line27> cfgDriveVbdr.type = Types.VbdType.CD; <line28> VBD cfgDriveVBD = VBD.create(conn, cfgDriveVbdr); <line29> cfgDriveVBD.insert(conn, configdriveVdi); <line30> break; <line31> } <line32> return true; <line33> } catch (BadServerResponse e) { <line34> return false; <line35> } catch (XenAPIException e) { <line36> return false; <line37> } catch (XmlRpcException e) { <line38> return false; <line39> } <line40> } <line41> } <line42> "	<line2>, <line6>, <line13>, <line14>, <line18>, <line29>, <line34>, <line36>, <line38>
6147	public class A { <line0> @Override <line1> public void writeChunk(byte[] buffer, int chunkIndex, boolean cached) throws IOException { <line2> if (!cached && cacheHandler != null) { <line3> try { <line4> cacheHandler.writeChunk(buffer, chunkIndex); <line5> } catch (IOException ex) { <line6> } <line7> } <line8> chunksBuffer.writeChunk(buffer, chunkIndex); <line9> } <line10> } <line11> 	<line6>, <line9>
6148	public class A { <line0> private void createAndInitScheduler() throws SchedulerException { <line1> scheduler = createScheduler(); <line2> SchedulerContext quartzContext = storeCamelContextInQuartzContext(); <line3> AtomicInteger number = <line4> (AtomicInteger) quartzContext.get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT); <line5> if (number == null) { <line6> number = new AtomicInteger(); <line7> quartzContext.put(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT, number); <line8> } <line9> } <line10> } <line11> 	<line1>
6149	public class A { <line0> public void logError(LogMessageIdentifier identifier, String... params) { <line1> String message = getLogMessageText(identifier, params); <line2> } <line3> } <line4> 	<line2>
6150	"public class A { <line0> @Override <line1> public SLIPrincipal locate( <line2> String tenantId, String externalUserId, String userType, String clientId) { <line3> SLIPrincipal user = new SLIPrincipal(externalUserId + ""@"" + tenantId); <line4> user.setExternalId(externalUserId); <line5> user.setTenantId(tenantId); <line6> user.setUserType(userType); <line7> TenantContext.setTenantId(tenantId); <line8> if (EntityNames.STUDENT.equals(userType)) { <line9> NeutralQuery neutralQuery = <line10> new NeutralQuery( <line11> new NeutralCriteria( <line12> ParameterConstants.STUDENT_UNIQUE_STATE_ID, <line13> NeutralCriteria.OPERATOR_EQUAL, <line14> externalUserId)); <line15> neutralQuery.setOffset(0); <line16> neutralQuery.setLimit(1); <line17> user.setEntity(repo.findOne(EntityNames.STUDENT, neutralQuery, true)); <line18> } else if (EntityNames.PARENT.equals(userType)) { <line19> NeutralQuery neutralQuery = <line20> new NeutralQuery( <line21> new NeutralCriteria( <line22> ParameterConstants.PARENT_UNIQUE_STATE_ID, <line23> NeutralCriteria.OPERATOR_EQUAL, <line24> externalUserId)); <line25> neutralQuery.setOffset(0); <line26> neutralQuery.setLimit(1); <line27> user.setEntity(repo.findOne(EntityNames.PARENT, neutralQuery, true)); <line28> } else if (isStaff(userType)) { <line29> NeutralQuery neutralQuery = new NeutralQuery(); <line30> neutralQuery.setOffset(0); <line31> neutralQuery.setLimit(1); <line32> neutralQuery.addCriteria( <line33> new NeutralCriteria( <line34> ParameterConstants.STAFF_UNIQUE_STATE_ID, <line35> NeutralCriteria.OPERATOR_EQUAL, <line36> externalUserId)); <line37> Iterable<Entity> staff = repo.findAll(EntityNames.STAFF, neutralQuery); <line38> if (staff != null && staff.iterator().hasNext()) { <line39> Entity entity = staff.iterator().next(); <line40> Set<String> edorgs = edorgHelper.locateDirectEdorgs(entity); <line41> if (edorgs.size() == 0) { <line42> throw new APIAccessDeniedException( <line43> ""User is not currently associated to a school/edorg"", user, clientId); <line44> } <line45> user.setEntity(entity); <line46> } <line47> } <line48> if (user.getEntity() == null) { <line49> Entity entity = <line50> new MongoEntity( <line51> ""user"", <line52> SLIPrincipal.NULL_ENTITY_ID, <line53> new HashMap<String, Object>(), <line54> new HashMap<String, Object>()); <line55> user.setEntity(entity); <line56> } else { <line57> } <line58> return user; <line59> } <line60> } <line61> "	<line3>, <line42>, <line49>, <line57>
6151	public class A { <line0> private void onSessionFailure(int error, String reason, Callback callback) { <line1> GoAwayFrame goAwayFrame; <line2> Throwable cause; <line3> try (AutoLock l = lock.lock()) { <line4> switch (closed) { <line5> case NOT_CLOSED: <line6> case LOCALLY_CLOSED: <line7> case REMOTELY_CLOSED: <line8> { <line9> goAwaySent = goAwayFrame = newGoAwayFrame(error, reason); <line10> closed = CloseState.CLOSING; <line11> zeroStreamsAction = null; <line12> failure = cause = toFailure(error, reason); <line13> break; <line14> } <line15> default: <line16> { <line17> if (LOG.isDebugEnabled()) <line18> callback.succeeded(); <line19> return; <line20> } <line21> } <line22> } <line23> failStreams(stream -> true, reason, true); <line24> sendGoAway(goAwayFrame, Callback.NOOP); <line25> notifyFailure(HTTP2Session.this, cause, Callback.NOOP); <line26> terminate(goAwayFrame); <line27> } <line28> } <line29> 	<line18>, <line23>
6152	"public class A { <line0> private void createTables() throws Exception { <line1> final Statement statement = connection.createStatement(); <line2> try { <line3> final BufferedReader reader = <line4> new BufferedReader( <line5> new InputStreamReader(getClass().getResourceAsStream(""/config/scanlog.dbd""))); <line6> StringBuilder cmd = new StringBuilder(); <line7> String line = reader.readLine(); <line8> while (line != null) { <line9> line = line.trim(); <line10> if (!line.startsWith(""--"")) { <line11> if (line.endsWith("";"")) { <line12> cmd.append(line.substring(0, line.length() - 1)); <line13> if (cmd.length() > 0) { <line14> final String sql = cmd.toString(); <line15> try { <line16> statement.execute(sql); <line17> } catch (SQLException ex) { <line18> if (!ex.getSQLState().equals(""42Y55"")) <line19> logger.log(Level.INFO, ""SQL failed: "" + sql, ex); <line20> } <line21> } <line22> cmd = new StringBuilder(); <line23> } else cmd.append(line); <line24> } <line25> line = reader.readLine(); <line26> } <line27> reader.close(); <line28> } finally { <line29> statement.close(); <line30> } <line31> } <line32> } <line33> "	<line3>
6153	"public class A { <line0> public static Map<String, List<CustomerGateway>> fetchCustomerGateway( <line1> BasicSessionCredentials temporaryCredentials, <line2> String skipRegions, <line3> String accountId, <line4> String accountName) { <line5> Map<String, List<CustomerGateway>> customerGatewayMap = new LinkedHashMap<>(); <line6> AmazonEC2 ec2Client; <line7> String expPrefix = <line8> InventoryConstants.ERROR_PREFIX_CODE <line9> + accountId <line10> + ""\"",\""Message\"": \""Exception in fetching info for resource in specific region\"""" <line11> + "" ,\""type\"": \""customergateway\"" , \""region\"":\""""; <line12> for (Region region : RegionUtils.getRegions()) { <line13> try { <line14> if (!skipRegions.contains(region.getName())) { <line15> ec2Client = <line16> AmazonEC2ClientBuilder.standard() <line17> .withCredentials(new AWSStaticCredentialsProvider(temporaryCredentials)) <line18> .withRegion(region.getName()) <line19> .build(); <line20> List<CustomerGateway> customerGatewayList = <line21> ec2Client.describeCustomerGateways().getCustomerGateways(); <line22> if (!customerGatewayList.isEmpty()) { <line23> customerGatewayMap.put( <line24> accountId + delimiter + accountName + delimiter + region.getName(), <line25> customerGatewayList); <line26> } <line27> } <line28> } catch (Exception e) { <line29> ErrorManageUtil.uploadError(accountId, region.getName(), ""customergateway"", e.getMessage()); <line30> } <line31> } <line32> return customerGatewayMap; <line33> } <line34> } <line35> "	<line23>, <line29>
6154	"public class A { <line0> Message updateKieContainerToVersion(KieContainerInstanceImpl kci, ReleaseId releaseId) { <line1> String containerId = kci.getContainerId(); <line2> Message response = null; <line3> kci.clearExtraClasses(); <line4> kci.disposeMarshallers(); <line5> Results results = kci.getKieContainer().updateToVersion(releaseId); <line6> if (results.hasMessages(Level.ERROR)) { <line7> response = <line8> new Message( <line9> Severity.WARN, <line10> ""Error updating releaseId for container "" + containerId + "" to version "" + releaseId); <line11> for (org.kie.api.builder.Message builderMsg : results.getMessages()) { <line12> response.addMessage(builderMsg.getText()); <line13> } <line14> } else { <line15> kci.updateReleaseId(); <line16> response = <line17> new Message(Severity.INFO, ""Kie container updated successfully to version "" + releaseId); <line18> } <line19> return response; <line20> } <line21> } <line22> "	<line14>
6155	"public class A { <line0> @Override <line1> protected RouteBuilder createRouteBuilder() throws Exception { <line2> return new RouteBuilder() { <line3> public void configure() throws Exception { <line4> from(""direct:start"").recipientList().header(""whereTo"").to(""mock:result""); <line5> from(""activemq:topic:news?disableReplyTo=true"") <line6> .transform(body().prepend(""Bye "")) <line7> .process( <line8> exchange -> { <line9> String replyTo = exchange.getIn().getHeader(""JMSReplyTo"", String.class); <line10> String cid = exchange.getIn().getHeader(""JMSCorrelationID"", String.class); <line11> if (replyTo != null && cid != null) { <line12> Thread.sleep(1000); <line13> template.sendBodyAndHeader( <line14> ""activemq:"" + replyTo, exchange.getIn().getBody(), ""JMSCorrelationID"", cid); <line15> } <line16> }); <line17> } <line18> }; <line19> } <line20> } <line21> "	<line11>, <line13>
6156	public class A { <line0> @Override <line1> public int countSharedProjectsByUser(Long idUser) { <line2> Condition conditions = Tables.PROJECT.SHARED.equal(Boolean.TRUE); <line3> if (idUser != null) { <line4> conditions = conditions.and(Tables.PROJECT.ID_USER.eq(idUser)); <line5> } <line6> return create.fetchCount(Tables.PROJECT, conditions); <line7> } <line8> } <line9> 	<line2>
6157	public class A { <line0> protected void success() { <line1> assert uuid != null; <line2> assert canceller != null; <line3> canceller.run(); <line4> SQL.New(GarbageCollectorVO.class) <line5> .eq(GarbageCollectorVO_.uuid, uuid) <line6> .set(GarbageCollectorVO_.status, GCStatus.Done) <line7> .update(); <line8> gcMgr.deregisterGC(this); <line9> } <line10> } <line11> 	<line3>
6158	public class A { <line0> public static ServletContext remove(String servletContextName) { <line1> String contextPath = PortalUtil.getPathContext(); <line2> if (contextPath.equals(servletContextName)) { <line3> return null; <line4> } <line5> ServletContext servletContext = _servletContexts.remove(servletContextName); <line6> if (_log.isDebugEnabled()) { <line7> } <line8> return servletContext; <line9> } <line10> } <line11> 	<line7>
6159	public class A { <line0> public void handle(SubCollectionSubCollectionContext ctx) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> currentState.handle(this, ctx); <line4> } <line5> } <line6> 	<line2>
6160	public class A { <line0> protected void closeResources() { <line1> try { <line2> if (cachedConnectionProvider != null) { <line3> cachedConnectionProvider.close(); <line4> } <line5> } catch (Throwable t) { <line6> } finally { <line7> cachedConnectionProvider = null; <line8> try { <line9> if (dialect != null) { <line10> dialect.close(); <line11> } <line12> } catch (Throwable t) { <line13> } finally { <line14> dialect = null; <line15> } <line16> } <line17> } <line18> } <line19> 	<line1>, <line6>, <line13>
6161	"public class A { <line0> @Override <line1> public VALUETO encodeFromRawInternal(Object o, Optional<CassandraOptions> cassandraOptions) { <line2> if (LOGGER.isTraceEnabled()) { <line3> } <line4> Validator.validateTrue( <line5> valueFromTypeToken.getRawType().isAssignableFrom(o.getClass()), <line6> ""The class of object %s to encode should be %s"", <line7> o, <line8> valueFromTypeToken); <line9> return encodeFromJava((VALUEFROM) o, cassandraOptions); <line10> } <line11> } <line12> "	<line3>
6162	public class A { <line0> @Override <line1> public void stop() throws Exception { <line2> appCtx.getClusterStateManager().setState(SHUTTING_DOWN); <line3> ((ActiveNotificationHandler) appCtx.getActiveNotificationHandler()).stop(); <line4> AsterixStateProxy.unregisterRemoteObject(); <line5> webManager.stop(); <line6> } <line7> } <line8> 	<line2>
6163	"public class A { <line0> private VoidResponse close(String id, Principal principal) { <line1> VoidResponse response = new VoidResponse(); <line2> try { <line3> boolean connectionRequestCanceled = <line4> accumuloConnectionRequestBean.cancelConnectionRequest(id, principal); <line5> Pair<QueryLogic<?>, AccumuloClient> tuple = <line6> qlCache.pollIfOwnedBy(id, ((DatawavePrincipal) principal).getShortName()); <line7> if (tuple == null) { <line8> try { <line9> RunningQuery query = getQueryById(id, principal); <line10> close(query); <line11> } catch (Exception e) { <line12> if (!closedQueryCache.exists(id)) { <line13> if (!connectionRequestCanceled) { <line14> throw e; <line15> } <line16> } <line17> } <line18> response.addMessage(id + "" closed.""); <line19> } else { <line20> QueryLogic<?> logic = tuple.getFirst(); <line21> try { <line22> logic.close(); <line23> } catch (Exception e) { <line24> } <line25> connectionFactory.returnClient(tuple.getSecond()); <line26> response.addMessage(id + "" closed before create completed.""); <line27> } <line28> closedQueryCache.remove(id); <line29> return response; <line30> } catch (DatawaveWebApplicationException e) { <line31> throw e; <line32> } catch (Exception e) { <line33> QueryException qe = <line34> new QueryException( <line35> DatawaveErrorCode.CLOSE_ERROR, e, MessageFormat.format(""query_id: {0}"", id)); <line36> response.addException(qe.getBottomQueryException()); <line37> int statusCode = qe.getBottomQueryException().getStatusCode(); <line38> throw new DatawaveWebApplicationException(qe, response, statusCode); <line39> } <line40> } <line41> } <line42> "	<line12>, <line13>, <line14>, <line24>, <line36>
6164	public class A { <line0> @OnDisabled <line1> @OnShutdown <line2> @Override <line3> public void stopClient() throws Exception { <line4> activeSessions.clear(); <line5> if (sessionMaintenanceScheduler != null) { <line6> try { <line7> sessionMaintenanceScheduler.shutdown(); <line8> } catch (Exception e) { <line9> } <line10> sessionMaintenanceScheduler = null; <line11> } <line12> if (client == null) { <line13> return; <line14> } <line15> client.stop(); <line16> client = null; <line17> } <line18> } <line19> 	<line9>
6165	public class A { <line0> @Override <line1> public void handleCommand(final ChannelUID channelUID, final Command command) { <line2> if (channelUID.getId().equals(WIFI_SOCKET_CHANNEL_ID)) { <line3> if (command == OnOffType.ON) { <line4> this.sendCommand(SilvercrestWifiSocketRequestType.ON); <line5> } else if (command == OnOffType.OFF) { <line6> this.sendCommand(SilvercrestWifiSocketRequestType.OFF); <line7> } else if (command == RefreshType.REFRESH) { <line8> this.sendCommand(SilvercrestWifiSocketRequestType.GPIO_STATUS); <line9> } <line10> } <line11> } <line12> } <line13> 	<line3>
6166	public class A { <line0> private void saveUserDetailsToEs(String userId, RequestContext context) { <line1> Request userRequest = new Request(); <line2> userRequest.setRequestContext(context); <line3> userRequest.setOperation(ActorOperations.UPDATE_USER_INFO_ELASTIC.getValue()); <line4> userRequest.getRequest().put(JsonKey.ID, userId); <line5> tellToAnother(userRequest); <line6> } <line7> } <line8> 	<line5>
6167	public class A { <line0> @Override <line1> public TraceEntry startServiceCallEntry( <line2> String serviceCallType, <line3> String serviceCallText, <line4> MessageSupplier messageSupplier, <line5> TimerName timerName) { <line6> if (serviceCallType == null) { <line7> return NopTransactionService.TRACE_ENTRY; <line8> } <line9> if (serviceCallText == null) { <line10> return NopTransactionService.TRACE_ENTRY; <line11> } <line12> if (messageSupplier == null) { <line13> return NopTransactionService.TRACE_ENTRY; <line14> } <line15> if (timerName == null) { <line16> return NopTransactionService.TRACE_ENTRY; <line17> } <line18> long startTick = ticker.read(); <line19> TimerImpl timer = startTimer(timerName, startTick); <line20> if (transaction.allowAnotherEntry()) { <line21> SyncQueryData queryData = getOrCreateServiceCallData(serviceCallType, serviceCallText, true); <line22> return traceEntryComponent.pushEntry(startTick, messageSupplier, timer, null, queryData, 1); <line23> } else { <line24> SyncQueryData queryData = getOrCreateServiceCallData(serviceCallType, serviceCallText, false); <line25> return new DummyTraceEntryOrQuery(timer, null, startTick, messageSupplier, queryData, 1); <line26> } <line27> } <line28> } <line29> 	<line7>, <line10>, <line13>, <line16>
6168	"public class A { <line0> public static String getUser(String userName, UserGroupInformation ugi) { <line1> if (StringUtils.isNotEmpty(userName)) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> return userName; <line5> } <line6> if (ugi != null && StringUtils.isNotEmpty(ugi.getShortUserName())) { <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> return ugi.getShortUserName(); <line10> } <line11> try { <line12> return UserGroupInformation.getCurrentUser().getShortUserName(); <line13> } catch (IOException e) { <line14> return System.getProperty(""user.name""); <line15> } <line16> } <line17> } <line18> "	<line3>, <line8>, <line14>
6169	"public class A { <line0> @Override <line1> public Serializable execute() { <line2> try { <line3> Long sleep = argument(0); <line4> assert sleep != null; <line5> Thread.sleep(sleep); <line6> } catch (InterruptedException e) { <line7> if (log.isInfoEnabled()) <line8> throw new IgniteException(""Job got interrupted."", e); <line9> } finally { <line10> if (log.isInfoEnabled()) <line11> } <line12> return ignite.cluster().localNode().id(); <line13> } <line14> } <line15> "	<line2>, <line8>, <line11>
6170	public class A { <line0> private void addFileToZipArchive( <line1> final String path, final File file, final ZipFile zipFile, final ZipParameters params) <line2> throws IOException { <line3> params.setFileNameInZip(path); <line4> zipFile.addStream(file.getInputStream(), params); <line5> } <line6> } <line7> 	<line3>
6171	"public class A { <line0> private void validateEntity(final EntityType entity) { <line1> final List<ValidationError> errors = new ArrayList<ValidationError>(); <line2> if (StringUtils.isBlank(entity.getPanno()) <line3> || StringUtils.isBlank(entity.getBankname()) <line4> || StringUtils.isBlank(entity.getBankaccount()) <line5> || StringUtils.isBlank(entity.getIfsccode())) { <line6> errors.add( <line7> new ValidationError( <line8> ""paymentMode"", <line9> ""BankName, BankAccount,IFSC Code, Pan number is mandatory for RTGS Payment for "" <line10> + entity.getName())); <line11> throw new ValidationException(errors); <line12> } <line13> } <line14> } <line15> "	<line1>, <line6>, <line13>
6172	public class A { <line0> @Override <line1> public String[] next() { <line2> counter++; <line3> if (counter % 100000 == 0) { <line4> } <line5> String[] result = rowEncoder.decode(new KV(rocksIterator.key(), rocksIterator.value())); <line6> rocksIterator.next(); <line7> return result; <line8> } <line9> } <line10> 	<line4>
6173	public class A { <line0> public @Nullable MediaLibraryStatistics getStatistics() { <line1> MediaLibraryStatistics stats = null; <line2> for (IndexType indexType : IndexType.values()) { <line3> IndexSearcher searcher = getSearcher(indexType); <line4> if (searcher == null) { <line5> return null; <line6> } <line7> IndexReader indexReader = searcher.getIndexReader(); <line8> if (!(indexReader instanceof DirectoryReader)) { <line9> return null; <line10> } <line11> try { <line12> Map<String, String> userData = <line13> ((DirectoryReader) indexReader).getIndexCommit().getUserData(); <line14> MediaLibraryStatistics currentStats = <line15> Util.stringMapToValidObject(MediaLibraryStatistics.class, userData); <line16> if (stats == null) { <line17> stats = currentStats; <line18> } else { <line19> if (!Objects.equals(stats, currentStats)) { <line20> return null; <line21> } <line22> } <line23> } catch (IOException | IllegalArgumentException e) { <line24> return null; <line25> } <line26> } <line27> return stats; <line28> } <line29> } <line30> 	<line5>, <line9>, <line20>, <line24>
6174	public class A { <line0> private void releaseUnprocessedEvents() { <line1> synchronized (this.unprocessedEventsLock) { <line2> Map<EventID, EventWrapper> m = this.unprocessedEvents; <line3> if (m != null) { <line4> for (EventWrapper ew : m.values()) { <line5> GatewaySenderEventImpl gatewayEvent = ew.event; <line6> if (logger.isDebugEnabled()) { <line7> } <line8> gatewayEvent.release(); <line9> } <line10> this.unprocessedEvents = null; <line11> } <line12> } <line13> } <line14> } <line15> 	<line7>
6175	public class A { <line0> String getAndLogServiceClientProperty(String property) { <line1> String value = serviceClientProp.getProperty(property).trim(); <line2> if (Constants.CM_SERVICE_USER_PWD.equals(property)) { <line3> } else { <line4> } <line5> return value; <line6> } <line7> } <line8> 	<line3>, <line4>
6176	public class A { <line0> public Expr allocAggregate(Aggregator agg) { <line1> String key = agg.key(); <line2> Var v = aggregatorsAllocated.get(key); <line3> if (v != null) { <line4> ExprAggregator eAgg = aggregatorsMap.get(v); <line5> if (!agg.equals(eAgg.getAggregator())) <line6> return eAgg; <line7> } <line8> v = allocInternVar(); <line9> ExprAggregator aggExpr = new ExprAggregator(v, agg); <line10> aggregatorsAllocated.put(key, v); <line11> aggregatorsMap.put(v, aggExpr); <line12> aggregators.add(aggExpr); <line13> return aggExpr; <line14> } <line15> } <line16> 	<line6>
6177	"public class A { <line0> @Override <line1> public void saveState(Node node) { <line2> Document doc = node instanceof Document ? (Document) node : node.getOwnerDocument(); <line3> try { <line4> Node timeNode = <line5> (Node) <line6> StateXML.newXPath() <line7> .evaluate( <line8> ""/"" + ModuleStateController.STATE_QNAME + ""/:time"", <line9> node, <line10> XPathConstants.NODE); <line11> if (timeNode == null) { <line12> timeNode = StateXML.createElement(doc, ""time""); <line13> node.appendChild(timeNode); <line14> } <line15> saveCurrentState(timeNode); <line16> saveHeldState(timeNode); <line17> saveFadeState(timeNode); <line18> } catch (XPathExpressionException e) { <line19> } <line20> } <line21> } <line22> "	<line19>
6178	"public class A { <line0> public SignResponse sign( <line1> String apiVersion, String moduleName, SignRequest signRequest, String generationId) <line2> throws IOException, TransportException, HsmException { <line3> String uri = baseUrl != null ? baseUrl.replaceFirst(""/*$"", """") : """"; <line4> byte[] body = signRequest.toJson().getBytes(); <line5> String pathBuilder = <line6> ""/modules/"" <line7> + URLEncoder.encode(moduleName, StandardCharsets.UTF_8.name()) <line8> + ""/genid/"" <line9> + URLEncoder.encode(generationId, StandardCharsets.UTF_8.name()) <line10> + ""/sign""; <line11> HttpsResponse response = <line12> sendRequestBasedOnScheme( <line13> HttpsMethod.POST, body, uri, pathBuilder, API_VERSION_QUERY_STRING_PREFIX + apiVersion); <line14> int responseCode = response.getStatus(); <line15> String responseBody = new String(response.getBody()); <line16> if (responseCode >= 200 && responseCode < 300) { <line17> return SignResponse.fromJson(responseBody); <line18> } else { <line19> String exceptionMessage = <line20> ""HttpsHsmClient received status code "" + responseCode + "" from provided uri.""; <line21> ErrorResponse errorResponse = ErrorResponse.fromJson(responseBody); <line22> if (errorResponse != null) { <line23> exceptionMessage = <line24> exceptionMessage + "" Error response message: "" + errorResponse.getMessage(); <line25> } <line26> throw new HsmException(exceptionMessage); <line27> } <line28> } <line29> } <line30> "	<line3>
6179	"public class A { <line0> protected static void logWsdl(String output) { <line1> try { <line2> PropertyAccessor propAccessor = PropertyAccessor.getInstance(); <line3> String logOutputValue = <line4> propAccessor.getProperty(NhincConstants.ADAPTER_PROPERTY_FILE_NAME, LOG_WSDL_KEY); <line5> if (logOutputValue.equalsIgnoreCase(""true"") || logOutputValue.equalsIgnoreCase(""t"")) { <line6> } <line7> } catch (PropertyAccessException ex) { <line8> } <line9> } <line10> } <line11> "	<line6>, <line8>
6180	public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> replicateKeyValues_result result = new replicateKeyValues_result(); <line4> if (e instanceof RemoteReplicationException) { <line5> result.e = (RemoteReplicationException) e; <line6> result.setEIsSet(true); <line7> msg = result; <line8> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line9> fb.close(); <line10> return; <line11> } else if (e instanceof org.apache.thrift.TApplicationException) { <line12> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line13> msg = (org.apache.thrift.TApplicationException) e; <line14> } else { <line15> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line16> msg = <line17> new org.apache.thrift.TApplicationException( <line18> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line19> } <line20> try { <line21> fcall.sendResponse(fb, msg, msgType, seqid); <line22> } catch (java.lang.Exception ex) { <line23> fb.close(); <line24> } <line25> } <line26> } <line27> 	<line9>, <line12>, <line15>, <line23>
6181	public class A { <line0> private void deleteCacheFile(FileOutputStream fos) { <line1> IOUtils.closeQuietly(fos); <line2> boolean result = FileUtils.deleteQuietly(new File(filePath)); <line3> } <line4> } <line5> 	<line1>, <line3>
6182	"public class A { <line0> @Override <line1> public boolean cheat( <line2> final UUID gameId, final String sessionId, final UUID playerId, final String cardName) <line3> throws MageException { <line4> return executeWithResult( <line5> ""cheatOne"", <line6> sessionId, <line7> new ActionWithBooleanResult() { <line8> @Override <line9> public Boolean execute() { <line10> if (testMode) { <line11> Optional<Session> session = managerFactory.sessionManager().getSession(sessionId); <line12> if (!session.isPresent()) { <line13> } else { <line14> UUID userId = session.get().getUserId(); <line15> return managerFactory.gameManager().cheat(gameId, userId, playerId, cardName); <line16> } <line17> } <line18> return false; <line19> } <line20> }); <line21> } <line22> } <line23> "	<line13>
6183	public class A { <line0> private static void updateOnImageFile(Document mets, String fileId, String path) { <line1> List<String> customFileGroups = getFileGroups(mets); <line2> PhysicalSubDiv div = <line3> new PhysicalSubDiv(PhysicalSubDiv.ID_PREFIX + fileId, PhysicalSubDiv.TYPE_PAGE); <line4> div.add(new Fptr(fileId)); <line5> customFileGroups.stream() <line6> .map(customFileGroup -> searchFileInGroup(mets, path, customFileGroup)) <line7> .filter(Objects::nonNull) <line8> .map(Fptr::new) <line9> .forEach(div::add); <line10> Element structMapPhys = getPhysicalStructmap(mets); <line11> structMapPhys.addContent(div.asElement()); <line12> SmLink smLink = getDefaultSmLink(mets, div); <line13> Element structLink = getStructLink(mets); <line14> structLink.addContent(smLink.asElement()); <line15> } <line16> } <line17> 	<line1>
6184	"public class A { <line0> public RuleResult execute( <line1> final Map<String, String> ruleParam, Map<String, String> resourceAttributes) { <line2> Annotation annotation = null; <line3> String volumeId = null; <line4> String region = null; <line5> String severity = ruleParam.get(PacmanRuleConstants.SEVERITY); <line6> String category = ruleParam.get(PacmanRuleConstants.CATEGORY); <line7> String ebsUrl = null; <line8> String formattedUrl = <line9> PacmanUtils.formatUrl(ruleParam, PacmanRuleConstants.ES_EBS_WITH_INSTANCE_URL); <line10> if (!StringUtils.isNullOrEmpty(formattedUrl)) { <line11> ebsUrl = formattedUrl; <line12> } <line13> MDC.put(""executionId"", ruleParam.get(""executionId"")); <line14> MDC.put(""ruleId"", ruleParam.get(PacmanSdkConstants.RULE_ID)); <line15> List<LinkedHashMap<String, Object>> issueList = new ArrayList<>(); <line16> LinkedHashMap<String, Object> issue = new LinkedHashMap<>(); <line17> if (!PacmanUtils.doesAllHaveValue(severity, category, ebsUrl)) { <line18> throw new InvalidInputException(PacmanRuleConstants.MISSING_CONFIGURATION); <line19> } <line20> if (resourceAttributes != null) { <line21> volumeId = StringUtils.trim(resourceAttributes.get(PacmanRuleConstants.VOLUME_ID)); <line22> region = StringUtils.trim(resourceAttributes.get(PacmanRuleConstants.REGION_ATTR)); <line23> if (!resourceAttributes.containsKey(PacmanRuleConstants.TAGS_APP) <line24> || StringUtils.isNullOrEmpty(resourceAttributes.get(PacmanRuleConstants.TAGS_APP)) <line25> || resourceAttributes <line26> .get(PacmanRuleConstants.TAGS_APP) <line27> .equals(PacmanRuleConstants.UNKNOWN)) { <line28> boolean isEbsWithEc2Exists = false; <line29> try { <line30> isEbsWithEc2Exists = <line31> PacmanUtils.checkResourceIdFromElasticSearch( <line32> volumeId, ebsUrl, PacmanRuleConstants.VOLUME_ID, region); <line33> } catch (Exception e) { <line34> throw new RuleExecutionFailedExeption(""unable to determine"" + e); <line35> } <line36> if (!isEbsWithEc2Exists) { <line37> annotation = Annotation.buildAnnotation(ruleParam, Annotation.Type.ISSUE); <line38> annotation.put( <line39> PacmanSdkConstants.DESCRIPTION, <line40> ""Untagged EBS volume's which are not attached to any instance found!!""); <line41> annotation.put(PacmanRuleConstants.SEVERITY, severity); <line42> annotation.put(PacmanRuleConstants.SUBTYPE, Annotation.Type.RECOMMENDATION.toString()); <line43> annotation.put(PacmanRuleConstants.CATEGORY, category); <line44> issue.put( <line45> PacmanRuleConstants.VIOLATION_REASON, <line46> ""Untagged EBS volume's which are not attached to any instance found""); <line47> issueList.add(issue); <line48> annotation.put(""issueDetails"", issueList.toString()); <line49> return new RuleResult( <line50> PacmanSdkConstants.STATUS_FAILURE, PacmanRuleConstants.FAILURE_MESSAGE, annotation); <line51> } <line52> } <line53> } <line54> return new RuleResult(PacmanSdkConstants.STATUS_SUCCESS, PacmanRuleConstants.SUCCESS_MESSAGE); <line55> } <line56> } <line57> "	<line2>, <line18>, <line34>, <line49>, <line54>
6185	"public class A { <line0> @BeforeClass <line1> public static void setup() throws Exception { <line2> Configuration conf = new Configuration(); <line3> conf.setInt(HttpServer.HTTP_MAX_THREADS, MAX_THREADS); <line4> server = createTestServer(conf); <line5> server.addUnprivilegedServlet(""echo"", ""/echo"", EchoServlet.class); <line6> server.addUnprivilegedServlet(""echomap"", ""/echomap"", EchoMapServlet.class); <line7> server.addUnprivilegedServlet(""htmlcontent"", ""/htmlcontent"", HtmlContentServlet.class); <line8> server.addUnprivilegedServlet(""longheader"", ""/longheader"", LongHeaderServlet.class); <line9> server.addJerseyResourcePackage(JerseyResource.class.getPackage().getName(), ""/jersey/*""); <line10> server.start(); <line11> baseUrl = getServerURL(server); <line12> } <line13> } <line14> "	<line12>
6186	public class A { <line0> public void commit() { <line1> fireTransactionEvent(TransactionState.COMMITTING, false); <line2> getDbSqlSession().commit(); <line3> fireTransactionEvent(TransactionState.COMMITTED, true); <line4> } <line5> } <line6> 	<line1>, <line2>, <line3>
6187	"public class A { <line0> @Override <line1> public void stopMonitoring( <line2> final String handlerId, <line3> final AlertHandlerPriority handlerPriority, <line4> final String environmentId) <line5> throws EnvironmentManagerException { <line6> Preconditions.checkArgument(!StringUtils.isBlank(handlerId), ""Invalid alert handler id.""); <line7> Preconditions.checkNotNull(handlerPriority, ""Invalid alert priority.""); <line8> try { <line9> LocalEnvironment environment = environmentService.find(environmentId); <line10> environment.removeAlertHandler(new EnvironmentAlertHandlerImpl(handlerId, handlerPriority)); <line11> update(environment); <line12> } catch (Exception e) { <line13> throw new EnvironmentManagerException(e.getMessage(), e); <line14> } <line15> } <line16> } <line17> "	<line13>
6188	public class A { <line0> @Test <line1> public void zeroCache() throws Exception { <line2> cache = FileCache.build(0, root, loader, null); <line3> closer.register(cache); <line4> File f = createFile(0, loader, cache, folder); <line5> cache.put(ID_PREFIX + 0, f); <line6> assertNull(cache.getIfPresent(ID_PREFIX + 0)); <line7> assertNull(cache.get(ID_PREFIX + 0)); <line8> assertEquals(0, cache.getStats().getMaxTotalWeight()); <line9> cache.invalidate(ID_PREFIX + 0); <line10> assertFalse(cache.containsKey(ID_PREFIX + 0)); <line11> cache.close(); <line12> } <line13> } <line14> 	<line2>, <line12>
6189	"public class A { <line0> public List<Object[]> fetchMajorCodeAndBENextYrApproved( <line1> final Budget topBudget, <line2> final BudgetDetail budgetDetail, <line3> final CFunction function, <line4> final Position pos) { <line5> if (LOGGER.isInfoEnabled()) <line6> StringBuffer query = new StringBuffer(); <line7> String functionCondition1 = """"; <line8> String functionCondition2 = """"; <line9> if (function != null) { <line10> functionCondition1 = "" AND bd1.function = "" + function.getId(); <line11> functionCondition2 = "" AND bd2.function = "" + function.getId(); <line12> } <line13> query = <line14> query.append( <line15> ""SELECT cao.majorcode, SUM(bd2.approvedamount) FROM egf_budgetdetail bd1,"" <line16> + "" egf_budgetdetail bd2, egf_budgetgroup bg, egf_budget b1, egf_budget b2,"" <line17> + "" chartofaccounts cao, eg_wf_states wf WHERE bd1.budget =b1.id AND bd2.budget"" <line18> + "" =b2.id AND b1.financialyearid="" <line19> + topBudget.getFinancialYear().getId() <line20> + "" AND b1.MATERIALIZEDPATH LIKE '"" <line21> + topBudget.getMaterializedPath() <line22> + ""%' AND bd2.budgetgroup =bg.id  AND cao.id =bg.mincode AND cao.id =bg.maxcode AND"" <line23> + "" bg.majorcode IS NULL AND bd2.executing_department = "" <line24> + budgetDetail.getExecutingDepartment().getId() <line25> + functionCondition2 <line26> + "" AND bd1.executing_department = "" <line27> + budgetDetail.getExecutingDepartment().getId() <line28> + functionCondition1 <line29> + "" AND bd1.uniqueno = bd2.uniqueno AND b2.reference_budget = b1.id AND"" <line30> + "" (wf.value='END' OR wf.owner_pos="" <line31> + pos.getId() <line32> + "") AND bd1.state_id = wf.id GROUP BY cao.majorcode""); <line33> final List<Object[]> result = getSession().createSQLQuery(query.toString()).list(); <line34> return result; <line35> } <line36> } <line37> "	<line6>, <line34>
6190	public class A { <line0> public void mergeStatistics(Statistics stats) { <line1> if (this.getClass() == stats.getClass()) { <line2> if (stats.startTime < this.startTime) { <line3> this.startTime = stats.startTime; <line4> } <line5> if (stats.endTime > this.endTime) { <line6> this.endTime = stats.endTime; <line7> } <line8> this.count += stats.count; <line9> mergeStatisticsValue(stats); <line10> isEmpty = false; <line11> } else { <line12> String thisClass = this.getClass().toString(); <line13> String statsClass = stats.getClass().toString(); <line14> throw new StatisticsClassException(this.getClass(), stats.getClass()); <line15> } <line16> } <line17> } <line18> 	<line14>
6191	public class A { <line0> protected boolean hasTeamUser(Object object) { <line1> User user = (User) object; <line2> try { <line3> return UserLocalServiceUtil.hasTeamUser(_team.getTeamId(), user.getUserId()); <line4> } catch (Exception exception) { <line5> return false; <line6> } <line7> } <line8> } <line9> 	<line5>
6192	"public class A { <line0> public String validatePostLogoutRedirectUri(String clientId, String postLogoutRedirectUri) { <line1> boolean isBlank = Util.isNullOrEmpty(postLogoutRedirectUri); <line2> Client client = clientService.getClient(clientId); <line3> if (client != null) { <line4> String[] postLogoutRedirectUris = client.getPostLogoutRedirectUris(); <line5> return validatePostLogoutRedirectUri(postLogoutRedirectUri, postLogoutRedirectUris); <line6> } <line7> if (!isBlank) { <line8> throw errorResponseFactory.createWebApplicationException( <line9> Response.Status.BAD_REQUEST, <line10> EndSessionErrorResponseType.POST_LOGOUT_URI_NOT_ASSOCIATED_WITH_CLIENT, <line11> ""`post_logout_redirect_uri` is not added to associated client.""); <line12> } <line13> return null; <line14> } <line15> } <line16> "	<line5>
6193	"public class A { <line0> public void setStore(BlobStore store) { <line1> blobStoreStateLock.lock(); <line2> try { <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> if (store == null) { <line6> throw new NullPointerException(""Input BlobStore cannot be null""); <line7> } <line8> this.store = store; <line9> } finally { <line10> blobStoreStateLock.unlock(); <line11> } <line12> } <line13> } <line14> "	<line4>
6194	public class A { <line0> @Override <line1> public void onNext(ThreadSnapshot snapshot) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> final ProfileThreadSnapshotRecord record = new ProfileThreadSnapshotRecord(); <line5> record.setTaskId(snapshot.getTaskId()); <line6> record.setSegmentId(snapshot.getTraceSegmentId()); <line7> record.setDumpTime(snapshot.getTime()); <line8> record.setSequence(snapshot.getSequence()); <line9> record.setStackBinary(snapshot.getStack().toByteArray()); <line10> record.setTimeBucket(TimeBucket.getRecordTimeBucket(snapshot.getTime())); <line11> RecordStreamProcessor.getInstance().in(record); <line12> } <line13> } <line14> 	<line3>
6195	"public class A { <line0> private void acquirePins() { <line1> if (this.gpioService != null) { <line2> logger.info(""______________________________""); <line3> Map<Integer, String> gpios = this.gpioService.getAvailablePins(); <line4> for (Entry<Integer, String> e : gpios.entrySet()) { <line5> } <line6> getPins(); <line7> } <line8> } <line9> } <line10> "	<line3>, <line5>, <line6>
6196	public class A { <line0> private void delayedRebalanceSchedule( <line1> ResourceControllerDataProvider clusterData, <line2> Set<String> delayedActiveNodes, <line3> Set<String> resourceSet) { <line4> if (_manager != null) { <line5> ClusterConfig clusterConfig = clusterData.getClusterConfig(); <line6> boolean delayedRebalanceEnabled = DelayedRebalanceUtil.isDelayRebalanceEnabled(clusterConfig); <line7> Set<String> offlineOrDisabledInstances = new HashSet<>(delayedActiveNodes); <line8> offlineOrDisabledInstances.removeAll(clusterData.getEnabledLiveInstances()); <line9> for (String resource : resourceSet) { <line10> DelayedRebalanceUtil.setRebalanceScheduler( <line11> resource, <line12> delayedRebalanceEnabled, <line13> offlineOrDisabledInstances, <line14> clusterData.getInstanceOfflineTimeMap(), <line15> clusterData.getLiveInstances().keySet(), <line16> clusterData.getInstanceConfigMap(), <line17> clusterConfig.getRebalanceDelayTime(), <line18> clusterConfig, <line19> _manager); <line20> } <line21> } else { <line22> } <line23> } <line24> } <line25> 	<line22>
6197	public class A { <line0> private void sendZip(Iterable<String> testJars, DataOutputStream outputStream) <line1> throws IOException { <line2> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line3> ZipOutputStream zipOutputStream = new ZipOutputStream(out); <line4> for (String jar : testJars) { <line5> File file = new File(jar); <line6> FileInputStream in = new FileInputStream(file); <line7> zipOutputStream.putNextEntry(new ZipEntry(file.getName())); <line8> IOUtils.copy(in, zipOutputStream); <line9> in.close(); <line10> zipOutputStream.closeEntry(); <line11> } <line12> zipOutputStream.close(); <line13> byte[] bs = out.toByteArray(); <line14> outputStream.writeInt(bs.length); <line15> outputStream.write(bs); <line16> } <line17> } <line18> 	<line5>
6198	public class A { <line0> @Override <line1> public boolean eventExecuted() { <line2> try { <line3> Thread.sleep(sleepTime); <line4> return true; <line5> } catch (InterruptedException e) { <line6> } <line7> return false; <line8> } <line9> } <line10> 	<line4>, <line6>
6199	public class A { <line0> @Override <line1> public void channelLinked(ChannelUID channelUID) { <line2> synchronized (this) { <line3> if (!verifyChannel(channelUID)) { <line4> return; <line5> } <line6> String channelGroup = channelUID.getGroupId(); <line7> if (channelGroup != null && channelGroup.equals(CHANNEL_GROUP_INPUT)) { <line8> if (pinStateHolder.getInputPin(channelUID) != null) { <line9> return; <line10> } <line11> GpioPinDigitalInput inputPin = initializeInputPin(channelUID); <line12> pinStateHolder.addInputPin(inputPin, channelUID); <line13> } <line14> super.channelLinked(channelUID); <line15> } <line16> } <line17> } <line18> 	<line3>
6200	"public class A { <line0> private String getAPIKey(Document doc) { <line1> Pattern p; <line2> Matcher m; <line3> p = Pattern.compile(""root.YUI_config.flickr.api.site_key = \""([a-zA-Z0-9]*)\"";""); <line4> for (Element e : doc.select(""script"")) { <line5> m = p.matcher(e.html()); <line6> if (m.find()) { <line7> return m.group(1); <line8> } <line9> } <line10> sendUpdate(RipStatusMessage.STATUS.DOWNLOAD_WARN, ""Unable to extract api key from flickr""); <line11> sendUpdate(RipStatusMessage.STATUS.DOWNLOAD_WARN, ""Using hardcoded api key""); <line12> return ""935649baf09b2cc50628e2b306e4da5d""; <line13> } <line14> } <line15> "	<line7>, <line10>
6201	"public class A { <line0> private static SimpleOrderedMap<Object> getDocumentFieldsInfo( <line1> Document doc, int docId, IndexReader reader, IndexSchema schema) throws IOException { <line2> final CharsRefBuilder spare = new CharsRefBuilder(); <line3> SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>(); <line4> for (Object o : doc.getFields()) { <line5> Field field = (Field) o; <line6> SimpleOrderedMap<Object> f = new SimpleOrderedMap<>(); <line7> SchemaField sfield = schema.getFieldOrNull(field.name()); <line8> FieldType ftype = (sfield == null) ? null : sfield.getType(); <line9> f.add(""type"", (ftype == null) ? null : ftype.getTypeName()); <line10> f.add(""schema"", getFieldFlags(sfield)); <line11> f.add(""flags"", getFieldFlags(field)); <line12> Term t = <line13> new Term( <line14> field.name(), ftype != null ? ftype.storedToIndexed(field) : field.stringValue()); <line15> f.add(""value"", (ftype == null) ? null : ftype.toExternal(field)); <line16> f.add(""internal"", field.stringValue()); <line17> BytesRef bytes = field.binaryValue(); <line18> if (bytes != null) { <line19> f.add(""binary"", Base64.byteArrayToBase64(bytes.bytes, bytes.offset, bytes.length)); <line20> } <line21> f.add(""boost"", field.boost()); <line22> f.add(""docFreq"", t.text() == null ? 0 : reader.docFreq(t)); <line23> if (field.fieldType().storeTermVectors()) { <line24> try { <line25> Terms v = reader.getTermVector(docId, field.name()); <line26> if (v != null) { <line27> SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<>(); <line28> final TermsEnum termsEnum = v.iterator(); <line29> BytesRef text; <line30> while ((text = termsEnum.next()) != null) { <line31> final int freq = (int) termsEnum.totalTermFreq(); <line32> spare.copyUTF8Bytes(text); <line33> tfv.add(spare.toString(), freq); <line34> } <line35> f.add(""termVector"", tfv); <line36> } <line37> } catch (Exception ex) { <line38> } <line39> } <line40> finfo.add(field.name(), f); <line41> } <line42> return finfo; <line43> } <line44> } <line45> "	<line38>
6202	"public class A { <line0> public static AbstractLockingManagement getLockingManagement( <line1> final GeoWavePluginConfig pluginConfig) { <line2> synchronized (LOCKING_MANAGEMENT_CLASS_LCK) { <line3> final String val = System.getenv(LOCKING_MANAGEMENT_CLASS); <line4> if (val == null) { <line5> return new MemoryLockManager(pluginConfig); <line6> } else { <line7> try { <line8> final Class<? extends AbstractLockingManagement> lockManagerClass = <line9> (Class<? extends AbstractLockingManagement>) Class.forName(val); <line10> if (!AbstractLockingManagement.class.isAssignableFrom(lockManagerClass)) { <line11> throw new IllegalArgumentException(""Invalid LockManagement class "" + val); <line12> } else { <line13> final Constructor cons = lockManagerClass.getConstructor(GeoWavePluginConfig.class); <line14> return (AbstractLockingManagement) cons.newInstance(pluginConfig); <line15> } <line16> } catch (final Exception ex) { <line17> return new MemoryLockManager(pluginConfig); <line18> } <line19> } <line20> } <line21> } <line22> } <line23> "	<line17>
6203	"public class A { <line0> public static File captureScreenShot() { <line1> File src = webDriver.getScreenshotAs(OutputType.FILE); <line2> File screenshotFile = <line3> new File(System.getProperty(""user.dir"") + ""/target/Selenium/"" + ""screen.png""); <line4> try { <line5> FileUtils.copyFile(src, screenshotFile); <line6> } catch (IOException e) { <line7> } <line8> return screenshotFile; <line9> } <line10> } <line11> "	<line7>
6204	public class A { <line0> private <T> T iterate(String path, WalkCommand<T> command) throws IOException { <line1> Lock readLock = repositoryLock.readLock(); <line2> try { <line3> readLock.lock(); <line4> org.eclipse.jgit.lib.Repository repository = git.getRepository(); <line5> if (isEmpty()) { <line6> return command.apply(repository, null, path); <line7> } <line8> try (RevWalk walk = new RevWalk(repository)) { <line9> ObjectId branchId = resolveBranchId(); <line10> if (branchId == null) { <line11> return command.apply(repository, null, path); <line12> } <line13> RevCommit commit = walk.parseCommit(branchId); <line14> RevTree tree = commit.getTree(); <line15> try (TreeWalk rootWalk = buildTreeWalk(repository, path, tree)) { <line16> return command.apply(repository, rootWalk, path); <line17> } catch (FileNotFoundException e) { <line18> return command.apply(repository, null, path); <line19> } <line20> } <line21> } catch (IOException e) { <line22> throw e; <line23> } catch (Exception e) { <line24> throw new IOException(e); <line25> } finally { <line26> readLock.unlock(); <line27> } <line28> } <line29> } <line30> 	<line3>, <line27>
6205	public class A { <line0> public void submit() { <line1> this.reef.submit(this.driverConfig); <line2> } <line3> } <line4> 	<line1>
6206	public class A { <line0> private void writeConfig( <line1> NetInterfaceConfig<? extends NetInterfaceAddressConfig> netInterfaceConfig) <line2> throws KuraException { <line3> NetInterfaceType type = netInterfaceConfig.getType(); <line4> if (type != NetInterfaceType.ETHERNET <line5> && type != NetInterfaceType.WIFI <line6> && type != NetInterfaceType.LOOPBACK) { <line7> return; <line8> } <line9> netConfigManager.write(netInterfaceConfig); <line10> } <line11> } <line12> 	<line7>
6207	"public class A { <line0> @Override <line1> public String validateRestore(UserCredentials credentials) { <line2> if (credentials == null || credentials.getUserInfo() == null) { <line3> return ""no_user_credentials""; <line4> } <line5> if (credentials.getUserInfo().getEmail() == null <line6> || !ValidationUtils.emailIsValid(credentials.getUserInfo().getEmail())) { <line7> return ""user_does_not_have_valid_email""; <line8> } <line9> if (!emailMessageSender.isConfigured()) { <line10> return ""email_not_configured_for_system""; <line11> } <line12> return null; <line13> } <line14> } <line15> "	<line3>, <line7>, <line10>
6208	public class A { <line0> @Override <line1> public void endpointAdded(final ZigBeeEndpoint endpoint) { <line2> final DeviceFactory factory = context.getBestDeviceProxyFactory(endpoint); <line3> if (factory == null) { <line4> return; <line5> } <line6> final DeviceBase haDevice = factory.getInstance(endpoint); <line7> context.addDevice(haDevice); <line8> } <line9> } <line10> 	<line4>, <line8>
6209	"public class A { <line0> public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter typeConverter) { <line1> TypeConverter converter = typeMappings.get(toType, fromType); <line2> if (typeConverter != converter) { <line3> boolean add = true; <line4> if (converter != null) { <line5> if (typeConverterExists == TypeConverterExists.Override) { <line6> CamelLogger logger = new CamelLogger(LOG, typeConverterExistsLoggingLevel); <line7> logger.log(""Overriding type converter from: "" + converter + "" to: "" + typeConverter); <line8> } else if (typeConverterExists == TypeConverterExists.Ignore) { <line9> CamelLogger logger = new CamelLogger(LOG, typeConverterExistsLoggingLevel); <line10> logger.log( <line11> ""Ignoring duplicate type converter from: "" + converter + "" to: "" + typeConverter); <line12> add = false; <line13> } else { <line14> throw new TypeConverterExistsException(toType, fromType); <line15> } <line16> } <line17> if (add) { <line18> typeMappings.put(toType, fromType, typeConverter); <line19> } <line20> } <line21> } <line22> } <line23> "	<line1>
6210	public class A { <line0> private PropogatingCombiner getAggregator(Key key) { <line1> PropogatingCombiner aggr = aggMap.get(key.getColumnFamilyData()); <line2> if (null == aggr) { <line3> if (log.isTraceEnabled()) { <line4> } <line5> aggr = defaultAgg; <line6> } <line7> if (log.isTraceEnabled()) { <line8> } <line9> if (log.isTraceEnabled()) { <line10> } <line11> return aggr; <line12> } <line13> } <line14> 	<line4>, <line8>, <line10>
6211	"public class A { <line0> public CreateVersionPage selectProjectType(final String projectType) { <line1> clickElement( <line2> (WebElement) <line3> waitForAMoment() <line4> .withMessage(""project type found"") <line5> .until( <line6> webDriver -> { <line7> for (WebElement item : <line8> readyElement(projectTypeSelection).findElements(By.tagName(""li""))) { <line9> if (item.findElement(By.tagName(""label"")) <line10> .getText() <line11> .startsWith(projectType)) { <line12> return item; <line13> } <line14> } <line15> return null; <line16> })); <line17> return new CreateVersionPage(getDriver()); <line18> } <line19> } <line20> "	<line1>
6212	"public class A { <line0> private void close(String stagedRepositoryId) { <line1> Map<String, Object> body = new HashMap<>(); <line2> body.put(""data"", Collections.singletonMap(""stagedRepositoryId"", stagedRepositoryId)); <line3> this.restTemplate.postForEntity( <line4> String.format(NEXUS_STAGING_PATH + ""profiles/%s/finish"", this.stagingProfileId), <line5> body, <line6> Void.class); <line7> while (true) { <line8> StagingRepository repository = <line9> this.restTemplate.getForObject( <line10> NEXUS_STAGING_PATH + ""repository/"" + stagedRepositoryId, StagingRepository.class); <line11> if (!repository.transitioning) { <line12> if (""open"".equals(repository.type)) { <line13> logFailures(stagedRepositoryId); <line14> throw new RuntimeException(""Close failed""); <line15> } <line16> return; <line17> } <line18> try { <line19> Thread.sleep(this.pollingInterval.toMillis()); <line20> } catch (InterruptedException ex) { <line21> Thread.currentThread().interrupt(); <line22> throw new RuntimeException(""Interrupted while waiting for staging repository to close"", ex); <line23> } <line24> } <line25> } <line26> } <line27> "	<line7>
6213	"public class A { <line0> public void removeFromSet(final String inKey, final Long inValue) { <line1> if (log.isTraceEnabled()) { <line2> } <line3> CASMutation<Object> mutation = <line4> new CASMutation<Object>() { <line5> @SuppressWarnings(""unchecked"") <line6> public Object getNewValue(final Object current) { <line7> Set<Long> set = (Set<Long>) current; <line8> HashSet<Long> hashSet = new HashSet<Long>(set); <line9> hashSet.remove(inValue); <line10> return hashSet; <line11> } <line12> }; <line13> SerializingTranscoder transcoder = new SerializingTranscoder(); <line14> CASMutator<Object> mutator = new CASMutator<Object>(client, transcoder); <line15> try { <line16> mutator.cas(inKey, new HashSet<Long>(), MAX_EXPIRATION_TIME, mutation); <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> "	<line2>, <line18>
6214	"public class A { <line0> @ApiOperation( <line1> value = ""Returns the rendered form for a specified task instance."", <line2> response = String.class, <line3> code = 200) <line4> @ApiResponses( <line5> value = { <line6> @ApiResponse(code = 500, message = ""Unexpected error""), <line7> @ApiResponse(code = 404, message = ""Task, form or Container Id not found"") <line8> }) <line9> @GET <line10> @Path(TASK_FORM_CONTENT_GET_URI) <line11> @Produces({MediaType.TEXT_HTML}) <line12> public Response getTaskRenderedForm( <line13> @javax.ws.rs.core.Context HttpHeaders headers, <line14> @ApiParam( <line15> value = ""container id that task instance belongs to"", <line16> required = true, <line17> example = ""evaluation_1.0.0-SNAPSHOT"") <line18> @PathParam(CONTAINER_ID) <line19> String containerId, <line20> @ApiParam( <line21> value = ""identifier of task instance that form should be fetched for"", <line22> required = true, <line23> example = ""123"") <line24> @PathParam(TASK_INSTANCE_ID) <line25> Long taskId, <line26> @ApiParam( <line27> value = ""optional renderer name that the form should be rendered with"", <line28> required = false) <line29> @QueryParam(""renderer"") <line30> @DefaultValue(""patternfly"") <line31> String renderer) { <line32> Variant variant = getVariant(headers); <line33> Header conversationIdHeader = buildConversationIdHeader(containerId, context, headers); <line34> try { <line35> String renderedForm = formRendererBase.getTaskRenderedForm(renderer, containerId, taskId); <line36> if (renderedForm == null) { <line37> return Response.status(Status.NOT_FOUND).build(); <line38> } <line39> return Response.ok().entity(renderedForm).build(); <line40> } catch (PermissionDeniedException e) { <line41> return permissionDenied( <line42> MessageFormat.format(TASK_PERMISSION_ERROR, taskId), variant, conversationIdHeader); <line43> } catch (TaskNotFoundException e) { <line44> return notFound( <line45> MessageFormat.format(TASK_INSTANCE_NOT_FOUND, taskId), variant, conversationIdHeader); <line46> } catch (DeploymentNotFoundException e) { <line47> return notFound( <line48> MessageFormat.format(CONTAINER_NOT_FOUND, containerId), variant, conversationIdHeader); <line49> } catch (IllegalArgumentException | IllegalStateException e) { <line50> return notFound(e.getMessage(), variant, conversationIdHeader); <line51> } catch (Exception e) { <line52> return internalServerError(errorMessage(e), variant, conversationIdHeader); <line53> } <line54> } <line55> } <line56> "	<line52>
6215	"public class A { <line0> static <K, V, OutputT, W extends BoundedWindow> JavaPairRDD<ByteArray, OutputT> bringWindowToKey( <line1> JavaRDD<WindowedValue<KV<K, V>>> rdd, <line2> Coder<K> keyCoder, <line3> Coder<W> windowCoder, <line4> SerializableFunction<WindowedValue<KV<K, V>>, OutputT> mappingFn) { <line5> if (!isKeyAndWindowCoderConsistentWithEquals(keyCoder, windowCoder)) { <line6> } <line7> return rdd.flatMapToPair( <line8> (WindowedValue<KV<K, V>> windowedValue) -> { <line9> final byte[] keyBytes = <line10> CoderHelpers.toByteArray(windowedValue.getValue().getKey(), keyCoder); <line11> return Iterators.transform( <line12> windowedValue.explodeWindows().iterator(), <line13> item -> { <line14> Objects.requireNonNull(item, ""Exploded window can not be null.""); <line15> @SuppressWarnings(""unchecked"") <line16> final W window = (W) Iterables.getOnlyElement(item.getWindows()); <line17> final byte[] windowBytes = CoderHelpers.toByteArray(window, windowCoder); <line18> WindowedValue<KV<K, V>> valueOut = <line19> WindowedValue.of(item.getValue(), item.getTimestamp(), window, item.getPane()); <line20> final ByteArray windowedKey = new ByteArray(Bytes.concat(keyBytes, windowBytes)); <line21> return new Tuple2<>(windowedKey, mappingFn.apply(valueOut)); <line22> }); <line23> }); <line24> } <line25> } <line26> "	<line6>
6216	public class A { <line0> private Optional<DataSourceInfo> dsInfoForDataSource(final @NonNull DataSource dataSource) { <line1> try (val connection = dataSource.getConnection()) { <line2> return Optional.ofNullable(connection.getMetaData()).map(DataSourceInfo::fromMetaData); <line3> } catch (SQLException e) { <line4> } <line5> return Optional.empty(); <line6> } <line7> } <line8> 	<line4>
6217	"public class A { <line0> @SuppressWarnings(""IfMayBeConditional"") <line1> public List<List<GridNode>> calculate(long topVer, GridDiscoveryEvent discoEvt) { <line2> if (log.isDebugEnabled()) <line3> GridAffinityAssignment prev = affCache.get(topVer - 1); <line4> List<GridNode> sorted; <line5> if (ctx.isLocal()) sorted = Collections.singletonList(ctx.localNode()); <line6> else { <line7> Collection<GridNode> nodes = ctx.discovery().cacheAffinityNodes(cacheName, topVer); <line8> sorted = sort(nodes); <line9> } <line10> List<List<GridNode>> prevAssignment = prev == null ? null : prev.assignment(); <line11> List<List<GridNode>> assignment; <line12> if (prevAssignment != null && discoEvt != null) { <line13> GridCacheDistributionMode distroMode = U.distributionMode(discoEvt.eventNode(), ctx.name()); <line14> if (distroMode == null || distroMode == CLIENT_ONLY || distroMode == NEAR_ONLY) <line15> assignment = prevAssignment; <line16> else <line17> assignment = <line18> aff.assignPartitions( <line19> new GridCacheAffinityFunctionContextImpl( <line20> sorted, prevAssignment, discoEvt, topVer, backups)); <line21> } else <line22> assignment = <line23> aff.assignPartitions( <line24> new GridCacheAffinityFunctionContextImpl( <line25> sorted, prevAssignment, discoEvt, topVer, backups)); <line26> assert assignment != null; <line27> GridAffinityAssignment updated = new GridAffinityAssignment(topVer, assignment); <line28> updated = F.addIfAbsent(affCache, topVer, updated); <line29> while (true) { <line30> GridAffinityAssignment headItem = head.get(); <line31> if (headItem.topologyVersion() >= topVer) break; <line32> if (head.compareAndSet(headItem, updated)) break; <line33> } <line34> for (Map.Entry<Long, AffinityReadyFuture> entry : readyFuts.entrySet()) { <line35> if (entry.getKey() <= topVer) { <line36> if (log.isDebugEnabled()) <line37> entry.getValue().onDone(topVer); <line38> } <line39> } <line40> return updated.assignment(); <line41> } <line42> } <line43> "	<line3>, <line37>
6218	public class A { <line0> @Override <line1> protected PROXYPOJOCLASS createObjectInternal( <line2> final POJOCLASS object, <line3> final EntityManager entityManager, <line4> final String transactionType, <line5> final PersistenceType persistenceType) <line6> throws DMPPersistenceException { <line7> final String uri = object.getUri(); <line8> final POJOCLASS existingObject = getObjectByUri(uri, entityManager); <line9> final POJOCLASS newObject; <line10> if (null == existingObject) { <line11> newObject = createNewObject(object.getUuid(), uri); <line12> updateObjectInternal(object, newObject); <line13> final Optional<POJOCLASS> optionalPersistentObject = <line14> persistObject(newObject, entityManager, persistenceType); <line15> final POJOCLASS persistentObject = <line16> determinePersistentObject(newObject, optionalPersistentObject); <line17> return createNewProxyObject(persistentObject); <line18> } else { <line19> return createNewProxyObject(existingObject, RetrievalType.RETRIEVED); <line20> } <line21> } <line22> } <line23> 	<line19>
6219	public class A { <line0> @Override <line1> protected void writeMultipleRecordsInternal() throws Exception { <line2> if (batchSize > 1) { <line3> BoundStatement boundStatement = pstmt.bind(); <line4> for (int rowIndex = 0; rowIndex < rows.size(); rowIndex++) { <line5> for (int columnIndex = 0; columnIndex < columnMeta.size(); columnIndex++) { <line6> Object value = rows.get(rowIndex).getField(columnIndex); <line7> CassandraUtil.bindColumn( <line8> boundStatement, columnIndex, columnTypes.get(columnIndex), value); <line9> } <line10> if ((rowIndex % 1000) == 0) { <line11> } <line12> if (asyncWrite) { <line13> unConfirmedWrite.add(session.executeAsync(boundStatement)); <line14> if (unConfirmedWrite.size() >= batchSize) { <line15> for (ResultSetFuture write : unConfirmedWrite) { <line16> write.getUninterruptibly(10000, TimeUnit.MILLISECONDS); <line17> } <line18> unConfirmedWrite.clear(); <line19> } <line20> } else { <line21> bufferedWrite.add(boundStatement); <line22> if (bufferedWrite.size() >= batchSize) { <line23> BatchStatement batchStatement = new BatchStatement(BatchStatement.Type.UNLOGGED); <line24> batchStatement.addAll(bufferedWrite); <line25> session.execute(batchStatement); <line26> bufferedWrite.clear(); <line27> } <line28> } <line29> } <line30> if (unConfirmedWrite != null && unConfirmedWrite.size() > 0) { <line31> for (ResultSetFuture write : unConfirmedWrite) { <line32> write.getUninterruptibly(10000, TimeUnit.MILLISECONDS); <line33> } <line34> unConfirmedWrite.clear(); <line35> } <line36> if (bufferedWrite != null && bufferedWrite.size() > 0) { <line37> BatchStatement batchStatement = new BatchStatement(BatchStatement.Type.UNLOGGED); <line38> batchStatement.addAll(bufferedWrite); <line39> session.execute(batchStatement); <line40> bufferedWrite.clear(); <line41> } <line42> } <line43> } <line44> } <line45> 	<line11>
6220	public class A { <line0> public boolean removeMessageListener(Object topic, @Nullable GridMessageListener lsnr) { <line1> assert topic != null; <line2> boolean rmv = true; <line3> Collection<GridCommunicationMessageSet> msgSets = null; <line4> if (lsnr == null) { <line5> closedTopics.add(topic); <line6> lsnr = listenerRemove0(topic); <line7> rmv = lsnr != null; <line8> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line9> if (map != null) msgSets = map.values(); <line10> } else { <line11> for (; ; ) { <line12> GridMessageListener lsnrs = listenerGet0(topic); <line13> if (lsnrs == null) { <line14> closedTopics.add(topic); <line15> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line16> if (map != null) msgSets = map.values(); <line17> rmv = false; <line18> break; <line19> } else { <line20> boolean empty = false; <line21> if (!(lsnrs instanceof ArrayListener)) { <line22> if (lsnrs.equals(lsnr)) { <line23> if (!listenerRemove0(topic, lsnrs)) continue; <line24> empty = true; <line25> } else rmv = false; <line26> } else { <line27> ArrayListener arrLsnr = (ArrayListener) lsnrs; <line28> if (arrLsnr.remove(lsnr)) empty = arrLsnr.isEmpty(); <line29> else rmv = false; <line30> if (empty) listenerRemove0(topic, lsnrs); <line31> } <line32> if (empty) { <line33> closedTopics.add(topic); <line34> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line35> if (map != null) msgSets = map.values(); <line36> } <line37> break; <line38> } <line39> } <line40> } <line41> if (msgSets != null) <line42> for (GridCommunicationMessageSet msgSet : msgSets) ctx.timeout().removeTimeoutObject(msgSet); <line43> if (rmv && log.isDebugEnabled()) <line44> if (lsnr instanceof ArrayListener) { <line45> for (GridMessageListener childLsnr : ((ArrayListener) lsnr).arr) closeListener(childLsnr); <line46> } else closeListener(lsnr); <line47> return rmv; <line48> } <line49> } <line50> 	<line44>
6221	"public class A { <line0> @Override <line1> public D create(final D dto) { <line2> Assert.isNull(dto.getId(), ""The DTO identifier must be null for creation.""); <line3> beforeCreate(dto); <line4> dto.setId(generateSuperId()); <line5> final E entity = convertFromDtoToEntity(dto); <line6> beforeCreate(entity); <line7> final E createdEntity = getRepository().save(entity); <line8> return convertFromEntityToDto(createdEntity); <line9> } <line10> } <line11> "	<line2>
6222	public class A { <line0> @Override <line1> public Set<RegisteredCredential> lookupAll(final ByteArray credentialId) { <line2> return Collections.emptySet(); <line3> } <line4> } <line5> 	<line2>
6223	"public class A { <line0> private void startBundles(List<Bundle> bundlesInstalled, boolean startBundles) { <line1> try { <line2> if (startBundles) { <line3> for (Bundle bundle : bundlesInstalled) { <line4> if (bundle.getState() != Bundle.ACTIVE && !isFragmentBundle(bundle)) { <line5> bundle.start(); <line6> } <line7> } <line8> } <line9> } catch (Exception e) { <line10> throw new MotechException(""Error while starting bundle."", e); <line11> } <line12> } <line13> } <line14> "	<line3>, <line5>
6224	"public class A { <line0> @Override <line1> public void onSubscriptionTransferFailed( <line2> final UaSubscription subscription, final StatusCode statusCode) { <line3> handleConnectionFailue(new RuntimeException(""Subscription failed to reconnect"")); <line4> } <line5> } <line6> "	<line3>
6225	"public class A { <line0> public String startProcessWithCorrelation( <line1> String containerId, <line2> String processId, <line3> String correlationKey, <line4> String payload, <line5> String marshallingType) { <line6> containerId = context.getContainerId(containerId, ContainerLocatorProvider.get().getLocator()); <line7> definitionService.getProcessDefinition(containerId, processId); <line8> Map<String, Object> parameters = <line9> marshallerHelper.unmarshal(containerId, payload, marshallingType, Map.class); <line10> String[] correlationProperties = correlationKey.split("":""); <line11> CorrelationKey actualCorrelationKey = <line12> correlationKeyFactory.newCorrelationKey(Arrays.asList(correlationProperties)); <line13> Long processInstanceId = <line14> processService.startProcess(containerId, processId, actualCorrelationKey, parameters); <line15> return marshallerHelper.marshal(containerId, marshallingType, processInstanceId); <line16> } <line17> } <line18> "	<line8>, <line13>
6226	"public class A { <line0> protected void instantiateAdjuncts(BrooklynObjectInstantiator instantiator) { <line1> checkEnteringPhase(5); <line2> if (rebindManager.persistPoliciesEnabled) { <line3> logRebindingDebug(""RebindManager instantiating policies: {}"", memento.getPolicyIds()); <line4> for (PolicyMemento policyMemento : memento.getPolicyMementos().values()) { <line5> logRebindingDebug(""RebindManager instantiating policy {}"", policyMemento); <line6> try { <line7> Policy policy = instantiator.newPolicy(policyMemento); <line8> rebindContext.registerPolicy(policyMemento.getId(), policy); <line9> } catch (Exception e) { <line10> exceptionHandler.onCreateFailed( <line11> BrooklynObjectType.POLICY, policyMemento.getId(), policyMemento.getType(), e); <line12> } <line13> } <line14> } else { <line15> logRebindingDebug(""Not rebinding policies; feature disabled: {}"", memento.getPolicyIds()); <line16> } <line17> if (rebindManager.persistEnrichersEnabled) { <line18> logRebindingDebug(""RebindManager instantiating enrichers: {}"", memento.getEnricherIds()); <line19> for (EnricherMemento enricherMemento : memento.getEnricherMementos().values()) { <line20> logRebindingDebug(""RebindManager instantiating enricher {}"", enricherMemento); <line21> try { <line22> Enricher enricher = instantiator.newEnricher(enricherMemento); <line23> rebindContext.registerEnricher(enricherMemento.getId(), enricher); <line24> } catch (Exception e) { <line25> exceptionHandler.onCreateFailed( <line26> BrooklynObjectType.ENRICHER, enricherMemento.getId(), enricherMemento.getType(), e); <line27> } <line28> } <line29> } else { <line30> logRebindingDebug(""Not rebinding enrichers; feature disabled: {}"", memento.getEnricherIds()); <line31> } <line32> if (rebindManager.persistFeedsEnabled) { <line33> logRebindingDebug(""RebindManager instantiating feeds: {}"", memento.getFeedIds()); <line34> for (FeedMemento feedMemento : memento.getFeedMementos().values()) { <line35> try { <line36> Feed feed = instantiator.newFeed(feedMemento); <line37> rebindContext.registerFeed(feedMemento.getId(), feed); <line38> } catch (Exception e) { <line39> exceptionHandler.onCreateFailed( <line40> BrooklynObjectType.FEED, feedMemento.getId(), feedMemento.getType(), e); <line41> } <line42> } <line43> } else { <line44> logRebindingDebug(""Not rebinding feeds; feature disabled: {}"", memento.getFeedIds()); <line45> } <line46> } <line47> } <line48> "	<line35>
6227	"public class A { <line0> @ApiOperation( <line1> value = ""Remove the requested AuthorizationIntraCloud entry"", <line2> tags = {CoreCommonConstants.SWAGGER_TAG_MGMT}) <line3> @ApiResponses( <line4> value = { <line5> @ApiResponse( <line6> code = HttpStatus.SC_OK, <line7> message = DELETE_AUTHORIZATION_INTRA_CLOUD_MGMT_HTTP_200_MESSAGE), <line8> @ApiResponse( <line9> code = HttpStatus.SC_BAD_REQUEST, <line10> message = DELETE_AUTHORIZATION_INTRA_CLOUD_MGMT_HTTP_400_MESSAGE), <line11> @ApiResponse( <line12> code = HttpStatus.SC_UNAUTHORIZED, <line13> message = CoreCommonConstants.SWAGGER_HTTP_401_MESSAGE), <line14> @ApiResponse( <line15> code = HttpStatus.SC_INTERNAL_SERVER_ERROR, <line16> message = CoreCommonConstants.SWAGGER_HTTP_500_MESSAGE) <line17> }) <line18> @DeleteMapping(path = AUTHORIZATION_INTRA_CLOUD_MGMT_BY_ID_URI) <line19> public void removeAuthorizationIntraCloudById( <line20> @PathVariable(value = PATH_VARIABLE_ID) final long id) { <line21> if (id < 1) { <line22> throw new BadPayloadException( <line23> ID_NOT_VALID_ERROR_MESSAGE, <line24> HttpStatus.SC_BAD_REQUEST, <line25> CommonConstants.AUTHORIZATION_URI + AUTHORIZATION_INTRA_CLOUD_MGMT_BY_ID_URI); <line26> } <line27> authorizationDBService.removeAuthorizationIntraCloudEntryById(id); <line28> } <line29> } <line30> "	<line21>, <line28>
6228	"public class A { <line0> public static java.util.List<com.liferay.portal.kernel.model.Country> getCompanyCountries( <line1> HttpPrincipal httpPrincipal, long companyId) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> CountryServiceUtil.class, ""getCompanyCountries"", _getCompanyCountriesParameterTypes8); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, companyId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line12> } <line13> return (java.util.List<com.liferay.portal.kernel.model.Country>) returnObj; <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	<line15>
6229	"public class A { <line0> @Test <line1> public void testClassLevelMultipleInterceptor() throws Exception { <line2> Collection<String> beanXmls = new ArrayList<String>(); <line3> beanXmls.add( <line4> getXmlPath(this.getClass().getPackage().getName(), this.getClass().getSimpleName())); <line5> Collection<Class<?>> beanClasses = new ArrayList<Class<?>>(); <line6> beanClasses.add(ClassMultiInterceptedClass.class); <line7> beanClasses.add(Transactional.class); <line8> beanClasses.add(Secure.class); <line9> beanClasses.add(Action.class); <line10> beanClasses.add(ActionInterceptor.class); <line11> beanClasses.add(SecureInterceptor.class); <line12> beanClasses.add(TransactionalInterceptor.class); <line13> startContainer(beanClasses, beanXmls); <line14> InterceptorResolutionService ir = new InterceptorResolutionService(getWebBeansContext()); <line15> AnnotatedType<ClassMultiInterceptedClass> annotatedType = <line16> getBeanManager().createAnnotatedType(ClassMultiInterceptedClass.class); <line17> Bean<ClassMultiInterceptedClass> bean = <line18> (Bean<ClassMultiInterceptedClass>) <line19> getBeanManager() <line20> .resolve((Set) getBeanManager().getBeans(ClassMultiInterceptedClass.class)); <line21> BeanInterceptorInfo interceptorInfo = null; <line22> long start = System.nanoTime(); <line23> for (int i = 0; i < 2; i++) { <line24> interceptorInfo = <line25> ir.calculateInterceptorInfo(bean.getTypes(), bean.getQualifiers(), annotatedType, false); <line26> } <line27> long end = System.nanoTime(); <line28> Assert.assertNotNull(interceptorInfo); <line29> Assert.assertNotNull(interceptorInfo.getCdiInterceptors()); <line30> Assert.assertEquals(3, interceptorInfo.getCdiInterceptors().size()); <line31> Assert.assertEquals(0, interceptorInfo.getDecorators().size()); <line32> Map<Method, BusinessMethodInterceptorInfo> methodInterceptorInfos = <line33> new HashMap<Method, BusinessMethodInterceptorInfo>( <line34> interceptorInfo.getBusinessMethodsInfo()); <line35> Assert.assertNotNull(methodInterceptorInfos); <line36> Assert.assertEquals(8, methodInterceptorInfos.size()); <line37> Method methodWithEnhancedAction = <line38> ClassMultiInterceptedClass.class.getMethod(""methodWithEnhancedAction""); <line39> Assert.assertEquals( <line40> 2, methodInterceptorInfos.get(methodWithEnhancedAction).getCdiInterceptors().length); <line41> methodInterceptorInfos.remove(methodWithEnhancedAction); <line42> for (BusinessMethodInterceptorInfo mi : methodInterceptorInfos.values()) { <line43> Assert.assertEquals(3, mi.getCdiInterceptors().length); <line44> } <line45> Assert.assertEquals(2, interceptorInfo.getLifecycleMethodInterceptorInfos().size()); <line46> LifecycleMethodInfo lmiPostConstruct = <line47> interceptorInfo.getLifecycleMethodInterceptorInfos().get(InterceptionType.POST_CONSTRUCT); <line48> Assert.assertNotNull(lmiPostConstruct); <line49> Assert.assertNotNull(lmiPostConstruct.getMethodInterceptorInfo().getCdiInterceptors()); <line50> shutDownContainer(); <line51> } <line52> } <line53> "	<line28>
6230	public class A { <line0> public boolean doMfglibSendPacket(int[] data) { <line1> EzspMfglibSendPacketRequest request = new EzspMfglibSendPacketRequest(); <line2> request.setPacketContents(data); <line3> EzspSingleResponseTransaction transaction = <line4> new EzspSingleResponseTransaction(request, EzspMfglibSendPacketResponse.class); <line5> protocolHandler.sendEzspTransaction(transaction); <line6> EzspMfglibSendPacketResponse response = <line7> (EzspMfglibSendPacketResponse) transaction.getResponse(); <line8> if (response == null || response.getStatus() != EmberStatus.EMBER_SUCCESS) { <line9> return false; <line10> } <line11> return true; <line12> } <line13> } <line14> 	<line9>, <line11>
6231	"public class A { <line0> protected static void setupClient() throws Exception { <line1> olingoApp = new Olingo2AppImpl(TEST_SERVICE_URL + ""/""); <line2> olingoApp.setContentType(TEST_FORMAT_STRING); <line3> final TestOlingo2ResponseHandler<Edm> responseHandler = new TestOlingo2ResponseHandler<>(); <line4> olingoApp.read(null, Olingo2AppImpl.METADATA, null, null, responseHandler); <line5> edm = responseHandler.await(); <line6> edmEntitySetMap = new HashMap<>(); <line7> for (EdmEntitySet ees : edm.getEntitySets()) { <line8> edmEntitySetMap.put(ees.getName(), ees); <line9> } <line10> Thread.sleep(2000); <line11> } <line12> } <line13> "	<line3>, <line6>
6232	public class A { <line0> public void setDefaults(final ActiveMQRAProperties prop) { <line1> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line2> } <line3> if (userName == null) { <line4> userName = prop.getUserName(); <line5> } <line6> if (password == null) { <line7> password = prop.getPassword(); <line8> } <line9> if (clientID == null) { <line10> clientID = prop.getClientID(); <line11> } <line12> } <line13> } <line14> 	<line2>
6233	"public class A { <line0> private void dropHdfsPathOnCluster(List<String> oldHdfsPaths, FileSystem fileSystem) <line1> throws IOException { <line2> if (oldHdfsPaths != null && oldHdfsPaths.size() > 0) { <line3> output.append(""Drop HDFS path on FileSystem: \"""" + fileSystem.getUri() + ""\"" \n""); <line4> for (String path : oldHdfsPaths) { <line5> if (path.endsWith(""*"")) path = path.substring(0, path.length() - 1); <line6> Path oldPath = Path.getPathWithoutSchemeAndAuthority(new Path(path)); <line7> if (fileSystem.exists(oldPath)) { <line8> fileSystem.delete(oldPath, true); <line9> output.append(""HDFS path "" + oldPath + "" is dropped.\n""); <line10> } else { <line11> output.append(""HDFS path "" + oldPath + "" not exists.\n""); <line12> } <line13> Path parentPath = oldPath.getParent(); <line14> if (fileSystem.exists(parentPath) && fileSystem.listStatus(parentPath).length == 0) { <line15> Path emptyJobPath = new Path(JobBuilderSupport.getJobWorkingDir(config, getJobId())); <line16> emptyJobPath = Path.getPathWithoutSchemeAndAuthority(emptyJobPath); <line17> if (fileSystem.exists(emptyJobPath)) { <line18> fileSystem.delete(emptyJobPath, true); <line19> output.append(""HDFS path "" + emptyJobPath + "" is empty and dropped.\n""); <line20> } <line21> } <line22> } <line23> } <line24> } <line25> } <line26> "	<line3>, <line9>, <line11>, <line19>
6234	public class A { <line0> private static InetAddress normalizeV6Address(Inet6Address address) { <line1> String addr = address.getHostAddress(); <line2> int i = addr.lastIndexOf('%'); <line3> if (i > 0) { <line4> try { <line5> return InetAddress.getByName(addr.substring(0, i) + '%' + address.getScopeId()); <line6> } catch (UnknownHostException e) { <line7> } <line8> } <line9> return address; <line10> } <line11> } <line12> 	<line7>
6235	public class A { <line0> public void persist(StgFilterBasis transientInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().persist(transientInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
6236	"public class A { <line0> public void set(int seconds) { <line1> if (freeze.get() > 0) return; <line2> if (freeze.get() < 0) throw exception(""Timeout freeze broken""); <line3> current.set(seconds); <line4> } <line5> } <line6> "	<line4>
6237	public class A { <line0> private synchronized void listen() { <line1> try { <line2> discoveryListener = new DiscoveryListener(); <line3> } catch (SocketException se) { <line4> return; <line5> } catch (IOException ioe) { <line6> return; <line7> } <line8> while (!terminate) { <line9> try { <line10> processMessage(discoveryListener.waitForMessage()); <line11> } catch (SocketTimeoutException e) { <line12> continue; <line13> } catch (IOException ioe) { <line14> break; <line15> } <line16> } <line17> discoveryListener.shutdown(); <line18> } <line19> } <line20> 	<line1>, <line4>, <line6>, <line8>, <line14>, <line18>
6238	"public class A { <line0> @Override <line1> public boolean isAcceptable(String protocol, String tlsProtocol, String tlsCipher) { <line2> boolean acceptable = <line3> ""h2-14"".equals(protocol) <line4> || !(HTTP2Cipher.isBlackListProtocol(tlsProtocol) <line5> && HTTP2Cipher.isBlackListCipher(tlsCipher)); <line6> if (LOG.isDebugEnabled()) <line7> return acceptable; <line8> } <line9> } <line10> "	<line7>
6239	public class A { <line0> @Override <line1> protected void download(Path tmp, URI baseUri, Artifact.Item item, Progress progress) <line2> throws IOException { <line3> String key = item.getUri(); <line4> GetObjectRequest req = GetObjectRequest.builder().bucket(bucket).key(key).build(); <line5> try (ResponseInputStream<GetObjectResponse> is = client.getObject(req)) { <line6> save(is, tmp, baseUri, item, progress); <line7> } <line8> } <line9> } <line10> 	<line4>
6240	"public class A { <line0> @Override <line1> public void onStartup(Set<Class<?>> c, ServletContext ctx) { <line2> try { <line3> ServletContextHandler context = ServletContextHandler.getServletContextHandler(ctx); <line4> Objects.requireNonNull(context); <line5> ClassLoader loader = context.getClassLoader(); <line6> if (loader == null) Loader.loadClass(""javax.enterprise.inject.spi.CDI""); <line7> else loader.loadClass(""javax.enterprise.inject.spi.CDI""); <line8> String mode = ctx.getInitParameter(CDI_INTEGRATION_ATTRIBUTE); <line9> if (mode == null) { <line10> mode = (String) context.getServer().getAttribute(CDI_INTEGRATION_ATTRIBUTE); <line11> if (mode == null) mode = CdiSpiDecorator.MODE; <line12> } <line13> switch (mode) { <line14> case CdiSpiDecorator.MODE: <line15> context.getObjectFactory().addDecorator(new CdiSpiDecorator(context)); <line16> break; <line17> case CdiDecoratingListener.MODE: <line18> context.addEventListener(new CdiDecoratingListener(context)); <line19> break; <line20> default: <line21> throw new IllegalStateException(mode); <line22> } <line23> } catch (UnsupportedOperationException | ClassNotFoundException e) { <line24> } <line25> } <line26> } <line27> "	<line23>, <line24>
6241	"public class A { <line0> private String matchContainer( <line1> final Class<? extends ContainerInfo> containerInfoType, <line2> final EnterpriseBean bean, <line3> final Collection<ContainerInfo> list) { <line4> for (final ContainerInfo containerInfo : list) { <line5> if (containerInfo.getClass().equals(containerInfoType)) { <line6> if (MessageDrivenBean.class.isInstance(bean)) { <line7> final MessageDrivenBean messageDrivenBean = (MessageDrivenBean) bean; <line8> final String messagingType = messageDrivenBean.getMessagingType(); <line9> if (containerInfo.properties.get(""MessageListenerInterface"").equals(messagingType)) { <line10> if (logger.isDebugEnabled()) { <line11> } <line12> return containerInfo.id; <line13> } else { <line14> if (logger.isDebugEnabled()) { <line15> } <line16> } <line17> } else { <line18> if (logger.isDebugEnabled()) { <line19> } <line20> return containerInfo.id; <line21> } <line22> } <line23> if (logger.isDebugEnabled()) { <line24> } <line25> } <line26> return null; <line27> } <line28> } <line29> "	<line11>, <line15>, <line19>, <line24>
6242	"public class A { <line0> public static float getScalingFactor() { <line1> float scalingFactor = 1.0f; <line2> try { <line3> Class<?> retinaDetectorClass = Class.forName(""ro.sync.ui.hidpi.RetinaDetector""); <line4> Method getInstanceMethod = retinaDetectorClass.getMethod(""getInstance""); <line5> Object retinaDetectorObj = getInstanceMethod.invoke(null); <line6> Method getScalingFactorMethod = retinaDetectorClass.getMethod(""getScalingFactor""); <line7> scalingFactor = (float) getScalingFactorMethod.invoke(retinaDetectorObj); <line8> } catch (Exception e) { <line9> } <line10> return scalingFactor; <line11> } <line12> } <line13> "	<line9>
6243	public class A { <line0> public static String getSHA512Checksum(final File file) { <line1> try (final InputStream is = file.getInputStream()) { <line2> return DigestUtils.sha512Hex(is); <line3> } catch (final IOException ex) { <line4> } <line5> return null; <line6> } <line7> } <line8> 	<line4>
6244	public class A { <line0> protected void addEndStateBackedByView(final Flow flow, final String id, final String viewId) { <line1> try { <line2> final EndState endState = new EndState(flow, id); <line3> final ViewFactory viewFactory = <line4> this.flowBuilderServices <line5> .getViewFactoryCreator() <line6> .createViewFactory( <line7> new LiteralExpression(viewId), <line8> this.flowBuilderServices.getExpressionParser(), <line9> this.flowBuilderServices.getConversionService(), <line10> null, <line11> this.flowBuilderServices.getValidator(), <line12> this.flowBuilderServices.getValidationHintResolver()); <line13> final Action finalResponseAction = new ViewFactoryActionAdapter(viewFactory); <line14> endState.setFinalResponseAction(finalResponseAction); <line15> } catch (final Exception e) { <line16> } <line17> } <line18> } <line19> 	<line15>, <line16>
6245	public class A { <line0> public static DLFolder addDLFolder( <line1> long groupId, long parentFolderId, boolean deleteExisting, ServiceContext serviceContext) <line2> throws Exception { <line3> String name = RandomTestUtil.randomString(); <line4> if (deleteExisting) { <line5> try { <line6> DLFolder folder = DLFolderLocalServiceUtil.getFolder(groupId, parentFolderId, name); <line7> DLFolderLocalServiceUtil.deleteFolder(folder.getFolderId()); <line8> } catch (NoSuchFolderException noSuchFolderException) { <line9> if (_log.isDebugEnabled()) { <line10> } <line11> } <line12> } <line13> return DLFolderLocalServiceUtil.addFolder( <line14> TestPropsValues.getUserId(), <line15> groupId, <line16> groupId, <line17> false, <line18> parentFolderId, <line19> name, <line20> StringPool.BLANK, <line21> false, <line22> serviceContext); <line23> } <line24> } <line25> 	<line10>
6246	public class A { <line0> @Override <line1> public void handleOutputs(Configuration conf, Path workingPath, int index) throws IOException { <line2> FileSystem srcFs = workingPath.getFileSystem(conf); <line3> Configuration dstFsConf = getEffectiveBundleConfig(conf); <line4> FileSystem dstFs = path.getFileSystem(dstFsConf); <line5> if (!dstFs.exists(path)) { <line6> dstFs.mkdirs(path); <line7> } <line8> Path srcPattern = getSourcePattern(workingPath, index); <line9> boolean sameFs = isCompatible(srcFs, path); <line10> boolean useDistributedCopy = conf.getBoolean(RuntimeParameters.FILE_TARGET_USE_DISTCP, true); <line11> int maxDistributedCopyTasks = conf.getInt(RuntimeParameters.FILE_TARGET_MAX_DISTCP_TASKS, 100); <line12> int maxDistributedCopyTaskBandwidthMB = <line13> conf.getInt( <line14> RuntimeParameters.FILE_TARGET_MAX_DISTCP_TASK_BANDWIDTH_MB, <line15> DistCpConstants.DEFAULT_BANDWIDTH_MB); <line16> int maxThreads = conf.getInt(RuntimeParameters.FILE_TARGET_MAX_THREADS, 1); <line17> if (!sameFs) { <line18> if (useDistributedCopy) { <line19> handleOutputsDistributedCopy( <line20> conf, <line21> srcPattern, <line22> srcFs, <line23> dstFs, <line24> maxDistributedCopyTasks, <line25> maxDistributedCopyTaskBandwidthMB); <line26> } else { <line27> handleOutputsAsynchronously(conf, srcPattern, srcFs, dstFs, sameFs, maxThreads); <line28> } <line29> } else { <line30> handleOutputsAsynchronously(conf, srcPattern, srcFs, dstFs, sameFs, maxThreads); <line31> } <line32> } <line33> } <line34> 	<line19>, <line27>, <line30>
6247	public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> ctx.channel().close(); <line3> } <line4> } <line5> 	<line2>
6248	"public class A { <line0> @Test <line1> public void runParallelWrapperMain(@TempDir Path testDir) throws Exception { <line2> int nChannels = 1; <line3> int outputNum = 10; <line4> int batchSize = 128; <line5> int seed = 123; <line6> int uiPort = 9500; <line7> System.setProperty(""org.deeplearning4j.ui.port"", String.valueOf(uiPort)); <line8> DataSetIterator mnistTrain = new MnistDataSetIterator(batchSize, true, 12345); <line9> DataSetIterator mnistTest = new MnistDataSetIterator(batchSize, false, 12345); <line10> MultiLayerConfiguration.Builder builder = <line11> new NeuralNetConfiguration.Builder() <line12> .seed(seed) <line13> .l2(0.0005) <line14> .weightInit(WeightInit.XAVIER) <line15> .updater(new Nesterovs(0.01, 0.9)) <line16> .list() <line17> .layer( <line18> 0, <line19> new ConvolutionLayer.Builder(5, 5) <line20> .nIn(nChannels) <line21> .stride(1, 1) <line22> .nOut(20) <line23> .activation(Activation.IDENTITY) <line24> .build()) <line25> .layer( <line26> 1, <line27> new SubsamplingLayer.Builder(SubsamplingLayer.PoolingType.MAX) <line28> .kernelSize(2, 2) <line29> .stride(2, 2) <line30> .build()) <line31> .layer( <line32> 2, <line33> new ConvolutionLayer.Builder(5, 5) <line34> .stride(1, 1) <line35> .nOut(50) <line36> .activation(Activation.IDENTITY) <line37> .build()) <line38> .layer( <line39> 3, <line40> new SubsamplingLayer.Builder(SubsamplingLayer.PoolingType.MAX) <line41> .kernelSize(2, 2) <line42> .stride(2, 2) <line43> .build()) <line44> .layer(4, new DenseLayer.Builder().activation(Activation.RELU).nOut(500).build()) <line45> .layer( <line46> 5, <line47> new OutputLayer.Builder(LossFunctions.LossFunction.NEGATIVELOGLIKELIHOOD) <line48> .nOut(outputNum) <line49> .activation(Activation.SOFTMAX) <line50> .build()) <line51> .setInputType(InputType.convolutionalFlat(28, 28, nChannels)); <line52> MultiLayerConfiguration conf = builder.build(); <line53> MultiLayerNetwork model = new MultiLayerNetwork(conf); <line54> model.init(); <line55> File tempModel = Files.createTempFile(testDir, ""tmpmodel"", ""zip"").toFile(); <line56> tempModel.deleteOnExit(); <line57> ModelSerializer.writeModel(model, tempModel, false); <line58> File tmp = Files.createTempFile(testDir, ""tmpmodel"", ""bin"").toFile(); <line59> tmp.deleteOnExit(); <line60> ParallelWrapperMain parallelWrapperMain = new ParallelWrapperMain(); <line61> try { <line62> parallelWrapperMain.runMain( <line63> new String[] { <line64> ""--modelPath"", <line65> tempModel.getAbsolutePath(), <line66> ""--dataSetIteratorFactoryClazz"", <line67> MnistDataSetIteratorProviderFactory.class.getName(), <line68> ""--modelOutputPath"", <line69> tmp.getAbsolutePath(), <line70> ""--uiUrl"", <line71> ""localhost:"" + uiPort <line72> }); <line73> } finally { <line74> parallelWrapperMain.stop(); <line75> } <line76> } <line77> } <line78> "	<line8>, <line10>
6249	public class A { <line0> public boolean flushPendingReplication(long timeout, TimeUnit units) { <line1> if (_specificLogger.isDebugEnabled()) <line2> final Collection<AbstractReplicationSourceChannel> channels = _channels.values(); <line3> for (AbstractReplicationSourceChannel sourceChannel : channels) { <line4> sourceChannel.flushPendingReplication(); <line5> } <line6> long remainingTime = units.toMillis(timeout); <line7> final int sleepTime = 50; <line8> long runningTime = 0; <line9> while (remainingTime >= 0) { <line10> boolean done = true; <line11> long weightToReplicate = 0; <line12> for (AbstractReplicationSourceChannel sourceChannel : channels) { <line13> long channelBacklogWeight = getGroupBacklog().getWeight(sourceChannel.getMemberName()); <line14> if (sourceChannel.isActive() && channelBacklogWeight > 0) { <line15> done = false; <line16> weightToReplicate = Math.max(channelBacklogWeight, weightToReplicate); <line17> } <line18> } <line19> if (done) { <line20> if (_specificLogger.isDebugEnabled()) <line21> return true; <line22> } <line23> if (remainingTime == 0) { <line24> if (_specificLogger.isWarnEnabled()) <line25> return false; <line26> } <line27> if (remainingTime > 0) <line28> try { <line29> if (runningTime % 5000 == 0 && _specificLogger.isInfoEnabled()) <line30> Thread.sleep(sleepTime); <line31> runningTime += sleepTime; <line32> remainingTime -= sleepTime; <line33> } catch (InterruptedException e) { <line34> if (_specificLogger.isWarnEnabled()) <line35> Thread.currentThread().interrupt(); <line36> return false; <line37> } <line38> } <line39> if (_specificLogger.isWarnEnabled()) <line40> return false; <line41> } <line42> } <line43> 	<line2>, <line21>, <line25>, <line30>, <line35>, <line40>
6250	"public class A { <line0> private static synchronized void createDefaults(CoreSettings settings) { <line1> if (!HANDLERS.isEmpty()) { <line2> return; <line3> } <line4> final IdManager idManager = PersistenceManagerFactory.getInstance(settings).getIdManager(); <line5> ArrayValueHandler idHandler = <line6> (Object value, Observation target) -> target.setId(idManager.parseId(value.toString())); <line7> HANDLERS.put(""id"", idHandler); <line8> HANDLERS.put(AT_IOT_ID, idHandler); <line9> HANDLERS.put(""result"", (Object value, Observation target) -> target.setResult(value)); <line10> HANDLERS.put( <line11> ""resultQuality"", (Object value, Observation target) -> target.setResultQuality(value)); <line12> HANDLERS.put( <line13> ""parameters"", <line14> (Object value, Observation target) -> { <line15> if (value instanceof Map) { <line16> target.setParameters((Map<String, Object>) value); <line17> return; <line18> } <line19> throw new IllegalArgumentException(""parameters has to be a map.""); <line20> }); <line21> HANDLERS.put( <line22> ""phenomenonTime"", <line23> (Object value, Observation target) -> { <line24> try { <line25> TimeInstant time = TimeInstant.parse(value.toString()); <line26> target.setPhenomenonTime(time); <line27> return; <line28> } catch (Exception e) { <line29> } <line30> try { <line31> TimeInterval time = TimeInterval.parse(value.toString()); <line32> target.setPhenomenonTime(time); <line33> return; <line34> } catch (Exception e) { <line35> } <line36> throw new IllegalArgumentException( <line37> ""phenomenonTime could not be parsed as time instant or time interval.""); <line38> }); <line39> HANDLERS.put( <line40> ""resultTime"", <line41> (Object value, Observation target) -> { <line42> try { <line43> TimeInstant time = TimeInstant.parse(value.toString()); <line44> target.setResultTime(time); <line45> } catch (Exception e) { <line46> throw new IllegalArgumentException( <line47> ""resultTime could not be parsed as time instant or time interval."", e); <line48> } <line49> }); <line50> HANDLERS.put( <line51> ""validTime"", <line52> (Object value, Observation target) -> { <line53> try { <line54> TimeInterval time = TimeInterval.parse(value.toString()); <line55> target.setValidTime(time); <line56> } catch (Exception e) { <line57> throw new IllegalArgumentException( <line58> ""resultTime could not be parsed as time instant or time interval."", e); <line59> } <line60> }); <line61> HANDLERS.put( <line62> ""FeatureOfInterest/id"", <line63> (Object value, Observation target) -> { <line64> Id foiId = idManager.parseId(value.toString()); <line65> target.setFeatureOfInterest(new FeatureOfInterest(foiId)); <line66> }); <line67> } <line68> } <line69> "	<line29>, <line35>
6251	public class A { <line0> public static com.liferay.asset.kernel.model.AssetVocabularySoap[] getGroupVocabularies( <line1> long groupId) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.asset.kernel.model.AssetVocabulary> returnValue = <line4> AssetVocabularyServiceUtil.getGroupVocabularies(groupId); <line5> return com.liferay.asset.kernel.model.AssetVocabularySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>
6252	"public class A { <line0> @SkipValidation <line1> @Action(value = ""/payment/chequeAssignment-beforeSearchForSurrender"") <line2> public String beforeSearchForSurrender() { <line3> addDropdownData(BANKACCOUNT_LIST, Collections.emptyList()); <line4> loadBankAndAccounForSurender(); <line5> return SURRENDERSEARCH; <line6> } <line7> } <line8> "	<line3>, <line5>
6253	public class A { <line0> protected void deleteRecursiveIfExists(File item) { <line1> if (!item.exists()) { <line2> return; <line3> } <line4> if (!Files.isSymbolicLink(item.toPath()) && item.isDirectory()) { <line5> File[] subitems = item.listFiles(); <line6> for (File subitem : subitems) { <line7> deleteRecursiveIfExists(subitem); <line8> } <line9> } <line10> try { <line11> if (!item.delete()) { <line12> } <line13> } catch (SecurityException exception) { <line14> } <line15> } <line16> } <line17> 	<line12>, <line14>
6254	public class A { <line0> public void error(String inWhat) { <line1> } <line2> } <line3> 	<line1>
6255	"public class A { <line0> @Test <line1> public void testCreateMerge() throws Exception { <line2> final Map<String, Object> data = getEntityData(); <line3> data.put(ID_PROPERTY, TEST_MERGE_MANUFACTURER_ID); <line4> final ODataEntry manufacturer = requestBody(""direct:CREATE"", data); <line5> assertNotNull(manufacturer, ""Created Manufacturer""); <line6> final Map<String, Object> properties = manufacturer.getProperties(); <line7> assertEquals( <line8> TEST_MERGE_MANUFACTURER_ID, properties.get(ID_PROPERTY), ""Created Manufacturer Id""); <line9> final Map<String, Object> propertiesToUpdate = new HashMap<>(); <line10> propertiesToUpdate.put(ID_PROPERTY, TEST_MERGE_MANUFACTURER_ID); <line11> propertiesToUpdate.put(""Name"", ""MyCarManufacturer Updated""); <line12> HttpStatusCodes status = requestBody(""direct:MERGE"", propertiesToUpdate); <line13> assertNotNull(status, ""Merge status""); <line14> assertEquals( <line15> HttpStatusCodes.NO_CONTENT.getStatusCode(), status.getStatusCode(), ""Merge status""); <line16> final Map<String, Object> headers = new HashMap<>(); <line17> headers.put( <line18> Olingo2Constants.PROPERTY_PREFIX + ""keyPredicate"", <line19> String.format(""'%s'"", TEST_MERGE_MANUFACTURER_ID)); <line20> final ODataEntry mergedManufacturer = requestBodyAndHeaders(""direct:READENTRY"", null, headers); <line21> assertNotNull(mergedManufacturer); <line22> final Map<String, Object> mergedProperties = mergedManufacturer.getProperties(); <line23> assertEquals(TEST_MERGE_MANUFACTURER_ID, mergedProperties.get(ID_PROPERTY), ""Manufacturer Id""); <line24> assertEquals(""MyCarManufacturer Updated"", mergedProperties.get(""Name""), ""Manufacturer Name""); <line25> assertNotNull(mergedProperties.get(""Address""), ""Manufacturer Address""); <line26> } <line27> } <line28> "	<line9>, <line16>, <line26>
6256	public class A { <line0> private Object[] getParams(CxfEndpoint endpoint, Exchange exchange) <line1> throws org.apache.camel.InvalidPayloadException { <line2> Object[] params = null; <line3> if (endpoint.getDataFormat() == DataFormat.POJO) { <line4> Object body = exchange.getIn().getBody(); <line5> if (body == null) { <line6> return new Object[0]; <line7> } <line8> if (body instanceof Object[]) { <line9> params = (Object[]) body; <line10> } else if (body instanceof List) { <line11> params = ((List<?>) body).toArray(); <line12> } else { <line13> Iterator<?> it = exchange.getIn().getBody(Iterator.class); <line14> if (it != null && it.hasNext()) { <line15> List<?> list = exchange.getContext().getTypeConverter().convertTo(List.class, it); <line16> if (list != null) { <line17> params = list.toArray(); <line18> } <line19> } <line20> if (params == null) { <line21> params = new Object[1]; <line22> params[0] = exchange.getIn().getBody(); <line23> } <line24> } <line25> checkParameterSize(endpoint, exchange, params); <line26> } else if (endpoint.getDataFormat() == DataFormat.PAYLOAD) { <line27> params = new Object[1]; <line28> params[0] = exchange.getIn().getMandatoryBody(CxfPayload.class); <line29> } else if (endpoint.getDataFormat().dealias() == DataFormat.RAW) { <line30> params = new Object[1]; <line31> params[0] = exchange.getIn().getMandatoryBody(InputStream.class); <line32> } else if (endpoint.getDataFormat().dealias() == DataFormat.CXF_MESSAGE) { <line33> params = new Object[1]; <line34> params[0] = exchange.getIn().getBody(); <line35> } <line36> if (LOG.isTraceEnabled()) { <line37> if (params != null) { <line38> for (int i = 0; i < params.length; i++) { <line39> } <line40> } <line41> } <line42> return params; <line43> } <line44> } <line45> 	<line39>
6257	public class A { <line0> static Map<String, ValidationMatcher> lookup() { <line1> if (matcher.isEmpty()) { <line2> matcher.putAll(new ResourcePathTypeResolver().resolveAll(RESOURCE_PATH)); <line3> if (LOG.isDebugEnabled()) { <line4> matcher.forEach( <line5> (k, v) -> <line6> } <line7> } <line8> return matcher; <line9> } <line10> } <line11> 	<line6>
6258	"public class A { <line0> public static void info(String msg) { <line1> addDebuggingLog(""INFO"", msg); <line2> } <line3> } <line4> "	<line1>
6259	public class A { <line0> protected void checkAccess(boolean isRead, String entityId, EntityBody content) { <line1> rightAccessValidator.checkSecurity(isRead, entityId, defn.getType(), collectionName, getRepo()); <line2> try { <line3> checkAccess(isRead, isSelf(entityId), content); <line4> } catch (APIAccessDeniedException e) { <line5> Set<String> entityIds = new HashSet<String>(); <line6> entityIds.add(entityId); <line7> e.setEntityType(defn.getType()); <line8> e.setEntityIds(entityIds); <line9> throw e; <line10> } <line11> } <line12> } <line13> 	<line1>
6260	"public class A { <line0> @Override <line1> public boolean addUsersToGroup(AuthzToken authzToken, List<String> userIds, String groupId) <line2> throws GroupManagerServiceException, AuthorizationException, TException { <line3> try { <line4> SharingRegistryService.Client sharingClient = getSharingRegistryServiceClient(); <line5> String userId = getUserId(authzToken); <line6> String domainId = getDomainId(authzToken); <line7> if (!(sharingClient.hasOwnerAccess(domainId, groupId, userId) <line8> || sharingClient.hasAdminAccess(domainId, groupId, userId))) { <line9> throw new GroupManagerServiceException( <line10> ""User does not have access to add users to the group""); <line11> } <line12> return internalAddUsersToGroup(sharingClient, domainId, userIds, groupId); <line13> } catch (Exception e) { <line14> String msg = ""Error adding users to group. Group ID: "" + groupId; <line15> GroupManagerServiceException exception = new GroupManagerServiceException(); <line16> exception.setMessage(msg + "" More info : "" + e.getMessage()); <line17> throw exception; <line18> } <line19> } <line20> } <line21> "	<line15>
6261	public class A { <line0> public static void main(String[] args) { <line1> Logger logger = LoggerFactory.getLogger(ExceptionEvaluatorExample.class); <line2> LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory(); <line3> try { <line4> JoranConfigurator configurator = new JoranConfigurator(); <line5> configurator.setContext(lc); <line6> lc.reset(); <line7> configurator.doConfigure(args[0]); <line8> } catch (JoranException je) { <line9> } <line10> StatusPrinter.printInCaseOfErrorsOrWarnings(lc); <line11> for (int i = 0; i < 3; i++) { <line12> if (i == 1) { <line13> } else { <line14> } <line15> } <line16> } <line17> } <line18> 	<line13>, <line14>
6262	"public class A { <line0> @Override <line1> public RecordHandlingFlow getRecordHandler(PipeLineSession session, String record) <line2> throws Exception { <line3> String value = null; <line4> if (startPosition >= record.length()) { <line5> throw new Exception( <line6> ""Record size is smaller then the specified position of the recordtype within the record""); <line7> } <line8> if (endPosition < 0) { <line9> Map<String, RecordHandlingFlow> valueHandlersMap = getFlowMap(); <line10> RecordHandlingFlow rhf = null; <line11> for (String name : valueHandlersMap.keySet()) { <line12> if (log.isTraceEnabled()) <line13> if (name.length() <= record.length()) { <line14> value = record.substring(startPosition, name.length()); <line15> if (value.equals(name) && (rhf = valueHandlersMap.get(name)) != null) { <line16> break; <line17> } <line18> } <line19> } <line20> if (rhf == null) { <line21> rhf = getFlowMap().get(""*""); <line22> if (rhf == null) { <line23> throw new Exception(""No handlers (flow) found for recordKey ["" + value + ""]""); <line24> } <line25> } <line26> return rhf; <line27> } <line28> if (endPosition >= record.length()) { <line29> value = record.substring(startPosition); <line30> } else { <line31> value = record.substring(startPosition, endPosition); <line32> } <line33> return super.getRecordHandlerByKey(value); <line34> } <line35> } <line36> "	<line13>
6263	public class A { <line0> @Override <line1> public Long call() { <line2> try { <line3> try { <line4> if (fast) { <line5> Thread.sleep(500); <line6> return 1L; <line7> } else { <line8> Thread.sleep(5000); <line9> return 2L; <line10> } <line11> } finally { <line12> isFinished = true; <line13> } <line14> } catch (InterruptedException ignore) { <line15> return 0L; <line16> } <line17> } <line18> } <line19> 	<line6>, <line9>, <line15>
6264	public class A { <line0> @Override <line1> public Account addAccount( <line2> String address, <line3> String personalName, <line4> String protocol, <line5> String incomingHostName, <line6> int incomingPort, <line7> boolean incomingSecure, <line8> String outgoingHostName, <line9> int outgoingPort, <line10> boolean outgoingSecure, <line11> String login, <line12> String password, <line13> boolean savePassword, <line14> String signature, <line15> boolean useSignature, <line16> String folderPrefix, <line17> boolean defaultSender) <line18> throws PortalException { <line19> validateAccount( <line20> incomingHostName, <line21> incomingPort, <line22> incomingSecure, <line23> outgoingHostName, <line24> outgoingPort, <line25> outgoingSecure, <line26> login, <line27> password); <line28> try { <line29> AccountLocalServiceUtil.getAccount(user.getUserId(), address); <line30> throw new MailException(MailException.ACCOUNT_ALREADY_EXISTS); <line31> } catch (NoSuchAccountException noSuchAccountException) { <line32> if (_log.isDebugEnabled()) { <line33> } <line34> long inboxFolderId = 0; <line35> long draftFolderId = 0; <line36> long sentFolderId = 0; <line37> long trashFolderId = 0; <line38> return AccountLocalServiceUtil.addAccount( <line39> user.getUserId(), <line40> address, <line41> personalName, <line42> protocol, <line43> incomingHostName, <line44> incomingPort, <line45> incomingSecure, <line46> outgoingHostName, <line47> outgoingPort, <line48> outgoingSecure, <line49> login, <line50> password, <line51> savePassword, <line52> signature, <line53> useSignature, <line54> folderPrefix, <line55> inboxFolderId, <line56> draftFolderId, <line57> sentFolderId, <line58> trashFolderId, <line59> defaultSender); <line60> } <line61> } <line62> } <line63> 	<line33>
6265	"public class A { <line0> @RequestMapping(""${uri.path.page}/atom/{identifier}/c"") <line1> public String showConnectionURIListPage( <line2> @PathVariable String identifier, <line3> @RequestParam(value = ""p"", required = false) Integer page, <line4> @RequestParam(value = ""deep"", defaultValue = ""false"") boolean deep, <line5> @RequestParam(value = ""resumebefore"", required = false) String resumeBefore, <line6> @RequestParam(value = ""resumeafter"", required = false) String resumeAfter, <line7> @RequestParam(value = ""type"", required = false) String type, <line8> @RequestParam(value = ""timeof"", required = false) String timestamp, <line9> @RequestParam(value = ""state"", required = false) String state, <line10> HttpServletRequest request, <line11> Model model, <line12> HttpServletResponse response) { <line13> URI atomURI = uriService.createAtomURIForId(identifier); <line14> try { <line15> ConnectionState connectionState = getConnectionState(state); <line16> DateParameter dateParam = new DateParameter(timestamp); <line17> WonMessageType eventsType = getMessageType(type); <line18> Dataset rdfDataset; <line19> if (page != null) { <line20> rdfDataset = <line21> linkedDataService <line22> .listConnections( <line23> page, <line24> atomURI, <line25> null, <line26> eventsType, <line27> dateParam.getDate(), <line28> deep, <line29> true, <line30> connectionState) <line31> .getContent(); <line32> } else if (resumeBefore != null) { <line33> URI connURI; <line34> try { <line35> connURI = new URI(resumeBefore); <line36> } catch (URISyntaxException e) { <line37> throw new IllegalArgumentException(""resumeBefore must be a full, valid connection URI""); <line38> } <line39> rdfDataset = <line40> linkedDataService <line41> .listConnectionsAfter( <line42> atomURI, <line43> connURI, <line44> null, <line45> eventsType, <line46> dateParam.getDate(), <line47> deep, <line48> true, <line49> connectionState) <line50> .getContent(); <line51> } else if (resumeAfter != null) { <line52> URI connURI; <line53> try { <line54> connURI = new URI(resumeAfter); <line55> } catch (URISyntaxException e) { <line56> throw new IllegalArgumentException(""resumeAfter must be a full, valid connection URI""); <line57> } <line58> rdfDataset = <line59> linkedDataService <line60> .listConnectionsBefore( <line61> atomURI, <line62> connURI, <line63> null, <line64> eventsType, <line65> dateParam.getDate(), <line66> deep, <line67> true, <line68> connectionState) <line69> .getContent(); <line70> } else { <line71> rdfDataset = <line72> linkedDataService.listConnections(atomURI, deep, true, connectionState).getContent(); <line73> } <line74> model.addAttribute(""rdfDataset"", rdfDataset); <line75> model.addAttribute( <line76> ""resourceURI"", <line77> uriService.toResourceURIIfPossible(URI.create(request.getRequestURI())).toString()); <line78> model.addAttribute( <line79> ""dataURI"", <line80> uriService.toDataURIIfPossible(URI.create(request.getRequestURI())).toString()); <line81> return ""rdfDatasetView""; <line82> } catch (ParseException e) { <line83> model.addAttribute(""error"", ""could not parse timestamp parameter""); <line84> return ""notFoundView""; <line85> } catch (NoSuchAtomException e) { <line86> response.setStatus(HttpServletResponse.SC_NOT_FOUND); <line87> return ""notFoundView""; <line88> } catch (NoSuchConnectionException e) { <line89> return ""notFoundView""; <line90> } <line91> } <line92> } <line93> "	<line89>
6266	"public class A { <line0> public static com.liferay.marketplace.model.App updateApp( <line1> HttpPrincipal httpPrincipal, java.io.File file) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(AppServiceUtil.class, ""updateApp"", _updateAppParameterTypes3); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, file); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.marketplace.model.App) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>
6267	"public class A { <line0> public List<DownloadFile> download() throws IOException, InterruptedException { <line1> List<DownloadFile> downloadFiles = new ArrayList<>(); <line2> Path oboFolder = downloadFolder.resolve(""ontology""); <line3> Files.createDirectories(oboFolder); <line4> String url = configuration.getDownload().getHpoObo().getHost(); <line5> downloadFiles.add(downloadFile(url, oboFolder.resolve(""hp.obo"").toString())); <line6> saveVersionData( <line7> EtlCommons.OBO_DATA, <line8> ""HPO"", <line9> getTimeStamp(), <line10> getTimeStamp(), <line11> Collections.singletonList(url), <line12> buildFolder.resolve(EtlCommons.HPO_VERSION_FILE)); <line13> url = configuration.getDownload().getGoObo().getHost(); <line14> downloadFiles.add(downloadFile(url, oboFolder.resolve(""go-basic.obo"").toString())); <line15> saveVersionData( <line16> EtlCommons.OBO_DATA, <line17> ""GO"", <line18> getTimeStamp(), <line19> getTimeStamp(), <line20> Collections.singletonList(url), <line21> buildFolder.resolve(EtlCommons.GO_VERSION_FILE)); <line22> url = configuration.getDownload().getDoidObo().getHost(); <line23> downloadFiles.add(downloadFile(url, oboFolder.resolve(""doid.obo"").toString())); <line24> saveVersionData( <line25> EtlCommons.OBO_DATA, <line26> ""DO"", <line27> getTimeStamp(), <line28> getTimeStamp(), <line29> Collections.singletonList(url), <line30> buildFolder.resolve(EtlCommons.DO_VERSION_FILE)); <line31> return downloadFiles; <line32> } <line33> } <line34> "	<line1>
6268	"public class A { <line0> private void throwExceptionWhenFailOnNoContracts( <line1> @Nullable File file, String contractsRepository) { <line2> if (StringUtils.hasText(contractsRepository)) { <line3> if (getLogger().isDebugEnabled()) { <line4> getLogger() <line5> } <line6> return; <line7> } <line8> if (failOnNoContracts.get() && (!file.exists() || file.listFiles().length == 0)) { <line9> String path = file.getAbsolutePath(); <line10> throw new GradleException( <line11> ""Contracts could not be found: ["" <line12> + path <line13> + ""]\n"" <line14> + ""Please make sure that the contracts were defined, or set the [failOnNoContracts]"" <line15> + "" flag to [false]""); <line16> } <line17> } <line18> } <line19> "	<line5>
6269	"public class A { <line0> @Override <line1> public void writeTo(final Packer pk) throws IOException { <line2> if (pk == null) { <line3> throw new IllegalArgumentException(""packer is null""); <line4> } <line5> try { <line6> pk.writeMapBegin(3); <line7> doWriteTo(pk); <line8> } catch (IOException ex) { <line9> throw ex; <line10> } finally { <line11> pk.writeMapEnd(); <line12> } <line13> } <line14> } <line15> "	<line9>
6270	"public class A { <line0> protected void insertGuiFragment(GuiFragment guiFragment, Connection conn) { <line1> PreparedStatement stat = null; <line2> try { <line3> stat = conn.prepareStatement(ADD_GUIFRAGMENT); <line4> int index = 1; <line5> stat.setString(index++, guiFragment.getCode()); <line6> if (StringUtils.isNotBlank(guiFragment.getWidgetTypeCode())) { <line7> stat.setString(index++, guiFragment.getWidgetTypeCode()); <line8> } else { <line9> stat.setNull(index++, Types.VARCHAR); <line10> } <line11> if (StringUtils.isNotBlank(guiFragment.getPluginCode())) { <line12> stat.setString(index++, guiFragment.getPluginCode()); <line13> } else { <line14> stat.setNull(index++, Types.VARCHAR); <line15> } <line16> stat.setString(index++, guiFragment.getGui()); <line17> stat.setInt(index++, 0); <line18> stat.executeUpdate(); <line19> } catch (Throwable t) { <line20> throw new RuntimeException(""Error on insert guiFragment"", t); <line21> } finally { <line22> this.closeDaoResources(null, stat); <line23> } <line24> } <line25> } <line26> "	<line20>
6271	"public class A { <line0> @Override <line1> public void grantFunctionPrivileges( <line2> String schemaName, String functionName, Collection<Privilege> privileges, String toUser) { <line3> final String objectName = DataDefinitionUtil.getQualifiedName(schemaName, functionName); <line4> DataDefinitionUtil.assertValidName(toUser); <line5> final String privs = privilegeString(privileges); <line6> final String grant = ""GRANT "" + privs + "" ON FUNCTION "" + objectName + "" TO "" + toUser; <line7> runStatement(grant); <line8> } <line9> } <line10> "	<line7>
6272	public class A { <line0> @Override <line1> public Path move( <line2> final Path source, <line3> final Path target, <line4> final TransferStatus status, <line5> final Delete.Callback callback, <line6> final ConnectionCallback connectionCallback) <line7> throws BackgroundException { <line8> if (containerService.isContainer(source)) { <line9> if (new SimplePathPredicate(source.getParent()).test(target.getParent())) { <line10> return proxy.move(source, target, status, callback, connectionCallback); <line11> } <line12> } <line13> if (nodeid.isEncrypted(source) ^ nodeid.isEncrypted(target)) { <line14> final Copy copy = <line15> new SDSDelegatingCopyFeature(session, nodeid, new SDSCopyFeature(session, nodeid)); <line16> if (log.isDebugEnabled()) { <line17> } <line18> final Path c = copy.copy(source, target, status, connectionCallback); <line19> final Delete delete = new SDSDeleteFeature(session, nodeid); <line20> if (delete.isSupported(source)) { <line21> delete.delete(Collections.singletonMap(source, status), connectionCallback, callback); <line22> } <line23> return c; <line24> } else { <line25> return proxy.move(source, target, status, callback, connectionCallback); <line26> } <line27> } <line28> } <line29> 	<line17>, <line21>
6273	public class A { <line0> private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) { <line1> try { <line2> Iterable<StopTime> interpolatedStopTimesForTrip = <line3> gtfsFeed.getInterpolatedStopTimesForTrip(tripUpdate.trip.trip_id); <line4> long nStopTimes = <line5> StreamSupport.stream(interpolatedStopTimesForTrip.spliterator(), false).count(); <line6> if (nStopTimes != tripUpdate.stopTimes.size()) { <line7> } <line8> } catch (GTFSFeed.FirstAndLastStopsDoNotHaveTimes firstAndLastStopsDoNotHaveTimes) { <line9> throw new RuntimeException(firstAndLastStopsDoNotHaveTimes); <line10> } <line11> } <line12> } <line13> 	<line6>, <line7>
6274	public class A { <line0> private void logReceivedParameters() { <line1> if (this.numberOfWorkers <= 0) { <line2> } <line3> } <line4> } <line5> 	<line2>
6275	public class A { <line0> private void logToolRefresh(final String dashboardPrefix, final Tool tool) { <line1> List<String> descriptorTypes = tool.getDescriptorType(); <line2> String name = tool.getEntryPath(); <line3> for (String descriptorType : descriptorTypes) { <line4> } <line5> } <line6> } <line7> 	<line4>
6276	public class A { <line0> public CompletableFuture<Optional<Topic>> getTopic(final String topic, boolean createIfMissing) { <line1> try { <line2> CompletableFuture<Optional<Topic>> topicFuture = topics.get(topic); <line3> if (topicFuture != null) { <line4> if (topicFuture.isCompletedExceptionally() <line5> || (topicFuture.isDone() && !topicFuture.getNow(Optional.empty()).isPresent())) { <line6> topics.remove(topic, topicFuture); <line7> } else { <line8> if (createIfMissing) { <line9> if (topicFuture.isDone() && topicFuture.getNow(Optional.empty()).isPresent()) { <line10> return topicFuture; <line11> } else { <line12> return topicFuture.thenCompose( <line13> value -> { <line14> if (!value.isPresent()) { <line15> return getTopic(topic, createIfMissing); <line16> } else { <line17> return CompletableFuture.completedFuture(value); <line18> } <line19> }); <line20> } <line21> } else { <line22> return topicFuture; <line23> } <line24> } <line25> } <line26> final boolean isPersistentTopic = <line27> TopicName.get(topic).getDomain().equals(TopicDomain.persistent); <line28> if (isPersistentTopic) { <line29> return topics.computeIfAbsent( <line30> topic, <line31> (topicName) -> { <line32> return this.loadOrCreatePersistentTopic(topicName, createIfMissing); <line33> }); <line34> } else { <line35> return topics.computeIfAbsent( <line36> topic, <line37> (name) -> { <line38> final TopicName topicName = TopicName.get(name); <line39> if (topicName.isPartitioned()) { <line40> final TopicName partitionedTopicName = <line41> TopicName.get(topicName.getPartitionedTopicName()); <line42> return this.fetchPartitionedTopicMetadataAsync(partitionedTopicName) <line43> .thenCompose( <line44> (metadata) -> { <line45> if (topicName.getPartitionIndex() < metadata.partitions) { <line46> return createNonPersistentTopic(name); <line47> } <line48> return CompletableFuture.completedFuture(Optional.empty()); <line49> }); <line50> } else if (createIfMissing) { <line51> return createNonPersistentTopic(name); <line52> } else { <line53> return CompletableFuture.completedFuture(Optional.empty()); <line54> } <line55> }); <line56> } <line57> } catch (IllegalArgumentException e) { <line58> return FutureUtil.failedFuture(e); <line59> } catch (RuntimeException e) { <line60> Throwable cause = e.getCause(); <line61> if (cause instanceof ServiceUnitNotReadyException) { <line62> } else { <line63> } <line64> return FutureUtil.failedFuture(cause); <line65> } <line66> } <line67> } <line68> 	<line58>, <line62>, <line63>
6277	"public class A { <line0> @Override <line1> public void init(Properties props) throws SystemException { <line2> if (props == null) { <line3> props = new Properties(); <line4> } <line5> final String dir = props.getProperty(EnvProps.IM_PASSIVATOR_PATH_PREFIX); <line6> try { <line7> if (dir != null) { <line8> sessionDirectory = SystemInstance.get().getBase().getDirectory(dir).getAbsoluteFile(); <line9> } else { <line10> sessionDirectory = <line11> new File( <line12> JavaSecurityManagers.getSystemProperty( <line13> ""java.io.tmpdir"", File.separator + ""tmp"")) <line14> .getAbsoluteFile(); <line15> } <line16> if (!sessionDirectory.exists() && !sessionDirectory.mkdirs()) { <line17> throw new IOException(""Failed to create directory: "" + sessionDirectory.getAbsolutePath()); <line18> } <line19> } catch (final IOException e) { <line20> throw new SystemException( <line21> getClass().getName() + "".init(): can't use directory prefix "" + dir + "":"" + e, e); <line22> } <line23> } <line24> } <line25> "	<line19>
6278	"public class A { <line0> private static Task load(File path, ClassLoader loader) throws IOException { <line1> JarFile jar = new JarFile(path); <line2> Manifest manifest = jar.getManifest(); <line3> String pkg = manifest.getMainAttributes().getValue(""Package""); <line4> String main = manifest.getMainAttributes().getValue(""Main-Class""); <line5> if (null == pkg || null == main) <line6> throw new NullPointerException(""Package or main class not found "" + ""in menifest file.""); <line7> String namespace = pkg + File.separator + main; <line8> namespace = namespace.replaceAll(File.separator, "".""); <line9> URLClassLoader child = new URLClassLoader(new URL[] {path.toURI().toURL()}, loader); <line10> Thread.currentThread().setContextClassLoader(child); <line11> Class<?> taskClass = null; <line12> try { <line13> taskClass = Class.forName(namespace, true, child); <line14> } catch (ClassNotFoundException cnfe) { <line15> } <line16> if (null == taskClass) return null; <line17> try { <line18> return (Task) taskClass.newInstance(); <line19> } catch (InstantiationException ie) { <line20> } catch (IllegalAccessException iae) { <line21> } <line22> return null; <line23> } <line24> } <line25> "	<line9>, <line15>, <line20>, <line21>
6279	"public class A { <line0> @PluginFactory <line1> public static SendAppender createAppender( <line2> @PluginAttribute(""name"") String name, <line3> @PluginElement(""Filter"") final Filter filter, <line4> @PluginElement(""Layout"") Layout<? extends Serializable> layout, <line5> @PluginAttribute(""ignoreExceptions"") boolean ignoreExceptions) { <line6> if (name == null) { <line7> return null; <line8> } <line9> if (layout == null) { <line10> layout = PatternLayout.createDefaultLayout(); <line11> } <line12> return new SendAppender(name, filter, layout, ignoreExceptions); <line13> } <line14> } <line15> "	<line7>
6280	public class A { <line0> @Override <line1> public TaskStatus doInTransaction(TransactionStatus status) { <line2> try { <line3> QueuedTaskHolder queuedTaskHolder = queuedTaskHolderService.getById(queuedTaskHolderId); <line4> final TaskStatus taskStatus; <line5> if (interruptedFlag.isTrue()) { <line6> taskStatus = onInterruptStatus(taskExecutionResult); <line7> } else { <line8> taskStatus = onFailStatus(taskExecutionResult); <line9> } <line10> endTask(queuedTaskHolder, taskStatus); <line11> return taskStatus; <line12> } catch (RuntimeException <line13> | JsonProcessingException <line14> | ServiceException <line15> | SecurityServiceException e) { <line16> throw new RuntimeException(e); <line17> } <line18> } <line19> } <line20> 	<line6>, <line8>
6281	"public class A { <line0> public static MCRDirectory importFiles(File local, String ownerID) { <line1> if (Objects.requireNonNull(ownerID, ""owner ID"" + "" is null"").trim().isEmpty()) { <line2> throw new MCRUsageException(""owner ID"" + "" is an empty String""); <line3> } <line4> MCRDirectory dir = new MCRDirectory(ownerID); <line5> try { <line6> importFiles(local, dir); <line7> } catch (Exception ex) { <line8> try { <line9> dir.delete(); <line10> } catch (Exception ignored) { <line11> } <line12> if (ex instanceof RuntimeException) { <line13> throw (RuntimeException) ex; <line14> } <line15> throw new MCRException(ex); <line16> } <line17> return dir; <line18> } <line19> } <line20> "	<line11>
6282	public class A { <line0> @Override <line1> public void run() { <line2> while (true) { <line3> State current = state.get(); <line4> switch (current) { <line5> case DISPATCH: <line6> { <line7> if (state.compareAndSet(current, State.EXECUTE)) runnable.run(); <line8> continue; <line9> } <line10> case EXECUTE: <line11> { <line12> if (state.compareAndSet(current, State.IDLE)) return; <line13> continue; <line14> } <line15> case SCHEDULE: <line16> { <line17> if (state.compareAndSet(current, State.DISPATCH)) continue; <line18> throw new IllegalStateException(); <line19> } <line20> default: <line21> { <line22> throw new IllegalStateException(); <line23> } <line24> } <line25> } <line26> } <line27> } <line28> 	<line4>
6283	"public class A { <line0> @Test <line1> public void simpleScheduleAlwaysFiredUnder20s() throws Exception { <line2> Properties properties = new Properties(); <line3> InputStream propertiesIs = getClass().getResourceAsStream(""/org/quartz/quartz.properties""); <line4> try { <line5> properties.load(propertiesIs); <line6> } finally { <line7> propertiesIs.close(); <line8> } <line9> properties.setProperty(""org.quartz.scheduler.skipUpdateCheck"", ""true""); <line10> properties.setProperty(""org.quartz.jobStore.class"", SlowRAMJobStore.class.getName()); <line11> SchedulerFactory sf = new StdSchedulerFactory(properties); <line12> Scheduler sched = sf.getScheduler(); <line13> JobDetail job = <line14> newJob(CollectDuractionBetweenFireTimesJob.class).withIdentity(""job"", ""group"").build(); <line15> SimpleTrigger trigger = <line16> newTrigger() <line17> .withIdentity(""trigger1"", ""group1"") <line18> .startAt(new Date(System.currentTimeMillis() + 1000)) <line19> .withSchedule( <line20> simpleSchedule() <line21> .withIntervalInSeconds(1) <line22> .repeatForever() <line23> .withMisfireHandlingInstructionIgnoreMisfires()) <line24> .build(); <line25> sched.scheduleJob(job, trigger); <line26> sched.start(); <line27> try { <line28> Thread.sleep(50000L); <line29> } catch (Exception e) { <line30> e.printStackTrace(); <line31> } <line32> List<Long> durationBetweenFireTimesInMillis = <line33> CollectDuractionBetweenFireTimesJob.getDurations(); <line34> assertFalse(""Job was not executed once!"", durationBetweenFireTimesInMillis.isEmpty()); <line35> for (long durationInMillis : durationBetweenFireTimesInMillis) { <line36> assertTrue( <line37> ""Missed an execution with one duration being between two fires: "" <line38> + durationInMillis <line39> + "" (all: "" <line40> + durationBetweenFireTimesInMillis <line41> + "")"", <line42> durationInMillis < 20000); <line43> } <line44> } <line45> } <line46> "	<line13>, <line27>
6284	public class A { <line0> private void resolveArtifact(ResolutionNode node) throws ArtifactResolutionException { <line1> try { <line2> resolve(node.getArtifact(), node.getRemoteRepositories(), localRepository); <line3> resolvedArtifacts.add(node.getArtifact()); <line4> } catch (ArtifactNotFoundException anfe) { <line5> missingArtifacts.add(node.getArtifact()); <line6> } <line7> } <line8> } <line9> 	<line5>
6285	public class A { <line0> @Override <line1> protected void doneWithContext() { <line2> if (!isCancelled()) { <line3> try { <line4> m_statusMessageConsumer.accept(get()); <line5> } catch (final ExecutionException e) { <line6> if (!(e.getCause() instanceof InterruptedException)) { <line7> } <line8> } catch (InterruptedException ex) { <line9> } <line10> } <line11> } <line12> } <line13> 	<line7>
6286	"public class A { <line0> @Test <line1> public void testConversionRuleSupportInPatternLayout() throws JoranException { <line2> configure(ClassicTestConstants.JORAN_INPUT_PREFIX + ""conversionRule/patternLayout0.xml""); <line3> root.getAppender(""LIST""); <line4> String msg = ""Simon says""; <line5> StringListAppender<ILoggingEvent> sla = <line6> (StringListAppender<ILoggingEvent>) root.getAppender(""LIST""); <line7> assertNotNull(sla); <line8> assertEquals(1, sla.strList.size()); <line9> assertEquals(SampleConverter.SAMPLE_STR + "" - "" + msg, sla.strList.get(0)); <line10> } <line11> } <line12> "	<line5>
6287	public class A { <line0> @Override <line1> protected String encodeAndEncrypt(MethodCallMessage secureRequest, SecretKey sessionKey) <line2> throws Exception { <line3> byte[] content = mapper.writeValueAsBytes(secureRequest); <line4> byte[] encryptedContent = CipherUtils.encrypt(content, sessionKey); <line5> EncryptedMessage encryptedMessage = new EncryptedMessage(); <line6> encryptedMessage.setEncryptedContent(encryptedContent); <line7> byte[] encryptedKey = CipherUtils.encrypt(sessionKey.getEncoded(), serverPublicKey); <line8> encryptedMessage.setEncryptedKey(encryptedKey); <line9> return mapper.writeValueAsString(encryptedMessage); <line10> } <line11> } <line12> 	<line4>
6288	public class A { <line0> public TransactionTree getCompressedTree() { <line1> TransactionTree ctree = new TransactionTree(); <line2> Iterator<Pair<IntArrayList, Long>> it = iterator(); <line3> final Map<Integer, MutableLong> fList = generateFList(); <line4> int node = 0; <line5> Comparator<Integer> comparator = <line6> new Comparator<Integer>() { <line7> @Override <line8> public int compare(Integer o1, Integer o2) { <line9> return fList.get(o2).compareTo(fList.get(o1)); <line10> } <line11> }; <line12> int size = 0; <line13> List<Pair<IntArrayList, Long>> compressedTransactionSet = Lists.newArrayList(); <line14> while (it.hasNext()) { <line15> Pair<IntArrayList, Long> p = it.next(); <line16> p.getFirst().sort(); <line17> compressedTransactionSet.add(p); <line18> node += ctree.addPattern(p.getFirst(), p.getSecond()); <line19> size += p.getFirst().size() + 2; <line20> } <line21> if (log.isDebugEnabled()) { <line22> } <line23> if (node * 4 * 4 + ctree.childCount() * 4 <= size * 4) { <line24> return ctree; <line25> } else { <line26> return new TransactionTree(compressedTransactionSet); <line27> } <line28> } <line29> } <line30> 	<line22>
6289	"public class A { <line0> @Override <line1> public void methodToFireBroadcastWithSingleStructParameter(String[] partitions) { <line2> logger.warn(""*******************************************************************""); <line3> } <line4> } <line5> "	<line3>
6290	"public class A { <line0> @Override <line1> public void writeTileMap(String layerId, String styleRef, ProfileType profile, Writer writer) <line2> throws GeomajasException { <line3> TileMap tileMap = new TileMap(); <line4> tileMap.setTitle(layerId); <line5> tileMap.setAbstract(""Tile Map Service publication of the Geomajas layer "" + layerId); <line6> tileMap.setVersion(""1.0.0""); <line7> StringBuilder sb = new StringBuilder(dispatcherUrlService.getDispatcherUrl()); <line8> sb.append(MAPPING_1_0_0.substring(0, MAPPING_1_0_0.length() - 1)); <line9> tileMap.setTileMapService(sb.toString()); <line10> TmsProfile p = null; <line11> VectorLayer layer = configurationService.getVectorLayer(layerId); <line12> StringBuilder href = new StringBuilder(dispatcherUrlService.getDispatcherUrl()); <line13> href.append(MAPPING_1_0_0).append(layerId); <line14> switch (profile) { <line15> case GLOBAL_GEODETIC: <line16> href.append(""@"").append(profile.getCrs()); <line17> tileMap.setSrs(profile.getCrs()); <line18> p = new GlobalGeodeticProfile(); <line19> break; <line20> case GLOBAL_MERCATOR: <line21> href.append(""@"").append(profile.getCrs()); <line22> tileMap.setSrs(profile.getCrs()); <line23> p = new GlobalMercatorProfile(); <line24> break; <line25> case LOCAL: <line26> default: <line27> href.append(""@"").append(layer.getLayerInfo().getCrs()); <line28> tileMap.setSrs(layer.getLayerInfo().getCrs()); <line29> Bbox layerBounds = layer.getLayerInfo().getMaxExtent(); <line30> p = <line31> new LocalProfile( <line32> dtoConverterService.toInternal(layerBounds), TmsController.PROFILE_TILE_SIZE); <line33> break; <line34> } <line35> href.append(""/"").append(layer.getLayerInfo().getNamedStyleInfos().get(0).getName()); <line36> tileMap.setBoundingBox(p.getBounds()); <line37> tileMap.setOrigin(p.getOrigin()); <line38> TileFormat tileFormat = new TileFormat(); <line39> tileFormat.setMimeType(""image/png""); <line40> tileFormat.setExtension(""png""); <line41> tileFormat.setWidth(p.getTileWidth()); <line42> tileFormat.setHeight(p.getTileHeight()); <line43> tileMap.setTileFormat(tileFormat); <line44> tileMap.setProfile(p, href.toString()); <line45> try { <line46> JAXBContext context = JAXBContext.newInstance(TileMap.class); <line47> Marshaller m = context.createMarshaller(); <line48> m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); <line49> m.marshal(tileMap, writer); <line50> } catch (JAXBException e) { <line51> } <line52> } <line53> } <line54> "	<line51>
6291	public class A { <line0> public boolean accept(HttpServletRequest request, PortalContainer container, URI remoteURI) { <line1> boolean trace = log.isTraceEnabled(); <line2> String remoteHost = remoteURI.getHost(); <line3> String remoteServerName = request.getServerName(); <line4> if (remoteHost.equals(remoteServerName)) { <line5> if (trace) { <line6> } <line7> return true; <line8> } <line9> for (int i = 0; i < blackList.size(); i++) { <line10> Pattern pattern = blackList.get(i); <line11> boolean rejected = pattern.matcher(remoteHost).matches(); <line12> if (trace) { <line13> } <line14> if (rejected) { <line15> return false; <line16> } <line17> } <line18> for (int i = 0; i < whiteList.size(); i++) { <line19> Pattern pattern = whiteList.get(i); <line20> boolean accepted = pattern.matcher(remoteHost).matches(); <line21> if (trace) { <line22> } <line23> if (accepted) { <line24> return true; <line25> } <line26> } <line27> return false; <line28> } <line29> } <line30> 	<line6>, <line13>, <line15>, <line22>, <line27>
6292	public class A { <line0> @Override <line1> public boolean supports(Class<?> c) { <line2> return Field.class.isAssignableFrom(c); <line3> } <line4> } <line5> 	<line2>
6293	"public class A { <line0> @GET <line1> @Path(""/photos/{UID}/{ConnectorPrettyName}.{ObjectTypeName}/{unixTime}/{count}"") <line2> @ApiOperation(value = ""Get photos at a given time"", response = PhotoItem.class) <line3> @ApiResponses({@ApiResponse(code = 403, message = ""In case of unauthorized access"")}) <line4> @Produces({MediaType.APPLICATION_JSON}) <line5> public Response getPhotosBeforeOrAfterTime( <line6> @ApiParam(value = ""User ID"", required = true) @PathParam(""UID"") long uid, <line7> @ApiParam(value = ""Connector name"", required = true) @PathParam(""ConnectorPrettyName"") <line8> String connectorPrettyName, <line9> @ApiParam(value = ""Object type name"", required = true) @PathParam(""ObjectTypeName"") <line10> String objectTypeName, <line11> @ApiParam(value = ""Timestamp (epoch seconds)"", required = true) @PathParam(""unixTime"") <line12> double unixTimeInSecs, <line13> @ApiParam(value = ""Photo count limit"", required = true) @PathParam(""count"") int desiredCount, <line14> @ApiParam(value = ""Is before time"", required = true) @QueryParam(""isBefore"") <line15> boolean isGetPhotosBeforeTime, <line16> @ApiParam(value = ""Tags for matching"", required = true) @QueryParam(""tags"") String tagsStr, <line17> @ApiParam(value = ""Tag matching strategy"", required = true) @QueryParam(""tag-match"") <line18> String tagMatchingStrategyName) { <line19> try { <line20> final TagFilter.FilteringStrategy tagFilteringStrategy = <line21> TagFilter.FilteringStrategy.findByName(tagMatchingStrategyName); <line22> if (isUnauthorized(uid)) { <line23> return Response.status(Response.Status.UNAUTHORIZED) <line24> .entity(""Invalid User ID (null)"") <line25> .build(); <line26> } <line27> final TagFilter tagFilter = <line28> TagFilter.create( <line29> Tag.parseTagsIntoStrings(tagsStr, Tag.COMMA_DELIMITER), tagFilteringStrategy); <line30> final SortedSet<PhotoService.Photo> photos = <line31> photoService.getPhotos( <line32> uid, <line33> (long) (unixTimeInSecs * 1000), <line34> connectorPrettyName, <line35> objectTypeName, <line36> desiredCount, <line37> isGetPhotosBeforeTime, <line38> tagFilter); <line39> final List<PhotoItem> photoItems = new ArrayList<PhotoItem>(); <line40> for (final PhotoService.Photo photo : photos) { <line41> photoItems.add(new PhotoItem(photo)); <line42> } <line43> return Response.ok(gson.toJson(photoItems)).build(); <line44> } catch (Exception e) { <line45> return Response.status(Response.Status.UNAUTHORIZED).entity(""Access Denied"").build(); <line46> } <line47> } <line48> } <line49> "	<line45>
6294	public class A { <line0> protected void dumpRoutes(CamelContext context, RoutesDefinition definition) { <line1> try { <line2> } catch (JAXBException e) { <line3> } <line4> } <line5> } <line6> 	<line2>, <line3>
6295	"public class A { <line0> private void sendInvalidCredentials( <line1> LdapSession ldapSession, BindResponse bindResponse, Exception e) { <line2> LdapResult result = bindResponse.getLdapResult(); <line3> String message = """"; <line4> if (e != null) { <line5> message = ResultCodeEnum.INVALID_CREDENTIALS + "": "" + e.getLocalizedMessage(); <line6> } else { <line7> message = ResultCodeEnum.INVALID_CREDENTIALS.toString(); <line8> } <line9> result.setResultCode(ResultCodeEnum.INVALID_CREDENTIALS); <line10> result.setDiagnosticMessage(message); <line11> ldapSession.clearSaslProperties(); <line12> ldapSession.setAnonymous(); <line13> ldapSession.getIoSession().write(bindResponse); <line14> } <line15> } <line16> "	<line9>
6296	public class A { <line0> private void stopComponents( <line1> final String processGroupId, <line2> final Map<String, Revision> componentRevisions, <line3> final Map<String, AffectedComponentEntity> affectedComponents, <line4> final Pause pause, <line5> final InvalidComponentAction invalidComponentAction) <line6> throws LifecycleManagementException { <line7> if (componentRevisions.isEmpty()) { <line8> return; <line9> } <line10> serviceFacade.verifyScheduleComponents( <line11> processGroupId, ScheduledState.STOPPED, componentRevisions.keySet()); <line12> serviceFacade.scheduleComponents(processGroupId, ScheduledState.STOPPED, componentRevisions); <line13> waitForProcessorState( <line14> processGroupId, affectedComponents, ScheduledState.STOPPED, pause, invalidComponentAction); <line15> } <line16> } <line17> 	<line10>
6297	public class A { <line0> @Override <line1> public void invalidateCache( <line2> TenantKey key, final Object cookie, final InternalTenantContext tenantContext) { <line3> catalogCache.clearCatalog(tenantContext); <line4> } <line5> } <line6> 	<line3>
6298	public class A { <line0> private void _sleepForPollPeriod() { <line1> try { <line2> Thread.sleep(POLL_INTERVAL_MS); <line3> } catch (InterruptedException ex) { <line4> Thread.currentThread().interrupt(); <line5> } <line6> } <line7> } <line8> 	<line2>, <line4>
6299	"public class A { <line0> static String findNonProgressingOp(Resource resource, boolean forServer, long timeout) <line1> throws OperationFailedException { <line2> Resource.ResourceEntry nonProgressing = null; <line3> for (Resource.ResourceEntry child : resource.getChildren(ACTIVE_OPERATION)) { <line4> ModelNode model = child.getModel(); <line5> if (model.get(EXCLUSIVE_RUNNING_TIME).asLong() > timeout) { <line6> nonProgressing = child; <line7> ControllerLogger.MGMT_OP_LOGGER.tracef(""non-progressing op: %s"", nonProgressing.getModel()); <line8> break; <line9> } <line10> } <line11> if (nonProgressing != null && !forServer) { <line12> ModelNode model = nonProgressing.getModel(); <line13> if (model.get(DOMAIN_ROLLOUT).asBoolean() <line14> && OperationContext.ExecutionStatus.COMPLETING <line15> .toString() <line16> .equals(model.get(EXECUTION_STATUS).asString()) <line17> && model.hasDefined(DOMAIN_UUID)) { <line18> String domainUUID = model.get(DOMAIN_UUID).asString(); <line19> Set<String> relatedIds = null; <line20> List<Resource.ResourceEntry> relatedExecutingOps = null; <line21> for (Resource.ResourceEntry activeOp : resource.getChildren(ACTIVE_OPERATION)) { <line22> if (nonProgressing.getName().equals(activeOp.getName())) { <line23> continue; <line24> } <line25> ModelNode opModel = activeOp.getModel(); <line26> if (opModel.hasDefined(DOMAIN_UUID) <line27> && domainUUID.equals(opModel.get(DOMAIN_UUID).asString()) <line28> && opModel.get(RUNNING_TIME).asLong() > timeout) { <line29> if (relatedIds == null) { <line30> relatedIds = new TreeSet<String>(); <line31> } <line32> relatedIds.add(activeOp.getName()); <line33> if (OperationContext.ExecutionStatus.EXECUTING <line34> .toString() <line35> .equals(opModel.get(EXECUTION_STATUS).asString())) { <line36> if (relatedExecutingOps == null) { <line37> relatedExecutingOps = new ArrayList<Resource.ResourceEntry>(); <line38> } <line39> relatedExecutingOps.add(activeOp); <line40> ControllerLogger.MGMT_OP_LOGGER.tracef(""Related executing: %s"", opModel); <line41> } else ControllerLogger.MGMT_OP_LOGGER.tracef(""Related non-executing: %s"", opModel); <line42> } else ControllerLogger.MGMT_OP_LOGGER.tracef(""unrelated: %s"", opModel); <line43> } <line44> if (relatedIds != null) { <line45> if (relatedExecutingOps != null && relatedExecutingOps.size() == 1) { <line46> nonProgressing = relatedExecutingOps.get(0); <line47> } else { <line48> throw DomainManagementLogger.ROOT_LOGGER.domainRolloutNotProgressing( <line49> nonProgressing.getName(), timeout, domainUUID, relatedIds); <line50> } <line51> } <line52> } <line53> } <line54> return nonProgressing == null ? null : nonProgressing.getName(); <line55> } <line56> } <line57> "	<line18>
6300	"public class A { <line0> private void describeAvailableLanguagePlugins(DefaultPluginManager languagePluginManager) { <line1> List<PluginWrapper> plugins = languagePluginManager.getStartedPlugins(); <line2> if (plugins.isEmpty()) { <line3> return; <line4> } <line5> StringBuilder builder = new StringBuilder(); <line6> builder.append(""PluginId\tPlugin Version\tPlugin Path\tInitial Path Pattern\tPlugin Type(s)\n""); <line7> for (PluginWrapper plugin : plugins) { <line8> builder.append(plugin.getPluginId()); <line9> builder.append(""\t""); <line10> builder.append(plugin.getPlugin().getWrapper().getDescriptor().getVersion()); <line11> builder.append(""\t""); <line12> builder.append(plugin.getPlugin().getWrapper().getPluginPath()); <line13> builder.append(""\t""); <line14> List<CompleteLanguageInterface> completeLanguageInterfaces = <line15> languagePluginManager.getExtensions( <line16> CompleteLanguageInterface.class, plugin.getPluginId()); <line17> List<RecommendedLanguageInterface> recommendedLanguageInterfaces = <line18> languagePluginManager.getExtensions( <line19> RecommendedLanguageInterface.class, plugin.getPluginId()); <line20> List<MinimalLanguageInterface> minimalLanguageInterfaces = <line21> languagePluginManager.getExtensions(MinimalLanguageInterface.class, plugin.getPluginId()); <line22> minimalLanguageInterfaces.forEach( <line23> extension -> <line24> Joiner.on(',') <line25> .appendTo(builder, Collections.singleton(extension.initialPathPattern()))); <line26> builder.append(""\t""); <line27> minimalLanguageInterfaces.forEach( <line28> extension -> Joiner.on(',').appendTo(builder, Collections.singleton(""Minimal""))); <line29> builder.append("" ""); <line30> recommendedLanguageInterfaces.forEach( <line31> extension -> Joiner.on(',').appendTo(builder, Collections.singleton(""Recommended""))); <line32> builder.append("" ""); <line33> completeLanguageInterfaces.forEach( <line34> extension -> Joiner.on(',').appendTo(builder, Collections.singleton(""Complete""))); <line35> builder.append(""\n""); <line36> } <line37> } <line38> } <line39> "	<line3>, <line37>
6301	"public class A { <line0> private void logFormatUsage() { <line1> StringBuilder builder = new StringBuilder(); <line2> for (NavigationFormat format : getNavigationFormatRegistry().getFormatsSortedByName()) { <line3> int reads = preferences.getInt(READ_COUNT_PREFERENCE + format.getClass().getName(), 0); <line4> int writes = preferences.getInt(WRITE_COUNT_PREFERENCE + format.getClass().getName(), 0); <line5> if (reads > 0 || writes > 0) <line6> builder.append(format(""%n%s, reads: %d, writes: %d"", format.getName(), reads, writes)); <line7> } <line8> } <line9> } <line10> "	<line8>
6302	public class A { <line0> private String[] resolvePlaceholders(String value) { <line1> String resolved = resolver.resolvePlaceholders(value); <line2> if (StringUtils.isBlank(resolved)) { <line3> return StringUtils.EMPTY_STRING_ARRAY; <line4> } <line5> return StringUtils.split(resolved, ','); <line6> } <line7> } <line8> 	<line3>
6303	public class A { <line0> public Command<T[]> command() { <line1> Command<T[]> command = getCommand(); <line2> command <line3> .future() <line4> .addListener( <line5> new CommandFutureListener<T[]>() { <line6> @Override <line7> public void operationComplete(CommandFuture<T[]> commandFuture) { <line8> if (!commandFuture.isSuccess()) { <line9> return; <line10> } <line11> updateRelevantField(commandFuture.getNow()); <line12> } <line13> }); <line14> return command; <line15> } <line16> } <line17> 	<line9>
6304	public class A { <line0> @Override <line1> public void postStop() throws Exception { <line2> super.postStop(); <line3> for (AkkaRpcActorRegistration actorRegistration : registeredAkkaRpcActors.values()) { <line4> terminateAkkaRpcActorOnStop(actorRegistration); <line5> } <line6> registeredAkkaRpcActors.clear(); <line7> } <line8> } <line9> 	<line2>
6305	public class A { <line0> @Override <line1> public AppendMessageResult<T> append(LogRecord log, LogAppender<T, LogRecord> appender) { <line2> appender.lockAppender(); <line3> try { <line4> long currentPos = wrotePosition.get(); <line5> AppendRecordResult<T> result = appender.appendLog(log); <line6> AppendMessageStatus status = result.getStatus(); <line7> if (AppendMessageStatus.SUCCESS != result.getStatus()) { <line8> return new AppendMessageResult<>(AppendMessageStatus.UNKNOWN_ERROR, -1, -1); <line9> } <line10> int wroteBytes = result.getWroteBytes(); <line11> int writes = fileChannel.write(result.getBuffer(), currentPos); <line12> if (writes != wroteBytes) { <line13> return new AppendMessageResult<>(AppendMessageStatus.APPEND_FAILED, -1, -1); <line14> } <line15> long channelPosition = wrotePosition.addAndGet(wroteBytes); <line16> this.needFlush.set(true); <line17> fileChannel.position(channelPosition); <line18> return new AppendMessageResult<>( <line19> AppendMessageStatus.SUCCESS, currentPos, wroteBytes, result.getAdditional()); <line20> } catch (Exception e) { <line21> return new AppendMessageResult<>(AppendMessageStatus.UNKNOWN_ERROR, -1, -1); <line22> } finally { <line23> appender.unlockAppender(); <line24> } <line25> } <line26> } <line27> 	<line8>, <line13>, <line21>
6306	public class A { <line0> @Override <line1> public void queueApplicableAutoPings(WeblogEntry changedWeblogEntry) throws WebloggerException { <line2> if (PingConfig.getSuspendPingProcessing()) { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> return; <line6> } <line7> PingQueueManager pingQueueMgr = roller.getPingQueueManager(); <line8> List<AutoPing> applicableAutopings = getApplicableAutoPings(changedWeblogEntry); <line9> for (AutoPing autoPing : applicableAutopings) { <line10> pingQueueMgr.addQueueEntry(autoPing); <line11> } <line12> } <line13> } <line14> 	<line4>
6307	public class A { <line0> @Override <line1> public void info(String message) { <line2> if (verbose) { <line3> } <line4> } <line5> } <line6> 	<line3>
6308	public class A { <line0> @Override <line1> public void updateVirtualIps(LoadBalancerEndpointConfiguration config, LoadBalancer loadBalancer) <line2> throws InsufficientRequestException, StmRollBackException { <line3> StingrayRestClient client = getResources().loadSTMRestClient(config); <line4> ResourceTranslator translator = ResourceTranslator.getNewResourceTranslator(); <line5> String vsName = ZxtmNameBuilder.genVSName(loadBalancer); <line6> translator.translateLoadBalancerResource(config, vsName, loadBalancer, loadBalancer); <line7> getResources().updateVirtualIps(client, vsName, translator.getcTrafficIpGroups()); <line8> getResources().updateVirtualServer(client, vsName, translator.getcVServer()); <line9> client.destroy(); <line10> } <line11> } <line12> 	<line7>, <line8>, <line9>
6309	"public class A { <line0> public String formatMessage(final String commitMessage) { <line1> final ServletContext servletContext = pageContext.getServletContext(); <line2> final WebApplicationContext context = <line3> WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); <line4> try { <line5> final Map<String, CommitMessageDisplayFormatter> formatterBeans = <line6> BeanFactoryUtils.beansOfTypeIncludingAncestors( <line7> context, CommitMessageDisplayFormatter.class); <line8> if (formatterBeans.size() == 0) { <line9> return StringEscapeUtils.escapeHtml4(commitMessage); <line10> } else if (formatterBeans.size() == 1) { <line11> CommitMessageDisplayFormatter formatter = <line12> (CommitMessageDisplayFormatter) formatterBeans.values().toArray()[0]; <line13> return formatter.formatMessage(commitMessage); <line14> } else { <line15> throw new IllegalArgumentException( <line16> ""Multiple beans of type "" <line17> + CommitMessageDisplayFormatter.class.getSimpleName() <line18> + "" found, expected 0 or 1.""); <line19> } <line20> } catch (Exception e) { <line21> return commitMessage; <line22> } <line23> } <line24> } <line25> "	<line21>
6310	"public class A { <line0> private void doMoveExistingFile(String fileName) throws GenericFileOperationFailedException { <line1> Exchange dummy = endpoint.createExchange(); <line2> String parent = FileUtil.onlyPath(fileName); <line3> String onlyName = FileUtil.stripPath(fileName); <line4> dummy.getIn().setHeader(Exchange.FILE_NAME, fileName); <line5> dummy.getIn().setHeader(Exchange.FILE_NAME_ONLY, onlyName); <line6> dummy.getIn().setHeader(Exchange.FILE_PARENT, parent); <line7> String to = endpoint.getMoveExisting().evaluate(dummy, String.class); <line8> to = FileUtil.normalizePath(to); <line9> if (ObjectHelper.isEmpty(to)) { <line10> throw new GenericFileOperationFailedException( <line11> ""moveExisting evaluated as empty String, cannot move existing file: "" + fileName); <line12> } <line13> File toFile = new File(to); <line14> String directory = toFile.getParent(); <line15> boolean absolute = FileUtil.isAbsolute(toFile); <line16> if (directory != null) { <line17> if (!buildDirectory(directory, absolute)) { <line18> } <line19> } <line20> if (existsFile(to)) { <line21> if (endpoint.isEagerDeleteTargetFile()) { <line22> if (!deleteFile(to)) { <line23> throw new GenericFileOperationFailedException(""Cannot delete file: "" + to); <line24> } <line25> } else { <line26> throw new GenericFileOperationFailedException( <line27> ""Cannot moved existing file from: "" <line28> + fileName <line29> + "" to: "" <line30> + to <line31> + "" as there already exists a file: "" <line32> + to); <line33> } <line34> } <line35> if (!renameFile(fileName, to)) { <line36> throw new GenericFileOperationFailedException( <line37> ""Cannot rename file from: "" + fileName + "" to: "" + to); <line38> } <line39> } <line40> } <line41> "	<line18>, <line22>, <line35>
6311	public class A { <line0> private MapData prepActiveRegionForProcessing( <line1> final ActiveRegion activeRegion, <line2> final ActiveRegionWalker<M, T> walker, <line3> final IntervalReferenceOrderedView referenceOrderedDataView) { <line4> final List<GATKSAMRecord> stillLive = new LinkedList<>(); <line5> for (final GATKSAMRecord read : myReads.popCurrentReads()) { <line6> boolean killed = false; <line7> final GenomeLoc readLoc = this.engine.getGenomeLocParser().createGenomeLoc(read); <line8> if (activeRegion.getLocation().overlapsP(readLoc)) { <line9> activeRegion.add(read); <line10> if (!walker.wantsNonPrimaryReads()) { <line11> killed = true; <line12> } <line13> } else if (walker.wantsExtendedReads() && activeRegion.getExtendedLoc().overlapsP(readLoc)) { <line14> activeRegion.add(read); <line15> } <line16> if (!killed && readCannotOccurInAnyMoreActiveRegions(read, activeRegion)) { <line17> killed = true; <line18> } <line19> if (!killed) stillLive.add(read); <line20> } <line21> myReads.addAll(stillLive); <line22> if (logger.isDebugEnabled()) { <line23> } <line24> if (LOG_READ_CARRYING) <line25> final GenomeLoc loc = activeRegion.getLocation(); <line26> final RefMetaDataTracker tracker = <line27> referenceOrderedDataView.getReferenceOrderedDataForInterval(loc); <line28> referenceOrderedDataView.trimCurrentFeaturesToLoc(loc); <line29> return new MapData(activeRegion, tracker); <line30> } <line31> } <line32> 	<line23>, <line25>
6312	public class A { <line0> @Override <line1> public boolean isVisible(Group group) { <line2> if (group.isCompany()) { <line3> return false; <line4> } <line5> boolean hasCustomAttributesAvailable = false; <line6> try { <line7> hasCustomAttributesAvailable = <line8> CustomAttributesUtil.hasCustomAttributes( <line9> group.getCompanyId(), Group.class.getName(), group.getGroupId(), null); <line10> } catch (Exception exception) { <line11> if (_log.isDebugEnabled()) { <line12> } <line13> } <line14> if (!hasCustomAttributesAvailable) { <line15> return false; <line16> } <line17> return true; <line18> } <line19> } <line20> 	<line12>
6313	public class A { <line0> @Override <line1> public synchronized void onSwitchAppeared(InstanceIdentifier<Table> appearedTablePath) { <line2> if (isLearning) { <line3> return; <line4> } <line5> if (registrationPublisher != null) { <line6> registrationPublisher.getDataTreeChangeListenerRegistration().close(); <line7> } <line8> isLearning = true; <line9> tablePath = appearedTablePath; <line10> nodePath = tablePath.firstIdentifierOf(Node.class); <line11> nodeId = nodePath.firstKeyOf(Node.class).getId(); <line12> mac2portMapping = new HashMap<>(); <line13> FlowId flowId = new FlowId(String.valueOf(flowIdInc.getAndIncrement())); <line14> FlowKey flowKey = new FlowKey(flowId); <line15> InstanceIdentifier<Flow> flowPath = InstanceIdentifierUtils.createFlowPath(tablePath, flowKey); <line16> Uint16 priority = Uint16.ZERO; <line17> FlowBuilder allToCtrlFlow = <line18> FlowUtils.createFwdAllToControllerFlow( <line19> InstanceIdentifierUtils.getTableId(tablePath), priority, flowId); <line20> dataStoreAccessor.writeFlowToConfig(flowPath, allToCtrlFlow.build()); <line21> } <line22> } <line23> 	<line3>, <line5>, <line6>, <line20>
6314	public class A { <line0> @Override <line1> public void resetPassword(String newPassword, Integer secretPin) { <line2> assert newPassword != null; <line3> } <line4> } <line5> 	<line2>
6315	public class A { <line0> @Override <line1> public void onActivityTestRequest(ActivityTestRequest ind) { <line2> TestEvent te = TestEvent.createReceivedEvent(EventType.ActivityTestRequest, ind, sequence++); <line3> this.observerdEvents.add(te); <line4> } <line5> } <line6> 	<line2>
6316	"public class A { <line0> @Override <line1> public void run() { <line2> ThreadHelper.suspend(5000); <line3> AbstractSystemInvoker invoker = getSystemInvokerMgr().getSystemInvoker(InvokerType.HTTP); <line4> for (int i = 0; i < 5; i++) { <line5> UAVHttpMessage msg = new UAVHttpMessage(); <line6> msg.setIntent(""services""); <line7> msg.putRequest(""service"", ""hbserveragent-HeartBeatQueryListenWorker-/hb/query""); <line8> String res = <line9> (String) <line10> invoker.invoke( <line11> ""hbserveragent-HeartBeatQueryListenWorker-/hb/query"", msg, String.class); <line12> } <line13> } <line14> } <line15> "	<line12>, <line13>
6317	"public class A { <line0> @Override <line1> protected void addPersistedPage(String sessionIdentifier, IManageablePage page) { <line2> if (page instanceof SerializedPage == false) { <line3> throw new WicketRuntimeException(""MemcachedDataStore works with serialized pages only""); <line4> } <line5> SerializedPage serializedPage = (SerializedPage) page; <line6> int expirationTime = settings.getExpirationTime(); <line7> MemcachedSet pages = <line8> new MemcachedSet(client, makeKey(sessionIdentifier, SESSION_PAGES), expirationTime); <line9> if (pages.add(String.valueOf(page.getPageId()))) { <line10> MemcachedSet sessions = <line11> new MemcachedSet(client, makeKey(SESSIONS), settings.getExpirationTime()); <line12> sessions.add(sessionIdentifier); <line13> sessions.compact(); <line14> } <line15> client.set( <line16> makeKey(sessionIdentifier, serializedPage.getPageId(), PAGE_DATA), <line17> expirationTime, <line18> serializedPage.getData()); <line19> client.set( <line20> makeKey(sessionIdentifier, serializedPage.getPageId(), PAGE_SIZE), <line21> expirationTime, <line22> serializedPage.getData().length); <line23> if (serializedPage.getPageType() != null) { <line24> client.set( <line25> makeKey(sessionIdentifier, serializedPage.getPageId(), PAGE_TYPE), <line26> expirationTime, <line27> serializedPage.getPageType()); <line28> } <line29> pages.compact(pageId -> client.get(makeKey(sessionIdentifier, pageId, PAGE_SIZE)) != null); <line30> } <line31> } <line32> "	<line30>
6318	"public class A { <line0> public <T extends SvBusResponse> T get(long timeoutMs) throws SocketTimeoutException { <line1> try { <line2> if (!latch.await(timeoutMs, TimeUnit.MILLISECONDS)) { <line3> throw new SocketTimeoutException( <line4> ""WebSocket response wait timeout ("" + timeoutMs + ""ms) exceeded""); <line5> } <line6> } catch (InterruptedException ex) { <line7> Thread.currentThread().interrupt(); <line8> } <line9> return (T) response; <line10> } <line11> } <line12> "	<line7>
6319	"public class A { <line0> @Then(""^the get tariff status async response contains$"") <line1> public void theGetTariffStatusAsyncResponseContains( <line2> final Map<String, String> expectedResponseData) { <line3> final org.opensmartgridplatform.adapter.ws.schema.tariffswitching.adhocmanagement <line4> .GetStatusAsyncResponse <line5> asyncResponse = <line6> (org.opensmartgridplatform.adapter.ws.schema.tariffswitching.adhocmanagement <line7> .GetStatusAsyncResponse) <line8> ScenarioContext.current().get(PlatformPubliclightingKeys.RESPONSE); <line9> assertThat(asyncResponse.getAsyncResponse().getCorrelationUid()).isNotNull(); <line10> assertThat(asyncResponse.getAsyncResponse().getDeviceId()) <line11> .isEqualTo( <line12> getString(expectedResponseData, PlatformPubliclightingKeys.KEY_DEVICE_IDENTIFICATION)); <line13> saveCorrelationUidInScenarioContext( <line14> asyncResponse.getAsyncResponse().getCorrelationUid(), <line15> getString( <line16> expectedResponseData, <line17> PlatformPubliclightingKeys.KEY_ORGANIZATION_IDENTIFICATION, <line18> PlatformPubliclightingDefaults.DEFAULT_ORGANIZATION_IDENTIFICATION)); <line19> } <line20> } <line21> "	<line19>
6320	"public class A { <line0> @Override <line1> public XSIElementHandler getHandler(String namespaceURI, String localName) throws SAXException { <line2> if (SchemaHandler.namespaceURI.equalsIgnoreCase(namespaceURI)) { <line3> logger.fine(""Getting Handler for "" + localName + "" inside Extension""); <line4> if (AllHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line5> AllHandler ah = new AllHandler(); <line6> if (child == null) { <line7> child = ah; <line8> } else { <line9> throw new SAXNotRecognizedException( <line10> getLocalName() + "" may only have one '"" + AllHandler.LOCALNAME + ""' declaration.""); <line11> } <line12> return ah; <line13> } <line14> if (AttributeHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line15> if (attributeDec == null) { <line16> attributeDec = new LinkedList<>(); <line17> } <line18> AttributeHandler ah = new AttributeHandler(); <line19> attributeDec.add(ah); <line20> return ah; <line21> } <line22> if (AttributeGroupHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line23> if (attributeDec == null) { <line24> attributeDec = new LinkedList<>(); <line25> } <line26> AttributeGroupHandler ah = new AttributeGroupHandler(); <line27> attributeDec.add(ah); <line28> return ah; <line29> } <line30> if (ChoiceHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line31> ChoiceHandler ah = new ChoiceHandler(); <line32> if (child == null) { <line33> child = ah; <line34> } else { <line35> throw new SAXNotRecognizedException( <line36> getLocalName() + "" may only have one '"" + ChoiceHandler.LOCALNAME + ""' declaration.""); <line37> } <line38> return ah; <line39> } <line40> if (GroupHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line41> GroupHandler ah = new GroupHandler(); <line42> if (child == null) { <line43> child = ah; <line44> } else { <line45> throw new SAXNotRecognizedException( <line46> getLocalName() + "" may only have one '"" + GroupHandler.LOCALNAME + ""' declaration.""); <line47> } <line48> return ah; <line49> } <line50> if (SequenceHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line51> SequenceHandler ah = new SequenceHandler(); <line52> if (child == null) { <line53> child = ah; <line54> } else { <line55> throw new SAXNotRecognizedException( <line56> getLocalName() <line57> + "" may only have one '"" <line58> + SequenceHandler.LOCALNAME <line59> + ""' declaration.""); <line60> } <line61> return ah; <line62> } <line63> } <line64> return null; <line65> } <line66> } <line67> "	<line64>
6321	public class A { <line0> @Override <line1> public void upgrade() { <line2> try { <line3> addMaxLengthAttribute(); <line4> } catch (IOException e) { <line5> throw new UncheckedIOException(e); <line6> } <line7> } <line8> } <line9> 	<line2>, <line7>
6322	public class A { <line0> @Override <line1> public PersonNameType getPersonNameBy(Long personnameId) { <line2> GetPersonNameRequestMessageType request = new GetPersonNameRequestMessageType(); <line3> request.setConfigAssertion(buildConfigAssertion()); <line4> request.setPersonNameId(personnameId); <line5> try { <line6> LoadTestDataSimpleResponseMessageType response = <line7> (LoadTestDataSimpleResponseMessageType) <line8> invokeClientPort(AdminWSConstants.ADMIN_LTD_GETPERSONNAME, request); <line9> logDebug( <line10> AdminWSConstants.ADMIN_LTD_GETPERSONNAME, response.isStatus(), response.getMessage()); <line11> return firstItem(response.getPersonNameList()); <line12> } catch (Exception e) { <line13> } <line14> return null; <line15> } <line16> } <line17> 	<line13>
6323	public class A { <line0> @Override <line1> public void thawDatabase(String profileId) { <line2> ApplicationContext ctx = profileInstanceManagers.get(profileId); <line3> DerbyPooledDataSource dataSource = (DerbyPooledDataSource) ctx.getBean(DATA_SOURCE_BEAN_NAME); <line4> try { <line5> dataSource.thaw(); <line6> } catch (Exception ex) { <line7> } <line8> } <line9> } <line10> 	<line7>
6324	public class A { <line0> @Override <line1> public void execute() { <line2> if (!resultInjectedFromCache) { <line3> results = new ArrayList<String>(0); <line4> int count = 0; <line5> try { <line6> LoadAttachmentsUserFiltered command = new LoadAttachmentsUserFiltered(rootElmt); <line7> command = getCommandService().executeCommand(command); <line8> for (Attachment attachment : command.getResult()) { <line9> if (isSupportedMIMEType(attachment.getMimeType())) { <line10> results.add(String.valueOf(count)); <line11> count++; <line12> } <line13> } <line14> } catch (CommandException e) { <line15> } <line16> } <line17> } <line18> } <line19> 	<line15>
6325	public class A { <line0> @Override <line1> @Transactional <line2> public void resetRuntimeCounters() { <line3> requireNotDisposed(); <line4> _monitorService.resetRuntimeCounters(); <line5> } <line6> } <line7> 	<line4>
6326	"public class A { <line0> public BigDecimal getVoucherExpenditureByEntities( <line1> final Integer detailTypeId, final List<Integer> entityIdList) { <line2> BigDecimal voucherSum = BigDecimal.ZERO; <line3> if (detailTypeId == null || entityIdList == null || entityIdList.size() == 0) <line4> throw new ValidationException( <line5> ""DetailTypeId or EntityIdList not provided"", ""DetailTypeId or EntityIdList not provided""); <line6> final String query = <line7> ""select sum(gld.amount) from CGeneralLedger gl, CGeneralLedgerDetail gld, CVoucherHeader vh"" <line8> + ""  WHERE gl.voucherHeaderId= vh and gl.id = gld.generalLedgerId.id and "" <line9> + "" gld.detailTypeId.id  in ( :detailTypeId ) and gld.detailKeyId   in ( :entityIdList"" <line10> + "" ) and gl.debitAmount>0 and vh.status!=4 and vh.type = 'Journal Voucher'""; <line11> if (LOGGER.isDebugEnabled()) <line12> final Query expenditureQuery = persistenceService.getSession().createQuery(query); <line13> expenditureQuery.setInteger(""detailTypeId"", detailTypeId); <line14> expenditureQuery.setParameterList(""entityIdList"", entityIdList); <line15> final List<Object> result = expenditureQuery.list(); <line16> if (result != null) voucherSum = getBigDecimalValue(result.get(0)); <line17> return voucherSum; <line18> } <line19> } <line20> "	<line12>
6327	"public class A { <line0> protected static void configureSslContextFactory( <line1> SslContextFactory.Server contextFactory, NiFiProperties props) { <line2> contextFactory.setIncludeProtocols(TlsConfiguration.getCurrentSupportedTlsProtocolVersions()); <line3> contextFactory.setExcludeProtocols( <line4> ""TLS"", ""TLSv1"", ""TLSv1.1"", ""SSL"", ""SSLv2"", ""SSLv2Hello"", ""SSLv3""); <line5> final String includeCipherSuitesProps = <line6> props.getProperty(NiFiProperties.WEB_HTTPS_CIPHERSUITES_INCLUDE); <line7> if (StringUtils.isNotEmpty(includeCipherSuitesProps)) { <line8> final String[] includeCipherSuites = includeCipherSuitesProps.split(REGEX_SPLIT_PROPERTY); <line9> contextFactory.setIncludeCipherSuites(includeCipherSuites); <line10> } <line11> final String excludeCipherSuitesProps = <line12> props.getProperty(NiFiProperties.WEB_HTTPS_CIPHERSUITES_EXCLUDE); <line13> if (StringUtils.isNotEmpty(excludeCipherSuitesProps)) { <line14> final String[] excludeCipherSuites = excludeCipherSuitesProps.split(REGEX_SPLIT_PROPERTY); <line15> contextFactory.setExcludeCipherSuites(excludeCipherSuites); <line16> } <line17> if (props.isClientAuthRequiredForRestApi()) { <line18> contextFactory.setNeedClientAuth(true); <line19> } else { <line20> contextFactory.setWantClientAuth(true); <line21> } <line22> if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_KEYSTORE))) { <line23> contextFactory.setKeyStorePath(props.getProperty(NiFiProperties.SECURITY_KEYSTORE)); <line24> } <line25> String keyStoreType = props.getProperty(NiFiProperties.SECURITY_KEYSTORE_TYPE); <line26> if (StringUtils.isNotBlank(keyStoreType)) { <line27> contextFactory.setKeyStoreType(keyStoreType); <line28> String keyStoreProvider = KeyStoreUtils.getKeyStoreProvider(keyStoreType); <line29> if (StringUtils.isNoneEmpty(keyStoreProvider)) { <line30> contextFactory.setKeyStoreProvider(keyStoreProvider); <line31> } <line32> } <line33> final String keystorePassword = props.getProperty(NiFiProperties.SECURITY_KEYSTORE_PASSWD); <line34> final String keyPassword = props.getProperty(NiFiProperties.SECURITY_KEY_PASSWD); <line35> if (StringUtils.isNotBlank(keystorePassword)) { <line36> final String defaultKeyPassword = <line37> (StringUtils.isBlank(keyPassword)) ? keystorePassword : keyPassword; <line38> contextFactory.setKeyStorePassword(keystorePassword); <line39> contextFactory.setKeyManagerPassword(defaultKeyPassword); <line40> } else if (StringUtils.isNotBlank(keyPassword)) { <line41> contextFactory.setKeyManagerPassword(keyPassword); <line42> } <line43> if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE))) { <line44> contextFactory.setTrustStorePath(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE)); <line45> } <line46> String trustStoreType = props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_TYPE); <line47> if (StringUtils.isNotBlank(trustStoreType)) { <line48> contextFactory.setTrustStoreType(trustStoreType); <line49> String trustStoreProvider = KeyStoreUtils.getKeyStoreProvider(trustStoreType); <line50> if (StringUtils.isNoneEmpty(trustStoreProvider)) { <line51> contextFactory.setTrustStoreProvider(trustStoreProvider); <line52> } <line53> } <line54> if (StringUtils.isNotBlank(props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_PASSWD))) { <line55> contextFactory.setTrustStorePassword( <line56> props.getProperty(NiFiProperties.SECURITY_TRUSTSTORE_PASSWD)); <line57> } <line58> } <line59> } <line60> "	<line9>, <line15>
6328	"public class A { <line0> public String earliestBinlogFilename() { <line1> List<String> logNames = new ArrayList<>(); <line2> try { <line3> query( <line4> ""SHOW BINARY LOGS"", <line5> rs -> { <line6> while (rs.next()) { <line7> logNames.add(rs.getString(1)); <line8> } <line9> }); <line10> } catch (SQLException e) { <line11> throw new DebeziumException( <line12> ""Unexpected error while connecting to MySQL and looking for binary logs: "", e); <line13> } <line14> if (logNames.isEmpty()) { <line15> return null; <line16> } <line17> return logNames.get(0); <line18> } <line19> } <line20> "	<line3>
6329	"public class A { <line0> List<TimeSeries> createTimeSeries() { <line1> TimeSeriesIndex index = getTimeSeriesIndex(); <line2> if (this.refIndex != null && !index.equals(refIndex)) { <line3> throw new TimeSeriesException( <line4> ""All version of the data must have the same index: "" + refIndex + "" != "" + index); <line5> } else { <line6> this.refIndex = index; <line7> } <line8> List<TimeSeries> timeSeriesList = new ArrayList<>(names.size()); <line9> for (int i = 0; i < names.size(); i++) { <line10> if (Objects.isNull(names.get(i))) { <line11> continue; <line12> } <line13> TimeSeriesMetadata metadata = new TimeSeriesMetadata(names.get(i), dataTypes[i], index); <line14> if (dataTypes[i] == TimeSeriesDataType.DOUBLE) { <line15> TDoubleArrayList doubleValues = (TDoubleArrayList) values[i]; <line16> DoubleDataChunk chunk = <line17> new UncompressedDoubleDataChunk(0, doubleValues.toArray()).tryToCompress(); <line18> timeSeriesList.add(new StoredDoubleTimeSeries(metadata, chunk)); <line19> } else if (dataTypes[i] == TimeSeriesDataType.STRING) { <line20> List<String> stringValues = (List<String>) values[i]; <line21> StringDataChunk chunk = <line22> new UncompressedStringDataChunk(0, stringValues.toArray(new String[0])).tryToCompress(); <line23> timeSeriesList.add(new StringTimeSeries(metadata, chunk)); <line24> } else { <line25> throw assertDataType(dataTypes[i - fixedColumns]); <line26> } <line27> } <line28> return timeSeriesList; <line29> } <line30> } <line31> "	<line11>
6330	public class A { <line0> @Override <line1> public void run() { <line2> while (true) { <line3> boolean needsToShutdown = needsToShutdown(); <line4> try { <line5> emitLargeEvents(); <line6> emitBatches(); <line7> tryEmitOneFailedBuffer(); <line8> if (needsToShutdown) { <line9> tryEmitAndDrainAllFailedBuffers(); <line10> drainBuffersToReuse(); <line11> return; <line12> } <line13> } catch (Throwable t) { <line14> } <line15> if (failedBuffers.isEmpty()) { <line16> long waitNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(config.getFlushMillis()) / 2, 1); <line17> LockSupport.parkNanos(HttpPostEmitter.this, waitNanos); <line18> } <line19> } <line20> } <line21> } <line22> 	<line14>
6331	public class A { <line0> public void close() { <line1> int poolCount = 0; <line2> int poolsSize = pools.size(); <line3> for (String destination : pools.keySet()) { <line4> GenericObjectPool pool = pools.get(destination); <line5> try { <line6> pool.close(); <line7> pools.remove(destination); <line8> poolCount++; <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> } <line14> 	<line9>, <line10>, <line12>
6332	"public class A { <line0> public void updateOrchestrationStatusDeleteVfModule(BuildingBlockExecution execution) { <line1> execution.setVariable(""aaiDeleteVfModuleRollback"", false); <line2> try { <line3> VfModule vfModule = extractPojosForBB.extractByKey(execution, ResourceKey.VF_MODULE_ID); <line4> vfModule.setHeatStackId(""""); <line5> GenericVnf vnf = extractPojosForBB.extractByKey(execution, ResourceKey.GENERIC_VNF_ID); <line6> aaiVfModuleResources.updateOrchestrationStatusVfModule( <line7> vfModule, vnf, OrchestrationStatus.ASSIGNED); <line8> execution.setVariable(""aaiDeleteVfModuleRollback"", true); <line9> } catch (Exception ex) { <line10> exceptionUtil.buildAndThrowWorkflowException(execution, 7000, ex); <line11> } <line12> } <line13> } <line14> "	<line10>
6333	public class A { <line0> @Override <line1> public void userEventTriggered(ChannelHandlerContext ctx, Object evt) { <line2> if (evt instanceof IdleStateEvent) { <line3> if (((IdleStateEvent) evt).state() == IdleState.READER_IDLE) { <line4> InetSocketAddress remoteAddress = (InetSocketAddress) ctx.channel().remoteAddress(); <line5> InetSocketAddress localAddress = (InetSocketAddress) ctx.channel().localAddress(); <line6> idleClosedConnections.inc(); <line7> ctx.channel().close(); <line8> } <line9> } <line10> } <line11> } <line12> 	<line6>
6334	"public class A { <line0> private boolean validateTimeStampToken(TimeStampToken tsToken) throws Exception { <line1> boolean result = false; <line2> KeyStore keyStore = getEncryptionUtils().getTSAKeyStore(); <line3> List<String> aliases = getEncryptionUtils().getTsaStoreAliases(); <line4> if (aliases == null || keyStore == null) { <line5> throw new IllegalStateException( <line6> ""keystore or aliases not initialised yet : aliases : ["" <line7> + aliases <line8> + ""] and keystore : ["" <line9> + keyStore <line10> + ""]""); <line11> } <line12> TimeStampTokenInfo tsi = tsToken.getTimeStampInfo(); <line13> boolean signatureValid = false; <line14> Exception lastException = null; <line15> for (String alias : aliases) { <line16> try { <line17> X509Certificate ttsaCert = (X509Certificate) keyStore.getCertificate(alias); <line18> String t = ttsaCert.getSubjectX500Principal().getName(X500Principal.RFC1779); <line19> X509CertificateHolder tokenSigner = new X509CertificateHolder(ttsaCert.getEncoded()); <line20> SignerInformationVerifier verifier = <line21> new BcRSASignerInfoVerifierBuilder( <line22> new DefaultCMSSignatureAlgorithmNameGenerator(), <line23> new DefaultSignatureAlgorithmIdentifierFinder(), <line24> new DefaultDigestAlgorithmIdentifierFinder(), <line25> new BcDigestCalculatorProvider()) <line26> .build(tokenSigner); <line27> tsToken.validate(verifier); <line28> signatureValid = true; <line29> break; <line30> } catch (Exception e) { <line31> lastException = e; <line32> } <line33> } <line34> if (signatureValid) { <line35> result = true; <line36> } else { <line37> result = false; <line38> throw new Exception(""timestamp is not valid "", lastException); <line39> } <line40> return result; <line41> } <line42> } <line43> "	<line13>, <line19>, <line36>
6335	"public class A { <line0> public static String loadPasswordKey( <line1> String pwdKeyAliasProperty, String pwdKeyPasswordProperty, String defaultPassword) { <line2> String passwordKey; <line3> KeyStoreHelper keyStoreHelper = new KeyStoreHelper(); <line4> try { <line5> String pwdKeyAlias = System.getProperty(pwdKeyAliasProperty, """"); <line6> String pwdKeyPassword = System.getProperty(pwdKeyPasswordProperty, """"); <line7> passwordKey = keyStoreHelper.getPasswordKey(pwdKeyAlias, pwdKeyPassword.toCharArray()); <line8> } catch (RuntimeException re) { <line9> passwordKey = defaultPassword; <line10> if (hasNotBeenInvoked(pwdKeyAliasProperty, pwdKeyPasswordProperty, passwordKey)) { <line11> } <line12> } <line13> return passwordKey; <line14> } <line15> } <line16> "	<line11>
6336	"public class A { <line0> private void waitForComplete() throws InterruptedException, IOException { <line1> FlowScriptTask done = doneQueue.take(); <line2> assert done.isDone(); <line3> FlowScript flow = done.script; <line4> try { <line5> done.get(); <line6> boolean blocked = blocking.remove(flow.getId()); <line7> assert blocked; <line8> } catch (CancellationException e) { <line9> } catch (ExecutionException e) { <line10> if (e.getCause() instanceof IOException) { <line11> throw (IOException) e.getCause(); <line12> } else if (e.getCause() instanceof InterruptedException) { <line13> throw (InterruptedException) e.getCause(); <line14> } else if (e.getCause() instanceof Error) { <line15> throw (Error) e.getCause(); <line16> } else { <line17> throw new IOException(""Flow execution failed by unknown error"", e); <line18> } <line19> } finally { <line20> FlowScriptTask ran = running.remove(flow.getId()); <line21> assert ran != null; <line22> } <line23> } <line24> } <line25> "	<line1>, <line9>
6337	"public class A { <line0> private void configureKeys( <line1> String workerIP, <line2> String user, <line3> boolean setPassword, <line4> String passwordOrKeyPair, <line5> String publicKey, <line6> String privateKey, <line7> String keyType) <line8> throws ConnectorException { <line9> try { <line10> String command = <line11> ""/bin/echo \"""" <line12> + publicKey <line13> + ""\"" > ~/.ssh/"" <line14> + keyType <line15> + "".pub"" <line16> + ""; "" <line17> + ""/bin/echo \"""" <line18> + privateKey <line19> + ""\"" > ~/.ssh/"" <line20> + keyType <line21> + ""; "" <line22> + ""chmod 600 ~/.ssh/"" <line23> + keyType <line24> + ""; "" <line25> + ""/bin/echo \"""" <line26> + publicKey <line27> + ""\"" >> ~/.ssh/authorized_keys""; <line28> executeTask(workerIP, user, setPassword, passwordOrKeyPair, command); <line29> } catch (ConnectorException e) { <line30> String msg = ERROR_CONFIG_KEYS + workerIP + "" user: "" + user; <line31> throw new ConnectorException(msg, e); <line32> } <line33> } <line34> } <line35> "	<line9>, <line31>
6338	"public class A { <line0> private String process(final String resourceUri, final String content) { <line1> File temp = null; <line2> try { <line3> temp = WroUtil.createTempFile(); <line4> IOUtils.write(content, new FileOutputStream(temp), StandardCharsets.UTF_8); <line5> final Process process = createProcess(temp); <line6> final String result = <line7> IOUtils.toString( <line8> new AutoCloseInputStream(process.getInputStream()), StandardCharsets.UTF_8); <line9> final int exitStatus = process.waitFor(); <line10> if (exitStatus != 0) { <line11> final String errorMessage = <line12> MessageFormat.format( <line13> ""Error in LESS: \n{0}"", result.replace(temp.getPath(), resourceUri)); <line14> throw new WroRuntimeException(errorMessage); <line15> } <line16> return result; <line17> } catch (final Exception e) { <line18> throw WroRuntimeException.wrap(e); <line19> } finally { <line20> FileUtils.deleteQuietly(temp); <line21> } <line22> } <line23> } <line24> "	<line5>, <line11>
6339	"public class A { <line0> private void readSingleSubTableFormat2( <line1> int lookupType, int lookupFlags, long subtableOffset, int subtableFormat) throws IOException { <line2> String tableTag = ""GSUB""; <line3> in.seekSet(subtableOffset); <line4> in.skip(2); <line5> int co = in.readTTFUShort(); <line6> int ng = in.readTTFUShort(); <line7> if (log.isDebugEnabled()) { <line8> } <line9> seMapping = readCoverageTable(tableTag + "" single substitution coverage"", subtableOffset + co); <line10> for (int i = 0, n = ng; i < n; i++) { <line11> int gs = in.readTTFUShort(); <line12> if (log.isDebugEnabled()) { <line13> } <line14> seEntries.add(gs); <line15> } <line16> } <line17> } <line18> "	<line8>, <line13>
6340	"public class A { <line0> public MbDelGefahr findById(sernet.gs.reveng.MbDelGefahrId id) { <line1> try { <line2> MbDelGefahr instance = <line3> (MbDelGefahr) sessionFactory.getCurrentSession().get(""sernet.gs.reveng.MbDelGefahr"", id); <line4> if (instance == null) { <line5> } else { <line6> } <line7> return instance; <line8> } catch (RuntimeException re) { <line9> throw re; <line10> } <line11> } <line12> } <line13> "	<line1>, <line5>, <line6>, <line9>
6341	"public class A { <line0> @SuppressWarnings(""checkstyle:IllegalCatch"") <line1> @SuppressFBWarnings( <line2> value = ""UPM_UNCALLED_PRIVATE_METHOD"", <line3> justification = ""https://github.com/spotbugs/spotbugs/issues/811"") <line4> private static void makeEmptyFlowCapableNode( <line5> final TxFacade txFacade, final DeviceInfo deviceInfo) { <line6> try { <line7> txFacade.writeToTransaction( <line8> LogicalDatastoreType.OPERATIONAL, <line9> deviceInfo.getNodeInstanceIdentifier().augmentation(FlowCapableNode.class), <line10> new FlowCapableNodeBuilder().build()); <line11> } catch (final Exception e) { <line12> } <line13> } <line14> } <line15> "	<line12>
6342	public class A { <line0> public synchronized byte[] contentsOf(FileID fid) { <line1> try { <line2> return bytesHelper.allBytesFrom(pathToContentsOf(fid)); <line3> } catch (IOException e) { <line4> throw new UncheckedIOException(e); <line5> } <line6> } <line7> } <line8> 	<line4>
6343	public class A { <line0> private ContraJournalVoucher addOrupdateContraJournalVoucher( <line1> final ContraJournalVoucher cjv, final InstrumentHeader ih, final CVoucherHeader vh) { <line2> cjv.setInstrumentHeaderId(ih); <line3> cjv.setVoucherHeaderId(vh); <line4> getHibObjectsFromContraBean(); <line5> cjv.setFromBankAccountId(contraVoucher.getFromBankAccountId()); <line6> cjv.setToBankAccountId(contraVoucher.getToBankAccountId()); <line7> if (cjv.getId() != null) { <line8> contraJournalVoucherService.applyAuditing(cjv); <line9> contraJournalVoucherService.update(cjv); <line10> } else { <line11> contraJournalVoucherService.applyAuditing(cjv); <line12> contraJournalVoucherService.persist(cjv); <line13> } <line14> return cjv; <line15> } <line16> } <line17> 	<line10>, <line13>
6344	"public class A { <line0> @Override <line1> public Tuple<Boolean, String> isHealthy() { <line2> try { <line3> final Response response = restClient.performRequest(METHOD_GET, ""_cluster/health""); <line4> final StatusLine statusLine = response.getStatusLine(); <line5> if (statusLine.getStatusCode() != 200) { <line6> return Tuple.tuple(false, ""Request failed: "" + statusLine.getReasonPhrase()); <line7> } <line8> final JsonNode jsonNode = OBJECT_MAPPER.readTree(response.getEntity().getContent()); <line9> final String status = jsonNode.get(""status"").asText(); <line10> if (status.equals(""red"")) { <line11> return Tuple.tuple(false, ""Elasticsearch cluster status is 'red'.""); <line12> } <line13> return Tuple.tuple(true, ""Elasticsearch filter is healthy.""); <line14> } catch (IOException e) { <line15> return Tuple.tuple(false, ""Request threw an exception: "" + e.getMessage()); <line16> } <line17> } <line18> } <line19> "	<line15>
6345	public class A { <line0> @Export <line1> public Iterable<Object> evaluate( <line2> final SecurityContext securityContext, final Map<String, Object> parameters) <line3> throws FrameworkException { <line4> final FlowEngine engine = new FlowEngine(); <line5> final Context context = new Context(); <line6> context.setParameters(parameters); <line7> final FlowNode entry = getProperty(startNode); <line8> final FlowResult flowResult = engine.execute(context, entry); <line9> if (flowResult.getError() != null) { <line10> if (flowResult.getError().getCause() != null) { <line11> } else { <line12> } <line13> final List<Object> result = new ArrayList<>(); <line14> result.add(flowResult.getError()); <line15> return result; <line16> } <line17> if (flowResult.getResult() instanceof Iterable) { <line18> return (Iterable) flowResult.getResult(); <line19> } else { <line20> final List<Object> result = new ArrayList<>(); <line21> result.add(flowResult.getResult()); <line22> return result; <line23> } <line24> } <line25> } <line26> 	<line11>, <line12>
6346	public class A { <line0> protected DataDescription createDataDescription() { <line1> DataDescription dataDescription = new DataDescription(); <line2> dataDescription.setName(DATA_DESC_FORMAT); <line3> dataDescription.setFormat(DATA_DESC_FORMAT); <line4> dataDescription.setCharset(Charsets.UTF_8.displayName()); <line5> try { <line6> dataDescription.setUrl( <line7> new URI(workflowConfiguration.getDownloadLink(configuration.getDownloadKey()))); <line8> } catch (URISyntaxException e) { <line9> } <line10> return dataDescription; <line11> } <line12> } <line13> 	<line9>
6347	public class A { <line0> private synchronized void getOrRefreshAccessToken() { <line1> if (token == null) { <line2> token = <line3> OAuthClientUtils.getAccessToken( <line4> WebClient.create(configuration.getOauthTokenUrl()), <line5> new Consumer(configuration.getOauthClientId(), configuration.getOauthClientSecret()), <line6> new ResourceOwnerGrant(configuration.getUserName(), configuration.getPassword()), <line7> true); <line8> token.setIssuedAt(System.currentTimeMillis()); <line9> token.setExpiresIn(TimeUnit.MILLISECONDS.convert(token.getExpiresIn(), TimeUnit.SECONDS)); <line10> authString = token.toString(); <line11> if (token.getExpiresIn() > 0) { <line12> expireAt = token.getIssuedAt() + token.getExpiresIn(); <line13> } <line14> } else if (expireAt > 0 && System.currentTimeMillis() >= expireAt) { <line15> token = <line16> OAuthClientUtils.refreshAccessToken( <line17> WebClient.create(configuration.getOauthTokenUrl()), <line18> new Consumer(configuration.getOauthClientId(), configuration.getOauthClientSecret()), <line19> token, <line20> null, <line21> false); <line22> token.setIssuedAt(System.currentTimeMillis()); <line23> token.setExpiresIn(TimeUnit.MILLISECONDS.convert(token.getExpiresIn(), TimeUnit.SECONDS)); <line24> authString = token.toString(); <line25> if (token.getExpiresIn() > 0) { <line26> expireAt = token.getIssuedAt() + token.getExpiresIn(); <line27> } <line28> } <line29> } <line30> } <line31> 	<line2>, <line8>, <line15>, <line22>
6348	"public class A { <line0> @Override <line1> public JavaFileObject getJavaFileForInput(Location location, String className, Kind kind) <line2> throws IOException { <line3> if (className.equals(""module-info"")) { <line4> return null; <line5> } <line6> throw new IllegalStateException(""Not expected to be used in this context""); <line7> } <line8> } <line9> "	<line3>
6349	public class A { <line0> @Override <line1> public CollectVoteResult collectVote(CollectVoteData voteData) { <line2> final String selfTerm = this.server.getCurrentTerm(); <line3> final String remoteTerm = voteData.getTerm(); <line4> final String remoteServerID = voteData.getServerID(); <line5> final CollectVoteResult voteResult = new CollectVoteResult(); <line6> voteResult.setServerID(this.landContext.getServerID()); <line7> voteResult.setRemoteTerm(selfTerm); <line8> if (this.landContext.getServerID().equals(remoteServerID)) { <line9> voteResult.setVoteGranted(true); <line10> return voteResult; <line11> } <line12> this.server.lockRun( <line13> new RunLock() { <line14> public void run(Operation object) { <line15> if (TermUtils.gtFirst(selfTerm, remoteTerm)) { <line16> voteResult.setVoteGranted(true); <line17> switchToFollow(object, remoteServerID, remoteTerm); <line18> return; <line19> } <line20> voteResult.setVoteGranted(false); <line21> } <line22> }); <line23> return voteResult; <line24> } <line25> } <line26> 	<line9>, <line16>, <line21>
6350	"public class A { <line0> private URI buildUri(final UUID interactionId) { <line1> final UriBuilder uriBuilder = <line2> UriBuilder.fromUri( <line3> interactionId != null <line4> ? String.format( <line5> ""%s%s?interactionId=%s&batchSize=%d"", <line6> secondaryConfig.getPrimaryBaseUrlRestful(), <line7> URL_SUFFIX, <line8> interactionId, <line9> secondaryConfig.getBatchSize()) <line10> : String.format( <line11> ""%s%s?batchSize=%d"", <line12> secondaryConfig.getPrimaryBaseUrlRestful(), <line13> URL_SUFFIX, <line14> secondaryConfig.getBatchSize())); <line15> final URI uri = uriBuilder.build(); <line16> return uri; <line17> } <line18> } <line19> "	<line16>
6351	public class A { <line0> private void validateActivatedProfiles(ProfileManager globalProfileManager, List projects) { <line1> if (globalProfileManager != null) { <line2> Set activeProfileIds = new HashSet(); <line3> for (Iterator i = projects.iterator(); i.hasNext(); ) { <line4> MavenProject project = (MavenProject) i.next(); <line5> do { <line6> for (Iterator j = project.getActiveProfiles().iterator(); j.hasNext(); ) { <line7> activeProfileIds.add(((Profile) j.next()).getId()); <line8> } <line9> project = project.getParent(); <line10> } while (project != null); <line11> } <line12> for (Iterator i = globalProfileManager.getExplicitlyActivatedIds().iterator(); <line13> i.hasNext(); ) { <line14> String explicitProfileId = (String) i.next(); <line15> if (!activeProfileIds.contains(explicitProfileId)) { <line16> getLogger() <line17> } <line18> } <line19> } <line20> } <line21> } <line22> 	<line17>
6352	public class A { <line0> @Override <line1> public void onFailure( <line2> final Throwable throwable, final HttpServerResponse response, final Span span) { <line3> TracingHelper.logError(span, throwable); <line4> } <line5> } <line6> 	<line3>
6353	"public class A { <line0> private void maybeStart() throws Exception { <line1> if (!routeDefinitionValid.get()) { <line2> return; <line3> } <line4> boolean eager = <line5> ""true"".equalsIgnoreCase(System.getProperty(""registerBlueprintCamelContextEager"")); <line6> if (eager) { <line7> for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) { <line8> if (notifier instanceof OsgiCamelContextPublisher) { <line9> OsgiCamelContextPublisher publisher = (OsgiCamelContextPublisher) notifier; <line10> publisher.registerCamelContext(this); <line11> break; <line12> } <line13> } <line14> } <line15> boolean skip = ""true"".equalsIgnoreCase(System.getProperty(""skipStartingCamelContext"")); <line16> if (skip) { <line17> return; <line18> } <line19> if (!isStarted() && !isStarting()) { <line20> start(); <line21> } else { <line22> } <line23> } <line24> } <line25> "	<line1>, <line2>, <line17>, <line20>, <line22>
6354	"public class A { <line0> public List findByExample(FilterName instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.FilterName"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	<line1>, <line8>, <line10>
6355	public class A { <line0> @Override <line1> public void onTccCoordinated( <line2> GrpcTccCoordinatedEvent request, StreamObserver<GrpcAck> responseObserver) { <line3> events.offer(request); <line4> sleep(); <line5> responseObserver.onNext(ALLOW); <line6> responseObserver.onCompleted(); <line7> } <line8> } <line9> 	<line3>
6356	"public class A { <line0> @GET <line1> @Path(""/roles/{id}"") <line2> @Timed <line3> public Response getRole(@PathParam(""id"") Long roleId, @Context SecurityContext securityContext) { <line4> if (!SecurityUtil.hasRole(authorizer, securityContext, ROLE_SECURITY_ADMIN)) { <line5> } <line6> Role role = catalogService.getRole(roleId); <line7> if (role != null) { <line8> return WSUtils.respondEntity(role, OK); <line9> } <line10> throw EntityNotFoundException.byId(roleId.toString()); <line11> } <line12> } <line13> "	<line5>
6357	public class A { <line0> private String getActivityType(String osmValue, String osmKey) { <line1> String matsimType = typeMap.get(osmValue); <line2> if (matsimType == null) { <line3> if (useGeneralTypeIsSpecificTypeUnknown) { <line4> return osmKey; <line5> } else { <line6> } <line7> } <line8> MapUtils.addToInteger(matsimType, typeCount, 0, 1); <line9> return matsimType; <line10> } <line11> } <line12> 	<line6>
6358	public class A { <line0> @Override <line1> public void readLacComplete( <line2> int rc, long ledgerId, final ByteBuf lacBuffer, final ByteBuf lastEntryBuffer, Object ctx) { <line3> int bookieIndex = (Integer) ctx; <line4> coverageSet.addBookie(bookieIndex, rc); <line5> numResponsesPending--; <line6> boolean heardValidResponse = false; <line7> if (completed) { <line8> return; <line9> } <line10> if (rc == BKException.Code.OK) { <line11> try { <line12> if (lacBuffer != null && lacBuffer.readableBytes() > 0) { <line13> long lac = lh.macManager.verifyDigestAndReturnLac(lacBuffer); <line14> if (lac > maxLac) { <line15> maxLac = lac; <line16> } <line17> } <line18> if (lastEntryBuffer != null && lastEntryBuffer.readableBytes() > 0) { <line19> RecoveryData recoveryData = <line20> lh.macManager.verifyDigestAndReturnLastConfirmed(lastEntryBuffer); <line21> long recoveredLac = recoveryData.getLastAddConfirmed(); <line22> if (recoveredLac > maxLac) { <line23> maxLac = recoveredLac; <line24> } <line25> } <line26> heardValidResponse = true; <line27> } catch (BKDigestMatchException e) { <line28> rc = BKException.Code.DigestMatchException; <line29> } <line30> } <line31> if (rc == BKException.Code.NoSuchLedgerExistsException <line32> || rc == BKException.Code.NoSuchEntryException) { <line33> heardValidResponse = true; <line34> } <line35> if (rc == BKException.Code.UnauthorizedAccessException && !completed) { <line36> cb.getLacComplete(rc, maxLac); <line37> completed = true; <line38> return; <line39> } <line40> if (!heardValidResponse && BKException.Code.OK != rc) { <line41> lastSeenError = rc; <line42> } <line43> if (heardValidResponse && coverageSet.checkCovered() && !completed) { <line44> completed = true; <line45> if (LOG.isDebugEnabled()) { <line46> } <line47> cb.getLacComplete(BKException.Code.OK, maxLac); <line48> return; <line49> } <line50> if (numResponsesPending == 0 && !completed) { <line51> cb.getLacComplete(lastSeenError, maxLac); <line52> } <line53> } <line54> } <line55> 	<line28>, <line46>, <line51>
6359	public class A { <line0> protected boolean isUserExcluded(User user) { <line1> if ((user == null) <line2> || Objects.equals( <line3> user.getScreenName(), AnalyticsSecurityConstants.SCREEN_NAME_ANALYTICS_ADMIN) <line4> || Objects.equals(user.getStatus(), WorkflowConstants.STATUS_INACTIVE)) { <line5> return true; <line6> } <line7> AnalyticsConfiguration analyticsConfiguration = <line8> analyticsConfigurationTracker.getAnalyticsConfiguration(user.getCompanyId()); <line9> if (analyticsConfiguration.syncAllContacts()) { <line10> return false; <line11> } <line12> long[] organizationIds = null; <line13> try { <line14> organizationIds = user.getOrganizationIds(); <line15> } catch (Exception exception) { <line16> if (_log.isDebugEnabled()) { <line17> } <line18> return true; <line19> } <line20> for (long organizationId : organizationIds) { <line21> if (ArrayUtil.contains( <line22> analyticsConfiguration.syncedOrganizationIds(), String.valueOf(organizationId))) { <line23> return false; <line24> } <line25> } <line26> for (long userGroupId : user.getUserGroupIds()) { <line27> if (ArrayUtil.contains( <line28> analyticsConfiguration.syncedUserGroupIds(), String.valueOf(userGroupId))) { <line29> return false; <line30> } <line31> } <line32> return true; <line33> } <line34> } <line35> 	<line17>
6360	public class A { <line0> @Override <line1> public void register(Object resourceProvider) { <line2> if (!(resourceProvider instanceof FhirProvider) <line3> || ((FhirProvider) resourceProvider).requiresRegistration()) { <line4> if (resourceProviders.add(resourceProvider)) { <line5> for (var servlet : servlets) { <line6> servlet.registerProvider(resourceProvider); <line7> } <line8> } else { <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>
6361	"public class A { <line0> private Message pollMyResponse(String messageControlID_in) throws InterruptedException { <line1> long timeStart = Calendar.getInstance().getTimeInMillis(); <line2> long timeEnd = 0; <line3> long timeDiff = 0; <line4> MsgWrapper responseWrapper = new MsgWrapper(); <line5> Hl7Consumer consumer = new Hl7Consumer(messageControlID_in, responseWrapper); <line6> Message response = null; <line7> do { <line8> applicationResponses.forEach(consumer); <line9> timeEnd = Calendar.getInstance().getTimeInMillis(); <line10> timeDiff = timeEnd - timeStart; <line11> response = responseWrapper.getMsg(); <line12> if (response == null) Thread.sleep(1000); <line13> } while (response == null && timeDiff < timeOutVal); <line14> if (response == null) { <line15> throw new InterruptedException( <line16> ""No response received for messageControlID_in:"" + messageControlID_in); <line17> } <line18> return response; <line19> } <line20> } <line21> "	<line4>, <line15>, <line18>
6362	public class A { <line0> public void copyBaseOutputsToInputs( <line1> Map<String, Object> inputs, <line2> Map<String, Object> otherStackOutputs, <line3> List<String> paramNames, <line4> Map<String, String> aliases) { <line5> if (inputs == null || otherStackOutputs == null) return; <line6> for (String key : otherStackOutputs.keySet()) { <line7> if (paramNames != null) { <line8> if (!paramNames.contains(key) && !aliases.containsKey(key)) { <line9> continue; <line10> } <line11> if (aliases.containsKey(key)) { <line12> Object obj = otherStackOutputs.get(key); <line13> key = aliases.get(key); <line14> otherStackOutputs.put(key, obj); <line15> } <line16> } <line17> if (!inputs.containsKey(key)) { <line18> Object obj = otherStackOutputs.get(key); <line19> if (obj instanceof String) { <line20> inputs.put(key, obj); <line21> } else if (obj instanceof Integer) { <line22> inputs.put(key, obj); <line23> } else if (obj instanceof JsonNode) { <line24> inputs.put(key, obj); <line25> } else if (obj instanceof Boolean) { <line26> inputs.put(key, obj); <line27> } else if (obj instanceof java.util.LinkedHashMap) { <line28> inputs.put(key, obj); <line29> } else if (obj instanceof java.util.ArrayList) { <line30> inputs.put(key, obj); <line31> } else { <line32> inputs.put(key, obj); <line33> } <line34> } else { <line35> } <line36> } <line37> return; <line38> } <line39> } <line40> 	<line9>, <line12>, <line19>, <line20>, <line22>, <line24>, <line26>, <line28>, <line30>, <line32>, <line35>
6363	public class A { <line0> public void wash() { <line1> synchronized (this) { <line2> if (washingMachineState == WashingMachineState.WASHING) { <line3> return; <line4> } <line5> washingMachineState = WashingMachineState.WASHING; <line6> } <line7> try { <line8> Thread.sleep(50); <line9> } catch (InterruptedException ie) { <line10> ie.printStackTrace(); <line11> } <line12> endOfWashing(); <line13> } <line14> } <line15> 	<line2>, <line3>, <line7>
6364	public class A { <line0> protected void loadConfig() { <line1> if (config == null) { <line2> if (verbose) <line3> config = new Config(genomeVer, configFile, dataDir, configOverride, verbose); <line4> } <line5> config.setUseHgvs(hgvs); <line6> config.setHgvsOld(hgvsOld); <line7> config.setHgvsOneLetterAA(hgvsOneLetterAa); <line8> config.setHgvsShift(hgvsShift); <line9> config.setHgvsTrId(hgvsTrId); <line10> config.setExpandIub(expandIub); <line11> config.setDebug(debug); <line12> config.setVerbose(verbose); <line13> config.setQuiet(quiet); <line14> } <line15> } <line16> 	<line3>, <line4>
6365	"public class A { <line0> private synchronized void registerPollTask(ModelBlock mainBlock) { <line1> if (pollTask != null) { <line2> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR); <line3> throw new IllegalStateException( <line4> ""pollTask should be unregistered before registering a new one!""); <line5> } <line6> @Nullable ModbusCommunicationInterface mycomms = comms; <line7> @Nullable SunSpecConfiguration myconfig = config; <line8> if (myconfig == null || mycomms == null) { <line9> throw new IllegalStateException(""registerPollTask called without proper configuration""); <line10> } <line11> ModbusReadRequestBlueprint request = <line12> new ModbusReadRequestBlueprint( <line13> getSlaveId(), <line14> ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, <line15> mainBlock.address, <line16> mainBlock.length, <line17> myconfig.maxTries); <line18> long refreshMillis = myconfig.getRefreshMillis(); <line19> pollTask = <line20> mycomms.registerRegularPoll( <line21> request, <line22> refreshMillis, <line23> 1000, <line24> result -> { <line25> result.getRegisters().ifPresent(this::handlePolledData); <line26> if (getThing().getStatus() != ThingStatus.ONLINE) { <line27> updateStatus(ThingStatus.ONLINE); <line28> } <line29> }, <line30> this::handleError); <line31> } <line32> } <line33> "	<line11>
6366	"public class A { <line0> @Override <line1> public ERCCompanyEntry fetchByC_ERC( <line2> long companyId, String externalReferenceCode, boolean useFinderCache) { <line3> externalReferenceCode = Objects.toString(externalReferenceCode, """"); <line4> Object[] finderArgs = null; <line5> if (useFinderCache) { <line6> finderArgs = new Object[] {companyId, externalReferenceCode}; <line7> } <line8> Object result = null; <line9> if (useFinderCache) { <line10> result = finderCache.getResult(_finderPathFetchByC_ERC, finderArgs); <line11> } <line12> if (result instanceof ERCCompanyEntry) { <line13> ERCCompanyEntry ercCompanyEntry = (ERCCompanyEntry) result; <line14> if ((companyId != ercCompanyEntry.getCompanyId()) <line15> || !Objects.equals(externalReferenceCode, ercCompanyEntry.getExternalReferenceCode())) { <line16> result = null; <line17> } <line18> } <line19> if (result == null) { <line20> StringBundler sb = new StringBundler(4); <line21> sb.append(_SQL_SELECT_ERCCOMPANYENTRY_WHERE); <line22> sb.append(_FINDER_COLUMN_C_ERC_COMPANYID_2); <line23> boolean bindExternalReferenceCode = false; <line24> if (externalReferenceCode.isEmpty()) { <line25> sb.append(_FINDER_COLUMN_C_ERC_EXTERNALREFERENCECODE_3); <line26> } else { <line27> bindExternalReferenceCode = true; <line28> sb.append(_FINDER_COLUMN_C_ERC_EXTERNALREFERENCECODE_2); <line29> } <line30> String sql = sb.toString(); <line31> Session session = null; <line32> try { <line33> session = openSession(); <line34> Query query = session.createQuery(sql); <line35> QueryPos queryPos = QueryPos.getInstance(query); <line36> queryPos.add(companyId); <line37> if (bindExternalReferenceCode) { <line38> queryPos.add(externalReferenceCode); <line39> } <line40> List<ERCCompanyEntry> list = query.list(); <line41> if (list.isEmpty()) { <line42> if (useFinderCache) { <line43> finderCache.putResult(_finderPathFetchByC_ERC, finderArgs, list); <line44> } <line45> } else { <line46> if (list.size() > 1) { <line47> Collections.sort(list, Collections.reverseOrder()); <line48> if (_log.isWarnEnabled()) { <line49> if (!useFinderCache) { <line50> finderArgs = new Object[] {companyId, externalReferenceCode}; <line51> } <line52> } <line53> } <line54> ERCCompanyEntry ercCompanyEntry = list.get(0); <line55> result = ercCompanyEntry; <line56> cacheResult(ercCompanyEntry); <line57> } <line58> } catch (Exception exception) { <line59> throw processException(exception); <line60> } finally { <line61> closeSession(session); <line62> } <line63> } <line64> if (result instanceof List<?>) { <line65> return null; <line66> } else { <line67> return (ERCCompanyEntry) result; <line68> } <line69> } <line70> } <line71> "	<line52>
6367	"public class A { <line0> @Test <line1> public void testEndpointTransformer() throws Exception { <line2> MockEndpoint xyzresult = getMockEndpoint(""mock:xyzresult""); <line3> xyzresult.expectedMessageCount(1); <line4> xyzresult.whenAnyExchangeReceived( <line5> new Processor() { <line6> @Override <line7> public void process(Exchange exchange) throws Exception { <line8> assertEquals(""response"", exchange.getIn().getBody()); <line9> } <line10> }); <line11> Exchange exchange = new DefaultExchange(context, ExchangePattern.InOut); <line12> exchange.getIn().setBody(""<XOrder/>""); <line13> Exchange answerEx = template.send(""direct:endpoint"", exchange); <line14> if (answerEx.getException() != null) { <line15> throw answerEx.getException(); <line16> } <line17> assertEquals(""<XOrderResponse/>"", answerEx.getMessage().getBody(String.class)); <line18> assertMockEndpointsSatisfied(); <line19> } <line20> } <line21> "	<line8>
6368	public class A { <line0> private boolean createAzureQueue(RuntimeContainer container) { <line1> Boolean createResult = false; <line2> try { <line3> createResult = queueService.createQueueIfNotExists(queueName); <line4> if (!createResult) { <line5> } <line6> } catch (InvalidKeyException | URISyntaxException | StorageException e) { <line7> if (dieOnError) { <line8> throw new ComponentException(e); <line9> } <line10> } <line11> return createResult; <line12> } <line13> } <line14> 	<line3>, <line5>, <line7>
6369	"public class A { <line0> @Test <line1> public void testWSHttpCall() throws Exception { <line2> AsyncHttpClient c = new DefaultAsyncHttpClient(); <line3> WebSocket websocket = <line4> c.prepareGet(""ws://localhost:"" + port + ""/shop"") <line5> .execute( <line6> new WebSocketUpgradeHandler.Builder() <line7> .addWebSocketListener( <line8> new WebSocketListener() { <line9> @Override <line10> public void onOpen(WebSocket websocket) {} <line11>  <line12> @Override <line13> public void onClose(WebSocket websocket, int code, String reason) {} <line14>  <line15> @Override <line16> public void onError(Throwable t) { <line17> } <line18>  <line19> @Override <line20> public void onBinaryFrame( <line21> byte[] payload, boolean finalFragment, int rsv) {} <line22>  <line23> @Override <line24> public void onTextFrame(String payload, boolean finalFragment, int rsv) { <line25> received.add(payload); <line26> latch.countDown(); <line27> } <line28>  <line29> @Override <line30> public void onPingFrame(byte[] payload) {} <line31>  <line32> @Override <line33> public void onPongFrame(byte[] payload) {} <line34> }) <line35> .build()) <line36> .get(); <line37> producer.sendBodyAndHeader( <line38> ""Beer on stock at Apache Mall"", WebsocketConstants.SEND_TO_ALL, ""true""); <line39> assertTrue(latch.await(10, TimeUnit.SECONDS)); <line40> assertEquals(1, received.size()); <line41> Object r = received.get(0); <line42> assertTrue(r instanceof String); <line43> assertEquals(""Beer on stock at Apache Mall"", r); <line44> websocket.sendCloseFrame(); <line45> c.close(); <line46> } <line47> } <line48> "	<line17>, <line26>
6370	"public class A { <line0> @Override <line1> public void validate(Currency currency, Transaction transaction) <line2> throws AplException.ValidationException { <line3> Objects.requireNonNull(transaction); <line4> if (currency == null) { <line5> throw new AplException.NotCurrentlyValidException( <line6> ""Unknown currency: "" + transaction.getAttachment().getJSONObject()); <line7> } <line8> this.validate(currency, currency.getType(), transaction); <line9> } <line10> } <line11> "	<line5>
6371	public class A { <line0> public PanelCategory getFirstChildPanelCategory( <line1> String panelCategoryKey, PermissionChecker permissionChecker, Group group) { <line2> List<PanelCategory> panelCategories = getChildPanelCategories(panelCategoryKey); <line3> for (PanelCategory panelCategory : panelCategories) { <line4> try { <line5> if (panelCategory.isShow(permissionChecker, group)) { <line6> return panelCategory; <line7> } <line8> } catch (PortalException portalException) { <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	<line9>
6372	"public class A { <line0> @BeforeEach <line1> @Override <line2> public void setUp(final TestInfo testInfo, final VertxTestContext ctx) { <line3> helper = new IntegrationTestSupport(vertx); <line4> tenantId = helper.getRandomTenantId(); <line5> deviceId = helper.getRandomDeviceId(tenantId); <line6> password = ""secret""; <line7> deviceCert = SelfSignedCertificate.create(UUID.randomUUID().toString()); <line8> helper.init().onComplete(ctx.completing()); <line9> } <line10> } <line11> "	<line3>
6373	public class A { <line0> @Override <line1> public Result run() { <line2> try { <line3> Runnable messageToShareCallback = totalExportedMessages::incrementAndGet; <line4> exportService.export(userExportFrom, exportQuery, exportTo, messageToShareCallback); <line5> return Result.COMPLETED; <line6> } catch (IOException e) { <line7> return Result.PARTIAL; <line8> } <line9> } <line10> } <line11> 	<line7>
6374	"public class A { <line0> @Test <line1> public void testMulti() { <line2> when(consoleConfig.getAllConsoles()).thenReturn(""127.0.0.1:8080, 127.0.0.1:8081""); <line3> when(consoleConfig.getQuorum()).thenReturn(1); <line4> ConsoleServiceManager manager = new ConsoleServiceManager(consoleConfig); <line5> List<HEALTH_STATE> health_states = manager.allHealthStatus(""127.0.0.1"", 6379); <line6> } <line7> } <line8> "	<line6>
6375	public class A { <line0> protected IServerSession getOrCreate( <line1> final ServerSessionEntry sessionContext, HttpSession httpSession) { <line2> final IServerSession session = sessionContext.getOrCreateScoutSession(); <line3> if (session == null) { <line4> return null; <line5> } <line6> boolean newlyAdded = sessionContext.addHttpSessionId(httpSession.getId()); <line7> if (newlyAdded) { <line8> httpSession.setAttribute(SERVER_SESSION_KEY, session); <line9> httpSession.setAttribute( <line10> UNBIND_LISTENER_KEY, new ScoutSessionBindingListener(session.getId())); <line11> if (LOG.isDebugEnabled()) { <line12> } <line13> } <line14> return session; <line15> } <line16> } <line17> 	<line4>, <line12>
6376	public class A { <line0> public CompletionStage<Void> insert(Object entity) { <line1> return entityOperations <line2> .insert(dao, entity) <line3> .exceptionally( <line4> e -> { <line5> return null; <line6> }); <line7> } <line8> } <line9> 	<line5>
6377	public class A { <line0> @Override <line1> public void setUserPreferenceContext(String context) { <line2> m_userPreferenceContext = context; <line3> if (isInitDone()) { <line4> try { <line5> reinit(); <line6> } catch (RuntimeException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6378	public class A { <line0> protected void internalCloseMessageBoxes(List<IMessageBox> list) { <line1> for (IMessageBox m : list) { <line2> if (m != null) { <line3> try { <line4> m.doClose(); <line5> } catch (RuntimeException | PlatformError e) { <line6> } finally { <line7> m_messageBoxStore.remove(m); <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	<line6>
6379	"public class A { <line0> @Test <line1> public void testAnyField() throws Exception { <line2> for (final TestCities city : TestCities.values()) { <line3> String cityPhrase = EQ_OP + ""'"" + city.name() + ""'""; <line4> String query = Constants.ANY_FIELD + cityPhrase; <line5> String expect = this.dataManager.convertAnyField(cityPhrase); <line6> runTest(query, expect, true, false); <line7> } <line8> } <line9> } <line10> "	<line2>
6380	public class A { <line0> @Override <line1> public InputStream newInputStream(Path path, OpenOption... options) throws IOException { <line2> InputStream inputStream = null; <line3> try (final Tx tx = StructrApp.getInstance(securityContext).tx()) { <line4> final File fileNode = (File) ((StructrSSHFile) path).getActualFile(); <line5> inputStream = fileNode.getInputStream(); <line6> tx.success(); <line7> } catch (FrameworkException fex) { <line8> throw new IOException(fex); <line9> } <line10> return inputStream; <line11> } <line12> } <line13> 	<line2>, <line8>
6381	public class A { <line0> void stop() { <line1> if (server == null) { <line2> return; <line3> } <line4> try { <line5> for (Handler ha : server.getHandlers()) { <line6> ha.stop(); <line7> ha.destroy(); <line8> h.removeHandler(ha); <line9> } <line10> this.server.stop(); <line11> this.server.join(); <line12> this.server.destroy(); <line13> this.server = null; <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> 	<line4>, <line14>, <line15>
6382	public class A { <line0> public boolean areIsolationPoliciesPresent(NamespaceName namespace) { <line1> try { <line2> Optional<NamespaceIsolationPolicies> policies = <line3> getIsolationPolicies(pulsar.getConfiguration().getClusterName()); <line4> return policies <line5> .filter(isolationPolicies -> isolationPolicies.getPolicyByNamespace(namespace) != null) <line6> .isPresent(); <line7> } catch (Exception e) { <line8> return false; <line9> } <line10> } <line11> } <line12> 	<line8>
6383	public class A { <line0> void doImport(final Set<String> sourceNames) { <line1> if (!enabled) { <line2> return; <line3> } <line4> for (final String sourceName : sourceNames) { <line5> try { <line6> final AuthoritativeResource authoritativeResource = fetchAuthoritativeResource(sourceName); <line7> resourceDataDao.store(sourceName, authoritativeResource); <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>
6384	"public class A { <line0> @Test <line1> public void qqq_getProjectShortNameTest() { <line2> Project project = null; <line3> try { <line4> String shortName = ""project-sprt_app""; <line5> CreateProject createProjectRequest = getCreateProjectRequest(shortName); <line6> CreateProject.Response createProjectResponse = <line7> projectServiceStub.createProject(createProjectRequest); <line8> project = createProjectResponse.getProject(); <line9> assertEquals( <line10> ""Project name not match with expected project name"", <line11> createProjectRequest.getName(), <line12> project.getName()); <line13> GetProjectShortName setProjectShortName = <line14> GetProjectShortName.newBuilder().setId(project.getId()).build(); <line15> GetProjectShortName.Response response = <line16> projectServiceStub.getProjectShortName(setProjectShortName); <line17> assertEquals( <line18> ""Project short name not match with expected short name"", <line19> shortName, <line20> response.getShortName()); <line21> } catch (StatusRuntimeException e) { <line22> Status status = Status.fromThrowable(e); <line23> fail(); <line24> } finally { <line25> if (project != null) { <line26> DeleteProject deleteProject = DeleteProject.newBuilder().setId(project.getId()).build(); <line27> DeleteProject.Response deleteProjectResponse = <line28> projectServiceStub.deleteProject(deleteProject); <line29> assertTrue(deleteProjectResponse.getStatus()); <line30> } <line31> } <line32> } <line33> } <line34> "	<line2>, <line9>, <line24>, <line29>, <line32>
6385	"public class A { <line0> @Override <line1> public <Q, R> CompletableFuture<QueryResponseMessage<R>> query(QueryMessage<Q, R> queryMessage) { <line2> shutdownLatch.ifShuttingDown( <line3> String.format(""Cannot dispatch new %s as this bus is being shut down"", ""queries"")); <line4> QueryMessage<Q, R> interceptedQuery = dispatchInterceptors.intercept(queryMessage); <line5> ShutdownLatch.ActivityHandle queryInTransit = shutdownLatch.registerActivity(); <line6> CompletableFuture<QueryResponseMessage<R>> queryTransaction = new CompletableFuture<>(); <line7> try { <line8> String targetContext = targetContextResolver.resolveContext(interceptedQuery); <line9> int priority = priorityCalculator.determinePriority(interceptedQuery); <line10> QueryRequest queryRequest = <line11> serializer.serializeRequest( <line12> interceptedQuery, DIRECT_QUERY_NUMBER_OF_RESULTS, DIRECT_QUERY_TIMEOUT_MS, priority); <line13> ResultStream<QueryResponse> result = <line14> axonServerConnectionManager <line15> .getConnection(targetContext) <line16> .queryChannel() <line17> .query(queryRequest); <line18> ResponseProcessingTask<R> responseProcessingTask = <line19> new ResponseProcessingTask<>( <line20> result, serializer, queryTransaction, priority, queryMessage.getResponseType()); <line21> result.onAvailable(() -> queryExecutor.submit(responseProcessingTask)); <line22> } catch (Exception e) { <line23> AxonException exception = <line24> ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e); <line25> queryTransaction.completeExceptionally(exception); <line26> queryInTransit.end(); <line27> } <line28> return queryTransaction; <line29> } <line30> } <line31> "	<line23>
6386	"public class A { <line0> @Override <line1> protected void map(LongWritable key, Text value, Context context) <line2> throws IOException, InterruptedException { <line3> String[] elements = COMMA_PATTERN.split(value.toString()); <line4> if (elements.length != 3) { <line5> throw new IOException( <line6> ""Expected input of length 3, received "" <line7> + elements.length <line8> + "". Please make sure you adhere to "" <line9> + ""the structure of (i,j,value) for representing a graph in text. "" <line10> + ""Input line was: '"" <line11> + value <line12> + ""'.""); <line13> } <line14> if (elements[0].isEmpty() || elements[1].isEmpty() || elements[2].isEmpty()) { <line15> throw new IOException( <line16> ""Found an element of 0 length. Please be sure you adhere to the structure of "" <line17> + ""(i,j,value) for  representing a graph in text.""); <line18> } <line19> DistributedRowMatrix.MatrixEntryWritable toAdd = new DistributedRowMatrix.MatrixEntryWritable(); <line20> IntWritable row = new IntWritable(Integer.valueOf(elements[0])); <line21> toAdd.setRow(-1); <line22> toAdd.setCol(Integer.valueOf(elements[1])); <line23> toAdd.setVal(Double.valueOf(elements[2])); <line24> context.write(row, toAdd); <line25> } <line26> } <line27> "	<line4>
6387	"public class A { <line0> @Override <line1> protected byte[] doExport( <line2> long recordSetId, <line3> int status, <line4> int start, <line5> int end, <line6> OrderByComparator<DDLRecord> orderByComparator) <line7> throws Exception { <line8> DDLRecordSet recordSet = _ddlRecordSetService.getRecordSet(recordSetId); <line9> Map<String, DDMFormField> ddmFormFields = getDistinctFields(recordSetId); <line10> DateTimeFormatter dateTimeFormatter = getDateTimeFormatter(); <line11> try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); <line12> Workbook workbook = new HSSFWorkbook()) { <line13> Sheet sheet = workbook.createSheet(); <line14> createHeaderRow(ddmFormFields.values(), sheet, workbook); <line15> List<DDLRecord> records = <line16> _ddlRecordLocalService.getRecords(recordSetId, status, start, end, orderByComparator); <line17> Iterator<DDLRecord> iterator = records.iterator(); <line18> int rowIndex = 1; <line19> CellStyle cellStyle = createCellStyle(workbook, false, ""Courier New"", (short) 12); <line20> while (iterator.hasNext()) { <line21> DDLRecord record = iterator.next(); <line22> DDLRecordVersion recordVersion = record.getRecordVersion(); <line23> DDMFormValues ddmFormValues = <line24> _storageEngine.getDDMFormValues(recordVersion.getDDMStorageId()); <line25> Map<String, DDMFormFieldRenderedValue> values = <line26> getRenderedValues(recordSet.getScope(), ddmFormFields.values(), ddmFormValues); <line27> createDataRow( <line28> rowIndex++, <line29> sheet, <line30> dateTimeFormatter, <line31> recordVersion.getUserName(), <line32> getStatusMessage(recordVersion.getStatus()), <line33> recordVersion.getStatusDate(), <line34> cellStyle, <line35> ddmFormFields, <line36> values); <line37> } <line38> workbook.write(byteArrayOutputStream); <line39> return byteArrayOutputStream.toByteArray(); <line40> } catch (Exception exception) { <line41> if (_log.isDebugEnabled()) { <line42> } <line43> return new byte[0]; <line44> } <line45> } <line46> } <line47> "	<line42>
6388	public class A { <line0> public static FlightVo from(Flight flight) { <line1> FlightVo flightVo = new FlightVo(); <line2> try { <line3> BeanUtils.copyProperties(flight, flightVo); <line4> BeanUtils.copyProperties(flight.getMutableFlightDetails(), flightVo); <line5> flightVo.setId(flight.getId()); <line6> } catch (Exception e) { <line7> } <line8> return flightVo; <line9> } <line10> } <line11> 	<line7>
6389	"public class A { <line0> @Test <line1> public void testEchoMethodInvocation() throws Exception { <line2> CountDownLatch latch = new CountDownLatch(1); <line3> Work work = new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY); <line4> thriftClient.echo( <line5> work, <line6> new AsyncMethodCallback<Work>() { <line7> @Override <line8> public void onComplete(Work response) { <line9> echoResult = response; <line10> latch.countDown(); <line11> } <line12>  <line13> @Override <line14> public void onError(Exception exception) { <line15> latch.countDown(); <line16> } <line17> }); <line18> latch.await(5, TimeUnit.SECONDS); <line19> MockEndpoint mockEndpoint = getMockEndpoint(""mock:thrift-service""); <line20> mockEndpoint.expectedMessageCount(1); <line21> mockEndpoint.expectedHeaderValuesReceivedInAnyOrder( <line22> ThriftConstants.THRIFT_METHOD_NAME_HEADER, ""echo""); <line23> mockEndpoint.assertIsSatisfied(); <line24> assertNotNull(echoResult); <line25> assertTrue(echoResult instanceof Work); <line26> assertEquals(THRIFT_TEST_NUM1, echoResult.num1); <line27> assertEquals(Operation.MULTIPLY, echoResult.op); <line28> } <line29> } <line30> "	<line15>
6390	"public class A { <line0> @Override <line1> public void invoke(AmazonS3FilePayload payload) throws EndpointException { <line2> if (configuration.getEnabled()) { <line3> super.invoke(payload); <line4> if (!new File(payload.getFilePath()).exists()) { <line5> throw new InvalidAmazonS3PayloadException( <line6> ""File at path "" + payload.getFilePath() + "" does not exist""); <line7> } <line8> s3Client.uploadFile(payload.getFilePath(), getKeyName(payload), getBucketName(payload)); <line9> } else { <line10> } <line11> } <line12> } <line13> "	<line10>
6391	public class A { <line0> public void processRow(ResultSet rs) throws SQLException { <line1> String layer = rs.getString(1); <line2> String gridset = rs.getString(2); <line3> int z = rs.getInt(3); <line4> String paramsKvp = rs.getString(4); <line5> String paramsId = rs.getString(5); <line6> String sha = getParamsSha1(paramsKvp); <line7> File origin = new File(buildFolderPath(root, layer, gridset, z, paramsId)); <line8> File destination = new File(buildFolderPath(root, layer, gridset, z, sha)); <line9> org.geowebcache.util.FileUtils.renameFile(origin, destination); <line10> count++; <line11> if (count % 1000 == 0 || count >= total) { <line12> } <line13> } <line14> } <line15> 	<line12>
6392	"public class A { <line0> @Test <line1> public void testRemoveHeaderDisabeld() throws Exception { <line2> final SahiHeaderAspect sahiHeaderAspect = BeanLoader.loadBean(SahiHeaderAspect.class); <line3> ReflectionTestUtils.setField(sahiHeaderAspect, ""removeAuthorizationHeader"", false); <line4> testling.removeHeader(""Authorization""); <line5> assertLastLine(logFile, ""SAHI"", LogLevel.DEBUG, ""SAHI skip remove Header 'Authorization'""); <line6> } <line7> } <line8> "	<line4>
6393	"public class A { <line0> private void writeTypeSystem(JCas aJCas) throws IOException { <line1> if (!typeSystemLocation.startsWith(JAR_PREFIX) && new File(typeSystemLocation).isAbsolute()) { <line2> try (OutputStream typeOS = CompressionUtils.getOutputStream(new File(typeSystemLocation))) { <line3> writeTypeSystem(aJCas, typeOS); <line4> } <line5> } else { <line6> try (NamedOutputStream typeOS = getOutputStream(typeSystemLocation, """")) { <line7> writeTypeSystem(aJCas, typeOS); <line8> } <line9> } <line10> } <line11> } <line12> "	<line3>, <line7>
6394	public class A { <line0> private void _sleepForPollPeriod() { <line1> try { <line2> sleep(TIME_BETWEEN_RECORDINGS); <line3> } catch (InterruptedException ex) { <line4> interrupt(); <line5> } <line6> } <line7> } <line8> 	<line2>, <line4>
6395	"public class A { <line0> @Override <line1> public void debug(String msg, Throwable t) { <line2> if (!isDebugEnabled()) { <line3> return; <line4> } <line5> msg = ""{} "" + msg; <line6> final Object[] os = {component}; <line7> logRepository.addLogMessage(LogLevel.DEBUG, msg, os, t); <line8> } <line9> } <line10> "	<line7>
6396	public class A { <line0> private boolean imported(List<ImportDeclaration> imports, String fullyQualifiedName) { <line1> final String packageName = ClassUtils.getPackageName(fullyQualifiedName); <line2> for (final ImportDeclaration i : imports) { <line3> if (!i.isStatic()) { <line4> final String importName = i.getName().toString(); <line5> if (i.isAsterisk()) { <line6> if (packageName.equals(importName)) { <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> return true; <line10> } <line11> } else { <line12> if (fullyQualifiedName.equals(importName)) { <line13> if (LOG.isDebugEnabled()) { <line14> } <line15> return true; <line16> } <line17> } <line18> } <line19> } <line20> return false; <line21> } <line22> } <line23> 	<line8>, <line14>
6397	public class A { <line0> @Override <line1> public DatanodeStateMachine.DatanodeStates call() throws Exception { <line2> Collection<InetSocketAddress> addresses = null; <line3> try { <line4> addresses = getSCMAddressForDatanodes(conf); <line5> } catch (IllegalArgumentException e) { <line6> if (!Strings.isNullOrEmpty(e.getMessage())) { <line7> } <line8> return DatanodeStateMachine.DatanodeStates.SHUTDOWN; <line9> } <line10> if (addresses.isEmpty()) { <line11> return DatanodeStateMachine.DatanodeStates.SHUTDOWN; <line12> } else { <line13> for (InetSocketAddress addr : addresses) { <line14> if (addr.isUnresolved()) { <line15> return this.context.getState(); <line16> } <line17> } <line18> for (InetSocketAddress addr : addresses) { <line19> connectionManager.addSCMServer(addr); <line20> this.context.addEndpoint(addr); <line21> } <line22> InetSocketAddress reconAddress = getReconAddresses(conf); <line23> if (reconAddress != null) { <line24> connectionManager.addReconServer(reconAddress); <line25> this.context.addEndpoint(reconAddress); <line26> } <line27> } <line28> persistContainerDatanodeDetails(); <line29> return this.context.getState().getNextState(); <line30> } <line31> } <line32> 	<line7>, <line11>, <line15>
6398	public class A { <line0> private List<JRJsonNode> goAnywhereDown(JRJsonNode jrJsonNode) { <line1> List<JRJsonNode> result = new ArrayList<>(); <line2> Deque<JRJsonNode> stack = new ArrayDeque<>(); <line3> JsonNode initialDataNode = jrJsonNode.getDataNode(); <line4> if (log.isDebugEnabled()) { <line5> } <line6> stack.push(jrJsonNode); <line7> while (!stack.isEmpty()) { <line8> JRJsonNode stackNode = stack.pop(); <line9> JsonNode stackDataNode = stackNode.getDataNode(); <line10> addChildrenToStack(stackNode, stack); <line11> if (stackDataNode.isArray()) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> ArrayNode newNode = getEvaluationContext().getObjectMapper().createArrayNode(); <line15> for (Integer idx : expression.getIndexes()) { <line16> if (idx >= 0 && idx < stackDataNode.size()) { <line17> JRJsonNode nodeAtIndex = stackNode.createChild(stackDataNode.get(idx)); <line18> if (applyFilter(nodeAtIndex)) { <line19> newNode.add(nodeAtIndex.getDataNode()); <line20> } <line21> } <line22> } <line23> if (newNode.size() > 0) { <line24> result.add(stackNode.createChild(newNode)); <line25> } <line26> } <line27> } <line28> return result; <line29> } <line30> } <line31> 	<line5>, <line13>
6399	public class A { <line0> @Override <line1> public boolean apply(UUID nodeId, Object msg) { <line2> try { <line3> if (!nodeId.equals(ignite1.cluster().localNode().id())) { <line4> error.set(true); <line5> return false; <line6> } <line7> return true; <line8> } finally { <line9> rcvLatch.countDown(); <line10> } <line11> } <line12> } <line13> 	<line3>, <line4>
6400	"public class A { <line0> @Override <line1> public List<ActivityStreamComment> getActionCommentRecords(int id) { <line2> List<ActivityStreamComment> comments = new ArrayList<>(); <line3> Connection conn = null; <line4> PreparedStatement stat = null; <line5> ResultSet result = null; <line6> try { <line7> conn = this.getConnection(); <line8> stat = conn.prepareStatement(GET_ACTION_COMMENT_RECORDS); <line9> stat.setInt(1, id); <line10> result = stat.executeQuery(); <line11> while (result.next()) { <line12> ActivityStreamComment comment = new ActivityStreamComment(); <line13> comment.setId(result.getInt(1)); <line14> comment.setUsername(result.getString(2)); <line15> comment.setCommentText(result.getString(3)); <line16> Timestamp timestamp = result.getTimestamp(4); <line17> comment.setCommentDate(new Date(timestamp.getTime())); <line18> comments.add(comment); <line19> } <line20> } catch (Throwable t) { <line21> throw new RuntimeException(""Error while loading activity stream comment records"", t); <line22> } finally { <line23> closeDaoResources(result, stat, conn); <line24> } <line25> return comments; <line26> } <line27> } <line28> "	<line21>
6401	public class A { <line0> @Override <line1> public void begin() { <line2> exchange.setProperty(ExchangePropertyKey.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri()); <line3> MessageHelper.resetStreamCache(exchange.getIn()); <line4> if (pattern != null) { <line5> originalPattern = exchange.getPattern(); <line6> exchange.setPattern(pattern); <line7> } <line8> } <line9> } <line10> 	<line2>, <line6>
6402	public class A { <line0> public LedgerHandle createLedger( <line1> int ensSize, <line2> int writeQuorumSize, <line3> int ackQuorumSize, <line4> DigestType digestType, <line5> byte[] passwd, <line6> final Map<String, byte[]> customMetadata) <line7> throws InterruptedException, BKException { <line8> CompletableFuture<LedgerHandle> future = new CompletableFuture<>(); <line9> SyncCreateCallback result = new SyncCreateCallback(future); <line10> asyncCreateLedger( <line11> ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, result, null, customMetadata); <line12> LedgerHandle lh = SyncCallbackUtils.waitForResult(future); <line13> if (lh == null) { <line14> throw BKException.create(BKException.Code.UnexpectedConditionException); <line15> } <line16> return lh; <line17> } <line18> } <line19> 	<line14>
6403	"public class A { <line0> public static jsignalml.compiler.CompiledClass<? extends jsignalml.Source> loadFromFile( <line1> String pkg, File file) <line2> throws java.io.IOException, java.lang.ClassNotFoundException, org.xml.sax.SAXException { <line3> jsignalml.JavaClassGen gen = <line4> jsignalml.CodecParser.generateFromFile(file, ""org.signalml.codec."" + pkg, false); <line5> String name = gen.getFullClassName(); <line6> CharSequence code = gen.getSourceCode(); <line7> jsignalml.compiler.CompiledClass<jsignalml.Source> klass = <line8> jsignalml.compiler.CompiledClass.newCompiledClass(name, code); <line9> return klass; <line10> } <line11> } <line12> "	<line9>
6404	"public class A { <line0> @Test <line1> public void test_hgvs_walk_and_roll_2() { <line2> String genome = ""testHg19Chr17""; <line3> String vcf = path(""hgvs_walk_and_roll.1.vcf""); <line4> compareHgvs(genome, vcf, true); <line5> } <line6> } <line7> "	<line2>
6405	"public class A { <line0> @PluginFactory <line1> public static Log4j2Appender createAppender( <line2> @PluginAttribute(""name"") String name, <line3> @PluginElement(""Layout"") Layout<? extends Serializable> layout, <line4> @PluginElement(""Filter"") final Filter filter, <line5> @PluginAttribute(""otherAttribute"") String otherAttribute) { <line6> if (name == null) { <line7> return null; <line8> } <line9> if (layout == null) { <line10> layout = PatternLayout.createDefaultLayout(); <line11> } <line12> return new Log4j2Appender(name, filter, layout, true); <line13> } <line14> } <line15> "	<line7>
6406	"public class A { <line0> public void prepareTables() throws SQLException { <line1> try (Connection connection = _dbAdaptor.getConnection(); <line2> Statement statement = connection.createStatement()) { <line3> connection.setAutoCommit(true); <line4> DatabaseMetaData metaData = connection.getMetaData(); <line5> _dbAdaptor.adaptTo(metaData); <line6> String tableName = _dbAdaptor.convertIdentifier(getTableName()); <line7> String schemaName = _dbAdaptor.convertIdentifier(getSchemaName()); <line8> if (INFERRED.equalsIgnoreCase(schemaName)) { <line9> schemaName = connection.getSchema(); <line10> setSchemaName(schemaName); <line11> } <line12> String catalogName = _dbAdaptor.convertIdentifier(getCatalogName()); <line13> if (INFERRED.equalsIgnoreCase(catalogName)) { <line14> catalogName = connection.getCatalog(); <line15> setCatalogName(catalogName); <line16> } <line17> try (ResultSet result = metaData.getTables(catalogName, schemaName, tableName, null)) { <line18> if (!result.next()) { <line19> if (LOG.isDebugEnabled()) <line20> statement.executeUpdate(getCreateStatementAsString()); <line21> } else { <line22> if (LOG.isDebugEnabled()) <line23> ResultSet colResult = null; <line24> try { <line25> colResult = <line26> metaData.getColumns( <line27> catalogName, <line28> schemaName, <line29> tableName, <line30> _dbAdaptor.convertIdentifier(getMaxIntervalColumn())); <line31> } catch (SQLException sqlEx) { <line32> throw sqlEx; <line33> } <line34> try { <line35> if (!colResult.next()) { <line36> try { <line37> statement.executeUpdate(getAlterTableForMaxIntervalAsString()); <line38> } catch (SQLException sqlEx) { <line39> throw sqlEx; <line40> } <line41> } <line42> } finally { <line43> colResult.close(); <line44> } <line45> } <line46> } <line47> String index1 = ""idx_"" + getTableName() + ""_expiry""; <line48> String index2 = ""idx_"" + getTableName() + ""_session""; <line49> boolean index1Exists = false; <line50> boolean index2Exists = false; <line51> try (ResultSet result = <line52> metaData.getIndexInfo(catalogName, schemaName, tableName, false, true)) { <line53> while (result.next()) { <line54> String idxName = result.getString(""INDEX_NAME""); <line55> if (index1.equalsIgnoreCase(idxName)) index1Exists = true; <line56> else if (index2.equalsIgnoreCase(idxName)) index2Exists = true; <line57> } <line58> } <line59> if (!index1Exists) statement.executeUpdate(getCreateIndexOverExpiryStatementAsString(index1)); <line60> if (!index2Exists) <line61> statement.executeUpdate(getCreateIndexOverSessionStatementAsString(index2)); <line62> } <line63> } <line64> } <line65> "	<line20>, <line23>, <line32>, <line39>
6407	"public class A { <line0> @Override <line1> public void shutdown() { <line2> try { <line3> File baseDir = <line4> new File( <line5> GenericTestUtils.getTempPath( <line6> MiniOzoneClusterImpl.class.getSimpleName() + ""-"" + getClusterId())); <line7> stop(); <line8> FileUtils.deleteDirectory(baseDir); <line9> ContainerCache.getInstance(conf).shutdownCache(); <line10> DefaultMetricsSystem.shutdown(); <line11> } catch (IOException e) { <line12> } <line13> } <line14> } <line15> "	<line3>, <line12>
6408	public class A { <line0> public void deleteRequestDeployState(String requestId) { <line1> if (!active) { <line2> return; <line3> } <line4> requestIdToDeployState.remove(requestId); <line5> } <line6> } <line7> 	<line2>
6409	"public class A { <line0> @Override <line1> protected boolean readElement(final IConfigurationElement element) { <line2> if (""UpdateItemType"".equals(element.getName())) { <line3> SafeRunner.run( <line4> new RegistryReader.RegistrySafeRunnable() { <line5> @Override <line6> public void run() throws Exception { <line7> try { <line8> final String name = element.getAttribute(""name""); <line9> final String description = element.getAttribute(""description""); <line10> final String displayLabel = element.getAttribute(""displayLabel""); <line11> ExtensionUpdateItemType type = <line12> new ExtensionUpdateItemType( <line13> name, element.getContributor().getName(), displayLabel); <line14> type.setDescription(description); <line15> IUpdateItemType existedType = extensionUpdateItemTypes.get(name); <line16> if (existedType != null) { <line17> if (existedType instanceof ExtensionUpdateItemType) { <line18> } else { <line19> } <line20> } else { <line21> extensionUpdateItemTypes.put(name, type); <line22> } <line23> } catch (Exception e) { <line24> } <line25> } <line26> }); <line27> return true; <line28> } else if (""ProcessUpdateManagerProvider"".equals(element.getName())) { <line29> readProviderElement(element, processProvidersMap); <line30> return true; <line31> } else if (""RepositoryUpdateManagerProvider"".equals(element.getName())) { <line32> readProviderElement(element, repositorProvidersMap); <line33> return true; <line34> } <line35> return false; <line36> } <line37> } <line38> "	<line18>, <line19>, <line24>
6410	"public class A { <line0> private File getDBFile() throws IOException { <line1> if (dbPath == null) { <line2> throw new IOException(""A Path to for DB file is needed.""); <line3> } <line4> if (StringUtil.isBlank(dbname)) { <line5> throw new IOException(""A valid DB name is required.""); <line6> } <line7> return Paths.get(dbPath.toString(), dbname).toFile(); <line8> } <line9> } <line10> "	<line2>, <line5>
6411	public class A { <line0> private JSONObject getProperties(RequestContext requestContext) { <line1> String remoteIP = requestContext.getClientIp(); <line2> JSONObject jsonObMap = new JSONObject(); <line3> ThrottleConfigDto config = ConfigHolder.getInstance().getConfig().getThrottleConfig(); <line4> if (remoteIP != null && remoteIP.length() > 0) { <line5> try { <line6> InetAddress address = InetAddress.getByName(remoteIP); <line7> if (address instanceof Inet4Address) { <line8> jsonObMap.put(ThrottleConstants.IP, FilterUtils.ipToLong(remoteIP)); <line9> jsonObMap.put(ThrottleConstants.IPV6, 0); <line10> } else if (address instanceof Inet6Address) { <line11> jsonObMap.put(ThrottleConstants.IPV6, FilterUtils.ipToBigInteger(remoteIP)); <line12> jsonObMap.put(ThrottleConstants.IP, 0); <line13> } <line14> } catch (UnknownHostException e) { <line15> jsonObMap.put(ThrottleConstants.IPV6, 0); <line16> jsonObMap.put(ThrottleConstants.IP, 0); <line17> } <line18> } <line19> if (config.isHeaderConditionsEnabled()) { <line20> Map<String, String> headers = requestContext.getHeaders(); <line21> for (String name : headers.keySet()) { <line22> jsonObMap.put(name, headers.get(name)); <line23> } <line24> } <line25> if (config.isQueryConditionsEnabled()) { <line26> Map<String, String> params = requestContext.getQueryParameters(); <line27> for (String name : params.keySet()) { <line28> jsonObMap.put(name, params.get(name)); <line29> } <line30> } <line31> String callerToken = requestContext.getAuthenticationContext().getCallerToken(); <line32> if (config.isJwtClaimConditionsEnabled() && callerToken != null) { <line33> Map<String, String> claims = ThrottleUtils.getJWTClaims(callerToken); <line34> for (String key : claims.keySet()) { <line35> jsonObMap.put(key, claims.get(key)); <line36> } <line37> } <line38> return jsonObMap; <line39> } <line40> } <line41> 	<line15>
6412	public class A { <line0> @Override <line1> public Collection<ACITuple> filter(AciContext aciContext, OperationScope scope, Entry userEntry) <line2> throws LdapException { <line3> if (aciContext.getEntryDn().isRootDse()) { <line4> return aciContext.getAciTuples(); <line5> } <line6> if (aciContext.getAciTuples().isEmpty()) { <line7> return aciContext.getAciTuples(); <line8> } <line9> if (scope != OperationScope.ENTRY) { <line10> return aciContext.getAciTuples(); <line11> } <line12> int immSubCount = -1; <line13> for (Iterator<ACITuple> i = aciContext.getAciTuples().iterator(); i.hasNext(); ) { <line14> ACITuple tuple = i.next(); <line15> if (!tuple.isGrant()) { <line16> continue; <line17> } <line18> for (ProtectedItem item : tuple.getProtectedItems()) { <line19> if (item instanceof MaxImmSubItem) { <line20> if (immSubCount < 0) { <line21> immSubCount = getImmSubCount(aciContext.getOperationContext(), aciContext.getEntryDn()); <line22> } <line23> MaxImmSubItem mis = (MaxImmSubItem) item; <line24> if (immSubCount >= mis.getValue()) { <line25> i.remove(); <line26> break; <line27> } <line28> } <line29> } <line30> } <line31> return aciContext.getAciTuples(); <line32> } <line33> } <line34> 	<line3>
6413	public class A { <line0> public boolean test(Authorizable authorizable) { <line1> try { <line2> return authorizable != null && group.isMember(authorizable); <line3> } catch (RepositoryException e) { <line4> return false; <line5> } <line6> } <line7> } <line8> 	<line4>
6414	"public class A { <line0> private <T> boolean matches(Supplier<T> supplier, Optional<String> value) { <line1> try { <line2> String nodeType = <line3> given().get(supplier.get() + ""/alpha/api/v1/metrics"").jsonPath().getString(""nodeType""); <line4> if (value.get().equalsIgnoreCase(nodeType)) { <line5> return true; <line6> } else { <line7> return false; <line8> } <line9> } catch (Exception ex) { <line10> return false; <line11> } <line12> } <line13> } <line14> "	<line4>, <line10>
6415	public class A { <line0> protected void doPrack(final SipServletRequest req) throws ServletException, IOException { <line1> final EventSource source = SessionUtils.getEventSource(req); <line2> if (source instanceof SIPIncomingCall) { <line3> final SIPIncomingCall call = (SIPIncomingCall) source; <line4> try { <line5> call.doPrack(req); <line6> } catch (final Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6416	"public class A { <line0> @Override <line1> public JsonObject search(JsonObject queryJson) throws IOException { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> JsonObject top = new JsonObject(); <line5> JsonArray elements = new JsonArray(); <line6> Search search = new Search.Builder(queryJson.toString()).build(); <line7> SearchResult result = client.execute(search); <line8> if (result == null) { <line9> return top; <line10> } <line11> if (result.getTotal() > 0) { <line12> top.addProperty( <line13> ""total"", result.getJsonObject().getAsJsonObject(""hits"").get(""total"").getAsInt()); <line14> JsonArray hits = result.getJsonObject().getAsJsonObject(""hits"").getAsJsonArray(""hits""); <line15> for (int i = 0; i < hits.size(); i++) { <line16> JsonObject o = hits.get(i).getAsJsonObject().getAsJsonObject(""_source""); <line17> elements.add(o); <line18> } <line19> } <line20> top.add(""elements"", elements); <line21> if (result.getJsonObject().has(""aggregations"")) { <line22> JsonObject aggs = result.getJsonObject().getAsJsonObject(""aggregations""); <line23> top.add(""aggregations"", aggs); <line24> } <line25> return top; <line26> } <line27> } <line28> "	<line3>
6417	public class A { <line0> GoogleIdToken authenticate(String token) { <line1> final GoogleIdToken googleIdToken; <line2> try { <line3> googleIdToken = verifyIdToken(token); <line4> } catch (IOException e) { <line5> return null; <line6> } <line7> if (googleIdToken == null) { <line8> return null; <line9> } <line10> final String email = googleIdToken.getPayload().getEmail(); <line11> if (email == null) { <line12> return null; <line13> } <line14> final String domain = getDomain(email); <line15> if (domain == null) { <line16> return null; <line17> } else if (domainWhitelist.contains(domain)) { <line18> return googleIdToken; <line19> } <line20> if (validatedEmailCache.getIfPresent(email) != null) { <line21> return googleIdToken; <line22> } <line23> if (!SERVICE_ACCOUNT_PATTERN.matcher(email).matches()) { <line24> return null; <line25> } <line26> if (!allowedAudiences.isEmpty() && googleIdToken.getPayload().getAudience() != null) { <line27> if (!googleIdToken.verifyAudience(allowedAudiences)) { <line28> return null; <line29> } <line30> } <line31> final String projectId; <line32> try { <line33> projectId = checkServiceAccountProject(email); <line34> } catch (IOException e) { <line35> return null; <line36> } <line37> if (projectId != null) { <line38> validatedEmailCache.put(email, projectId); <line39> return googleIdToken; <line40> } <line41> return null; <line42> } <line43> } <line44> 	<line5>, <line8>, <line12>, <line16>, <line18>, <line21>, <line24>, <line28>, <line35>, <line41>
6418	"public class A { <line0> @Override <line1> public Boolean call() { <line2> HttpToolResponse result = <line3> ((BrooklynNode) entity()) <line4> .http() <line5> .responseSuccess( <line6> Predicates.<Integer>or( <line7> ResponseCodePredicates.success(), Predicates.equalTo(HttpStatus.SC_FORBIDDEN))) <line8> .post(""/v1/applications"", headers, plan.getBytes()); <line9> if (result.getResponseCode() == HttpStatus.SC_FORBIDDEN) { <line10> return false; <line11> } else { <line12> byte[] content = result.getContent(); <line13> response.set(content); <line14> return true; <line15> } <line16> } <line17> } <line18> "	<line10>
6419	"public class A { <line0> @Override <line1> public UpdateContainer undoIt(Workspace workspace) { <line2> UpdateContainer c = new UpdateContainer(); <line3> Worksheet worksheet = workspace.getWorksheet(worksheetId); <line4> if (oldType == null) { <line5> worksheet.getSemanticTypes().unassignColumnSemanticType(hNodeId); <line6> } else { <line7> worksheet.getSemanticTypes().setType(oldType); <line8> worksheet.getSemanticTypes().addSynonymTypesForHNodeId(hNodeId, oldSynonymTypes); <line9> } <line10> String alignmentId = <line11> AlignmentManager.Instance().constructAlignmentId(workspace.getId(), worksheetId); <line12> AlignmentManager.Instance().addAlignmentToMap(alignmentId, oldAlignment); <line13> oldAlignment.setGraph(oldGraph); <line14> try { <line15> c.append(computeAlignmentAndSemanticTypesAndCreateUpdates(workspace)); <line16> } catch (Exception e) { <line17> return new UpdateContainer( <line18> new ErrorUpdate(""Error occured while unsetting the semantic type!"")); <line19> } <line20> return c; <line21> } <line22> } <line23> "	<line17>
6420	public class A { <line0> @Override <line1> public OrchestrationContext build() { <line2> return new OrchestrationContext( <line3> new OutboundDocSubmissionDeferredRequestStrategyImpl_g0(), <line4> new OutboundDocSubmissionDeferredRequestOrchestratable( <line5> getNhinDelegate(), getRequest(), getTarget(), getAssertionType())); <line6> } <line7> } <line8> 	<line2>
6421	"public class A { <line0> private boolean openConnection() { <line1> try { <line2> if (vo.getConnection() instanceof SerialPortConnection) { <line3> SerialPortConnection spc = (SerialPortConnection) vo.getConnection(); <line4> master.setConnection( <line5> new MangoMBusSerialConnection( <line6> ""MBus "" + this.vo.getXid(), spc.getPortName(), spc.getBitPerSecond(), 1000)); <line7> } else { <line8> master.setConnection(vo.getConnection()); <line9> } <line10> master.open(); <line11> return true; <line12> } catch (IOException ex) { <line13> master.setConnection(null); <line14> raiseEvent( <line15> DATA_SOURCE_EXCEPTION_EVENT, <line16> System.currentTimeMillis(), <line17> true, <line18> new TranslatableMessage(""event.exception2"", ""openConnection() Failed"", ex.getMessage())); <line19> return false; <line20> } <line21> } <line22> } <line23> "	<line2>, <line13>
6422	public class A { <line0> @Deprecated <line1> public static com.liferay.commerce.tax.model.CommerceTaxMethodSoap addCommerceTaxMethod( <line2> String[] nameMapLanguageIds, <line3> String[] nameMapValues, <line4> String[] descriptionMapLanguageIds, <line5> String[] descriptionMapValues, <line6> String engineKey, <line7> boolean percentage, <line8> boolean active, <line9> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line10> throws RemoteException { <line11> try { <line12> Map<Locale, String> nameMap = <line13> LocalizationUtil.getLocalizationMap(nameMapLanguageIds, nameMapValues); <line14> Map<Locale, String> descriptionMap = <line15> LocalizationUtil.getLocalizationMap(descriptionMapLanguageIds, descriptionMapValues); <line16> com.liferay.commerce.tax.model.CommerceTaxMethod returnValue = <line17> CommerceTaxMethodServiceUtil.addCommerceTaxMethod( <line18> nameMap, descriptionMap, engineKey, percentage, active, serviceContext); <line19> return com.liferay.commerce.tax.model.CommerceTaxMethodSoap.toSoapModel(returnValue); <line20> } catch (Exception exception) { <line21> throw new RemoteException(exception.getMessage()); <line22> } <line23> } <line24> } <line25> 	<line21>
6423	public class A { <line0> @VisibleForTesting <line1> public PhysicalExec[] switchJoinSidesIfNecessary( <line2> TaskAttemptContext context, JoinNode plan, PhysicalExec left, PhysicalExec right) <line3> throws IOException { <line4> String[] leftLineage = PlannerUtil.getRelationLineage(plan.getLeftChild()); <line5> String[] rightLineage = PlannerUtil.getRelationLineage(plan.getRightChild()); <line6> long leftSize = estimateSizeRecursive(context, leftLineage); <line7> long rightSize = estimateSizeRecursive(context, rightLineage); <line8> PhysicalExec smaller; <line9> PhysicalExec larger; <line10> if (leftSize <= rightSize) { <line11> smaller = left; <line12> larger = right; <line13> } else { <line14> smaller = right; <line15> larger = left; <line16> } <line17> return new PhysicalExec[] {smaller, larger}; <line18> } <line19> } <line20> 	<line13>, <line16>
6424	public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (ihc == null) { <line3> return; <line4> } <line5> if (ihc.getConnectionState() != ConnectionState.CONNECTED) { <line6> return; <line7> } <line8> switch (channelUID.getId()) { <line9> case CHANNEL_CONTROLLER_STATE: <line10> if (command.equals(RefreshType.REFRESH)) { <line11> updateControllerStateChannel(); <line12> } <line13> break; <line14> case CHANNEL_CONTROLLER_UPTIME: <line15> if (command.equals(RefreshType.REFRESH)) { <line16> updateControllerInformationChannels(); <line17> } <line18> break; <line19> case CHANNEL_CONTROLLER_TIME: <line20> if (command.equals(RefreshType.REFRESH)) { <line21> updateControllerTimeChannels(); <line22> } <line23> break; <line24> default: <line25> if (command.equals(RefreshType.REFRESH)) { <line26> refreshChannel(channelUID); <line27> } else { <line28> updateResourceChannel(channelUID, command); <line29> } <line30> break; <line31> } <line32> } <line33> } <line34> 	<line2>, <line3>, <line6>
6425	public class A { <line0> public List<NowPlayingInfo> getNowPlaying() { <line1> try { <line2> return convert(statusService.getPlayStatuses()); <line3> } catch (Throwable x) { <line4> return Collections.emptyList(); <line5> } <line6> } <line7> } <line8> 	<line4>
6426	public class A { <line0> public void run() { <line1> DefaultSmppClient client = new DefaultSmppClient(); <line2> SmppSession session = null; <line3> try { <line4> clientHandlerArray[i] = new DefaultSmppClientHandler(); <line5> session = <line6> client.bind(ConfigInit.getSmppSessionConfiguration(i, false), clientHandlerArray[i]); <line7> Thread.sleep(1000); <line8> for (int j = 0; j < smsNumber; j++) { <line9> session.submit(ConfigInit.getSubmitSm(), 12000); <line10> } <line11> if (smsNumber == 0) sleep(14000); <line12> sleep(2000); <line13> session.unbind(5000); <line14> sleep(200); <line15> } catch (Exception e) { <line16> } <line17> if (session != null) { <line18> session.destroy(); <line19> } <line20> client.destroy(); <line21> listener.clientCompleted(); <line22> } <line23> } <line24> 	<line16>, <line18>, <line20>
6427	"public class A { <line0> protected boolean areBundlesStillStarting(JSONArray bundles) throws JSONException { <line1> for (int i = 0; i < bundles.length(); ++i) { <line2> JSONObject object = bundles.getJSONObject(i); <line3> String status = object.getString(""state""); <line4> String symbolicName = object.getString(""symbolicName""); <line5> if (""STARTING"".equalsIgnoreCase(status)) { <line6> return true; <line7> } <line8> } <line9> return false; <line10> } <line11> } <line12> "	<line1>, <line5>, <line6>, <line9>
6428	"public class A { <line0> public static java.util.List<com.liferay.fragment.model.FragmentCollection> <line1> getFragmentCollections( <line2> HttpPrincipal httpPrincipal, <line3> long groupId, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator< <line7> com.liferay.fragment.model.FragmentCollection> <line8> orderByComparator) { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey( <line12> FragmentCollectionServiceUtil.class, <line13> ""getFragmentCollections"", <line14> _getFragmentCollectionsParameterTypes9); <line15> MethodHandler methodHandler = <line16> new MethodHandler(methodKey, groupId, start, end, orderByComparator); <line17> Object returnObj = null; <line18> try { <line19> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line20> } catch (Exception exception) { <line21> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line22> } <line23> return (java.util.List<com.liferay.fragment.model.FragmentCollection>) returnObj; <line24> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line25> throw systemException; <line26> } <line27> } <line28> } <line29> "	<line25>
6429	public class A { <line0> public void releaseResources(boolean isForced) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> PolicyEngine policyEngine = this.policyEngine; <line4> if (policyEngine != null) { <line5> policyEngine.preCleanup(isForced); <line6> } else { <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> } <line10> if (LOG.isDebugEnabled()) { <line11> } <line12> } <line13> } <line14> 	<line2>, <line8>, <line11>
6430	public class A { <line0> @Override <line1> public IOperatorNodePushable createPushRuntime( <line2> IHyracksTaskContext ctx, <line3> IRecordDescriptorProvider recordDescProvider, <line4> int partition, <line5> int nPartitions) { <line6> return new AbstractLibraryNodePushable(ctx) { <line7> @Override <line8> protected void execute() throws IOException { <line9> if (LOGGER.isInfoEnabled()) { <line10> } <line11> FileReference rev1 = getRev1Dir(); <line12> FileReference stage = getStageDir(); <line13> move(stage, rev1); <line14> FileReference libDir = getLibraryDir(); <line15> flushDirectory(libDir); <line16> } <line17> }; <line18> } <line19> } <line20> 	<line10>
6431	public class A { <line0> public void removeRoute(int index) { <line1> synchronized (this) { <line2> if (index < 0 || index >= routes.size()) { <line3> return; <line4> } <line5> if (isActiveRoute(index)) { <line6> return; <line7> } <line8> if (index < activeRouteIndex) { <line9> activeRouteIndex--; <line10> } <line11> routes.remove(index); <line12> } <line13> notifyListeners(RoutesUpdateEvent.ROUTE_REMOVED); <line14> } <line15> } <line16> 	<line3>, <line6>
6432	public class A { <line0> public static void boxLog(String message) { <line1> } <line2> } <line3> 	<line1>
6433	public class A { <line0> public void after() { <line1> socketListener.close(); <line2> executorService.shutdown(); <line3> try { <line4> if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) { <line5> executorService.shutdownNow(); <line6> if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) { <line7> } <line8> } <line9> } catch (InterruptedException iEx) { <line10> executorService.shutdownNow(); <line11> Thread.currentThread().interrupt(); <line12> } <line13> } <line14> } <line15> 	<line1>, <line7>
6434	public class A { <line0> private void notifyConnectionFailure(int error, String reason) { <line1> try { <line2> listener.onConnectionFailure(error, reason); <line3> } catch (Throwable x) { <line4> } <line5> } <line6> } <line7> 	<line4>
6435	public class A { <line0> private static Authorizations getScanAuthorizations( <line1> ConnectorSession session, AccumuloTableHandle table, Connector connector, String username) <line2> throws AccumuloException, AccumuloSecurityException { <line3> String sessionScanUser = AccumuloSessionProperties.getScanUsername(session); <line4> if (sessionScanUser != null) { <line5> Authorizations scanAuths = <line6> connector.securityOperations().getUserAuthorizations(sessionScanUser); <line7> return scanAuths; <line8> } <line9> Optional<String> scanAuths = table.getScanAuthorizations(); <line10> if (scanAuths.isPresent()) { <line11> Authorizations auths = <line12> new Authorizations( <line13> Iterables.toArray(COMMA_SPLITTER.split(scanAuths.get()), String.class)); <line14> return auths; <line15> } else { <line16> Authorizations auths = connector.securityOperations().getUserAuthorizations(username); <line17> return auths; <line18> } <line19> } <line20> } <line21> 	<line7>, <line14>, <line17>
6436	public class A { <line0> @Override <line1> public String getIndexTextForEntity(String guid) throws AtlasBaseException { <line2> String ret = null; <line3> final AtlasEntity entity; <line4> final AtlasEntityExtInfo entityExtInfo; <line5> if (followReferences) { <line6> AtlasEntityWithExtInfo entityWithExtInfo = getAndCacheEntityWithExtInfo(guid); <line7> entity = entityWithExtInfo != null ? entityWithExtInfo.getEntity() : null; <line8> entityExtInfo = entityWithExtInfo; <line9> } else { <line10> entity = getAndCacheEntity(guid, false); <line11> entityExtInfo = null; <line12> } <line13> if (entity != null) { <line14> StringBuilder sb = new StringBuilder(); <line15> map(entity, entityExtInfo, sb, new HashSet<String>(), false); <line16> ret = sb.toString(); <line17> } <line18> if (LOG.isDebugEnabled()) { <line19> } <line20> return ret; <line21> } <line22> } <line23> 	<line19>
6437	"public class A { <line0> public static void awaitCountDown( <line1> final CountDownLatch countDownLatch, final String countDownLatchId) { <line2> int iteration = 0; <line3> try { <line4> boolean finished = false; <line5> while (!finished) { <line6> iteration++; <line7> finished = countDownLatch.await(AWAIT_TIMEOUT_MINUTES, TimeUnit.MINUTES); <line8> if (!finished) { <line9> } <line10> } <line11> } catch (final InterruptedException e) { <line12> throw new IllegalStateException( <line13> ""Awaiting completion of '"" + countDownLatchId + ""' was interrupted!"", e); <line14> } <line15> } <line16> } <line17> "	<line9>
6438	public class A { <line0> @After <line1> public void stopBundle() throws Exception { <line2> InitializerTestHelper.removeResources(resourceManager); <line3> } <line4> } <line5> 	<line3>
6439	public class A { <line0> private void closeResultSet() { <line1> if (rs != null) { <line2> try { <line3> rs.close(); <line4> } catch (Throwable e) { <line5> } <line6> } <line7> rs = null; <line8> } <line9> } <line10> 	<line5>
6440	public class A { <line0> @Override <line1> public BytesAndBits getNoBuffer(DiskRegion dr, DiskId id) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> try { <line5> return basicGet(dr, id.getOffsetInOplog(), false, id.getValueLength(), id.getUserBits()); <line6> } catch (DiskAccessException dae) { <line7> throw dae; <line8> } catch (IllegalStateException ise) { <line9> throw ise; <line10> } <line11> } <line12> } <line13> 	<line3>, <line7>, <line9>
6441	public class A { <line0> private MapObject<String, Object> convertAvroBeanToRethinkDBDocField( <line1> final String docf, final Schema fieldSchema, final Object value) { <line2> MapObject<String, Object> record = new MapObject(); <line3> for (Schema.Field member : fieldSchema.getFields()) { <line4> Object innerValue = ((PersistentBase) value).get(member.pos()); <line5> String innerDoc = rethinkDBMapping.getDocumentField(member.name()); <line6> Schema.Type innerType = member.schema().getType(); <line7> RethinkDBMapping.DocumentFieldType innerStoreType = <line8> rethinkDBMapping.getDocumentFieldType(innerDoc); <line9> Object fieldValue = <line10> convertAvroFieldToRethinkDBField( <line11> docf, member.schema(), innerType, innerStoreType, innerValue); <line12> record.put(member.name(), fieldValue); <line13> } <line14> return record; <line15> } <line16> } <line17> 	<line9>
6442	public class A { <line0> @Override <line1> public void run() { <line2> while (isRunning()) { <line3> try { <line4> final Socket conn = serverSocket.accept(); <line5> executorService.execute( <line6> new Runnable() { <line7> @Override <line8> public void run() { <line9> handleRequest(conn); <line10> if (conn.isClosed() == false) { <line11> try { <line12> conn.close(); <line13> } catch (IOException ioe) { <line14> } <line15> } <line16> } <line17> }); <line18> } catch (final SocketException se) { <line19> } catch (final IOException ioe) { <line20> if (logger.isDebugEnabled()) { <line21> } <line22> } <line23> } <line24> } <line25> } <line26> 	<line21>
6443	public class A { <line0> public static void main(String[] args) throws Exception { <line1> final Terminal terminal = TerminalBuilder.builder().system(true).build(); <line2> History defaultHistory = new DefaultHistory(); <line3> Runtime.getRuntime() <line4> .addShutdownHook( <line5> new Thread( <line6> () -> { <line7> try { <line8> defaultHistory.save(); <line9> } catch (IOException e) { <line10> } <line11> })); <line12> final LineReader lineReader = <line13> LineReaderBuilder.builder() <line14> .terminal(terminal) <line15> .highlighter(new DefaultHighlighter()) <line16> .history(defaultHistory) <line17> .build(); <line18> LogServiceShellOpts opts = new LogServiceShellOpts(); <line19> JCommander.newBuilder().addObject(opts).build().parse(args); <line20> try (LogServiceClient logServiceClient = new LogServiceClient(opts.metaQuorum)) { <line21> LogServiceShell client = new LogServiceShell(terminal, lineReader, logServiceClient); <line22> client.run(); <line23> } <line24> } <line25> } <line26> 	<line10>
6444	"public class A { <line0> private Provider<? extends Graph> getGraphProvider( <line1> Configuration configuration, String configurationPrefix) { <line2> String graphClassName = configuration.get(configurationPrefix, null); <line3> if (graphClassName == null) { <line4> throw new LumifyException(""Could not find graph configuration: "" + configurationPrefix); <line5> } <line6> final Map<String, String> configurationSubset = configuration.getSubset(configurationPrefix); <line7> final Class<?> graphClass; <line8> try { <line9> graphClass = Class.forName(graphClassName); <line10> } catch (ClassNotFoundException e) { <line11> throw new RuntimeException(""Could not find graph class with name: "" + graphClassName, e); <line12> } <line13> final Method createMethod; <line14> try { <line15> createMethod = graphClass.getDeclaredMethod(""create"", Map.class); <line16> } catch (NoSuchMethodException e) { <line17> throw new RuntimeException( <line18> ""Could not find create(Map) method on class: "" + graphClass.getName(), e); <line19> } <line20> return new Provider<Graph>() { <line21> @Override <line22> public Graph get() { <line23> Graph g; <line24> try { <line25> g = (Graph) createMethod.invoke(null, configurationSubset); <line26> } catch (Exception e) { <line27> throw new RuntimeException(""Could not create graph "" + graphClass.getName(), e); <line28> } <line29> checkLumifyGraphVersion(g); <line30> return g; <line31> } <line32> }; <line33> } <line34> } <line35> "	<line9>, <line25>
6445	public class A { <line0> @Override <line1> @Transactional <line2> public void deleteExpiredAudits() { <line3> requireNotDisposed(); <line4> try { <line5> int deletedCount = Audit.deleteExpired(emf.get()); <line6> } catch (Exception ex) { <line7> } <line8> } <line9> } <line10> 	<line6>, <line7>
6446	"public class A { <line0> @MCRCommand( <line1> syntax = ""migrate author servflags for {0}"", <line2> help = ""Create missing servflags for createdby and modifiedby for object {0}. (MCR-786)"", <line3> order = 10) <line4> public static void addServFlags(String id) <line5> throws IOException, MCRPersistenceException, MCRActiveLinkException, MCRAccessException { <line6> MCRObjectID objectID = MCRObjectID.getInstance(id); <line7> MCRBase obj = MCRMetadataManager.retrieve(objectID); <line8> MCRObjectService service = obj.getService(); <line9> if (!service.isFlagTypeSet(MCRObjectService.FLAG_TYPE_CREATEDBY)) { <line10> MCRVersionedMetadata versionedMetadata = <line11> MCRXMLMetadataManager.instance().getVersionedMetaData(objectID); <line12> String createUser = null, modifyUser = null; <line13> if (versionedMetadata == null) { <line14> createUser = MCRSessionMgr.getCurrentSession().getUserInformation().getUserID(); <line15> modifyUser = createUser; <line16> } else { <line17> List<MCRMetadataVersion> versions = versionedMetadata.listVersions(); <line18> MCRMetadataVersion firstVersion = versions.get(0); <line19> for (MCRMetadataVersion version : versions) { <line20> if (version.getType() == 'A') { <line21> firstVersion = version; <line22> } <line23> } <line24> MCRMetadataVersion lastVersion = versions.get(versions.size() - 1); <line25> createUser = firstVersion.getUser(); <line26> modifyUser = lastVersion.getUser(); <line27> } <line28> service.addFlag(MCRObjectService.FLAG_TYPE_CREATEDBY, createUser); <line29> if (!service.isFlagTypeSet(MCRObjectService.FLAG_TYPE_MODIFIEDBY)) { <line30> service.addFlag(MCRObjectService.FLAG_TYPE_MODIFIEDBY, modifyUser); <line31> } <line32> obj.setImportMode(true); <line33> MCRMetadataManager.update(obj); <line34> } <line35> } <line36> } <line37> "	<line14>, <line29>, <line30>
6447	public class A { <line0> public void closeChannel() { <line1> if (channel.getPipeline().getLast() != null) channel.getPipeline().removeLast(); <line2> channel.close(); <line3> enquireRunnable.cancel(); <line4> enquireTimer.cancel(false); <line5> connectionCheckRunnable.cancel(); <line6> connectionCheckTimer.cancel(false); <line7> userSpace.getCustomers().remove(sessionId); <line8> if (userSpace.getCustomers().isEmpty()) { <line9> userSpace.disconnectFromServer(); <line10> } <line11> } <line12> } <line13> 	<line8>, <line9>
6448	"public class A { <line0> @Override <line1> public Map<String, String> getWorkflowConfig(String mediaPackageId) <line2> throws NotFoundException, SchedulerException { <line3> notEmpty(mediaPackageId, ""mediaPackageId""); <line4> try { <line5> Opt<ExtendedEventDto> record = persistence.getEvent(mediaPackageId); <line6> if (record.isNone()) throw new NotFoundException(); <line7> return deserializeExtendedEventProperties(record.get().getWorkflowProperties()); <line8> } catch (NotFoundException e) { <line9> throw e; <line10> } catch (Exception e) { <line11> throw new SchedulerException(e); <line12> } <line13> } <line14> } <line15> "	<line11>
6449	public class A { <line0> @Override <line1> protected void before() throws Throwable { <line2> requester = <line3> H2MultiplexingRequesterBootstrap.bootstrap() <line4> .setIOReactorConfig(IOReactorConfig.custom().setSoTimeout(TIMEOUT).build()) <line5> .setTlsStrategy(new H2ClientTlsStrategy(SSLTestContexts.createClientSSLContext())) <line6> .setStrictALPNHandshake(strictALPN) <line7> .setStreamListener(LoggingH2StreamListener.INSTANCE) <line8> .setIOSessionDecorator(LoggingIOSessionDecorator.INSTANCE) <line9> .setExceptionCallback(LoggingExceptionCallback.INSTANCE) <line10> .setIOSessionListener(LoggingIOSessionListener.INSTANCE) <line11> .create(); <line12> } <line13> } <line14> 	<line2>
6450	"public class A { <line0> private int executeQuery(String queryString, Map<String, Object> queryParams) { <line1> if (logger.isDebugEnabled()) { <line2> StringBuilder paramsStr = new StringBuilder(""PARAMS:""); <line3> Map<String, Object> orderedParams = new TreeMap<>(queryParams); <line4> for (Entry<String, Object> entry : orderedParams.entrySet()) { <line5> paramsStr.append(""\n "" + entry.getKey() + "" : '"" + entry.getValue() + ""'""); <line6> } <line7> } <line8> EntityManager em = getEntityManager(); <line9> Object newTx = joinTransaction(em); <line10> Query query = em.createQuery(queryString); <line11> int result = executeWithParameters(queryParams, query); <line12> closeEntityManager(em, newTx); <line13> return result; <line14> } <line15> } <line16> "	<line1>, <line7>, <line12>
6451	public class A { <line0> public boolean load(String schemaPartitionDir, String ldifFile, String targetPartitionDir) { <line1> initSchema(schemaPartitionDir); <line2> if (schemaManager == null) { <line3> return false; <line4> } <line5> return load(ldifFile, targetPartitionDir); <line6> } <line7> } <line8> 	<line3>
6452	"public class A { <line0> protected List<X509Certificate> getTrustedCertificatesInRemoteFiles() { <line1> FilenameFilter certFilter = (file, name) -> name.toLowerCase().endsWith("".der""); <line2> try { <line3> RemoteFile[] certRemoteFiles = <line4> BEANS.get(IRemoteFileService.class).getRemoteFiles(PATH_CERTS, certFilter, null); <line5> if (certRemoteFiles == null || certRemoteFiles.length < 1) { <line6> return Collections.emptyList(); <line7> } <line8> return remoteFilesToCertificates(certRemoteFiles); <line9> } catch (RuntimeException e) { <line10> return Collections.emptyList(); <line11> } <line12> } <line13> } <line14> "	<line6>, <line10>
6453	"public class A { <line0> @Test <line1> public void testRenderTaskFormViaUIClientNoFrmFoundTest() throws Exception { <line2> changeUser(USER_JOHN); <line3> Map<String, Object> parameters = new HashMap<>(); <line4> parameters.put(""name"", ""john""); <line5> parameters.put(""age"", 33); <line6> parameters.put(""mail"", ""john@doe.org""); <line7> long processInstanceId = <line8> processClient.startProcess(CONTAINER_ID, HIRING_2_PROCESS_ID, parameters); <line9> try { <line10> List<TaskSummary> tasks = <line11> taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); <line12> assertThat(tasks).isNotNull().hasSize(1); <line13> Long taskId = tasks.get(0).getId(); <line14> String result = uiServicesClient.renderTaskForm(CONTAINER_ID, taskId); <line15> assertThat(result).isNotNull().isNotEmpty(); <line16> assertThat(result).contains(""/files/patternfly/css/patternfly.min.css\"" rel=\""stylesheet\"">""); <line17> assertThat(result) <line18> .contains(""/files/patternfly/css/patternfly-additions.min.css\"" rel=\""stylesheet\"">""); <line19> assertThat(result).contains(""/files/patternfly/js/jquery.min.js\""></script>""); <line20> assertThat(result).contains(""/files/patternfly/js/patternfly.min.js\""></script>""); <line21> assertThat(result).contains(""/files/js/kieserver-ui.js\""></script>""); <line22> assertThat(result).contains(""<h3 class=\""panel-title\"">Default form - HR Interview</h3>""); <line23> } finally { <line24> changeUser(USER_YODA); <line25> processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); <line26> } <line27> } <line28> } <line29> "	<line15>
6454	"public class A { <line0> protected void initKettle() { <line1> try { <line2> KettleSystemListener.environmentInit(PentahoSessionHolder.getSession()); <line3> if (Props.isInitialized() == false) { <line4> Props.init(Props.TYPE_PROPERTIES_EMPTY); <line5> } <line6> } catch (KettleException e) { <line7> throw new IllegalStateException(""Failed to initialize Kettle system""); <line8> } <line9> } <line10> } <line11> "	<line7>
6455	public class A { <line0> protected String format(User user, long groupId, JournalArticle article, String content) <line1> throws PortalException { <line2> Document document = null; <line3> try { <line4> document = SAXReaderUtil.read(content); <line5> format(user, groupId, article, document.getRootElement()); <line6> content = XMLUtil.formatXML(document); <line7> } catch (DocumentException documentException) { <line8> } <line9> return content; <line10> } <line11> } <line12> 	<line8>
6456	public class A { <line0> private boolean isAuthorized() { <line1> boolean isAuthorized = false; <line2> try { <line3> AccessTokenResponse localAccessTokenResponse = oAuthClientService.getAccessTokenResponse(); <line4> if (localAccessTokenResponse != null) { <line5> if (localAccessTokenResponse.isExpired( <line6> LocalDateTime.now(), TOKEN_EXPIRES_IN_BUFFER_SECONDS)) { <line7> localAccessTokenResponse = oAuthClientService.refreshToken(); <line8> } <line9> ecobeeAuth.setState(EcobeeAuthState.COMPLETE); <line10> isAuthorized = true; <line11> } else { <line12> if (ecobeeAuth.isComplete()) { <line13> ecobeeAuth.setState(EcobeeAuthState.NEED_PIN); <line14> } <line15> } <line16> accessTokenResponse = localAccessTokenResponse; <line17> ecobeeAuth.doAuthorization(); <line18> } catch (OAuthException | IOException | RuntimeException e) { <line19> if (logger.isDebugEnabled()) { <line20> } else { <line21> } <line22> } catch (EcobeeAuthException e) { <line23> if (logger.isDebugEnabled()) { <line24> } else { <line25> } <line26> ecobeeAuth.setState(EcobeeAuthState.NEED_PIN); <line27> } catch (OAuthResponseException e) { <line28> handleOAuthException(e); <line29> } <line30> return isAuthorized; <line31> } <line32> } <line33> 	<line5>, <line7>, <line12>, <line20>, <line21>, <line24>, <line25>
6457	public class A { <line0> private void publishPingResult(long period, Member member, MemberStatus status) { <line1> sink.emitNext(new FailureDetectorEvent(member, status), RETRY_NOT_SERIALIZED); <line2> } <line3> } <line4> 	<line1>
6458	public class A { <line0> private boolean changeTaskCount(int desiredActiveTaskCount) <line1> throws InterruptedException, ExecutionException, TimeoutException { <line2> int currentActiveTaskCount; <line3> Collection<TaskGroup> activeTaskGroups = activelyReadingTaskGroups.values(); <line4> currentActiveTaskCount = activeTaskGroups.size(); <line5> if (desiredActiveTaskCount < 0 || desiredActiveTaskCount == currentActiveTaskCount) { <line6> return false; <line7> } else { <line8> gracefulShutdownInternal(); <line9> changeTaskCountInIOConfig(desiredActiveTaskCount); <line10> clearAllocationInfo(); <line11> return true; <line12> } <line13> } <line14> } <line15> 	<line8>, <line11>
6459	"public class A { <line0> public ClosableReportingIterator<String[]> rowIterator(Source source) throws SourceException { <line1> if (source == null) { <line2> return null; <line3> } <line4> try { <line5> if (source instanceof SqlSource) { <line6> return new SqlRowIterator((SqlSource) source); <line7> } <line8> return ((FileSource) source).rowIterator(); <line9> } catch (Exception e) { <line10> throw new SourceException( <line11> ""Can't build iterator for source "" + source.getName() + "" :"" + e.getMessage()); <line12> } <line13> } <line14> } <line15> "	<line10>
6460	"public class A { <line0> private void testIfQuartzTablesExist() { <line1> final SingleConnectionDataSource singleConnectionDataSource = new SingleConnectionDataSource(); <line2> singleConnectionDataSource.setDriverClassName(this.databaseDriver); <line3> singleConnectionDataSource.setUsername(this.databaseUsername); <line4> singleConnectionDataSource.setPassword(this.databasePassword); <line5> singleConnectionDataSource.setUrl(this.getDatabaseUrl()); <line6> singleConnectionDataSource.setSuppressClose(false); <line7> try { <line8> final Connection connection = singleConnectionDataSource.getConnection(); <line9> final Statement statement = connection.createStatement(); <line10> statement.executeQuery(""SELECT * FROM qrtz_locks LIMIT 1""); <line11> connection.close(); <line12> } catch (final SQLException e) { <line13> if (e.getMessage().contains(""ERROR: relation \""qrtz_locks\"" does not exist"")) { <line14> this.determineRetry(""Table qrtz_lock does not exist""); <line15> } <line16> } finally { <line17> singleConnectionDataSource.destroy(); <line18> } <line19> } <line20> } <line21> "	<line13>
6461	"public class A { <line0> @Override <line1> public OAuthTokens findOAuthTokens(final Host bookmark) { <line2> if (log.isInfoEnabled()) { <line3> } <line4> final long expiry = <line5> preferences.getLong( <line6> String.format(""%s.oauth.expiry"", bookmark.getProtocol().getIdentifier())); <line7> final String prefix = this.getOAuthPrefix(bookmark); <line8> final String hostname = getOAuthHostname(bookmark); <line9> try { <line10> return new OAuthTokens( <line11> this.getPassword( <line12> bookmark.getProtocol().getScheme(), <line13> bookmark.getPort(), <line14> hostname, <line15> String.format(""%s OAuth2 Access Token"", prefix)), <line16> this.getPassword( <line17> bookmark.getProtocol().getScheme(), <line18> bookmark.getPort(), <line19> hostname, <line20> String.format(""%s OAuth2 Refresh Token"", prefix)), <line21> expiry); <line22> } catch (LocalAccessDeniedException e) { <line23> return OAuthTokens.EMPTY; <line24> } <line25> } <line26> } <line27> "	<line3>, <line23>
6462	public class A { <line0> @Override <line1> public AccumuloResource makeObject() { <line2> AccumuloResource scannerResource = new AccumuloResource(client); <line3> return scannerResource; <line4> } <line5> } <line6> 	<line3>
6463	"public class A { <line0> @Override <line1> public void subscribe(final Long dataTagId, final TagListener listener) <line2> throws CacheSynchronizationException { <line3> if (dataTagId == null) { <line4> String error = ""Called with null parameter (id collection).""; <line5> throw new IllegalArgumentException(error); <line6> } <line7> Set<Long> id = new HashSet<>(1); <line8> id.add(dataTagId); <line9> subscribe(id, listener); <line10> } <line11> } <line12> "	<line5>
6464	"public class A { <line0> @Override <line1> public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) <line2> throws MadokaParsingException { <line3> byte[] powerStateValue = mm.getValues().get(0x20).getRawValue(); <line4> if (powerStateValue == null || powerStateValue.length != 1) { <line5> setState(State.FAILED); <line6> throw new MadokaParsingException(""Incorrect value for PowerState""); <line7> } <line8> powerState = Integer.valueOf(powerStateValue[0]) == 1; <line9> setState(State.SUCCEEDED); <line10> executor.execute(() -> listener.receivedResponse(this)); <line11> } <line12> } <line13> "	<line9>
6465	public class A { <line0> @Override <line1> protected void createCacheManagers() throws Throwable { <line2> ConfigurationBuilder defaultConfig = getDefaultClusteredCacheConfig(cacheMode); <line3> defaultConfig.clustering().l1().disable().stateTransfer().fetchInMemoryState(true); <line4> createClusteredCaches(5, defaultConfig); <line5> ConsistentHash hash = <line6> cache(0).getAdvancedCache().getDistributionManager().getWriteConsistentHash(); <line7> List<Address> members = hash.getMembers(); <line8> addresses = members.toArray(new Address[members.size()]); <line9> } <line10> } <line11> 	<line3>
6466	"public class A { <line0> private void handleSSLDialog() { <line1> try { <line2> DefaultShell certificateDialog = new DefaultShell(CDKLabel.Shell.UNTRUSTED_SSL_DIALOG); <line3> certificateDialog.setFocus(); <line4> new PushButton(certificateDialog, CDKLabel.Buttons.YES).click(); <line5> new WaitWhile(new ShellIsAvailable(certificateDialog)); <line6> } catch (WaitTimeoutExpiredException ex) { <line7> String message = ""WaitTimeoutExpiredException occured when handling Certificate dialog.""; <line8> log.debug(message); <line9> throw new CDKServerException(message, ex); <line10> } catch (CoreLayerException exc) { <line11> String message = <line12> ""CoreLayerexception occured when handling Certificate dialog."" <line13> + ""Dialog has not been shown""; <line14> } <line15> } <line16> } <line17> "	<line4>, <line14>
6467	"public class A { <line0> @Override <line1> public String toModelFilename(String name) { <line2> if (!StringUtils.isEmpty(modelNamePrefix)) { <line3> name = modelNamePrefix + ""_"" + name; <line4> } <line5> if (!StringUtils.isEmpty(modelNameSuffix)) { <line6> name = name + ""_"" + modelNameSuffix; <line7> } <line8> name = sanitizeName(name); <line9> if (isReservedWord(name)) { <line10> name = ""model_"" + name; <line11> } <line12> return underscore(name); <line13> } <line14> } <line15> "	<line10>
6468	"public class A { <line0> @Override <line1> public LeapData onLeapData(LeapData data) { <line2> String side = getName().contains(""left"") ? ""left"" : ""right""; <line3> if (!data.frame.isValid()) { <line4> return data; <line5> } <line6> LeapHand h; <line7> if (""right"".equalsIgnoreCase(side)) { <line8> if (data.frame.hands().rightmost().isValid()) { <line9> h = data.rightHand; <line10> } else { <line11> return data; <line12> } <line13> } else if (""left"".equalsIgnoreCase(side)) { <line14> if (data.frame.hands().leftmost().isValid()) { <line15> h = data.leftHand; <line16> } else { <line17> return data; <line18> } <line19> } else { <line20> if (data.frame.hands().rightmost().isValid()) { <line21> h = data.rightHand; <line22> } else { <line23> return data; <line24> } <line25> } <line26> return data; <line27> } <line28> } <line29> "	<line4>, <line11>, <line17>, <line20>, <line23>
6469	"public class A { <line0> public void deletePath(final String path) { <line1> Objects.requireNonNull(path, ""Path cannot be null""); <line2> if (path.length() == 0) { <line3> throw new IllegalArgumentException(""Invalid path: "" + path); <line4> } <line5> final String[] pathComponents = split(path); <line6> writeLock.lock(); <line7> try { <line8> TrieNode parent = rootNode; <line9> for (final String part : pathComponents) { <line10> if (parent.getChild(part) == null) { <line11> return; <line12> } <line13> parent = parent.getChild(part); <line14> } <line15> final TrieNode realParent = parent.getParent(); <line16> realParent.deleteChild(parent.getValue()); <line17> } finally { <line18> writeLock.unlock(); <line19> } <line20> } <line21> } <line22> "	<line14>
6470	public class A { <line0> public void registerNewVersions(String artifactId, DeployedJar deployedJar) <line1> throws ClassNotFoundException { <line2> lock.lock(); <line3> try { <line4> if (deployedJar != null) { <line5> DeployedJar oldJar = this.deployedJars.put(artifactId, deployedJar); <line6> ClassPathLoader.getLatest().chainClassloader(deployedJar.getFile(), artifactId); <line7> } <line8> } finally { <line9> lock.unlock(); <line10> } <line11> } <line12> } <line13> 	<line5>
6471	public class A { <line0> private void validateFailInConfigWithExplicitTotalFlinkMem(Configuration customConfig) { <line1> Configuration config = configWithExplicitTotalFlinkMem(); <line2> config.addAll(customConfig); <line3> validateFail(config); <line4> } <line5> } <line6> 	<line1>
6472	"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON + "";charset=UTF-8"") <line2> @Path(""/@me/@all"") <line3> public Response<Resource> getAllPersonGroups(@PathParam(""said"") String said) { <line4> Data<Resource> data = null; <line5> try { <line6> Collection<PersonGroup> personGroups = personGroupManager.getAll(); <line7> data = new Data<Resource>(0, personGroups.size(), personGroups.size()); <line8> for (PersonGroup personGroup : personGroups) { <line9> data.getEntries().add(new Resource(personGroup, personGroupManager.getMe().asURI())); <line10> } <line11> } catch (InfosphereException e) { <line12> return Response.badRequest(e.getMessage(), e); <line13> } catch (Exception e) { <line14> return Response.serverError(e.getMessage(), e); <line15> } <line16> return Response.ok(data); <line17> } <line18> } <line19> "	<line4>
6473	public class A { <line0> @Override <line1> public void jobFailedNotification(String scriptId, JobStats stats) { <line2> if (stats.getJobId() == null) { <line3> return; <line4> } <line5> DAGNode<PigJob> node = dagNodeJobIdMap.get(stats.getJobId()); <line6> if (node == null) { <line7> return; <line8> } <line9> mapReduceHelper.addMapReduceJobState(node.getJob(), pigConfig.getJobClient()); <line10> addCompletedJobStats(node.getJob(), stats); <line11> AmbroseUtils.pushEvent(statsWriteService, scriptId, new Event.JobFailedEvent(node)); <line12> } <line13> } <line14> 	<line2>, <line3>, <line7>
6474	"public class A { <line0> @ApiOperation(value = ""Returns current variable values of a specified process instance."") <line1> @ApiResponses( <line2> value = { <line3> @ApiResponse(code = 500, message = ""Unexpected error""), <line4> @ApiResponse( <line5> code = 200, <line6> response = VariableInstanceList.class, <line7> message = ""Successful response"", <line8> examples = <line9> @Example( <line10> value = { <line11> @ExampleProperty( <line12> mediaType = JSON, <line13> value = GET_PROCESS_INSTANCE_VARS_LOG_RESPONSE_JSON) <line14> })) <line15> }) <line16> @GET <line17> @Path(VAR_INSTANCES_BY_INSTANCE_ID_GET_URI) <line18> @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line19> public Response getVariablesCurrentState( <line20> @Context HttpHeaders headers, <line21> @ApiParam( <line22> value = ""process instance id to load variables current state (latest value) for"", <line23> required = true) <line24> @PathParam(PROCESS_INST_ID) <line25> long processInstanceId) { <line26> Header conversationIdHeader = buildConversationIdHeader("""", context, headers); <line27> VariableInstanceList variableInstanceList = <line28> runtimeDataServiceBase.getVariablesCurrentState(processInstanceId); <line29> return createCorrectVariant( <line30> variableInstanceList, headers, Response.Status.OK, conversationIdHeader); <line31> } <line32> } <line33> "	<line29>
6475	public class A { <line0> @Substitute <line1> public synchronized void register(Logger logger) { <line2> } <line3> } <line4> 	<line2>
6476	public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public SystemResponseDTO updateSystemDto( <line2> final long systemId, <line3> final String systemName, <line4> final String address, <line5> final int port, <line6> final String authenticationInfo) { <line7> return DTOConverter.convertSystemToSystemResponseDTO( <line8> updateSystem(systemId, systemName, address, port, authenticationInfo)); <line9> } <line10> } <line11> 	<line7>
6477	public class A { <line0> private void removeApplication(ApplicationId applicationId) throws Exception { <line1> try { <line2> applicationLifecycleService.removeApplication(applicationId); <line3> } catch (NotFoundException ex) { <line4> } <line5> } <line6> } <line7> 	<line4>
6478	public class A { <line0> @OnWebSocketConnect <line1> public void onConnect(Session session) { <line2> try { <line3> ByteBuffer buf = generateRequest(); <line4> session.getRemote().sendBytes(buf); <line5> } catch (IOException e) { <line6> connectionError(e); <line7> } <line8> } <line9> } <line10> 	<line3>
6479	public class A { <line0> @Override <line1> public DocumentModel next() { <line2> String csid = csidIterator.next(); <line3> try { <line4> return null; <line5> } catch (Exception e) { <line6> return null; <line7> } <line8> } <line9> } <line10> 	<line6>
6480	"public class A { <line0> @Override <line1> public void doFilter( <line2> ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) <line3> throws IOException, ServletException { <line4> var request = validateRequestType(servletRequest); <line5> var response = validateResponseType(servletResponse); <line6> var path = <line7> request.getContextPath() + (request.getPathInfo() == null ? """" : request.getPathInfo()); <line8> if (blacklisted(path)) { <line9> response.setStatus(Response.Status.FORBIDDEN.getStatusCode()); <line10> } else { <line11> chain.doFilter(servletRequest, servletResponse); <line12> } <line13> } <line14> } <line15> "	<line9>
6481	public class A { <line0> private <V> void taskActivated(ProgressManager<V> progressManager) { <line1> currentTask.set(progressManager); <line2> taskActivatedHandlers.forEach( <line3> handler -> { <line4> try { <line5> handler.taskActivated(progressManager.getFuture()); <line6> } catch (Exception e) { <line7> } <line8> }); <line9> } <line10> } <line11> 	<line7>
6482	"public class A { <line0> @Override <line1> public boolean validateReference( <line2> PortletDataContext portletDataContext, Element referenceElement) { <line3> validateMissingGroupReference(portletDataContext, referenceElement); <line4> String uuid = referenceElement.attributeValue(""uuid""); <line5> Map<Long, Long> groupIds = <line6> (Map<Long, Long>) portletDataContext.getNewPrimaryKeysMap(Group.class); <line7> long groupId = GetterUtil.getLong(referenceElement.attributeValue(""group-id"")); <line8> groupId = MapUtil.getLong(groupIds, groupId); <line9> try { <line10> return validateMissingReference(uuid, groupId); <line11> } catch (Exception exception) { <line12> if (_log.isDebugEnabled()) { <line13> } <line14> return false; <line15> } <line16> } <line17> } <line18> "	<line13>
6483	public class A { <line0> void removeSingleInventory(DruidServer container, SegmentId segmentId) { <line1> if (!doRemoveSingleInventory(container, segmentId)) { <line2> } <line3> } <line4> } <line5> 	<line1>, <line2>
6484	"public class A { <line0> private static void extractParamsFromJSON(UIRequest request, JSONObject payloadOut) <line1> throws Exception { <line2> JSONObject payloadIn = null; <line3> try { <line4> payloadIn = request.getJSONBody(); <line5> } catch (UIException e) { <line6> } <line7> if (payloadIn != null) { <line8> JSONObject fields = payloadIn.optJSONObject(""fields""); <line9> setPayloadField(""mode"", payloadOut, fields, payloadIn, ""single""); <line10> setPayloadField(""docType"", payloadOut, fields, payloadIn); <line11> String exceptionMsg = null; <line12> if (payloadOut.getString(""mode"").equals(""single"")) { <line13> if (setPayloadField(""singleCSID"", payloadOut, fields, payloadIn) == false) { <line14> if (fields != null && fields.getString(""csid"").trim().isEmpty() == false) { <line15> payloadOut.put(""singleCSID"", fields.getString(""csid"")); <line16> } else { <line17> exceptionMsg = <line18> String.format( <line19> ""Report invocation context specified '%s' mode but did not provide a '%s'"" <line20> + "" param."", <line21> ""single"", ""singleCSID""); <line22> } <line23> } <line24> } else if (payloadOut.getString(""mode"").equals(""group"")) { <line25> if (setPayloadField(""groupCSID"", payloadOut, fields, payloadIn) == false) { <line26> if (fields != null && fields.getString(""csid"").trim().isEmpty() == false) { <line27> payloadOut.put(""groupCSID"", fields.getString(""csid"")); <line28> } else { <line29> exceptionMsg = <line30> String.format( <line31> ""Report invocation context specified '%s' mode but did not provide a '%s'"" <line32> + "" param."", <line33> ""group"", ""groupCSID""); <line34> } <line35> } <line36> } else { <line37> exceptionMsg = <line38> String.format( <line39> ""The Report invocation mode '%s' is unknown."", payloadOut.getString(""mode"")); <line40> } <line41> if (exceptionMsg != null) { <line42> throw new UIException(exceptionMsg); <line43> } <line44> } <line45> } <line46> } <line47> "	<line6>
6485	public class A { <line0> public static boolean equivalent(Text t1, Text t2) { <line1> String v1 = t1.getValue(); <line2> String v2 = t2.getValue(); <line3> boolean equals = v1.equals(v2); <line4> if (!equals && LOGGER.isDebugEnabled()) { <line5> } <line6> return equals; <line7> } <line8> } <line9> 	<line5>
6486	public class A { <line0> private List<NavigationPosition> filterSelectedPositions( <line1> List<NavigationPosition> positions, int[] selectedIndices) { <line2> long start = currentTimeMillis(); <line3> List<NavigationPosition> result = new ArrayList<>(); <line4> for (int selectedIndex : selectedIndices) { <line5> if (selectedIndex >= positions.size()) continue; <line6> result.add(positions.get(selectedIndex)); <line7> } <line8> long end = currentTimeMillis(); <line9> if (positions.size() != result.size()) <line10> return result; <line11> } <line12> } <line13> 	<line10>
6487	public class A { <line0> @Override <line1> public void finishJob(JobResult result, Class<?> batch, List<Session> sessions) { <line2> super.finishJob(result, batch, sessions); <line3> for (Session session : sessions) { <line4> if (!super.isAdmin(session)) { <line5> return; <line6> } <line7> try { <line8> session.close(); <line9> } catch (IOException e) { <line10> } <line11> } <line12> } <line13> } <line14> 	<line10>
6488	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void start() throws Exception { <line3> try { <line4> ClientPoolManager<CLIENT_POOL> clientMgr = <line5> (ClientPoolManager<CLIENT_POOL>) config().getValue(CLIENT_MGR); <line6> clientMgr.createClientPool(context); <line7> } catch (Throwable e) { <line8> throw e; <line9> } <line10> } <line11> } <line12> "	<line8>
6489	public class A { <line0> @Override <line1> public QueryExpression rewrite(QueryExpression q) { <line2> QueryExpression trc = q; <line3> QueryExpression newq; <line4> boolean done = false; <line5> do { <line6> newq = rewriteIteration(trc); <line7> if (newq == trc) { <line8> done = true; <line9> } <line10> trc = newq; <line11> } while (!done); <line12> return newq; <line13> } <line14> } <line15> 	<line7>
6490	"public class A { <line0> @Test <line1> public void testCompositeMultiOr() throws Exception { <line2> String state = ""'oregon'""; <line3> int one = 155; <line4> int two = 36; <line5> int three = 54; <line6> int four = 66; <line7> String query = <line8> GroupField.STATE_EAST.getQueryField() <line9> + EQ_OP <line10> + state <line11> + AND_OP <line12> + ""("" <line13> + GroupField.COUNT_EAST.getQueryField() <line14> + EQ_OP <line15> + one <line16> + OR_OP <line17> + GroupField.COUNT_EAST.getQueryField() <line18> + EQ_OP <line19> + two <line20> + OR_OP <line21> + GroupField.COUNT_EAST.getQueryField() <line22> + EQ_OP <line23> + three <line24> + OR_OP <line25> + GroupField.COUNT_EAST.getQueryField() <line26> + EQ_OP <line27> + four <line28> + "")""; <line29> runTest(query, query); <line30> } <line31> } <line32> "	<line2>
6491	public class A { <line0> public <T> DataGroupMember getDataMember( <line1> Node header, AsyncMethodCallback<T> resultHandler, Object request) { <line2> if (header == null) { <line3> if (resultHandler != null) { <line4> resultHandler.onError(new NoHeaderNodeException()); <line5> } <line6> return null; <line7> } <line8> DataGroupMember member = stoppedMemberManager.get(header); <line9> if (member != null) { <line10> return member; <line11> } <line12> Exception ex = null; <line13> synchronized (headerGroupMap) { <line14> member = headerGroupMap.get(header); <line15> if (member != null) { <line16> return member; <line17> } <line18> if (partitionTable != null) { <line19> try { <line20> member = createNewMember(header); <line21> } catch (NotInSameGroupException | CheckConsistencyException e) { <line22> ex = e; <line23> } <line24> } else { <line25> ex = new PartitionTableUnavailableException(thisNode); <line26> } <line27> if (ex != null && resultHandler != null) { <line28> resultHandler.onError(ex); <line29> } <line30> return member; <line31> } <line32> } <line33> } <line34> 	<line18>, <line25>
6492	public class A { <line0> @Override <line1> public void updateTriggerChannel(String event) { <line2> triggerChannel(CHANNEL_DOOR_WINDOW_TRIGGER_CHANNEL, event); <line3> } <line4> } <line5> 	<line2>
6493	public class A { <line0> private List<Element> parseElements(final ITemplateResource templateResource) { <line1> elements = new ArrayList<>(); <line2> try (Reader reader = templateResource.reader()) { <line3> final ParseConfiguration config = ParseConfiguration.htmlConfiguration(); <line4> final ParseConfiguration autoCloseConfig = ParseConfiguration.htmlConfiguration(); <line5> autoCloseConfig.setElementBalancing(ParseConfiguration.ElementBalancing.AUTO_OPEN_CLOSE); <line6> final MarkupParser htmlStandardParser = new MarkupParser(config); <line7> htmlStandardParser.parse(reader, this); <line8> } catch (IOException | ParseException e) { <line9> } <line10> return elements; <line11> } <line12> } <line13> 	<line9>
6494	"public class A { <line0> public static com.liferay.portal.kernel.model.Country getCountryByName( <line1> HttpPrincipal httpPrincipal, String name) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CountryServiceUtil.class, ""getCountryByName"", _getCountryByNameParameterTypes22); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, name); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (com.liferay.portal.kernel.model.Country) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>
6495	"public class A { <line0> @SuppressWarnings(""ConstantConditions"") <line1> @Override <line2> public void prepareRun(BatchSinkContext context) { <line3> Schema inputSchema = context.getInputSchema(); <line4> FailureCollector collector = context.getFailureCollector(); <line5> config.validate(inputSchema, collector); <line6> collector.getOrThrowException(); <line7> String project = config.getProject(); <line8> String serviceAccount = config.getServiceAccount(); <line9> String shouldAutoGenerateKey = Boolean.toString(config.shouldUseAutoGeneratedKey(collector)); <line10> String batchSize = Integer.toString(config.getBatchSize()); <line11> context.addOutput( <line12> Output.of( <line13> config.getReferenceName(), <line14> new DatastoreOutputFormatProvider( <line15> project, <line16> serviceAccount, <line17> config.isServiceAccountFilePath(), <line18> shouldAutoGenerateKey, <line19> batchSize))); <line20> LineageRecorder lineageRecorder = new LineageRecorder(context, config.getReferenceName()); <line21> lineageRecorder.createExternalDataset(inputSchema); <line22> lineageRecorder.recordWrite( <line23> ""Write"", <line24> ""Wrote to Cloud Datastore sink"", <line25> inputSchema.getFields().stream().map(Schema.Field::getName).collect(Collectors.toList())); <line26> } <line27> } <line28> "	<line4>
6496	public class A { <line0> @Override <line1> protected ConfigurationBuilder getDefaultHotRodConfig() { <line2> ConfigurationBuilder defaultHotRodConfig = super.getDefaultHotRodConfig(); <line3> if (marshaller != null) { <line4> defaultHotRodConfig.marshaller(marshaller); <line5> } <line6> return defaultHotRodConfig; <line7> } <line8> } <line9> 	<line5>
6497	public class A { <line0> @Override <line1> public void registerAlarmObservation( <line2> String dpid, String port, String threshold, IAlarmObserver alarmObserver) { <line3> AlarmInformation alarmInformation = <line4> new AlarmInformation(threshold, this.host, this.port, URL_WITH_RESOURCE); <line5> monitoringModuleAlarmHandler.addAlarmObserver(dpid, Integer.valueOf(port), alarmObserver); <line6> monitoringClient.registerAlarm(dpid, port, alarmInformation); <line7> } <line8> } <line9> 	<line3>, <line7>
6498	"public class A { <line0> @VisibleForTesting <line1> protected void setSystemAccessControl(String name, Map<String, String> properties) { <line2> requireNonNull(name, ""name is null""); <line3> requireNonNull(properties, ""properties is null""); <line4> checkState( <line5> systemAccessControlLoading.compareAndSet(false, true), <line6> ""System access control already initialized""); <line7> SystemAccessControlFactory systemAccessControlFactory = systemAccessControlFactories.get(name); <line8> checkState(systemAccessControlFactory != null, ""Access control %s is not registered"", name); <line9> SystemAccessControl systemAccessControl = <line10> systemAccessControlFactory.create(ImmutableMap.copyOf(properties)); <line11> this.systemAccessControl.set(systemAccessControl); <line12> } <line13> } <line14> "	<line7>, <line12>
6499	"public class A { <line0> void finishJob(Job job) { <line1> if (bundleLog != null) { <line2> try { <line3> Bundle bundle = initBundle(EventType.JOB_FINISH); <line4> BundleFormat format = bundleLog.getFormat(); <line5> bundleSetValue(bundle, ""JOB_ID"", job.getId()); <line6> bundleSetValue(bundle, ""JOB_STATE"", job.getState().toString()); <line7> bundleSetValue(bundle, ""JOB_WAS_STOPPED"", job.getWasStopped()); <line8> Long start = job.getStartTime(); <line9> Long end = job.getEndTime(); <line10> if (start != null) { <line11> bundleSetValue(bundle, ""JOB_START_TIME"", start); <line12> } <line13> if (end != null) { <line14> bundleSetValue(bundle, ""JOB_END_TIME"", end); <line15> } <line16> if (start != null && end != null) { <line17> bundleSetValue(bundle, ""JOB_ELAPSED_TIME"", end - start); <line18> } <line19> int taskCount = job.getTaskCount(); <line20> bundleSetValue(bundle, ""JOB_TASK_COUNT"", taskCount); <line21> ValueArray taskMeanRates = ValueFactory.createArray(taskCount); <line22> for (int i = 0; i < taskCount; i++) { <line23> JobTask task = job.getTask(i); <line24> taskMeanRates.add(ValueFactory.create(task.getMeanRate())); <line25> } <line26> bundle.setValue(format.getField(""TASK_AVG_RATES""), taskMeanRates); <line27> bundleLog.send(bundle); <line28> } catch (Exception ex) { <line29> } <line30> } <line31> } <line32> } <line33> "	<line29>
6500	public class A { <line0> public RESPONSE processRequest( <line1> REQUEST request, <line2> FunctionWithServiceException<REQUEST, RESPONSE> methodCall, <line3> TYPE type, <line4> String traceId) <line5> throws ServiceException { <line6> Span span = TracingUtil.importAndCreateSpan(type.toString(), traceId); <line7> try { <line8> if (logger.isTraceEnabled()) { <line9> } else if (logger.isDebugEnabled()) { <line10> } <line11> long startTime = System.currentTimeMillis(); <line12> RESPONSE response = methodCall.apply(request); <line13> protocolMessageMetrics.increment(type, System.currentTimeMillis() - startTime); <line14> if (logger.isTraceEnabled()) { <line15> } <line16> return response; <line17> } finally { <line18> span.finish(); <line19> } <line20> } <line21> } <line22> 	<line9>, <line10>, <line15>
6501	public class A { <line0> private TextFileSource importSource(Resource config, ArchiveFile af) <line1> throws ImportException, InvalidFilenameException { <line2> File extFile = af.getLocationFile(); <line3> TextFileSource s = (TextFileSource) sourceManager.add(config, extFile, af.getLocation()); <line4> SourceManagerImpl.copyArchiveFileProperties(af, s); <line5> if (s.getIgnoreHeaderLines() != 1) { <line6> } <line7> s.setRows(s.getRows() + 1 - s.getIgnoreHeaderLines()); <line8> return s; <line9> } <line10> } <line11> 	<line6>
6502	public class A { <line0> public Duration getLargestIntegerUnitType(Duration input) { <line1> Duration largest = null; <line2> for (Class<? extends Duration> type : getAvailableUnits(false)) { <line3> try { <line4> Duration dur = Duration.create(type, input); <line5> BigDecimal durMag = dur.getMagnitude(); <line6> if (durMag.stripTrailingZeros().scale() <= 0 <line7> && (largest == null || largest.getMagnitude().compareTo(durMag) > 0)) { <line8> largest = dur; <line9> } <line10> } catch (InvalidUnitsException e) { <line11> if (LOGGER.isTraceEnabled()) { <line12> } <line13> } catch (InconvertibleUnits e) { <line14> if (LOGGER.isTraceEnabled()) { <line15> } <line16> } <line17> } <line18> return largest; <line19> } <line20> } <line21> 	<line12>, <line15>
6503	public class A { <line0> public void destroy() { <line1> ElementsThreadLocals.destroy(); <line2> } <line3> } <line4> 	<line2>
6504	public class A { <line0> @Override <line1> public void onSuccess(final EffectiveModelContext result) { <line2> final Collection<QName> filteredQNames = <line3> Sets.difference( <line4> deviceSources.getRequiredSourcesQName(), <line5> capabilities.getUnresolvedCapabilites().keySet()); <line6> capabilities.addCapabilities( <line7> filteredQNames.stream() <line8> .map( <line9> entry -> <line10> new AvailableCapabilityBuilder() <line11> .setCapability(entry.toString()) <line12> .setCapabilityOrigin( <line13> remoteSessionCapabilities.getModuleBasedCapsOrigin().get(entry)) <line14> .build()) <line15> .collect(Collectors.toList())); <line16> capabilities.addNonModuleBasedCapabilities( <line17> remoteSessionCapabilities.getNonModuleCaps().stream() <line18> .map( <line19> entry -> <line20> new AvailableCapabilityBuilder() <line21> .setCapability(entry) <line22> .setCapabilityOrigin( <line23> remoteSessionCapabilities.getNonModuleBasedCapsOrigin().get(entry)) <line24> .build()) <line25> .collect(Collectors.toList())); <line26> resultFuture.set(result); <line27> } <line28> } <line29> 	<line2>
6505	public class A { <line0> private boolean tryPublish(byte[] bytes) { <line1> try { <line2> resilientChannel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, NO_PROPERTIES, bytes); <line3> return true; <line4> } catch (Exception e) { <line5> return false; <line6> } <line7> } <line8> } <line9> 	<line5>
6506	public class A { <line0> private void asyncProcessLevelNodes( <line1> final String path, <line2> final Processor<String> processor, <line3> final AsyncCallback.VoidCallback finalCb, <line4> final Object context, <line5> final int successRc, <line6> final int failureRc) { <line7> zk.sync( <line8> path, <line9> new AsyncCallback.VoidCallback() { <line10> @Override <line11> public void processResult(int rc, String path, Object ctx) { <line12> if (rc != Code.OK.intValue()) { <line13> finalCb.processResult(failureRc, null, context); <line14> return; <line15> } <line16> zk.getChildren( <line17> path, <line18> false, <line19> new AsyncCallback.ChildrenCallback() { <line20> @Override <line21> public void processResult( <line22> int rc, String path, Object ctx, List<String> levelNodes) { <line23> if (rc != Code.OK.intValue()) { <line24> finalCb.processResult(failureRc, null, context); <line25> return; <line26> } <line27> AsyncListProcessor<String> listProcessor = <line28> new AsyncListProcessor<String>(scheduler); <line29> listProcessor.process( <line30> levelNodes, processor, finalCb, context, successRc, failureRc); <line31> } <line32> }, <line33> null); <line34> } <line35> }, <line36> null); <line37> } <line38> } <line39> 	<line13>, <line24>
6507	"public class A { <line0> @Override <line1> public void execute() throws ResourceUnavailableException { <line2> try { <line3> boolean result = <line4> _rulesService.enableStaticNat( <line5> ipAddressId, virtualMachineId, getNetworkId(), getVmSecondaryIp()); <line6> if (result) { <line7> SuccessResponse response = new SuccessResponse(getCommandName()); <line8> this.setResponseObject(response); <line9> } else { <line10> throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to enable static NAT""); <line11> } <line12> } catch (NetworkRuleConflictException ex) { <line13> throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, ex.getMessage()); <line14> } <line15> } <line16> } <line17> "	<line13>
6508	"public class A { <line0> @Override <line1> public SecurityGroupInZone apply(ZoneSecurityGroupNameAndPorts zoneSecurityGroupNameAndPorts) { <line2> checkNotNull(zoneSecurityGroupNameAndPorts, ""zoneSecurityGroupNameAndPorts""); <line3> String zoneId = zoneSecurityGroupNameAndPorts.getZone(); <line4> Optional<? extends SecurityGroupApi> api = novaApi.getSecurityGroupExtensionForZone(zoneId); <line5> checkArgument( <line6> api.isPresent(), <line7> ""Security groups are required, but the extension is not availablein zone %s!"", <line8> zoneId); <line9> try { <line10> SecurityGroup securityGroup = <line11> api.get() <line12> .createWithDescription( <line13> zoneSecurityGroupNameAndPorts.getName(), zoneSecurityGroupNameAndPorts.getName()); <line14> for (int port : zoneSecurityGroupNameAndPorts.getPorts()) { <line15> authorizeGroupToItselfAndAllIPsToTCPPort(api.get(), securityGroup, port); <line16> } <line17> return new SecurityGroupInZone(api.get().get(securityGroup.getId()), zoneId); <line18> } catch (IllegalStateException e) { <line19> SecurityGroup group = <line20> find(api.get().list(), nameEquals(zoneSecurityGroupNameAndPorts.getName())); <line21> return new SecurityGroupInZone(group, zoneId); <line22> } <line23> } <line24> } <line25> "	<line9>, <line14>, <line19>, <line21>
6509	"public class A { <line0> @AfterTest <line1> public void cleanUp() throws IOException, TimeoutException { <line2> try { <line3> WebHookMessagePublisher.getInstance().purgeQueue(""IPW_WebhookTest""); <line4> WebHookMessagePublisher.getInstance().releaseMqConnetion(); <line5> Assert.assertTrue(Boolean.TRUE); <line6> } catch (AssertionError e) { <line7> } <line8> } <line9> } <line10> "	<line7>
6510	"public class A { <line0> @VisibleForTesting <line1> public void processAll(long timeout) { <line2> long currentTime = Time.now(); <line3> while (true) { <line4> if (!isRunning) { <line5> return; <line6> } <line7> long processed = 0; <line8> Stream<EventExecutor> allExecutor = <line9> this.executors.values().stream().flatMap(handlerMap -> handlerMap.keySet().stream()); <line10> boolean allIdle = <line11> allExecutor.allMatch( <line12> executor -> <line13> executor.queuedEvents() == executor.successfulEvents() + executor.failedEvents()); <line14> if (allIdle) { <line15> return; <line16> } <line17> try { <line18> Thread.sleep(100); <line19> } catch (InterruptedException e) { <line20> Thread.currentThread().interrupt(); <line21> } <line22> if (Time.now() > currentTime + timeout) { <line23> throw new AssertionError( <line24> ""Messages are not processed in the given timeframe. Queued: "" <line25> + queuedCount.get() <line26> + "" Processed: "" <line27> + processed); <line28> } <line29> } <line30> } <line31> } <line32> "	<line5>, <line20>
6511	public class A { <line0> public void addPlayer(final User user) throws TooManyPlayersException, IllegalStateException { <line1> synchronized (players) { <line2> if (options.playerLimit >= 3 && players.size() >= options.playerLimit) { <line3> throw new TooManyPlayersException(); <line4> } <line5> user.joinGame(this); <line6> final Player player = new Player(user); <line7> players.add(player); <line8> if (host == null) { <line9> host = player; <line10> } <line11> } <line12> final HashMap<ReturnableData, Object> data = getEventMap(); <line13> data.put(LongPollResponse.EVENT, LongPollEvent.GAME_PLAYER_JOIN.toString()); <line14> data.put(LongPollResponse.NICKNAME, user.getNickname()); <line15> broadcastToPlayers(MessageType.GAME_PLAYER_EVENT, data); <line16> } <line17> } <line18> 	<line1>
6512	"public class A { <line0> @Override <line1> public void run() { <line2> if (needToRollover()) { <line3> writeLock.lock(); <line4> try { <line5> if (needToRollover()) { <line6> try { <line7> rollover(false); <line8> } catch (final Exception e) { <line9> eventReporter.reportEvent( <line10> Severity.ERROR, <line11> EVENT_CATEGORY, <line12> ""Failed to roll over Provenance Event Log due to "" + e.toString()); <line13> } <line14> } <line15> } finally { <line16> writeLock.unlock(); <line17> } <line18> } <line19> } <line20> } <line21> "	<line5>, <line9>
6513	"public class A { <line0> private Set<String> mapRoles( <line1> Caller caller, Set<String> currentRoles, Set<String> runAsRoles, boolean sanitized) { <line2> Set<String> result = currentRoles; <line3> if (runAsRoles != null) { <line4> Set<String> roleSet = new HashSet<String>(); <line5> for (String role : runAsRoles) { <line6> String requestedRole = sanitized ? role : getRoleFromText(role); <line7> if (realRoleMapper.canRunAs(currentRoles, requestedRole)) { <line8> roleSet.add(requestedRole); <line9> } <line10> } <line11> if (roleSet.isEmpty() == false) { <line12> result = Collections.unmodifiableSet(roleSet); <line13> if (ACCESS_LOGGER.isTraceEnabled()) { <line14> StringBuilder sb = <line15> new StringBuilder(""User '"") <line16> .append(caller.getName()) <line17> .append(""' Mapped to requested roles { ""); <line18> for (String current : result) { <line19> sb.append(""'"").append(current).append(""' ""); <line20> } <line21> sb.append(""}""); <line22> } <line23> } <line24> } <line25> return result; <line26> } <line27> } <line28> "	<line22>
6514	"public class A { <line0> public ActionForward delete( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> LoggedInInfo loggedInInfo = LoggedInInfo.getLoggedInInfoFromSession(request); <line6> String[] checks = request.getParameterValues(""checkbox""); <line7> for (int x = 0; x < checks.length; x++) { <line8> ticklerManager.deleteTickler( <line9> loggedInInfo, Integer.parseInt(checks[x]), getProviderNo(request)); <line10> } <line11> return filter(mapping, form, request, response); <line12> } <line13> } <line14> "	<line5>
6515	"public class A { <line0> @BeforeMethod <line1> public void setUp() throws Exception { <line2> basePath = TestsHelper.createBaseTempDir(getClass(), true); <line3> boolean deploySolr = true; <line4> boolean deployLdap = true; <line5> boolean deployFolderMonitor = true; <line6> boolean deployOrchestrator = true; <line7> boolean deployPluginManager = true; <line8> boolean deployDefaultResources = false; <line9> RodaCoreFactory.instantiateTest( <line10> deploySolr, <line11> deployLdap, <line12> deployFolderMonitor, <line13> deployOrchestrator, <line14> deployPluginManager, <line15> deployDefaultResources, <line16> false); <line17> model = RodaCoreFactory.getModelService(); <line18> index = RodaCoreFactory.getIndexService(); <line19> URL corporaURL = BagitSIPPluginsTest.class.getResource(""/corpora""); <line20> corporaPath = Paths.get(corporaURL.toURI()); <line21> } <line22> } <line23> "	<line21>
6516	public class A { <line0> @Override <line1> public void handlePacket(Packet packet) { <line2> if (!isStarted()) { <line3> if (channelHandler != null) { <line4> channelHandler.handlePacket(packet); <line5> } <line6> return; <line7> } <line8> if (!authorized) { <line9> if (packet.getType() == PacketImpl.CLUSTER_CONNECT) { <line10> ClusterConnection clusterConnection = acceptorUsed.getClusterConnection(); <line11> if (clusterConnection == null) { <line12> clusterConnection = server.getClusterManager().getDefaultConnection(null); <line13> } <line14> if (clusterConnection == null && server.getConfiguration().isSecurityEnabled()) { <line15> ActiveMQServerLogger.LOGGER.failedToFindClusterConnection(packet.toString()); <line16> return; <line17> } <line18> ClusterConnectMessage msg = (ClusterConnectMessage) packet; <line19> if (server.getConfiguration().isSecurityEnabled() <line20> && !clusterConnection.verify(msg.getClusterUser(), msg.getClusterPassword())) { <line21> clusterChannel.send(new ClusterConnectReplyMessage(false)); <line22> } else { <line23> authorized = true; <line24> clusterChannel.send(new ClusterConnectReplyMessage(true)); <line25> } <line26> } <line27> } else { <line28> if (packet.getType() == PacketImpl.NODE_ANNOUNCE) { <line29> NodeAnnounceMessage msg = (NodeAnnounceMessage) packet; <line30> Pair<TransportConfiguration, TransportConfiguration> pair; <line31> if (msg.isBackup()) { <line32> pair = new Pair<>(null, msg.getConnector()); <line33> } else { <line34> pair = new Pair<>(msg.getConnector(), msg.getBackupConnector()); <line35> } <line36> if (logger.isTraceEnabled()) { <line37> } <line38> if (acceptorUsed != null) { <line39> ClusterConnection clusterConn = acceptorUsed.getClusterConnection(); <line40> if (clusterConn != null) { <line41> String scaleDownGroupName = msg.getScaleDownGroupName(); <line42> clusterConn.nodeAnnounced( <line43> msg.getCurrentEventID(), <line44> msg.getNodeID(), <line45> msg.getBackupGroupName(), <line46> scaleDownGroupName, <line47> pair, <line48> msg.isBackup()); <line49> } else { <line50> } <line51> } else { <line52> } <line53> } else if (packet.getType() == PacketImpl.QUORUM_VOTE) { <line54> quorumManager.handleQuorumVote(clusterChannel, packet); <line55> } else if (packet.getType() == PacketImpl.SCALEDOWN_ANNOUNCEMENT) { <line56> ScaleDownAnnounceMessage message = (ScaleDownAnnounceMessage) packet; <line57> if (server.getNodeID().equals(message.getTargetNodeId())) { <line58> server.addScaledDownNode(message.getScaledDownNodeId()); <line59> } <line60> } else if (channelHandler != null) { <line61> channelHandler.handlePacket(packet); <line62> } <line63> } <line64> } <line65> } <line66> 	<line37>, <line50>, <line52>
6517	"public class A { <line0> public static KeyManagerFactory createKeyManagerFactory(String keyStoreLoc, String keyStorePass) <line1> throws IOException { <line2> KeyManagerFactory kmf; <line3> try { <line4> KeyStore keyStore = KeyStore.getInstance(System.getProperty(""javax.net.ssl.keyStoreType"")); <line5> try (FileInputStream keyFIS = new FileInputStream(keyStoreLoc)) { <line6> keyStore.load(keyFIS, keyStorePass.toCharArray()); <line7> } catch (CertificateException e) { <line8> throw new IOException(""Unable to load certificates from keystore. "" + keyStoreLoc, e); <line9> } <line10> kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); <line11> kmf.init(keyStore, keyStorePass.toCharArray()); <line12> } catch (NoSuchAlgorithmException e) { <line13> throw new IOException( <line14> ""Problems creating SSL socket. Usually this is "" <line15> + ""referring to the certificate sent by the server not being trusted by the client."", <line16> e); <line17> } catch (UnrecoverableKeyException e) { <line18> throw new IOException(""Unable to load keystore. "" + keyStoreLoc, e); <line19> } catch (KeyStoreException e) { <line20> throw new IOException(""Unable to read keystore. "" + keyStoreLoc, e); <line21> } <line22> return kmf; <line23> } <line24> } <line25> "	<line5>, <line6>, <line12>
6518	public class A { <line0> @Override <line1> public List<Exchange> getExchanges() { <line2> final List<Exchange> answer = new ArrayList<>(); <line3> GenericFileConsumer<?> consumer = null; <line4> try { <line5> consumer = createConsumer(null); <line6> consumer.setCustomProcessor( <line7> new Processor() { <line8> @Override <line9> public void process(Exchange exchange) throws Exception { <line10> answer.add(exchange); <line11> } <line12> }); <line13> consumer.setStartScheduler(false); <line14> ServiceHelper.startService(consumer); <line15> consumer.poll(); <line16> } catch (Exception e) { <line17> throw RuntimeCamelException.wrapRuntimeCamelException(e); <line18> } finally { <line19> try { <line20> ServiceHelper.stopService(consumer); <line21> } catch (Exception e) { <line22> } <line23> } <line24> return answer; <line25> } <line26> } <line27> 	<line22>
6519	public class A { <line0> @Override <line1> public Future<KafkaTopic> createResource(KafkaTopic topicResource) { <line2> Promise<KafkaTopic> handler = Promise.promise(); <line3> vertx.executeBlocking( <line4> future -> { <line5> try { <line6> KafkaTopic kafkaTopic = operation().inNamespace(namespace).create(topicResource); <line7> future.complete(kafkaTopic); <line8> } catch (Exception e) { <line9> future.fail(e); <line10> } <line11> }, <line12> handler); <line13> return handler.future(); <line14> } <line15> } <line16> 	<line7>
6520	public class A { <line0> @Override <line1> public void onBeginRequest(RequestCycle cycle) { <line2> if (log.isDebugEnabled()) { <line3> HttpServletRequest containerRequest = <line4> (HttpServletRequest) cycle.getRequest().getContainerRequest(); <line5> } <line6> } <line7> } <line8> 	<line5>
6521	public class A { <line0> @Override <line1> public CommerceInventoryWarehouseItem remove(Serializable primaryKey) <line2> throws NoSuchInventoryWarehouseItemException { <line3> Session session = null; <line4> try { <line5> session = openSession(); <line6> CommerceInventoryWarehouseItem commerceInventoryWarehouseItem = <line7> (CommerceInventoryWarehouseItem) <line8> session.get(CommerceInventoryWarehouseItemImpl.class, primaryKey); <line9> if (commerceInventoryWarehouseItem == null) { <line10> if (_log.isDebugEnabled()) { <line11> } <line12> throw new NoSuchInventoryWarehouseItemException( <line13> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line14> } <line15> return remove(commerceInventoryWarehouseItem); <line16> } catch (NoSuchInventoryWarehouseItemException noSuchEntityException) { <line17> throw noSuchEntityException; <line18> } catch (Exception exception) { <line19> throw processException(exception); <line20> } finally { <line21> closeSession(session); <line22> } <line23> } <line24> } <line25> 	<line11>
6522	"public class A { <line0> @Override <line1> public List<Action> getAll() { <line2> List<Action> actions = new ArrayList<>(); <line3> String query = ""select * from "" + getMetadataRepository().getTableNameByLabel(""Actions""); <line4> CachedRowSet crs = getMetadataRepository().executeQuery(query, ""reader""); <line5> try { <line6> while (crs.next()) { <line7> ActionKey actionKey = <line8> new ActionKey( <line9> new ScriptKey(crs.getString(""SCRIPT_ID""), crs.getLong(""SCRIPT_VRS_NB"")), <line10> crs.getString(""ACTION_ID"")); <line11> List<ActionParameter> actionParameters = <line12> ActionParameterConfiguration.getInstance().getByAction(actionKey); <line13> actions.add( <line14> new Action( <line15> actionKey, <line16> crs.getLong(""ACTION_NB""), <line17> crs.getString(""ACTION_TYP_NM""), <line18> crs.getString(""ACTION_NM""), <line19> crs.getString(""ACTION_DSC""), <line20> crs.getString(""COMP_NM""), <line21> crs.getString(""CONDITION_VAL""), <line22> crs.getString(""ITERATION_VAL""), <line23> crs.getString(""EXP_ERR_FL""), <line24> crs.getString(""STOP_ERR_FL""), <line25> crs.getString(""RETRIES_VAL""), <line26> actionParameters)); <line27> } <line28> crs.close(); <line29> } catch (SQLException e) { <line30> StringWriter stackTrace = new StringWriter(); <line31> e.printStackTrace(new PrintWriter(stackTrace)); <line32> } <line33> return actions; <line34> } <line35> } <line36> "	<line32>
6523	public class A { <line0> @Override <line1> public void run() { <line2> CrowdManager manager = null; <line3> try { <line4> manager = CrowdManager.getInstance(); <line5> } catch (Exception e) { <line6> return; <line7> } <line8> List<String> allGroups = null; <line9> try { <line10> allGroups = manager.getAllGroupNames(); <line11> } catch (RemoteException re) { <line12> return; <line13> } <line14> if (allGroups != null && allGroups.size() > 0) { <line15> CrowdGroupProvider.lock.writeLock().lock(); <line16> try { <line17> CrowdGroupProvider.groups = allGroups; <line18> } finally { <line19> CrowdGroupProvider.lock.writeLock().unlock(); <line20> } <line21> } <line22> } <line23> } <line24> 	<line2>, <line6>, <line12>, <line22>
6524	"public class A { <line0> private void initConfiguration(String versionHome) throws JsonProcessingException { <line1> String metadataConfHome = versionHome + File.separator + ""metadata"" + File.separator + ""conf""; <line2> } <line3> } <line4> "	<line1>
6525	"public class A { <line0> @Override <line1> public VirtualHost findByC_L_D(long companyId, long layoutSetId, boolean defaultVirtualHost) <line2> throws NoSuchVirtualHostException { <line3> VirtualHost virtualHost = fetchByC_L_D(companyId, layoutSetId, defaultVirtualHost); <line4> if (virtualHost == null) { <line5> StringBundler sb = new StringBundler(8); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""companyId=""); <line8> sb.append(companyId); <line9> sb.append("", layoutSetId=""); <line10> sb.append(layoutSetId); <line11> sb.append("", defaultVirtualHost=""); <line12> sb.append(defaultVirtualHost); <line13> sb.append(""}""); <line14> if (_log.isDebugEnabled()) { <line15> } <line16> throw new NoSuchVirtualHostException(sb.toString()); <line17> } <line18> return virtualHost; <line19> } <line20> } <line21> "	<line15>
6526	"public class A { <line0> @Path(""/getWrongIdShouldThrow"") <line1> @POST <line2> public void getWrongIdShouldThrow() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.GET); <line4> try { <line5> template.requestBodyAndHeader( <line6> uri, null, OpenstackConstants.ID, SERVER_WRONG_ID, Server.class); <line7> fail(""Getting nova server with wrong id should throw""); <line8> } catch (Exception ex) { <line9> assertTrue(ex instanceof CamelExecutionException); <line10> assertTrue(((CamelExecutionException) ex).getCause() instanceof ServerResponseException); <line11> } <line12> } <line13> } <line14> "	<line3>
6527	"public class A { <line0> @Override <line1> public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) { <line2> try { <line3> return process0(annotations, roundEnv); <line4> } catch (IOException e) { <line5> logger.log(Level.SEVERE, ""Failed to processs annotated sources."", e); <line6> } <line7> return false; <line8> } <line9> } <line10> "	<line2>
6528	"public class A { <line0> private Set<String> getTrashRemovedResourcesId( <line1> List<String> resourceIds, List<String> archivedResources) { <line2> Set<String> trashRemovedResources = null; <line3> Iterator<String> it = resourceIds.iterator(); <line4> String id = null; <line5> while (it.hasNext()) { <line6> id = (String) it.next(); <line7> ResourceInterface resourceInterfaceArchived = null; <line8> ResourceInterface resourceInterfaceTrashed = null; <line9> try { <line10> resourceInterfaceTrashed = this.getTrashedResourceManager().loadTrashedResource(id); <line11> resourceInterfaceArchived = this.getResourceManager().loadResource(id); <line12> if (!(null != resourceInterfaceArchived || null != resourceInterfaceTrashed)) { <line13> if (null == trashRemovedResources) { <line14> trashRemovedResources = new HashSet<String>(); <line15> } <line16> trashRemovedResources.add(id); <line17> } <line18> } catch (Throwable t) { <line19> throw new RuntimeException(""Error checking resource permanently removed, id "" + id, t); <line20> } <line21> } <line22> return trashRemovedResources; <line23> } <line24> } <line25> "	<line19>
6529	"public class A { <line0> @Override <line1> public void setThingOffline(ThingStatusDetail detail, String messageKey) { <line2> if (!isThingOffline()) { <line3> updateStatus(ThingStatus.OFFLINE, detail, ""@text/"" + messageKey); <line4> watchdog = 0; <line5> channelsCreated = false; <line6> } <line7> } <line8> } <line9> "	<line3>
6530	public class A { <line0> @Override <line1> public void notifyElementExpired(Ehcache cache, Element element) { <line2> _cache.remove(element.getKey()); <line3> } <line4> } <line5> 	<line3>
6531	"public class A { <line0> @Override <line1> public void sendWelcomeEmail(User user, User sender, PasswordReset passwordReset) <line2> throws MailSendException { <line3> Locale locale = LocaleContextHolder.getLocale(); <line4> final Context ctx = new Context(locale); <line5> ctx.setVariable(""ngsEmail"", serverEmail); <line6> ctx.setVariable(""serverURL"", serverURL); <line7> ctx.setVariable(""creator"", sender); <line8> ctx.setVariable(""user"", user); <line9> ctx.setVariable(""passwordReset"", passwordReset); <line10> try { <line11> final MimeMessage mimeMessage = this.javaMailSender.createMimeMessage(); <line12> final MimeMessageHelper message = new MimeMessageHelper(mimeMessage, ""UTF-8""); <line13> message.setSubject(messageSource.getMessage(""email.welcome.subject"", null, locale)); <line14> message.setFrom(serverEmail); <line15> message.setTo(user.getEmail()); <line16> final String htmlContent = templateEngine.process(WELCOME_TEMPLATE, ctx); <line17> message.setText(htmlContent, true); <line18> javaMailSender.send(mimeMessage); <line19> } catch (final Exception e) { <line20> throw new MailSendException(""Failed to send e-mail when creating user account."", e); <line21> } <line22> } <line23> } <line24> "	<line3>, <line20>
6532	"public class A { <line0> @Override <line1> public void run() { <line2> while (!closed) { <line3> try { <line4> byte[] buffer = new byte[UDP_MSS]; <line5> DatagramPacket packet = new DatagramPacket(buffer, buffer.length); <line6> udpSocket.receive(packet); <line7> String json = new String(IoUtils.tryDecompress(packet.getData()), UTF_8).trim(); <line8> PushPacket pushPacket = JacksonUtils.toObj(json, PushPacket.class); <line9> String ack; <line10> if (""dom"".equals(pushPacket.type) || ""service"".equals(pushPacket.type)) { <line11> serviceInfoHolder.processServiceInfo(pushPacket.data); <line12> ack = <line13> ""{\""type\"": \""push-ack\"""" <line14> + "", \""lastRefTime\"":\"""" <line15> + pushPacket.lastRefTime <line16> + ""\"", \""data\"":"" <line17> + ""\""\""}""; <line18> } else if (""dump"".equals(pushPacket.type)) { <line19> ack = <line20> ""{\""type\"": \""dump-ack\"""" <line21> + "", \""lastRefTime\"": \"""" <line22> + pushPacket.lastRefTime <line23> + ""\"", \""data\"":"" <line24> + ""\"""" <line25> + StringUtils.escapeJavaScript( <line26> JacksonUtils.toJson(serviceInfoHolder.getServiceInfoMap())) <line27> + ""\""}""; <line28> } else { <line29> ack = <line30> ""{\""type\"": \""unknown-ack\"""" <line31> + "", \""lastRefTime\"":\"""" <line32> + pushPacket.lastRefTime <line33> + ""\"", \""data\"":"" <line34> + ""\""\""}""; <line35> } <line36> udpSocket.send( <line37> new DatagramPacket( <line38> ack.getBytes(UTF_8), ack.getBytes(UTF_8).length, packet.getSocketAddress())); <line39> } catch (Exception e) { <line40> if (closed) { <line41> return; <line42> } <line43> } <line44> } <line45> } <line46> } <line47> "	<line8>, <line43>
6533	"public class A { <line0> @Override <line1> public void generate( <line2> File outputDir, <line3> String languageName, <line4> String protocolName, <line5> String outputFlavor, <line6> Map<String, TypeDefinition> types) <line7> throws GenerationException { <line8> try { <line9> Configuration freemarkerConfiguration = getFreemarkerConfiguration(); <line10> ClassTemplateLoader classTemplateLoader = <line11> new ClassTemplateLoader(FreemarkerLanguageOutput.class, ""/""); <line12> freemarkerConfiguration.setTemplateLoader(classTemplateLoader); <line13> List<Template> specTemplates = getSpecTemplates(freemarkerConfiguration); <line14> List<Template> complexTypesTemplateList = getComplexTypeTemplates(freemarkerConfiguration); <line15> List<Template> enumTypesTemplateList = getEnumTypeTemplates(freemarkerConfiguration); <line16> List<Template> dataIoTemplateList = getDataIoTemplates(freemarkerConfiguration); <line17> if (!specTemplates.isEmpty()) { <line18> Map<String, Object> typeContext = new HashMap<>(); <line19> typeContext.put(""languageName"", languageName); <line20> typeContext.put(""protocolName"", protocolName); <line21> typeContext.put(""outputFlavor"", outputFlavor); <line22> typeContext.put(""helper"", getHelper(null, protocolName, outputFlavor, types)); <line23> for (Template template : specTemplates) { <line24> try { <line25> renderTemplate(outputDir, template, typeContext); <line26> } catch (TemplateNotFoundException <line27> | TemplateException <line28> | MalformedTemplateNameException <line29> | ParseException e) { <line30> throw new GenerationException(""Error generating global protocol output."", e); <line31> } <line32> } <line33> } <line34> for (Map.Entry<String, TypeDefinition> typeEntry : types.entrySet()) { <line35> Map<String, Object> typeContext = new HashMap<>(); <line36> typeContext.put(""languageName"", languageName); <line37> typeContext.put(""protocolName"", protocolName); <line38> typeContext.put(""outputFlavor"", outputFlavor); <line39> typeContext.put(""typeName"", typeEntry.getKey()); <line40> typeContext.put(""type"", typeEntry.getValue()); <line41> typeContext.put( <line42> ""helper"", getHelper(typeEntry.getValue(), protocolName, outputFlavor, types)); <line43> List<Template> templateList; <line44> if (typeEntry.getValue() instanceof EnumTypeDefinition) { <line45> templateList = enumTypesTemplateList; <line46> } else if (typeEntry.getValue() instanceof DataIoTypeDefinition) { <line47> templateList = dataIoTemplateList; <line48> } else { <line49> if (typeEntry.getValue().getParentType() instanceof DataIoTypeDefinition) { <line50> continue; <line51> } <line52> templateList = complexTypesTemplateList; <line53> } <line54> for (Template template : templateList) { <line55> try { <line56> renderTemplate(outputDir, template, typeContext); <line57> } catch (TemplateNotFoundException <line58> | TemplateException <line59> | MalformedTemplateNameException <line60> | ParseException e) { <line61> throw new GenerationException( <line62> ""Error generating output for type '"" + typeEntry.getKey() + ""'"", e); <line63> } <line64> } <line65> } <line66> } catch (IOException e) { <line67> throw new GenerationException(""Error generating sources"", e); <line68> } <line69> } <line70> } <line71> "	<line54>
6534	public class A { <line0> public BindCredentials executeExternalGetBindCredentialsMethod( <line1> CustomScriptConfiguration customScriptConfiguration, String configId) { <line2> try { <line3> CacheRefreshType externalType = <line4> (CacheRefreshType) customScriptConfiguration.getExternalType(); <line5> Map<String, SimpleCustomProperty> configurationAttributes = <line6> customScriptConfiguration.getConfigurationAttributes(); <line7> if (externalType.getApiVersion() > 1) { <line8> return externalType.getBindCredentials(configId, configurationAttributes); <line9> } <line10> } catch (Exception ex) { <line11> saveScriptError(customScriptConfiguration.getCustomScript(), ex); <line12> } <line13> return null; <line14> } <line15> } <line16> 	<line3>, <line11>
6535	"public class A { <line0> public ResultSet getTableTypes() { <line1> List<ColumnMetaData> tableTypeMeta = new ArrayList<ColumnMetaData>(); <line2> tableTypeMeta.add( <line3> ColumnMetaData.dummy(ColumnMetaData.scalar(Types.VARCHAR, ""varchar"", Rep.STRING), false)); <line4> List<Object[]> data = new ArrayList<Object[]>(); <line5> Object[] row = new Object[1]; <line6> row[0] = ""TABLE""; <line7> data.add(row); <line8> AvaticaResultSet resultSet = null; <line9> try { <line10> resultSet = <line11> this.conn <line12> .getFactory() <line13> .newResultSet( <line14> this.conn.createStatement(), <line15> new KylinPrepare.PrepareResult( <line16> null, <line17> null, <line18> new KylinEnumerator<Object[]>(data), <line19> ColumnMetaData.struct(tableTypeMeta)), <line20> this.conn.getTimeZone()); <line21> KylinConnectionImpl.TROJAN.execute(resultSet); <line22> } catch (SQLException e) { <line23> } <line24> return resultSet; <line25> } <line26> } <line27> "	<line23>
6536	public class A { <line0> @Override <line1> public void onTerminated(List<ExecutionMessage> messages) { <line2> ScoreEvent[] scoreEvents = handleTerminatedMessages(messages); <line3> if (scoreEvents.length > 0) { <line4> try { <line5> eventBus.dispatch(scoreEvents); <line6> } catch (InterruptedException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
6537	public class A { <line0> @Override <line1> public void terminate() { <line2> if (status.ordinal() < Status.TERMINATED.ordinal()) { <line3> status = Status.TERMINATING; <line4> } <line5> tryTerminate(); <line6> } <line7> } <line8> 	<line5>
6538	public class A { <line0> private void storeCookie() { <line1> if (syncCookie == null) { <line2> return; <line3> } <line4> if ((lastSavedCookie != null) && Arrays.equals(syncCookie, lastSavedCookie)) { <line5> return; <line6> } <line7> try { <line8> Attribute attr = cookieMod.getAttribute(); <line9> attr.clear(); <line10> attr.add(syncCookie); <line11> String cookieString = Strings.utf8ToString(syncCookie); <line12> int replicaId = LdapProtocolUtils.getReplicaId(cookieString); <line13> Attribute ridAt = ridMod.getAttribute(); <line14> ridAt.clear(); <line15> ridAt.add(String.valueOf(replicaId)); <line16> session.modify(config.getConfigEntryDn(), cookieMod); <line17> lastSavedCookie = new byte[syncCookie.length]; <line18> System.arraycopy(syncCookie, 0, lastSavedCookie, 0, syncCookie.length); <line19> } catch (Exception e) { <line20> } <line21> } <line22> } <line23> 	<line1>, <line16>, <line17>, <line20>
6539	public class A { <line0> @Override <line1> public AsyncExecutionState execute(ProcessContext context) { <line2> CloudApplication application = context.getVariable(Variables.APP_TO_PROCESS); <line3> CloudControllerClient client = context.getControllerClient(); <line4> StepLogger stepLogger = context.getStepLogger(); <line5> StagingState state = applicationStager.getStagingState(); <line6> ProcessLoggerProvider processLoggerProvider = stepLogger.getProcessLoggerProvider(); <line7> StepsUtil.saveAppLogs( <line8> context, client, recentLogsRetriever, application, LOGGER, processLoggerProvider); <line9> if (state.getState() != PackageState.STAGED) { <line10> return checkStagingState(context.getStepLogger(), application, state); <line11> } <line12> bindDropletToApplication(client, application); <line13> return AsyncExecutionState.FINISHED; <line14> } <line15> } <line16> 	<line5>, <line6>, <line13>
6540	public class A { <line0> @Override <line1> public boolean declareStored(CsarId csar) { <line2> deploymentTracker.storeDeploymentState(csar, STORED); <line3> return true; <line4> } <line5> } <line6> 	<line2>
6541	public class A { <line0> public String initProfileConfigurations() { <line1> if (profileConfigurations != null) { <line2> return OxTrustConstants.RESULT_SUCCESS; <line3> } <line4> trustRelationship = updateTrustRelationshipAction.getTrustRelationship(); <line5> try { <line6> profileConfigurationService.parseProfileConfigurations(trustRelationship); <line7> } catch (Exception e) { <line8> } <line9> availableProfileConfigurations = new ArrayList<String>(); <line10> for (ProfileConfiguration profileConfiguration : <line11> profileConfigurationService.getAvailableProfileConfigurations()) { <line12> availableProfileConfigurations.add(profileConfiguration.getName()); <line13> this.getFileWrappers().put(profileConfiguration.getName(), new FileUploadWrapper()); <line14> } <line15> profileConfigurations = new ArrayList<String>(); <line16> savedProfileConfigurations = new ArrayList<ProfileConfiguration>(); <line17> for (ProfileConfiguration profileConfiguration : <line18> profileConfigurationService.getProfileConfigurationsList(trustRelationship)) { <line19> savedProfileConfigurations.add(profileConfiguration); <line20> profileConfigurations.add(profileConfiguration.getName()); <line21> } <line22> return OxTrustConstants.RESULT_SUCCESS; <line23> } <line24> } <line25> 	<line8>
6542	public class A { <line0> @Override <line1> public void start() { <line2> if (queue == null) { <line3> AS400 system = endpoint.getSystem(); <line4> if (endpoint.isKeyed()) { <line5> queue = new KeyedDataQueue(system, endpoint.getObjectPath()); <line6> } else { <line7> queue = new DataQueue(system, endpoint.getObjectPath()); <line8> } <line9> } <line10> if (!queue.getSystem().isConnected(AS400.DATAQUEUE)) { <line11> try { <line12> queue.getSystem().connectService(AS400.DATAQUEUE); <line13> } catch (Exception e) { <line14> throw RuntimeCamelException.wrapRuntimeCamelException(e); <line15> } <line16> } <line17> } <line18> } <line19> 	<line11>
6543	public class A { <line0> @Override <line1> public int insertTransaction(InsertTransactionParams p) { <line2> SelectConditionStep<Record1<Integer>> connectorPkQuery = <line3> DSL.select(CONNECTOR.CONNECTOR_PK) <line4> .from(CONNECTOR) <line5> .where(CONNECTOR.CHARGE_BOX_ID.equal(p.getChargeBoxId())) <line6> .and(CONNECTOR.CONNECTOR_ID.equal(p.getConnectorId())); <line7> insertIgnoreConnector(ctx, p.getChargeBoxId(), p.getConnectorId()); <line8> boolean unknownTagInserted = insertIgnoreIdTag(ctx, p); <line9> TransactionDataHolder data = insertIgnoreTransaction(p, connectorPkQuery); <line10> int transactionId = data.transactionId; <line11> if (data.existsAlready) { <line12> return transactionId; <line13> } <line14> if (unknownTagInserted) { <line15> } <line16> if (p.isSetReservationId()) { <line17> reservationRepository.used( <line18> connectorPkQuery, p.getIdTag(), p.getReservationId(), transactionId); <line19> } <line20> if (shouldInsertConnectorStatusAfterTransactionMsg(p.getChargeBoxId())) { <line21> insertConnectorStatus(ctx, connectorPkQuery, p.getStartTimestamp(), p.getStatusUpdate()); <line22> } <line23> return transactionId; <line24> } <line25> } <line26> 	<line15>
6544	public class A { <line0> private void logJSException(Exception e, String response) { <line1> } <line2> } <line3> 	<line1>
6545	public class A { <line0> public static com.liferay.commerce.pricing.model.CommercePriceModifierRelSoap[] <line1> getCommercePriceModifierRels(long commercePriceModifierRelId, String className) <line2> throws RemoteException { <line3> try { <line4> java.util.List<com.liferay.commerce.pricing.model.CommercePriceModifierRel> returnValue = <line5> CommercePriceModifierRelServiceUtil.getCommercePriceModifierRels( <line6> commercePriceModifierRelId, className); <line7> return com.liferay.commerce.pricing.model.CommercePriceModifierRelSoap.toSoapModels( <line8> returnValue); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line10>
6546	"public class A { <line0> public boolean next(Buffer buffer) throws Exception { <line1> byte cmd = buffer.getByte(); <line2> if (cmd != SshConstants.SSH_MSG_KEXDH_REPLY) { <line3> throw new SshException( <line4> SshConstants.SSH2_DISCONNECT_KEY_EXCHANGE_FAILED, <line5> ""Protocol error: expected packet SSH_MSG_KEXDH_REPLY, got "" + cmd); <line6> } <line7> byte[] K_S = buffer.getBytes(); <line8> f = buffer.getMPIntAsBytes(); <line9> byte[] sig = buffer.getBytes(); <line10> dh.setF(f); <line11> K = dh.getK(); <line12> buffer = new Buffer(K_S); <line13> serverKey = buffer.getRawPublicKey(); <line14> final String keyAlg = KeyUtils.getKeyType(serverKey); <line15> if (keyAlg == null) { <line16> throw new SshException(""Unsupported server key type""); <line17> } <line18> buffer = new Buffer(); <line19> buffer.putString(V_C); <line20> buffer.putString(V_S); <line21> buffer.putString(I_C); <line22> buffer.putString(I_S); <line23> buffer.putString(K_S); <line24> buffer.putMPInt(e); <line25> buffer.putMPInt(f); <line26> buffer.putMPInt(K); <line27> hash.update(buffer.array(), 0, buffer.available()); <line28> H = hash.digest(); <line29> Signature verif = <line30> NamedFactory.Utils.create(session.getFactoryManager().getSignatureFactories(), keyAlg); <line31> verif.init(serverKey, null); <line32> verif.update(H, 0, H.length); <line33> if (!verif.verify(sig)) { <line34> throw new SshException( <line35> SshConstants.SSH2_DISCONNECT_KEY_EXCHANGE_FAILED, <line36> ""KeyExchange signature verification failed""); <line37> } <line38> return true; <line39> } <line40> } <line41> "	<line7>
6547	public class A { <line0> @Override <line1> public void removePrefItems() { <line2> plist.clear(); <line3> } <line4> } <line5> 	<line2>
6548	"public class A { <line0> String[] constructArgumentsList() { <line1> List<String> argumentsList = new ArrayList<>(); <line2> argumentsList.add(javaRuntime); <line3> argumentsList.add(MessageFormat.format(""-Xms{0}M"", String.valueOf(initialHeapSizeInMegaBytes))); <line4> argumentsList.add(MessageFormat.format(""-Xmx{0}M"", String.valueOf(maximumHeapSizeInMegaBytes))); <line5> argumentsList.addAll(userSuppliedArguments); <line6> argumentsList.add(""-jar""); <line7> argumentsList.add(runtimeJarName); <line8> argumentsList.addAll(mainClassArguments); <line9> return argumentsList.toArray(new String[0]); <line10> } <line11> } <line12> "	<line9>
6549	public class A { <line0> private void ensureFieldIsAccessible(final Field field) { <line1> field.setAccessible(true); <line2> } <line3> } <line4> 	<line2>
6550	public class A { <line0> @VisibleForTesting <line1> static Date parseRetryAfter(long now, Response response) { <line2> String retryAfter = response.header(RETRY_AFTER); <line3> if (retryAfter == null) { <line4> return null; <line5> } <line6> try { <line7> long retryAfterSeconds = Long.parseLong(retryAfter); <line8> return new Date(now + TimeUnit.SECONDS.toMillis(retryAfterSeconds)); <line9> } catch (NumberFormatException e) { <line10> try { <line11> return HTTP_DATE_FORMAT.get().parse(retryAfter); <line12> } catch (ParseException ignore) { <line13> return null; <line14> } <line15> } <line16> } <line17> } <line18> 	<line13>
6551	"public class A { <line0> public void searchNodesTest2() { <line1> try { <line2> logger.info( <line3> ""****************************************************************************************************""); <line4> logger.info(""""); <line5> Thread.sleep(10000); <line6> logger.info(""""); <line7> } catch (Exception e) { <line8> e.printStackTrace(); <line9> } <line10> } <line11> } <line12> "	<line2>, <line7>
6552	"public class A { <line0> public ProjectVersionsPage clickProjectEntry(String searchEntry) { <line1> List<WebElement> projects = existingElement(projectResult).findElements(By.name(""entry"")); <line2> for (WebElement element : projects) { <line3> WebElement aTag = element.findElement(By.tagName(""a"")); <line4> if (aTag != null && aTag.getText().equals(searchEntry)) { <line5> clickElement(aTag); <line6> break; <line7> } <line8> } <line9> return new ProjectVersionsPage(getDriver()); <line10> } <line11> } <line12> "	<line1>
6553	"public class A { <line0> public static BrokerController start(BrokerController controller) { <line1> try { <line2> controller.start(); <line3> String tip = <line4> ""The broker["" <line5> + controller.getBrokerConfig().getBrokerName() <line6> + "", "" <line7> + controller.getBrokerAddr() <line8> + ""] boot success. serializeType="" <line9> + RemotingCommand.getSerializeTypeConfigInThisServer(); <line10> if (null != controller.getBrokerConfig().getNamesrvAddr()) { <line11> tip += "" and name server is "" + controller.getBrokerConfig().getNamesrvAddr(); <line12> } <line13> System.out.printf(""%s%n"", tip); <line14> return controller; <line15> } catch (Throwable e) { <line16> e.printStackTrace(); <line17> System.exit(-1); <line18> } <line19> return null; <line20> } <line21> } <line22> "	<line13>
6554	public class A { <line0> public boolean isPortReachable(String port) { <line1> boolean ret = false; <line2> synchronized (this.atLock) { <line3> try { <line4> CommConnection commAtConnection = openSerialPort(port); <line5> closeSerialPort(commAtConnection); <line6> ret = true; <line7> } catch (KuraException e) { <line8> } <line9> } <line10> return ret; <line11> } <line12> } <line13> 	<line8>
6555	public class A { <line0> static void logSet(String key, Object value) { <line1> } <line2> } <line3> 	<line1>
6556	public class A { <line0> @Override <line1> public void closeConnection() { <line2> try { <line3> if (is != null) { <line4> is.close(); <line5> is = null; <line6> } <line7> } catch (IOException e) { <line8> } <line9> try { <line10> if (os != null) { <line11> os.close(); <line12> os = null; <line13> } <line14> } catch (IOException e) { <line15> } <line16> if (serialPort != null) { <line17> serialPort.close(); <line18> serialPort = null; <line19> } <line20> } <line21> } <line22> 	<line8>, <line15>
6557	"public class A { <line0> private boolean cancelOrderOnAPI(final long id) <line1> throws BitfinexClientException, InterruptedException { <line2> final CountDownLatch waitLatch = new CountDownLatch(1); <line3> final Consumer<BitfinexSubmittedOrder> ordercallback = <line4> (o) -> { <line5> if (o.getOrderId() == id && o.getStatus() == BitfinexSubmittedOrderStatus.CANCELED) { <line6> waitLatch.countDown(); <line7> } <line8> }; <line9> registerCallback(ordercallback); <line10> try { <line11> cancelOrder(id); <line12> waitLatch.await(TIMEOUT_IN_SECONDS, TimeUnit.SECONDS); <line13> if (waitLatch.getCount() != 0) { <line14> throw new BitfinexClientException(""Timeout while waiting for order""); <line15> } <line16> return true; <line17> } catch (Exception e) { <line18> throw e; <line19> } finally { <line20> removeCallback(ordercallback); <line21> } <line22> } <line23> } <line24> "	<line11>
6558	public class A { <line0> @Override <line1> public void deployArtifacts(CarbonApplication carbonApp, AxisConfiguration axisConfig) <line2> throws DeploymentException { <line3> if (log.isDebugEnabled()) { <line4> } <line5> ApplicationConfiguration appConfig = carbonApp.getAppConfig(); <line6> List<Artifact.Dependency> dependencies = appConfig.getApplicationArtifact().getDependencies(); <line7> List<Artifact> artifacts = new ArrayList<>(); <line8> for (Artifact.Dependency dependency : dependencies) { <line9> if (dependency.getArtifact() != null) { <line10> artifacts.add(dependency.getArtifact()); <line11> } <line12> } <line13> deployDataSources(artifacts, axisConfig); <line14> } <line15> } <line16> 	<line4>
6559	public class A { <line0> public InstancesResult killInstance( <line1> Properties props, <line2> String type, <line3> String entity, <line4> String startStr, <line5> String endStr, <line6> String colo, <line7> List<LifeCycle> lifeCycles) { <line8> checkColo(colo); <line9> checkType(type); <line10> try { <line11> lifeCycles = checkAndUpdateLifeCycle(lifeCycles, type); <line12> validateParams(type, entity); <line13> Entity entityObject = EntityUtil.getEntity(type, entity); <line14> Pair<Date, Date> startAndEndDate = <line15> getStartAndEndDateForLifecycleOperations(entityObject, startStr, endStr); <line16> AbstractWorkflowEngine wfEngine = getWorkflowEngine(entityObject); <line17> wfEngine.killInstances( <line18> entityObject, startAndEndDate.first, startAndEndDate.second, props, lifeCycles); <line19> return wfEngine.ignoreInstances( <line20> entityObject, startAndEndDate.first, startAndEndDate.second, props, lifeCycles); <line21> } catch (Throwable e) { <line22> throw FalconWebException.newAPIException(e); <line23> } <line24> } <line25> } <line26> 	<line22>
6560	public class A { <line0> public void replaceProcessingUser(Task task, User user) { <line1> User currentProcessingUser = task.getProcessingUser(); <line2> if (Objects.isNull(user) && Objects.isNull(currentProcessingUser)) { <line3> } else if (Objects.isNull(user)) { <line4> currentProcessingUser.getProcessingTasks().remove(task); <line5> task.setProcessingUser(null); <line6> } else if (Objects.isNull(currentProcessingUser)) { <line7> user.getProcessingTasks().add(task); <line8> task.setProcessingUser(user); <line9> } else if (Objects.equals(currentProcessingUser.getId(), user.getId())) { <line10> } else { <line11> currentProcessingUser.getProcessingTasks().remove(task); <line12> user.getProcessingTasks().add(task); <line13> task.setProcessingUser(user); <line14> } <line15> } <line16> } <line17> 	<line3>, <line10>
6561	"public class A { <line0> private static Options loadOptions(Options options) { <line1> Reflections reflections = new Reflections(Command.class.getPackage().getName()); <line2> for (Class<? extends Command> cls : reflections.getSubTypesOf(Command.class)) { <line3> try { <line4> for (Field f : cls.getDeclaredFields()) { <line5> if (f.getName().equals(""OPTIONS"")) { <line6> Options clsOptions = ((Options) f.get(null)); <line7> if (clsOptions == null) { <line8> continue; <line9> } <line10> for (Option o : clsOptions.getOptions()) { <line11> options.addOption(o); <line12> } <line13> } <line14> } <line15> } catch (IllegalAccessException e) { <line16> } <line17> } <line18> return options; <line19> } <line20> } <line21> "	<line16>
6562	"public class A { <line0> public Application getApplicationByResourcePath(String applicationResourcePath) { <line1> try { <line2> startTenantFlow(); <line3> Object obj = retrieve(applicationResourcePath); <line4> if (obj != null) { <line5> try { <line6> Object dataObj = Deserializer.deserializeFromByteArray((byte[]) obj); <line7> if (dataObj instanceof Application) { <line8> return (Application) dataObj; <line9> } <line10> } catch (Exception e) { <line11> String msg = <line12> ""Unable to retrieve resource from registry: [resource-path] "" <line13> + applicationResourcePath; <line14> } <line15> } <line16> return null; <line17> } finally { <line18> endTenantFlow(); <line19> } <line20> } <line21> } <line22> "	<line14>
6563	public class A { <line0> public synchronized void close() { <line1> executorService.shutdownNow(); <line2> try { <line3> Thread.sleep(1 * 1000); <line4> } catch (InterruptedException ie) { <line5> } <line6> envelopeSocket.close(); <line7> context.term(); <line8> } <line9> } <line10> 	<line1>
6564	public class A { <line0> @Override <line1> public IAtom getAtom() { <line2> return super.getAtom(); <line3> } <line4> } <line5> 	<line2>
6565	public class A { <line0> @Override <line1> public void readFromByteArray(byte[] bytes) throws MessageException { <line2> if (GZIPUtils.isCompressed(bytes)) { <line3> try { <line4> bytes = GZIPUtils.decompress(bytes); <line5> } catch (IOException ioe) { <line6> throw new MessageException(MessageErrorCodes.INVALID_MESSAGE, ioe, (Object[]) null); <line7> } <line8> } <line9> KuraPayloadProto.KuraPayload protoMsg = null; <line10> try { <line11> protoMsg = KuraPayloadProto.KuraPayload.parseFrom(bytes); <line12> } catch (InvalidProtocolBufferException ipbe) { <line13> throw new MessageException(MessageErrorCodes.INVALID_MESSAGE, ipbe, (Object[]) null); <line14> } <line15> if (protoMsg.hasTimestamp()) { <line16> timestamp = (new Date(protoMsg.getTimestamp())); <line17> } <line18> if (protoMsg.hasPosition()) { <line19> position = (buildFromProtoBuf(protoMsg.getPosition())); <line20> } <line21> protoMsg <line22> .getMetricList() <line23> .forEach( <line24> kuraMetric -> { <line25> try { <line26> Object value = getProtoKuraMetricValue(kuraMetric, kuraMetric.getType()); <line27> addMetric(kuraMetric.getName(), value); <line28> } catch (MessageException me) { <line29> } <line30> }); <line31> if (protoMsg.hasBody()) { <line32> setBody(protoMsg.getBody().toByteArray()); <line33> } <line34> } <line35> } <line36> 	<line29>
6566	"public class A { <line0> public void run(RegressionEnvironment env) { <line1> int numThreads = 2; <line2> int numStatements = 100; <line3> int numEvents = 50000; <line4> BlockingQueue<Runnable> queue = new LinkedBlockingQueue<Runnable>(); <line5> ThreadPoolExecutor threadpool = <line6> new ThreadPoolExecutor( <line7> numThreads, <line8> numThreads, <line9> 1000, <line10> TimeUnit.SECONDS, <line11> queue, <line12> new SupportThreadFactory(MultithreadPatternTimer.class)); <line13> threadpool.prestartAllCoreThreads(); <line14> for (int i = 0; i < numStatements; i++) { <line15> String statementName = ""s"" + i; <line16> String stmtText = <line17> String.format( <line18> ""@name('s%d')select * from pattern [ every e1=SupportByteArrEventLongId(id=%d) ->"" <line19> + "" timer:interval(1 seconds)]"", <line20> i, i); <line21> env.compileDeploy(stmtText); <line22> env.statement(statementName).addListener(new SupportCountListener()); <line23> } <line24> long startTime = System.currentTimeMillis(); <line25> Random random = new Random(new Date().getTime()); <line26> for (int i = 0; i < numEvents; i++) { <line27> final SupportByteArrEventLongId event = <line28> new SupportByteArrEventLongId(random.nextInt(numStatements), 0); <line29> Runnable sendEventRunnable = <line30> new Runnable() { <line31> public void run() { <line32> env.sendEventBean(event); <line33> } <line34> }; <line35> threadpool.submit(sendEventRunnable); <line36> } <line37> while (!queue.isEmpty()) { <line38> try { <line39> Thread.sleep(5000); <line40> } catch (InterruptedException e) { <line41> fail(); <line42> } <line43> } <line44> long endTime = System.currentTimeMillis(); <line45> long startWaitTime = System.currentTimeMillis(); <line46> while (true) { <line47> try { <line48> Thread.sleep(1000); <line49> } catch (InterruptedException e) { <line50> fail(); <line51> } <line52> int countTotal = getCount(env, numStatements); <line53> if (countTotal >= numEvents) { <line54> break; <line55> } <line56> if (System.currentTimeMillis() - startWaitTime > 20000) { <line57> fail(); <line58> } <line59> } <line60> int total = getCount(env, numStatements); <line61> assertEquals(numEvents, total); <line62> env.undeployAll(); <line63> } <line64> } <line65> "	<line14>, <line25>, <line37>, <line43>, <line45>, <line59>
6567	"public class A { <line0> @Test <line1> public void testSortProcessDefinitionsNextPage() throws Exception { <line2> String json1 = read(this.getClass().getResourceAsStream(""/json/process-def-1.json"")); <line3> String json2 = read(this.getClass().getResourceAsStream(""/json/process-def-2.json"")); <line4> JSONResponseAggregator aggregate = new JSONResponseAggregator(); <line5> List<String> data = new ArrayList<>(); <line6> data.add(json1); <line7> data.add(json2); <line8> String sorted = aggregate.aggregate(data, ""ProcessId"", true, 1, 2); <line9> JSONObject aggregated = new JSONObject(sorted); <line10> assertNotNull(aggregated); <line11> Object processes = aggregated.get(""processes""); <line12> assertNotNull(processes); <line13> assertTrue(processes instanceof JSONArray); <line14> JSONArray processDefs = (JSONArray) processes; <line15> assertEquals(2, processDefs.length()); <line16> String value1 = ((JSONObject) processDefs.get(0)).getString(""process-id""); <line17> assertEquals(""3"", value1); <line18> String value2 = ((JSONObject) processDefs.get(1)).getString(""process-id""); <line19> assertEquals(""4"", value2); <line20> } <line21> } <line22> "	<line9>
6568	public class A { <line0> public boolean authenticate(String clientId, String password) { <line1> boolean authenticated = false; <line2> try { <line3> Client client = getClient(clientId); <line4> if (client == null) { <line5> return authenticated; <line6> } <line7> String decryptedClientSecret = decryptSecret(client.getClientSecret()); <line8> authenticated = <line9> client != null && decryptedClientSecret != null && decryptedClientSecret.equals(password); <line10> } catch (StringEncrypter.EncryptionException e) { <line11> } <line12> return authenticated; <line13> } <line14> } <line15> 	<line1>, <line5>, <line11>
6569	"public class A { <line0> private void deviceReboot(DeploymentPackageUninstallOptions options) { <line1> if (options.isReboot()) { <line2> try { <line3> int delay = options.getRebootDelay(); <line4> Thread.sleep(delay); <line5> Consumer<CommandStatus> commandCallback = status -> {}; <line6> this.executorService.execute(new Command(new String[] {""reboot""}), commandCallback); <line7> } catch (InterruptedException e) { <line8> Thread.currentThread().interrupt(); <line9> } <line10> } <line11> } <line12> } <line13> "	<line3>, <line4>, <line5>, <line9>
6570	public class A { <line0> static <T extends Event> List<EventListenerSupplier<T>> load( <line1> final SessionInfo sessionInfo, <line2> final Class<T> eventType, <line3> final Iterable<ListenerService> loader) { <line4> return StreamUtil.toStream(loader) <line5> .flatMap(s -> s.findListeners(sessionInfo, eventType)) <line6> .filter(Objects::nonNull) <line7> .collect(Collectors.toList()); <line8> } <line9> } <line10> 	<line4>, <line5>
6571	public class A { <line0> public static com.liferay.portal.kernel.model.LayoutSoap updateLayout( <line1> long groupId, boolean privateLayout, long layoutId, String typeSettings) <line2> throws RemoteException { <line3> try { <line4> com.liferay.portal.kernel.model.Layout returnValue = <line5> LayoutServiceUtil.updateLayout(groupId, privateLayout, layoutId, typeSettings); <line6> return com.liferay.portal.kernel.model.LayoutSoap.toSoapModel(returnValue); <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>
6572	public class A { <line0> @Override <line1> public boolean failAllContent(Throwable failure) { <line2> List<HttpInput.Content> copy; <line3> try (AutoLock l = _lock.lock()) { <line4> copy = new ArrayList<>(_contentQueue); <line5> _contentQueue.clear(); <line6> } <line7> copy.forEach(c -> c.failed(failure)); <line8> boolean atEof; <line9> try (AutoLock l = _lock.lock()) { <line10> atEof = _specialContent != null && _specialContent.isEof(); <line11> } <line12> return atEof; <line13> } <line14> } <line15> 	<line2>, <line12>
6573	"public class A { <line0> private Stream<AggregationBuilder> seriesStream( <line1> Pivot pivot, ESGeneratedQueryContext queryContext, String reason) { <line2> return EntryStream.of(pivot.series()) <line3> .mapKeyValue( <line4> (integer, seriesSpec) -> { <line5> final String seriesName = queryContext.seriesName(seriesSpec, pivot); <line6> final ESPivotSeriesSpecHandler<? extends SeriesSpec, ? extends Aggregation> <line7> esPivotSeriesSpecHandler = seriesHandlers.get(seriesSpec.type()); <line8> if (esPivotSeriesSpecHandler == null) { <line9> throw new IllegalArgumentException( <line10> ""No series handler registered for: "" + seriesSpec.type()); <line11> } <line12> return esPivotSeriesSpecHandler.createAggregation( <line13> seriesName, pivot, seriesSpec, this, queryContext); <line14> }) <line15> .filter(Optional::isPresent) <line16> .map(Optional::get); <line17> } <line18> } <line19> "	<line6>
6574	"public class A { <line0> @Override <line1> public Location getPickLocation() throws Exception { <line2> if (pickLocation == null) { <line3> pickLocation = location; <line4> } <line5> int partX, partY; <line6> if (feedCount >= (trayCountCols * trayCountRows)) { <line7> throw new Exception(""Tray empty.""); <line8> } <line9> if (trayCountCols >= trayCountRows) { <line10> partX = feedCount / trayCountRows; <line11> partY = feedCount % trayCountRows; <line12> } else { <line13> partX = feedCount % trayCountCols; <line14> partY = feedCount / trayCountCols; <line15> } <line16> calculatePickLocation(partX, partY); <line17> return pickLocation; <line18> } <line19> } <line20> "	<line17>
6575	"public class A { <line0> @Test <line1> public void test_31_MISSING_REF() { <line2> String vcfFile = path(""test_missing_ref.vcf""); <line3> VcfFileIterator vcf = new VcfFileIterator(vcfFile); <line4> int countVariants = 0; <line5> for (VcfEntry ve : vcf) { <line6> for (Variant v : ve.variants()) { <line7> if (v.isVariant()) countVariants++; <line8> } <line9> } <line10> Assert.assertEquals(1, countVariants); <line11> } <line12> } <line13> "	<line6>, <line7>
6576	public class A { <line0> @Override <line1> public void start( <line2> ResourceManagerId newResourceManagerId, <line3> Executor newMainThreadExecutor, <line4> ResourceActions newResourceActions) { <line5> resourceManagerId = Preconditions.checkNotNull(newResourceManagerId); <line6> mainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor); <line7> resourceActions = Preconditions.checkNotNull(newResourceActions); <line8> slotStatusSyncer.initialize( <line9> taskManagerTracker, resourceTracker, resourceManagerId, mainThreadExecutor); <line10> started = true; <line11> taskManagerTimeoutsCheck = <line12> scheduledExecutor.scheduleWithFixedDelay( <line13> () -> mainThreadExecutor.execute(this::checkTaskManagerTimeouts), <line14> 0L, <line15> taskManagerTimeout.toMilliseconds(), <line16> TimeUnit.MILLISECONDS); <line17> registerSlotManagerMetrics(); <line18> } <line19> } <line20> 	<line5>
6577	public class A { <line0> private static void verifyRegistration() throws Exception { <line1> MBeanServer mbs = ManagementFactory.getPlatformMBeanServer(); <line2> if (mbs.isRegistered(getGlobalName(HAStatus.class))) { <line3> } <line4> ; <line5> } <line6> } <line7> 	<line3>
6578	"public class A { <line0> private StatusResponseHolder makeRequest(HttpMethod method, String url) { <line1> try { <line2> StatusResponseHolder response = <line3> this.httpClient <line4> .go(new Request(method, new URL(url)), StatusResponseHandler.getInstance()) <line5> .get(); <line6> if (!response.getStatus().equals(HttpResponseStatus.OK)) { <line7> throw new ISE( <line8> ""Error while making request to indexer [%s %s]"", <line9> response.getStatus(), response.getContent()); <line10> } <line11> return response; <line12> } catch (Exception e) { <line13> throw new RuntimeException(e); <line14> } <line15> } <line16> } <line17> "	<line13>
6579	"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (EnvUtil.getPort() <= 0) { <line4> return; <line5> } <line6> int weight = EnvUtil.getAvailableProcessors(0.5); <line7> if (weight <= 0) { <line8> weight = 1; <line9> } <line10> long curTime = System.currentTimeMillis(); <line11> String status = <line12> LOCALHOST_SITE + ""#"" + EnvUtil.getLocalAddress() + ""#"" + curTime + ""#"" + weight + ""\r\n""; <line13> List<Member> allServers = getServers(); <line14> if (!contains(EnvUtil.getLocalAddress())) { <line15> return; <line16> } <line17> if (allServers.size() > 0 <line18> && !EnvUtil.getLocalAddress().contains(InternetAddressUtil.localHostIP())) { <line19> for (Member server : allServers) { <line20> if (Objects.equals(server.getAddress(), EnvUtil.getLocalAddress())) { <line21> continue; <line22> } <line23> if (server.getExtendVal(MemberMetaDataConstants.VERSION) != null) { <line24> continue; <line25> } <line26> Message msg = new Message(); <line27> msg.setData(status); <line28> synchronizer.send(server.getAddress(), msg); <line29> } <line30> } <line31> } catch (Exception e) { <line32> } finally { <line33> GlobalExecutor.registerServerStatusReporter( <line34> this, switchDomain.getServerStatusSynchronizationPeriodMillis()); <line35> } <line36> } <line37> } <line38> "	<line15>, <line24>, <line32>
6580	"public class A { <line0> @BeforeMethod <line1> public void beforeMethod() throws Exception { <line2> TSOServerConfig tsoConfig = new TSOServerConfig(); <line3> tsoConfig.setConflictMapSize(1000); <line4> tsoConfig.setPort(TSO_SERVER_PORT); <line5> tsoConfig.setTimestampType(TIMESTAMP_TYPE.INCREMENTAL.toString()); <line6> tsoConfig.setNumConcurrentCTWriters(2); <line7> Module tsoServerMockModule = new TSOMockModule(tsoConfig); <line8> Injector injector = Guice.createInjector(tsoServerMockModule); <line9> LOG.info( <line10> ""==================================================================================================""); <line11> LOG.info( <line12> ""==================================================================================================""); <line13> tsoServer = injector.getInstance(TSOServer.class); <line14> tsoServer.startAsync(); <line15> tsoServer.awaitRunning(); <line16> TestUtils.waitForSocketListening(TSO_SERVER_HOST, TSO_SERVER_PORT, 100); <line17> LOG.info( <line18> ""==================================================================================================""); <line19> pausableTSOracle = (PausableTimestampOracle) injector.getInstance(TimestampOracle.class); <line20> commitTable = injector.getInstance(CommitTable.class); <line21> OmidClientConfiguration tsoClientConf = new OmidClientConfiguration(); <line22> tsoClientConf.setConnectionString(TSO_SERVER_HOST + "":"" + TSO_SERVER_PORT); <line23> this.tsoClientConf = tsoClientConf; <line24> } <line25> } <line26> "	<line11>, <line19>
6581	public class A { <line0> @Override <line1> public void channelInactive(ChannelHandlerContext ctx) { <line2> var hardwareChannel = ctx.channel(); <line3> var state = getHardState(hardwareChannel); <line4> if (state != null) { <line5> var session = sessionDao.get(state.userKey); <line6> if (session != null) { <line7> var device = state.device; <line8> sentOfflineMessage(ctx, session, state.dash, device); <line9> } <line10> } <line11> } <line12> } <line13> 	<line8>
6582	"public class A { <line0> @Override <line1> public void deleteUploadPart(String objectId, String uploadId, Part part) throws IOException { <line2> retry.execute( <line3> ctx -> { <line4> serviceTemplate.exchange( <line5> endpoint + ""/upload/{object-id}/parts?uploadId={upload-id}&partNumber={partNumber}"", <line6> DELETE, <line7> defaultEntity(), <line8> Void.class, <line9> objectId, <line10> uploadId, <line11> part.getPartNumber()); <line12> return null; <line13> }); <line14> } <line15> } <line16> "	<line2>
6583	"public class A { <line0> public static String replaceNamedPlaceholders( <line1> final String textWithNamedPlaceholders, Map<String, String> values) { <line2> PlaceholderResolver placeholderResolver = <line3> placeholderName -> { <line4> String result = values.get(placeholderName); <line5> if (StringUtils.isEmpty(result)) { <line6> } <line7> return result; <line8> }; <line9> PropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(""${"", ""}""); <line10> String replacedTextResult = <line11> helper.replacePlaceholders(textWithNamedPlaceholders, placeholderResolver); <line12> helper = new PropertyPlaceholderHelper(""{{"", ""}}""); <line13> return helper.replacePlaceholders(replacedTextResult, placeholderResolver); <line14> } <line15> } <line16> "	<line6>
6584	"public class A { <line0> public static void checkAngleRegulation( <line1> UcteAngleRegulation ucteAngleRegulation, UcteElementId transfoId, Reporter reporter) { <line2> if (ucteAngleRegulation.getDu() < ZERO_EPS || ucteAngleRegulation.getDu() > DU_LIMIT) { <line3> reporter.report( <line4> Report.builder() <line5> .withKey(""wrongAngleRegulationDu"") <line6> .withDefaultMessage( <line7> ""${transfoId} - For LTCs, transformer angle regulation voltage per tap should not"" <line8> + "" be zero. Its absolute value should not be above 6 % (${du} %)"") <line9> .withValue(""transfoId"", transfoId.toString()) <line10> .withValue(""du"", ucteAngleRegulation.getDu()) <line11> .withSeverity(UcteReportConstants.WARN_SEVERITY) <line12> .build()); <line13> } <line14> if (ucteAngleRegulation.getN() != null <line15> && (ucteAngleRegulation.getN() < ZERO_EPS || ucteAngleRegulation.getN() > N_LIMIT)) { <line16> } <line17> if (Math.abs(ucteAngleRegulation.getTheta()) > THETA_ABS_LIMIT) { <line18> } <line19> } <line20> } <line21> "	<line13>, <line16>, <line18>
6585	"public class A { <line0> public synchronized void store(final ChangeLog changeLog) throws ItemStateException { <line1> int failures = 0; <line2> ItemStateException lastException = null; <line3> boolean sleepInterrupted = false; <line4> while (!sleepInterrupted && (blockOnConnectionLoss || failures <= 1)) { <line5> try { <line6> conHelper.startBatch(); <line7> super.store(changeLog); <line8> conHelper.endBatch(true); <line9> return; <line10> } catch (SQLException e) { <line11> lastException = new ItemStateException(e.getMessage(), e); <line12> } catch (ItemStateException e) { <line13> lastException = e; <line14> try { <line15> conHelper.endBatch(false); <line16> } catch (SQLException e2) { <line17> DbUtility.logException(""rollback failed"", e2); <line18> } <line19> assert !isIntegrityConstraintViolation(e.getCause()); <line20> } <line21> failures++; <line22> if (blockOnConnectionLoss || failures <= 1) { <line23> try { <line24> Thread.sleep(100); <line25> } catch (InterruptedException e1) { <line26> Thread.currentThread().interrupt(); <line27> sleepInterrupted = true; <line28> } <line29> } <line30> } <line31> throw lastException; <line32> } <line33> } <line34> "	<line22>, <line28>
6586	public class A { <line0> @Override <line1> public JRPrintElement convert(ReportConverter reportConverter, JRComponentElement element) { <line2> BarbecueComponent component = (BarbecueComponent) element.getComponent(); <line3> if (component == null || component.getType() == null) { <line4> return null; <line5> } <line6> try { <line7> JRBasePrintImage image = new JRBasePrintImage(reportConverter.getDefaultStyleProvider()); <line8> reportConverter.copyBaseAttributes(element, image); <line9> image.setScaleImage(ScaleImageEnum.RETAIN_SHAPE); <line10> String code = null; <line11> if (component.getCodeExpression() != null) { <line12> code = JRExpressionUtil.getSimpleExpressionText(component.getCodeExpression()); <line13> } <line14> if (code == null) { <line15> code = DEFAULT_PREVIEW_CODE; <line16> } <line17> String applicationIdentifier = null; <line18> if (component.getApplicationIdentifierExpression() != null) { <line19> applicationIdentifier = <line20> JRExpressionUtil.getSimpleExpressionText( <line21> component.getApplicationIdentifierExpression()); <line22> } <line23> BarcodeInfo barcodeInfo = new BarcodeInfo(); <line24> barcodeInfo.setType(component.getType()); <line25> barcodeInfo.setCode(code); <line26> barcodeInfo.setApplicationIdentifier(applicationIdentifier); <line27> barcodeInfo.setDrawText(component.isDrawText()); <line28> barcodeInfo.setRequiresChecksum(component.isChecksumRequired()); <line29> barcodeInfo.setBarWidth(component.getBarWidth()); <line30> barcodeInfo.setBarHeight(component.getBarHeight()); <line31> Barcode barcode = BarcodeProviders.createBarcode(barcodeInfo); <line32> BarbecueRendererImpl renderer = new BarbecueRendererImpl(barcode); <line33> renderer.setRotation(BarbecueStyleResolver.getRotationValue(element)); <line34> image.setRenderer(renderer); <line35> return image; <line36> } catch (Exception e) { <line37> if (log.isDebugEnabled()) { <line38> } <line39> return null; <line40> } <line41> } <line42> } <line43> 	<line38>
6587	"public class A { <line0> public static RuntimeStatisticsAggregator parse(String str) { <line1> String[] tokens = str.split("" ""); <line2> try { <line3> double throughputTotal = Double.parseDouble(tokens[0]); <line4> double responseDataThroughputTotal = Double.parseDouble(tokens[1]); <line5> long numRequestsTotal = Long.parseLong(tokens[2]); <line6> long numHitsTotal = Long.parseLong(tokens[3]); <line7> long numL1CacheHitsTotal = Long.parseLong(tokens[4]); <line8> long numL2CacheHitsTotal = Long.parseLong(tokens[5]); <line9> CacheStatistics cacheStatisticsTotal = <line10> new CacheStatistics( <line11> Long.parseLong(tokens[6]), <line12> Long.parseLong(tokens[7]), <line13> Long.parseLong(tokens[8]), <line14> Long.parseLong(tokens[9])); <line15> int numRandomSample = tokens.length - 14; <line16> double[] randomSample = new double[numRandomSample]; <line17> for (int i = 0; i < numRandomSample; ++i) { <line18> randomSample[i] = Double.parseDouble(tokens[14 + i]); <line19> } <line20> DoublePopulationStatisticsAggregator getRequestsPopulationStatistics = <line21> new DoublePopulationStatisticsAggregator( <line22> Double.parseDouble(tokens[10]), <line23> Double.parseDouble(tokens[11]), <line24> Long.parseLong(tokens[12]), <line25> Double.parseDouble(tokens[13]), <line26> randomSample); <line27> return new RuntimeStatisticsAggregator( <line28> throughputTotal, <line29> responseDataThroughputTotal, <line30> numRequestsTotal, <line31> numHitsTotal, <line32> numL1CacheHitsTotal, <line33> numL2CacheHitsTotal, <line34> getRequestsPopulationStatistics, <line35> cacheStatisticsTotal); <line36> } catch (Exception e) { <line37> return new RuntimeStatisticsAggregator(); <line38> } <line39> } <line40> } <line41> "	<line37>
6588	public class A { <line0> protected int myGetProperty(String property, int defaultValue) { <line1> int value; <line2> try { <line3> value = Integer.parseInt(prop.getProperty(property)); <line4> } catch (Exception e) { <line5> return defaultValue; <line6> } <line7> return value; <line8> } <line9> } <line10> 	<line5>
6589	"public class A { <line0> @SuppressWarnings(""resource"") <line1> protected PartialList<String> doQuery( <line2> String query, String queryType, QueryFilter queryFilter, int countUpTo) { <line3> final Timer.Context timerContext = queryTimer.time(); <line4> try { <line5> Mutable<String> idKeyHolder = new MutableObject<>(); <line6> PartialList<Map<String, Serializable>> pl = <line7> doQueryAndFetch(query, queryType, queryFilter, false, countUpTo, idKeyHolder); <line8> String idKey = idKeyHolder.getValue(); <line9> List<String> ids = new ArrayList<>(pl.size()); <line10> for (Map<String, Serializable> map : pl) { <line11> String id = (String) map.get(idKey); <line12> ids.add(id); <line13> } <line14> return new PartialList<>(ids, pl.totalSize()); <line15> } finally { <line16> long duration = timerContext.stop(); <line17> if (LOG_MIN_DURATION_NS >= 0 && duration > LOG_MIN_DURATION_NS) { <line18> String msg = <line19> String.format( <line20> ""duration_ms:\t%.2f\t%s %s\tquery\t%s"", <line21> duration / 1000000.0, queryFilter, countUpToAsString(countUpTo), query); <line22> if (log.isTraceEnabled()) { <line23> } else { <line24> } <line25> } <line26> } <line27> } <line28> } <line29> "	<line23>, <line24>
6590	public class A { <line0> private long[] _updateDDMStructure( <line1> long userId, <line2> String fileEntryTypeUuid, <line3> long fileEntryTypeId, <line4> long groupId, <line5> Map<Locale, String> nameMap, <line6> Map<Locale, String> descriptionMap, <line7> long[] ddmStructureIds, <line8> ServiceContext serviceContext) <line9> throws PortalException { <line10> DDMStructure ddmStructure = null; <line11> try { <line12> fixDDMStructureKey(fileEntryTypeUuid, fileEntryTypeId, groupId); <line13> String ddmStructureKey = DLUtil.getDDMStructureKey(fileEntryTypeUuid); <line14> ddmStructure = <line15> DDMStructureManagerUtil.fetchStructure( <line16> groupId, <line17> classNameLocalService.getClassNameId(DLFileEntryMetadata.class), <line18> ddmStructureKey); <line19> DDMForm ddmForm = _getDDMForm(ddmStructure, serviceContext); <line20> if (_isEmptyDDMForm(ddmForm)) { <line21> if (ddmStructure != null) { <line22> _deleteDDMStructure(fileEntryTypeId, ddmStructure.getStructureId()); <line23> return ArrayUtil.remove(ddmStructureIds, ddmStructure.getStructureId()); <line24> } <line25> return ddmStructureIds; <line26> } <line27> if (ddmStructure == null) { <line28> ddmStructure = <line29> DDMStructureManagerUtil.addStructure( <line30> userId, <line31> groupId, <line32> null, <line33> classNameLocalService.getClassNameId(DLFileEntryMetadata.class), <line34> ddmStructureKey, <line35> nameMap, <line36> descriptionMap, <line37> ddmForm, <line38> StorageEngineManager.STORAGE_TYPE_DEFAULT, <line39> DDMStructureManager.STRUCTURE_TYPE_AUTO, <line40> serviceContext); <line41> } else { <line42> ddmStructure = <line43> DDMStructureManagerUtil.updateStructure( <line44> userId, <line45> ddmStructure.getStructureId(), <line46> ddmStructure.getParentStructureId(), <line47> nameMap, <line48> descriptionMap, <line49> ddmForm, <line50> serviceContext); <line51> } <line52> return ArrayUtil.append(ddmStructureIds, ddmStructure.getStructureId()); <line53> } catch (StructureDefinitionException structureDefinitionException) { <line54> if (_log.isWarnEnabled()) { <line55> } <line56> if (ddmStructure != null) { <line57> long ddmStructureId = ddmStructure.getStructureId(); <line58> _deleteDDMStructure(fileEntryTypeId, ddmStructureId); <line59> return ArrayUtil.remove(ddmStructureIds, ddmStructureId); <line60> } <line61> return ddmStructureIds; <line62> } <line63> } <line64> } <line65> 	<line55>
6591	public class A { <line0> public static File getKitodoDebugDirectory() { <line1> try { <line2> File debugDirectory = new File(ConfigCore.getParameter(ParameterCore.DIR_DEBUG)); <line3> if (!debugDirectory.exists()) { <line4> return null; <line5> } <line6> if (!debugDirectory.isDirectory()) { <line7> return null; <line8> } <line9> if (!debugDirectory.canWrite()) { <line10> return null; <line11> } <line12> return debugDirectory; <line13> } catch (NoSuchElementException debugDirectoryNotConfigured) { <line14> logger.catching(Level.TRACE, debugDirectoryNotConfigured); <line15> return null; <line16> } <line17> } <line18> } <line19> 	<line4>, <line7>, <line10>
6592	public class A { <line0> public AuxiliaryCache getCache(String cacheName) { <line1> LateralCacheNoWait c = null; <line2> synchronized (this.caches) { <line3> c = (LateralCacheNoWait) this.caches.get(cacheName); <line4> if (c == null) { <line5> LateralCacheAttributes attr = (LateralCacheAttributes) lca.copy(); <line6> attr.setCacheName(cacheName); <line7> LateralCache cache = new LateralCache(attr, this.lateralService, monitor); <line8> if (log.isDebugEnabled()) { <line9> } <line10> c = new LateralCacheNoWait(cache); <line11> this.caches.put(cacheName, c); <line12> } <line13> } <line14> if (lca.isReceive()) { <line15> try { <line16> addLateralCacheListener(cacheName, LateralCacheJGListener.getInstance(this.lca, cacheMgr)); <line17> } catch (IOException ioe) { <line18> } catch (Exception e) { <line19> } <line20> } else { <line21> if (log.isDebugEnabled()) { <line22> } <line23> } <line24> return c; <line25> } <line26> } <line27> 	<line9>, <line12>, <line18>, <line19>, <line22>
6593	public class A { <line0> public void send(OutputStream out) throws IOException { <line1> sendStart(out); <line2> sendDispositionHeader(out); <line3> sendContentTypeHeader(out); <line4> sendTransferEncodingHeader(out); <line5> sendEndOfHeader(out); <line6> sendData(out); <line7> sendEnd(out); <line8> } <line9> } <line10> 	<line1>
6594	"public class A { <line0> public void validate(Object command, Errors errors) { <line1> AddScenarioSchemaCommand data = (AddScenarioSchemaCommand) command; <line2> ValidationUtils.rejectIfEmptyOrWhitespace(errors, ""schemaDescription"", ""required.field""); <line3> int len = data.getSchemaDescription().length(); <line4> if (len > 2000) { <line5> errors.rejectValue(""schemaDescription"", ""invalid.maxScenSchemaLen""); <line6> } <line7> if ((!(data.getId() > 0)) <line8> && (data.getSchemaFile().isEmpty()) <line9> && (data.getSchemaFile().isEmpty())) { <line10> errors.rejectValue(""schemaFile"", ""required.dataFileXsd""); <line11> } <line12> } <line13> } <line14> "	<line1>, <line11>
6595	public class A { <line0> @Override <line1> public void closeFailure(CommandContext commandContext) { <line2> if (commandContext.getEventDispatcher().isEnabled()) { <line3> commandContext <line4> .getEventDispatcher() <line5> .dispatchEvent( <line6> ActivitiEventBuilder.createEntityExceptionEvent( <line7> ActivitiEventType.JOB_EXECUTION_FAILURE, job, commandContext.getException())); <line8> } <line9> CommandConfig commandConfig = commandExecutor.getDefaultConfig().transactionRequiresNew(); <line10> FailedJobCommandFactory failedJobCommandFactory = commandContext.getFailedJobCommandFactory(); <line11> Command<Object> cmd = <line12> failedJobCommandFactory.getCommand(job.getId(), commandContext.getException()); <line13> commandExecutor.execute(commandConfig, cmd); <line14> } <line15> } <line16> 	<line13>
6596	public class A { <line0> @Override <line1> public void exitFunction(AqlParser.FunctionContext functionContext) { <line2> } <line3> } <line4> 	<line2>
6597	"public class A { <line0> @Override <line1> public CommandReport executeCommand( <line2> final String userName, final Long commandId, final Object value) <line3> throws CommandTagValueException { <line4> if (sessionService != null) { <line5> if (!sessionService.isUserLogged(userName)) { <line6> return new CommandReportImpl( <line7> commandId, CommandExecutionStatus.STATUS_AUTHORISATION_FAILED, ""No user is logged-in.""); <line8> } <line9> } else { <line10> } <line11> if (!commandCache.containsKey(commandId)) { <line12> getCommandTag(commandId); <line13> } <line14> CommandTagImpl<Object> cct = commandCache.get(commandId); <line15> if (!cct.isExistingCommand()) { <line16> return new CommandReportImpl( <line17> commandId, <line18> CommandExecutionStatus.STATUS_CMD_UNKNOWN, <line19> ""The command with tagId '"" + commandId + ""' is not known to the server""); <line20> } <line21> CommandExecuteRequest<Object> executeRequest = createCommandExecuteRequest(cct, value); <line22> if (sessionService != null && !isAuthorized(userName, commandId)) { <line23> return new CommandReportImpl( <line24> commandId, <line25> CommandExecutionStatus.STATUS_AUTHORISATION_FAILED, <line26> ""The logged user has not the priviledges to execute command "" + commandId + "".""); <line27> } <line28> try { <line29> return clientRequestHandler.executeCommand(executeRequest); <line30> } catch (Exception e) { <line31> return new CommandReportImpl( <line32> commandId, <line33> CommandExecutionStatus.STATUS_SERVER_ERROR, <line34> ""Could not execute the command due to a communication error with the server. Error: "" <line35> + e.getMessage()); <line36> } <line37> } <line38> } <line39> "	<line5>, <line10>, <line29>, <line31>
6598	"public class A { <line0> public static int getEntriesCount( <line1> HttpPrincipal httpPrincipal, <line2> com.liferay.asset.kernel.service.persistence.AssetEntryQuery entryQuery) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> new MethodKey( <line7> AssetEntryServiceUtil.class, ""getEntriesCount"", _getEntriesCountParameterTypes4); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, entryQuery); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> return ((Integer) returnObj).intValue(); <line19> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	<line20>
6599	"public class A { <line0> @Override <line1> public void operationComplete(Future future) throws Exception { <line2> if (future.isSuccess()) { <line3> tlsTransportClient.setTlsHandshakingState(TlsHandshakingState.SHAKEN); <line4> pipeline.addLast( <line5> ""decoder"", <line6> new DiameterMessageDecoder( <line7> StartTlsServerHandler.this.tlsTransportClient.getParent(), <line8> StartTlsServerHandler.this.tlsTransportClient.getParser())); <line9> pipeline.addLast( <line10> ""msgHandler"", <line11> new DiameterMessageHandler( <line12> StartTlsServerHandler.this.tlsTransportClient.getParent(), true)); <line13> pipeline.addLast( <line14> ""encoder"", <line15> new DiameterMessageEncoder(StartTlsServerHandler.this.tlsTransportClient.getParser())); <line16> pipeline.addLast(""inbandWriter"", new InbandSecurityHandler()); <line17> } <line18> } <line19> } <line20> "	<line3>, <line4>
6600	public class A { <line0> private static void destroy(Process process) { <line1> try { <line2> process.destroy(); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	<line4>
6601	"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/users/{userName}/permissions"") <line3> @RolesAllowed({ADMIN_ROLE}) <line4> public PermissionResponse getUserPermissions(@PathParam(""userName"") String userName) { <line5> final User user = userManagerService.getUser(userName); <line6> assertObjectExists(user, ""user"", userName); <line7> return resourceHelper.getUserPermissions(userName); <line8> } <line9> } <line10> "	<line5>
6602	"public class A { <line0> private void persistTasks() { <line1> Dictionary<String, Object> configProperties = new Hashtable<>(); <line2> try { <line3> persistTasks(configProperties, dataFile); <line4> configuration.updateIfDifferent(configProperties); <line5> } catch (RepositoryException | IOException e) { <line6> throw new IllegalStateException(""Could not persist tasks"", e); <line7> } <line8> } <line9> } <line10> "	<line5>
6603	public class A { <line0> @Asynchronous <line1> public void initTimer() { <line2> this.isActive = new AtomicBoolean(false); <line3> timerEvent.fire( <line4> new TimerEvent( <line5> new TimerSchedule(TIMER_TICK_INTERVAL_IN_SECONDS, TIMER_TICK_INTERVAL_IN_SECONDS), <line6> new StatEvent(), <line7> Scheduled.Literal.INSTANCE)); <line8> this.lastFinishedTime = System.currentTimeMillis(); <line9> } <line10> } <line11> 	<line2>, <line9>
6604	public class A { <line0> public static void buildProducers() { <line1> DecoratorRegistryFactory.getDecoratorRegistry() <line2> .addDecorator(MBeanStats.class, new GeneralMBeanDecorator()); <line3> for (MBeanServer server : MBeanServerFactory.findMBeanServer(null)) <line4> for (final ObjectInstance mBean : server.queryMBeans(null, null)) <line5> if (isMBeanRequired(mBean)) { <line6> SimpleStatsProducer<MBeanStats> producer = buildProducer(server, mBean); <line7> if (producer != null) { <line8> producerRegistry.registerProducer(producer); <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>
6605	"public class A { <line0> private void doTest(int numPipelinesToCreate, boolean destroyEachWebRtc, boolean checkMemory) <line1> throws Exception { <line2> initMemory(); <line3> ListenerSubscription listenerObjectCreated = <line4> getServerManager() <line5> .addObjectCreatedListener( <line6> new EventListener<ObjectCreatedEvent>() { <line7> @Override <line8> public void onEvent(ObjectCreatedEvent event) { <line9> objectsLatch.getObjectsCreatedLatch().countDown(); <line10> } <line11> }); <line12> ListenerSubscription listenerObjectDestroyed = <line13> getServerManager() <line14> .addObjectDestroyedListener( <line15> new EventListener<ObjectDestroyedEvent>() { <line16> @Override <line17> public void onEvent(ObjectDestroyedEvent event) { <line18> objectsLatch.getObjectsDestroyedLatch().countDown(); <line19> } <line20> }); <line21> int webRtcEndpointToCreate = 0; <line22> int objectsToCreate = 0; <line23> for (int i = 1; i <= ITERATIONS; i++) { <line24> webRtcEndpointToCreate = (int) Math.pow(INCREASE_EXPONENTIAL, i); <line25> objectsToCreate = (webRtcEndpointToCreate * numPipelinesToCreate) + numPipelinesToCreate; <line26> ArrayList<WebRtcEndpoint> webRtcEndpoints = new ArrayList<WebRtcEndpoint>(); <line27> ArrayList<MediaPipeline> mediaPipelines = new ArrayList<MediaPipeline>(); <line28> objectsLatch = new ObjectsLatch(objectsToCreate); <line29> for (int j = 0; j < numPipelinesToCreate; j++) { <line30> MediaPipeline mp = kurentoClient.createMediaPipeline(); <line31> mediaPipelines.add(mp); <line32> for (int k = 0; k < webRtcEndpointToCreate; k++) { <line33> WebRtcEndpoint webRtcEp = new WebRtcEndpoint.Builder(mp).build(); <line34> webRtcEndpoints.add(webRtcEp); <line35> } <line36> for (int k = 0; k < webRtcEndpoints.size(); k = k + 2) { <line37> WebRtcEndpoint webRtcEp1 = webRtcEndpoints.get(k); <line38> WebRtcEndpoint webRtcEp2 = webRtcEndpoints.get(k + 1); <line39> String sdpOffer = webRtcEp1.generateOffer(); <line40> webRtcEp2.processOffer(sdpOffer); <line41> } <line42> } <line43> Assert.assertTrue( <line44> ""The Objects are not created properly. Expected: "" <line45> + objectsToCreate <line46> + "". No received "" <line47> + (objectsToCreate - objectsLatch.getObjectsCreatedLatch().getCount()) <line48> + "" ObjectCreated event(s)"", <line49> objectsLatch.getObjectsCreatedLatch().await(TIMEOUT, TimeUnit.SECONDS)); <line50> if (destroyEachWebRtc) { <line51> for (WebRtcEndpoint webRtcEp : webRtcEndpoints) { <line52> webRtcEp.release(); <line53> } <line54> } <line55> for (MediaPipeline pipeline : mediaPipelines) { <line56> pipeline.release(); <line57> } <line58> Assert.assertTrue( <line59> ""The Objects are not destroyed properly. Expected: "" <line60> + objectsToCreate <line61> + "". No received "" <line62> + (objectsToCreate - objectsLatch.getObjectsDestroyedLatch().getCount()) <line63> + "" ObjectDestroyed event(s)"", <line64> objectsLatch.getObjectsDestroyedLatch().await(TIMEOUT, TimeUnit.SECONDS)); <line65> double percentageMemory = getMemoryIncrease(); <line66> if (checkMemory) { <line67> Assert.assertTrue( <line68> ""The memory increases more than 0%. The percentage memory was "" + percentageMemory, <line69> percentageMemory >= 0.0 && percentageMemory <= 10.0); <line70> } <line71> } <line72> getServerManager().removeObjectCreatedListener(listenerObjectCreated); <line73> getServerManager().removeObjectDestroyedListener(listenerObjectDestroyed); <line74> } <line75> } <line76> "	<line26>
6606	public class A { <line0> protected void handleAspDownAck(ASPDownAck aspUpAck) { <line1> if (!this.aspFactoryImpl.started) { <line2> boolean stopAssociation = true; <line3> for (FastList.Node<Asp> n = this.aspFactoryImpl.aspList.head(), <line4> end = this.aspFactoryImpl.aspList.tail(); <line5> (n = n.getNext()) != end; ) { <line6> AspImpl aspImpl = (AspImpl) n.getValue(); <line7> FSM fsm = aspImpl.getLocalFSM(); <line8> if (fsm == null) { <line9> continue; <line10> } <line11> FSM fsmPeer = aspImpl.getPeerFSM(); <line12> if (fsmPeer != null) { <line13> AspState aspPeerState = AspState.getState(fsmPeer.getState().getName()); <line14> if (aspPeerState != AspState.DOWN) { <line15> stopAssociation = false; <line16> } <line17> } <line18> try { <line19> fsm.signal(TransitionState.ASP_DOWN_ACK); <line20> } catch (UnknownTransitionException e) { <line21> } <line22> } <line23> if (!stopAssociation) { <line24> } <line25> try { <line26> if (this.aspFactoryImpl.aspFactoryStopTimer != null) { <line27> this.aspFactoryImpl.aspFactoryStopTimer.cancel(); <line28> } <line29> this.aspFactoryImpl.transportManagement.stopAssociation( <line30> this.aspFactoryImpl.association.getName()); <line31> } catch (Exception e) { <line32> } <line33> } else { <line34> } <line35> } <line36> } <line37> 	<line9>, <line21>, <line24>, <line32>, <line34>
6607	"public class A { <line0> @Override <line1> public Pair<Boolean, String> restoreBackedUpVolume( <line2> Backup backup, String volumeUuid, String hostIp, String dataStoreUuid) { <line3> throw new CloudRuntimeException(""Dummy plugin does not support this feature""); <line4> } <line5> } <line6> "	<line3>
6608	"public class A { <line0> private void checkPrefix(String prefix) throws CommitFailedException { <line1> if (prefix.isEmpty() || !contains(prefixes, namespaces, prefix)) { <line2> String msg = ""Invalid namespace prefix("" + prefixes + ""): "" + prefix; <line3> if (initPhase && !strictInitialNSChecks) { <line4> return; <line5> } <line6> throw new CommitFailedException(CommitFailedException.NAME, 1, msg); <line7> } <line8> } <line9> } <line10> "	<line4>
6609	public class A { <line0> public static void removeTemporaryAIPShallow(String jobId, List<AIP> aips) { <line1> Path tempPath; <line2> for (AIP aip : aips) { <line3> try { <line4> tempPath = <line5> RodaCoreFactory.getFileShallowTmpDirectoryPath() <line6> .resolve(jobId) <line7> .resolve(String.valueOf(getAIPStoragePath(aip.getId()).hashCode())); <line8> if (Files.exists(tempPath)) { <line9> FileUtils.deleteDirectory(tempPath.toFile()); <line10> } <line11> } catch (IOException | RequestNotValidException e) { <line12> } <line13> } <line14> } <line15> } <line16> 	<line12>
6610	"public class A { <line0> public Table autoAddAttributes() { <line1> if (entityClass == null) { <line2> throw new IllegalStateException( <line3> ""Entity class isn't set. Can't add attributes from property names. Please set entity"" <line4> + "" class first.""); <line5> } <line6> final Field[] fields; <line7> final List<Method> getter; <line8> if (this.superTable != null) { <line9> fields = entityClass.getDeclaredFields(); <line10> getter = BeanHelper.getAllGetterMethods(entityClass, false); <line11> } else { <line12> fields = BeanHelper.getAllDeclaredFields(entityClass); <line13> getter = BeanHelper.getAllGetterMethods(entityClass); <line14> } <line15> for (final Field field : fields) { <line16> final List<Annotation> annotations = handlePersistencyAnnotations(field); <line17> if (annotations == null) { <line18> continue; <line19> } <line20> final String fieldName = field.getName(); <line21> if (log.isDebugEnabled()) { <line22> } <line23> addTableAttribute(fieldName, annotations); <line24> } <line25> for (final Method method : getter) { <line26> final List<Annotation> annotations = handlePersistencyAnnotations(method); <line27> if (annotations == null) { <line28> continue; <line29> } <line30> if (log.isDebugEnabled()) { <line31> } <line32> final String property = BeanHelper.getProperty(method); <line33> if (property != null) { <line34> addTableAttribute(property, annotations); <line35> } else { <line36> } <line37> } <line38> if (this.discriminatorColumn != null) { <line39> TableAttributeType type; <line40> if (this.discriminatorColumn.discriminatorType() == DiscriminatorType.CHAR) { <line41> type = TableAttributeType.CHAR; <line42> } else if (this.discriminatorColumn.discriminatorType() == DiscriminatorType.INTEGER) { <line43> type = TableAttributeType.INT; <line44> } else { <line45> type = TableAttributeType.VARCHAR; <line46> } <line47> final TableAttribute attr = new TableAttribute(this.discriminatorColumn.name(), type); <line48> if (type == TableAttributeType.VARCHAR) { <line49> attr.setLength(31); <line50> } <line51> addAttribute(attr); <line52> } <line53> return this; <line54> } <line55> } <line56> "	<line22>, <line31>, <line36>
6611	public class A { <line0> public void setReadOnly() { <line1> synchronized (readOnly) { <line2> readOnly = true; <line3> } <line4> } <line5> } <line6> 	<line1>
6612	"public class A { <line0> private int getLevel(String controlGroupTitle) { <line1> int lvl = 0; <line2> final int maxSupportedLvl = 3; <line3> if (controlGroupTitle.contains("","")) { <line4> String lvlString = controlGroupTitle.substring(controlGroupTitle.lastIndexOf(',') + 1).trim(); <line5> if (lvlString.contains("" "")) { <line6> String lvlNrString = lvlString.substring(lvlString.lastIndexOf(' ')).trim(); <line7> try { <line8> lvl = Integer.parseInt(lvlNrString); <line9> if (lvl > maxSupportedLvl) { <line10> lvl = 0; <line11> } <line12> } catch (NumberFormatException e) { <line13> lvl = 0; <line14> } <line15> } <line16> } <line17> return lvl; <line18> } <line19> } <line20> "	<line13>
6613	"public class A { <line0> @Override <line1> public void init() throws DBException { <line2> Properties props = getProperties(); <line3> String servers = props.getProperty(""voltdb.servers"", ""localhost""); <line4> String user = props.getProperty(""voltdb.user"", """"); <line5> String password = props.getProperty(""voltdb.password"", """"); <line6> String strLimit = props.getProperty(""voltdb.ratelimit""); <line7> String useScanAllParam = props.getProperty(""voltdb.scanall"", ""no""); <line8> if (useScanAllParam.equalsIgnoreCase(""YES"")) { <line9> useScanAll = true; <line10> } <line11> int ratelimit = strLimit != null ? Integer.parseInt(strLimit) : Integer.MAX_VALUE; <line12> try { <line13> mclient = ConnectionHelper.createConnection(servers, user, password, ratelimit); <line14> ysb = StaticHolder.INSTANCE; <line15> ysb.loadClassesAndDDLIfNeeded(mclient); <line16> } catch (Exception e) { <line17> throw new DBException(e.getMessage()); <line18> } <line19> mworkingData = new byte[1024 * 1024]; <line20> mwriteBuf = ByteBuffer.wrap(mworkingData); <line21> } <line22> } <line23> "	<line17>
6614	"public class A { <line0> private static synchronized void load() { <line1> ClassLoader classLoader = ParserIndex.class.getClassLoader(); <line2> Reflections reflections = <line3> new Reflections(new ConfigurationBuilder().setUrls(effectiveClassPathUrls(classLoader))); <line4> Set<Class<? extends MessageParser>> indexLoc = reflections.getSubTypesOf(MessageParser.class); <line5> Map<String, String> availableParsersLoc = new HashMap<>(); <line6> indexLoc.forEach( <line7> parserClass -> { <line8> if (!""BasicParser"".equals(parserClass.getSimpleName())) { <line9> availableParsersLoc.put( <line10> parserClass.getSimpleName().replaceAll(""Basic|Parser"", """"), parserClass.getName()); <line11> } <line12> }); <line13> index = indexLoc; <line14> availableParsers = availableParsersLoc; <line15> } <line16> } <line17> "	<line1>, <line13>
6615	"public class A { <line0> @ApiOperation( <line1> value = <line2> ""Creates message queues for testing the connection between this cloud and the target"" <line3> + "" cloud through the given relay"", <line4> tags = {CoreCommonConstants.SWAGGER_TAG_PRIVATE}) <line5> @ApiResponses( <line6> value = { <line7> @ApiResponse(code = HttpStatus.SC_CREATED, message = POST_CONNECT_HTTP_201_MESSAGE), <line8> @ApiResponse(code = HttpStatus.SC_BAD_REQUEST, message = POST_CONNECT_HTTP_400_MESSAGE), <line9> @ApiResponse(code = HttpStatus.SC_BAD_GATEWAY, message = POST_CONNECT_HTTP_502_MESSAGE), <line10> @ApiResponse( <line11> code = HttpStatus.SC_UNAUTHORIZED, <line12> message = CoreCommonConstants.SWAGGER_HTTP_401_MESSAGE), <line13> @ApiResponse( <line14> code = HttpStatus.SC_INTERNAL_SERVER_ERROR, <line15> message = CoreCommonConstants.SWAGGER_HTTP_500_MESSAGE) <line16> }) <line17> @ResponseStatus(value = org.springframework.http.HttpStatus.CREATED) <line18> @PostMapping( <line19> path = CommonConstants.OP_QOS_MONITOR_INIT_RELAY_TEST_URI, <line20> consumes = MediaType.APPLICATION_JSON_VALUE) <line21> public void initRelayTest(@RequestBody final QoSMonitorSenderConnectionRequestDTO request) { <line22> validateConnectionRequest( <line23> request, <line24> CommonConstants.QOS_MONITOR_URI + CommonConstants.OP_QOS_MONITOR_INIT_RELAY_TEST_URI); <line25> relayTestService.initRelayTest(request); <line26> } <line27> } <line28> "	<line22>, <line26>
6616	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @GET <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @Path(""{id}/properties.json"") <line4> @RestQuery( <line5> name = ""getSeriesProperties"", <line6> description = ""Returns the series properties"", <line7> returnDescription = ""Returns the series properties as JSON"", <line8> pathParameters = { <line9> @RestParameter( <line10> name = ""id"", <line11> description = ""ID of series"", <line12> isRequired = true, <line13> type = Type.STRING) <line14> }, <line15> responses = { <line16> @RestResponse(responseCode = SC_OK, description = ""The access control list.""), <line17> @RestResponse( <line18> responseCode = SC_UNAUTHORIZED, <line19> description = ""If the current user is not authorized to perform this action"") <line20> }) <line21> public Response getSeriesPropertiesAsJson(@PathParam(""id"") String seriesId) <line22> throws UnauthorizedException, NotFoundException { <line23> if (StringUtils.isBlank(seriesId)) { <line24> return Response.status(BAD_REQUEST).build(); <line25> } <line26> try { <line27> Map<String, String> properties = seriesService.getSeriesProperties(seriesId); <line28> JSONArray jsonProperties = new JSONArray(); <line29> for (String name : properties.keySet()) { <line30> JSONObject property = new JSONObject(); <line31> property.put(name, properties.get(name)); <line32> jsonProperties.add(property); <line33> } <line34> return Response.ok(jsonProperties.toString()).build(); <line35> } catch (UnauthorizedException e) { <line36> throw e; <line37> } catch (NotFoundException e) { <line38> throw e; <line39> } catch (Exception e) { <line40> } <line41> throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR); <line42> } <line43> } <line44> "	<line24>, <line40>
6617	public class A { <line0> public FeedbackDocument[] getFeedbackDocuments(Request request) { <line1> String queryid = request.getQueryID(); <line2> TIntByteHashMap list = queryidRelDocumentMap.get(queryid); <line3> if (list == null) return null; <line4> if (list.size() == 0) return new FeedbackDocument[0]; <line5> final List<FeedbackDocument> rtrList = new ArrayList<FeedbackDocument>(list.size()); <line6> for (int id : list.keys()) { <line7> FeedbackDocument doc = new FeedbackDocument(); <line8> doc.docid = id; <line9> doc.score = -1; <line10> doc.rank = -1; <line11> doc.relevance = list.get(id); <line12> rtrList.add(doc); <line13> } <line14> return rtrList.toArray(new FeedbackDocument[0]); <line15> } <line16> } <line17> 	<line14>
6618	public class A { <line0> public void testSparseDoubleLongKeyCompUDF() throws Exception { <line1> Worker worker = LocalClusterContext.get().getWorker(workerAttempt0Id).getWorker(); <line2> MatrixClient client1 = worker.getPSAgent().getMatrixClient(SPARSE_DOUBLE_LONG_MAT_COMP, 0); <line3> int matrixW1Id = client1.getMatrixId(); <line4> long blockColNum = <line5> worker.getPSAgent().getMatrixMetaManager().getMatrixMeta(matrixW1Id).getBlockColNum(); <line6> long[] index = genLongIndexs(feaNum, nnz); <line7> CompLongDoubleVector deltaVec = null; <line8> for (int rowId = 0; rowId < rowNum; rowId++) { <line9> int partNum = (feaNum + (int) blockColNum - 1) / (int) blockColNum; <line10> LongDoubleVector[] subVecs = new LongDoubleVector[partNum]; <line11> for (int i = 0; i < partNum; i++) { <line12> subVecs[i] = VFactory.sparseLongKeyDoubleVector((int) blockColNum); <line13> } <line14> deltaVec = new CompLongDoubleVector(feaNum, subVecs, (int) blockColNum); <line15> for (int i = 0; i < nnz; i++) deltaVec.set(index[i], index[i]); <line16> client1.increment(rowId, deltaVec, true); <line17> } <line18> int[] rowIds = new int[rowNum]; <line19> for (int i = 0; i < rowNum; i++) { <line20> rowIds[i] = i; <line21> } <line22> Vector[] rows = client1.getRows(rowIds); <line23> for (int i = 0; i < rowNum; i++) { <line24> for (long id : index) { <line25> Assert.assertEquals(((CompLongDoubleVector) rows[i]).get(id), deltaVec.get(id), zero); <line26> } <line27> } <line28> } <line29> } <line30> 	<line25>
6619	public class A { <line0> private void populateRealTimeContainerMetrics( <line1> ContainersMetricsDto containersMetricsDto, <line2> ResourceHost resourceHost, <line3> Date startTime, <line4> Date endTime) { <line5> for (ContainerHost containerHost : resourceHost.getContainerHosts()) { <line6> if (Common.BAZAAR_ID.equals(containerHost.getInitiatorPeerId())) { <line7> try { <line8> HistoricalMetrics historicalMetrics = <line9> monitor.getMetricsSeries(containerHost, startTime, endTime); <line10> HostMetricsDto hostMetricsDto = historicalMetrics.getHostMetrics(); <line11> if (!HistoricalMetrics.isZeroMetric(hostMetricsDto)) { <line12> hostMetricsDto.setType(HostMetricsDto.HostType.CONTAINER_HOST); <line13> hostMetricsDto.setHostId(containerHost.getId()); <line14> hostMetricsDto.setHostName(containerHost.getContainerName()); <line15> hostMetricsDto.setStartTime(startTime); <line16> hostMetricsDto.setEndTime(endTime); <line17> containersMetricsDto.getContainerHostMetricsDto().add(hostMetricsDto); <line18> } <line19> } catch (Exception e) { <line20> } <line21> } <line22> } <line23> } <line24> } <line25> 	<line20>
6620	public class A { <line0> private void failOnStart(final Throwable cause) { <line1> if (cause != null) { <line2> } else { <line3> } <line4> if (this.locator != null) { <line5> this.locator.stop(); <line6> this.locator = null; <line7> } <line8> if (this.process != null) { <line9> this.process.stop(this.deletePidFileOnStop); <line10> this.process = null; <line11> } <line12> INSTANCE.compareAndSet(this, null); <line13> this.running.set(false); <line14> } <line15> } <line16> 	<line2>, <line3>
6621	public class A { <line0> @Override <line1> public void run() { <line2> while (!this.isStopped()) { <line3> this.waitForRunning(1000); <line4> try { <line5> Worker.this.maintainConnectorState(); <line6> Worker.this.maintainTaskState(); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> } <line12> 	<line2>, <line8>, <line10>
6622	public class A { <line0> private List<MavenProject> validateModuleVersions(Set<MavenProject> moduleProjects) { <line1> List<MavenProject> result = new ArrayList<MavenProject>(); <line2> if (moduleProjects != null && !moduleProjects.isEmpty()) { <line3> String version = moduleProjects.iterator().next().getVersion(); <line4> for (MavenProject mavenProject : moduleProjects) { <line5> if (!version.equals(mavenProject.getVersion())) { <line6> result.add(mavenProject); <line7> } <line8> } <line9> } <line10> return result; <line11> } <line12> } <line13> 	<line4>, <line5>
6623	public class A { <line0> @Override <line1> public boolean getBoolean(String key) { <line2> if (containsKey(key)) { <line3> return PropertyConverter.toBoolean(getProperty(key)); <line4> } else { <line5> throw new NoSuchElementException(doesNotMapMessage(key)); <line6> } <line7> } <line8> } <line9> 	<line5>
6624	"public class A { <line0> @Override <line1> public void run2() { <line2> Cache cache = getCache(); <line3> LogWriter logger = cache.getLogger(); <line4> QueryService qs = cache.getQueryService(); <line5> Region region = cache.getRegion(prRegionName); <line6> try { <line7> if (null != fromClause) { <line8> qs.createIndex(indexName, IndexType.FUNCTIONAL, indexedExpression, fromClause); <line9> throw new RuntimeException( <line10> ""Should throw an exception because "" <line11> + ""the index with name : "" <line12> + indexName <line13> + "" should already exists""); <line14> } else { <line15> qs.createIndex( <line16> indexName, IndexType.FUNCTIONAL, indexedExpression, region.getFullPath() + "" "" + alias); <line17> throw new RuntimeException( <line18> ""Should throw an exception because "" <line19> + ""the index with name : "" <line20> + indexName <line21> + "" should already exists""); <line22> } <line23> } catch (IndexExistsException e) { <line24> } catch (IndexNameConflictException ex) { <line25> } catch (RegionNotFoundException exx) { <line26> Assert.fail(""Region Not found in this vm "", exx); <line27> } <line28> } <line29> } <line30> "	<line24>, <line25>
6625	"public class A { <line0> private PgAuditSettingVO selectPgAuditLogSetting(JSONObject serverInfoObj) throws Exception { <line1> PgAuditSettingVO pgAuditSettingVO = new PgAuditSettingVO(); <line2> SqlSessionFactory sqlSessionFactory = null; <line3> sqlSessionFactory = SqlSessionManager.getInstance(); <line4> String poolName = <line5> """" <line6> + serverInfoObj.get(ProtocolID.SERVER_IP) <line7> + ""_"" <line8> + serverInfoObj.get(ProtocolID.DATABASE_NAME) <line9> + ""_"" <line10> + serverInfoObj.get(ProtocolID.SERVER_PORT); <line11> Connection connDB = null; <line12> SqlSession sessDB = null; <line13> try { <line14> SocketExt.setupDriverPool(serverInfoObj, poolName); <line15> connDB = DriverManager.getConnection(""jdbc:apache:commons:dbcp:"" + poolName); <line16> sessDB = sqlSessionFactory.openSession(connDB); <line17> pgAuditSettingVO = sessDB.selectOne(""app.selectPgAuditLogSetting""); <line18> sessDB.close(); <line19> connDB.close(); <line20> } catch (Exception e) { <line21> throw e; <line22> } finally { <line23> if (sessDB != null) sessDB.close(); <line24> if (connDB != null) connDB.close(); <line25> } <line26> return pgAuditSettingVO; <line27> } <line28> } <line29> "	<line21>
6626	public class A { <line0> @Override <line1> public boolean logout() throws LoginException { <line2> if (trace) { <line3> } <line4> return true; <line5> } <line6> } <line7> 	<line3>
6627	public class A { <line0> public void dispatch( <line1> List<EventState> eventList, SessionImpl session, Path pathPrefix, String userData) { <line2> ObservationDispatcher[] disp; <line3> synchronized (dispatchers) { <line4> disp = <line5> (ObservationDispatcher[]) <line6> dispatchers.toArray(new ObservationDispatcher[dispatchers.size()]); <line7> } <line8> for (int i = 0; i < disp.length; i++) { <line9> EventStateCollection events = new EventStateCollection(disp[i], session, pathPrefix); <line10> events.setUserData(userData); <line11> try { <line12> events.addAll(eventList); <line13> events.prepare(); <line14> events.dispatch(); <line15> } catch (Exception e) { <line16> } <line17> } <line18> } <line19> } <line20> 	<line16>
6628	"public class A { <line0> public void waitForConnectedAndDeflectorHealthy(long timeout, TimeUnit unit) <line1> throws InterruptedException, TimeoutException { <line2> final CountDownLatch latch = new CountDownLatch(1); <line3> final ScheduledFuture<?> scheduledFuture = <line4> scheduler.scheduleAtFixedRate( <line5> () -> { <line6> try { <line7> if (isConnected() && isDeflectorHealthy()) { <line8> latch.countDown(); <line9> } <line10> } catch (Exception ignore) { <line11> } <line12> }, <line13> 0, <line14> 1, <line15> TimeUnit.SECONDS); <line16> final boolean waitSuccess = latch.await(timeout, unit); <line17> scheduledFuture.cancel(true); <line18> if (!waitSuccess) { <line19> throw new TimeoutException(""Write-active index didn't get healthy within timeout""); <line20> } <line21> } <line22> } <line23> "	<line2>, <line8>
6629	public class A { <line0> public void push(ZToolAddress16 nwkAddress, ZToolAddress64 ieeeAddress) { <line1> ZigBeeNodeAddress inserting = new ZigBeeNodeAddress(nwkAddress, ieeeAddress); <line2> for (ZigBeeNodeAddress address : addresses) { <line3> if (address.equals(inserting)) { <line4> return; <line5> } <line6> } <line7> synchronized (addresses) { <line8> if (closing) { <line9> return; <line10> } <line11> addresses.add(inserting); <line12> addresses.notify(); <line13> } <line14> } <line15> } <line16> 	<line1>, <line4>, <line14>
6630	public class A { <line0> private Future<Void> checkInternalModules() { <line1> final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion); <line2> final String okapiModule = md.getId(); <line3> final String interfaceVersion = md.getProvides()[0].getVersion(); <line4> return moduleManager <line5> .get(okapiModule) <line6> .compose( <line7> gres -> { <line8> return Future.succeededFuture(); <line9> }, <line10> cause -> { <line11> if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) { <line12> return Future.failedFuture(cause); <line13> } <line14> return moduleManager.createList( <line15> Collections.singletonList(md), true, true, true, false); <line16> }) <line17> .compose(x -> checkSuperTenant(okapiModule)); <line18> } <line19> } <line20> 	<line1>, <line8>, <line14>
6631	"public class A { <line0> @Override <line1> public ModelAndView resolveException( <line2> HttpServletRequest request, <line3> HttpServletResponse response, <line4> Object handler, <line5> Exception exception) { <line6> Map<String, Object> model = new HashMap<>(); <line7> int statusCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR; <line8> String errMsg = exception.getMessage(); <line9> if (exception instanceof HTTPException) { <line10> HTTPException httpExc = (HTTPException) exception; <line11> statusCode = httpExc.getStatusCode(); <line12> if (exception instanceof ClientHTTPException) { <line13> } else { <line14> } <line15> } else { <line16> } <line17> int depth = 10; <line18> Throwable temp = exception; <line19> while (!(temp instanceof ValidationException)) { <line20> if (depth-- == 0) { <line21> break; <line22> } <line23> if (temp == null) { <line24> break; <line25> } <line26> temp = temp.getCause(); <line27> } <line28> if (temp instanceof ValidationException) { <line29> Model validationReportModel = ((ValidationException) temp).validationReportAsModel(); <line30> StringWriter stringWriter = new StringWriter(); <line31> Rio.write(validationReportModel, stringWriter, RDFFormat.NQUADS); <line32> statusCode = HttpServletResponse.SC_CONFLICT; <line33> errMsg = stringWriter.toString(); <line34> Map<String, String> headers = new HashMap<>(); <line35> headers.put(""Content-Type"", ""application/shacl-validation-report+n-quads""); <line36> model.put(SimpleResponseView.CUSTOM_HEADERS_KEY, headers); <line37> } <line38> model.put(SimpleResponseView.SC_KEY, statusCode); <line39> model.put(SimpleResponseView.CONTENT_KEY, errMsg); <line40> return new ModelAndView(SimpleResponseView.getInstance(), model); <line41> } <line42> } <line43> "	<line6>, <line13>, <line14>, <line16>
6632	"public class A { <line0> private static ConsistencyLevel parseConsistency(String consistency) { <line1> if (consistency != null) { <line2> for (ConsistencyLevel consistencyLevel : ConsistencyLevel.values()) { <line3> if (consistencyLevel.name().toLowerCase().equals(consistency.toLowerCase())) { <line4> return consistencyLevel; <line5> } <line6> } <line7> } <line8> throw new IllegalStateException(""Invalid configured test consistency "" + consistency); <line9> } <line10> } <line11> "	<line8>
6633	public class A { <line0> @Before <line1> public void setup() throws Exception { <line2> root = folder.newFolder(); <line3> loader = new TestCacheLoader<String, InputStream>(folder.newFolder()); <line4> uploader = new TestStagingUploader(folder.newFolder()); <line5> taskLatch = new CountDownLatch(1); <line6> callbackLatch = new CountDownLatch(1); <line7> afterExecuteLatch = new CountDownLatch(1); <line8> executor = new TestExecutor(1, taskLatch, callbackLatch, afterExecuteLatch); <line9> ScheduledExecutorService statsExecutor = Executors.newSingleThreadScheduledExecutor(); <line10> closer.register(new ExecutorCloser(statsExecutor, 500, TimeUnit.MILLISECONDS)); <line11> statsProvider = new DefaultStatisticsProvider(statsExecutor); <line12> scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); <line13> closer.register(new ExecutorCloser(scheduledExecutor, 500, TimeUnit.MILLISECONDS)); <line14> fileCacheExecutor = sameThreadExecutor(); <line15> cache = <line16> new CompositeDataStoreCache( <line17> root.getAbsolutePath(), <line18> null, <line19> 80 * 1024, <line20> 10, <line21> 1, <line22> loader, <line23> uploader, <line24> statsProvider, <line25> executor, <line26> scheduledExecutor, <line27> fileCacheExecutor, <line28> 3000, <line29> 6000); <line30> closer.register(cache); <line31> } <line32> } <line33> 	<line2>, <line31>
6634	public class A { <line0> @Override <line1> public IAtom getLastAtom() { <line2> return super.getLastAtom(); <line3> } <line4> } <line5> 	<line2>
6635	"public class A { <line0> @Override <line1> public StateMachine registryStateMachine(StateMachine stateMachine) { <line2> String stateMachineName = stateMachine.getName(); <line3> String tenantId = stateMachine.getTenantId(); <line4> if (stateLangStore != null) { <line5> StateMachine oldStateMachine = <line6> stateLangStore.getLastVersionStateMachine(stateMachineName, tenantId); <line7> if (oldStateMachine != null) { <line8> byte[] oldBytesContent = null; <line9> byte[] bytesContent = null; <line10> try { <line11> oldBytesContent = oldStateMachine.getContent().getBytes(charset); <line12> bytesContent = stateMachine.getContent().getBytes(charset); <line13> } catch (UnsupportedEncodingException e) { <line14> } <line15> if (Arrays.equals(bytesContent, oldBytesContent) <line16> && stateMachine.getVersion() != null <line17> && stateMachine.getVersion().equals(oldStateMachine.getVersion())) { <line18> stateMachine.setId(oldStateMachine.getId()); <line19> stateMachine.setGmtCreate(oldStateMachine.getGmtCreate()); <line20> Item item = new Item(stateMachine); <line21> stateMachineMapByNameAndTenant.put(stateMachineName + ""_"" + tenantId, item); <line22> stateMachineMapById.put(stateMachine.getId(), item); <line23> return stateMachine; <line24> } <line25> } <line26> if (StringUtils.isBlank(stateMachine.getId())) { <line27> stateMachine.setId(seqGenerator.generate(DomainConstants.SEQ_ENTITY_STATE_MACHINE)); <line28> } <line29> stateMachine.setGmtCreate(new Date()); <line30> stateLangStore.storeStateMachine(stateMachine); <line31> } <line32> if (StringUtils.isBlank(stateMachine.getId())) { <line33> stateMachine.setId(seqGenerator.generate(DomainConstants.SEQ_ENTITY_STATE_MACHINE)); <line34> } <line35> Item item = new Item(stateMachine); <line36> stateMachineMapByNameAndTenant.put(stateMachineName + ""_"" + tenantId, item); <line37> stateMachineMapById.put(stateMachine.getId(), item); <line38> return stateMachine; <line39> } <line40> } <line41> "	<line14>, <line18>
6636	public class A { <line0> @Test <line1> public void testSerializeRpc_in() throws Exception { <line2> Optional<? extends RpcDefinition> loadRpc = <line3> ConverterUtils.loadRpc(this.effectiveModelContext, SIMPLE_IO_RPC_QNAME); <line4> Writer serializeRpc = <line5> bindingSerializer.serializeRpc( <line6> loadRpc.get().getInput(), testedSimpleRpcInputNormalizedNodes); <line7> Assert.assertFalse(Strings.isNullOrEmpty(serializeRpc.toString())); <line8> } <line9> } <line10> 	<line8>
6637	public class A { <line0> @Override <line1> public void spaceCreated(SpaceLifeCycleEvent event) { <line2> IndexingService indexingService = CommonsUtils.getService(IndexingService.class); <line3> String id = event.getSpace().getId(); <line4> indexingService.index(SpaceIndexingServiceConnector.TYPE, id); <line5> } <line6> } <line7> 	<line4>
6638	"public class A { <line0> @Test <line1> public void testGetFeature() { <line2> Document doc = <line3> getAsDOM(""wfs?service=WFS&version=2.0.0&request=GetFeature&typenames=gsml:GeologicUnit""); <line4> assertXpathCount(1, ""//gsml:GeologicUnit"", doc); <line5> assertXpathEvaluatesTo(""gu.1"", ""//gsml:GeologicUnit/@gml:id"", doc); <line6> assertXpathCount(2, ""//gsml:GeologicUnit[@gml:id='gu.1']/gsml:occurrence"", doc); <line7> assertXpathEvaluatesTo( <line8> ""http://resource.example.org/mapped-feature/mf.2"", <line9> ""//gsml:GeologicUnit[@gml:id='gu.1']/gsml:occurrence[1]/@xlink:href"", <line10> doc); <line11> assertXpathEvaluatesTo( <line12> ""http://resource.example.org/mapped-feature/mf.3"", <line13> ""//gsml:GeologicUnit[@gml:id='gu.1']/gsml:occurrence[2]/@xlink:href"", <line14> doc); <line15> } <line16> } <line17> "	<line4>
6639	"public class A { <line0> private void addMissingPidsToEntities(Graph graph, String collectionName, String entityTypeName) { <line1> graph <line2> .traversal() <line3> .V() <line4> .has(T.label, LabelP.of(entityTypeName)) <line5> .hasNot(""pid"") <line6> .valueMap(""tim_id"", ""rev"") <line7> .forEachRemaining( <line8> entity -> { <line9> final UUID id = UUID.fromString(((List<String>) entity.get(""tim_id"")).get(0)); <line10> final int rev = ((List<Integer>) entity.get(""rev"")).get(0); <line11> final EntityLookup entityLookup = <line12> ImmutableEntityLookup.builder() <line13> .collection(collectionName) <line14> .timId(id) <line15> .rev(rev) <line16> .build(); <line17> redirectionService.oldAdd(urlGenerator.apply(collectionName, id, rev), entityLookup); <line18> }); <line19> } <line20> } <line21> "	<line1>, <line9>
6640	public class A { <line0> private void handleMeasures( <line1> Set<Configuration> globalNotifees, Set<Configuration> globalAuditorNotifees) { <line2> try { <line3> LoadCnAElementByType<MassnahmenUmsetzung> lmu = <line4> new LoadCnAElementByType<MassnahmenUmsetzung>(MassnahmenUmsetzung.class, true); <line5> lmu = getCommandService().executeCommand(lmu); <line6> for (MassnahmenUmsetzung mu : lmu.getElements()) { <line7> if (mu.isCompleted()) { <line8> handleCompletedMeasure(mu, globalAuditorNotifees); <line9> } else { <line10> handleIncompletedMeasure(mu, globalNotifees); <line11> } <line12> } <line13> } catch (CommandException e) { <line14> throw new RuntimeException(e); <line15> } catch (RuntimeException e) { <line16> throw e; <line17> } <line18> } <line19> } <line20> 	<line14>, <line16>
6641	"public class A { <line0> protected void createAllLinks(String typeId) throws CommandException { <line1> CnATreeElement element = elementMap.get(typeId); <line2> EntityType entityType = huiTypeFactory.getEntityType(typeId); <line3> Set<HuiRelation> relations = entityType.getPossibleRelations(); <line4> for (HuiRelation relation : relations) { <line5> String destinationTypeId = <line6> (relation.getFrom().equals(typeId)) ? relation.getTo() : relation.getFrom(); <line7> CnATreeElement destination = elementMap.get(destinationTypeId); <line8> assertTrue( <line9> ""No element found with destination id: "" + destinationTypeId, <line10> destination != null || isIgnoredType(destinationTypeId)); <line11> if (destination != null) { <line12> String linkType = relation.getId(); <line13> CnALink link = createLink(element, destination, linkType); <line14> addToLinkMap(element, link); <line15> } else { <line16> } <line17> } <line18> } <line19> } <line20> "	<line15>, <line16>
6642	public class A { <line0> protected boolean poolHasHotFix(Connection conn, String hostIp, String hotFixUuid) { <line1> try { <line2> Map<Host, Host.Record> hosts = Host.getAllRecords(conn); <line3> for (Map.Entry<Host, Host.Record> entry : hosts.entrySet()) { <line4> Host.Record re = entry.getValue(); <line5> if (!re.address.equalsIgnoreCase(hostIp)) { <line6> continue; <line7> } <line8> Set<HostPatch> patches = re.patches; <line9> PoolPatch poolPatch = PoolPatch.getByUuid(conn, hotFixUuid); <line10> for (HostPatch patch : patches) { <line11> PoolPatch pp = patch.getPoolPatch(conn); <line12> if (pp != null && pp.equals(poolPatch) && patch.getApplied(conn)) { <line13> return true; <line14> } <line15> } <line16> } <line17> return false; <line18> } catch (UuidInvalid e) { <line19> } catch (Exception e) { <line20> } <line21> return false; <line22> } <line23> } <line24> 	<line13>, <line19>, <line20>
6643	"public class A { <line0> private static void copyFilesFromClasspath( <line1> String classpathPrefix, <line2> Path destinationDirectory, <line3> boolean removeClasspathPrefixFromFinalPath, <line4> List<String> excludePaths) { <line5> List<ClassLoader> classLoadersList = new LinkedList<>(); <line6> classLoadersList.add(ClasspathHelper.contextClassLoader()); <line7> Reflections reflections = <line8> new Reflections( <line9> new ConfigurationBuilder() <line10> .setScanners(new ResourcesScanner()) <line11> .setUrls( <line12> ClasspathHelper.forPackage( <line13> classpathPrefix, <line14> ClasspathHelper.contextClassLoader(), <line15> ClasspathHelper.staticClassLoader()))); <line16> Set<String> resources = reflections.getResources(Pattern.compile("".*"")); <line17> resources = <line18> resources.stream() <line19> .filter(r -> !shouldExclude(r, classpathPrefix, excludePaths)) <line20> .collect(Collectors.toSet()); <line21> for (String resource : resources) { <line22> InputStream originStream = <line23> RodaCoreFactory.class.getClassLoader().getResourceAsStream(resource); <line24> Path destinyPath; <line25> String resourceFileName = resource; <line26> resourceFileName = resourceFileName.replace(""::"", "":""); <line27> if (removeClasspathPrefixFromFinalPath) { <line28> destinyPath = <line29> destinationDirectory.resolve(resourceFileName.replaceFirst(classpathPrefix, """")); <line30> } else { <line31> destinyPath = destinationDirectory.resolve(resourceFileName); <line32> } <line33> try { <line34> Files.createDirectories(destinyPath.getParent()); <line35> Files.copy(originStream, destinyPath, StandardCopyOption.REPLACE_EXISTING); <line36> } catch (IOException e) { <line37> instantiatedWithoutErrors = false; <line38> } finally { <line39> RodaUtils.closeQuietly(originStream); <line40> } <line41> } <line42> } <line43> } <line44> "	<line21>, <line37>
6644	public class A { <line0> private void createPGChannels(List<JablotronSection> programmableGates) { <line1> for (JablotronSection gate : programmableGates) { <line2> String id = gate.getCloudComponentId().toLowerCase(); <line3> Channel channel = getThing().getChannel(id); <line4> if (channel == null) { <line5> createPGChannel(id, gate.getName()); <line6> } <line7> } <line8> } <line9> } <line10> 	<line3>, <line5>
6645	public class A { <line0> public DeviceStatus sendDeviceStatus(DeviceStatus deviceStatus) <line1> throws MelCloudCommException, MelCloudLoginException { <line2> connectIfNotConnected(); <line3> try { <line4> return connection.sendDeviceStatus(deviceStatus); <line5> } catch (MelCloudCommException e) { <line6> connect(); <line7> return connection.sendDeviceStatus(deviceStatus); <line8> } <line9> } <line10> } <line11> 	<line6>
6646	public class A { <line0> private void executeDatanode(HddsDatanodeService hdds, String[] args) { <line1> CommandLine cmd = hdds.getCmd(); <line2> IExceptionHandler2<List<Object>> exceptionHandler = <line3> new IExceptionHandler2<List<Object>>() { <line4> @Override <line5> public List<Object> handleParseException(ParameterException ex, String[] args) { <line6> throw ex; <line7> } <line8>  <line9> @Override <line10> public List<Object> handleExecutionException( <line11> ExecutionException ex, ParseResult parseResult) { <line12> throw ex; <line13> } <line14> }; <line15> cmd.parseWithHandlers(new RunLast(), exceptionHandler, args); <line16> } <line17> } <line18> 	<line1>
6647	"public class A { <line0> private String getDebugInfo(String exceptionMsg) { <line1> String debugInfoPattern = ""\\[\\[\\[(.*)\\]\\]\\]""; <line2> Pattern p = Pattern.compile(debugInfoPattern); <line3> Matcher m = p.matcher(exceptionMsg); <line4> String debugInfo = """"; <line5> if (m.find()) { <line6> debugInfo = m.group(1); <line7> } else { <line8> } <line9> return debugInfo; <line10> } <line11> } <line12> "	<line7>, <line8>
6648	public class A { <line0> @Override <line1> public void close() throws InterruptedException { <line2> try { <line3> for (LocalLogManager logManager : logManagers) { <line4> logManager.beginShutdown(); <line5> } <line6> for (LocalLogManager logManager : logManagers) { <line7> logManager.close(); <line8> } <line9> Utils.delete(dir); <line10> } catch (IOException e) { <line11> } <line12> } <line13> } <line14> 	<line11>
6649	"public class A { <line0> OnlineDetectionDataDTO doUpdateOnlineData( <line1> JsonNode payloadNode, <line2> DatasetConfigDTO datasetConfigDTO, <line3> MetricConfigDTO metricConfigDTO, <line4> OnlineDetectionDataDTO onlineDetectionDataDTO) <line5> throws JsonProcessingException { <line6> if (payloadNode.has(DATASET_FIELD)) { <line7> updateDatasetCustomFields(payloadNode, datasetConfigDTO); <line8> } <line9> if (payloadNode.has(METRIC_FIELD)) { <line10> updateMetricCustomFields(payloadNode, metricConfigDTO); <line11> onlineDetectionDataDTO.setMetric(metricConfigDTO.getName()); <line12> } <line13> JsonNode dataNode = payloadNode.get(DATA_FIELD); <line14> Preconditions.checkArgument( <line15> validateOnlineDetectionData( <line16> dataNode, datasetConfigDTO.getTimeColumn(), metricConfigDTO.getName()), <line17> String.format( <line18> ""metric: %s or time: %s not found in adhoc data."", <line19> metricConfigDTO.getName(), datasetConfigDTO.getTimeColumn())); <line20> onlineDetectionDataDTO.setOnlineDetectionData(this.objectMapper.writeValueAsString(dataNode)); <line21> datasetConfigDAO.update(datasetConfigDTO); <line22> metricConfigDAO.update(metricConfigDTO); <line23> onlineDetectionDataDAO.update(onlineDetectionDataDTO); <line24> return onlineDetectionDataDTO; <line25> } <line26> } <line27> "	<line8>, <line12>, <line24>
6650	public class A { <line0> public static double greatCircleDistanceR(LatLonAlt start, LatLonAlt end) { <line1> double startLat = start.getLatD() * MathUtil.DEG_TO_RAD; <line2> double startLon = start.getLonD() * MathUtil.DEG_TO_RAD; <line3> double endLat = end.getLatD() * MathUtil.DEG_TO_RAD; <line4> double endLon = end.getLonD() * MathUtil.DEG_TO_RAD; <line5> if (MathUtil.isZero(startLon - endLon) && MathUtil.isZero(startLat - endLat)) { <line6> return 0.; <line7> } <line8> double a = <line9> Math.sin((endLat - startLat) / 2.0) * Math.sin((endLat - startLat) / 2.0) <line10> + Math.cos(startLat) <line11> * Math.cos(endLat) <line12> * Math.sin((endLon - startLon) / 2.0) <line13> * Math.sin((endLon - startLon) / 2.0); <line14> double distanceRadians = 2.0 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); <line15> if (Double.isNaN(distanceRadians)) { <line16> return 0.; <line17> } <line18> return distanceRadians; <line19> } <line20> } <line21> 	<line16>
6651	"public class A { <line0> private void getServiceSchemaDcos( <line1> Integer level, String service, String model, String version, String envVar, String fileName) <line2> throws Exception { <line3> commonspec.setCCTConnection(null, null); <line4> if (level == null) { <line5> level = 1; <line6> } <line7> String endPoint = <line8> ""/service/"" <line9> + ThreadProperty.get(""deploy_api_id"") <line10> + ""/deploy/"" <line11> + service <line12> + ""/"" <line13> + model <line14> + ""/"" <line15> + version <line16> + ""/schema?enriched=true&level="" <line17> + level; <line18> Future<Response> response = <line19> commonspec.generateRequest(""GET"", false, null, null, endPoint, """", null); <line20> commonspec.setResponse(""GET"", response.get()); <line21> if (commonspec.getResponse().getStatusCode() != 200) { <line22> throw new Exception( <line23> ""Request to endpoint: "" <line24> + endPoint <line25> + "" failed with status code: "" <line26> + commonspec.getResponse().getStatusCode() <line27> + "" and response: "" <line28> + commonspec.getResponse().getResponse()); <line29> } <line30> String json = commonspec.getResponse().getResponse(); <line31> if (envVar != null || fileName != null) { <line32> DcosSpec dcosSpec = new DcosSpec(commonspec); <line33> dcosSpec.convertJSONSchemaToJSON(json, envVar, fileName); <line34> } <line35> } <line36> } <line37> "	<line22>
6652	public class A { <line0> public void cameraOffline(IpCameraHandler handle) { <line1> if (cameraOrder.remove(handle)) { <line2> } <line3> } <line4> } <line5> 	<line2>
6653	public class A { <line0> private @Nullable Group getGroup() { <line1> try { <line2> CBusNetworkHandler networkHandler = cBusNetworkHandler; <line3> if (networkHandler == null) { <line4> return null; <line5> } <line6> Network network = networkHandler.getNetwork(); <line7> if (network != null) { <line8> Application application = network.getApplication(applicationId); <line9> if (application == null) { <line10> return null; <line11> } <line12> return application.getGroup(groupId); <line13> } <line14> } catch (CGateException e) { <line15> } <line16> return null; <line17> } <line18> } <line19> 	<line10>, <line12>, <line15>
6654	public class A { <line0> public void deployJarsReceivedFromClusterConfiguration(ConfigurationResponse response) <line1> throws IOException, ClassNotFoundException { <line2> if (response == null) { <line3> return; <line4> } <line5> List<String> jarFileNames = <line6> response.getJarNames().values().stream().flatMap(Set::stream).collect(Collectors.toList()); <line7> if (!jarFileNames.isEmpty()) { <line8> JarDeploymentService jarDeploymentService = <line9> ClassPathLoader.getLatest().getJarDeploymentService(); <line10> Set<File> stagedJarFiles = getJarsFromLocator(response.getMember(), response.getJarNames()); <line11> for (File file : stagedJarFiles) { <line12> jarDeploymentService.undeployByFileName(file.getName()); <line13> jarDeploymentService.deploy(file); <line14> } <line15> } <line16> } <line17> } <line18> 	<line5>, <line8>, <line12>, <line14>
6655	"public class A { <line0> protected Set<String> getNamespaceReplicatedClusters(NamespaceName namespaceName) { <line1> try { <line2> final Policies policies = <line3> namespaceResources() <line4> .get(ZkAdminPaths.namespacePoliciesPath(namespaceName)) <line5> .orElseThrow(() -> new RestException(Status.NOT_FOUND, ""Namespace does not exist"")); <line6> return policies.replication_clusters; <line7> } catch (RestException re) { <line8> throw re; <line9> } catch (Exception e) { <line10> throw new RestException(e); <line11> } <line12> } <line13> } <line14> "	<line10>
6656	"public class A { <line0> public void store(String surveyName, File file) { <line1> try { <line2> File directory = getSuveyBackupStorageDirectory(surveyName); <line3> directory.mkdir(); <line4> String fileName = createNewBackupFileName(surveyName); <line5> File newFile = new File(directory, fileName); <line6> if (newFile.createNewFile()) { <line7> FileUtils.copyFile(file, newFile); <line8> } else { <line9> throw new RuntimeException( <line10> ""Cannot create file or file already exists: "" + newFile.getAbsolutePath()); <line11> } <line12> } catch (IOException e) { <line13> throw new RuntimeException(e); <line14> } <line15> } <line16> } <line17> "	<line13>
6657	public class A { <line0> private XmlParser getDelegate(final String namespaceUri) { <line1> XmlParser delegate = delegates.get(namespaceUri); <line2> if (null == delegate) { <line3> try { <line4> final ServiceLoader<XmlParser> serviceLoader = <line5> ServiceLoader.load(XmlParser.class, ClassPathLoader.getLatestAsClassLoader()); <line6> for (final XmlParser xmlParser : serviceLoader) { <line7> if (xmlParser.getNamespaceUri().equals(namespaceUri)) { <line8> delegate = xmlParser; <line9> delegate.setStack(stack); <line10> delegate.setDocumentLocator(documentLocator); <line11> delegates.put(xmlParser.getNamespaceUri(), xmlParser); <line12> break; <line13> } <line14> } <line15> } catch (final Exception e) { <line16> } <line17> } <line18> return delegate; <line19> } <line20> } <line21> 	<line16>
6658	"public class A { <line0> private String getGrafanaCurrentOrg(Map<String, String> headers) throws InsightsCustomException { <line1> String grafanaCurrentOrgResponse = grafanaHandler.grafanaGet(""/api/user"", headers); <line2> JsonObject responseJson = new JsonParser().parse(grafanaCurrentOrgResponse).getAsJsonObject(); <line3> String grafanaCurrentOrg = responseJson.get(""orgId"").toString(); <line4> return grafanaCurrentOrg; <line5> } <line6> } <line7> "	<line1>, <line4>
6659	"public class A { <line0> default boolean isCarrierConnectionAvailable() { <line1> AndroidService androidService = AndroidService.getInstance(); <line2> boolean status = ((AndroidDriver) this.castDriver()).getConnection().isDataEnabled(); <line3> boolean linkProperties = false; <line4> String linkProp = <line5> androidService.executeAdbCommand( <line6> ""shell dumpsys telephony.registry | grep mPreciseDataConnectionState""); <line7> if (!linkProp.isEmpty()) { <line8> linkProperties = !StringUtils.substringBetween(linkProp, ""APN: "", "" "").equals(""null""); <line9> } <line10> return ((AndroidDriver) this.castDriver()).getConnection().isDataEnabled() && linkProperties; <line11> } <line12> } <line13> "	<line7>, <line10>
6660	"public class A { <line0> public static void addTblMetaCommitLag(MigrationContext migrationContext) { <line1> Path path = migrationContext.getTablePath(); <line2> final FilesFacade ff = migrationContext.getFf(); <line3> path.concat(META_FILE_NAME).$(); <line4> if (!ff.exists(path)) { <line5> return; <line6> } <line7> long tempMem = migrationContext.getTempMemory(8); <line8> Unsafe.getUnsafe().putInt(tempMem, migrationContext.getConfiguration().getMaxUncommittedRows()); <line9> if (ff.write( <line10> migrationContext.metadataFd, tempMem, Integer.BYTES, META_OFFSET_MAX_UNCOMMITTED_ROWS) <line11> != Integer.BYTES) { <line12> throw CairoException.instance(ff.errno()) <line13> .put(""Cannot update metadata [path="") <line14> .put(path) <line15> .put(']'); <line16> } <line17> Unsafe.getUnsafe().putLong(tempMem, migrationContext.getConfiguration().getCommitLag()); <line18> if (ff.write(migrationContext.metadataFd, tempMem, Long.BYTES, META_OFFSET_COMMIT_LAG) <line19> != Long.BYTES) { <line20> throw CairoException.instance(ff.errno()) <line21> .put(""Cannot update metadata [path="") <line22> .put(path) <line23> .put(']'); <line24> } <line25> } <line26> } <line27> "	<line5>
6661	public class A { <line0> protected void nudgeQueue() { <line1> int n = Math.min(5, size()); <line2> if (n == 0) { <line3> return; <line4> } <line5> for (int i = 0; i < n; i++) { <line6> Message msg = !prioritized.isEmpty() ? prioritized.poll() : queue.poll(); <line7> ctx.write(msg).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE); <line8> } <line9> ctx.flush(); <line10> } <line11> } <line12> 	<line7>
6662	public class A { <line0> @Override <line1> public Optional<TagSummary> load(@Nonnull final String source) throws Exception { <line2> final Optional<TagSummary> result = tagForSource(source); <line3> if (!result.isPresent()) { <line4> } <line5> return result; <line6> } <line7> } <line8> 	<line4>
6663	"public class A { <line0> @SuppressWarnings(""WeakerAccess"") <line1> public void saveAndPublishJobStatus(JobModel jobModel) throws Exception { <line2> try { <line3> JobStatus jobStatus; <line4> if (jobModel.getJobStatuses() != null && jobModel.getJobStatuses().size() > 0) { <line5> jobStatus = jobModel.getJobStatuses().get(0); <line6> } else { <line7> return; <line8> } <line9> List<JobStatus> statuses = new ArrayList<>(); <line10> statuses.add(jobStatus); <line11> jobModel.setJobStatuses(statuses); <line12> if (jobStatus.getTimeOfStateChange() == 0 || jobStatus.getTimeOfStateChange() > 0) { <line13> jobStatus.setTimeOfStateChange(AiravataUtils.getCurrentTimestamp().getTime()); <line14> } else { <line15> jobStatus.setTimeOfStateChange(jobStatus.getTimeOfStateChange()); <line16> } <line17> getRegistryServiceClient().addJobStatus(jobStatus, jobModel.getTaskId(), jobModel.getJobId()); <line18> } catch (Exception e) { <line19> throw new Exception(""Error persisting job status "" + e.getLocalizedMessage(), e); <line20> } <line21> } <line22> } <line23> "	<line7>
6664	"public class A { <line0> @Override <line1> @SecurityCheck <line2> public String addCloudJobSubmissionDetails( <line3> AuthzToken authzToken, <line4> String computeResourceId, <line5> int priorityOrder, <line6> CloudJobSubmission cloudJobSubmission) <line7> throws InvalidRequestException, AiravataClientException, AiravataSystemException, <line8> AuthorizationException, TException { <line9> RegistryService.Client regClient = registryClientPool.getResource(); <line10> try { <line11> String result = <line12> regClient.addCloudJobSubmissionDetails( <line13> computeResourceId, priorityOrder, cloudJobSubmission); <line14> registryClientPool.returnResource(regClient); <line15> return result; <line16> } catch (Exception e) { <line17> AiravataSystemException exception = new AiravataSystemException(); <line18> exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR); <line19> exception.setMessage( <line20> ""Error while adding job submission interface to resource compute resource. More info : "" <line21> + e.getMessage()); <line22> registryClientPool.returnBrokenResource(regClient); <line23> throw exception; <line24> } <line25> } <line26> } <line27> "	<line17>
6665	public class A { <line0> @Override <line1> public void initialize(Configuration conf, Properties tbl) throws SerDeException { <line2> List<TypeInfo> columnTypes; <line3> StructTypeInfo rowTypeInfo; <line4> String columnNameProperty = tbl.getProperty(serdeConstants.LIST_COLUMNS); <line5> String columnTypeProperty = tbl.getProperty(serdeConstants.LIST_COLUMN_TYPES); <line6> final String columnNameDelimiter = <line7> tbl.containsKey(serdeConstants.COLUMN_NAME_DELIMITER) <line8> ? tbl.getProperty(serdeConstants.COLUMN_NAME_DELIMITER) <line9> : String.valueOf(SerDeUtils.COMMA); <line10> if (columnNameProperty.isEmpty()) { <line11> columnNames = new ArrayList<>(0); <line12> } else { <line13> columnNames = new ArrayList<>(Arrays.asList(columnNameProperty.split(columnNameDelimiter))); <line14> } <line15> if (columnTypeProperty.isEmpty()) { <line16> columnTypes = new ArrayList<>(0); <line17> } else { <line18> columnTypes = TypeInfoUtils.getTypeInfosFromTypeString(columnTypeProperty); <line19> } <line20> assert (columnNames.size() == columnTypes.size()); <line21> rowTypeInfo = (StructTypeInfo) TypeInfoFactory.getStructTypeInfo(columnNames, columnTypes); <line22> schema = rowTypeInfo; <line23> cachedObjectInspector = <line24> (StandardStructObjectInspector) <line25> TypeInfoUtils.getStandardJavaObjectInspectorFromTypeInfo(rowTypeInfo); <line26> tsParser = <line27> new TimestampParser( <line28> HiveStringUtils.splitAndUnEscape(tbl.getProperty(serdeConstants.TIMESTAMP_FORMATS))); <line29> stats = new SerDeStats(); <line30> } <line31> } <line32> 	<line4>, <line20>, <line23>
6666	public class A { <line0> public <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> key) { <line1> if (container.canProvide(key)) { <line2> return container.instanceFor(key); <line3> } <line4> return new ReflectionInstanceCreator().instanceFor(key); <line5> } <line6> } <line7> 	<line2>
6667	"public class A { <line0> @Override <line1> public List<Document> processDocument(Document doc) { <line2> String title = doc.getId(); <line3> if (!doc.hasField(input)) { <line4> return null; <line5> } <line6> String wikiText = doc.getField(input).get(0).toString(); <line7> try { <line8> PageTitle pageTitle = PageTitle.make(wikiConfig, title); <line9> PageId pageId = new PageId(pageTitle, -1); <line10> EngProcessedPage cp = engine.postprocess(pageId, wikiText, null); <line11> TextConverter p = new TextConverter(wikiConfig, 132, doc); <line12> String result = (String) p.go(cp.getPage()); <line13> doc.setField(output, result); <line14> List<Document> children = p.getChildrenDocs(); <line15> int i = 0; <line16> for (Document d : children) { <line17> String childId = doc.getId() + ""_infobox_"" + i; <line18> d.setId(childId); <line19> i++; <line20> } <line21> p = null; <line22> return children; <line23> } catch (Exception e) { <line24> e.printStackTrace(); <line25> } <line26> return null; <line27> } <line28> } <line29> "	<line4>, <line24>
6668	"public class A { <line0> public void testSelectionRange2() throws Exception { <line1> String req = ""{\""selections\"":[{\""range\"":{\""groupid_range\"":{\""to\"":\""10\""}}}]}""; <line2> JSONObject res = TestSensei.search(new JSONObject(req)); <line3> assertEquals(""numhits is wrong"", 20, res.getInt(""numhits"")); <line4> } <line5> } <line6> "	<line1>
6669	public class A { <line0> public Object decode(CachedData d) { <line1> byte[] data = d.getData(); <line2> Object rv = null; <line3> if ((d.getFlag() & COMPRESSED) != 0) { <line4> data = decompress(d.getData()); <line5> } <line6> if ((d.getFlag() & SERIALIZED) != 0) { <line7> rv = deserialize(data); <line8> } else { <line9> int f = d.getFlag() & ~COMPRESSED; <line10> if (this.primitiveAsString) { <line11> if (f == SPECIAL_STRING) { <line12> return decodeString(d.getData()); <line13> } <line14> } <line15> switch (f) { <line16> case SPECIAL_BOOLEAN: <line17> rv = Boolean.valueOf(this.decodeBoolean(data)); <line18> break; <line19> case SPECIAL_INT: <line20> rv = Integer.valueOf(this.tu.decodeInt(data)); <line21> break; <line22> case SPECIAL_SHORT: <line23> rv = Short.valueOf((short) this.tu.decodeInt(data)); <line24> break; <line25> case SPECIAL_LONG: <line26> rv = Long.valueOf(this.tu.decodeLong(data)); <line27> break; <line28> case SPECIAL_DATE: <line29> rv = new Date(this.tu.decodeLong(data)); <line30> break; <line31> case SPECIAL_BYTE: <line32> rv = Byte.valueOf(this.tu.decodeByte(data)); <line33> break; <line34> case SPECIAL_FLOAT: <line35> rv = new Float(Float.intBitsToFloat(this.tu.decodeInt(data))); <line36> break; <line37> case SPECIAL_DOUBLE: <line38> rv = new Double(Double.longBitsToDouble(this.tu.decodeLong(data))); <line39> break; <line40> case SPECIAL_BYTEARRAY: <line41> rv = data; <line42> break; <line43> case SPECIAL_STRING: <line44> rv = decodeString(data); <line45> break; <line46> case SPECIAL_STRINGBUFFER: <line47> rv = new StringBuffer(decodeString(data)); <line48> break; <line49> case SPECIAL_STRINGBUILDER: <line50> rv = new StringBuilder(decodeString(data)); <line51> break; <line52> case SPECIAL_CHARACTER: <line53> rv = decodeCharacter(data); <line54> break; <line55> default: <line56> } <line57> } <line58> return rv; <line59> } <line60> } <line61> 	<line56>
6670	"public class A { <line0> public static void main(final String[] args) throws Exception { <line1> final Properties prop = <line2> args.length > 0 ? RemoteUtils.loadProps(args[args.length - 1]) : new Properties(); <line3> int port; <line4> try { <line5> port = Integer.parseInt(prop.getProperty(""registry.port"")); <line6> } catch (final NumberFormatException ex) { <line7> port = Registry.REGISTRY_PORT; <line8> } <line9> if (args.length > 0 && args[0].toLowerCase().indexOf(""-shutdown"") != -1) { <line10> try { <line11> final ICacheServiceAdmin admin = lookupCacheServiceAdmin(prop, port); <line12> admin.shutdown(); <line13> } catch (final Exception ex) { <line14> } <line15> log.debug(""done.""); <line16> System.exit(0); <line17> } <line18> if (args.length > 0 && args[0].toLowerCase().indexOf(""-stats"") != -1) { <line19> try { <line20> final ICacheServiceAdmin admin = lookupCacheServiceAdmin(prop, port); <line21> try { <line22> } catch (final IOException es) { <line23> } <line24> } catch (final Exception ex) { <line25> } <line26> System.exit(0); <line27> } <line28> final String hostName = prop.getProperty(""registry.host""); <line29> final InetAddress host = InetAddress.getByName(hostName); <line30> if (host.isLoopbackAddress()) { <line31> RemoteUtils.createRegistry(port); <line32> } <line33> startup(host.getHostName(), port, prop); <line34> } <line35> } <line36> "	<line14>, <line19>, <line22>, <line23>, <line25>, <line26>, <line31>, <line33>, <line34>
6671	public class A { <line0> @Override <line1> protected void readSubscriptionData( <line2> final ByteString topic, <line3> final ByteString subscriberId, <line4> final Callback<InMemorySubscriptionState> cb, <line5> final Object ctx) { <line6> subManager.readSubscriptionData( <line7> topic, <line8> subscriberId, <line9> new Callback<Versioned<SubscriptionData>>() { <line10> @Override <line11> public void operationFinished(Object ctx, Versioned<SubscriptionData> subData) { <line12> if (null != subData) { <line13> if (logger.isDebugEnabled()) { <line14> } <line15> cb.operationFinished( <line16> ctx, new InMemorySubscriptionState(subData.getValue(), subData.getVersion())); <line17> } else { <line18> cb.operationFinished( <line19> ctx, <line20> new InMemorySubscriptionState( <line21> SubscriptionData.getDefaultInstance(), Version.NEW)); <line22> } <line23> } <line24>  <line25> @Override <line26> public void operationFailed(Object ctx, PubSubException exception) { <line27> cb.operationFailed(ctx, exception); <line28> } <line29> }, <line30> ctx); <line31> } <line32> } <line33> 	<line14>, <line27>
6672	public class A { <line0> private void assertIsInvalid(String text) throws Exception { <line1> try { <line2> parse(text); <line3> assertFalse(true); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	<line1>, <line5>
6673	public class A { <line0> private String getApplicationId(AgentInfo agentInfo, String agentId) { <line1> if (agentInfo == null) { <line2> return NOT_FOUND_APP_ID; <line3> } <line4> return agentInfo.getApplicationName(); <line5> } <line6> } <line7> 	<line2>
6674	"public class A { <line0> @Test(timeout = 30000) <line1> public void testSentTransactionalMessageIsSettleWithTransactionalDisposition() throws Exception { <line2> AmqpClient client = createAmqpClient(); <line3> AmqpConnection connection = addConnection(client.connect()); <line4> AmqpSession session = connection.createSession(); <line5> assertNotNull(session); <line6> AmqpSender sender = session.createSender(getQueueName()); <line7> sender.setStateInspector( <line8> new AmqpValidator() { <line9> @Override <line10> public void inspectDeliveryUpdate(Sender sender, Delivery delivery) { <line11> if (delivery.remotelySettled()) { <line12> DeliveryState state = delivery.getRemoteState(); <line13> if (state instanceof TransactionalState) { <line14> } else { <line15> markAsInvalid(""Remote did not settled with TransactionState.""); <line16> } <line17> } <line18> } <line19> }); <line20> session.begin(); <line21> assertTrue(session.isInTransaction()); <line22> AmqpMessage message = new AmqpMessage(); <line23> message.setText(""Test-Message""); <line24> sender.send(message); <line25> session.commit(); <line26> sender.getStateInspector().assertValid(); <line27> connection.close(); <line28> } <line29> } <line30> "	<line14>, <line15>
6675	"public class A { <line0> private static void callStaticInitMethods() <line1> throws InvocationTargetException, IllegalAccessException { <line2> List<Method> inits = new ArrayList<>(reflections.getMethodsAnnotatedWith(StaticInit.class)); <line3> inits.sort( <line4> (o1, o2) -> { <line5> StaticInit a1 = o1.getAnnotation(StaticInit.class); <line6> StaticInit a2 = o2.getAnnotation(StaticInit.class); <line7> return a2.order() - a1.order(); <line8> }); <line9> for (Method init : inits) { <line10> if (!Modifier.isStatic(init.getModifiers())) { <line11> throw new CloudRuntimeException( <line12> String.format( <line13> ""the method[%s:%s] annotated by @StaticInit is not a static method"", <line14> init.getDeclaringClass(), init.getName())); <line15> } <line16> init.setAccessible(true); <line17> init.invoke(null); <line18> } <line19> } <line20> } <line21> "	<line16>
6676	public class A { <line0> public ScriptEngine getScriptEngine() { <line1> try { <line2> return atlasGraph.getGremlinScriptEngine(); <line3> } catch (AtlasBaseException e) { <line4> } <line5> return null; <line6> } <line7> } <line8> 	<line4>
6677	public class A { <line0> @PUT <line1> public Response generate() { <line2> Response response = null; <line3> try { <line4> SshKeyPair sshKeypair = karamelApi.generateSshKeysAndUpdateConf(); <line5> karamelApi.registerSshKeys(sshKeypair); <line6> response = Response.status(Response.Status.OK).entity(sshKeypair).build(); <line7> } catch (KaramelException ex) { <line8> response = buildExceptionResponse(ex); <line9> } <line10> return response; <line11> } <line12> } <line13> 	<line3>
6678	public class A { <line0> @Override <line1> public void doClose() { <line2> subscribedStream.removeSubscriber(this); <line3> try { <line4> serverSocket.close(); <line5> } catch (IOException e) { <line6> } <line7> if (socket != null) { <line8> try { <line9> socket.close(); <line10> } catch (IOException e) { <line11> } <line12> } <line13> } <line14> } <line15> 	<line6>, <line11>
6679	"public class A { <line0> @SuppressWarnings(""squid:S2445"") <line1> public void registerTsFileProcessor(TsFileProcessor tsFileProcessor) { <line2> synchronized (tsFileProcessor) { <line3> if (tsFileProcessor.isManagedByFlushManager()) { <line4> } else { <line5> if (tsFileProcessor.getFlushingMemTableSize() > 0) { <line6> tsFileProcessorQueue.add(tsFileProcessor); <line7> if (LOGGER.isDebugEnabled()) { <line8> } <line9> tsFileProcessor.setManagedByFlushManager(true); <line10> flushPool.submit(new FlushThread()); <line11> } else { <line12> if (LOGGER.isDebugEnabled()) { <line13> } <line14> } <line15> } <line16> } <line17> } <line18> } <line19> "	<line4>, <line8>, <line13>
6680	"public class A { <line0> @Override <line1> public Collection<CustomerInvoiceDocument> getCustomerInvoiceDocumentsByCustomerNumber( <line2> String customerNumber) { <line3> Collection<CustomerInvoiceDocument> invoices = new ArrayList<CustomerInvoiceDocument>(); <line4> Map<String, String> fieldValues = new HashMap<String, String>(); <line5> fieldValues.put(""customerNumber"", customerNumber); <line6> Collection<AccountsReceivableDocumentHeader> documentHeaders = <line7> businessObjectService.findMatching(AccountsReceivableDocumentHeader.class, fieldValues); <line8> List<String> documentHeaderIds = new ArrayList<String>(); <line9> for (AccountsReceivableDocumentHeader header : documentHeaders) { <line10> documentHeaderIds.add(header.getDocumentHeader().getDocumentNumber()); <line11> } <line12> if (0 < documentHeaderIds.size()) { <line13> try { <line14> for (Document doc : <line15> documentService.getDocumentsByListOfDocumentHeaderIds( <line16> CustomerInvoiceDocument.class, documentHeaderIds)) { <line17> invoices.add((CustomerInvoiceDocument) doc); <line18> } <line19> } catch (WorkflowException e) { <line20> } <line21> } <line22> return invoices; <line23> } <line24> } <line25> "	<line20>
6681	"public class A { <line0> @Override <line1> public void run() { <line2> currentWrite = this; <line3> try { <line4> final OutputStream out = serialPort.getOutputStream(); <line5> if (out == null) { <line6> throw new IOException(""serial port is not writable""); <line7> } <line8> for (int tries = 0; tries < MAX_RETRIES && ack == null; tries++) { <line9> out.write(0x14); <line10> out.write(msg.getBytes(US_ASCII)); <line11> out.write(0x0d); <line12> out.flush(); <line13> final boolean acked = ackLatch.await(ACK_TIMEOUT_MS, MILLISECONDS); <line14> if (acked) { <line15> break; <line16> } <line17> } <line18> final Boolean ack = this.ack; <line19> if (ack == null) { <line20> completion.complete(CmdStatus.WRITE_FAILED); <line21> } else if (ack) { <line22> completion.complete(CmdStatus.ACK); <line23> } else { <line24> completion.complete(CmdStatus.NAK); <line25> } <line26> } catch (final IOException | InterruptedException e) { <line27> completion.complete(CmdStatus.WRITE_FAILED); <line28> } <line29> } <line30> } <line31> "	<line4>, <line17>, <line20>, <line27>
6682	"public class A { <line0> @Override <line1> public void onSuccess(List<FieldDesc> result) { <line2> helpPanel.clear(); <line3> final SafeHtmlBuilder html = new SafeHtmlBuilder(); <line4> html.appendHtmlConstant(""<table class='help-attribute-descriptions'>""); <line5> if (result.isEmpty()) { <line6> html.appendHtmlConstant(""<tr class='help-field-row'>""); <line7> html.appendHtmlConstant(""<td class='help-field-name' colspan=2>""); <line8> html.appendEscaped(Console.CONSTANTS.attributeDescriptionsNotAvailable()); <line9> html.appendHtmlConstant(""</td>""); <line10> html.appendHtmlConstant(""</tr>""); <line11> } else { <line12> for (int i = 0; i < result.size(); i++) { <line13> FieldDesc field = result.get(i); <line14> if (i < result.size() - 1) html.appendHtmlConstant(""<tr class='help-field-row'>""); <line15> else html.appendHtmlConstant(""<tr class='help-field-row-last'>""); <line16> html.appendHtmlConstant(""<td class='help-field-name'>""); <line17> String ref = field.getRef(); <line18> String title = form.getFormItemTitle(ref); <line19> html.appendEscaped(title).appendEscaped("": ""); <line20> html.appendHtmlConstant(""</td>""); <line21> html.appendHtmlConstant(""<td class='help-field-desc'>""); <line22> try { <line23> html.appendEscaped(field.getDesc()); <line24> } catch (Throwable e) { <line25> html.appendHtmlConstant(""<i>"" + Console.CONSTANTS.failedToParseDescription() + ""</i>""); <line26> } <line27> html.appendHtmlConstant(""</td>""); <line28> html.appendHtmlConstant(""</tr>""); <line29> } <line30> } <line31> html.appendHtmlConstant(""</table>""); <line32> helpPanel.add(new HTML(html.toSafeHtml())); <line33> hasBeenBuild = true; <line34> } <line35> } <line36> "	<line6>
6683	public class A { <line0> public String getValidOid(CRFVersionBean crfVersion, String crfName, String crfVersionName) { <line1> String oid = getOid(crfVersion, crfName, crfVersionName); <line2> String oidPreRandomization = oid; <line3> while (findAllByOid(oid).size() > 0) { <line4> oid = crfVersion.getOidGenerator().randomizeOid(oidPreRandomization); <line5> } <line6> return oid; <line7> } <line8> } <line9> 	<line2>
6684	public class A { <line0> protected void assertImageContent(String result) { <line1> assertNotNull(result); <line2> assertFalse(result.isEmpty()); <line3> } <line4> } <line5> 	<line1>
6685	public class A { <line0> @Override <line1> public void run(MessageReply reply) { <line2> if (!reply.isSuccess()) { <line3> } else { <line4> } <line5> } <line6> } <line7> 	<line3>, <line4>
6686	public class A { <line0> @Test <line1> public void shouldHaveNoBookErrors() { <line2> streamingMarketDataService <line3> .getOrderBook(xbtUsd) <line4> .test() <line5> .assertSubscribed() <line6> .assertNoErrors() <line7> .awaitCount(10) <line8> .assertNever( <line9> book -> { <line10> String err = BookSanityChecker.hasErrors(book); <line11> return err != null; <line12> }) <line13> .assertNoTimeout() <line14> .dispose(); <line15> } <line16> } <line17> 	<line11>
6687	public class A { <line0> public static CPE findEntryForBinaryRoot(IClasspath cp, File binaryClasspathtRoot) { <line1> try { <line2> for (CPE cpe : cp.getClasspathEntries()) { <line3> if (correspondsToBinaryLocation(cpe, binaryClasspathtRoot)) { <line4> return cpe; <line5> } <line6> } <line7> } catch (Exception e) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	<line8>
6688	"public class A { <line0> @Override <line1> public StageResult processAckOnMain(List<DistStageAck> acks) { <line2> StageResult result = super.processAckOnMain(acks); <line3> if (result.isError()) return result; <line4> boolean anyValueChangeDetected = false; <line5> for (ChangeAck ack : instancesOf(acks, ChangeAck.class)) { <line6> log.debugf( <line7> ""Value change detected on worker %d: %s"", ack.getWorkerIndex(), ack.valueChangeDetected); <line8> if (expectedLevel.equalsIgnoreCase(REPEATABLE_READ) && ack.valueChangeDetected) { <line9> return errorResult(); <line10> } <line11> anyValueChangeDetected |= ack.valueChangeDetected; <line12> } <line13> if (expectedLevel.equalsIgnoreCase(READ_COMMITTED) && !anyValueChangeDetected) { <line14> return errorResult(); <line15> } <line16> return StageResult.SUCCESS; <line17> } <line18> } <line19> "	<line9>, <line14>
6689	public class A { <line0> @Override <line1> public TableLayoutDesc apply(final KijiTableLayout refLayout) { <line2> Preconditions.checkNotNull(refLayout); <line3> try { <line4> final TableLayoutDesc refDesc = refLayout.getDesc(); <line5> return new TableLayoutBuilder(refDesc, kiji) <line6> .withLayoutId(nextLayoutId(refDesc.getLayoutId())) <line7> .withWriter(column, writerSchema) <line8> .withWritten(column, writerSchema) <line9> .build(); <line10> } catch (InvalidLayoutException ile) { <line11> throw new InternalKijiError(ile); <line12> } catch (IOException ioe) { <line13> throw new KijiIOException(ioe); <line14> } <line15> } <line16> } <line17> 	<line11>, <line13>
6690	"public class A { <line0> @Override <line1> @Transactional <line2> public void deleteUser(PrincipalUser user) { <line3> requireNotDisposed(); <line4> requireArgument( <line5> user != null && user.getId() != null && user.getId().compareTo(ZERO) > 0, <line6> ""User cannot be null and must have a valid ID.""); <line7> EntityManager em = emf.get(); <line8> deleteEntity(em, user); <line9> em.flush(); <line10> } <line11> } <line12> "	<line7>
6691	public class A { <line0> @Override <line1> public void onValueChange(ValueChangeEvent<String> event) { <line2> HistoryToken newHistoryToken = HistoryToken.fromTokenString(event.getValue()); <line3> processForDocumentListPresenter(newHistoryToken); <line4> processForProjectWideSearch(newHistoryToken); <line5> configHolder.setFilterByUntranslated(newHistoryToken.isFilterUntranslated()); <line6> configHolder.setFilterByFuzzy(newHistoryToken.isFilterFuzzy()); <line7> configHolder.setFilterByTranslated(newHistoryToken.isFilterTranslated()); <line8> configHolder.setFilterByApproved(newHistoryToken.isFilterApproved()); <line9> configHolder.setFilterByRejected(newHistoryToken.isFilterRejected()); <line10> configHolder.setFilterByHasError(newHistoryToken.isFilterHasError()); <line11> configHolder.setFilterByMT(newHistoryToken.isFilterMT()); <line12> DocumentId documentId = documentListPresenter.getDocumentId(newHistoryToken.getDocumentPath()); <line13> EditorFilter editorFilter = getEditorFilterFromToken(newHistoryToken); <line14> if (!getTransUnitActionContextHolder.isContextInitialized() && documentId != null) { <line15> DocumentInfo documentInfo = documentListPresenter.getDocumentInfo(documentId); <line16> Long textFlowId = newHistoryToken.getTextFlowId(); <line17> TransUnitId transUnitId = textFlowId == null ? null : new TransUnitId(textFlowId); <line18> getTransUnitActionContextHolder.initContext(documentInfo, transUnitId, editorFilter); <line19> eventBus.fireEvent(new InitEditorEvent()); <line20> } <line21> processForAppPresenter(documentId); <line22> processForBookmarkedTextFlow(newHistoryToken); <line23> processMessageFilterOptions(newHistoryToken); <line24> currentHistoryState = newHistoryToken; <line25> appPresenter.showView(newHistoryToken.getView()); <line26> } <line27> } <line28> 	<line3>
6692	public class A { <line0> private String getDate(String value) { <line1> try { <line2> return FormInputParser.dateToString(new java.sql.Date(Long.parseLong(value))); <line3> } catch (NumberFormatException | AssertException e) { <line4> return value; <line5> } <line6> } <line7> } <line8> 	<line4>
6693	"public class A { <line0> @Override <line1> public String run() { <line2> String name = fromSystemEnv(); <line3> if (name != null) { <line4> return name; <line5> } <line6> name = fromSystemProperty(); <line7> if (name != null) { <line8> return name; <line9> } <line10> name = fromApplicationContext(); <line11> if (name != null) { <line12> return name; <line13> } <line14> return ""development""; <line15> } <line16> } <line17> "	<line4>, <line8>, <line12>, <line14>
6694	"public class A { <line0> public void end() { <line1> keepRunning = false; <line2> for (int i = 0; i < size; i++) { <line3> if (Boolean.FALSE.equals(responses.get(i))) { <line4> System.err.println(""missing id="" + i); <line5> } <line6> assert (Boolean.TRUE.equals(responses.get(i))); <line7> } <line8> } <line9> } <line10> "	<line8>
6695	"public class A { <line0> @Override <line1> public Object getResult(CallableStatement arg0, int arg1) throws SQLException { <line2> throw new RuntimeException( <line3> ""getResult(CallableStatement,...) method in PropertiesTypeHandler is not implemented!""); <line4> } <line5> } <line6> "	<line2>
6696	"public class A { <line0> @Test <line1> public void test_02_INV_fusion() { <line2> String genome = ""testHg19Chr2""; <line3> String vcf = path(""test_fusion_EML4-ALK.vcf""); <line4> String args[] = {""-noLog"", ""-ud"", ""0"", genome, vcf}; <line5> SnpEff snpEff = new SnpEff(args); <line6> snpEff.setVerbose(verbose); <line7> snpEff.setSupressOutput(!verbose); <line8> snpEff.setDebug(debug); <line9> SnpEffCmdEff seff = (SnpEffCmdEff) snpEff.cmd(); <line10> boolean checked = false; <line11> List<VcfEntry> vcfEntries = seff.run(true); <line12> for (VcfEntry ve : vcfEntries) { <line13> for (VcfEffect veff : ve.getVcfEffects()) { <line14> if (veff.getEffectType() == EffectType.GENE_FUSION) { <line15> Assert.assertEquals(EffectImpact.HIGH, veff.getImpact()); <line16> Assert.assertEquals(veff.getGeneId(), ""ALK&EML4""); <line17> checked = true; <line18> } <line19> } <line20> } <line21> Assert.assertTrue(""No translocation found"", checked); <line22> } <line23> } <line24> "	<line2>, <line13>, <line14>
6697	public class A { <line0> public APIResult delete(LensSessionHandle sessionid, String entityName, Boolean cascade) <line1> throws LensException { <line2> checkSessionId(sessionid); <line3> doDelete(sessionid, entityName, cascade); <line4> return success(); <line5> } <line6> } <line7> 	<line2>
6698	"public class A { <line0> @Override <line1> public void terminateAll() { <line2> this.terminate = true; <line3> this.dead.terminate(); <line4> try { <line5> Thread.sleep(DeadlineThread.getMaxDeadlineInterval()); <line6> } catch (InterruptedException ie) { <line7> Thread.currentThread().interrupt(); <line8> } <line9> synchronized (this.vmsToDelete) { <line10> for (VM vm : this.vmsToDelete) { <line11> try { <line12> poweroff(vm); <line13> } catch (Exception e) { <line14> LOGGER.error( <line15> ""ERROR: Exception while trying to destroy the virtual machine "" + vm.getName(), e); <line16> } <line17> this.vmsToDelete.clear(); <line18> } <line19> } <line20> synchronized (this.ip2vm) { <line21> for (VM vm : this.ip2vm.values()) { <line22> vm.getWorker().disableExecution(); <line23> vm.getWorker().retrieveTracingAndDebugData(); <line24> Semaphore sem = new Semaphore(0); <line25> ShutdownListener sl = new ShutdownListener(sem); <line26> vm.getWorker().stop(sl); <line27> sl.enable(); <line28> try { <line29> sem.acquire(); <line30> } catch (Exception e) { <line31> } <line32> try { <line33> destroy(vm.getEnvId()); <line34> } catch (Exception e) { <line35> } <line36> } <line37> this.ip2vm.clear(); <line38> } <line39> synchronized (this.vmsAlive) { <line40> this.vmsAlive.clear(); <line41> } <line42> close(); <line43> } <line44> } <line45> "	<line22>, <line24>, <line31>, <line35>
6699	public class A { <line0> protected <T> T getProperty( <line1> String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) { <line2> if (this.propertySources != null) { <line3> for (PropertySource<?> propertySource : this.propertySources) { <line4> if (logger.isTraceEnabled()) { <line5> } <line6> Object value = propertySource.getProperty(key); <line7> if (value != null) { <line8> if (resolveNestedPlaceholders && value instanceof String) { <line9> value = resolveNestedPlaceholders((String) value); <line10> } <line11> logKeyFound(key, propertySource, value); <line12> return convertValueIfNecessary(value, targetValueType); <line13> } <line14> } <line15> } <line16> if (logger.isDebugEnabled()) { <line17> } <line18> return null; <line19> } <line20> } <line21> 	<line5>, <line17>
6700	public class A { <line0> private void bust(StreamingWeakReference ghost) { <line1> try { <line2> if (STREAMING_VERBOSE) { <line3> CursorProvider innerDelegate = unwrap(ghost.janitor.provider); <line4> Optional<ComponentLocation> originatingLocation = <line5> ghost.janitor.provider.getOriginatingLocation(); <line6> } <line7> ghost.dispose(); <line8> } catch (Exception e) { <line9> if (LOGGER.isWarnEnabled()) { <line10> } <line11> } finally { <line12> ghost.clear(); <line13> } <line14> } <line15> } <line16> 	<line6>, <line10>
6701	public class A { <line0> @Override <line1> public MutableAcl updateAcl(MutableAcl acl) throws NotFoundException { <line2> try { <line3> readAclById(acl.getObjectIdentity()); <line4> } catch (NotFoundException e) { <line5> throw e; <line6> } <line7> HTableInterface htable = null; <line8> try { <line9> htable = HBaseConnection.get(hbaseUrl).getTable(aclTableName); <line10> Delete delete = <line11> new Delete(Bytes.toBytes(String.valueOf(acl.getObjectIdentity().getIdentifier()))); <line12> delete.deleteFamily(Bytes.toBytes(ACL_ACES_FAMILY)); <line13> htable.delete(delete); <line14> Put put = new Put(Bytes.toBytes(String.valueOf(acl.getObjectIdentity().getIdentifier()))); <line15> if (null != acl.getParentAcl()) { <line16> put.add( <line17> Bytes.toBytes(ACL_INFO_FAMILY), <line18> Bytes.toBytes(ACL_INFO_FAMILY_PARENT_COLUMN), <line19> domainObjSerializer.serialize( <line20> new DomainObjectInfo(acl.getParentAcl().getObjectIdentity()))); <line21> } <line22> for (AccessControlEntry ace : acl.getEntries()) { <line23> AceInfo aceInfo = new AceInfo(ace); <line24> put.add( <line25> Bytes.toBytes(ACL_ACES_FAMILY), <line26> Bytes.toBytes(aceInfo.getSidInfo().getSid()), <line27> aceSerializer.serialize(aceInfo)); <line28> } <line29> if (!put.isEmpty()) { <line30> htable.put(put); <line31> htable.flushCommits(); <line32> } <line33> } catch (IOException e) { <line34> throw new RuntimeException(e.getMessage(), e); <line35> } finally { <line36> IOUtils.closeQuietly(htable); <line37> } <line38> return (MutableAcl) readAclById(acl.getObjectIdentity()); <line39> } <line40> } <line41> 	<line32>
6702	public class A { <line0> @Override <line1> public JType getReturnType(String[] path, MonitoredLogger logger) { <line2> if (path.length == 2) { <line3> String maybeCssClass = path[1]; <line4> Set<String> cssClassNames = null; <line5> try { <line6> cssClassNames = css.getCssClassNames(); <line7> if (cssClassNames.contains(maybeCssClass) <line8> || cssClassNames.contains(nameConverter.convertName(maybeCssClass)) <line9> || css.getNormalizedCssClassNames().contains(maybeCssClass)) { <line10> return stringType; <line11> } <line12> } catch (UnableToCompleteException e) { <line13> } <line14> } <line15> return super.getReturnType(path, logger); <line16> } <line17> } <line18> 	<line13>
6703	public class A { <line0> public static void processSegment( <line1> KylinConfig config, <line2> String cubeName, <line3> String segmentID, <line4> String uuid, <line5> DistinctColumnValuesProvider factTableValueProvider, <line6> DictionaryProvider dictProvider) <line7> throws IOException { <line8> CubeInstance cube = CubeManager.getInstance(config).getCube(cubeName); <line9> CubeSegment segment = cube.getSegmentById(segmentID); <line10> int retryTime = 0; <line11> while (retryTime < 3) { <line12> if (retryTime > 0) { <line13> } <line14> processSegment(config, segment, uuid, factTableValueProvider, dictProvider); <line15> if (isAllDictsAndSnapshotsReady(config, cubeName, segmentID)) { <line16> break; <line17> } <line18> retryTime++; <line19> } <line20> if (retryTime >= 3) { <line21> } else { <line22> } <line23> } <line24> } <line25> 	<line13>, <line21>, <line22>
6704	public class A { <line0> @Override <line1> public Model retrieve(@Nonnull IRI uri) throws MetadataServiceException { <line2> Model catalog = super.retrieve(uri); <line3> try { <line4> List<IRI> themes = metadataRepository.getDatasetThemesForCatalog(uri); <line5> setThemeTaxonomies(catalog, uri, themes); <line6> } catch (MetadataRepositoryException ex) { <line7> throw new MetadataServiceException(ex.getMessage()); <line8> } <line9> return catalog; <line10> } <line11> } <line12> 	<line7>
6705	"public class A { <line0> public String resolve(String input) { <line1> int openPos; <line2> int closePos; <line3> String variable_char = ""ENC(""; <line4> String variable_char_close = "")""; <line5> String midBit; <line6> String replaceValue; <line7> String temp = input; <line8> while (temp.indexOf(variable_char) > 0 || temp.startsWith(variable_char)) { <line9> openPos = temp.indexOf(variable_char); <line10> closePos = temp.indexOf(variable_char_close, openPos + 1); <line11> midBit = temp.substring(openPos + 4, closePos); <line12> replaceValue = this.decrypt(variable_char + midBit + variable_char_close); <line13> if (replaceValue != null) { <line14> input = input.replace(variable_char + midBit + variable_char_close, replaceValue); <line15> } <line16> temp = temp.substring(closePos + 1, temp.length()); <line17> } <line18> return input; <line19> } <line20> } <line21> "	<line1>
6706	public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSession session) <line2> throws ProcessException { <line3> FlowFile flowfile = session.get(); <line4> if (flowfile == null) { <line5> return; <line6> } <line7> if (!isConnected()) { <line8> synchronized (this) { <line9> if (!isConnected()) { <line10> initializeClient(context); <line11> } <line12> } <line13> } <line14> String topic = <line15> context.getProperty(PROP_TOPIC).evaluateAttributeExpressions(flowfile).getValue(); <line16> if (topic == null || topic.isEmpty()) { <line17> session.transfer(flowfile, REL_FAILURE); <line18> return; <line19> } <line20> final byte[] messageContent = new byte[(int) flowfile.getSize()]; <line21> session.read( <line22> flowfile, <line23> new InputStreamCallback() { <line24> @Override <line25> public void process(final InputStream in) throws IOException { <line26> StreamUtils.fillBuffer(in, messageContent, true); <line27> } <line28> }); <line29> int qos = context.getProperty(PROP_QOS).evaluateAttributeExpressions(flowfile).asInteger(); <line30> final MqttMessage mqttMessage = new MqttMessage(messageContent); <line31> mqttMessage.setQos(qos); <line32> mqttMessage.setPayload(messageContent); <line33> mqttMessage.setRetained( <line34> context.getProperty(PROP_RETAIN).evaluateAttributeExpressions(flowfile).asBoolean()); <line35> try { <line36> final StopWatch stopWatch = new StopWatch(true); <line37> mqttClient.publish(topic, mqttMessage); <line38> session <line39> .getProvenanceReporter() <line40> .send(flowfile, broker, stopWatch.getElapsed(TimeUnit.MILLISECONDS)); <line41> session.transfer(flowfile, REL_SUCCESS); <line42> } catch (MqttException me) { <line43> session.transfer(flowfile, REL_FAILURE); <line44> } <line45> } <line46> } <line47> 	<line17>, <line43>
6707	public class A { <line0> @Override <line1> public final void stop(BundleContext ctx) throws Exception { <line2> onBeforeStop(ctx); <line3> try { <line4> ignite.close(); <line5> } catch (Throwable t) { <line6> onAfterStop(ctx, t); <line7> return; <line8> } <line9> if (log.isInfoEnabled()) <line10> IgniteOsgiUtils.classloaders().remove(ignite); <line11> onAfterStop(ctx, null); <line12> } <line13> } <line14> 	<line6>, <line10>
6708	"public class A { <line0> @Override <line1> public JSONArray handleResponse(HttpResponse response) throws IOException { <line2> assertNotNull(""Unable to retrieve bundle status from server"", response); <line3> String responseBody = EntityUtils.toString(response.getEntity()); <line4> return new JSONArray(responseBody); <line5> } <line6> } <line7> "	<line2>, <line3>, <line4>
6709	public class A { <line0> private List<Path> discoverInstanceToDelete( <line1> String inPath, TimeZone timeZone, Date start, FileSystem fs) throws IOException { <line2> FileStatus[] files = findFilesForFeed(fs, inPath); <line3> if (files == null || files.length == 0) { <line4> return Collections.emptyList(); <line5> } <line6> List<Path> toBeDeleted = new ArrayList<Path>(); <line7> for (FileStatus file : files) { <line8> Date date = FeedHelper.getDate(inPath, new Path(file.getPath().toUri().getPath()), timeZone); <line9> if (date != null && !isDateInRange(date, start)) { <line10> toBeDeleted.add(file.getPath()); <line11> } <line12> } <line13> return toBeDeleted; <line14> } <line15> } <line16> 	<line9>
6710	"public class A { <line0> @PreAuthorize(""hasRole('"" + IdRepoEntitlement.SECURITY_QUESTION_DELETE + ""')"") <line1> public SecurityQuestionTO delete(final String key) { <line2> SecurityQuestion securityQuestion = securityQuestionDAO.find(key); <line3> if (securityQuestion == null) { <line4> throw new NotFoundException(key); <line5> } <line6> SecurityQuestionTO deleted = binder.getSecurityQuestionTO(securityQuestion); <line7> securityQuestionDAO.delete(key); <line8> return deleted; <line9> } <line10> } <line11> "	<line4>
6711	public class A { <line0> public void attachDirty(RechteProzesse instance) { <line1> try { <line2> sessionFactory.getCurrentSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
6712	"public class A { <line0> private void obtainUserAndPassword() throws LoginException { <line1> if (callbackHandler == null) { <line2> throw new LoginException( <line3> ""Error: no CallbackHandler available  to gather authentication information from the"" <line4> + "" user""); <line5> } <line6> try { <line7> NameCallback nameCallback = new NameCallback(""username""); <line8> PasswordCallback passwordCallback = new PasswordCallback(""password"", false); <line9> invokeCallbackHandler(nameCallback, passwordCallback); <line10> initUserName(nameCallback); <line11> initPassword(passwordCallback); <line12> } catch (IOException | UnsupportedCallbackException ex) { <line13> LoginException le = new LoginException(""Error in callbacks""); <line14> le.initCause(ex); <line15> throw le; <line16> } <line17> } <line18> } <line19> "	<line12>
6713	"public class A { <line0> public InvocationResults formatVoucherNames(List<String> voucherCsids) <line1> throws URISyntaxException, DocumentException { <line2> InvocationResults results = new InvocationResults(); <line3> int numAffected = 0; <line4> List<String> formattedNames = new ArrayList<String>(); <line5> for (String voucherCsid : voucherCsids) { <line6> VoucherName name = getVoucherName(voucherCsid); <line7> String formattedName = formatVoucherName(name); <line8> setStyledName(voucherCsid, formattedName); <line9> formattedNames.add(formattedName); <line10> numAffected = numAffected + 1; <line11> } <line12> results.setNumAffected(numAffected); <line13> results.setUserNote( <line14> ""Updated "" <line15> + numAffected <line16> + "" "" <line17> + (numAffected == 1 ? ""voucher"" : ""vouchers"") <line18> + (numAffected == 1 ? "": "" + formattedNames.get(0) : """")); <line19> return results; <line20> } <line21> } <line22> "	<line8>
6714	"public class A { <line0> private void createBroaderRelationship( <line1> RelationClient relationClient, String subjectCSID, String objectCSID, String docType) <line2> throws Exception { <line3> RelationsCommon relationCommon = new RelationsCommon(); <line4> relationCommon.setSubjectCsid(subjectCSID); <line5> relationCommon.setSubjectDocumentType(docType); <line6> relationCommon.setObjectCsid(objectCSID); <line7> relationCommon.setObjectDocumentType(docType); <line8> relationCommon.setRelationshipType(RelationshipType.HAS_BROADER.value()); <line9> relationCommon.setPredicateDisplayName(RelationshipType.HAS_BROADER.value()); <line10> PoxPayloadOut payloadOut = relationClient.createRequestTypeInstance(relationCommon); <line11> Response res = relationClient.create(payloadOut); <line12> try { <line13> if (res.getStatus() == HttpStatus.SC_CREATED) { <line14> String relationCSID = extractId(res); <line15> allRelationResourceIdsCreated.add(relationCSID); <line16> } else { <line17> String errMsg = ""Could not create Relationship.""; <line18> throw new Exception(errMsg); <line19> } <line20> } finally { <line21> res.close(); <line22> } <line23> } <line24> } <line25> "	<line18>
6715	public class A { <line0> public Serializable getElementValue() { <line1> if (_elementValueBytes == null) { <line2> return null; <line3> } <line4> Deserializer deserializer = new Deserializer(ByteBuffer.wrap(_elementValueBytes)); <line5> try { <line6> return deserializer.readObject(); <line7> } catch (ClassNotFoundException classNotFoundException) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	<line8>
6716	"public class A { <line0> @AroundInvoke <line1> public Object intercept(InvocationContext invocationContext) throws Exception { <line2> CacheInterceptionContext<CacheInvalidateAll> interceptionContext = <line3> getInterceptionContext(invocationContext, CacheInvalidateAll.class, false); <line4> if (interceptionContext.getInterceptorBindings().isEmpty()) { <line5> } else { <line6> for (CacheInvalidateAll binding : interceptionContext.getInterceptorBindings()) { <line7> AbstractCache cache = (AbstractCache) cacheManager.getCache(binding.cacheName()).get(); <line8> if (LOGGER.isDebugEnabled()) { <line9> LOGGER.debugf(""Invalidating all entries from cache [%s]"", binding.cacheName()); <line10> } <line11> cache.invalidateAll(); <line12> } <line13> } <line14> return invocationContext.proceed(); <line15> } <line16> } <line17> "	<line5>
6717	public class A { <line0> private void closeSocket(DeviceConnection conn) { <line1> if (conn.getSocket() != null) { <line2> try { <line3> conn.getSocket().close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>
6718	"public class A { <line0> public void start() { <line1> waitForFrameLoaded(); <line2> nuxeoFrame.stopping = false; <line3> nuxeoFrame.mainButton.setText(NuxeoLauncherGUI.getMessage(""mainbutton.start.inprogress"")); <line4> nuxeoFrame.mainButton.setToolTipText(NuxeoLauncherGUI.getMessage(""mainbutton.stop.tooltip"")); <line5> nuxeoFrame.mainButton.setIcon(nuxeoFrame.stopIcon); <line6> executor.execute( <line7> new Runnable() { <line8> @Override <line9> public void run() { <line10> try { <line11> launcher.doStartAndWait(); <line12> } catch (PackageException e) { <line13> System.exit(1); <line14> } <line15> updateServerStatus(); <line16> } <line17> }); <line18> } <line19> } <line20> "	<line13>
6719	public class A { <line0> @Override <line1> protected void runTest() throws Throwable { <line2> if (log.isDebugEnabled()) { <line3> if (isEmptyLinesEnabled) { <line4> } <line5> } <line6> try { <line7> super.runTest(); <line8> } catch (AssertionFailedError e) { <line9> log.error(EMPTY_LINE); <line10> throw e; <line11> } catch (Throwable e) { <line12> throw e; <line13> } finally { <line14> } <line15> } <line16> } <line17> 	<line4>, <line5>, <line10>, <line12>, <line14>
6720	"public class A { <line0> public synchronized boolean addReadyTask(BuildTask task) { <line1> if (!task.readyToBuild()) { <line2> throw new IllegalArgumentException(""a not ready task added to the queue: "" + task); <line3> } <line4> MDCAwareElement element = new MDCAwareElement(task); <line5> unfinishedTasks.add(element); <line6> readyTasks.add(element); <line7> return true; <line8> } <line9> } <line10> "	<line6>
6721	"public class A { <line0> private void editOrCreateRulesDeploy( <line1> RulesProject currentProject, <line2> ProjectModel projectModel, <line3> OpenAPIGeneratedClasses generatedClasses, <line4> boolean rulesDeployExists) { <line5> try { <line6> configureSerializer(); <line7> } catch (IOException e) { <line8> } <line9> try { <line10> if (rulesDeployExists) { <line11> AProjectResource artifact = (AProjectResource) currentProject.getArtefact(RULES_DEPLOY_XML); <line12> try (InputStream rulesDeployContent = artifact.getContent()) { <line13> RulesDeploy rulesDeploy = <line14> rulesDeploySerializerFactory <line15> .getSerializer(SupportedVersion.getLastVersion()) <line16> .deserialize(rulesDeployContent); <line17> artifact.setContent( <line18> openAPIHelper.editOrCreateRulesDeploy( <line19> rulesDeploySerializer, projectModel, generatedClasses, rulesDeploy)); <line20> } <line21> } else { <line22> try (ByteArrayInputStream rulesDeployInputStream = <line23> openAPIHelper.editOrCreateRulesDeploy( <line24> rulesDeploySerializer, projectModel, generatedClasses, null)) { <line25> currentProject.addResource(RULES_DEPLOY_XML, rulesDeployInputStream); <line26> } <line27> } <line28> } catch (ProjectException | IOException e) { <line29> throw new Message(""Failed to add rules deploy xml file.""); <line30> } <line31> } <line32> } <line33> "	<line8>, <line29>
6722	"public class A { <line0> public Sequence evalWithCollection( <line1> Collection collection, Sequence[] args, Sequence contextSequence) throws XPathException { <line2> if (getSignature().getArgumentCount() == 3) { <line3> final XmldbURI doc = new AnyURIValue(args[1].itemAt(0).getStringValue()).toXmldbURI(); <line4> try { <line5> final Resource resource = collection.getResource(doc.toString()); <line6> if (resource == null) { <line7> throw new XPathException(this, ""Resource "" + doc + "" not found""); <line8> } <line9> final String newName = args[2].itemAt(0).getStringValue(); <line10> final EXistCollectionManagementService service = <line11> (EXistCollectionManagementService) <line12> collection.getService(""CollectionManagementService"", ""1.0""); <line13> service.moveResource(doc, (XmldbURI) null, XmldbURI.xmldbUriFor(newName)); <line14> } catch (final XMLDBException e) { <line15> logger.error(e.getMessage()); <line16> throw new XPathException(this, ""XMLDB exception caught: "" + e.getMessage(), e); <line17> } catch (final URISyntaxException e) { <line18> logger.error(e.getMessage()); <line19> throw new XPathException(this, ""URI exception: "" + e.getMessage(), e); <line20> } <line21> } else { <line22> try { <line23> final String newName = args[1].itemAt(0).getStringValue(); <line24> final EXistCollectionManagementService service = <line25> (EXistCollectionManagementService) <line26> collection.getService(""CollectionManagementService"", ""1.0""); <line27> service.move( <line28> XmldbURI.xmldbUriFor(collection.getName()), null, XmldbURI.xmldbUriFor(newName)); <line29> } catch (final XMLDBException e) { <line30> throw new XPathException(this, ""Cannot rename collection: "" + e.getMessage(), e); <line31> } catch (final URISyntaxException e) { <line32> throw new XPathException(this, ""URI exception: "" + e.getMessage(), e); <line33> } <line34> } <line35> return Sequence.EMPTY_SEQUENCE; <line36> } <line37> } <line38> "	<line7>, <line30>, <line32>
6723	public class A { <line0> private void retry(MessageQueryIndex failMessage, Consumer<MessageQueryIndex> fi) { <line1> final int tryStoreNum = failMessage.getBackupRetryTimes(); <line2> if (tryStoreNum < retryNum()) { <line3> monitorStoreRetry(failMessage.getSubject()); <line4> failMessage.setBackupRetryTimes(tryStoreNum + 1); <line5> add(failMessage, fi); <line6> } else { <line7> monitorStoreDiscard(failMessage.getSubject()); <line8> } <line9> } <line10> } <line11> 	<line8>
6724	public class A { <line0> @Override <line1> public CommandOutcome run(Cli cli) { <line2> final Logger logger = this.logger.get(); <line3> final SarldocConfig dconfig = this.config.get(); <line4> forceProxyDefinition(dconfig, logger); <line5> CommandOutcome outcome = runSarlc(cli, logger); <line6> if (outcome.isSuccess()) { <line7> final SarlcConfig cconfig = this.sarlcConfig.get(); <line8> final AtomicInteger errorCount = new AtomicInteger(); <line9> final AtomicInteger warningCount = new AtomicInteger(); <line10> outcome = runJavadoc(cli, dconfig, cconfig, logger, errorCount, warningCount); <line11> if (outcome == null || outcome.isSuccess()) { <line12> if (warningCount.get() > 0) { <line13> if (warningCount.get() > 1) { <line14> } else { <line15> } <line16> } else { <line17> } <line18> } <line19> } <line20> return outcome; <line21> } <line22> } <line23> 	<line14>, <line15>, <line17>
6725	"public class A { <line0> @SuppressWarnings(""PMD.ThreadPoolCreationRule"") <line1> private void startTimerService() { <line2> service = <line3> Executors.newScheduledThreadPool( <line4> 1, new NamedThreadFactory(""sentinel-datasource-auto-refresh-task"", true)); <line5> service.scheduleAtFixedRate( <line6> new Runnable() { <line7> @Override <line8> public void run() { <line9> try { <line10> if (!isModified()) { <line11> return; <line12> } <line13> T newValue = loadConfig(); <line14> getProperty().updateValue(newValue); <line15> } catch (Throwable e) { <line16> } <line17> } <line18> }, <line19> recommendRefreshMs, <line20> recommendRefreshMs, <line21> TimeUnit.MILLISECONDS); <line22> } <line23> } <line24> "	<line16>
6726	public class A { <line0> @Override <line1> public Status insert(String table, String key, Map<String, ByteIterator> values) { <line2> try { <line3> user.setUserId(key); <line4> for (int fieldCount = 0; fieldCount < totalFieldCount; fieldCount++) { <line5> String field = FIELDS[fieldCount + 1]; <line6> int fieldIndex = fieldCount + 1; <line7> String fieldValue = values.get(field).toString(); <line8> user.put(fieldIndex, fieldValue); <line9> user.setDirty(fieldIndex); <line10> } <line11> dataStore.put(key, user); <line12> } catch (Exception e) { <line13> return Status.ERROR; <line14> } <line15> return Status.OK; <line16> } <line17> } <line18> 	<line13>
6727	"public class A { <line0> @Test <line1> public void testGetAllAtomContainers_IChemModel() throws Exception { <line2> String filename = ""data/mdl/a-pinene.mol""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> MDLV2000Reader reader = new MDLV2000Reader(ins); <line5> ChemModel chemFile = (ChemModel) reader.read((ChemObject) new ChemModel()); <line6> Assert.assertNotNull(chemFile); <line7> List<IAtomContainer> containersList = ChemModelManipulator.getAllAtomContainers(chemFile); <line8> Assert.assertEquals(1, containersList.size()); <line9> } <line10> } <line11> "	<line3>
6728	public class A { <line0> @Override <line1> public void tearDown() throws Exception { <line2> for (ActivityEntity activity : tearDownActivityList) { <line3> try { <line4> activityDao.delete(activity); <line5> } catch (Exception e) { <line6> } <line7> } <line8> identityManager.deleteIdentity(ghostIdentity); <line9> identityManager.deleteIdentity(jameIdentity); <line10> identityManager.deleteIdentity(raulIdentity); <line11> identityManager.deleteIdentity(paulIdentity); <line12> for (Space space : tearDownSpaceList) { <line13> Identity spaceIdentity = <line14> identityManager.getOrCreateIdentity( <line15> SpaceIdentityProvider.NAME, space.getPrettyName(), false); <line16> if (spaceIdentity != null) { <line17> identityManager.deleteIdentity(spaceIdentity); <line18> } <line19> spaceService.deleteSpace(space); <line20> } <line21> ConversationState.setCurrent(null); <line22> super.tearDown(); <line23> } <line24> } <line25> 	<line6>
6729	"public class A { <line0> public static void atomicCopy(Path source, Path dest) throws IOException { <line1> Path tmp = Files.createTempFile(dest.getParent(), ""bin_"", "".tmp""); <line2> try { <line3> Files.copy(source, tmp, REPLACE_EXISTING); <line4> Files.move(tmp, dest, ATOMIC_MOVE, REPLACE_EXISTING); <line5> } finally { <line6> try { <line7> Files.deleteIfExists(tmp); <line8> } catch (IOException e) { <line9> } <line10> } <line11> } <line12> } <line13> "	<line9>
6730	"public class A { <line0> @Override <line1> public Authentication authenticate(Authentication authentication) throws AuthenticationException { <line2> String username = authentication.getName(); <line3> String password = (String) authentication.getCredentials(); <line4> HttpHeaders headers = getHeaders(); <line5> @SuppressWarnings(""rawtypes"") <line6> ResponseEntity<Map> response = <line7> restTemplate.exchange( <line8> remoteUrl, <line9> HttpMethod.POST, <line10> new HttpEntity<Object>(getParameters(username, password), headers), <line11> Map.class); <line12> if (response.getStatusCode() == HttpStatus.OK <line13> || response.getStatusCode() == HttpStatus.CREATED) { <line14> if (evaluateResponse(authentication, response)) { <line15> return new UsernamePasswordAuthenticationToken( <line16> username, nullPassword ? null : """", UaaAuthority.USER_AUTHORITIES); <line17> } <line18> } else if (response.getStatusCode() == HttpStatus.UNAUTHORIZED) { <line19> throw new BadCredentialsException(""Authentication failed""); <line20> } else if (response.getStatusCode() == HttpStatus.INTERNAL_SERVER_ERROR) { <line21> } else { <line22> } <line23> throw new RuntimeException(""Could not authenticate with remote server""); <line24> } <line25> } <line26> "	<line15>, <line19>, <line21>, <line22>
6731	"public class A { <line0> public void testConsumeAndReceiveInitialQueryBeforeUpdates() throws Exception { <line1> connection = createConnection(); <line2> session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line3> connection.start(); <line4> MessageConsumer consumer = session.createConsumer(destination); <line5> MessageIdList listener = new MessageIdList(); <line6> listener.setVerbose(true); <line7> consumer.setMessageListener(listener); <line8> MessageProducer producer = session.createProducer(destination); <line9> int updateMessageCount = messageCount - DummyMessageQuery.MESSAGE_COUNT; <line10> for (int i = 0; i < updateMessageCount; i++) { <line11> TextMessage message = <line12> session.createTextMessage(""Update Message: "" + i + "" sent at: "" + new Date()); <line13> producer.send(message); <line14> } <line15> producer.close(); <line16> listener.assertMessagesReceived(messageCount); <line17> } <line18> } <line19> "	<line16>
6732	public class A { <line0> @Override <line1> public void put(K key, T persistent) throws GoraException { <line2> Schema schema = persistent.getSchema(); <line3> if (!persistent.isDirty()) { <line4> return; <line5> } <line6> SolrInputDocument doc = new SolrInputDocument(); <line7> doc.addField(mapping.getPrimaryKey(), key); <line8> List<Field> fields = schema.getFields(); <line9> for (Field field : fields) { <line10> String sf = mapping.getSolrField(field.name()); <line11> if (sf == null) { <line12> continue; <line13> } <line14> Schema fieldSchema = field.schema(); <line15> Object v = persistent.get(field.pos()); <line16> if (v == null) { <line17> continue; <line18> } <line19> v = serializeFieldValue(fieldSchema, v); <line20> doc.addField(sf, v); <line21> } <line22> batch.add(doc); <line23> if (batch.size() >= batchSize) { <line24> try { <line25> add(batch, commitWithin); <line26> batch.clear(); <line27> } catch (Exception e) { <line28> throw new GoraException(e); <line29> } <line30> } <line31> } <line32> } <line33> 	<line22>
6733	"public class A { <line0> public List<TTag> getPartnerEndpoints(final TServiceTemplate serviceTemplate) { <line1> if (Objects.isNull(serviceTemplate.getTags())) { <line2> return null; <line3> } <line4> List<TTag> tags = serviceTemplate.getTags().getTag(); <line5> List<TTag> partnerTags = Lists.newArrayList(); <line6> tags.forEach( <line7> tag -> { <line8> if (tag.getName().startsWith(""participant:"")) { <line9> String participantName = tag.getName().replace(""participant:"", """"); <line10> partnerTags.add( <line11> new TTag.Builder().setName(participantName).setValue(tag.getValue()).build()); <line12> } <line13> }); <line14> return partnerTags; <line15> } <line16> } <line17> "	<line2>, <line5>, <line14>
6734	public class A { <line0> @Override <line1> protected void doStart() throws Exception { <line2> super.doStart(); <line3> if (task == null) { <line4> task = new GoalTask(); <line5> int period = fastMode ? 5 * 1000 : 60 * 1000; <line6> timer.scheduleAtFixedRate(task, 1000, period); <line7> } <line8> } <line9> } <line10> 	<line3>
6735	public class A { <line0> public static <T> T fromJson(final String jsonString, final Class<T> clazz) { <line1> if (StringUtils.isNotBlank(jsonString)) { <line2> try { <line3> return OBJECT_MAPPER.readValue(jsonString, clazz); <line4> } catch (final IOException ex) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	<line5>
6736	"public class A { <line0> private String getUserID(String eMail, String password) <line1> throws UnsupportedEncodingException, ServiceNotAvailableException, ServiceException { <line2> String params = ""&User="" + eMail + ""&Password="" + password + ""&Password2="" + password; <line3> String query = MYYM_LOGIN_SELECT + this.staticParameter + params; <line4> String userXml = callService(this.myymProxy, query); <line5> if (userXml == null) { <line6> return null; <line7> } <line8> NodeList nodes = findNodes(userXml, xpathExpUserId); <line9> if (nodes.getLength() > 0) return nodes.item(0).getTextContent(); <line10> else return null; <line11> } <line12> } <line13> "	<line6>
6737	public class A { <line0> private boolean runClient(int timeout, boolean logToOutput) { <line1> messages.clear(); <line2> try { <line3> executor = new Exec(logPath); <line4> if (linkAttachedProbeFactory() != null) { <line5> setLinkAttachedProbe(); <line6> } <line7> int ret = executor.exec(prepareCommand(), timeout); <line8> synchronized (lock) { <line9> if (logToOutput) { <line10> } <line11> if (ret == 0) { <line12> parseToJson(executor.getStdOut()); <line13> } else { <line14> if (!executor.getStdErr().isEmpty() && logToOutput) { <line15> } <line16> } <line17> } <line18> return ret == 0; <line19> } catch (Exception ex) { <line20> ex.printStackTrace(); <line21> return false; <line22> } <line23> } <line24> } <line25> 	<line9>, <line10>, <line15>
6738	public class A { <line0> @Override <line1> public synchronized void writeHeader(int id, byte[] bytes, boolean cached) throws IOException { <line2> if (closed) return; <line3> if (!cached && cache != null) { <line4> try { <line5> cache.setHeader(id, bytes); <line6> } catch (IOException ex) { <line7> if (id == HEADER_SIZE) throw new IOException(ex); <line8> } <line9> } <line10> if (id == HEADER_SIZE) { <line11> size = ByteBuffer.wrap(bytes).getInt(); <line12> size *= 4; <line13> chunks = (size + CHUNK_SIZE - 1) / CHUNK_SIZE; <line14> exception = null; <line15> notifyAll(); <line16> } else if (id == HEADER_CDN) { <line17> exception = new StorageNotAvailable(new String(bytes)); <line18> notifyAll(); <line19> } <line20> } <line21> } <line22> 	<line8>
6739	"public class A { <line0> @SuppressWarnings({""unchecked""}) <line1> public static final StringBuffer transformXml( <line2> final String xslName, <line3> final String xslPath, <line4> final InputStream docInStrm, <line5> Map params, <line6> final IDocumentResourceLoader loader) <line7> throws TransformerException { <line8> StringBuffer result = null; <line9> InputStream xslInStrm = XmlHelper.getLocalizedXsl(xslPath, xslName, loader); <line10> if (null == xslInStrm) { <line11> } else if (null == docInStrm) { <line12> } else { <line13> if (params == null) { <line14> params = new HashMap(); <line15> } <line16> params.put(""output-encoding"", LocaleHelper.getSystemEncoding()); <line17> try { <line18> result = XmlHelper.transformXml(xslInStrm, docInStrm, params, loader); <line19> } catch (TransformerException e) { <line20> throw e; <line21> } finally { <line22> FileHelper.closeInputStream(xslInStrm); <line23> } <line24> } <line25> return result; <line26> } <line27> } <line28> "	<line11>, <line12>, <line20>
6740	"public class A { <line0> private boolean authenticateImpl(final String bindDn, final String password) <line1> throws LDAPException, ConnectionException { <line2> Instant startTime = OperationDurationUtil.instance().now(); <line3> boolean result = false; <line4> List<PasswordEncryptionMethod> additionalPasswordMethods = <line5> this.connectionProvider.getAdditionalPasswordMethods(); <line6> if ((persistenceExtension != null) || !additionalPasswordMethods.isEmpty()) { <line7> SearchResultEntry searchResult = lookup(bindDn, USER_PASSWORD); <line8> if (searchResult == null) { <line9> throw new ConnectionException(""Failed to find use by dn""); <line10> } <line11> String userPassword = searchResult.getAttribute(USER_PASSWORD).getValue(); <line12> if (userPassword != null) { <line13> if (persistenceExtension != null) { <line14> result = persistenceExtension.compareHashedPasswords(password, userPassword); <line15> } else { <line16> PasswordEncryptionMethod storedPasswordMethod = <line17> PasswordEncryptionHelper.findAlgorithm(userPassword); <line18> if (additionalPasswordMethods.contains(storedPasswordMethod)) { <line19> result = PasswordEncryptionHelper.compareCredentials(password, userPassword); <line20> } <line21> } <line22> } <line23> } else { <line24> if (this.bindConnectionProvider == null) { <line25> result = authenticateConnectionPoolImpl(bindDn, password); <line26> } else { <line27> result = authenticateBindConnectionPoolImpl(bindDn, password); <line28> } <line29> } <line30> Duration duration = OperationDurationUtil.instance().duration(startTime); <line31> OperationDurationUtil.instance() <line32> .logDebug(""LDAP operation: bind, duration: {}, dn: {}"", duration, bindDn); <line33> return result; <line34> } <line35> } <line36> "	<line19>
6741	"public class A { <line0> public static void main(String[] args) { <line1> int port = 8080; <line2> for (int i = 0; i < args.length; i++) { <line3> String a = args[i]; <line4> if (""-p"".equals(a) || ""--port"".equals(a)) { <line5> port = Integer.parseInt(args[++i]); <line6> } <line7> } <line8> try { <line9> BrowserDebugTool tool = new BrowserDebugTool(); <line10> tool.prepare(port); <line11> tool.start(); <line12> } catch (Throwable t) { <line13> } <line14> } <line15> } <line16> "	<line13>
6742	public class A { <line0> public static com.liferay.commerce.model.CommerceOrderSoap <line1> updateCommerceOrderExternalReferenceCode(String externalReferenceCode, long commerceOrderId) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.model.CommerceOrder returnValue = <line5> CommerceOrderServiceUtil.updateCommerceOrderExternalReferenceCode( <line6> externalReferenceCode, commerceOrderId); <line7> return com.liferay.commerce.model.CommerceOrderSoap.toSoapModel(returnValue); <line8> } catch (Exception exception) { <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line9>
6743	"public class A { <line0> public void resolveLookupReferences(Map<String, LookupTable> lookupTables) { <line1> if (lookupTables != null) { <line2> String lid = ""lu"" + Integer.toString(lookupIndex); <line3> LookupTable lt = lookupTables.get(lid); <line4> if (lt != null) { <line5> this.lookup = lt; <line6> } else { <line7> } <line8> } <line9> } <line10> } <line11> "	<line7>
6744	public class A { <line0> private void watchErrorHandler( <line1> Throwable e, <line2> String selfMicroserviceId, <line3> AsyncResultCallback<MicroserviceInstanceChangedEvent> callback) { <line4> callback.fail(e); <line5> watchServices.remove(selfMicroserviceId); <line6> } <line7> } <line8> 	<line4>
6745	"public class A { <line0> public static java.util.List<com.liferay.asset.kernel.model.AssetVocabulary> getGroupVocabularies( <line1> HttpPrincipal httpPrincipal, long groupId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> AssetVocabularyServiceUtil.class, <line7> ""getGroupVocabularies"", <line8> _getGroupVocabulariesParameterTypes10); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (java.util.List<com.liferay.asset.kernel.model.AssetVocabulary>) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
6746	"public class A { <line0> private static String getUrl(WebDriver driver, String name) { <line1> String seleniumHost = Configuration.getSeleniumUrl().replace(""wd/hub"", ""download/""); <line2> WebDriver drv = <line3> (driver instanceof EventFiringWebDriver) <line4> ? ((EventFiringWebDriver) driver).getWrappedDriver() <line5> : driver; <line6> String sessionId = ((RemoteWebDriver) drv).getSessionId().toString(); <line7> String url = seleniumHost + sessionId + ""/"" + name; <line8> return url; <line9> } <line10> } <line11> "	<line8>
6747	public class A { <line0> @Override <line1> public void onPublish(UTF8Buffer topic, Buffer payload, Runnable ack) { <line2> try { <line3> this.incoming.put(new AckableMessage(topic.toString(), payload.toByteArray(), ack)); <line4> } catch (InterruptedException e) { <line5> } <line6> } <line7> } <line8> 	<line2>, <line5>
6748	"public class A { <line0> @Nullable <line1> public String postRequest(String ipAddress, String contentString) { <line2> String url = ""http://"" + ipAddress + ""/api.cgi""; <line3> try { <line4> Request request = httpClient.POST(url); <line5> request.header(HttpHeader.CONTENT_TYPE, ""application/json""); <line6> request.content(new StringContentProvider(contentString), ""application/json""); <line7> ContentResponse contentResponse = request.timeout(5, TimeUnit.SECONDS).send(); <line8> String response = <line9> contentResponse.getContentAsString().replace(""\t"", """").replace(""\r\n"", """").trim(); <line10> if (response != null && !response.isEmpty()) { <line11> return response; <line12> } else { <line13> return null; <line14> } <line15> } catch (TimeoutException | InterruptedException | ExecutionException e) { <line16> } <line17> return null; <line18> } <line19> } <line20> "	<line16>
6749	"public class A { <line0> private void selfCheckingMove( <line1> String s3Bucket, String targetS3Bucket, String s3Path, String targetS3Path, String copyMsg) <line2> throws IOException, SegmentLoadingException { <line3> if (s3Bucket.equals(targetS3Bucket) && s3Path.equals(targetS3Path)) { <line4> return; <line5> } <line6> if (s3Client.doesObjectExist(s3Bucket, s3Path)) { <line7> final ListObjectsV2Result listResult = <line8> s3Client.listObjectsV2( <line9> new ListObjectsV2Request() <line10> .withBucketName(s3Bucket) <line11> .withPrefix(s3Path) <line12> .withMaxKeys(1)); <line13> if (listResult.getObjectSummaries().size() == 0) { <line14> throw new ISE(""Unable to list object [s3://%s/%s]"", s3Bucket, s3Path); <line15> } <line16> final S3ObjectSummary objectSummary = listResult.getObjectSummaries().get(0); <line17> if (objectSummary.getStorageClass() != null <line18> && StorageClass.fromValue(StringUtils.toUpperCase(objectSummary.getStorageClass())) <line19> .equals(StorageClass.Glacier)) { <line20> throw new AmazonServiceException( <line21> StringUtils.format( <line22> ""Cannot move file[s3://%s/%s] of storage class glacier, skipping."", <line23> s3Bucket, s3Path)); <line24> } else { <line25> final CopyObjectRequest copyRequest = <line26> new CopyObjectRequest(s3Bucket, s3Path, targetS3Bucket, targetS3Path); <line27> if (!config.getDisableAcl()) { <line28> copyRequest.setAccessControlList( <line29> S3Utils.grantFullControlToBucketOwner(s3Client, targetS3Bucket)); <line30> } <line31> s3Client.copyObject(copyRequest); <line32> if (!s3Client.doesObjectExist(targetS3Bucket, targetS3Path)) { <line33> throw new IOE( <line34> ""After copy was reported as successful the file doesn't exist in the target location"" <line35> + "" [%s]"", <line36> copyMsg); <line37> } <line38> deleteWithRetriesSilent(s3Bucket, s3Path); <line39> } <line40> } else { <line41> if (s3Client.doesObjectExist(targetS3Bucket, targetS3Path)) { <line42> } else { <line43> throw new SegmentLoadingException( <line44> ""Unable to move file %s, not present in either source or target location"", copyMsg); <line45> } <line46> } <line47> } <line48> } <line49> "	<line4>, <line25>, <line39>, <line42>
6750	"public class A { <line0> private void checkPreconditions(Path basePath) throws IOException { <line1> Preconditions.checkNotNull(basePath, ""Base path cannot be null""); <line2> if (!isPosixFileSystem.get()) { <line3> throw new IOException(""Unsupported File System for pem file.""); <line4> } <line5> if (Files.exists(basePath)) { <line6> Files.setPosixFilePermissions(basePath, permissionSet); <line7> } else { <line8> boolean success = basePath.toFile().mkdirs(); <line9> if (!success) { <line10> throw new IOException( <line11> ""Unable to create the directory for the "" + ""location. Location:"" + basePath); <line12> } <line13> Files.setPosixFilePermissions(basePath, permissionSet); <line14> } <line15> } <line16> } <line17> "	<line3>, <line10>
6751	"public class A { <line0> @Override <line1> public List<RestDefinition> getRestDefinitions(CamelContext camelContext, String camelId) <line2> throws Exception { <line3> ObjectName found = null; <line4> MBeanServer server = ManagementFactory.getPlatformMBeanServer(); <line5> Set<ObjectName> names = <line6> server.queryNames(new ObjectName(""org.apache.camel:type=context,*""), null); <line7> for (ObjectName on : names) { <line8> String id = on.getKeyProperty(""name""); <line9> if (id.startsWith(""\"""") && id.endsWith(""\"""")) { <line10> id = id.substring(1, id.length() - 1); <line11> } <line12> if (camelId == null || camelId.equals(id)) { <line13> found = on; <line14> } <line15> } <line16> if (found != null) { <line17> String xml = <line18> (String) <line19> server.invoke(found, ""dumpRestsAsXml"", new Object[] {true}, new String[] {""boolean""}); <line20> if (xml != null) { <line21> InputStream xmlis = camelContext.getTypeConverter().convertTo(InputStream.class, xml); <line22> ExtendedCamelContext ecc = camelContext.adapt(ExtendedCamelContext.class); <line23> RestsDefinition rests = <line24> (RestsDefinition) <line25> ecc.getXMLRoutesDefinitionLoader().loadRestsDefinition(camelContext, xmlis); <line26> if (rests != null) { <line27> return rests.getRests(); <line28> } <line29> } <line30> } <line31> return null; <line32> } <line33> } <line34> "	<line21>
6752	public class A { <line0> private void print(Object o) { <line1> if (logWriter != null) { <line2> } <line3> } <line4> } <line5> 	<line2>
6753	"public class A { <line0> @Override <line1> int runCmd(CommandLine cmdLine) throws Exception { <line2> UpdateBookieInLedgerCommand cmd = new UpdateBookieInLedgerCommand(); <line3> UpdateBookieInLedgerCommand.UpdateBookieInLedgerFlags flags = <line4> new UpdateBookieInLedgerCommand.UpdateBookieInLedgerFlags(); <line5> final String srcBookie = cmdLine.getOptionValue(""srcBookie""); <line6> final String destBookie = cmdLine.getOptionValue(""destBookie""); <line7> if (StringUtils.isBlank(srcBookie) || StringUtils.isBlank(destBookie)) { <line8> this.printUsage(); <line9> return -1; <line10> } <line11> if (StringUtils.equals(srcBookie, destBookie)) { <line12> return -1; <line13> } <line14> final int rate = getOptionIntValue(cmdLine, ""updatespersec"", 5); <line15> final int maxOutstandingReads = getOptionIntValue(cmdLine, ""maxOutstandingReads"", (rate * 5)); <line16> final int limit = getOptionIntValue(cmdLine, ""limit"", Integer.MIN_VALUE); <line17> final boolean verbose = getOptionBooleanValue(cmdLine, ""verbose"", false); <line18> final long printprogress; <line19> if (!verbose) { <line20> if (cmdLine.hasOption(""printprogress"")) { <line21> } <line22> printprogress = Integer.MIN_VALUE; <line23> } else { <line24> printprogress = getOptionLongValue(cmdLine, ""printprogress"", 10); <line25> } <line26> flags.srcBookie(srcBookie); <line27> flags.destBookie(destBookie); <line28> flags.printProgress(printprogress); <line29> flags.limit(limit); <line30> flags.updatePerSec(rate); <line31> flags.maxOutstandingReads(maxOutstandingReads); <line32> flags.verbose(verbose); <line33> boolean result = cmd.apply(bkConf, flags); <line34> return (result) ? 0 : -1; <line35> } <line36> } <line37> "	<line8>, <line12>, <line21>
6754	public class A { <line0> private void submit(Runnable action) { <line1> boolean empty; <line2> synchronized (this) { <line3> empty = actions.isEmpty(); <line4> actions.offer(action); <line5> } <line6> if (empty && process()) { <line7> synchronized (this) { <line8> if (logger.isDebugEnabled()) { <line9> } <line10> notifyAll(); <line11> } <line12> } <line13> } <line14> } <line15> 	<line9>
6755	public class A { <line0> @Override <line1> protected void onRun() { <line2> Set keys = devices.keySet(); <line3> Iterator keyIter = keys.iterator(); <line4> while (keyIter.hasNext()) { <line5> String alias = (String) keyIter.next(); <line6> Board board = (Board) devices.get(alias); <line7> SNMPRequest(board); <line8> readP6Port(board); <line9> } <line10> try { <line11> Thread.sleep(POLLING_TIME); <line12> } catch (InterruptedException ex) { <line13> Thread.currentThread().interrupt(); <line14> } <line15> } <line16> } <line17> 	<line13>
6756	"public class A { <line0> public void testGetACL() throws Exception { <line1> ByteArrayContainerResponseWriter writer = new ByteArrayContainerResponseWriter(); <line2> String requestPath = SERVICE_URI + ""acl/"" + fileId; <line3> ContainerResponse response = <line4> launcher.service(HttpMethod.GET, requestPath, BASE_URI, null, null, writer, null); <line5> assertEquals(""Error: "" + response.getEntity(), 200, response.getStatus()); <line6> @SuppressWarnings(""unchecked"") <line7> List<AccessControlEntry> acl = (List<AccessControlEntry>) response.getEntity(); <line8> assertEquals(permissions, toMap(acl)); <line9> } <line10> } <line11> "	<line5>
6757	public class A { <line0> private void cancelTemplateHolder( <line1> ITemplateHolder template, Exception exp, boolean fromTimerThread) { <line2> IResponseContext respContext = template.getResponseContext(); <line3> if (respContext != null || template.getMultipleIdsContext() != null || exp != null) { <line4> ILockObject templateLock = _cacheManager.getLockManager().getLockObject(template, false); <line5> Context context = null; <line6> AnswerHolder aHolder = template.getAnswerHolder(); <line7> try { <line8> synchronized (templateLock) { <line9> synchronized (aHolder) { <line10> if (!template.isDeleted()) { <line11> if (!fromTimerThread) removeTemplate(template); <line12> else template.setInExpirationManager(false); <line13> context = _cacheManager.getCacheContext(); <line14> context.setOperationAnswer(template, null, exp); <line15> _cacheManager.removeTemplate(context, template, false, true, false); <line16> } else { <line17> return; <line18> } <line19> } <line20> } <line21> } catch (ClosedResourceException ex) { <line22> } finally { <line23> if (templateLock != null) _cacheManager.getLockManager().freeLockObject(templateLock); <line24> _cacheManager.freeCacheContext(context); <line25> } <line26> } <line27> } <line28> } <line29> 	<line22>
6758	"public class A { <line0> @Test <line1> public void testCustomerErrorHandler() throws Exception { <line2> String response = <line3> template.requestBody( <line4> ""http://localhost:{{port}}/myserver1?throwExceptionOnFailure=false"", <line5> null, <line6> String.class); <line7> assertTrue(response.indexOf(""MyErrorHandler"") > 0, ""Get a wrong error message""); <line8> } <line9> } <line10> "	<line7>
6759	public class A { <line0> @Override <line1> public void disconnect() { <line2> if (readerThread != null) { <line3> readerThread.interrupt(); <line4> try { <line5> readerThread.join(); <line6> } catch (InterruptedException e) { <line7> } <line8> } <line9> readerThread = null; <line10> connected = false; <line11> } <line12> } <line13> 	<line3>, <line11>
6760	"public class A { <line0> public void savePerformed(AjaxRequestTarget target) { <line1> ObjectViewDto dto = model.getObject(); <line2> if (StringUtils.isEmpty(dto.getXml())) { <line3> error(getString(""pageDebugView.message.cantSaveEmpty"")); <line4> target.add(getFeedbackPanel()); <line5> return; <line6> } <line7> Task task = createSimpleTask(OPERATION_SAVE_OBJECT); <line8> OperationResult result = task.getResult(); <line9> try { <line10> PrismObject<ObjectType> oldObject = dto.getObject(); <line11> oldObject.revive(getPrismContext()); <line12> Holder<Objectable> objectHolder = new Holder<>(null); <line13> validateObject(result, objectHolder); <line14> if (result.isAcceptable()) { <line15> PrismObject<ObjectType> newObject = <line16> (PrismObject<ObjectType>) objectHolder.getValue().asPrismObject(); <line17> ObjectDelta<ObjectType> delta = oldObject.diff(newObject, true, true); <line18> if (delta.getPrismContext() == null) { <line19> delta.revive(getPrismContext()); <line20> } <line21> if (LOGGER.isTraceEnabled()) { <line22> } <line23> Collection<ObjectDelta<? extends ObjectType>> deltas = <line24> (Collection) MiscUtil.createCollection(delta); <line25> ModelExecuteOptions options = new ModelExecuteOptions(); <line26> if (saveAsRaw.getObject()) { <line27> options.setRaw(true); <line28> } <line29> if (reevaluateSearchFilters.getObject()) { <line30> options.setReevaluateSearchFilters(true); <line31> } <line32> if (!encrypt.getObject()) { <line33> options.setNoCrypt(true); <line34> } <line35> getModelService().executeChanges(deltas, options, task, result); <line36> result.computeStatus(); <line37> } <line38> } catch (Exception ex) { <line39> result.recordFatalError(""Couldn't save object."", ex); <line40> } <line41> if (result.isError()) { <line42> showResult(result); <line43> target.add(getFeedbackPanel()); <line44> } else { <line45> showResult(result); <line46> redirectBack(); <line47> } <line48> } <line49> } <line50> "	<line19>, <line22>
6761	public class A { <line0> public void recreate() throws Exception { <line1> } <line2> } <line3> 	<line1>
6762	"public class A { <line0> @Override <line1> public void onCollision(CollisionContext ctx) { <line2> Collection<CollisionJobContext> waitJobs = ctx.waitingJobs(); <line3> for (CollisionJobContext job : waitJobs) { <line4> IgniteUuid jobId = job.getJobContext().getJobId(); <line5> try { <line6> job.getTaskSession().setAttribute(jobId, ""test-"" + jobId); <line7> } catch (IgniteException e) { <line8> } <line9> job.activate(); <line10> } <line11> } <line12> } <line13> "	<line7>, <line8>
6763	"public class A { <line0> @PUT <line1> public Response startCluster(KaramelBoardJSON boardJSON) { <line2> Response response = null; <line3> try { <line4> karamelApi.startCluster(boardJSON.getJson()); <line5> response = <line6> Response.status(Response.Status.OK) <line7> .entity(new StatusResponseJSON(StatusResponseJSON.SUCCESS_STRING, ""success"")) <line8> .build(); <line9> } catch (KaramelException e) { <line10> response = buildExceptionResponse(e); <line11> } <line12> return response; <line13> } <line14> } <line15> "	<line3>
6764	public class A { <line0> @Override <line1> public boolean isSatisified() throws Exception { <line2> long numConnections = hub.broker.getTransportConnectors().get(0).getConnections().size(); <line3> return numConnections == 1; <line4> } <line5> } <line6> 	<line3>
6765	public class A { <line0> protected void addActionsTimed() { <line1> FutureTask<Integer> task = <line2> new FutureTask<>( <line3> new Callable<Integer>() { <line4> @Override <line5> public Integer call() throws Exception { <line6> return addActions(root, Integer.MIN_VALUE, Integer.MAX_VALUE); <line7> } <line8> }); <line9> long startTime = System.nanoTime(); <line10> pool.execute(task); <line11> try { <line12> task.get(maxThink, TimeUnit.SECONDS); <line13> long endTime = System.nanoTime(); <line14> long duration = endTime - startTime; <line15> nodeCount += SimulationNode.nodeCount; <line16> thinkTime += duration; <line17> } catch (TimeoutException e) { <line18> task.cancel(true); <line19> try { <line20> Thread.sleep(1000); <line21> } catch (InterruptedException ex) { <line22> } <line23> long endTime = System.nanoTime(); <line24> long duration = endTime - startTime; <line25> nodeCount += SimulationNode.nodeCount; <line26> thinkTime += duration; <line27> } catch (ExecutionException e) { <line28> task.cancel(true); <line29> } catch (InterruptedException e) { <line30> task.cancel(true); <line31> } <line32> } <line33> } <line34> 	<line15>, <line18>, <line22>, <line25>, <line28>, <line30>
6766	"public class A { <line0> public static com.liferay.portal.kernel.model.UserGroup updateUserGroup( <line1> HttpPrincipal httpPrincipal, <line2> long userGroupId, <line3> String name, <line4> String description, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey( <line10> UserGroupServiceUtil.class, ""updateUserGroup"", _updateUserGroupParameterTypes18); <line11> MethodHandler methodHandler = <line12> new MethodHandler(methodKey, userGroupId, name, description, serviceContext); <line13> Object returnObj = null; <line14> try { <line15> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line18> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line19> } <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (com.liferay.portal.kernel.model.UserGroup) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	<line24>
6767	public class A { <line0> protected void suspendRs(ServerName server) throws IOException { <line1> cluster.suspendRegionServer(server); <line2> if (!(cluster instanceof MiniHBaseCluster)) { <line3> cluster.waitForRegionServerToStop(server, killRsTimeout); <line4> } <line5> getLogger() <line6> } <line7> } <line8> 	<line1>, <line6>
6768	"public class A { <line0> private CompletableFuture<Void> updateSubscriptionPermissionAsync( <line1> NamespaceName namespace, String subscriptionName, Set<String> roles, boolean remove) { <line2> CompletableFuture<Void> result = new CompletableFuture<>(); <line3> try { <line4> validatePoliciesReadOnlyAccess(); <line5> } catch (Exception e) { <line6> result.completeExceptionally(e); <line7> } <line8> final String policiesPath = String.format(""/%s/%s/%s"", ""admin"", POLICIES, namespace.toString()); <line9> try { <line10> Policies policies = <line11> pulsarResources <line12> .getNamespaceResources() <line13> .get(policiesPath) <line14> .orElseThrow(() -> new NotFoundException(policiesPath + "" not found"")); <line15> if (remove) { <line16> if (policies.auth_policies.subscription_auth_roles.get(subscriptionName) != null) { <line17> policies.auth_policies.subscription_auth_roles.get(subscriptionName).removeAll(roles); <line18> } else { <line19> result.completeExceptionally(new IllegalArgumentException(""couldn't find subscription"")); <line20> return result; <line21> } <line22> } else { <line23> policies.auth_policies.subscription_auth_roles.put(subscriptionName, roles); <line24> } <line25> pulsarResources.getNamespaceResources().set(policiesPath, (data) -> policies); <line26> result.complete(null); <line27> } catch (NotFoundException e) { <line28> result.completeExceptionally( <line29> new IllegalArgumentException(""Namespace does not exist"" + namespace)); <line30> } catch (BadVersionException e) { <line31> result.completeExceptionally( <line32> new IllegalStateException( <line33> ""Concurrent modification on zk path: "" + policiesPath + "", "" + e.getMessage())); <line34> } catch (Exception e) { <line35> result.completeExceptionally( <line36> new IllegalStateException(""Failed to get permissions for namespace "" + namespace)); <line37> } <line38> return result; <line39> } <line40> } <line41> "	<line19>, <line26>, <line28>, <line31>, <line35>
6769	"public class A { <line0> public static boolean continueProcessing(Exchange exchange, String message, Logger log) { <line1> ExtendedExchange ee = (ExtendedExchange) exchange; <line2> boolean stop = <line3> ee.isFailed() <line4> || ee.isRollbackOnly() <line5> || ee.isRollbackOnlyLast() <line6> || ee.isErrorHandlerHandledSet() && ee.isErrorHandlerHandled(); <line7> if (stop) { <line8> if (log.isDebugEnabled()) { <line9> StringBuilder sb = new StringBuilder(); <line10> sb.append(""Message exchange has failed: "") <line11> .append(message) <line12> .append("" for exchange: "") <line13> .append(exchange); <line14> if (exchange.isRollbackOnly() || exchange.isRollbackOnlyLast()) { <line15> sb.append("" Marked as rollback only.""); <line16> } <line17> if (exchange.getException() != null) { <line18> sb.append("" Exception: "").append(exchange.getException()); <line19> } <line20> if (ee.isErrorHandlerHandledSet() && ee.isErrorHandlerHandled()) { <line21> sb.append("" Handled by the error handler.""); <line22> } <line23> } <line24> return false; <line25> } <line26> if (ee.isRouteStop()) { <line27> if (log.isDebugEnabled()) { <line28> } <line29> return false; <line30> } <line31> return true; <line32> } <line33> } <line34> "	<line23>, <line28>
6770	"public class A { <line0> @Override <line1> public void run() { <line2> int postNumThreads = Thread.activeCount(); <line3> String msg = <line4> ""pre="" + preNumThreads + ""; post="" + postNumThreads + ""; iterations="" + numIterations; <line5> assertTrue(postNumThreads < preNumThreads + (numIterations / 2), msg); <line6> } <line7> } <line8> "	<line5>
6771	"public class A { <line0> @RequestMapping( <line1> value = ""/{mvnGroup:.+}/{artifact:.+}/{version:.+}/goals/{executionId}"", <line2> method = RequestMethod.OPTIONS) <line3> public ResponseEntity<GoalExecution> isGoalExecutionExisting( <line4> @PathVariable String mvnGroup, <line5> @PathVariable String artifact, <line6> @PathVariable String version, <line7> @PathVariable String executionId, <line8> @ApiIgnore @RequestHeader(value = Constants.HTTP_SPACE_HEADER, required = false) <line9> String space) { <line10> Space s = null; <line11> try { <line12> s = this.spaceRepository.getSpace(space); <line13> } catch (Exception e) { <line14> return new ResponseEntity<GoalExecution>(HttpStatus.NOT_FOUND); <line15> } <line16> Application app = null; <line17> try { <line18> app = <line19> ApplicationRepository.FILTER.findOne( <line20> this.appRepository.findByGAV(mvnGroup, artifact, version, s)); <line21> } catch (EntityNotFoundException e) { <line22> return new ResponseEntity<GoalExecution>(HttpStatus.NOT_FOUND); <line23> } <line24> try { <line25> GoalExecutionRepository.FILTER.findOne(this.gexeRepository.findByExecutionId(executionId)); <line26> return new ResponseEntity<GoalExecution>(HttpStatus.OK); <line27> } catch (EntityNotFoundException enfe) { <line28> return new ResponseEntity<GoalExecution>(HttpStatus.NOT_FOUND); <line29> } <line30> } <line31> } <line32> "	<line14>
6772	public class A { <line0> public void connectionOpen(final NHttpConnection conn) { <line1> if (log.isInfoEnabled()) { <line2> } <line3> } <line4> } <line5> 	<line2>
6773	public class A { <line0> private synchronized void loadConfiguration() { <line1> if (Services.get() != null) { <line2> KiteConfigurationService kiteService = Services.get().get(KiteConfigurationService.class); <line3> if (kiteService != null) { <line4> Configuration kiteConf = kiteService.getKiteConf(); <line5> if (kiteConf != null) { <line6> DefaultConfiguration.set(kiteConf); <line7> } else { <line8> } <line9> } else { <line10> } <line11> } else { <line12> } <line13> } <line14> } <line15> 	<line8>, <line10>, <line12>
6774	"public class A { <line0> @Override <line1> public void handleClose() throws QueryEvaluationException { <line2> try { <line3> Object take = queueRef.poll(); <line4> while (take != null) { <line5> if (take instanceof CloseableIteration) { <line6> @SuppressWarnings(""unchecked"") <line7> CloseableIteration<T, QueryEvaluationException> closable = <line8> (CloseableIteration<T, QueryEvaluationException>) take; <line9> try { <line10> closable.close(); <line11> } catch (Throwable t) { <line12> } <line13> } <line14> take = queueRef.poll(); <line15> } <line16> done(); <line17> } finally { <line18> super.handleClose(); <line19> } <line20> } <line21> } <line22> "	<line10>, <line12>
6775	public class A { <line0> @Override <line1> public Class<?> getImplementingClass(String key) { <line2> readLock.lock(); <line3> try { <line4> for (IPentahoObjectFactory fact : factories) { <line5> if (fact.objectDefined(key)) { <line6> return fact.getImplementingClass(key); <line7> } <line8> } <line9> } finally { <line10> readLock.unlock(); <line11> } <line12> return null; <line13> } <line14> } <line15> 	<line6>
6776	public class A { <line0> private void run(ExecutionMonitor monitor, ExecutionContext context, HadoopScript script) <line1> throws InterruptedException, IOException { <line2> assert monitor != null; <line3> assert context != null; <line4> assert script != null; <line5> monitor.open(100); <line6> try { <line7> monitor.checkCancelled(); <line8> JobInfo info = registerScript(monitor, context, script); <line9> monitor.progressed(5); <line10> monitor.checkCancelled(); <line11> submitScript(context, info); <line12> monitor.progressed(5); <line13> monitor.checkCancelled(); <line14> long start = System.currentTimeMillis(); <line15> try { <line16> JobStatus.Kind lastKind = JobStatus.Kind.INITIALIZED; <line17> while (true) { <line18> JobStatus status = poll(context, info); <line19> JobStatus.Kind currentKind = status.getKind(); <line20> if (lastKind.compareTo(currentKind) < 0) { <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> switch (currentKind) { <line24> case WAITING: <line25> break; <line26> case RUNNING: <line27> monitor.progressed(10); <line28> break; <line29> case COMPLETED: <line30> case ERROR: <line31> checkError(context, info, status); <line32> return; <line33> default: <line34> throw new AssertionError(currentKind); <line35> } <line36> } <line37> lastKind = currentKind; <line38> monitor.checkCancelled(); <line39> Thread.sleep(pollingInterval); <line40> } <line41> } finally { <line42> long end = System.currentTimeMillis(); <line43> } <line44> } finally { <line45> monitor.close(); <line46> } <line47> } <line48> } <line49> 	<line14>, <line22>, <line43>
6777	"public class A { <line0> public static void setSystemProperty(ServerContext context, String property, String value) <line1> throws KeeperException, InterruptedException { <line2> final var original = property; <line3> property = <line4> DeprecatedPropertyUtil.getReplacementName( <line5> property, <line6> (log, replacement) -> { <line7> }); <line8> if (!Property.isValidZooPropertyKey(property)) { <line9> IllegalArgumentException iae = <line10> new IllegalArgumentException(""Zookeeper property is not mutable: "" + property); <line11> throw iae; <line12> } <line13> Property foundProp = null; <line14> for (Property prop : Property.values()) { <line15> if (prop.getType() == PropertyType.PREFIX && property.startsWith(prop.getKey()) <line16> || prop.getKey().equals(property)) { <line17> foundProp = prop; <line18> break; <line19> } <line20> } <line21> if ((foundProp == null <line22> || (foundProp.getType() != PropertyType.PREFIX <line23> && !foundProp.getType().isValidFormat(value)))) { <line24> IllegalArgumentException iae = <line25> new IllegalArgumentException( <line26> ""Ignoring property "" + property + "" it is either null or in an invalid format""); <line27> throw iae; <line28> } <line29> String zPath = context.getZooKeeperRoot() + Constants.ZCONFIG + ""/"" + property; <line30> context <line31> .getZooReaderWriter() <line32> .putPersistentData(zPath, value.getBytes(UTF_8), NodeExistsPolicy.OVERWRITE); <line33> } <line34> } <line35> "	<line7>, <line11>, <line27>
6778	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> bazaarEventListener.onRegistrationSucceeded(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	<line5>
6779	public class A { <line0> private int addGeneralizedPattern(OWLAxiom axiom) { <line1> String axiomString = render(axiom); <line2> Integer patternID = getGeneralizedPatternID(axiom); <line3> if (patternID != null) { <line4> return patternID; <line5> } <line6> try { <line7> insertPatternGeneralizationPs.setString(1, axiomString); <line8> insertPatternGeneralizationPs.setString(2, axiomRenderer.render(axiom)); <line9> insertPatternGeneralizationPs.setString(3, getAxiomType(axiom)); <line10> insertPatternGeneralizationPs.execute(); <line11> } catch (SQLException e) { <line12> } <line13> return getGeneralizedPatternID(axiom); <line14> } <line15> } <line16> 	<line12>
6780	public class A { <line0> public TmpRepZob merge(TmpRepZob detachedInstance) { <line1> try { <line2> TmpRepZob result = (TmpRepZob) sessionFactory.getCurrentSession().merge(detachedInstance); <line3> return result; <line4> } catch (RuntimeException re) { <line5> throw re; <line6> } <line7> } <line8> } <line9> 	<line1>, <line3>, <line5>
6781	"public class A { <line0> private Integer doHttpPost(String url, String requestBody, Map<String, String> headers) <line1> throws ServerlessRuleFailedException { <line2> PostMethod httppost = null; <line3> Gson gson = new GsonBuilder().create(); <line4> try { <line5> httppost = new PostMethod(url); <line6> for (Map.Entry<String, String> entry : headers.entrySet()) { <line7> httppost.addRequestHeader(entry.getKey(), entry.getValue()); <line8> } <line9> httppost.setRequestHeader(""Content-Type"", ""application/json""); <line10> httppost.setRequestEntity(new StringRequestEntity(requestBody, null, null)); <line11> int responsecode = httpClient.executeMethod(httppost); <line12> if (HttpStatus.SC_OK == responsecode) { <line13> httppost.releaseConnection(); <line14> return responsecode; <line15> } else <line16> throw new ServerlessRuleFailedException(httppost.getResponseBodyAsString(), responsecode); <line17> } catch (org.apache.http.ParseException parseException) { <line18> } catch (IOException ioException) { <line19> } finally { <line20> if (null != httppost) { <line21> httppost.releaseConnection(); <line22> } <line23> } <line24> return null; <line25> } <line26> } <line27> "	<line18>, <line19>
6782	public class A { <line0> public boolean isExpired() { <line1> boolean messageExpired; <line2> if (this.expiryTime == 0) { <line3> messageExpired = false; <line4> } else { <line5> long currentTime = System.currentTimeMillis(); <line6> if (currentTime > expiryTime) { <line7> messageExpired = true; <line8> } else { <line9> messageExpired = false; <line10> } <line11> } <line12> return messageExpired; <line13> } <line14> } <line15> 	<line7>
6783	public class A { <line0> @PostConstruct <line1> @Order(1) <line2> void postConstruct() { <line3> } <line4> } <line5> 	<line3>
6784	public class A { <line0> public synchronized Command handleTimeoutNowRequest(TimeoutNowRequest request) { <line1> TimeoutNowResponse response = new TimeoutNowResponse(true, currentTerm); <line2> do { <line3> if (request.getTerm() != currentTerm) { <line4> if (request.getTerm() > currentTerm) { <line5> stepDown(request.getTerm()); <line6> } <line7> response.setSuccess(false); <line8> break; <line9> } <line10> if (state() != FOLLOWER) { <line11> response.setSuccess(false); <line12> break; <line13> } <line14> response.setTerm(currentTerm + 1); <line15> resetElectionTimer(); <line16> electSelf(); <line17> } while (false); <line18> JoyQueueHeader header = <line19> new JoyQueueHeader(Direction.RESPONSE, CommandType.RAFT_TIMEOUT_NOW_RESPONSE); <line20> return new Command(header, response); <line21> } <line22> } <line23> 	<line4>, <line11>
6785	"public class A { <line0> @Override <line1> public void execute(RefreshConfigurationRequest request, RefreshConfigurationResponse response) <line2> throws Exception { <line3> if (context instanceof ReconfigurableApplicationContext) { <line4> ReconfigurableApplicationContext rollback = (ReconfigurableApplicationContext) context; <line5> if (request.getConfigLocations() != null) { <line6> ArrayList<String> configLocations = new ArrayList<String>(); <line7> configLocations.add(""org/geomajas/spring/geomajasContext.xml""); <line8> configLocations.addAll(Arrays.asList(request.getConfigLocations())); <line9> try { <line10> rollback.refresh(configLocations.toArray(new String[configLocations.size()])); <line11> } catch (GeomajasException e) { <line12> rollback.rollback(); <line13> response.setApplicationNames(context.getBeanNamesForType(ClientApplicationInfo.class)); <line14> throw e; <line15> } <line16> response.setApplicationNames(context.getBeanNamesForType(ClientApplicationInfo.class)); <line17> } <line18> } else { <line19> response.setApplicationNames(context.getBeanNamesForType(ClientApplicationInfo.class)); <line20> throw new GeomajasException(ExceptionCode.REFRESH_CONFIGURATION_FAILED); <line21> } <line22> } <line23> } <line24> "	<line12>
6786	public class A { <line0> public Map<Locator, MetricData> getDatapointsForRange( <line1> List<Locator> locators, Range range, Granularity gran) { <line2> ListMultimap<ColumnFamily, Locator> locatorsByCF = ArrayListMultimap.create(); <line3> Map<Locator, MetricData> results = new HashMap<Locator, MetricData>(); <line4> for (Locator locator : locators) { <line5> try { <line6> RollupType rollupType = <line7> RollupType.fromString( <line8> metaCache.get(locator, MetricMetadata.ROLLUP_TYPE.name().toLowerCase())); <line9> ColumnFamily cf = CassandraModel.getColumnFamily(rollupType, gran); <line10> List<Locator> locs = locatorsByCF.get(cf); <line11> locs.add(locator); <line12> } catch (Exception e) { <line13> } <line14> } <line15> for (ColumnFamily CF : locatorsByCF.keySet()) { <line16> List<Locator> locs = locatorsByCF.get(CF); <line17> results.putAll(getNumericDataForRangeLocatorList(range, gran, CF, locs)); <line18> } <line19> return results; <line20> } <line21> } <line22> 	<line13>
6787	"public class A { <line0> public void run() throws ParameterException, WorkflowExecutionException, ConfigurationException { <line1> MitmCommandConfig cmdConfig = new MitmCommandConfig(new GeneralDelegate()); <line2> JCommander commander = new JCommander(cmdConfig); <line3> try { <line4> commander.parse(args); <line5> } catch (ParameterException pe) { <line6> LOGGER.error(""Could not parse provided parameters. "" + pe.getLocalizedMessage()); <line7> LOGGER.info(""Try -help""); <line8> throw pe; <line9> } <line10> if (cmdConfig.getGeneralDelegate().isHelp()) { <line11> commander.usage(); <line12> return; <line13> } <line14> ListDelegate list = (ListDelegate) cmdConfig.getDelegate(ListDelegate.class); <line15> if (list.isSet()) { <line16> list.plotListing(); <line17> return; <line18> } <line19> try { <line20> Config config = cmdConfig.createConfig(); <line21> executeMitmWorkflow(config); <line22> } catch (WorkflowExecutionException wee) { <line23> throw wee; <line24> } catch (ConfigurationException ce) { <line25> throw ce; <line26> } catch (ParameterException pe) { <line27> throw pe; <line28> } <line29> } <line30> } <line31> "	<line23>, <line25>, <line27>
6788	"public class A { <line0> private InvocationResults updateUri(String uri, String payload) throws URISyntaxException { <line1> String[] uriParts = uri.split(""/""); <line2> if (uriParts.length == 3) { <line3> String serviceName = uriParts[1]; <line4> String csid = uriParts[2]; <line5> NuxeoBasedResource resource = (NuxeoBasedResource) getResourceMap().get(serviceName); <line6> resource.update(getServiceContext(), getResourceMap(), createUriInfo(), csid, payload); <line7> } else if (uriParts.length == 5) { <line8> String serviceName = uriParts[1]; <line9> String vocabularyCsid = uriParts[2]; <line10> String items = uriParts[3]; <line11> String csid = uriParts[4]; <line12> if (items.equals(""items"")) { <line13> AuthorityResource<?, ?> resource = <line14> (AuthorityResource<?, ?>) getResourceMap().get(serviceName); <line15> resource.updateAuthorityItem( <line16> getServiceContext(), getResourceMap(), createUriInfo(), vocabularyCsid, csid, payload); <line17> } <line18> } else { <line19> throw new IllegalArgumentException(""Invalid uri "" + uri); <line20> } <line21> InvocationResults results = new InvocationResults(); <line22> results.setNumAffected(1); <line23> results.setUserNote(""Updated referencing record "" + uri); <line24> return results; <line25> } <line26> } <line27> "	<line21>
6789	public class A { <line0> public List<Integer> getDemoIds(String indicatorName) { <line1> if (indicatorName == null || indicatorName.isEmpty()) return null; <line2> demoIds = new ArrayList<Integer>(); <line3> List<DemographicExt> allProviderDemoExts = <line4> demographicExtDao.getDemographicExtByKeyAndValue(excludeIndicator, indicatorName); <line5> String providerNo = getProviderNo(); <line6> for (DemographicExt e : allProviderDemoExts) { <line7> if (e.getProviderNo().equals(providerNo) && isCurrentExclusion(e)) { <line8> demoIds.add(e.getDemographicNo()); <line9> } <line10> } <line11> return demoIds; <line12> } <line13> } <line14> 	<line5>, <line9>
6790	"public class A { <line0> @Override <line1> public void onSessionRemoteOpen(Event e) { <line2> final Session session = e.getSession(); <line3> if (session.getLocalState() == EndpointState.UNINITIALIZED) { <line4> logger.warning( <line5> ""onSessionRemoteOpen connectionId[{}], entityName[{}], sessionIncCapacity[{}],"" <line6> + "" sessionOutgoingWindow[{}] endpoint was uninitialised."", <line7> getConnectionId(), <line8> entityName, <line9> session.getIncomingCapacity(), <line10> session.getOutgoingWindow()); <line11> session.open(); <line12> } else { <line13> } <line14> onNext(EndpointState.ACTIVE); <line15> } <line16> } <line17> "	<line13>
6791	"public class A { <line0> @Override <line1> public void processTuple(byte[] inputTuple) { <line2> if (inputTuple == null) { <line3> this.emitError(null, ""null tuple""); <line4> return; <line5> } <line6> String incomingString = """"; <line7> try { <line8> incomingString = new String(inputTuple, encoding); <line9> if (StringUtils.isBlank(incomingString)) { <line10> this.emitError(incomingString, ""Blank tuple""); <line11> return; <line12> } <line13> if (this.logSchemaDetails != null && clazz != null) { <line14> if (parsedOutput.isConnected()) { <line15> parsedOutput.emit( <line16> objMapper.readValue( <line17> this.logSchemaDetails.createJsonFromLog(incomingString).toString().getBytes(), <line18> clazz)); <line19> parsedOutputCount++; <line20> } <line21> } <line22> } catch (NullPointerException | IOException | JSONException e) { <line23> this.emitError(incomingString, e.getMessage()); <line24> } <line25> } <line26> } <line27> "	<line13>, <line24>
6792	"public class A { <line0> public static void main(String[] args) throws Exception { <line1> org.apache.log4j.Logger.getLogger(""io.netty"").setLevel(org.apache.log4j.Level.OFF); <line2> try { <line3> Configuration cfg = new Configuration(); <line4> cfg.tryGetValuesFromSystem(); <line5> JCommander jcommander = new JCommander(cfg, args); <line6> if (cfg.isHelp()) { <line7> jcommander.usage(); <line8> return; <line9> } <line10> AsyncBenchmark benchmark; <line11> switch (cfg.getOperationType()) { <line12> case WriteThroughput: <line13> case WriteLatency: <line14> benchmark = new AsyncWriteBenchmark(cfg); <line15> break; <line16> case ReadThroughput: <line17> case ReadLatency: <line18> benchmark = new AsyncReadBenchmark(cfg); <line19> break; <line20> case QueryCross: <line21> case QuerySingle: <line22> case QueryParallel: <line23> case QueryOrderby: <line24> case QueryAggregate: <line25> case QueryTopOrderby: <line26> case QueryAggregateTopOrderby: <line27> benchmark = new AsyncQueryBenchmark(cfg); <line28> break; <line29> case Mixed: <line30> benchmark = new AsyncMixedBenchmark(cfg); <line31> break; <line32> case QuerySingleMany: <line33> benchmark = new AsyncQuerySinglePartitionMultiple(cfg); <line34> break; <line35> case ReadMyWrites: <line36> benchmark = new ReadMyWriteWorkflow(cfg); <line37> break; <line38> default: <line39> throw new RuntimeException(cfg.getOperationType() + "" is not supported""); <line40> } <line41> benchmark.run(); <line42> benchmark.shutdown(); <line43> } catch (ParameterException e) { <line44> System.err.println(""Invalid Usage: "" + e.getMessage()); <line45> System.err.println(""Try '-help' for more information.""); <line46> throw e; <line47> } <line48> } <line49> } <line50> "	<line3>, <line41>
6793	public class A { <line0> private void unregisterClient( <line1> ClientProxyMembershipID proxyID, <line2> boolean clientDisconnectedCleanly, <line3> Throwable clientDisconnectException) { <line4> if (clientHeartbeats.remove(proxyID) != null) { <line5> if (clientDisconnectedCleanly) { <line6> if (logger.isDebugEnabled()) { <line7> } <line8> } else { <line9> } <line10> if (stats != null) { <line11> stats.incClientUnRegisterRequests(); <line12> } <line13> expireTXStates(proxyID); <line14> } <line15> clientMaximumTimeBetweenPings.remove(proxyID); <line16> } <line17> } <line18> 	<line7>, <line9>
6794	"public class A { <line0> public static void decryptWithSubjectKey( <line1> OutputStream out, <line2> InputStream in, <line3> int outLen, <line4> String subject, <line5> Configuration conf, <line6> Cipher cipher, <line7> byte[] iv) <line8> throws IOException { <line9> Key key = getSecretKeyForSubject(subject, conf); <line10> if (key == null) { <line11> throw new IOException(""No key found for subject '"" + subject + ""'""); <line12> } <line13> Decryptor d = cipher.getDecryptor(); <line14> d.setKey(key); <line15> d.setIv(iv); <line16> try { <line17> decrypt(out, in, outLen, d); <line18> } catch (IOException e) { <line19> String alternateAlgorithm = conf.get(HConstants.CRYPTO_ALTERNATE_KEY_ALGORITHM_CONF_KEY); <line20> if (alternateAlgorithm != null) { <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> Cipher alterCipher = Encryption.getCipher(conf, alternateAlgorithm); <line24> if (alterCipher == null) { <line25> throw new RuntimeException(""Cipher '"" + alternateAlgorithm + ""' not available""); <line26> } <line27> d = alterCipher.getDecryptor(); <line28> d.setKey(key); <line29> d.setIv(iv); <line30> decrypt(out, in, outLen, d); <line31> } else { <line32> throw new IOException(e); <line33> } <line34> } <line35> } <line36> } <line37> "	<line22>
6795	public class A { <line0> public void addNode(String name) { <line1> Spatial s = jme.find(name); <line2> if (s != null) { <line3> return; <line4> } <line5> Node n = new Node(name); <line6> jme.getRootNode().attachChild(n); <line7> } <line8> } <line9> 	<line3>
6796	public class A { <line0> static @Nullable State handleRefresh( <line1> ChannelUID channelUID, String channelId, VeluxBridgeHandler thisBridgeHandler) { <line2> State newState = null; <line3> thisBridgeHandler.bridgeParameters.lanConfig = <line4> new VeluxBridgeLANConfig().retrieve(thisBridgeHandler.thisBridge); <line5> if (thisBridgeHandler.bridgeParameters.lanConfig.isRetrieved) { <line6> VeluxItemType itemType = <line7> VeluxItemType.getByThingAndChannel( <line8> thisBridgeHandler.thingTypeUIDOf(channelUID), channelUID.getId()); <line9> switch (itemType) { <line10> case BRIDGE_ADDRESS: <line11> newState = <line12> StateUtils.createState(thisBridgeHandler.bridgeParameters.lanConfig.openHABipAddress); <line13> break; <line14> case BRIDGE_SUBNETMASK: <line15> newState = <line16> StateUtils.createState( <line17> thisBridgeHandler.bridgeParameters.lanConfig.openHABsubnetMask); <line18> break; <line19> case BRIDGE_DEFAULTGW: <line20> newState = <line21> StateUtils.createState(thisBridgeHandler.bridgeParameters.lanConfig.openHABdefaultGW); <line22> break; <line23> case BRIDGE_DHCP: <line24> newState = <line25> StateUtils.createState( <line26> thisBridgeHandler.bridgeParameters.lanConfig.openHABenabledDHCP); <line27> default: <line28> } <line29> } <line30> return newState; <line31> } <line32> } <line33> 	<line2>, <line30>
6797	"public class A { <line0> @Override <line1> protected void doDeleteIdentity(String principalName) throws KrbException { <line2> try { <line3> Dn dn = toDn(principalName); <line4> new FailoverInvocationHandler<Void>() { <line5> @Override <line6> public Void execute() throws LdapException { <line7> connection.delete(dn); <line8> return null; <line9> } <line10> }.run(); <line11> } catch (LdapException e) { <line12> throw new KrbException(""Failed to remove identity"", e); <line13> } <line14> } <line15> } <line16> "	<line12>
6798	public class A { <line0> public static void SyncHosts( <line1> ClusterCreate clusterSpec, Set<String> hostnames, SoftwareManager softMgr) { <line2> int maxTimeDiffInSec = Constants.MAX_TIME_DIFF_IN_SEC; <line3> if (softMgr.hasHbase(clusterSpec.toBlueprint())) <line4> maxTimeDiffInSec = Constants.MAX_TIME_DIFF_IN_SEC_HBASE; <line5> List<String> outOfSyncHosts = new ArrayList<String>(); <line6> for (String hostname : hostnames) { <line7> int hostTimeDiffInSec = VcResourceUtils.getHostTimeDiffInSec(hostname); <line8> if (Math.abs(hostTimeDiffInSec) > maxTimeDiffInSec) { <line9> outOfSyncHosts.add(hostname); <line10> } <line11> } <line12> if (!outOfSyncHosts.isEmpty()) { <line13> String managementServerHost = VcResourceUtils.getManagementServerHost(); <line14> throw TaskException.HOST_TIME_OUT_OF_SYNC(outOfSyncHosts, managementServerHost); <line15> } <line16> } <line17> } <line18> 	<line9>, <line14>
6799	"public class A { <line0> private void handleTestConnectivityFailure( <line1> String name, <line2> ReconnectionConfig reconnectionConfig, <line3> RetryContext context, <line4> ConnectionValidationResult result) <line5> throws ConnectionException { <line6> if ((reconnectionConfig.isFailsDeployment())) { <line7> context.setFailed(result.getException()); <line8> throw new ConnectionException( <line9> format(""Connectivity test failed for config '%s'"", name), result.getException()); <line10> } else { <line11> if (LOGGER.isInfoEnabled()) { <line12> } <line13> } <line14> } <line15> } <line16> "	<line12>
6800	public class A { <line0> public ListenableFuture<Void> onDeviceCredentialsUpdate( <line1> TenantId tenantId, DeviceCredentialsUpdateMsg deviceCredentialsUpdateMsg) { <line2> DeviceId deviceId = <line3> new DeviceId( <line4> new UUID( <line5> deviceCredentialsUpdateMsg.getDeviceIdMSB(), <line6> deviceCredentialsUpdateMsg.getDeviceIdLSB())); <line7> ListenableFuture<Device> deviceFuture = deviceService.findDeviceByIdAsync(tenantId, deviceId); <line8> return Futures.transform( <line9> deviceFuture, <line10> device -> { <line11> if (device != null) { <line12> try { <line13> DeviceCredentials deviceCredentials = <line14> deviceCredentialsService.findDeviceCredentialsByDeviceId( <line15> tenantId, device.getId()); <line16> deviceCredentials.setCredentialsType( <line17> DeviceCredentialsType.valueOf(deviceCredentialsUpdateMsg.getCredentialsType())); <line18> deviceCredentials.setCredentialsId(deviceCredentialsUpdateMsg.getCredentialsId()); <line19> deviceCredentials.setCredentialsValue( <line20> deviceCredentialsUpdateMsg.getCredentialsValue()); <line21> deviceCredentialsService.updateDeviceCredentials(tenantId, deviceCredentials); <line22> } catch (Exception e) { <line23> throw new RuntimeException(e); <line24> } <line25> } <line26> return null; <line27> }, <line28> dbCallbackExecutorService); <line29> } <line30> } <line31> 	<line2>, <line12>, <line23>
6801	"public class A { <line0> private List<BitVectorValue> preprocess( <line1> final DataTable inData, <line2> final ExecutionMonitor exec, <line3> final Map<Integer, RowKey> tidRowKeyMapping, <line4> final AtomicInteger maxBitsetLength) <line5> throws CanceledExecutionException { <line6> int nrOfRows = 0; <line7> int totalNrRows = ((BufferedDataTable) inData).getRowCount(); <line8> List<BitVectorValue> bitSets = new ArrayList<BitVectorValue>(); <line9> int bitVectorIndex = <line10> inData.getDataTableSpec().findColumnIndex(m_transactionColumn.getStringValue()); <line11> if (bitVectorIndex < 0) { <line12> return new ArrayList<BitVectorValue>(); <line13> } <line14> for (DataRow currRow : inData) { <line15> exec.checkCanceled(); <line16> DataCell dc = currRow.getCell(bitVectorIndex); <line17> if (dc.isMissing()) { <line18> continue; <line19> } <line20> BitVectorValue currCell = ((BitVectorValue) currRow.getCell(bitVectorIndex)); <line21> if (currCell.length() > Integer.MAX_VALUE) { <line22> throw new IllegalArgumentException( <line23> ""bit vector in row "" <line24> + currRow.getKey().getString() <line25> + "" is too long: "" <line26> + currCell.length() <line27> + "". Only bit vectors up to "" <line28> + Integer.MAX_VALUE <line29> + "" are supported by this node.""); <line30> } <line31> maxBitsetLength.set(Math.max(maxBitsetLength.get(), (int) currCell.length())); <line32> bitSets.add(currCell); <line33> tidRowKeyMapping.put(nrOfRows, currRow.getKey()); <line34> nrOfRows++; <line35> exec.setProgress((double) nrOfRows / (double) totalNrRows, ""preprocessing..."" + nrOfRows); <line36> } <line37> return bitSets; <line38> } <line39> } <line40> "	<line37>
6802	public class A { <line0> @Override <line1> public boolean move(SshFile target) { <line2> return super.move((SafFile) target); <line3> } <line4> } <line5> 	<line2>
6803	"public class A { <line0> public static byte[] compute( <line1> PRFAlgorithm prfAlgorithm, byte[] secret, String label, byte[] seed, int size) <line2> throws CryptoException { <line3> if (prfAlgorithm == null) { <line4> prfAlgorithm = PRFAlgorithm.TLS_PRF_LEGACY; <line5> } <line6> switch (prfAlgorithm) { <line7> case TLS_PRF_SHA256: <line8> case TLS_PRF_SHA384: <line9> case TLS_PRF_GOSTR3411: <line10> case TLS_PRF_GOSTR3411_2012_256: <line11> return computeTls12( <line12> secret, label, seed, size, prfAlgorithm.getMacAlgorithm().getJavaName()); <line13> case TLS_PRF_LEGACY: <line14> return TlsUtils.PRF_legacy(secret, label, seed, size); <line15> default: <line16> throw new UnsupportedOperationException( <line17> ""PRF computation for different"" + "" protocol versions is not supported yet""); <line18> } <line19> } <line20> } <line21> "	<line4>
6804	"public class A { <line0> private void checkSemaphore() throws Exception { <line1> checkAcquire(); <line2> checkRelease(); <line3> checkFailoverSafe(); <line4> final IgniteSemaphore semaphore1 = grid(0).semaphore(""semaphore"", -2, true, true); <line5> assertEquals(-2, semaphore1.availablePermits()); <line6> IgniteFuture<Object> fut = <line7> grid(0) <line8> .compute() <line9> .callAsync( <line10> new IgniteCallable<Object>() { <line11> @IgniteInstanceResource private Ignite ignite; <line12> @LoggerResource private IgniteLogger log; <line13>  <line14> @Nullable <line15> @Override <line16> public Object call() throws Exception { <line17> IgniteInternalFuture<?> fut = <line18> GridTestUtils.runMultiThreadedAsync( <line19> new Callable<Object>() { <line20> @Nullable <line21> @Override <line22> public Object call() throws Exception { <line23> IgniteSemaphore semaphore = <line24> ignite.semaphore(""semaphore"", -2, true, true); <line25> assert semaphore != null && semaphore.availablePermits() == -2; <line26> assert semaphore.tryAcquire(1, 1, MINUTES); <line27> semaphore.release(); <line28> return null; <line29> } <line30> }, <line31> 5, <line32> ""test-thread""); <line33> fut.get(); <line34> return null; <line35> } <line36> }); <line37> Thread.sleep(3000); <line38> semaphore1.release(2); <line39> assert semaphore1.availablePermits() == 0; <line40> semaphore1.release(1); <line41> fut.get(); <line42> semaphore1.close(); <line43> checkRemovedSemaphore(semaphore1); <line44> } <line45> } <line46> "	<line26>, <line27>
6805	"public class A { <line0> public void loggingSnippets() { <line1> ClientLogger logger = new ClientLogger(ClientLoggerJavaDocCodeSnippets.class); <line2> String name = getName(); <line3> logger.verbose(""A log message""); <line4> logger.verbose(""A formattable message. Hello, {}"", name); <line5> Throwable detailedException = <line6> new IllegalArgumentException(""A exception with a detailed message""); <line7> logger.warning(detailedException.getMessage()); <line8> Throwable exception = new IllegalArgumentException(""An invalid argument was encountered.""); <line9> logger.warning(""A formattable message. Hello, {}"", name, exception); <line10> File resource = getFile(); <line11> try { <line12> upload(resource); <line13> } catch (IOException ex) { <line14> } <line15> try { <line16> upload(resource); <line17> } catch (IOException ex) { <line18> } <line19> } <line20> } <line21> "	<line5>, <line14>, <line18>
6806	public class A { <line0> @Override <line1> public void filter(ContainerRequestContext requestContext) throws IOException { <line2> String path = requestContext.getUriInfo().getPath(); <line3> BaseUmaProtectionService protectionService = null; <line4> for (String prefix : protectionMapping.keySet()) { <line5> if (path.startsWith(prefix)) { <line6> protectionService = protectionServiceInstance.select(protectionMapping.get(prefix)).get(); <line7> break; <line8> } <line9> } <line10> if (protectionService == null) { <line11> } else { <line12> Response authorizationResponse = <line13> protectionService.processAuthorization(httpHeaders, resourceInfo); <line14> else requestContext.abortWith(authorizationResponse); <line15> } <line16> } <line17> } <line18> 	<line3>, <line11>, <line12>, <line14>
6807	"public class A { <line0> private Response doAdvancedSearch(String propertyName, String propertyValue, String operator) <line1> throws Exception { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> String whereClause = propertyName + operator + ""'"" + propertyValue + ""'""; <line5> CollectionObjectClient client = new CollectionObjectClient(); <line6> Response res = client.advancedSearchIncludeDeleted(whereClause, false); <line7> return res; <line8> } <line9> } <line10> "	<line3>
6808	public class A { <line0> public synchronized void setExpiredFromCache() { <line1> if (users.get() != 0) { <line2> } <line3> expiredFromCache = true; <line4> } <line5> } <line6> 	<line2>
6809	public class A { <line0> @Deprecated <line1> @Override <line2> public void execute(ModelInfo model, IUserContext user, Map<String, Object> context) { <line3> IModelPolicyManager policyManager = repositoryFactory.getPolicyManager(user.getWorkspaceId()); <line4> IRole role = roleToMakeReadOnly.get(); <line5> Collection<PolicyEntry> policies = policyManager.getPolicyEntries(model.getId()); <line6> for (PolicyEntry policy : policies) { <line7> if (policy.getPrincipalId().equals(role.getName()) <line8> && policy.getPrincipalType() == PrincipalType.Role) { <line9> policyManager.makePolicyEntryReadOnly(model.getId(), policy); <line10> break; <line11> } <line12> } <line13> } <line14> } <line15> 	<line5>
6810	"public class A { <line0> public boolean isTerminal(String vertexName) { <line1> waitForElement(String.format(VERTEX_TEMPLATE, vertexName), DEFAULT_TIMEOUT, ""Vertex not found""); <line2> WebElement vertex = driver.findElement(By.xpath(String.format(VERTEX_TEMPLATE, vertexName))); <line3> String vertexClass = vertex.getAttribute(""class""); <line4> return vertexClass.contains(""lineage-node-terminal""); <line5> } <line6> } <line7> "	<line1>
6811	public class A { <line0> @Override <line1> public void onError(Throwable t) { <line2> if (active) { <line3> synchronized (GrpcClientStreamer.this) { <line4> handleError(t, this); <line5> GrpcClientStreamer.this.notifyAll(); <line6> } <line7> } <line8> } <line9> } <line10> 	<line2>
6812	public class A { <line0> @After <line1> public void cleanUp() throws IOException { <line2> channel.shutdown(); <line3> } <line4> } <line5> 	<line2>
6813	public class A { <line0> private void closeStatement() { <line1> Statement _statement = <line2> statement != null <line3> ? statement <line4> : preparedStatement != null ? preparedStatement : callableStatement; <line5> statement = null; <line6> preparedStatement = null; <line7> callableStatement = null; <line8> if (_statement != null) { <line9> try { <line10> _statement.close(); <line11> } catch (Throwable e) { <line12> } <line13> } <line14> } <line15> } <line16> 	<line12>
6814	"public class A { <line0> private void validateScopes( <line1> String apiContext, <line2> String apiVersion, <line3> ResourceConfig matchingResource, <line4> JWTValidationInfo jwtValidationInfo, <line5> SignedJWTInfo jwtToken) <line6> throws APISecurityException { <line7> try { <line8> String tenantDomain = ""carbon.super""; <line9> TokenValidationContext tokenValidationContext = new TokenValidationContext(); <line10> APIKeyValidationInfoDTO apiKeyValidationInfoDTO = new APIKeyValidationInfoDTO(); <line11> Set<String> scopeSet = new HashSet<>(); <line12> scopeSet.addAll(jwtValidationInfo.getScopes()); <line13> apiKeyValidationInfoDTO.setScopes(scopeSet); <line14> tokenValidationContext.setValidationInfoDTO(apiKeyValidationInfoDTO); <line15> tokenValidationContext.setAccessToken(jwtToken.getToken()); <line16> tokenValidationContext.setHttpVerb(matchingResource.getPath().toUpperCase()); <line17> tokenValidationContext.setMatchingResourceConfig(matchingResource); <line18> tokenValidationContext.setContext(apiContext); <line19> tokenValidationContext.setVersion(apiVersion); <line20> boolean valid = <line21> ReferenceHolder.getInstance() <line22> .getKeyValidationHandler(tenantDomain) <line23> .validateScopes(tokenValidationContext); <line24> if (valid) { <line25> if (log.isDebugEnabled()) { <line26> } <line27> } else { <line28> String message = <line29> ""User is NOT authorized to access the Resource: "" <line30> + matchingResource.getPath() <line31> + "". Scope validation failed.""; <line32> throw new APISecurityException( <line33> APIConstants.StatusCodes.UNAUTHORIZED.getCode(), <line34> APISecurityConstants.INVALID_SCOPE, <line35> message); <line36> } <line37> } catch (EnforcerException e) { <line38> String message = ""Error while accessing backend services for token scope validation""; <line39> throw new APISecurityException( <line40> APIConstants.StatusCodes.UNAUTHENTICATED.getCode(), <line41> APISecurityConstants.API_AUTH_GENERAL_ERROR, <line42> message, <line43> e); <line44> } <line45> } <line46> } <line47> "	<line26>, <line32>, <line39>
6815	public class A { <line0> private synchronized void initializeLockingMap() <line1> throws ClassNotFoundException, IllegalAccessException, InvocationTargetException, IOException, <line2> NoSuchMethodException, InstantiationException { <line3> if (lockingMap == null) { <line4> Map<String, LockingSupport> map = new HashMap<>(); <line5> CRUDController[] controllers = getFactory().getCRUDControllers(); <line6> for (CRUDController controller : controllers) { <line7> if (controller instanceof ExtensionSupport) { <line8> LockingSupport lockingSupport = <line9> (LockingSupport) <line10> ((ExtensionSupport) controller).getExtensionInstance(LockingSupport.class); <line11> if (lockingSupport != null) { <line12> for (String domain : lockingSupport.getLockingDomains()) { <line13> map.put(domain, lockingSupport); <line14> } <line15> } <line16> } <line17> } <line18> lockingMap = map; <line19> } <line20> } <line21> } <line22> 	<line4>, <line6>, <line7>, <line8>, <line12>, <line18>
6816	public class A { <line0> private void waitForFuturesToComplete(List<Future> futures) { <line1> try { <line2> for (Future future : futures) { <line3> future.get(); <line4> } <line5> } catch (InterruptedException e) { <line6> } catch (ExecutionException e) { <line7> } <line8> } <line9> } <line10> 	<line6>, <line7>
6817	public class A { <line0> private Duration getControllerClientSslHandshakeTimeoutFromEnvironment() { <line1> Integer value = <line2> environment.getPositiveInteger( <line3> CFG_CONTROLLER_CLIENT_SSL_HANDSHAKE_TIMEOUT_IN_SECONDS, <line4> DEFAULT_CONTROLLER_CLIENT_SSL_HANDSHAKE_TIMEOUT_IN_SECONDS); <line5> return Duration.ofSeconds(value); <line6> } <line7> } <line8> 	<line5>
6818	"public class A { <line0> @Override <line1> public FileStatus getFileStatus(String hostName, Path path, String msg) <line2> throws IOException, FileNotFoundException { <line3> Container cont = mJossAccount.getAccount().getContainer(container); <line4> if (path.toString().contains(""temp_url"")) { <line5> long length = SwiftAPIDirect.getTempUrlObjectLength(path, swiftConnectionManager); <line6> return new FileStatus(length, false, 1, blockSize, 0L, path); <line7> } <line8> if (path.toString().equals(hostName) || (path.toString().length() + 1 == hostName.length())) { <line9> return new FileStatus(0L, true, 1, blockSize, 0L, path); <line10> } <line11> boolean isDirectory = false; <line12> String objectName = getObjName(hostName, path); <line13> if (stocatorPath.isTemporaryPath(objectName)) { <line14> throw new FileNotFoundException(""Not found "" + path.toString()); <line15> } <line16> SwiftCachedObject obj = objectCache.get(objectName); <line17> if (obj != null) { <line18> if (obj.getContentLength() == 0) { <line19> Collection<DirectoryOrObject> directoryFiles = cont.listDirectory(objectName, '/', """", 10); <line20> if (directoryFiles != null && directoryFiles.size() != 0) { <line21> isDirectory = true; <line22> } <line23> } <line24> return new FileStatus( <line25> obj.getContentLength(), isDirectory, 1, blockSize, obj.getLastModified(), path); <line26> } <line27> Collection<DirectoryOrObject> directoryFiles = <line28> cont.listDirectory(objectName + ""/"", '/', """", 10); <line29> if (directoryFiles != null) { <line30> } <line31> if (directoryFiles != null && directoryFiles.size() != 0) { <line32> isDirectory = true; <line33> return new FileStatus(0, isDirectory, 1, blockSize, 0L, path); <line34> } <line35> throw new FileNotFoundException(""No such object exists "" + path.toString()); <line36> } <line37> } <line38> "	<line3>, <line9>, <line14>, <line24>, <line27>, <line30>, <line33>, <line35>
6819	public class A { <line0> @Override <line1> public Path downloadArtifact(Artifact a) throws Exception { <line2> String downloadUrl = null; <line3> Path result = null; <line4> try { <line5> final PypiResponse response = <line6> this.searchInPypi(a.getLibId().getArtifact(), a.getLibId().getVersion()); <line7> if (response != null) { <line8> for (String k : response.getReleases().keySet()) { <line9> if (k.equals(a.getLibId().getVersion())) { <line10> for (PypiRelease release : response.getReleases().get(k)) { <line11> if (release.getPackagetype().equals(a.getPackaging())) { <line12> downloadUrl = release.getUrl(); <line13> break; <line14> } <line15> } <line16> break; <line17> } <line18> } <line19> if (downloadUrl != null) { <line20> final RestTemplate rest_template = new RestTemplate(); <line21> rest_template.execute( <line22> downloadUrl, <line23> HttpMethod.GET, <line24> new DefaultRequestCallback(), <line25> new FileResponseExtractor(a, a.getAbsM2Path())); <line26> result = a.getAbsM2Path(); <line27> } <line28> } <line29> } catch (HttpClientErrorException e) { <line30> } <line31> return result; <line32> } <line33> } <line34> 	<line30>
6820	public class A { <line0> @Override <line1> public void onDone(Exchange exchange) { <line2> int actualExchanges = exchangeCounter.decrementAndGet(); <line3> if (actualExchanges == 0) { <line4> try { <line5> closeFileInputStreams(); <line6> if (outputStream != null) { <line7> outputStream.close(); <line8> } <line9> } catch (Exception e) { <line10> } <line11> try { <line12> cleanUpTempFile(); <line13> } catch (Exception e) { <line14> } <line15> } <line16> } <line17> } <line18> 	<line10>, <line14>
6821	"public class A { <line0> @JsxGetter <line1> public Object getResponseXML() { <line2> if (webResponse_ == null) { <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> return null; <line6> } <line7> if (webResponse_ instanceof NetworkErrorWebResponse) { <line8> if (LOG.isDebugEnabled()) { <line9> } <line10> return null; <line11> } <line12> final String contentType = webResponse_.getContentType(); <line13> if (contentType.isEmpty() || contentType.contains(""xml"")) { <line14> final Window w = getWindow(); <line15> try { <line16> final XmlPage page = new XmlPage(webResponse_, w.getWebWindow()); <line17> final XMLDocument document = new XMLDocument(); <line18> document.setPrototype(getPrototype(document.getClass())); <line19> document.setParentScope(w); <line20> document.setDomNode(page); <line21> return document; <line22> } catch (final IOException e) { <line23> if (LOG.isWarnEnabled()) { <line24> } <line25> return null; <line26> } <line27> } <line28> if (LOG.isDebugEnabled()) { <line29> } <line30> return null; <line31> } <line32> } <line33> "	<line4>, <line9>, <line24>, <line29>
6822	public class A { <line0> void undoCreatePage(final CreatePageLoggable loggable) { <line1> final DOMPage page = getDOMPage(loggable.newPage); <line2> final DOMFilePageHeader pageHeader = page.getPageHeader(); <line3> try { <line4> pageHeader.setNextDataPage(NO_PAGE); <line5> pageHeader.setPrevDataPage(NO_PAGE); <line6> pageHeader.setDataLength(0); <line7> pageHeader.setNextTupleID(ItemId.UNKNOWN_ID); <line8> pageHeader.setRecordCount((short) 0); <line9> page.len = 0; <line10> unlinkPages(page.page); <line11> page.setDirty(true); <line12> dataCache.remove(page); <line13> } catch (final IOException e) { <line14> } <line15> } <line16> } <line17> 	<line14>
6823	"public class A { <line0> public List<Object[]> fetchMajorCodeAndAppropriation( <line1> final Budget topBudget, <line2> final BudgetDetail budgetDetail, <line3> final CFunction function, <line4> final Position pos, <line5> final Date asOnDate) { <line6> if (LOGGER.isInfoEnabled()) <line7> StringBuffer query = new StringBuffer(); <line8> String functionCondition1 = """"; <line9> String functionCondition2 = """"; <line10> String dateCondition = """"; <line11> String ReappropriationTable = "" ""; <line12> if (function != null) { <line13> functionCondition1 = "" AND bd1.function = "" + function.getId(); <line14> functionCondition2 = "" AND bd2.function = "" + function.getId(); <line15> } <line16> if (asOnDate != null) { <line17> ReappropriationTable = "" egf_reappropriation_misc bmisc,""; <line18> dateCondition = <line19> "" and bapp.reappropriation_misc= bmisc.id and  bmisc.reappropriation_date <= '"" <line20> + Constants.DDMMYYYYFORMAT1.format(asOnDate) <line21> + ""'""; <line22> } <line23> query = <line24> query.append( <line25> ""SELECT cao.majorcode, SUM(bapp.addition_amount)-SUM(bapp.deduction_amount) FROM"" <line26> + "" egf_budgetdetail bd1, egf_budgetdetail bd2, egf_budgetgroup bg, egf_budget b1,"" <line27> + "" egf_budget b2, chartofaccounts cao, financialyear f, egf_budget_reappropriation"" <line28> + "" bapp, "" <line29> + ReappropriationTable <line30> + "" eg_wf_states wf"" <line31> + "" WHERE bd1.budget=b1.id and bd2.budget=b2.id AND f.id   ="" <line32> + topBudget.getFinancialYear().getId() <line33> + "" AND b1.financialyearid="" <line34> + topBudget.getFinancialYear().getId() <line35> + "" AND b2.financialyearid="" <line36> + topBudget.getFinancialYear().getId() <line37> + "" AND b1.MATERIALIZEDPATH LIKE '"" <line38> + topBudget.getMaterializedPath() <line39> + ""%' and b2.isbere='BE' AND bd2.budgetgroup          =bg.id "" <line40> + dateCondition <line41> + "" AND cao.id=bg.mincode AND cao.id=bg.maxcode AND bg.majorcode IS NULL AND"" <line42> + "" bd1.executing_department = "" <line43> + budgetDetail.getExecutingDepartment().getId() <line44> + "" "" <line45> + functionCondition1 <line46> + "" AND bd2.executing_department = "" <line47> + budgetDetail.getExecutingDepartment().getId() <line48> + """" <line49> + "" "" <line50> + functionCondition2 <line51> + "" AND bapp.budgetdetail  = bd2.id AND (wf.value ='END' OR wf.owner_pos ="" <line52> + pos.getId() <line53> + "") AND bd1.state_id             = wf.id and bd1.uniqueno = bd2.uniqueno GROUP BY"" <line54> + "" cao.majorcode""); <line55> final List<Object[]> result = getSession().createSQLQuery(query.toString()).list(); <line56> return result; <line57> } <line58> } <line59> "	<line7>, <line56>
6824	"public class A { <line0> @Override <line1> public void deleteIDGenerator(ServiceContext<PoxPayloadIn, PoxPayloadOut> ctx, String csid) <line2> throws Exception { <line3> Connection conn = null; <line4> try { <line5> String repositoryName = ctx.getRepositoryName(); <line6> conn = getJdbcConnection(getDatabaseName(repositoryName)); <line7> Statement stmt = conn.createStatement(); <line8> ResultSet rs = <line9> stmt.executeQuery(""SELECT csid FROM id_generators "" + ""WHERE csid='"" + csid + ""'""); <line10> boolean moreRows = rs.next(); <line11> boolean idGeneratorFound = true; <line12> if (!moreRows) { <line13> idGeneratorFound = false; <line14> } <line15> if (idGeneratorFound) { <line16> final String SQL_STATEMENT_STRING = ""DELETE FROM id_generators WHERE csid = ?""; <line17> PreparedStatement ps = conn.prepareStatement(SQL_STATEMENT_STRING); <line18> ps.setString(1, csid); <line19> int rowsUpdated = ps.executeUpdate(); <line20> if (rowsUpdated != 1) { <line21> throw new IllegalStateException( <line22> ""Error deleting ID generator '"" + csid + ""'"" + "" in the database.""); <line23> } <line24> } else { <line25> throw new DocumentNotFoundException( <line26> ""Error deleting ID generator '"" <line27> + csid <line28> + ""': generator could not be found in the database.""); <line29> } <line30> } catch (IllegalStateException ise) { <line31> throw ise; <line32> } catch (SQLException e) { <line33> throw new IllegalStateException(""Error deleting ID generator in database: "" + e.getMessage()); <line34> } finally { <line35> try { <line36> if (conn != null) { <line37> conn.close(); <line38> } <line39> } catch (SQLException e) { <line40> } <line41> } <line42> } <line43> } <line44> "	<line3>, <line30>
6825	public class A { <line0> @Override <line1> public void shutdown() { <line2> if (closed) { <line3> return; <line4> } <line5> closed = true; <line6> final NodeIdentifier localId = getLocalNodeIdentifier(); <line7> if (localId != null) { <line8> final NodeConnectionStatus shutdownStatus = <line9> new NodeConnectionStatus(localId, DisconnectionCode.NODE_SHUTDOWN); <line10> updateNodeStatus(shutdownStatus, false); <line11> } <line12> } <line13> } <line14> 	<line11>
6826	public class A { <line0> private void queryAllDomainGroups() { <line1> long start = System.currentTimeMillis(); <line2> Criteria criteria = domainGroupQueryStrategy.getCriteria(getHibernateSession()); <line3> criteria.setFetchSize(FETCH_SIZE); <line4> criteria.setCacheMode(CacheMode.IGNORE); <line5> ScrollableResults scroll = criteria.scroll(ScrollMode.FORWARD_ONLY); <line6> long recordCounter = 0; <line7> while (scroll.next()) { <line8> if (++recordCounter % FETCH_SIZE == 0) { <line9> getHibernateSession().clear(); <line10> } <line11> DomainGroupModelView result = (DomainGroupModelView) scroll.get(0); <line12> getCache().set(CacheKeys.GROUP_BY_ID + result.getEntityId(), result); <line13> getCache().set(CacheKeys.GROUP_BY_SHORT_NAME + result.getShortName(), result.getEntityId()); <line14> } <line15> } <line16> } <line17> 	<line2>, <line9>, <line15>
6827	"public class A { <line0> protected static void printReleaseFailed(HttpResponse response) { <line1> response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR); <line2> setStringEntity(response, ""An error occurred while releasing the document""); <line3> } <line4> } <line5> "	<line1>
6828	"public class A { <line0> @Override <line1> public int chooseReplacementEffect(Map<String, String> rEffects, Game game) { <line2> if (gameInCheckPlayableState(game, true)) { <line3> return 0; <line4> } <line5> if (rEffects.size() <= 1) { <line6> return 0; <line7> } <line8> if (!autoSelectReplacementEffects.isEmpty()) { <line9> for (String autoKey : autoSelectReplacementEffects) { <line10> int count = 0; <line11> for (String effectKey : rEffects.keySet()) { <line12> if (effectKey.equals(autoKey)) { <line13> return count; <line14> } <line15> count++; <line16> } <line17> } <line18> } <line19> replacementEffectChoice.getChoices().clear(); <line20> replacementEffectChoice.setKeyChoices(rEffects); <line21> int differentChoices = 0; <line22> String lastChoice = """"; <line23> for (String value : replacementEffectChoice.getKeyChoices().values()) { <line24> if (!lastChoice.equalsIgnoreCase(value)) { <line25> lastChoice = value; <line26> differentChoices++; <line27> } <line28> } <line29> if (differentChoices <= 1) { <line30> return 0; <line31> } <line32> while (canRespond()) { <line33> updateGameStatePriority(""chooseEffect"", game); <line34> prepareForResponse(game); <line35> if (!isExecutingMacro()) { <line36> game.fireChooseChoiceEvent(playerId, replacementEffectChoice); <line37> } <line38> waitForResponse(game); <line39> if (response.getString() != null) { <line40> if (response.getString().startsWith(""#"")) { <line41> autoSelectReplacementEffects.add(response.getString().substring(1)); <line42> replacementEffectChoice.setChoiceByKey(response.getString().substring(1)); <line43> } else { <line44> replacementEffectChoice.setChoiceByKey(response.getString()); <line45> } <line46> if (replacementEffectChoice.getChoiceKey() != null) { <line47> int index = 0; <line48> for (String key : rEffects.keySet()) { <line49> if (replacementEffectChoice.getChoiceKey().equals(key)) { <line50> return index; <line51> } <line52> index++; <line53> } <line54> } <line55> } <line56> } <line57> return 0; <line58> } <line59> } <line60> "	<line39>
6829	"public class A { <line0> public void loadData(MidPointApplication application) { <line1> try { <line2> scanPackagesForPages(application); <line3> if (LOGGER.isTraceEnabled()) { <line4> } <line5> } catch (InstantiationException | IllegalAccessException e) { <line6> throw new SystemException(""Error scanning packages for pages: "" + e.getMessage(), e); <line7> } <line8> } <line9> } <line10> "	<line1>, <line4>, <line6>
6830	"public class A { <line0> @Override <line1> public Object on(Object obj, Method method, Object[] parameters) throws Throwable { <line2> if (""finalize"".equals(method.getName())) { <line3> super.finalize(); <line4> return null; <line5> } <line6> stack.add(method); <line7> for (Object param : parameters) { <line8> if (param == null) { <line9> Evaluation evaluation = lastNonProxyable.get(); <line10> if (evaluation != null) { <line11> lastNonProxyable.remove(); <line12> stack.add(evaluation); <line13> continue; <line14> } <line15> } <line16> stack.add(param); <line17> } <line18> type = Reflection.resultType(type, method.getGenericReturnType()); <line19> if (type == null) { <line20> type = method.getReturnType(); <line21> } <line22> return proxy(); <line23> } <line24> } <line25> "	<line20>
6831	"public class A { <line0> public void dropAllData() { <line1> String[] sqls = new String[51]; <line2> sqls[0] = ""TRUNCATE TABLE KNOWLEDGES;""; <line3> sqls[1] = ""TRUNCATE TABLE EVENTS;""; <line4> sqls[2] = ""TRUNCATE TABLE MAIL_POSTS;""; <line5> sqls[3] = ""TRUNCATE TABLE WEBHOOK_CONFIGS;""; <line6> sqls[4] = ""TRUNCATE TABLE SURVEY_CHOICES;""; <line7> sqls[5] = ""TRUNCATE TABLE KNOWLEDGE_GROUPS;""; <line8> sqls[6] = ""TRUNCATE TABLE SURVEY_ITEM_ANSWERS;""; <line9> sqls[7] = ""TRUNCATE TABLE DRAFT_ITEM_VALUES;""; <line10> sqls[8] = ""TRUNCATE TABLE KNOWLEDGE_EDIT_GROUPS;""; <line11> sqls[9] = ""TRUNCATE TABLE WEBHOOKS;""; <line12> sqls[10] = ""TRUNCATE TABLE KNOWLEDGE_FILES;""; <line13> sqls[11] = ""TRUNCATE TABLE NOTIFY_QUEUES;""; <line14> sqls[12] = ""TRUNCATE TABLE TEMPLATE_MASTERS;""; <line15> sqls[13] = ""TRUNCATE TABLE ITEM_CHOICES;""; <line16> sqls[14] = ""TRUNCATE TABLE KNOWLEDGE_ITEM_VALUES;""; <line17> sqls[15] = ""TRUNCATE TABLE KNOWLEDGE_TAGS;""; <line18> sqls[16] = ""TRUNCATE TABLE NOTIFICATION_STATUS;""; <line19> sqls[17] = ""TRUNCATE TABLE USER_BADGES;""; <line20> sqls[18] = ""TRUNCATE TABLE NOTIFY_CONFIGS;""; <line21> sqls[19] = ""TRUNCATE TABLE MAIL_HOOKS;""; <line22> sqls[20] = ""TRUNCATE TABLE DRAFT_KNOWLEDGES;""; <line23> sqls[21] = ""TRUNCATE TABLE STOCK_KNOWLEDGES;""; <line24> sqls[22] = ""TRUNCATE TABLE KNOWLEDGE_USERS;""; <line25> sqls[23] = ""TRUNCATE TABLE PARTICIPANTS;""; <line26> sqls[24] = ""TRUNCATE TABLE TAGS;""; <line27> sqls[25] = ""TRUNCATE TABLE SERVICE_LOCALE_CONFIGS;""; <line28> sqls[26] = ""TRUNCATE TABLE ACCOUNT_IMAGES;""; <line29> sqls[27] = ""TRUNCATE TABLE MAIL_PROPERTIES;""; <line30> sqls[28] = ""TRUNCATE TABLE POINT_KNOWLEDGE_HISTORIES;""; <line31> sqls[29] = ""TRUNCATE TABLE MAIL_LOCALE_TEMPLATES;""; <line32> sqls[30] = ""TRUNCATE TABLE VOTES;""; <line33> sqls[31] = ""TRUNCATE TABLE COMMENTS;""; <line34> sqls[32] = ""TRUNCATE TABLE TOKENS;""; <line35> sqls[33] = ""TRUNCATE TABLE MAIL_HOOK_CONDITIONS;""; <line36> sqls[34] = ""TRUNCATE TABLE LIKES;""; <line37> sqls[35] = ""TRUNCATE TABLE VIEW_HISTORIES;""; <line38> sqls[36] = ""TRUNCATE TABLE SERVICE_CONFIGS;""; <line39> sqls[37] = ""TRUNCATE TABLE KNOWLEDGE_EDIT_USERS;""; <line40> sqls[38] = ""TRUNCATE TABLE PINS;""; <line41> sqls[39] = ""TRUNCATE TABLE KNOWLEDGE_HISTORIES;""; <line42> sqls[40] = ""TRUNCATE TABLE LIKE_COMMENTS;""; <line43> sqls[41] = ""TRUNCATE TABLE BADGES;""; <line44> sqls[42] = ""TRUNCATE TABLE SURVEY_ANSWERS;""; <line45> sqls[43] = ""TRUNCATE TABLE SURVEYS;""; <line46> sqls[44] = ""TRUNCATE TABLE ACTIVITIES;""; <line47> sqls[45] = ""TRUNCATE TABLE MAIL_HOOK_IGNORE_CONDITIONS;""; <line48> sqls[46] = ""TRUNCATE TABLE MAIL_TEMPLATES;""; <line49> sqls[47] = ""TRUNCATE TABLE POINT_USER_HISTORIES;""; <line50> sqls[48] = ""TRUNCATE TABLE SURVEY_ITEMS;""; <line51> sqls[49] = ""TRUNCATE TABLE STOCKS;""; <line52> sqls[50] = ""TRUNCATE TABLE TEMPLATE_ITEMS;""; <line53> for (String sql : sqls) { <line54> executeUpdate(sql); <line55> } <line56> } <line57> } <line58> "	<line54>
6832	"public class A { <line0> private void addUserConfigRecord(String username, String config, Connection conn) <line1> throws ApsSystemException { <line2> PreparedStatement stat = null; <line3> try { <line4> stat = conn.prepareStatement(ADD_CONFIG); <line5> stat.setString(1, username); <line6> stat.setString(2, config); <line7> stat.executeUpdate(); <line8> } catch (Throwable t) { <line9> throw new RuntimeException(""Error adding user config record"", t); <line10> } finally { <line11> this.closeDaoResources(null, stat); <line12> } <line13> } <line14> } <line15> "	<line9>
6833	"public class A { <line0> @Test <line1> public void test12IncorrectObservation() throws ServiceFailureException { <line2> Observation modifiedObservation = OBSERVATIONS.get(0).withOnlyId(); <line3> modifiedObservation.setMultiDatastream(MULTIDATASTREAMS.get(0).withOnlyId()); <line4> updateForException( <line5> ""Linking Observation to Datastream AND MultiDatastream."", modifiedObservation); <line6> } <line7> } <line8> "	<line2>
6834	public class A { <line0> public static RdsBackupPolicy queryBinlogBackupPolicy( <line1> String url, String ak, String sk, String dbInstanceId) { <line2> DescribeBackupPolicyRequest request = new DescribeBackupPolicyRequest(); <line3> if (StringUtils.isNotEmpty(url)) { <line4> try { <line5> URI uri = new URI(url); <line6> request.setEndPoint(uri.getHost()); <line7> } catch (URISyntaxException e) { <line8> } <line9> } <line10> request.setRdsInstanceId(dbInstanceId); <line11> request.setAccessKeyId(ak); <line12> request.setAccessKeySecret(sk); <line13> int retryTime = 3; <line14> while (true) { <line15> try { <line16> return request.doAction(); <line17> } catch (Exception e) { <line18> if (retryTime-- <= 0) { <line19> throw new RuntimeException(e); <line20> } <line21> try { <line22> Thread.sleep(100L); <line23> } catch (InterruptedException e1) { <line24> } <line25> } <line26> } <line27> } <line28> } <line29> 	<line8>
6835	public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> ctx.close().addListener(CLOSE_ON_FAILURE); <line3> } <line4> } <line5> 	<line2>
6836	"public class A { <line0> public void release() { <line1> try { <line2> if (channel.isOpen()) { <line3> channel.close(); <line4> } <line5> channel = null; <line6> } catch (final Exception e) { <line7> message(""Failed to close lock file"", e); <line8> } <line9> if (Files.exists(lockFile)) { <line10> FileUtils.deleteQuietly(lockFile); <line11> } <line12> } <line13> } <line14> "	<line10>
6837	public class A { <line0> @Override <line1> public void perform(CcId ccId, IControllerService cs) throws HyracksDataException { <line2> INcApplicationContext appContext = (INcApplicationContext) cs.getApplicationContext(); <line3> boolean success = false; <line4> for (Pair<URI, String> referenceNode : nodes) { <line5> try { <line6> retrieveLibrary(referenceNode.getFirst(), referenceNode.getSecond(), appContext); <line7> success = true; <line8> break; <line9> } catch (HyracksDataException e) { <line10> } <line11> } <line12> if (!success) { <line13> throw HyracksDataException.create(ErrorCode.TIMEOUT); <line14> } <line15> } <line16> } <line17> 	<line6>, <line10>, <line13>
6838	public class A { <line0> public void stopClusterIfExists(UUID clusterId) { <line1> ignite.services().cancel(String.format(SERVICE_NAME_TEMPLATE, clusterId)); <line2> if (log.isInfoEnabled()) <line3> } <line4> } <line5> 	<line3>
6839	"public class A { <line0> @Test <line1> public void testHttpFeedRegisteredInInitIsPersistedAndFeedsStop() throws Exception { <line2> TestEntity origEntity = <line3> origApp.createAndManageChild( <line4> EntitySpec.create(TestEntity.class) <line5> .impl(MyEntityWithHttpFeedImpl.class) <line6> .configure(MyEntityWithHttpFeedImpl.BASE_URL, baseUrl)); <line7> EntityTestUtils.assertAttributeEqualsEventually(origEntity, SENSOR_INT, (Integer) 200); <line8> EntityTestUtils.assertAttributeEqualsEventually( <line9> origEntity, SENSOR_STRING, ""{\""foo\"":\""myfoo\""}""); <line10> assertEquals(origEntity.feeds().getFeeds().size(), 1); <line11> final long taskCountBefore = <line12> ((BasicExecutionManager) origManagementContext.getExecutionManager()) <line13> .getNumIncompleteTasks(); <line14> newApp = rebind(); <line15> TestEntity newEntity = (TestEntity) Iterables.getOnlyElement(newApp.getChildren()); <line16> Collection<Feed> newFeeds = newEntity.feeds().getFeeds(); <line17> assertEquals(newFeeds.size(), 1); <line18> newEntity.sensors().set(SENSOR_INT, null); <line19> newEntity.sensors().set(SENSOR_STRING, null); <line20> EntityTestUtils.assertAttributeEqualsEventually(newEntity, SENSOR_INT, (Integer) 200); <line21> EntityTestUtils.assertAttributeEqualsEventually( <line22> newEntity, SENSOR_STRING, ""{\""foo\"":\""myfoo\""}""); <line23> Entities.unmanage(origApp); <line24> origApp = null; <line25> origManagementContext.getRebindManager().stop(); <line26> waitForTaskCountToBecome(origManagementContext, 0); <line27> } <line28> } <line29> "	<line14>
6840	"public class A { <line0> private void setAuth( <line1> String serviceName, <line2> Auth auth, <line3> Consumer<Map<String, String>> headersSetter, <line4> BiConsumer<String, String> basicSetter) { <line5> AuthType type = auth.getType(); <line6> if (type == AuthType.headers) { <line7> System.setProperty(""sun.net.http.allowRestrictedHeaders"", ""true""); <line8> Map<String, String> headers = <line9> auth.getHeaders() == null ? Collections.emptyMap() : auth.getHeaders(); <line10> headersSetter.accept(headers); <line11> if (headers.isEmpty()) { <line12> } else { <line13> } <line14> } else if (type == AuthType.basic) { <line15> BasicAuth basic = auth.getBasic(); <line16> Objects.requireNonNull( <line17> basic == null ? null : basic.getUsername(), <line18> () -> <line19> String.format( <line20> ""%s REST API client configured to use HTTP Basic authentication but no"" <line21> + "" credentials provided"", <line22> serviceName)); <line23> String username = basic.getUsername(); <line24> String password = basic.getPassword(); <line25> basicSetter.accept(username, password); <line26> if (StringUtils.hasText(password)) { <line27> } else { <line28> } <line29> } else if (type == AuthType.none || type == null) { <line30> } else { <line31> throw new IllegalArgumentException(""Uknown AuthType: "" + type); <line32> } <line33> } <line34> } <line35> "	<line12>, <line13>, <line27>, <line28>, <line30>
6841	public class A { <line0> @Override <line1> public void onChangeApplied(HistoryRecord record) { <line2> lastAppliedChange = record; <line3> totalChangesApplied.incrementAndGet(); <line4> if (getMilliSecondsSinceLastAppliedChange() >= PAUSE_BETWEEN_LOG_MESSAGES.toMillis()) { <line5> } <line6> lastChangeAppliedTimestamp = Instant.now(); <line7> } <line8> } <line9> 	<line5>
6842	public class A { <line0> private void updateClients( <line1> List<DisplayNameEntry> oldClientDisplayNameEntries, <line2> List<DisplayNameEntry> newClientDisplayNameEntries) <line3> throws Exception { <line4> String sectorIdentifierDn = this.sectorIdentifier.getDn(); <line5> String[] oldClientDns = convertToDNsArray(oldClientDisplayNameEntries); <line6> String[] newClientDns = convertToDNsArray(newClientDisplayNameEntries); <line7> Arrays.sort(oldClientDns); <line8> Arrays.sort(newClientDns); <line9> boolean[] retainOldClients = new boolean[oldClientDns.length]; <line10> Arrays.fill(retainOldClients, false); <line11> List<String> addedMembers = new ArrayList<String>(); <line12> List<String> removedMembers = new ArrayList<String>(); <line13> List<String> existingMembers = new ArrayList<String>(); <line14> for (String value : newClientDns) { <line15> int idx = Arrays.binarySearch(oldClientDns, value); <line16> if (idx >= 0) { <line17> retainOldClients[idx] = true; <line18> } else { <line19> addedMembers.add(value); <line20> } <line21> } <line22> for (int i = 0; i < oldClientDns.length; i++) { <line23> if (retainOldClients[i]) { <line24> existingMembers.add(oldClientDns[i]); <line25> } else { <line26> removedMembers.add(oldClientDns[i]); <line27> } <line28> } <line29> for (String dn : addedMembers) { <line30> OxAuthClient client = clientService.getClientByDn(dn); <line31> client.setSectorIdentifierUri(getSectorIdentifierUrl()); <line32> clientService.updateClient(client); <line33> } <line34> for (String dn : removedMembers) { <line35> OxAuthClient client = clientService.getClientByDn(dn); <line36> client.setSectorIdentifierUri(null); <line37> clientService.updateClient(client); <line38> } <line39> } <line40> } <line41> 	<line4>, <line31>, <line36>
6843	"public class A { <line0> @Cacheable(""import-funding-clients"") <line1> public List<ImportWizzardClientForm> findOrcidClientsWithPredefinedOauthScopeFundingImport( <line2> Locale locale) { <line3> updateLocalCacheVersion(); <line4> return generateImportWizzardForm(RedirectUriType.IMPORT_FUNDING_WIZARD, locale); <line5> } <line6> } <line7> "	<line4>
6844	"public class A { <line0> private void findIncludes(String tag, Set<String> set) { <line1> List<Element> includes = xsl.getChildren(tag, MCRConstants.XSL_NAMESPACE); <line2> for (Element include : includes) { <line3> String href = include.getAttributeValue(""href""); <line4> set.add(href); <line5> if (!stylesheets.containsKey(href)) { <line6> unknown.add(href); <line7> } <line8> } <line9> } <line10> } <line11> "	<line4>
6845	public class A { <line0> private static void prepare() { <line1> if (INTERCEPTOR == null) { <line2> ClassLoader loader = BootstrapInterRuntimeAssist.getAgentClassLoader(); <line3> if (loader != null) { <line4> IBootstrapLog logger = BootstrapInterRuntimeAssist.getLogger(loader, TARGET_INTERCEPTOR); <line5> if (logger != null) { <line6> LOGGER = logger; <line7> INTERCEPTOR = <line8> BootstrapInterRuntimeAssist.createInterceptor(loader, TARGET_INTERCEPTOR, LOGGER); <line9> } <line10> } else { <line11> } <line12> } <line13> } <line14> } <line15> 	<line11>
6846	"public class A { <line0> public ChannelFuture send() { <line1> ChannelFuture channelFuture; <line2> if (content instanceof File) { <line3> File file = (File) content; <line4> try { <line5> channelFuture = sendFile(file); <line6> } catch (IOException e) { <line7> channelFuture = sendError(HttpResponseStatus.FORBIDDEN, """"); <line8> } <line9> } else { <line10> channelFuture = sendFull(); <line11> } <line12> this.isSent = true; <line13> return channelFuture; <line14> } <line15> } <line16> "	<line7>
6847	public class A { <line0> @Override <line1> public void run() { <line2> MessageAndMetadata<String, String> item; <line3> while (true) { <line4> for (MessageAndMetadata<String, String> aStream : stream) { <line5> item = aStream; <line6> reader.persistQueue.add(new StreamsDatum(item.message())); <line7> } <line8> try { <line9> Thread.sleep(new Random().nextInt(100)); <line10> } catch (InterruptedException interrupt) { <line11> } <line12> } <line13> } <line14> } <line15> 	<line11>
6848	public class A { <line0> @MasterDataSource <line1> @Override <line2> public Lock lock( <line3> final String className, <line4> final String key, <line5> final String expectedOwner, <line6> final String updatedOwner) { <line7> while (true) { <line8> try { <line9> return TransactionInvokerUtil.invoke( <line10> _transactionConfig, <line11> new Callable<Lock>() { <line12> @Override <line13> public Lock call() { <line14> Lock lock = lockPersistence.fetchByC_K(className, key, false); <line15> if (lock == null) { <line16> long lockId = counterLocalService.increment(); <line17> lock = lockPersistence.create(lockId); <line18> lock.setCreateDate(new Date()); <line19> lock.setClassName(className); <line20> lock.setKey(key); <line21> lock.setOwner(updatedOwner); <line22> lock = lockPersistence.update(lock); <line23> lock.setNew(true); <line24> } else if (Objects.equals(lock.getOwner(), expectedOwner)) { <line25> lock.setCreateDate(new Date()); <line26> lock.setClassName(className); <line27> lock.setKey(key); <line28> lock.setOwner(updatedOwner); <line29> lock = lockPersistence.update(lock); <line30> lock.setNew(true); <line31> } <line32> return lock; <line33> } <line34> }); <line35> } catch (Throwable throwable) { <line36> Throwable causeThrowable = throwable; <line37> if (throwable instanceof ORMException) { <line38> causeThrowable = throwable.getCause(); <line39> } <line40> if (causeThrowable instanceof ConstraintViolationException <line41> || causeThrowable instanceof LockAcquisitionException) { <line42> if (_log.isInfoEnabled()) { <line43> } <line44> continue; <line45> } <line46> ReflectionUtil.throwException(throwable); <line47> } <line48> } <line49> } <line50> } <line51> 	<line43>
6849	public class A { <line0> public boolean isAvailable() { <line1> boolean exists = false; <line2> try { <line3> final Process p = new ProcessBuilder(this.pathToPip.toString()).start(); <line4> final int exit_code = p.waitFor(); <line5> exists = exit_code == 0; <line6> } catch (IOException ioe) { <line7> } catch (InterruptedException ie) { <line8> } <line9> return exists; <line10> } <line11> } <line12> 	<line7>, <line8>
6850	"public class A { <line0> @GET <line1> @Timed <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @Path(""agreements/{seaCloudsId}"") <line4> @ApiOperation(value = ""Get SLA Agreement for a particular SeaClouds Application Id"") <line5> public Response getAgreement(@PathParam(""seaCloudsId"") String seaCloudsId) { <line6> if (seaCloudsId == null) { <line7> return Response.status(Response.Status.NOT_ACCEPTABLE).build(); <line8> } else { <line9> SeaCloudsApplicationData seaCloudsApplicationData = <line10> dataStore.getSeaCloudsApplicationDataById(seaCloudsId); <line11> if (seaCloudsApplicationData == null) { <line12> return Response.status(Response.Status.BAD_REQUEST).build(); <line13> } <line14> if (seaCloudsApplicationData.getAgreementId() == null) { <line15> return Response.status(Response.Status.NOT_FOUND).build(); <line16> } <line17> return Response.ok(sla.getAgreement(seaCloudsApplicationData.getAgreementId())).build(); <line18> } <line19> } <line20> } <line21> "	<line7>, <line15>
6851	"public class A { <line0> private List<String> getMatchedPaths(Path pt, String type) { <line1> List<String> finalPaths = new ArrayList<>(); <line2> InputStream resourceOrderIStream = null; <line3> FileSystem fs; <line4> try { <line5> fs = pt.getFileSystem(new Configuration()); <line6> if (fs.exists(pt)) { <line7> if (fs.isFile(pt)) { <line8> finalPaths.add(pt.toUri().toString()); <line9> } else if (fs.isDirectory(pt)) { <line10> Path resourceOrderFile; <line11> FileStatus[] statuses; <line12> List<String> newMatches; <line13> List<String> resources; <line14> resourceOrderFile = new Path(pt, ""jar_order""); <line15> if (!fs.exists(resourceOrderFile)) { <line16> resourceOrderFile = new Path(pt, ""glob_order""); <line17> if (!fs.exists(resourceOrderFile)) { <line18> resourceOrderFile = null; <line19> statuses = fs.globStatus(new Path(pt, ""*"")); <line20> if (statuses != null) { <line21> for (FileStatus st : statuses) { <line22> newMatches = getMatchedPaths(st.getPath(), type); <line23> finalPaths.addAll(newMatches); <line24> } <line25> } <line26> } <line27> } <line28> if (resourceOrderFile != null) { <line29> resourceOrderIStream = fs.open(resourceOrderFile); <line30> resources = IOUtils.readLines(resourceOrderIStream, Charset.forName(""UTF-8"")); <line31> for (String resource : resources) { <line32> if (StringUtils.isBlank(resource)) { <line33> continue; <line34> } <line35> resource = resource.trim(); <line36> if (resource.startsWith(""/"") || resource.contains("":/"")) { <line37> newMatches = getMatchedPaths(new Path(resource), type); <line38> } else { <line39> newMatches = getMatchedPaths(new Path(pt, resource), type); <line40> } <line41> finalPaths.addAll(newMatches); <line42> } <line43> } <line44> } <line45> } else { <line46> FileStatus[] statuses = fs.globStatus(Path.getPathWithoutSchemeAndAuthority(pt)); <line47> if (statuses != null) { <line48> for (FileStatus st : statuses) { <line49> List<String> newMatches = getMatchedPaths(st.getPath(), type); <line50> finalPaths.addAll(newMatches); <line51> } <line52> } <line53> } <line54> filterDirsAndJarType(fs, finalPaths); <line55> } catch (FileNotFoundException fex) { <line56> } catch (Exception e) { <line57> } finally { <line58> IOUtils.closeQuietly(resourceOrderIStream); <line59> } <line60> return finalPaths; <line61> } <line62> } <line63> "	<line56>, <line57>
6852	"public class A { <line0> @Override <line1> public List<String> getAllActiveTrapExpressions() { <line2> Connection conn = HarvestDBConnection.get(); <line3> List<String> result = new ArrayList<String>(); <line4> PreparedStatement stmt = null; <line5> try { <line6> stmt = <line7> conn.prepareStatement( <line8> ""SELECT DISTINCT trap_expression FROM global_crawler_trap_lists, "" <line9> + ""global_crawler_trap_expressions "" <line10> + ""WHERE global_crawler_trap_list_id = "" <line11> + ""crawler_trap_list_id "" <line12> + ""AND isActive = ?""); <line13> stmt.setBoolean(1, true); <line14> ResultSet rs = stmt.executeQuery(); <line15> while (rs.next()) { <line16> result.add(rs.getString(1)); <line17> } <line18> return result; <line19> } catch (SQLException e) { <line20> String message = ""Error retrieving expressions.\n"" + ExceptionUtils.getSQLExceptionCause(e); <line21> throw new IOFailure(message, e); <line22> } finally { <line23> DBUtils.closeStatementIfOpen(stmt); <line24> HarvestDBConnection.release(conn); <line25> } <line26> } <line27> } <line28> "	<line21>
6853	public class A { <line0> @Override <line1> public Group getScopeGroup() throws PortalException { <line2> Group group = null; <line3> try { <line4> group = GroupLocalServiceUtil.getLayoutGroup(getCompanyId(), getPlid()); <line5> } catch (NoSuchGroupException noSuchGroupException) { <line6> if (_log.isDebugEnabled()) { <line7> } <line8> } <line9> return group; <line10> } <line11> } <line12> 	<line7>
6854	public class A { <line0> public static String property(final String name) { <line1> final String value = System.getProperty(name); <line2> if (value == null) { <line3> System.exit(1); <line4> } <line5> return value; <line6> } <line7> } <line8> 	<line3>
6855	public class A { <line0> @VisibleForTesting <line1> static String safelyDecode(String text) { <line2> try { <line3> return MimeUtility.decodeText(text); <line4> } catch (UnsupportedEncodingException e) { <line5> return text; <line6> } <line7> } <line8> } <line9> 	<line5>
6856	public class A { <line0> @Override <line1> public Key apply(SortedKeyValueIterator<Key, Value> itr, Document doc, AttributeFactory attrs) <line2> throws IOException { <line3> Key key = itr.getTopKey(); <line4> Text row = key.getRow(); <line5> ByteSequence pointer = parsePointer(key.getColumnQualifierData()); <line6> Key nextKey = key; <line7> while (nextKey != null && samePointer(row, pointer, nextKey)) { <line8> DatawaveKey topKey = new DatawaveKey(nextKey); <line9> String field = topKey.getFieldName(); <line10> String value = topKey.getFieldValue(); <line11> FieldValueCardinality fvC = null; <line12> byte[] currentValue = itr.getTopValue().get(); <line13> try { <line14> if (currentValue.length > 0) { <line15> fvC = new FieldValueCardinality(HyperLogLogPlus.Builder.build(currentValue)); <line16> if (log.isTraceEnabled()) { <line17> } <line18> } <line19> } catch (Exception e) { <line20> if (log.isTraceEnabled()) { <line21> } <line22> } <line23> if (null == fvC) { <line24> fvC = new FieldValueCardinality(); <line25> if (setDocIds) fvC.setDocId(topKey.getUid()); <line26> } <line27> fvC.setContent(value); <line28> Key metadata = <line29> new Key(EMPTY_TEXT, EMPTY_TEXT, EMPTY_TEXT, itr.getTopKey().getColumnVisibility(), -1); <line30> Cardinality card = new Cardinality(fvC, metadata, doc.isToKeep()); <line31> card.setToKeep( <line32> fieldsToKeep == null <line33> || fieldsToKeep.contains(JexlASTHelper.removeGroupingContext(field))); <line34> doc.put(field, card); <line35> key = nextKey; <line36> itr.next(); <line37> nextKey = (itr.hasTop() ? itr.getTopKey() : null); <line38> } <line39> return TLD.buildParentKey( <line40> row, <line41> pointer, <line42> TLD.parseFieldAndValueFromFI(key.getColumnFamilyData(), key.getColumnQualifierData()), <line43> key.getColumnVisibility(), <line44> key.getTimestamp()); <line45> } <line46> } <line47> 	<line17>, <line21>, <line24>
6857	public class A { <line0> @Override <line1> protected long nextPartitionCounter(IgniteInternalTx tx, @Nullable Long primaryCntr) { <line2> try { <line3> return locPart.nextUpdateCounter(cctx.cacheId(), tx, primaryCntr); <line4> } catch (Throwable t) { <line5> throw t; <line6> } <line7> } <line8> } <line9> 	<line5>
6858	public class A { <line0> public static void handleGroupInstanceActivatedEvent( <line1> String appId, String groupId, String instanceId) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> Applications applications = ApplicationHolder.getApplications(); <line5> Application application = applications.getApplication(appId); <line6> if (application == null) { <line7> return; <line8> } <line9> Group group = application.getGroupRecursively(groupId); <line10> if (group == null) { <line11> return; <line12> } <line13> GroupInstance groupInstance = group.getInstanceContexts(instanceId); <line14> GroupStatus status = GroupStatus.Active; <line15> if (groupInstance != null) { <line16> if (groupInstance.isStateTransitionValid(status)) { <line17> groupInstance.setStatus(status); <line18> updateGroupMonitor( <line19> appId, <line20> groupId, <line21> status, <line22> groupInstance.getNetworkPartitionId(), <line23> instanceId, <line24> groupInstance.getParentId()); <line25> ApplicationHolder.persistApplication(application); <line26> ApplicationsEventPublisher.sendGroupInstanceActivatedEvent(appId, groupId, instanceId); <line27> } else { <line28> } <line29> } else { <line30> } <line31> } <line32> } <line33> 	<line3>, <line7>, <line11>, <line28>, <line30>
6859	"public class A { <line0> private void loadMavenDependencies(String versionHome) { <line1> String mavenDependenciesSource = <line2> repository <line3> + File.separator <line4> + ""core"" <line5> + File.separator <line6> + ""java"" <line7> + File.separator <line8> + ""iesi-core"" <line9> + File.separator <line10> + ""target"" <line11> + File.separator <line12> + ""dependencies""; <line13> String mavenDependenciesTarget = versionHome + File.separator + ""lib""; <line14> FolderTools.copyFromFolderToFolder(mavenDependenciesSource, mavenDependenciesTarget, true); <line15> } <line16> } <line17> "	<line1>
6860	public class A { <line0> @Override <line1> public ObjectMetadata getObjectMetadata(String objectId) { <line2> try { <line3> val objectKey = ObjectKeys.getObjectKey(dataDir, objectId); <line4> return s3Client.getObjectMetadata( <line5> bucketNamingService.getStateBucketName(objectId), objectKey.getMetaKey()); <line6> } catch (AmazonServiceException e) { <line7> throw new NotRetryableException(e); <line8> } <line9> } <line10> } <line11> 	<line7>
6861	public class A { <line0> public static String asString(String propertyName, Object value) { <line1> if (value != null && !(value instanceof String)) { <line2> return null; <line3> } <line4> return (String) value; <line5> } <line6> } <line7> 	<line2>
6862	public class A { <line0> @Override <line1> public void run() { <line2> shutdown(); <line3> } <line4> } <line5> 	<line2>, <line3>
6863	public class A { <line0> @Override <line1> public AuthorizationResult authorize(final AuthorizationRequest request) <line2> throws AuthorizationAccessException { <line3> final String identity = request.getIdentity(); <line4> final Set<String> userGroups = request.getGroups(); <line5> final String resourceIdentifier = request.getResource().getIdentifier(); <line6> if (StringUtils.isNotBlank(rangerAdminIdentity) <line7> && rangerAdminIdentity.equals(identity) <line8> && resourceIdentifier.equals(RESOURCES_RESOURCE)) { <line9> return AuthorizationResult.approved(); <line10> } <line11> final String clientIp; <line12> if (request.getUserContext() != null) { <line13> clientIp = request.getUserContext().get(UserContextKeys.CLIENT_ADDRESS.name()); <line14> } else { <line15> clientIp = null; <line16> } <line17> final RangerAccessResourceImpl resource = new RangerAccessResourceImpl(); <line18> resource.setValue(RANGER_NIFI_RESOURCE_NAME, resourceIdentifier); <line19> final RangerAccessRequestImpl rangerRequest = new RangerAccessRequestImpl(); <line20> rangerRequest.setResource(resource); <line21> rangerRequest.setAction(request.getAction().name()); <line22> rangerRequest.setAccessType(request.getAction().name()); <line23> rangerRequest.setUser(identity); <line24> rangerRequest.setUserGroups(userGroups); <line25> rangerRequest.setAccessTime(new Date()); <line26> if (!StringUtils.isBlank(clientIp)) { <line27> rangerRequest.setClientIPAddress(clientIp); <line28> } <line29> final long authStart = System.nanoTime(); <line30> final RangerAccessResult result = nifiPlugin.isAccessAllowed(rangerRequest); <line31> final long authNanos = System.nanoTime() - authStart; <line32> if (request.isAccessAttempt()) { <line33> synchronized (resultLookup) { <line34> resultLookup.put(request, result); <line35> } <line36> } <line37> if (result != null && result.getIsAllowed()) { <line38> return AuthorizationResult.approved(); <line39> } else { <line40> final boolean doesPolicyExist = <line41> nifiPlugin.doesPolicyExist(request.getResource().getIdentifier(), request.getAction()); <line42> if (doesPolicyExist) { <line43> final String reason = result == null ? null : result.getReason(); <line44> if (reason != null) { <line45> } <line46> return AuthorizationResult.denied(request.getExplanationSupplier().get()); <line47> } else { <line48> return AuthorizationResult.resourceNotFound(); <line49> } <line50> } <line51> } <line52> } <line53> 	<line32>, <line45>
6864	"public class A { <line0> @Test <line1> public void add() throws Exception { <line2> File f = createFile(0, loader, cache, folder); <line3> assertCache(0, cache, f); <line4> assertCacheStats(cache, 1, 4 * 1024, 1, 1); <line5> assertEquals( <line6> ""Memory weight different"", <line7> getWeight(ID_PREFIX + 0, cache.getIfPresent(ID_PREFIX + 0)), <line8> cache.getStats().estimateCurrentMemoryWeight()); <line9> } <line10> } <line11> "	<line2>, <line9>
6865	"public class A { <line0> private void stopSessionFailover() { <line1> try { <line2> releaseCommunications(sourceSession, ""sourceSession""); <line3> } catch (Throwable t) { <line4> } <line5> try { <line6> releaseCommunications(targetSession, ""targetSession""); <line7> } catch (Throwable t) { <line8> } <line9> } <line10> } <line11> "	<line4>, <line8>
6866	"public class A { <line0> private boolean processWithBody( <line1> final Exchange exchange, Object body, BodyReleaseCallback callback) { <line2> if (getConfiguration().getCharsetName() != null) { <line3> exchange.setProperty( <line4> ExchangePropertyKey.CHARSET_NAME, <line5> IOHelper.normalizeCharset(getConfiguration().getCharsetName())); <line6> } <line7> if (LOG.isTraceEnabled()) { <line8> } <line9> ChannelFuture channelFuture; <line10> Channel channel = null; <line11> try { <line12> if (getConfiguration().isReuseChannel()) { <line13> channel = exchange.getProperty(NettyConstants.NETTY_CHANNEL, Channel.class); <line14> } <line15> if (channel == null) { <line16> if (pool == null) { <line17> throw new IllegalStateException(""Producer pool is null""); <line18> } <line19> channelFuture = pool.borrowObject(); <line20> if (channelFuture != null) { <line21> } <line22> } else { <line23> channelFuture = channel.newSucceededFuture(); <line24> } <line25> } catch (Exception e) { <line26> exchange.setException(e); <line27> callback.done(true); <line28> return true; <line29> } <line30> if (channelFuture == null) { <line31> exchange.setException(new CamelExchangeException(""Cannot get channel from pool"", exchange)); <line32> callback.done(true); <line33> return true; <line34> } <line35> channelFuture.addListener(new ChannelConnectedListener(exchange, callback, body)); <line36> return false; <line37> } <line38> } <line39> "	<line8>, <line21>
6867	"public class A { <line0> public Node loadNodeFromXml(String fileName) throws Exception { <line1> URL resource = getClass().getClassLoader().getResource(fileName); <line2> if (resource == null) { <line3> throw new IllegalArgumentException(""no file "" + fileName + "" found in resources""); <line4> } else { <line5> return XMLHandler.getSubNode(XMLHandler.loadXMLFile(resource), ""entry""); <line6> } <line7> } <line8> } <line9> "	<line3>
6868	"public class A { <line0> public static MessageTransfer4 makeBasicMessageTransfer( <line1> MyOscarLoggedInInfo credentials, <line2> byte[] messageThreadId, <line3> Long replyToPersonId, <line4> String subject, <line5> String messageBody) { <line6> try { <line7> MessageTransfer4 messageTransfer = new MessageTransfer4(); <line8> messageTransfer.setMessageThreadId(messageThreadId); <line9> messageTransfer.setReplyToPersonId(replyToPersonId); <line10> messageTransfer.setSenderPersonId(credentials.getLoggedInPersonId()); <line11> messageTransfer.setSentTime(new GregorianCalendar()); <line12> MessagePartTransfer subjectPart = new MessagePartTransfer(); <line13> if (subject != null) subjectPart.setContents(subject.getBytes(""UTF-8"")); <line14> subjectPart.setDataType(""SUBJECT""); <line15> subjectPart.setMimeType(""text/plain""); <line16> messageTransfer.getMessageParts().add(subjectPart); <line17> MessagePartTransfer bodyPart = new MessagePartTransfer(); <line18> if (messageBody != null) bodyPart.setContents(messageBody.getBytes(""UTF-8"")); <line19> bodyPart.setDataType(""MESSAGE""); <line20> bodyPart.setMimeType(""text/plain""); <line21> messageTransfer.getMessageParts().add(bodyPart); <line22> return (messageTransfer); <line23> } catch (UnsupportedEncodingException e) { <line24> throw (new RuntimeException(e)); <line25> } <line26> } <line27> } <line28> "	<line24>
6869	public class A { <line0> @Override <line1> public void put(Object key, Object value) { <line2> try { <line3> V newValue = (V) clone(value); <line4> if (value instanceof KapuaListResult) { <line5> for (Object element : ((KapuaListResult) value).getItems()) { <line6> ((KapuaListResult) newValue).addItem((KapuaEntity) clone(element)); <line7> } <line8> } <line9> hashMap.put((K) key, newValue); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	<line11>
6870	public class A { <line0> @Override <line1> public void exportTableRowData(ITableRow row, AbstractTableRowData rowData) { <line2> for (IColumn column : m_columnSet.getColumns()) { <line3> if (m_ignoredColumns.contains(column)) { <line4> continue; <line5> } <line6> Object value = column.getValue(row); <line7> FastPropertyDescriptor propertyDesc = m_propertyDescriptorByColumn.get(column); <line8> if (propertyDesc != null) { <line9> try { <line10> Method columnWriteMethod = propertyDesc.getWriteMethod(); <line11> Object dto = getDataContainer(rowData, columnWriteMethod.getDeclaringClass()); <line12> columnWriteMethod.invoke(dto, value); <line13> } catch (Exception t) { <line14> } <line15> } else { <line16> rowData.setCustomValue(column.getColumnId(), value); <line17> } <line18> } <line19> rowData.setRowState(row.getStatus()); <line20> exportCustomValues(row, rowData); <line21> } <line22> } <line23> 	<line14>
6871	public class A { <line0> private void checkForMinimumApplicationInstances( <line1> Application application, List<String> defaultNetworkPartitions) { <line2> List<String> instanceIds = new ArrayList<String>(); <line3> for (String networkPartitionId : defaultNetworkPartitions) { <line4> if (!networkPartitionContextsMap.containsKey(networkPartitionId)) { <line5> String instanceId; <line6> NetworkPartitionContext context = new NetworkPartitionContext(networkPartitionId); <line7> ApplicationInstance appInstance = <line8> (ApplicationInstance) application.getInstanceByNetworkPartitionId(context.getId()); <line9> if (appInstance != null) { <line10> return; <line11> } <line12> instanceId = handleApplicationInstanceCreation(application, context, null); <line13> instanceIds.add(instanceId); <line14> } <line15> } <line16> if (!instanceIds.isEmpty()) { <line17> startDependency(application, instanceIds); <line18> } <line19> } <line20> } <line21> 	<line6>, <line10>
6872	"public class A { <line0> public static String toJson(final Object obj) { <line1> try { <line2> return getObjectMapper().writeValueAsString(obj); <line3> } catch (JsonProcessingException ex) { <line4> return """"; <line5> } <line6> } <line7> } <line8> "	<line4>
6873	public class A { <line0> @PostConstruct <line1> public synchronized void start() { <line2> if (discoveryServiceURI != null || scheduledFuture != null) { <line3> return; <line4> } <line5> scheduledFuture = <line6> executorService.scheduleAtFixedRate( <line7> () -> { <line8> try { <line9> updateServiceInventory(); <line10> } catch (Throwable e) { <line11> } <line12> }, <line13> updateInterval.toMillis(), <line14> updateInterval.toMillis(), <line15> TimeUnit.MILLISECONDS); <line16> } <line17> } <line18> 	<line11>
6874	public class A { <line0> @Override <line1> public synchronized ListenableFuture<Boolean> shutdown() { <line2> if (!this.running) { <line3> return Futures.immediateFuture(true); <line4> } <line5> ListenableFuture<Boolean> shutdownFuture = <line6> this.executorService.submit( <line7> () -> { <line8> synchronized (AbstractLightyModule.this) { <line9> final boolean stopResult = stopProcedure(); <line10> this.shutdownLatch.countDown(); <line11> this.running = false; <line12> return stopResult; <line13> } <line14> }); <line15> if (!this.executorIsProvided) { <line16> return Futures.transform( <line17> shutdownFuture, <line18> (result) -> { <line19> synchronized (AbstractLightyModule.this) { <line20> this.executorService.shutdown(); <line21> this.executorService = null; <line22> return true; <line23> } <line24> }, <line25> MoreExecutors.directExecutor()); <line26> } <line27> return shutdownFuture; <line28> } <line29> } <line30> 	<line3>, <line5>, <line9>, <line12>, <line20>
6875	public class A { <line0> private int getStreamSizeFromComment(String fileToImport) { <line1> int ret = 1; <line2> try { <line3> ZipFile zipFile = new ZipFile(fileToImport); <line4> String comment = zipFile.getComment(); <line5> ret = processZipFileStreamSizeComment(comment); <line6> zipFile.close(); <line7> } catch (IOException e) { <line8> } <line9> return ret; <line10> } <line11> } <line12> 	<line8>
6876	"public class A { <line0> ContainerCommandResponseProto handlePutSmallFile( <line1> ContainerCommandRequestProto request, <line2> KeyValueContainer kvContainer, <line3> DispatcherContext dispatcherContext) { <line4> if (!request.hasPutSmallFile()) { <line5> if (LOG.isDebugEnabled()) { <line6> } <line7> return malformedRequest(request); <line8> } <line9> PutSmallFileRequestProto putSmallFileReq = request.getPutSmallFile(); <line10> final ContainerProtos.BlockData blockDataProto; <line11> try { <line12> checkContainerOpen(kvContainer); <line13> BlockData blockData = BlockData.getFromProtoBuf(putSmallFileReq.getBlock().getBlockData()); <line14> Preconditions.checkNotNull(blockData); <line15> ContainerProtos.ChunkInfo chunkInfoProto = putSmallFileReq.getChunkInfo(); <line16> ChunkInfo chunkInfo = ChunkInfo.getFromProtoBuf(chunkInfoProto); <line17> Preconditions.checkNotNull(chunkInfo); <line18> ChunkBuffer data = ChunkBuffer.wrap(putSmallFileReq.getData().asReadOnlyByteBufferList()); <line19> if (dispatcherContext == null) { <line20> dispatcherContext = new DispatcherContext.Builder().build(); <line21> } <line22> BlockID blockID = blockData.getBlockID(); <line23> chunkManager.writeChunk(kvContainer, blockID, chunkInfo, data, dispatcherContext); <line24> chunkManager.finishWriteChunks(kvContainer, blockData); <line25> List<ContainerProtos.ChunkInfo> chunks = new LinkedList<>(); <line26> chunks.add(chunkInfoProto); <line27> blockData.setChunks(chunks); <line28> blockData.setBlockCommitSequenceId(dispatcherContext.getLogIndex()); <line29> blockManager.putBlock(kvContainer, blockData); <line30> blockDataProto = blockData.getProtoBufMessage(); <line31> metrics.incContainerBytesStats(Type.PutSmallFile, chunkInfo.getLen()); <line32> } catch (StorageContainerException ex) { <line33> return ContainerUtils.logAndReturnError(LOG, ex, request); <line34> } catch (IOException ex) { <line35> return ContainerUtils.logAndReturnError( <line36> LOG, <line37> new StorageContainerException(""Read Chunk failed"", ex, PUT_SMALL_FILE_ERROR), <line38> request); <line39> } <line40> return getPutFileResponseSuccess(request, blockDataProto); <line41> } <line42> } <line43> "	<line6>
6877	"public class A { <line0> @Override <line1> public void configure() { <line2> if (context.getRoute(""direct.route"") == null) { <line3> from(""direct:start"").id(""direct.route"").to(destinationName); <line4> } <line5> from(destinationName + ""?transacted=true&concurrentConsumers="" + concurrentConsumers) <line6> .id(""consumer.route."" + routeNumber) <line7> .choice() <line8> .when(header(""JMSRedelivered"").isEqualTo(""false"")) <line9> .log( <line10> ""Route "" <line11> + routeNumber <line12> + "" 1st attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}"") <line13> .to(""mock:test.before."" + routeNumber) <line14> .process( <line15> new Processor() { <line16> private final AtomicInteger counter = new AtomicInteger(); <line17>  <line18> @Override <line19> public void process(Exchange exchange) throws Exception { <line20> if (counter.incrementAndGet() == maxAttemptsCount) { <line21> throw new IllegalArgumentException(""Forced rollback""); <line22> } <line23> latch.countDown(); <line24> } <line25> }) <line26> .when(header(""JMSRedelivered"").isEqualTo(""true"")) <line27> .log( <line28> ""Route "" <line29> + routeNumber <line30> + "" 2nd attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}"") <line31> .to(""mock:test.after."" + routeNumber) <line32> .process( <line33> new Processor() { <line34> @Override <line35> public void process(Exchange exchange) throws Exception { <line36> latch.countDown(); <line37> } <line38> }) <line39> .otherwise() <line40> .to(""mock:test.after""); <line41> } <line42> } <line43> "	<line21>
6878	"public class A { <line0> private Map.Entry<String, AbstractIdentityProviderDefinition> evaluateLoginHint( <line1> Model model, <line2> Map<String, SamlIdentityProviderDefinition> samlIdentityProviders, <line3> Map<String, AbstractExternalOAuthIdentityProviderDefinition> oauthIdentityProviders, <line4> Map<String, AbstractIdentityProviderDefinition> allIdentityProviders, <line5> List<String> allowedIdentityProviderKeys, <line6> String loginHintParam, <line7> UaaLoginHint uaaLoginHint, <line8> Map<String, AbstractIdentityProviderDefinition> loginHintProviders) { <line9> Map.Entry<String, AbstractIdentityProviderDefinition> idpForRedirect = null; <line10> if (loginHintParam != null) { <line11> if (uaaLoginHint != null) { <line12> if (OriginKeys.UAA.equals(uaaLoginHint.getOrigin()) <line13> || OriginKeys.LDAP.equals(uaaLoginHint.getOrigin())) { <line14> if (allowedIdentityProviderKeys == null <line15> || allowedIdentityProviderKeys.contains(uaaLoginHint.getOrigin())) { <line16> model.addAttribute(""login_hint"", loginHintParam); <line17> samlIdentityProviders.clear(); <line18> oauthIdentityProviders.clear(); <line19> } else { <line20> model.addAttribute(""error"", ""invalid_login_hint""); <line21> } <line22> } else { <line23> List<Map.Entry<String, AbstractIdentityProviderDefinition>> hintIdentityProviders = <line24> allIdentityProviders.entrySet().stream() <line25> .filter(idp -> idp.getKey().equals(uaaLoginHint.getOrigin())) <line26> .collect(Collectors.toList()); <line27> if (loginHintProviders.size() > 1) { <line28> throw new IllegalStateException( <line29> ""There is a misconfiguration with the identity provider(s). Please contact your"" <line30> + "" system administrator.""); <line31> } <line32> if (loginHintProviders.size() == 1) { <line33> idpForRedirect = new ArrayList<>(loginHintProviders.entrySet()).get(0); <line34> } else { <line35> model.addAttribute(""error"", ""invalid_login_hint""); <line36> } <line37> } <line38> } else { <line39> List<Map.Entry<String, AbstractIdentityProviderDefinition>> matchingIdentityProviders = <line40> allIdentityProviders.entrySet().stream() <line41> .filter( <line42> idp -> <line43> ofNullable(idp.getValue().getEmailDomain()) <line44> .orElse(Collections.emptyList()) <line45> .contains(loginHintParam)) <line46> .collect(Collectors.toList()); <line47> if (matchingIdentityProviders.size() > 1) { <line48> throw new IllegalStateException( <line49> ""There is a misconfiguration with the identity provider(s). Please contact your"" <line50> + "" system administrator.""); <line51> } else if (matchingIdentityProviders.size() == 1) { <line52> idpForRedirect = matchingIdentityProviders.get(0); <line53> } <line54> } <line55> } <line56> return idpForRedirect; <line57> } <line58> } <line59> "	<line12>, <line34>, <line35>, <line53>
6879	public class A { <line0> @Override <line1> public void run() { <line2> moveIndexJs(); <line3> removeJsFolder(); <line4> fileByFileTasks(); <line5> deleteEmptyDirectories(); <line6> } <line7> } <line8> 	<line6>
6880	public class A { <line0> @Override <line1> public boolean move(File source, File destination) { <line2> if (!source.exists()) { <line3> return false; <line4> } <line5> destination.delete(); <line6> try { <line7> if (source.isDirectory()) { <line8> FileUtils.moveDirectory(source, destination); <line9> } else { <line10> FileUtils.moveFile(source, destination); <line11> } <line12> } catch (IOException ioException) { <line13> if (_log.isDebugEnabled()) { <line14> } <line15> return false; <line16> } <line17> return true; <line18> } <line19> } <line20> 	<line14>
6881	public class A { <line0> @Override <line1> protected void syslog(String message, Exception exc) { <line2> if (message == null && exc == null) return; <line3> } <line4> } <line5> 	<line3>
6882	public class A { <line0> private void logEvent(String event, long barrierId) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> } <line4> } <line5> 	<line2>
6883	public class A { <line0> private Set<Long> collectGatewayRelayIdsFromCloud(final Cloud cloud) { <line1> final Set<Long> idSet = new HashSet<>(); <line2> for (final CloudGatewayRelay conn : cloud.getGatewayRelays()) { <line3> idSet.add(conn.getRelay().getId()); <line4> } <line5> return idSet; <line6> } <line7> } <line8> 	<line1>
6884	public class A { <line0> public static com.liferay.segments.model.SegmentsExperienceSoap getSegmentsExperience( <line1> long segmentsExperienceId) throws RemoteException { <line2> try { <line3> com.liferay.segments.model.SegmentsExperience returnValue = <line4> SegmentsExperienceServiceUtil.getSegmentsExperience(segmentsExperienceId); <line5> return com.liferay.segments.model.SegmentsExperienceSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>
6885	"public class A { <line0> private static void tryCompactingTable( <line1> CompactionMode compactMode, String tableName, String partitionString, Duration timeout) <line2> throws TimeoutException { <line3> Instant beforeCompactionStart = Instant.now(); <line4> onHive() <line5> .executeQuery( <line6> format( <line7> ""ALTER TABLE %s %s COMPACT '%s'"", tableName, partitionString, compactMode.name())) <line8> .getRowsCount(); <line9> long loopStart = System.nanoTime(); <line10> while (true) { <line11> try { <line12> Thread.sleep(1000); <line13> } catch (InterruptedException e) { <line14> Thread.currentThread().interrupt(); <line15> throw new RuntimeException(e); <line16> } <line17> List<Map<String, String>> startedCompactions = <line18> getTableCompactions(compactMode, tableName, Optional.of(beforeCompactionStart)); <line19> verify(startedCompactions.size() < 2, ""Expected at most 1 compaction""); <line20> if (startedCompactions.isEmpty()) { <line21> continue; <line22> } <line23> String compactionState = startedCompactions.get(0).get(""state""); <line24> if (compactionState.equals(""failed"")) { <line25> throw new IllegalStateException(""Compaction has failed""); <line26> } <line27> if (compactionState.equals(""succeeded"")) { <line28> return; <line29> } <line30> if (Duration.nanosSince(loopStart).compareTo(timeout) > 0) { <line31> throw new TimeoutException(""Compaction has timed out""); <line32> } <line33> } <line34> } <line35> } <line36> "	<line9>, <line21>, <line25>, <line31>
6886	public class A { <line0> @Override <line1> public CommerceSubscriptionEntry incrementCommerceDeliverySubscriptionEntryCycle( <line2> long commerceSubscriptionEntryId) throws PortalException { <line3> CommerceSubscriptionEntry commerceSubscriptionEntry = <line4> commerceSubscriptionEntryPersistence.findByPrimaryKey(commerceSubscriptionEntryId); <line5> CPSubscriptionType cpSubscriptionType = <line6> _cpSubscriptionTypeRegistry.getCPSubscriptionType( <line7> commerceSubscriptionEntry.getDeliverySubscriptionType()); <line8> if (cpSubscriptionType == null) { <line9> if (_log.isInfoEnabled()) { <line10> } <line11> return commerceSubscriptionEntry; <line12> } <line13> long currentSubscriptionCycle = commerceSubscriptionEntry.getDeliveryCurrentCycle(); <line14> commerceSubscriptionEntry.setDeliveryCurrentCycle(currentSubscriptionCycle + 1); <line15> User user = userLocalService.getUser(commerceSubscriptionEntry.getUserId()); <line16> commerceSubscriptionEntry.setDeliveryLastIterationDate( <line17> commerceSubscriptionEntry.getDeliveryNextIterationDate()); <line18> Date subscriptionNextIterationDate = <line19> cpSubscriptionType.getSubscriptionNextIterationDate( <line20> user.getTimeZone(), <line21> commerceSubscriptionEntry.getDeliverySubscriptionLength(), <line22> commerceSubscriptionEntry.getDeliverySubscriptionTypeSettingsProperties(), <line23> commerceSubscriptionEntry.getDeliveryNextIterationDate()); <line24> commerceSubscriptionEntry.setDeliveryNextIterationDate(subscriptionNextIterationDate); <line25> CommerceSubscriptionEntry updatedSubscriptionEntry = <line26> commerceSubscriptionEntryPersistence.update(commerceSubscriptionEntry); <line27> CommerceOrderItem commerceOrderItem = commerceSubscriptionEntry.fetchCommerceOrderItem(); <line28> if (commerceOrderItem != null) { <line29> CommerceOrder commerceOrder = commerceOrderItem.getCommerceOrder(); <line30> _commerceNotificationHelper.sendNotifications( <line31> commerceOrder.getGroupId(), <line32> commerceOrder.getUserId(), <line33> CommerceSubscriptionNotificationConstants.SUBSCRIPTION_RENEWED, <line34> updatedSubscriptionEntry); <line35> } <line36> return updatedSubscriptionEntry; <line37> } <line38> } <line39> 	<line10>
6887	"public class A { <line0> public static java.util.List<com.liferay.oauth2.provider.model.OAuth2Authorization> <line1> getApplicationOAuth2Authorizations( <line2> HttpPrincipal httpPrincipal, <line3> long oAuth2ApplicationId, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator< <line7> com.liferay.oauth2.provider.model.OAuth2Authorization> <line8> orderByComparator) <line9> throws com.liferay.portal.kernel.exception.PortalException { <line10> try { <line11> MethodKey methodKey = <line12> new MethodKey( <line13> OAuth2AuthorizationServiceUtil.class, <line14> ""getApplicationOAuth2Authorizations"", <line15> _getApplicationOAuth2AuthorizationsParameterTypes0); <line16> MethodHandler methodHandler = <line17> new MethodHandler(methodKey, oAuth2ApplicationId, start, end, orderByComparator); <line18> Object returnObj = null; <line19> try { <line20> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line21> } catch (Exception exception) { <line22> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line23> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line24> } <line25> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line26> } <line27> return (java.util.List<com.liferay.oauth2.provider.model.OAuth2Authorization>) returnObj; <line28> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line29> throw systemException; <line30> } <line31> } <line32> } <line33> "	<line29>
6888	"public class A { <line0> @Test <line1> public void addNonSampledSpanToLogEntryWithAllSpans() { <line2> String log = <line3> logWithSpanAndLog4jConfiguration( <line4> TEST_PATTERN, <line5> SpanContext.create( <line6> TraceId.fromLowerBase16(""cd7061dfa9d312cdcc42edab3feab51b""), <line7> SpanId.fromLowerBase16(""117d42d4c7acd066""), <line8> TraceOptions.builder().setIsSampled(false).build(), <line9> EMPTY_TRACESTATE), <line10> new Function<Logger, Void>() { <line11> @Override <line12> public Void apply(Logger logger) { <line13> return null; <line14> } <line15> }); <line16> assertThat(log) <line17> .isEqualTo( <line18> ""traceId=cd7061dfa9d312cdcc42edab3feab51b spanId=117d42d4c7acd066 sampled=false INFO  "" <line19> + ""- message #2""); <line20> } <line21> } <line22> "	<line13>
6889	"public class A { <line0> @Override <line1> public void start() { <line2> IActionEngine engine = this.getActionEngineMgr().getActionEngine(""NodeOperActionEngine""); <line3> new MOFInstallMgtAction(""installmof"", feature, engine); <line4> new MOFInstallMgtAction(""uninstallmof"", feature, engine); <line5> new MSCPGeneralAction(""fstart"", feature, engine); <line6> new MSCPGeneralAction(""fstop"", feature, engine); <line7> new MSCPGeneralAction(""killproc"", feature, engine); <line8> new MSCPGeneralAction(""kill"", feature, engine); <line9> new MSCPGeneralAction(""shutdown"", feature, engine); <line10> new MSCPGeneralAction(""chgsyspro"", feature, engine); <line11> new MSCPGeneralAction(""loadnodepro"", feature, engine); <line12> new MSCPGeneralAction(""chgnodepro"", feature, engine); <line13> new MSCPGeneralAction(""watch"", feature, engine); <line14> new MSCPGeneralAction(""unwatch"", feature, engine); <line15> new MSCPGeneralAction(""upgrade"", feature, engine); <line16> new MSCPGeneralAction(""restart"", feature, engine); <line17> new MSCPGeneralAction(""stopuav"", feature, engine); <line18> new MOFCtrlAction(""ctrlmof"", feature, engine); <line19> nodeOperHttpServer = <line20> new NodeOperHttpServer(""NodeOperHttpServer"", this.feature, ""nodeophandlers""); <line21> int port = <line22> DataConvertHelper.toInt( <line23> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.port""), 10101); <line24> int backlog = <line25> DataConvertHelper.toInt( <line26> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.backlog""), 10); <line27> int core = <line28> DataConvertHelper.toInt( <line29> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.core""), 5); <line30> int max = <line31> DataConvertHelper.toInt( <line32> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.max""), 10); <line33> int bqsize = <line34> DataConvertHelper.toInt( <line35> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.bqsize""), 10); <line36> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line37> ThreadPoolExecutor exe = <line38> new ThreadPoolExecutor( <line39> core, max, 30000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue(bqsize)); <line40> nodeOperHttpServer.start(exe, port, backlog, true); <line41> if (log.isTraceEnable()) { <line42> } <line43> } <line44> } <line45> "	<line42>
6890	"public class A { <line0> private void verifyListener( <line1> String address, <line2> Integer port, <line3> boolean enabled, <line4> boolean secure, <line5> Supplier<UndertowFactory.AcceptingChannelWithAddress> listenerProvider) { <line6> UndertowFactory.AcceptingChannelWithAddress expectedListener = null; <line7> boolean listenerFound = false; <line8> UndertowFactory.AcceptingChannelWithAddress backupListener = null; <line9> for (Iterator<UndertowFactory.AcceptingChannelWithAddress> iterator = <line10> listeners.values().iterator(); <line11> iterator.hasNext(); ) { <line12> UndertowFactory.AcceptingChannelWithAddress listener = iterator.next(); <line13> String className = listener.getAcceptingChannel().getClass().getName(); <line14> boolean secureMatch = <line15> secure && className.equals(""io.undertow.protocols.ssl.UndertowAcceptingSslChannel""); <line16> boolean nonSecureMatch = !secure && className.equals(""org.xnio.nio.QueuedNioTcpServer""); <line17> if (secureMatch || nonSecureMatch) { <line18> if (match(address, port, listener.getAddress())) { <line19> listenerFound = true; <line20> if (enabled) { <line21> expectedListener = listener; <line22> } else { <line23> iterator.remove(); <line24> } <line25> } else { <line26> backupListener = listener; <line27> } <line28> } <line29> } <line30> if (expectedListener == null && backupListener != null) { <line31> expectedListener = backupListener; <line32> } <line33> if (listenerFound) { <line34> if (enabled) { <line35> } <line36> } else if (enabled) { <line37> UndertowFactory.AcceptingChannelWithAddress listener = listenerProvider.get(); <line38> listeners.put(UUID.randomUUID().toString(), listener); <line39> } <line40> } <line41> } <line42> "	<line23>, <line35>, <line37>
6891	"public class A { <line0> public static String generateMachineToken(Function<String, String> cryptoFunction) { <line1> if (cryptoFunction == null) { <line2> throw new IllegalArgumentException(""Crypto function cannot be null.""); <line3> } <line4> final StringBuilder sb = new StringBuilder(); <line5> try { <line6> final InetAddress loopBackAddress = InetAddress.getLocalHost(); <line7> final Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces(); <line8> while (networks.hasMoreElements()) { <line9> final NetworkInterface network = networks.nextElement(); <line10> final byte[] mac = network.getHardwareAddress(); <line11> if (mac != null) { <line12> StringBuilder macAddress = new StringBuilder(); <line13> for (byte macByte : mac) { <line14> macAddress.append(String.format(""%02X"", macByte)); <line15> } <line16> if (!""0000000000E0"".equals(macAddress.toString())) { <line17> sb.append(macAddress.toString()); <line18> } <line19> } <line20> } <line21> sb.append('-'); <line22> sb.append(System.getProperty(""os.name"")); <line23> sb.append(System.getProperty(""os.version"")); <line24> sb.append('-').append(loopBackAddress.getHostName()); <line25> } catch (SocketException | UnknownHostException e) { <line26> sb.append(UUID.randomUUID().toString()); <line27> } <line28> final String machineId = cryptoFunction.apply(sb.toString()); <line29> return machineId; <line30> } <line31> } <line32> "	<line26>, <line29>
6892	"public class A { <line0> @Rule <line1> public Timeout testsShouldTimeout() { <line2> int waitLonger = 0; <line3> try { <line4> String timeoutString = System.getProperty(""timeout.factor""); <line5> if (timeoutString != null && !timeoutString.isEmpty()) { <line6> waitLonger = Integer.parseInt(timeoutString); <line7> } <line8> } catch (NumberFormatException exception) { <line9> } <line10> return Timeout.builder() <line11> .withTimeout(waitLonger * defaultTimeoutSeconds(), TimeUnit.SECONDS) <line12> .withLookingForStuckThread(true) <line13> .build(); <line14> } <line15> } <line16> "	<line9>
6893	"public class A { <line0> private void sendMessage(EchoAsync echoService) { <line1> if (!providerPreparingForShutdown.get()) { <line2> try { <line3> if (!semaphore.tryAcquire(5, TimeUnit.SECONDS)) { <line4> throw new TimeoutException(""unable to acquire semaphore in time""); <line5> } <line6> echoService.echoString( <line7> new Callback<String>() { <line8> @Override <line9> public void onSuccess(String result) { <line10> if (result != null) { <line11> if (result.contains(""Unable to transform"")) { <line12> providerPreparingForShutdown.set(true); <line13> } <line14> semaphore.release(); <line15> } else { <line16> } <line17> } <line18>  <line19> @Override <line20> public void onFailure(JoynrRuntimeException runtimeException) { <line21> semaphore.release(); <line22> } <line23> }, <line24> ""Test "" + System.currentTimeMillis()); <line25> } catch (InterruptedException | TimeoutException e) { <line26> } <line27> } else { <line28> } <line29> } <line30> } <line31> "	<line11>, <line16>, <line21>, <line26>, <line28>
6894	"public class A { <line0> private void startMonitor(final String interfaceName) { <line1> synchronized (lock) { <line2> if (tasks == null) { <line3> tasks = new HashMap<>(); <line4> } <line5> if (stopThreads == null) { <line6> stopThreads = new HashMap<>(); <line7> } <line8> if (tasks.get(interfaceName) == null) { <line9> stopThreads.put(interfaceName, new AtomicBoolean(false)); <line10> Future<?> task = <line11> this.executor.submit( <line12> () -> { <line13> Thread.currentThread().setName(""EthernetMonitor_"" + interfaceName); <line14> while (!stopThreads.get(interfaceName).get()) { <line15> try { <line16> monitor(interfaceName); <line17> monitorWait(interfaceName); <line18> } catch (InterruptedException interruptedException) { <line19> Thread.currentThread().interrupt(); <line20> } catch (Throwable t) { <line21> } <line22> } <line23> }); <line24> tasks.put(interfaceName, task); <line25> } else { <line26> monitorNotify(interfaceName); <line27> } <line28> } <line29> } <line30> } <line31> "	<line9>, <line19>, <line21>
6895	"public class A { <line0> private void logUnmatchedTrip(int blockNo, String entryKey, boolean setGtfsBlockId) { <line1> for (StifTrip trip : unmatchedTrips) { <line2> for (Trip gtfsTrip : trip.getGtfsTrips()) { <line3> blockNo++; <line4> String blockId = <line5> gtfsTrip.getServiceId().getId() <line6> + ""_"" <line7> + trip.serviceCode.getLetterCode() <line8> + ""_"" <line9> + trip.firstStop <line10> + ""_"" <line11> + trip.firstStopTime <line12> + ""_"" <line13> + trip.runId.replace(""-"", ""_"") <line14> + blockNo <line15> + ""_orphn""; <line16> if (blockId.length() > MAX_BLOCK_ID_LENGTH) { <line17> blockId = truncateId(blockId); <line18> } <line19> if (setGtfsBlockId) { <line20> gtfsTrip.setBlockId(blockId); <line21> _AbnormalStifDataLogger.dumpBlockDataForTrip( <line22> trip, <line23> gtfsTrip.getServiceId().getId(), <line24> gtfsTrip.getId().getId(), <line25> blockId, <line26> gtfsTrip.getRoute().getId().getId()); <line27> _AbnormalStifDataLogger.log( <line28> ""stif_trips_without_pullout.csv"", <line29> trip.id, <line30> trip.path, <line31> trip.lineNumber, <line32> gtfsTrip.getId(), <line33> blockId); <line34> } <line35> usedGtfsTrips.add(gtfsTrip); <line36> } <line37> } <line38> } <line39> } <line40> "	<line2>, <line19>
6896	public class A { <line0> @Override <line1> public FhirValidator get() { <line2> final FhirInstanceValidator instanceValidator = new FhirInstanceValidator(); <line3> final FhirValidator fhirValidator = ctx.newValidator(); <line4> fhirValidator.setValidateAgainstStandardSchematron( <line5> validationConfiguration.isSchematronValidation()); <line6> fhirValidator.setValidateAgainstStandardSchema(validationConfiguration.isSchemaValidation()); <line7> fhirValidator.registerValidatorModule(instanceValidator); <line8> instanceValidator.setValidationSupport(this.supportChain); <line9> return fhirValidator; <line10> } <line11> } <line12> 	<line2>
6897	"public class A { <line0> public void genSearchRecordTypeMetaDataModel() { <line1> Collection<Class<?>> searchRecordClasses = new HashSet<>(); <line2> for (Class<?> searchRecordBaseClass : searchRecordBaseClasses) { <line3> XmlSeeAlso xmlSeeAlso = searchRecordBaseClass.getAnnotation(XmlSeeAlso.class); <line4> for (Class<?> clazz : xmlSeeAlso.value()) { <line5> if (clazz == searchRecordBaseClass <line6> || !searchRecordBaseClass.isAssignableFrom(clazz) <line7> || Modifier.isAbstract(clazz.getModifiers())) { <line8> continue; <line9> } <line10> searchRecordClasses.add(clazz); <line11> } <line12> } <line13> Set<String> searchRecordTypeSet = new HashSet<>(); <line14> for (Enum value : searchRecordTypeEnumClass.getEnumConstants()) { <line15> String searchRecordTypeName = searchRecordTypeEnumAccessor.getStringValue(value); <line16> searchRecordTypeSet.add(searchRecordTypeName); <line17> } <line18> searchRecordTypeSet.addAll(additionalSearchRecordTypes.keySet()); <line19> Map<String, Class<?>> searchRecordClassMap = new HashMap<>(); <line20> for (Class<?> clazz : searchRecordClasses) { <line21> String searchRecordTypeName = clazz.getSimpleName(); <line22> if (searchRecordClassMap.containsKey(searchRecordTypeName)) { <line23> throw new IllegalStateException( <line24> ""Search record class already registered: "" + searchRecordTypeName + "", "" + clazz); <line25> } <line26> searchRecordClassMap.put(searchRecordTypeName, clazz); <line27> } <line28> Set<Class<?>> unresolvedSearchRecords = new HashSet<>(searchRecordClassMap.values()); <line29> for (String searchRecordType : searchRecordTypeSet) { <line30> String searchRecordTypeName = toInitialUpper(searchRecordType); <line31> Class<?> searchClass; <line32> Class<?> searchBasicClass; <line33> Class<?> searchAdvancedClass; <line34> searchClass = searchRecordClassMap.get(searchRecordTypeName + ""Search""); <line35> unresolvedSearchRecords.remove(searchClass); <line36> searchBasicClass = searchRecordClassMap.get(searchRecordTypeName + ""SearchBasic""); <line37> unresolvedSearchRecords.remove(searchBasicClass); <line38> searchAdvancedClass = searchRecordClassMap.get(searchRecordTypeName + ""SearchAdvanced""); <line39> unresolvedSearchRecords.remove(searchAdvancedClass); <line40> if (searchBasicClass != null) { <line41> Enum<?> searchRecordEnumValue = null; <line42> String searchRecordTypeEnumConstantName = null; <line43> try { <line44> searchRecordEnumValue = searchRecordTypeEnumAccessor.getEnumValue(searchRecordType); <line45> searchRecordTypeEnumConstantName = searchRecordEnumValue.name(); <line46> } catch (IllegalArgumentException e) { <line47> searchRecordTypeEnumConstantName = additionalSearchRecordTypes.get(searchRecordType); <line48> } <line49> SearchRecordTypeSpec spec = new SearchRecordTypeSpec(); <line50> spec.setName(searchRecordType); <line51> spec.setTypeName(searchRecordTypeName); <line52> spec.setEnumConstantName(searchRecordTypeEnumConstantName); <line53> spec.setSearchClass(searchClass); <line54> spec.setSearchBasicClass(searchBasicClass); <line55> spec.setSearchAdvancedClass(searchAdvancedClass); <line56> searchRecordTypeMap.put(spec.getName(), spec); <line57> } <line58> } <line59> if (!unresolvedSearchRecords.isEmpty()) { <line60> System.out.println( <line61> ""[WARNING] Unresolved search record types detected: "" + unresolvedSearchRecords); <line62> } <line63> } <line64> } <line65> "	<line60>
6898	"public class A { <line0> @Override <line1> public String getTuple(Object object) { <line2> if (object != null) { <line3> return object.toString(); <line4> } else { <line5> return ""null""; <line6> } <line7> } <line8> } <line9> "	<line5>
6899	public class A { <line0> private Future<List<String>> fail(Throwable cause, String baseUrl) { <line1> return Future.failedFuture(cause); <line2> } <line3> } <line4> 	<line1>
6900	public class A { <line0> protected final String getInNode(final OFPFlow flow) { <line1> if (!flow.validate()) { <line2> return null; <line3> } <line4> BasicFlowMatch flowMatchs = flow.getMatches().get(0); <line5> if (flowMatchs == null) { <line6> return null; <line7> } <line8> return flowMatchs.getInNode(); <line9> } <line10> } <line11> 	<line1>
6901	public class A { <line0> private void closeStreams() { <line1> try { <line2> if (reader != null && socket != null && !socket.isInputShutdown()) { <line3> reader.close(); <line4> } <line5> if (writer != null && socket != null && !socket.isOutputShutdown()) { <line6> writer.close(); <line7> } <line8> } catch (final IOException e) { <line9> } <line10> } <line11> } <line12> 	<line9>
6902	public class A { <line0> @Override <line1> public Boolean execute(final DeleteActivityCacheUpdateRequest inRequest) { <line2> ActivityDTO activity = inRequest.getActivity(); <line3> long activityId = activity.getId(); <line4> EntityType streamType = activity.getDestinationStream().getType(); <line5> switch (streamType) { <line6> case GROUP: <line7> DomainGroupModelView group = <line8> groupByShortNameDAO <line9> .execute(Arrays.asList(activity.getDestinationStream().getUniqueIdentifier())) <line10> .get(0); <line11> getCache() <line12> .removeFromList(CacheKeys.ENTITY_STREAM_BY_SCOPE_ID + group.getStreamId(), activityId); <line13> break; <line14> case PERSON: <line15> PersonModelView person = <line16> getPersonModelViewByAccountIdMapper.execute( <line17> activity.getDestinationStream().getUniqueIdentifier()); <line18> getCache() <line19> .removeFromList(CacheKeys.ENTITY_STREAM_BY_SCOPE_ID + person.getStreamId(), activityId); <line20> break; <line21> default: <line22> break; <line23> } <line24> for (Long personId : inRequest.getPersonIdsWithActivityStarred()) { <line25> getCache().removeFromList(CacheKeys.STARRED_BY_PERSON_ID + personId, activityId); <line26> } <line27> List<List<Long>> likers = getLikersForActivity.execute(Arrays.asList(activityId)); <line28> if (likers.size() > 0) { <line29> for (Long liker : likers.get(0)) { <line30> getCache().removeFromList(CacheKeys.LIKED_BY_PERSON_ID + liker, activityId); <line31> } <line32> } <line33> getCache().delete(CacheKeys.LIKERS_BY_ACTIVITY_ID + activityId); <line34> getCache().delete(CacheKeys.COMMENT_IDS_BY_ACTIVITY_ID + activityId); <line35> List<Long> followingUserIds = getIdsForUsersFollowingDestinationStream(inRequest.getActivity()); <line36> for (Long followerId : followingUserIds) { <line37> getCache().removeFromList(CacheKeys.ACTIVITIES_BY_FOLLOWING + followerId, activityId); <line38> } <line39> for (Long commentId : inRequest.getCommentIds()) { <line40> getCache().delete(CacheKeys.COMMENT_BY_ID + commentId); <line41> } <line42> getCache().delete(CacheKeys.ACTIVITY_BY_ID + activityId); <line43> getCache().delete(CacheKeys.ACTIVITY_SECURITY_BY_ID + activityId); <line44> return true; <line45> } <line46> } <line47> 	<line4>, <line11>, <line18>, <line25>, <line30>, <line37>, <line40>, <line42>, <line43>
6903	public class A { <line0> @Override <line1> public void tick(EventContext context, long curTime) { <line2> Task task = context.task; <line3> if (task.isCancelled() && task.cancellationTime + Task.MAX_CANCELLATION_TIME < curTime) { <line4> launchFailed(context); <line5> } <line6> } <line7> } <line8> 	<line4>
6904	public class A { <line0> public static void stopBrokerOnCounter() { <line1> if (doByteman.get()) { <line2> if (count++ == 1) { <line3> new Thread() { <line4> @Override <line5> public void run() { <line6> try { <line7> if (broker != null) { <line8> broker.stop(); <line9> broker = null; <line10> } <line11> } catch (Exception e) { <line12> e.printStackTrace(); <line13> } finally { <line14> brokerStopLatch.countDown(); <line15> } <line16> } <line17> }.start(); <line18> } <line19> } <line20> } <line21> } <line22> 	<line1>, <line3>, <line11>
6905	public class A { <line0> private void tryResetWorkerCreationCoolDown() { <line1> if (startWorkerCoolDown.isDone()) { <line2> startWorkerCoolDown = new CompletableFuture<>(); <line3> scheduleRunAsync(() -> startWorkerCoolDown.complete(null), startWorkerRetryInterval); <line4> } <line5> } <line6> } <line7> 	<line2>
6906	"public class A { <line0> @SuppressWarnings(""null"") <line1> @Override <line2> public void onSwallowException(@Nullable Exception e) { <line3> LoggerFactory.getLogger(ModbusManagerImpl.class) <line4> } <line5> } <line6> "	<line4>
6907	public class A { <line0> @BeforeEach <line1> public void setUp() { <line2> try { <line3> TestUtils.setupWeblogger(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	<line5>
6908	public class A { <line0> private void updateCurrentChannel(ChannelUID channelUID) { <line1> String channelId = channelUID.getIdWithoutGroup(); <line2> String channelGroupId = channelUID.getGroupId(); <line3> if (weatherData != null && weatherData.getCurrently() != null) { <line4> DarkSkyCurrentlyData currentData = weatherData.getCurrently(); <line5> State state = UnDefType.UNDEF; <line6> switch (channelId) { <line7> case CHANNEL_TIME_STAMP: <line8> state = getDateTimeTypeState(currentData.getTime()); <line9> break; <line10> case CHANNEL_CONDITION: <line11> state = getStringTypeState(currentData.getSummary()); <line12> break; <line13> case CHANNEL_CONDITION_ICON: <line14> state = getRawTypeState(DarkSkyConnection.getWeatherIcon(currentData.getIcon())); <line15> break; <line16> case CHANNEL_CONDITION_ICON_ID: <line17> state = getStringTypeState(currentData.getIcon()); <line18> break; <line19> case CHANNEL_TEMPERATURE: <line20> state = getQuantityTypeState(currentData.getTemperature(), CELSIUS); <line21> break; <line22> case CHANNEL_APPARENT_TEMPERATURE: <line23> state = getQuantityTypeState(currentData.getApparentTemperature(), CELSIUS); <line24> break; <line25> case CHANNEL_PRESSURE: <line26> state = getQuantityTypeState(currentData.getPressure(), HECTO(PASCAL)); <line27> break; <line28> case CHANNEL_HUMIDITY: <line29> state = getQuantityTypeState(currentData.getHumidity() * 100, PERCENT); <line30> break; <line31> case CHANNEL_WIND_SPEED: <line32> state = getQuantityTypeState(currentData.getWindSpeed(), METRE_PER_SECOND); <line33> break; <line34> case CHANNEL_WIND_DIRECTION: <line35> state = getQuantityTypeState(currentData.getWindBearing(), DEGREE_ANGLE); <line36> break; <line37> case CHANNEL_GUST_SPEED: <line38> state = getQuantityTypeState(currentData.getWindGust(), METRE_PER_SECOND); <line39> break; <line40> case CHANNEL_CLOUDINESS: <line41> state = getQuantityTypeState(currentData.getCloudCover() * 100, PERCENT); <line42> break; <line43> case CHANNEL_VISIBILITY: <line44> state = getQuantityTypeState(currentData.getVisibility(), KILO(METRE)); <line45> break; <line46> case CHANNEL_RAIN: <line47> state = <line48> getQuantityTypeState( <line49> PRECIP_TYPE_RAIN.equals(currentData.getPrecipType()) <line50> ? currentData.getPrecipIntensity() <line51> : 0, <line52> MILLIMETRE_PER_HOUR); <line53> break; <line54> case CHANNEL_SNOW: <line55> state = <line56> getQuantityTypeState( <line57> PRECIP_TYPE_SNOW.equals(currentData.getPrecipType()) <line58> ? currentData.getPrecipIntensity() <line59> : 0, <line60> MILLIMETRE_PER_HOUR); <line61> break; <line62> case CHANNEL_PRECIPITATION_INTENSITY: <line63> state = getQuantityTypeState(currentData.getPrecipIntensity(), MILLIMETRE_PER_HOUR); <line64> break; <line65> case CHANNEL_PRECIPITATION_PROBABILITY: <line66> state = getQuantityTypeState(currentData.getPrecipProbability() * 100, PERCENT); <line67> break; <line68> case CHANNEL_PRECIPITATION_TYPE: <line69> state = getStringTypeState(currentData.getPrecipType()); <line70> break; <line71> case CHANNEL_UVINDEX: <line72> state = getDecimalTypeState(currentData.getUvIndex()); <line73> break; <line74> case CHANNEL_OZONE: <line75> state = getQuantityTypeState(currentData.getOzone(), DOBSON_UNIT); <line76> break; <line77> case CHANNEL_SUNRISE: <line78> case CHANNEL_SUNSET: <line79> updateDailyForecastChannel(channelUID, 0); <line80> return; <line81> } <line82> updateState(channelUID, state); <line83> } else { <line84> } <line85> } <line86> } <line87> 	<line82>, <line84>
6909	public class A { <line0> @Override <line1> public Response toResponse(KapuaServiceDisabledException kapuaException) { <line2> return Response.status(STATUS) <line3> .entity(new ExceptionInfo(STATUS, kapuaException.getCode(), kapuaException)) <line4> .build(); <line5> } <line6> } <line7> 	<line2>
6910	"public class A { <line0> @Test <line1> public void testSerialization() { <line2> AbstractCache<VocabWord> cache = new AbstractCache.Builder<VocabWord>().build(); <line3> val words = new VocabWord[3]; <line4> words[0] = new VocabWord(1.0, ""word""); <line5> words[1] = new VocabWord(2.0, ""test""); <line6> words[2] = new VocabWord(3.0, ""tester""); <line7> for (int i = 0; i < words.length; ++i) { <line8> cache.addToken(words[i]); <line9> cache.addWordToIndex(i, words[i].getLabel()); <line10> } <line11> String json = null; <line12> AbstractCache<VocabWord> unserialized = null; <line13> try { <line14> json = cache.toJson(); <line15> unserialized = AbstractCache.fromJson(json); <line16> } catch (Exception e) { <line17> fail(); <line18> } <line19> assertEquals(cache.totalWordOccurrences(), unserialized.totalWordOccurrences()); <line20> assertEquals(cache.totalNumberOfDocs(), unserialized.totalNumberOfDocs()); <line21> for (int i = 0; i < words.length; ++i) { <line22> val cached = cache.wordAtIndex(i); <line23> val restored = unserialized.wordAtIndex(i); <line24> assertNotNull(cached); <line25> assertEquals(cached, restored); <line26> } <line27> } <line28> } <line29> "	<line15>, <line17>
6911	public class A { <line0> private void sendEmail(RuleActionBean ruleAction, UserAccountBean ub, String body, String subject) <line1> throws OpenClinicaSystemException { <line2> try { <line3> getEmailEngine() <line4> .process( <line5> ((EmailActionBean) ruleAction).getTo().trim(), <line6> EmailEngine.getAdminEmail(), <line7> subject, <line8> body); <line9> } catch (MessagingException me) { <line10> throw new OpenClinicaSystemException(me.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line2>, <line9>, <line10>
6912	public class A { <line0> @Override <line1> public void operationComplete(ChannelFuture future) { <line2> if (!future.isSuccess()) { <line3> } <line4> } <line5> } <line6> 	<line3>
6913	public class A { <line0> public Charset getCharset() { <line1> if (hasCharsetName()) { <line2> try { <line3> if (Charset.isSupported(charsetName)) { <line4> return Charset.forName(charsetName); <line5> } <line6> } catch (Exception charsetEx) { <line7> } <line8> } <line9> return MllpComponent.getDefaultCharset(); <line10> } <line11> } <line12> 	<line6>, <line7>
6914	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> monitor(JgroupsProbeMonitorStartStage.this.run()); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	<line5>
6915	public class A { <line0> private void readLoop(ShardRecordsIterator shardRecordsIterator, RateLimitPolicy rateLimiter) { <line1> while (poolOpened.get()) { <line2> try { <line3> try { <line4> List<KinesisRecord> kinesisRecords = shardRecordsIterator.readNextBatch(); <line5> try { <line6> for (KinesisRecord kinesisRecord : kinesisRecords) { <line7> recordsQueue.put(kinesisRecord); <line8> numberOfRecordsInAQueueByShard.get(kinesisRecord.getShardId()).incrementAndGet(); <line9> } <line10> } finally { <line11> if (!Thread.currentThread().isInterrupted()) { <line12> rateLimiter.onSuccess(kinesisRecords); <line13> } <line14> } <line15> } catch (KinesisShardClosedException e) { <line16> waitUntilAllShardRecordsRead(shardRecordsIterator); <line17> readFromSuccessiveShards(shardRecordsIterator); <line18> break; <line19> } <line20> } catch (KinesisClientThrottledException e) { <line21> try { <line22> rateLimiter.onThrottle(e); <line23> } catch (InterruptedException ex) { <line24> Thread.currentThread().interrupt(); <line25> break; <line26> } <line27> } catch (TransientKinesisException e) { <line28> } catch (InterruptedException e) { <line29> Thread.currentThread().interrupt(); <line30> break; <line31> } catch (Throwable e) { <line32> } <line33> } <line34> } <line35> } <line36> 	<line16>, <line24>, <line28>, <line29>, <line32>, <line34>
6916	public class A { <line0> static Object invokeWithScopes( <line1> InvocationContext invocation, BeanManager beanManager, ContextControl ctxCtrl) <line2> throws Exception { <line3> boolean shouldStopSession = false; <line4> boolean shouldStopRequest = false; <line5> if (!isSessionScopeActive(beanManager)) { <line6> shouldStopSession = true; <line7> ctxCtrl.startContext(SessionScoped.class); <line8> } <line9> if (!isRequestScopeActive(beanManager)) { <line10> shouldStopRequest = true; <line11> ctxCtrl.startContext(RequestScoped.class); <line12> } <line13> try { <line14> return invocation.proceed(); <line15> } finally { <line16> if (shouldStopRequest) { <line17> ctxCtrl.stopContext(RequestScoped.class); <line18> } <line19> if (shouldStopSession) { <line20> ctxCtrl.stopContext(SessionScoped.class); <line21> } <line22> } <line23> } <line24> } <line25> 	<line7>, <line11>, <line18>, <line21>
6917	public class A { <line0> @Override <line1> public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall( <line2> MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) { <line3> ClientCall<ReqT, RespT> call = next.newCall(method, callOptions); <line4> call = <line5> new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(call) { <line6> @Override <line7> public void start(Listener<RespT> responseListener, Metadata headers) { <line8> if (apiKey != null && !apiKey.isEmpty()) { <line9> headers.put(API_KEY_HEADER, apiKey); <line10> } <line11> super.start(responseListener, headers); <line12> } <line13> }; <line14> return call; <line15> } <line16> } <line17> 	<line3>, <line9>
6918	public class A { <line0> private void setCertificateInfoArray(String certificateValue) { <line1> try { <line2> if (StringUtils.isNotBlank(certificateValue) && !certificateValue.equals(EMPTY_JSON_ARRAY)) { <line3> certificateValue = certificateValue.trim(); <line4> try { <line5> this.certificateInfoArray = handleJsonFormatCertificate(certificateValue); <line6> } catch (JSONException e) { <line7> if (certificateValue.startsWith(IdentityUtil.PEM_BEGIN_CERTFICATE)) { <line8> this.certificateInfoArray = handlePlainTextCertificate(certificateValue); <line9> } else { <line10> this.certificateInfoArray = handleEncodedCertificate(certificateValue); <line11> } <line12> } <line13> } else { <line14> this.certificateInfoArray = new CertificateInfo[0]; <line15> } <line16> } catch (NoSuchAlgorithmException e) { <line17> } <line18> } <line19> } <line20> 	<line17>
6919	"public class A { <line0> private boolean provisionFile( <line1> String input, <line2> String output, <line3> boolean skipIfMissing, <line4> ArrayList<FileMetadata> fileArray, <line5> boolean fullOutputPath, <line6> FileMetadata metadata) { <line7> BufferedInputStream reader; <line8> int bufLen = 5000 * 1024; <line9> for (FileMetadata fmd : fileArray) { <line10> if (fmd.getFilePath() != null && fmd.getFilePath().equals(filesUtil.getOriginalFileName())) { <line11> fmd.setFilePath(filesUtil.getFileName()); <line12> } <line13> } <line14> reader = filesUtil.getSourceReader(input, bufLen, 0L); <line15> if (reader == null) { <line16> metadata.setFilePath(""""); <line17> metadata.setMetaType(""""); <line18> if (skipIfMissing) { <line19> return true; <line20> } else { <line21> return false; <line22> } <line23> } <line24> Map<String, String> settings = ConfigTools.getSettings(); <line25> if (settings.containsKey(SqwKeys.SW_PROVISION_FILES_MD5.getSettingKey()) && metadata != null) { <line26> String value = settings.get(SqwKeys.SW_PROVISION_FILES_MD5.getSettingKey()); <line27> boolean usemd5 = Boolean.valueOf(value); <line28> if (usemd5) { <line29> ProvisionFilesUtil.calculateInputMetadata(input, metadata); <line30> } <line31> } else { <line32> ProvisionFilesUtil.calculateInputMetadata(input, metadata); <line33> } <line34> return putDestination(reader, output, bufLen, input, fileArray, fullOutputPath, metadata); <line35> } <line36> } <line37> "	<line10>, <line19>, <line21>
6920	"public class A { <line0> public void UPInterfaceLo() throws Exception { <line1> List<String> response = executeCommand(""chassis:up "" + resourceFriendlyID + "" lo0""); <line2> Assert.assertTrue(response.get(1).isEmpty()); <line3> List<String> response1 = executeCommand(""queue:execute "" + resourceFriendlyID); <line4> Assert.assertTrue(response1.get(1).isEmpty()); <line5> List<String> response2 = executeCommand(""chassis:showInterfaces "" + resourceFriendlyID); <line6> Assert.assertTrue(response2.get(1).isEmpty()); <line7> if (!isMock) { <line8> ComputerSystem system = (ComputerSystem) resource.getModel(); <line9> List<LogicalDevice> ld = system.getLogicalDevices(); <line10> for (LogicalDevice logicalDevice : ld) { <line11> if (logicalDevice instanceof LogicalPort && logicalDevice.getName().equals(""lo0.0"")) { <line12> LogicalPort logicalPort = (LogicalPort) logicalDevice; <line13> Assert.assertTrue(logicalPort.getOperationalStatus() == OperationalStatus.OK); <line14> } <line15> } <line16> } <line17> } <line18> } <line19> "	<line2>, <line4>, <line6>
6921	public class A { <line0> @Ignore <line1> @Test <line2> public void userAdminHasPermissionToAddModule() { <line3> User admin = userRepository.findOne(1L); <line4> Module module = moduleRepository.findOne(2L); <line5> Boolean hasPermission = <line6> securityService.hasUserPermissionToObject(admin, PermissionName.MODULE_ADD, module); <line7> assertTrue(hasPermission); <line8> } <line9> } <line10> 	<line3>
6922	"public class A { <line0> private Long getEthGasPrice() throws AplException.ExecutiveProcessException { <line1> Long gasPrice; <line2> try { <line3> gasPrice = dexEthService.getEthPriceInfo().getFastSpeedPrice(); <line4> } catch (ExecutionException e) { <line5> throw new AplException.ExecutiveProcessException( <line6> ""Third service is not available, try later.""); <line7> } <line8> if (gasPrice == null) { <line9> throw new AplException.ThirdServiceIsNotAvailable(""Eth Price Info is not available.""); <line10> } <line11> return gasPrice; <line12> } <line13> } <line14> "	<line5>
6923	public class A { <line0> private UserGroupInformation getUGI(ObserverContext<?> ctx) { <line1> UserGroupInformation ugi = null; <line2> User user = null; <line3> try { <line4> user = getActiveUser(ctx); <line5> ugi = UserGroupInformation.getLoginUser(); <line6> } catch (Exception e) { <line7> } <line8> if (ugi == null) { <line9> if (user != null) { <line10> ugi = user.getUGI(); <line11> } <line12> } <line13> return ugi; <line14> } <line15> } <line16> 	<line13>
6924	public class A { <line0> public DefaultSessionPool withMinIdle(final int count) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> pool.setMinIdle(count); <line4> return this; <line5> } <line6> } <line7> 	<line2>
6925	public class A { <line0> public static com.liferay.commerce.discount.model.CommerceDiscountAccountRelSoap[] <line1> getCommerceDiscountAccountRels( <line2> long commerceDiscountId, <line3> int start, <line4> int end, <line5> com.liferay.portal.kernel.util.OrderByComparator< <line6> com.liferay.commerce.discount.model.CommerceDiscountAccountRel> <line7> orderByComparator) <line8> throws RemoteException { <line9> try { <line10> java.util.List<com.liferay.commerce.discount.model.CommerceDiscountAccountRel> returnValue = <line11> CommerceDiscountAccountRelServiceUtil.getCommerceDiscountAccountRels( <line12> commerceDiscountId, start, end, orderByComparator); <line13> return com.liferay.commerce.discount.model.CommerceDiscountAccountRelSoap.toSoapModels( <line14> returnValue); <line15> } catch (Exception exception) { <line16> throw new RemoteException(exception.getMessage()); <line17> } <line18> } <line19> } <line20> 	<line16>
6926	"public class A { <line0> public static KylinConfig getInstanceFromEnv(boolean allowConfigFileNoExist) { <line1> synchronized (KylinConfig.class) { <line2> KylinConfig config = THREAD_ENV_INSTANCE.get(); <line3> if (config != null) { <line4> return config; <line5> } <line6> if (SYS_ENV_INSTANCE == null) { <line7> try { <line8> buildDefaultOrderedProperties(); <line9> config = new KylinConfig(); <line10> try { <line11> config.reloadKylinConfig(buildSiteProperties()); <line12> } catch (KylinConfigCannotInitException e) { <line13> if (!allowConfigFileNoExist) { <line14> throw e; <line15> } <line16> } <line17> VersionUtil.loadKylinVersion(); <line18> SYS_ENV_INSTANCE = config; <line19> } catch (IllegalArgumentException e) { <line20> throw new IllegalStateException(""Failed to find KylinConfig "", e); <line21> } <line22> } <line23> return SYS_ENV_INSTANCE; <line24> } <line25> } <line26> } <line27> "	<line13>, <line18>
6927	public class A { <line0> public void handleError( <line1> Map<String, Object> params, <line2> Map<String, Object> metadata, <line3> Task task, <line4> TaskHandlerException e, <line5> Long activityId) { <line6> activityService.addFailedExecution(activityId, e); <line7> task.incrementFailuresInRow(); <line8> int failureNumber = task.getFailuresInRow(); <line9> int possibleErrorsNumber = getPossibleErrorsNumber(); <line10> if (possibleErrorsNumber != 0 && failureNumber >= possibleErrorsNumber) { <line11> task.setEnabled(false); <line12> activityService.addTaskDisabledWarning(task); <line13> publishTaskDisabledMessage(task.getName()); <line14> } <line15> taskService.save(task); <line16> Map<String, Object> errorParam = new HashMap<>(); <line17> errorParam.put(TASK_FAIL_MESSAGE, e.getMessage()); <line18> errorParam.put(TASK_FAIL_STACK_TRACE, ExceptionUtils.getStackTrace(e)); <line19> errorParam.put(TASK_FAIL_FAILURE_DATE, DateTime.now()); <line20> errorParam.put(TASK_FAIL_FAILURE_NUMBER, failureNumber); <line21> errorParam.put(TASK_FAIL_TRIGGER_DISABLED, task.isEnabled()); <line22> errorParam.put(TASK_FAIL_TASK_ID, task.getId()); <line23> errorParam.put(TASK_FAIL_TASK_NAME, task.getName()); <line24> Map<String, Object> errorEventParam = new HashMap<>(); <line25> errorEventParam.putAll(params); <line26> errorEventParam.put(HANDLER_ERROR_PARAM, errorParam); <line27> eventRelay.sendEventMessage( <line28> new MotechEvent( <line29> createHandlerFailureSubject(task.getName(), e.getFailureCause()), errorEventParam)); <line30> int numberOfRetries = getRetriesFromSettings(task, params); <line31> if (shouldScheduleRetry(params, numberOfRetries)) { <line32> retryHandler.handleTaskRetries(task, params); <line33> } <line34> } <line35> } <line36> 	<line6>, <line8>
6928	"public class A { <line0> protected void setupControlTemplate() { <line1> final DfLittleAdjustmentProperties littleProp = getLittleAdjustmentProperties(); <line2> final String title; <line3> final String controlPath; <line4> if (littleProp.isAlternateSql2EntityControlValid()) { <line5> title = ""alternate control""; <line6> controlPath = littleProp.getAlternateSql2EntityControl(); <line7> } else { <line8> final DfLanguageDependency lang = getBasicProperties().getLanguageDependency(); <line9> title = lang.getLanguageTitle(); <line10> controlPath = lang.getSql2EntityControl(); <line11> } <line12> setControlTemplate(controlPath); <line13> } <line14> } <line15> "	<line12>
6929	"public class A { <line0> private int merge(int partition1, int partition2) { <line1> IndexOnDisk src1 = IndexOnDisk.createIndex(index.path, index.prefix + ""-"" + partition1); <line2> IndexOnDisk src2 = IndexOnDisk.createIndex(index.path, index.prefix + ""-"" + partition2); <line3> IndexOnDisk indexD = <line4> IndexOnDisk.createNewIndex(index.path, index.prefix + ""-"" + index.prefixID); <line5> StructureMerger merger = new StructureMerger(src1, src2, indexD); <line6> merger.mergeStructures(); <line7> index.prefixID++; <line8> merged.add(partition1); <line9> merged.add(partition2); <line10> purgeMerged(); <line11> synchronized (indices) { <line12> } <line13> return index.prefixID - 1; <line14> } <line15> } <line16> "	<line7>
6930	"public class A { <line0> @Test <line1> public void givenCertifValidThenReturnOK() { <line2> final SecureClientConfiguration configuration = <line3> changeConfigurationFile(INGEST_EXTERNAL_CLIENT_CONF); <line4> configuration.setServerPort(vitamServerTestRunner.getBusinessPort()); <line5> final VitamClientFactory<DefaultClient> factory = <line6> new VitamClientFactory<DefaultClient>(configuration, BASE_URI) { <line7> @Override <line8> public DefaultClient getClient() { <line9> return new DefaultClient(this); <line10> } <line11> }; <line12> try (final DefaultClient client = factory.getClient()) { <line13> client.checkStatus(); <line14> } catch (final VitamException e) { <line15> fail(""THIS SHOULD NOT RAIZED AN EXCEPTION""); <line16> } finally { <line17> try { <line18> factory.shutdown(); <line19> } catch (Exception e) { <line20> SysErrLogger.FAKE_LOGGER.ignoreLog(e); <line21> } <line22> } <line23> } <line24> } <line25> "	<line12>, <line15>
6931	public class A { <line0> public void actionPerformed(ActionEvent event) { <line1> if (jTable.getSelectedRow() < 0) { <line2> } else { <line3> selectedrow = jTable.getSelectedRow(); <line4> deliveryType = (DeliveryType) (model.getValueAt(selectedrow, -1)); <line5> DeliveryTypeBrowserEdit newrecord = new DeliveryTypeBrowserEdit(myFrame, deliveryType, false); <line6> newrecord.addDeliveryTypeListener(DeliveryTypeBrowser.this); <line7> newrecord.setVisible(true); <line8> } <line9> } <line10> } <line11> 	<line2>
6932	public class A { <line0> public void run() throws IOException, RocksDBException { <line1> if (indexingNeeded) { <line2> int recordCounter = 0; <line3> List<Variant> variantList = variantReader.read(); <line4> while (!variantList.isEmpty()) { <line5> try { <line6> updateIndex(variantList); <line7> } catch (IOException | RocksDBException e) { <line8> e.printStackTrace(); <line9> throw e; <line10> } catch (Exception e) { <line11> if (recordCounter >= 0 && variantList != null) { <line12> } else { <line13> } <line14> throw e; <line15> } <line16> recordCounter++; <line17> if (recordCounter % 100000 == 0) { <line18> } <line19> variantList = variantReader.read(); <line20> } <line21> } else { <line22> } <line23> } <line24> } <line25> 	<line12>, <line13>, <line18>, <line22>
6933	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> batchSizeCalculator.startTiming( <line4> System.currentTimeMillis(), batchSizeCalculator.currentBatchSize()); <line5> try { <line6> processor.processDelayedTxs(batchSizeCalculator.currentBatchSize()); <line7> } catch (Exception e) { <line8> } finally { <line9> batchSizeCalculator.stopTiming(System.currentTimeMillis()); <line10> } <line11> } catch (Throwable t) { <line12> t.printStackTrace(); <line13> System.exit(1); <line14> } <line15> } <line16> } <line17> 	<line8>, <line12>
6934	public class A { <line0> protected Queue<Exchange> createExchanges(List<Blob> blobList) { <line1> if (LOG.isTraceEnabled()) { <line2> } <line3> Queue<Exchange> answer = new LinkedList<>(); <line4> try { <line5> for (Blob blob : blobList) { <line6> if (includeObject(blob)) { <line7> Exchange exchange = createExchange(blob, blob.getBlobId().getName()); <line8> answer.add(exchange); <line9> } <line10> } <line11> } catch (Exception e) { <line12> throw e; <line13> } <line14> return answer; <line15> } <line16> } <line17> 	<line2>, <line12>
6935	"public class A { <line0> @Override <line1> public ConsumerRecordVO getConsumer(String clientId) { <line2> Connection conn = null; <line3> ConsumerRecordVO consumer = null; <line4> PreparedStatement stat = null; <line5> ResultSet res = null; <line6> try { <line7> conn = this.getConnection(); <line8> String query = SELECT_CONSUMER; <line9> stat = conn.prepareStatement(query); <line10> stat.setString(1, clientId); <line11> res = stat.executeQuery(); <line12> if (res.next()) { <line13> consumer = consumerFromResultSet(res); <line14> } <line15> } catch (SQLException | ApsSystemException t) { <line16> throw new RuntimeException(""Error while loading consumer by key "" + clientId, t); <line17> } finally { <line18> closeDaoResources(res, stat, conn); <line19> } <line20> return consumer; <line21> } <line22> } <line23> "	<line16>
6936	"public class A { <line0> @Override <line1> public List<CollectionAndDataObjectListingEntry> listAllDataObjectsAndCollectionsUnderPath( <line2> final String irodsAbsolutePath) throws FileNotFoundException, JargonException { <line3> if (irodsAbsolutePath == null || irodsAbsolutePath.isEmpty()) { <line4> throw new IllegalArgumentException(""irodsAbsolutePath is null or empty""); <line5> } <line6> ObjStat objStat; <line7> try { <line8> objStat = retrieveObjectStatForPath(irodsAbsolutePath); <line9> } catch (final FileNotFoundException fnf) { <line10> return collectionListingUtils.handleNoListingUnderRootOrHome(irodsAbsolutePath); <line11> } <line12> MiscIRODSUtils.evaluateSpecCollSupport(objStat); <line13> final CollectionListingUtils collectionListingUtils = <line14> new CollectionListingUtils(getIRODSAccount(), getIRODSAccessObjectFactory()); <line15> final List<CollectionAndDataObjectListingEntry> entries = new ArrayList<>(); <line16> try { <line17> entries.addAll(collectionListingUtils.listAllCollectionsUnderPath(objStat, 0)); <line18> } catch (DataNotFoundException dnf) { <line19> log.warn(""overhead of data not found and possible continuation flag error in iRODS"", dnf); <line20> } <line21> try { <line22> entries.addAll(collectionListingUtils.listAllDataObjectsUnderPath(objStat, 0)); <line23> } catch (DataNotFoundException dnf) { <line24> } <line25> return entries; <line26> } <line27> } <line28> "	<line3>, <line6>, <line10>, <line24>
6937	public class A { <line0> @Override <line1> public void updateIndex(Collection<Bill> bills) { <line2> if (!env.isElasticIndexing() || bills.isEmpty()) { <line3> return; <line4> } <line5> List<Bill> indexableBills = new ArrayList<>(); <line6> List<Bill> nonIndexableBills = new ArrayList<>(); <line7> for (Bill bill : bills) { <line8> if (isBillIndexable(bill)) { <line9> indexableBills.add(bill); <line10> } else { <line11> nonIndexableBills.add(bill); <line12> } <line13> } <line14> billSearchDao.updateBillIndex(indexableBills); <line15> nonIndexableBills.stream().map(Bill::getBaseBillId).forEach(billSearchDao::deleteBillFromIndex); <line16> } <line17> } <line18> 	<line14>
6938	"public class A { <line0> @Override <line1> public void process(final OutputStream rawOut) throws IOException { <line2> try (final OutputStream bufferedOut = new BufferedOutputStream(rawOut); <line3> final ZipOutputStream out = new ZipOutputStream(bufferedOut)) { <line4> out.setLevel(compressionLevel); <line5> for (final FlowFile flowFile : contents) { <line6> final String path = keepPath ? getPath(flowFile) : """"; <line7> final String entryName = path + flowFile.getAttribute(CoreAttributes.FILENAME.key()); <line8> final ZipEntry zipEntry = new ZipEntry(entryName); <line9> zipEntry.setSize(flowFile.getSize()); <line10> try { <line11> out.putNextEntry(zipEntry); <line12> bin.getSession().exportTo(flowFile, out); <line13> out.closeEntry(); <line14> unmerged.remove(flowFile); <line15> } catch (ZipException e) { <line16> } <line17> } <line18> out.finish(); <line19> out.flush(); <line20> } <line21> } <line22> } <line23> "	<line16>
6939	public class A { <line0> private void deleteExpiredFromAllRegisteredRegions() { <line1> for (final Iterator<JDBCDiskCache<?, ?>> i = shrinkSet.iterator(); i.hasNext(); ) { <line2> final JDBCDiskCache<?, ?> cache = i.next(); <line3> final ElapsedTimer timer = new ElapsedTimer(); <line4> final int deleted = cache.deleteExpired(); <line5> if (i.hasNext()) { <line6> try { <line7> Thread.sleep(this.getPauseBetweenRegionCallsMillis()); <line8> } catch (final InterruptedException e) { <line9> } <line10> } <line11> } <line12> } <line13> } <line14> 	<line1>, <line5>, <line6>, <line9>
6940	"public class A { <line0> @Override <line1> public void delete(String... identifiers) throws SecurityManagementException { <line2> if (identifiers == null) { <line3> throw new NullPointerException(); <line4> } <line5> try { <line6> Set<Object> keysToRemove = new HashSet<>(groupsPropertiesFileLoader.getProperties().keySet()); <line7> keysToRemove.forEach( <line8> key -> { <line9> final String username = (String) key; <line10> try { <line11> final String groupsStr = <line12> groupsPropertiesFileLoader.getProperties().getProperty(username); <line13> if (groupsStr != null && groupsStr.trim().length() > 0) { <line14> final String newGroupsStr = deleteGroupsFromSerliazedValue(groupsStr, identifiers); <line15> final String errorMsg = ""Error deleting groups for user "" + username; <line16> updateGroupProperty(username, newGroupsStr, errorMsg); <line17> } <line18> } catch (final IOException e) { <line19> throw new SecurityManagementException(e); <line20> } <line21> }); <line22> } catch (Exception e) { <line23> throw new SecurityManagementException(e); <line24> } <line25> } <line26> } <line27> "	<line23>
6941	public class A { <line0> public Optional<LoadBalancer> getLoadBalancer(String loadBalancer) { <line1> DescribeLoadBalancersRequest request = <line2> new DescribeLoadBalancersRequest().withNames(loadBalancer); <line3> try { <line4> List<LoadBalancer> maybeLoadBalancer = <line5> elbClient.describeLoadBalancers(request).getLoadBalancers(); <line6> if (maybeLoadBalancer.size() > 0) { <line7> return Optional.of(maybeLoadBalancer.get(0)); <line8> } else { <line9> return Optional.absent(); <line10> } <line11> } catch (LoadBalancerNotFoundException notFound) { <line12> return Optional.absent(); <line13> } <line14> } <line15> } <line16> 	<line12>
6942	"public class A { <line0> @Override <line1> public void listenToTimebase(boolean listen) { <line2> if (!listen && timeListener == null) { <line3> return; <line4> } <line5> if (timeListener == null) { <line6> timeListener = <line7> evt -> { <line8> try { <line9> if (evt.getPropertyName().equals(""minutes"")) { <line10> checkAlarmList(); <line11> } <line12> } catch (IOException ex) { <line13> timebase.removeMinuteChangeListener(timeListener); <line14> } <line15> }; <line16> } <line17> if (listen) { <line18> timebase.addMinuteChangeListener(timeListener); <line19> } else { <line20> timebase.removeMinuteChangeListener(timeListener); <line21> } <line22> } <line23> } <line24> "	<line13>
6943	"public class A { <line0> @SuppressWarnings(""squid:S1181"") <line1> @Override <line2> public void abortTransaction(MetadataTransactionContext ctx) { <line3> try { <line4> metadataNode.abortTransaction(ctx.getTxnId()); <line5> } catch (Throwable th) { <line6> ExitUtil.halt(ExitUtil.EC_FAILED_TO_ABORT_METADATA_TXN); <line7> } <line8> } <line9> } <line10> "	<line6>
6944	public class A { <line0> @Override <line1> public void onConnectionFailure(final ProviderException ex) { <line2> providerFailed(ex); <line3> for (JmsSession session : sessions.values()) { <line4> try { <line5> session.onConnectionInterrupted(); <line6> } catch (Throwable t) { <line7> } <line8> } <line9> onProviderException(ex); <line10> for (AsyncResult request : requests.keySet()) { <line11> try { <line12> request.onFailure(ex); <line13> } catch (Exception e) { <line14> } <line15> } <line16> if (!closing.get() && !closed.get()) { <line17> executor.execute( <line18> new Runnable() { <line19> @Override <line20> public void run() { <line21> if (provider != null) { <line22> try { <line23> provider.close(); <line24> } catch (Throwable error) { <line25> } <line26> } <line27> for (AsyncResult request : requests.keySet()) { <line28> try { <line29> request.onFailure(ex); <line30> } catch (Exception e) { <line31> } <line32> } <line33> try { <line34> shutdown(ex); <line35> } catch (JMSException e) { <line36> } <line37> for (JmsConnectionListener listener : connectionListeners) { <line38> listener.onConnectionFailure(ex); <line39> } <line40> executor.shutdown(); <line41> } <line42> }); <line43> } <line44> } <line45> } <line46> 	<line3>, <line7>, <line14>, <line25>, <line31>, <line36>
6945	"public class A { <line0> public void runMigration( <line1> String version, <line2> Set<Migration.MigrationDomain> domainsFilter, <line3> Set<Migration.MigrationLanguage> languageFilter, <line4> String appHome, <line5> ObjectMap params, <line6> String token) <line7> throws CatalogException { <line8> validateAdmin(token); <line9> token = catalogManager.getUserManager().getNonExpiringToken(AbstractManager.OPENCGA, token); <line10> Set<Class<? extends MigrationTool>> availableMigrations = getAvailableMigrations(); <line11> List<Class<? extends MigrationTool>> runnableMigrations = <line12> filterRunnableMigrations(version, domainsFilter, languageFilter, availableMigrations); <line13> List<Class<? extends MigrationTool>> pendingMigrations = <line14> filterPendingMigrations(version, availableMigrations); <line15> if (runnableMigrations.isEmpty() && pendingMigrations.isEmpty()) { <line16> return; <line17> } <line18> for (Class<? extends MigrationTool> migration : pendingMigrations) { <line19> Migration annotation = getMigrationAnnotation(migration); <line20> if (annotation.manual()) { <line21> throw new MigrationException( <line22> ""Missing previous migration '"" <line23> + annotation.id() <line24> + ""' from version '"" <line25> + annotation.version() <line26> + ""'. Please, run this migration manually using the CLI.""); <line27> } <line28> } <line29> for (Class<? extends MigrationTool> migration : pendingMigrations) { <line30> run(migration, appHome, new ObjectMap(), token); <line31> } <line32> for (Class<? extends MigrationTool> migration : runnableMigrations) { <line33> run(migration, appHome, params, token); <line34> } <line35> } <line36> } <line37> "	<line16>
6946	"public class A { <line0> @Test <line1> public void testTransformMetacard() throws Exception { <line2> MockEndpoint mock = getMockEndpoint(""mock:result""); <line3> mock.expectedMinimumMessageCount(1); <line4> InputTransformer mockTransformer = getMockInputTransformer(); <line5> Hashtable<String, String> props = new Hashtable<String, String>(); <line6> props.put(MimeTypeToTransformerMapper.ID_KEY, ""xml""); <line7> props.put(MimeTypeToTransformerMapper.MIME_TYPE_KEY, ""text/xml""); <line8> bundleContext.registerService(InputTransformer.class.getName(), mockTransformer, props); <line9> MimeTypeToTransformerMapper matchingService = mock(MimeTypeToTransformerMapper.class); <line10> catalogComponent.setMimeTypeToTransformerMapper(matchingService); <line11> when(matchingService.findMatches(eq(InputTransformer.class), isA(MimeType.class))) <line12> .thenReturn((List) Arrays.asList(mockTransformer)); <line13> InputStream input = IOUtils.toInputStream(xmlInput); <line14> InputTransformer transformer = getTransformer(""text/xml"", ""identity""); <line15> assertNotNull(""InputTransformer for mimeType=text/xml&id=identity not found"", transformer); <line16> Metacard metacard = transformer.transform(input); <line17> assertNotNull(metacard); <line18> assertMockEndpointsSatisfied(); <line19> } <line20> } <line21> "	<line2>
6947	public class A { <line0> private DeviceData getDeviceata(String data) { <line1> ObjectMapper mapper = new ObjectMapper(); <line2> DeviceData obj = null; <line3> try { <line4> obj = mapper.readValue(data, DeviceData.class); <line5> } catch (IOException e) { <line6> } <line7> return obj; <line8> } <line9> } <line10> 	<line6>
6948	public class A { <line0> public static Integer getSQLProcessId(long processId) { <line1> for (SQLSession sqlSession : sqlSessionMap.keySet()) { <line2> ExConnection connection = sqlSession.getDebugConnection(); <line3> if (connection != null) { <line4> Thread activeThread = sqlSession.getActiveThread(); <line5> if (activeThread != null && activeThread.getId() == processId) <line6> return ((PGConnection) connection.sql).getBackendPID(); <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	<line9>
6949	"public class A { <line0> SqlAndIncludedColumns generateUpsert( <line1> final RecordSchema recordSchema, <line2> final String tableName, <line3> final String updateKeys, <line4> final TableSchema tableSchema, <line5> final DMLSettings settings) <line6> throws IllegalArgumentException, SQLException, MalformedRecordException { <line7> checkValuesForRequiredColumns(recordSchema, tableSchema, settings); <line8> Set<String> keyColumnNames = getUpdateKeyColumnNames(tableName, updateKeys, tableSchema); <line9> Set<String> normalizedKeyColumnNames = <line10> normalizeKeyColumnNamesAndCheckForValues( <line11> recordSchema, <line12> updateKeys, <line13> settings, <line14> keyColumnNames, <line15> tableSchema.getQuotedIdentifierString()); <line16> List<String> usedColumnNames = new ArrayList<>(); <line17> List<Integer> usedColumnIndices = new ArrayList<>(); <line18> List<String> fieldNames = recordSchema.getFieldNames(); <line19> if (fieldNames != null) { <line20> int fieldCount = fieldNames.size(); <line21> for (int i = 0; i < fieldCount; i++) { <line22> RecordField field = recordSchema.getField(i); <line23> String fieldName = field.getFieldName(); <line24> final ColumnDescription desc = <line25> tableSchema <line26> .getColumns() <line27> .get(normalizeColumnName(fieldName, settings.translateFieldNames)); <line28> if (desc == null && !settings.ignoreUnmappedFields) { <line29> throw new SQLDataException( <line30> ""Cannot map field '"" <line31> + fieldName <line32> + ""' to any column in the database\n"" <line33> + (settings.translateFieldNames ? ""Normalized "" : """") <line34> + ""Columns: "" <line35> + String.join("","", tableSchema.getColumns().keySet())); <line36> } <line37> if (desc != null) { <line38> if (settings.escapeColumnNames) { <line39> usedColumnNames.add( <line40> tableSchema.getQuotedIdentifierString() <line41> + desc.getColumnName() <line42> + tableSchema.getQuotedIdentifierString()); <line43> } else { <line44> usedColumnNames.add(desc.getColumnName()); <line45> } <line46> usedColumnIndices.add(i); <line47> } else { <line48> getLogger() <line49> } <line50> } <line51> } <line52> String sql = <line53> databaseAdapter.getUpsertStatement(tableName, usedColumnNames, normalizedKeyColumnNames); <line54> return new SqlAndIncludedColumns(sql, usedColumnIndices); <line55> } <line56> } <line57> "	<line49>
6950	public class A { <line0> public static XSSFWorkbook loadDocument(InputStream is) { <line1> XSSFWorkbook workbook = null; <line2> try { <line3> workbook = new XSSFWorkbook(is); <line4> } catch (IOException e) { <line5> return null; <line6> } <line7> return workbook; <line8> } <line9> } <line10> 	<line5>
6951	public class A { <line0> public void expand() { <line1> MCTSPlayer player = (MCTSPlayer) game.getPlayer(playerId); <line2> if (player.getNextAction() == null) { <line3> } <line4> switch (player.getNextAction()) { <line5> case PRIORITY: <line6> List<Ability> abilities; <line7> if (!USE_ACTION_CACHE) abilities = player.getPlayableOptions(game); <line8> else abilities = getPlayables(player, fullStateValue, game); <line9> for (Ability ability : abilities) { <line10> Game sim = game.copy(); <line11> MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId()); <line12> simPlayer.activateAbility((ActivatedAbility) ability, sim); <line13> sim.resume(); <line14> children.add(new MCTSNode(this, sim, ability)); <line15> } <line16> break; <line17> case SELECT_ATTACKERS: <line18> List<List<UUID>> attacks; <line19> if (!USE_ACTION_CACHE) attacks = player.getAttacks(game); <line20> else attacks = getAttacks(player, fullStateValue, game); <line21> UUID defenderId = game.getOpponents(player.getId()).iterator().next(); <line22> for (List<UUID> attack : attacks) { <line23> Game sim = game.copy(); <line24> MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId()); <line25> for (UUID attackerId : attack) { <line26> simPlayer.declareAttacker(attackerId, defenderId, sim, false); <line27> } <line28> sim.resume(); <line29> children.add(new MCTSNode(this, sim, sim.getCombat())); <line30> } <line31> break; <line32> case SELECT_BLOCKERS: <line33> List<List<List<UUID>>> blocks; <line34> if (!USE_ACTION_CACHE) blocks = player.getBlocks(game); <line35> else blocks = getBlocks(player, fullStateValue, game); <line36> for (List<List<UUID>> block : blocks) { <line37> Game sim = game.copy(); <line38> MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId()); <line39> List<CombatGroup> groups = sim.getCombat().getGroups(); <line40> for (int i = 0; i < groups.size(); i++) { <line41> if (i < block.size()) { <line42> for (UUID blockerId : block.get(i)) { <line43> simPlayer.declareBlocker( <line44> simPlayer.getId(), blockerId, groups.get(i).getAttackers().get(0), sim); <line45> } <line46> } <line47> } <line48> sim.resume(); <line49> children.add(new MCTSNode(this, sim, sim.getCombat())); <line50> } <line51> break; <line52> } <line53> game = null; <line54> } <line55> } <line56> 	<line3>
6952	"public class A { <line0> private static void handleRetrievalRequest( <line1> HttpServletRequest request, HttpServletResponse response, Database db) { <line2> try { <line3> PrintWriter out = response.getWriter(); <line4> try { <line5> if (request.getPathInfo().equals(""/find"") || request.getPathInfo().equals(""/count"")) { <line6> showSelectEntityDialog(out, db); <line7> return; <line8> } <line9> String entityName = request.getPathInfo().substring(""/find/"".length()); <line10> if (request.getPathInfo().startsWith(""/count/"")) <line11> entityName = request.getPathInfo().substring(""/count/"".length()); <line12> Entity entity = (Entity) Class.forName(entityName).newInstance(); <line13> if (request.getQueryString() != null <line14> && request.getQueryString().equals(""__showQueryDialogue=true"")) { <line15> showSelectFilterDialogForEntity(entity, out, db); <line16> return; <line17> } <line18> List<QueryRule> rulesList = createQueryRulesFromRequest(request); <line19> if (request.getPathInfo().startsWith(""/count/"")) { <line20> if (rulesList != null) <line21> db.count( <line22> getClassForName(entityName), rulesList.toArray(new QueryRule[rulesList.size()])); <line23> else { <line24> out.println(db.count(getClassForName(entityName))); <line25> } <line26> } else { <line27> TupleWriter csvWriter = new CsvWriter(out); <line28> try { <line29> if (rulesList != null) <line30> db.find( <line31> getClassForName(entityName), <line32> csvWriter, <line33> rulesList.toArray(new QueryRule[rulesList.size()])); <line34> else { <line35> db.find(getClassForName(entityName), csvWriter); <line36> } <line37> } finally { <line38> csvWriter.close(); <line39> } <line40> } <line41> } catch (Exception e) { <line42> out.println(e + ""<br>""); <line43> e.printStackTrace(); <line44> throw e; <line45> } finally { <line46> db.close(); <line47> } <line48> out.close(); <line49> } catch (Exception e) { <line50> } <line51> } <line52> } <line53> "	<line50>
6953	"public class A { <line0> @Test <line1> public void testPersistenceEvents() { <line2> KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(); <line3> kbuilder.add(new ClassPathResource(""EventsProcess.rf""), ResourceType.DRF); <line4> InternalKnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase(); <line5> kbase.addPackages(kbuilder.getKnowledgePackages()); <line6> StatefulKnowledgeSession ksession = <line7> InfinispanKnowledgeService.newStatefulKnowledgeSession(kbase, null, env); <line8> long id = ksession.getIdentifier(); <line9> ProcessInstance processInstance = ksession.startProcess(""org.drools.test.TestProcess""); <line10> TestWorkItemHandler handler = TestWorkItemHandler.getInstance(); <line11> WorkItem workItem = handler.getWorkItem(); <line12> assertNotNull(workItem); <line13> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line14> processInstance = ksession.getProcessInstance(processInstance.getId()); <line15> assertNotNull(processInstance); <line16> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line17> ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null); <line18> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line19> processInstance = ksession.getProcessInstance(processInstance.getId()); <line20> assertNotNull(processInstance); <line21> ksession.signalEvent(""MyEvent1"", null, processInstance.getId()); <line22> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line23> processInstance = ksession.getProcessInstance(processInstance.getId()); <line24> assertNotNull(processInstance); <line25> ksession.signalEvent(""MyEvent2"", null, processInstance.getId()); <line26> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line27> processInstance = ksession.getProcessInstance(processInstance.getId()); <line28> assertNull(processInstance); <line29> } <line30> } <line31> "	<line10>
6954	public class A { <line0> private void enqueueMessage(final WebSocketMessage incomingMessage) { <line1> final ProcessSession session = processSessionFactory.createSession(); <line2> try { <line3> FlowFile messageFlowFile = session.create(); <line4> final Map<String, String> attrs = new HashMap<>(); <line5> attrs.put(ATTR_WS_CS_ID, webSocketService.getIdentifier()); <line6> final WebSocketSessionInfo sessionInfo = incomingMessage.getSessionInfo(); <line7> attrs.put(ATTR_WS_SESSION_ID, sessionInfo.getSessionId()); <line8> attrs.put(ATTR_WS_ENDPOINT_ID, endpointId); <line9> attrs.put(ATTR_WS_LOCAL_ADDRESS, sessionInfo.getLocalAddress().toString()); <line10> attrs.put(ATTR_WS_REMOTE_ADDRESS, sessionInfo.getRemoteAddress().toString()); <line11> final WebSocketMessage.Type messageType = incomingMessage.getType(); <line12> if (messageType != null) { <line13> attrs.put(ATTR_WS_MESSAGE_TYPE, messageType.name()); <line14> } <line15> messageFlowFile = session.putAllAttributes(messageFlowFile, attrs); <line16> final byte[] payload = incomingMessage.getPayload(); <line17> if (payload != null) { <line18> messageFlowFile = <line19> session.write( <line20> messageFlowFile, <line21> out -> { <line22> out.write(payload, incomingMessage.getOffset(), incomingMessage.getLength()); <line23> }); <line24> } <line25> session.getProvenanceReporter().receive(messageFlowFile, getTransitUri(sessionInfo)); <line26> if (incomingMessage instanceof WebSocketConnectedMessage) { <line27> session.transfer(messageFlowFile, REL_CONNECTED); <line28> } else { <line29> switch (messageType) { <line30> case TEXT: <line31> session.transfer(messageFlowFile, REL_MESSAGE_TEXT); <line32> break; <line33> case BINARY: <line34> session.transfer(messageFlowFile, REL_MESSAGE_BINARY); <line35> break; <line36> } <line37> } <line38> session.commitAsync(); <line39> } catch (Exception e) { <line40> session.rollback(); <line41> } <line42> } <line43> } <line44> 	<line40>
6955	public class A { <line0> @Override <line1> public Role update(final Role toBeUpdated, final RoleTO roleTO) { <line2> toBeUpdated.setKey(roleTO.getKey()); <line3> Role role = roleDAO.save(toBeUpdated); <line4> role.getEntitlements().clear(); <line5> role.getEntitlements().addAll(roleTO.getEntitlements()); <line6> role.getRealms().clear(); <line7> for (String realmFullPath : roleTO.getRealms()) { <line8> Realm realm = realmDAO.findByFullPath(realmFullPath); <line9> if (realm == null) { <line10> } else { <line11> role.add(realm); <line12> } <line13> } <line14> role.getDynRealms().clear(); <line15> for (String key : roleTO.getDynRealms()) { <line16> DynRealm dynRealm = dynRealmDAO.find(key); <line17> if (dynRealm == null) { <line18> } else { <line19> role.add(dynRealm); <line20> } <line21> } <line22> role = roleDAO.save(role); <line23> roleDAO.clearDynMembers(role); <line24> if (role.getKey() == null && roleTO.getDynMembershipCond() != null) { <line25> setDynMembership(role, roleTO.getDynMembershipCond()); <line26> } else if (role.getDynMembership() != null && roleTO.getDynMembershipCond() == null) { <line27> role.setDynMembership(null); <line28> } else if (role.getDynMembership() == null && roleTO.getDynMembershipCond() != null) { <line29> setDynMembership(role, roleTO.getDynMembershipCond()); <line30> } else if (role.getDynMembership() != null <line31> && roleTO.getDynMembershipCond() != null <line32> && !role.getDynMembership().getFIQLCond().equals(roleTO.getDynMembershipCond())) { <line33> setDynMembership(role, roleTO.getDynMembershipCond()); <line34> } <line35> role.getPrivileges().clear(); <line36> for (String key : roleTO.getPrivileges()) { <line37> Privilege privilege = applicationDAO.findPrivilege(key); <line38> if (privilege == null) { <line39> } else { <line40> role.add(privilege); <line41> } <line42> } <line43> return roleDAO.saveAndRefreshDynMemberships(role); <line44> } <line45> } <line46> 	<line10>, <line18>, <line39>
6956	public class A { <line0> @Override <line1> public boolean showControls( <line2> HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { <line3> CommerceOrder commerceOrder = <line4> (CommerceOrder) httpServletRequest.getAttribute(CommerceCheckoutWebKeys.COMMERCE_ORDER); <line5> if (!commerceOrder.isOpen()) { <line6> return false; <line7> } <line8> try { <line9> ThemeDisplay themeDisplay = <line10> (ThemeDisplay) httpServletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line11> return _commerceOrderValidatorRegistry.isValid(themeDisplay.getLocale(), commerceOrder); <line12> } catch (PortalException portalException) { <line13> return false; <line14> } <line15> } <line16> } <line17> 	<line13>
6957	"public class A { <line0> @Override <line1> public void push(byte[] message, int offset, int length) { <line2> if (connection.isOpen()) { <line3> Args.notNull(message, ""message""); <line4> try { <line5> connection.sendMessage(message, offset, length); <line6> } catch (IOException iox) { <line7> } <line8> } else { <line9> } <line10> } <line11> } <line12> "	<line7>, <line9>
6958	"public class A { <line0> private static void actionCopyLogToClipboard(ActionEvent aEvent) { <line1> try { <line2> StringSelection stringSelection = new StringSelection(getLog()); <line3> Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); <line4> clipboard.setContents(stringSelection, null); <line5> } catch (Exception e) { <line6> showMessageDialog(null, ""Unable to copy log to clipboard: "" + getRootCauseMessage(e)); <line7> } <line8> } <line9> } <line10> "	<line6>
6959	public class A { <line0> private void unregisterTaskInScheduler(final JobKey key) throws SchedulerException { <line1> quartzScheduler.interrupt(key); <line2> final boolean removed = quartzScheduler.deleteJob(key); <line3> if (removed) { <line4> } else { <line5> } <line6> } <line7> } <line8> 	<line4>, <line5>
6960	"public class A { <line0> @Override <line1> public void removePolicy(String absPath, AccessControlPolicy policy) throws RepositoryException { <line2> String oakPath = getOakPath(absPath); <line3> if (isSupportedPath(oakPath)) { <line4> checkValidPolicy(absPath, policy); <line5> Tree tree = getTree(oakPath, Permissions.MODIFY_ACCESS_CONTROL, true); <line6> Tree cug = tree.getChild(REP_CUG_POLICY); <line7> if (!CugUtil.definesCug(cug)) { <line8> throw new AccessControlException(""Unexpected primary type of node rep:cugPolicy.""); <line9> } else { <line10> Set<String> mixins = <line11> Sets.newHashSet(TreeUtil.getNames(tree, NodeTypeConstants.JCR_MIXINTYPES)); <line12> if (mixins.remove(MIX_REP_CUG_MIXIN)) { <line13> tree.setProperty(JcrConstants.JCR_MIXINTYPES, mixins, NAMES); <line14> } else { <line15> } <line16> cug.remove(); <line17> } <line18> } else { <line19> throw new AccessControlException(""Unsupported path: "" + absPath); <line20> } <line21> } <line22> } <line23> "	<line15>
6961	public class A { <line0> public ProjectGeneralTab selectProjectType(String projectType) { <line1> assert getProjectTypes().containsKey(projectType); <line2> WebElement projectTypeButton = getProjectTypes().get(projectType); <line3> scrollIntoView(projectTypeButton); <line4> projectTypeButton.click(); <line5> return new ProjectGeneralTab(getDriver()); <line6> } <line7> } <line8> 	<line1>
6962	public class A { <line0> protected void logItemStates() { <line1> thing <line2> .getChannels() <line3> .forEach( <line4> c -> { <line5> String channelId = c.getUID().getId(); <line6> String itemName = getItemName(channelId); <line7> }); <line8> } <line9> } <line10> 	<line7>
6963	public class A { <line0> @Override <line1> public void initialize() { <line2> config = getConfigAs(StiebelEltronConfiguration.class); <line3> startUp(); <line4> } <line5> } <line6> 	<line3>
6964	public class A { <line0> protected void rewriteProjectJSON(final String resourceName) throws Exception { <line1> final URI resourceURI = DMPPersistenceTestUtils.getResourceURI(resourceName, root); <line2> final String content = DMPPersistenceTestUtils.readResource(resourceURI); <line3> try { <line4> final JsonNode rootNode = <line5> JsonSchemaTransformer.INSTANCE.transformFixAttributePathInstance(content, true); <line6> Assert.assertNotNull(rootNode); <line7> checkProject(rootNode, resourceURI); <line8> DMPPersistenceTestUtils.writeToFile(rootNode, resourceURI); <line9> Assert.assertTrue(true); <line10> } catch (JsonModelAlreadyTransformedException | JsonModelValidationException e) { <line11> } <line12> } <line13> } <line14> 	<line11>
6965	"public class A { <line0> @Override <line1> public SchemaVersionInfo findSchemaVersion( <line2> String schemaBranchName, <line3> String type, <line4> String schemaText, <line5> String schemaMetadataName, <line6> boolean disableCanonicalCheck) <line7> throws InvalidSchemaException, SchemaNotFoundException, SchemaBranchNotFoundException { <line8> Preconditions.checkNotNull(schemaBranchName, ""Schema branch name can't be null""); <line9> String fingerPrint = getFingerprint(type, schemaText); <line10> Collection<SchemaVersionInfo> versionedSchemas = <line11> atlasClient.searchVersions(schemaMetadataName, fingerPrint); <line12> Set<Long> versionIdSet = null; <line13> if (versionedSchemas != null && !versionedSchemas.isEmpty()) { <line14> if (versionedSchemas.size() > 1) { <line15> } <line16> versionIdSet = <line17> versionedSchemas.stream().map(SchemaVersionInfo::getId).collect(Collectors.toSet()); <line18> } <line19> if (versionIdSet == null) { <line20> return null; <line21> } else { <line22> SchemaBranch schemaBranch = <line23> schemaBranchCache.get( <line24> SchemaBranchCache.Key.of(new SchemaBranchKey(schemaBranchName, schemaMetadataName))); <line25> SchemaVersionInfo matchedSchemaVersionInfo = null; <line26> for (SchemaVersionInfo schemaVersionInfo : getSortedSchemaVersions(schemaBranch)) { <line27> if (versionIdSet.contains(schemaVersionInfo.getId())) { <line28> if (!disableCanonicalCheck || schemaVersionInfo.getSchemaText().equals(schemaText)) { <line29> matchedSchemaVersionInfo = schemaVersionInfo; <line30> } <line31> } <line32> } <line33> return matchedSchemaVersionInfo; <line34> } <line35> } <line36> } <line37> "	<line8>, <line10>, <line15>
6966	public class A { <line0> public static String copyFileFromGCSToWorker(ExecutableFile execuableFile) throws Exception { <line1> ResourceId sourceFile = <line2> FileSystems.matchNewResource(execuableFile.getSourceGCSLocation(), false); <line3> ResourceId destinationFile = <line4> FileSystems.matchNewResource(execuableFile.getDestinationLocation(), false); <line5> try { <line6> Path path = Paths.get(execuableFile.getDestinationLocation()); <line7> if (path.toFile().exists()) { <line8> } <line9> copyFile(sourceFile, destinationFile); <line10> path.toFile().setExecutable(true); <line11> return path.toString(); <line12> } catch (Exception ex) { <line13> throw ex; <line14> } <line15> } <line16> } <line17> 	<line6>, <line8>, <line13>
6967	"public class A { <line0> @RolesAllowed({""Resource-Management|Write"", ""Resource-Management|Update""}) <line1> @Override <line2> public Response changeRhHostname(final String rhId, final String hostname) { <line3> try { <line4> registrationManager.changeRhHostname(rhId, hostname); <line5> return Response.ok().build(); <line6> } catch (Exception e) { <line7> return Response.serverError() <line8> .entity( <line9> JsonUtil.toJson( <line10> ERROR_KEY, e.getMessage() == null ? ""Internal error"" : e.getMessage())) <line11> .build(); <line12> } <line13> } <line14> } <line15> "	<line7>
6968	"public class A { <line0> public Object call() throws Exception { <line1> Thread.sleep(getEndpoint().getDelay()); <line2> int count = counter.incrementAndGet(); <line3> if (getEndpoint().getFailFirstAttempts() >= count) { <line4> exchange.setException( <line5> new CamelExchangeException(""Simulated error at attempt "" + count, exchange)); <line6> } else { <line7> String reply = getEndpoint().getReply(); <line8> reply = getEndpoint().isAppend() ? exchange.getIn().getBody() + "" "" + reply : reply; <line9> exchange.getMessage().setBody(reply); <line10> } <line11> callback.done(false); <line12> return null; <line13> } <line14> } <line15> "	<line1>, <line4>, <line10>, <line11>
6969	public class A { <line0> public static synchronized KeyPairGenerator getKeyPairGenerator(String algorithm) <line1> throws NoSuchAlgorithmException, NoSuchProviderException { <line2> KeyPairGenerator result = KeyPairGenerator.getInstance(algorithm); <line3> return result; <line4> } <line5> } <line6> 	<line3>
6970	"public class A { <line0> @Override <line1> public void init() throws FalconException { <line2> Set<Map.Entry<Object, Object>> entrySet = RuntimeProperties.get().entrySet(); <line3> for (Map.Entry<Object, Object> entry : entrySet) { <line4> String key = (String) entry.getKey(); <line5> if (key.startsWith(CONF_PREFIX) && key.endsWith(GROUPS)) { <line6> String proxyUser = key.substring(0, key.lastIndexOf(GROUPS)); <line7> if (RuntimeProperties.get().getProperty(proxyUser + HOSTS) == null) { <line8> throw new FalconException( <line9> proxyUser + HOSTS + "" property not set in runtime "" + ""properties. Please add it.""); <line10> } <line11> proxyUser = proxyUser.substring(CONF_PREFIX.length()); <line12> String value = ((String) entry.getValue()).trim(); <line13> LOG.info(""Loading proxyuser settings [{}]=[{}]"", key, value); <line14> Set<String> values = null; <line15> if (!value.equals(""*"")) { <line16> values = new HashSet<>(Arrays.asList(value.split("",""))); <line17> } <line18> proxyUserGroups.put(proxyUser, values); <line19> } <line20> if (key.startsWith(CONF_PREFIX) && key.endsWith(HOSTS)) { <line21> String proxyUser = key.substring(0, key.lastIndexOf(HOSTS)); <line22> if (RuntimeProperties.get().getProperty(proxyUser + GROUPS) == null) { <line23> throw new FalconException( <line24> proxyUser + GROUPS + "" property not set in runtime "" + ""properties. Please add it.""); <line25> } <line26> proxyUser = proxyUser.substring(CONF_PREFIX.length()); <line27> String value = ((String) entry.getValue()).trim(); <line28> Set<String> values = null; <line29> if (!value.equals(""*"")) { <line30> String[] hosts = value.split("",""); <line31> for (int i = 0; i < hosts.length; i++) { <line32> String hostName = hosts[i]; <line33> try { <line34> hosts[i] = normalizeHostname(hostName); <line35> } catch (Exception ex) { <line36> throw new FalconException( <line37> ""Exception normalizing host name: "" + hostName + ""."" + ex.getMessage(), ex); <line38> } <line39> } <line40> values = new HashSet<>(Arrays.asList(hosts)); <line41> } <line42> proxyUserHosts.put(proxyUser, values); <line43> } <line44> } <line45> } <line46> } <line47> "	<line28>, <line39>
6971	public class A { <line0> private void importTimeDomainFiltersFromMontage(Montage montage) { <line1> int channelCount = montage.getMontageChannelCount(); <line2> int filterCount = montage.getSampleFilterCount(); <line3> SampleFilterDefinition[] definitions = new SampleFilterDefinition[filterCount]; <line4> TimeDomainSampleFilter tdsFilter; <line5> LinkedList<SinglechannelSampleFilterEngine> chain; <line6> SampleSource input; <line7> int i, e; <line8> for (i = 0; i < filterCount; i++) { <line9> definitions[i] = montage.getSampleFilterAt(i); <line10> if (definitions[i] instanceof TimeDomainSampleFilter) { <line11> tdsFilter = (TimeDomainSampleFilter) definitions[i]; <line12> tdsFilter.setSamplingFrequency(source.getSamplingFrequency()); <line13> FilterCoefficients filterCoefficients = null; <line14> try { <line15> filterCoefficients = IIRDesigner.designDigitalFilter(tdsFilter); <line16> } catch (BadFilterParametersException ex) { <line17> continue; <line18> } <line19> for (e = 0; e < channelCount; e++) { <line20> if (!montage.isFilteringExcluded(i, e)) { <line21> chain = chains.get(e); <line22> if (chain.isEmpty()) input = new ChannelSelectorSampleSource(source, e); <line23> else input = chain.getLast(); <line24> AbstractIIRSinglechannelSampleFilter timeDomainSampleFilterEngine; <line25> if (originalSource instanceof ChangeableMultichannelSampleSource) { <line26> timeDomainSampleFilterEngine = <line27> new OnlineIIRSinglechannelSampleFilter(input, tdsFilter, filterCoefficients); <line28> } else { <line29> timeDomainSampleFilterEngine = <line30> new OfflineIIRSinglechannelSampleFilter(input, tdsFilter, filterCoefficients); <line31> ((OfflineIIRSinglechannelSampleFilter) timeDomainSampleFilterEngine) <line32> .setFiltfiltEnabled(montage.isFiltfiltEnabled()); <line33> } <line34> addFilter(timeDomainSampleFilterEngine, e); <line35> } <line36> } <line37> } <line38> } <line39> } <line40> } <line41> 	<line17>
6972	"public class A { <line0> private void createIdForPage(StringBuilder b, IPage<?> page, Object o) { <line1> b.append(""/""); <line2> b.append(page.getClass().getName()); <line3> if (page.getUserPreferenceContext() != null) { <line4> b.append(""/""); <line5> b.append(page.getUserPreferenceContext()); <line6> } <line7> if (o != null) { <line8> b.append(""/""); <line9> b.append(o.getClass().getName()); <line10> } <line11> FastBeanInfo pi = new FastBeanInfo(page.getClass(), page.getClass().getSuperclass()); <line12> for (FastPropertyDescriptor prop : pi.getPropertyDescriptors()) { <line13> if (prop.getReadMethod() != null <line14> && (Date.class.isAssignableFrom(prop.getPropertyType()) <line15> || Number.class.isAssignableFrom(prop.getPropertyType()) <line16> || String.class.isAssignableFrom(prop.getPropertyType()) <line17> || long.class.isAssignableFrom(prop.getPropertyType()))) { <line18> try { <line19> b.append(""/""); <line20> b.append(prop.getName()); <line21> b.append(""=""); <line22> b.append(prop.getReadMethod().invoke(page, new Object[0])); <line23> } catch (Exception e) { <line24> } <line25> } <line26> } <line27> } <line28> } <line29> "	<line24>
6973	public class A { <line0> @Override <line1> public <T> T getBoxValue(VBox<T> vbox) { <line2> this.numBoxReads++; <line3> return readFromBody(vbox); <line4> } <line5> } <line6> 	<line3>
6974	"public class A { <line0> private static PRPAMT201310UV02OtherIDs createOtherIds(Patient patient) { <line1> PRPAMT201310UV02OtherIDs otherIds = new PRPAMT201310UV02OtherIDs(); <line2> otherIds.getClassCode().add(""SD""); <line3> if (StringUtils.isNotEmpty(patient.getSSN())) { <line4> II ssn = new II(); <line5> ssn.setExtension(patient.getSSN()); <line6> ssn.setRoot(""2.16.840.1.113883.4.1""); <line7> otherIds.getId().add(ssn); <line8> COCTMT150002UV01Organization scopingOrg = new COCTMT150002UV01Organization(); <line9> scopingOrg.setClassCode(""ORG""); <line10> scopingOrg.setDeterminerCode(""INSTANCE""); <line11> II orgId = new II(); <line12> orgId.setRoot(ssn.getRoot()); <line13> scopingOrg.getId().add(orgId); <line14> otherIds.setScopingOrganization(scopingOrg); <line15> } <line16> return otherIds; <line17> } <line18> } <line19> "	<line7>
6975	public class A { <line0> public void onFailure(final Throwable caught) { <line1> if (caught instanceof com.google.gwt.user.client.rpc.StatusCodeException <line2> && ((StatusCodeException) caught).getStatusCode() == 0) { <line3> if (!(action instanceof ExitWorkspaceAction)) { <line4> eventBus.fireEvent( <line5> new NotificationEvent( <line6> NotificationEvent.Severity.Error, messages.noResponseFromServer())); <line7> } <line8> } <line9> if (caught instanceof AuthenticationError) { <line10> Application.redirectToLogin(); <line11> } else if (caught instanceof InvalidTokenError) { <line12> Application.redirectToLogin(); <line13> } else if (caught instanceof AuthorizationError) { <line14> callback.onFailure(caught); <line15> } else { <line16> callback.onFailure(caught); <line17> } <line18> } <line19> } <line20> 	<line10>, <line12>, <line14>
6976	public class A { <line0> @Override <line1> public void destroy() { <line2> if (PortletIdCodec.hasInstanceId(_portletModel.getPortletId())) { <line3> if (_log.isWarnEnabled()) { <line4> } <line5> return; <line6> } <line7> Thread currentThread = Thread.currentThread(); <line8> ClassLoader contextClassLoader = currentThread.getContextClassLoader(); <line9> try { <line10> if (_portletClassLoader != null) { <line11> currentThread.setContextClassLoader(_portletClassLoader); <line12> } <line13> cleanUp(); <line14> _portlet.destroy(); <line15> } finally { <line16> if (_portletClassLoader != null) { <line17> currentThread.setContextClassLoader(contextClassLoader); <line18> } <line19> } <line20> } <line21> } <line22> 	<line4>
6977	public class A { <line0> public boolean start() { <line1> Session session = null; <line2> try { <line3> session = sessionProvider.get(); <line4> if (state != GameState.LOBBY || !hasEnoughCards(session)) { <line5> return false; <line6> } <line7> boolean started; <line8> final int numPlayers = players.size(); <line9> if (numPlayers >= 3) { <line10> judgeIndex = (int) (Math.random() * numPlayers); <line11> started = true; <line12> } else { <line13> started = false; <line14> } <line15> if (started) { <line16> currentUniqueId = uniqueIdProvider.get(); <line17> final List<CardSet> cardSets; <line18> synchronized (options.cardSetIds) { <line19> cardSets = loadCardSets(session); <line20> blackDeck = loadBlackDeck(cardSets); <line21> whiteDeck = loadWhiteDeck(cardSets); <line22> } <line23> metrics.gameStart( <line24> currentUniqueId, <line25> cardSets, <line26> options.blanksInDeck, <line27> options.playerLimit, <line28> options.scoreGoal, <line29> !StringUtils.isBlank(options.password)); <line30> startNextRound(); <line31> gameManager.broadcastGameListRefresh(); <line32> } <line33> return started; <line34> } finally { <line35> if (null != session) { <line36> session.close(); <line37> } <line38> } <line39> } <line40> } <line41> 	<line17>
6978	"public class A { <line0> @Test <line1> public void testDropAll() throws Exception { <line2> String update = ""DROP ALL""; <line3> Update operation = con.prepareUpdate(QueryLanguage.SPARQL, update); <line4> operation.execute(); <line5> assertFalse(con.hasStatement(null, null, null, false)); <line6> } <line7> } <line8> "	<line2>
6979	"public class A { <line0> @Override <line1> protected void onStop() { <line2> teardownXMPP(); <line3> teardownSkype(); <line4> setDescription(""Chat plugin""); <line5> } <line6> } <line7> "	<line5>
6980	"public class A { <line0> @Override <line1> public int addToInt(Session session, int delta) { <line2> Object o = getItem(session); <line3> if (o instanceof IntVar) { <line4> IntVar iv = (IntVar) o; <line5> if (!iv.isSet()) { <line6> int index = session.currentSequence().index(); <line7> throw new IllegalStateException(""Variable "" + key + ""["" + index + ""] was not set yet!""); <line8> } <line9> int prev = iv.intValue(session); <line10> if (trace) { <line11> } <line12> iv.add(delta); <line13> return prev; <line14> } else { <line15> int index = session.currentSequence().index(); <line16> throw new IllegalStateException( <line17> ""Variable "" + key + ""["" + index + ""] should contain IntVar but contains "" + o); <line18> } <line19> } <line20> } <line21> "	<line11>
6981	"public class A { <line0> @Override <line1> protected void onNodeAdded(String networkId, Node node) { <line2> String connType = conversionTable().getConnectionType(networkId); <line3> if (connType.equals(FEDERATED_NETWORK)) { <line4> return; <line5> } <line6> String fedNwId = getNetworkIdByType(FEDERATED_NETWORK); <line7> if (fedNwId == null) { <line8> return; <line9> } <line10> NetworkInterface fedNwIf = networkInterfaces().get(fedNwId); <line11> String fedNodeId = String.format(""%s_%s"", networkId, node.getId()); <line12> Node fedNode = node.clone(); <line13> fedNode.setId(fedNodeId); <line14> conversionTable().addEntryNode(networkId, node.getId(), fedNwId, fedNodeId); <line15> fedNwIf.putNode(fedNode); <line16> } <line17> } <line18> "	<line2>
6982	public class A { <line0> @Override <line1> public void onFatalError(Throwable exception) { <line2> ClusterEntryPointExceptionUtils.tryEnrichClusterEntryPointError(exception); <line3> FlinkSecurityManager.forceProcessExit(RUNTIME_FAILURE_RETURN_CODE); <line4> } <line5> } <line6> 	<line3>
6983	public class A { <line0> private void awaitAcknowledgment() { <line1> if (executionProgress.isDataQueued()) { <line2> return; <line3> } <line4> final ExecutionProgress.CompletionAction completionAction; <line5> try { <line6> completionAction = executionProgress.awaitCompletionAction(); <line7> } catch (InterruptedException e) { <line8> abortProcessing(e); <line9> throw new DataflowAbortedException(); <line10> } <line11> if (completionAction == ExecutionProgress.CompletionAction.CANCEL) { <line12> abortProcessing(null); <line13> throw new DataflowAbortedException(); <line14> } <line15> } <line16> } <line17> 	<line2>, <line4>, <line8>, <line12>
6984	"public class A { <line0> @Test <line1> public void testSetMetacardContentTypeToCswRecordType() <line2> throws ParserConfigurationException, SAXException, IOException { <line3> DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance(); <line4> DocumentBuilder docBuilder = docFactory.newDocumentBuilder(); <line5> Document doc = <line6> docBuilder.parse(CswRecordConverterTest.class.getResource(""/Csw_Record.xml"").getPath()); <line7> HierarchicalStreamReader reader = new DomReader(doc); <line8> UnmarshallingContext context = new TreeUnmarshaller(null, null, null, null); <line9> Metacard metacard = (Metacard) converter.unmarshal(reader, context); <line10> assertThat(metacard.getContentTypeName(), is(""IMAGE-PRODUCT"")); <line11> } <line12> } <line13> "	<line10>
6985	public class A { <line0> private void updateConfigInZk(String configStr, ZkCluster zkCluster) { <line1> CuratorRepository.CuratorFrameworkOp curatorFrameworkOp = zkCluster.getCuratorFrameworkOp(); <line2> if (curatorFrameworkOp == null) { <line3> return; <line4> } <line5> String dataInZk = curatorFrameworkOp.getData(SaturnSelfNodePath.SATURN_EXECUTOR_CONFIG); <line6> if (configStr.equals(dataInZk)) { <line7> return; <line8> } <line9> curatorFrameworkOp.update(SaturnSelfNodePath.SATURN_EXECUTOR_CONFIG, configStr); <line10> } <line11> } <line12> 	<line10>
6986	"public class A { <line0> private void setDefaults(NewStagerFASPThreshold threshold, String type, boolean parsePhase) { <line1> try { <line2> setRange(threshold.amplitude, ""stager."" + type + ""Amplitude""); <line3> setRange(threshold.frequency, ""stager."" + type + ""Frequency""); <line4> setRange(threshold.scale, ""stager."" + type + ""Scale""); <line5> if (parsePhase && threshold.phase != null) { <line6> setRange(threshold.phase, ""stager."" + type + ""Phase""); <line7> } <line8> } catch (NumberFormatException e) { <line9> return; <line10> } catch (ConfigurationDefaultsException e) { <line11> return; <line12> } <line13> } <line14> } <line15> "	<line9>
6987	public class A { <line0> @Override <line1> public void appRegistered(AppEvent event) { <line2> DapengApplication application = (DapengApplication) event.getSource(); <line3> application <line4> .getServiceInfos() <line5> .forEach(serviceInfo -> registerService(serviceInfo.serviceName, serviceInfo.version)); <line6> } <line7> } <line8> 	<line2>
6988	"public class A { <line0> public static void main(String[] args) throws IOException { <line1> for (String arg : args) { <line2> } <line3> if (args.length == 0) { <line4> args = new String[] {""scenarios/berlin-v5.5-10pct/input/berlin-v5.5-10pct.config.xml""}; <line5> } <line6> String outputFile = ""scenarios/berlin-v5.5-10pct/output-berlin-v5.5-10pct-accidents/""; <line7> String BVWPNetwork = <line8> ""https://svn.vsp.tu-berlin.de/repos/public-svn/matsim/scenarios/countries/de/berlin/berlin-v5.5-10pct/input/berlin-v5.5-network-with-bvwp-accidents-attributes.xml.gz""; <line9> String plans = <line10> ""https://svn.vsp.tu-berlin.de/repos/public-svn/matsim/scenarios/countries/de/berlin/berlin-v5.5-10pct/input/berlin-v5.5-10pct.plans.xml.gz""; <line11> Config config = RunBerlinScenario.prepareConfig(args); <line12> config.controler().setOutputDirectory(outputFile); <line13> config.controler().setOverwriteFileSetting(OverwriteFileSetting.deleteDirectoryIfExists); <line14> config.controler().setLastIteration(500); <line15> config.plans().setInputFile(plans); <line16> AccidentsConfigGroup accidentsSettings = <line17> ConfigUtils.addOrGetModule(config, AccidentsConfigGroup.class); <line18> accidentsSettings.setEnableAccidentsModule(true); <line19> accidentsSettings.setScaleFactor(10); <line20> config.network().setInputFile(BVWPNetwork); <line21> config.planCalcScore().getModes().get(""car"").setMonetaryDistanceRate(-0.0004); <line22> Scenario scenario = RunBerlinScenario.prepareScenario(config); <line23> Controler controler = RunBerlinScenario.prepareControler(scenario); <line24> controler.addOverridingModule(new AccidentsModule()); <line25> controler.run(); <line26> } <line27> } <line28> "	<line2>
6989	public class A { <line0> private void readyNearLock( <line1> IgniteTxEntry txEntry, <line2> GridCacheVersion dhtVer, <line3> Collection<GridCacheVersion> pendingVers, <line4> Collection<GridCacheVersion> committedVers, <line5> Collection<GridCacheVersion> rolledbackVers) { <line6> while (true) { <line7> GridCacheContext cacheCtx = txEntry.cached().context(); <line8> assert cacheCtx.isNear(); <line9> GridDistributedCacheEntry entry = (GridDistributedCacheEntry) txEntry.cached(); <line10> try { <line11> GridCacheVersion explicit = txEntry.explicitVersion(); <line12> if (explicit == null) { <line13> entry.readyNearLock(xidVer, dhtVer, committedVers, rolledbackVers, pendingVers); <line14> } <line15> break; <line16> } catch (GridCacheEntryRemovedException ignored) { <line17> assert entry.obsoleteVersion() != null; <line18> if (log.isDebugEnabled()) <line19> txEntry.cached(txEntry.context().cache().entryEx(txEntry.key(), topologyVersion())); <line20> } <line21> } <line22> } <line23> } <line24> 	<line19>
6990	public class A { <line0> public void segmentIsReady(String segmentName) { <line1> CountDownLatch cdl = _segmentsAreReady.get(segmentName); <line2> if (cdl == null) { <line3> return; <line4> } <line5> long originalCount = cdl.getCount(); <line6> cdl.countDown(); <line7> if (originalCount > 0L) { <line8> } <line9> } <line10> } <line11> 	<line8>
6991	public class A { <line0> public void runNow(String taskName) { <line1> ScheduledFuture scheduledFuture = taskSchedules.get(taskName); <line2> scheduledFuture.cancel(false); <line3> scheduleTask(runtimeInformationMap.get(taskName), true); <line4> } <line5> } <line6> 	<line1>
6992	"public class A { <line0> public boolean checkErrorMessageByElement(String elementTag, String errMessage) { <line1> List<WebElement> elements = clusterBox.findElements(By.xpath(""//"" + elementTag)); <line2> if (!elements.isEmpty()) { <line3> for (WebElement element : elements) { <line4> Assert.assertEquals(element.getText(), errMessage); <line5> } <line6> return true; <line7> } else { <line8> return false; <line9> } <line10> } <line11> } <line12> "	<line5>, <line8>
6993	public class A { <line0> @Override <line1> public void run() { <line2> } <line3> } <line4> 	<line2>
6994	public class A { <line0> @Override <line1> public String getConfigFile() { <line2> NginxSshDriver driver = (NginxSshDriver) getDriver(); <line3> if (driver == null) { <line4> return null; <line5> } <line6> NginxConfigFileGenerator templateGenerator = getConfig(NginxController.SERVER_CONF_GENERATOR); <line7> return templateGenerator.generateConfigFile(driver, this); <line8> } <line9> } <line10> 	<line4>
6995	"public class A { <line0> @Override <line1> protected IResourceStream getResourceStream() { <line2> return new AbstractResourceStream() { <line3> private static final long serialVersionUID = 1L; <line4>  <line5> @Override <line6> public InputStream getInputStream() throws ResourceStreamNotFoundException { <line7> try { <line8> CodingAgreementResult result = <line9> PairwiseCodingAgreementTable.this.getModelObject().getStudy(aKey1, aKey2); <line10> switch (formatField.getModelObject()) { <line11> case CSV: <line12> return AgreementUtils.generateCsvReport(result); <line13> case DEBUG: <line14> return generateDebugReport(result); <line15> default: <line16> throw new IllegalStateException( <line17> ""Unknown export format ["" + formatField.getModelObject() + ""]""); <line18> } <line19> } catch (Exception e) { <line20> throw new ResourceStreamNotFoundException(e); <line21> } <line22> } <line23>  <line24> @Override <line25> public void close() throws IOException {} <line26> }; <line27> } <line28> } <line29> "	<line20>
6996	"public class A { <line0> private void executeScp(SCPCommand command, Session session, ResponseInfo response) { <line1> Channel channel = null; <line2> FileInputStream fis = null; <line3> OutputStream out = null; <line4> InputStream in = null; <line5> String message; <line6> try { <line7> String exec = ""scp -t "" + command.getDestinationFilePath(); <line8> channel = session.openChannel(""exec""); <line9> ((ChannelExec) channel).setCommand(exec); <line10> out = channel.getOutputStream(); <line11> in = channel.getInputStream(); <line12> channel.connect(); <line13> if ((message = Utils.checkAck(in)) != null) { <line14> response.addErrorMessage(message); <line15> return; <line16> } <line17> File srcFile = new File(command.getSourceFilePath()); <line18> StringBuilder sb = new StringBuilder(); <line19> String fileMode = <line20> PosixFilePermissions.toString(Files.getPosixFilePermissions(srcFile.toPath())); <line21> long filesize = srcFile.length(); <line22> exec = <line23> sb.append(""C0"") <line24> .append(Utils.convertToNumericalForm(fileMode)) <line25> .append("" "") <line26> .append(filesize) <line27> .append("" "") <line28> .append(srcFile.getName()) <line29> .append(""\n"") <line30> .toString(); <line31> out.write(exec.getBytes()); <line32> out.flush(); <line33> if ((message = Utils.checkAck(in)) != null) { <line34> response.addErrorMessage(message); <line35> return; <line36> } <line37> fis = new FileInputStream(command.getSourceFilePath()); <line38> byte[] buf = new byte[1024]; <line39> while (true) { <line40> int len = fis.read(buf, 0, buf.length); <line41> if (len <= 0) { <line42> break; <line43> } <line44> out.write(buf, 0, len); <line45> } <line46> buf[0] = 0; <line47> out.write(buf, 0, 1); <line48> out.flush(); <line49> if ((message = Utils.checkAck(in)) != null) { <line50> response.addErrorMessage(message); <line51> } <line52> } catch (Exception e) { <line53> message = ""Error while sending file to "" + value.getPublicIpAddress(); <line54> response.addErrorMessage(message); <line55> } finally { <line56> try { <line57> if (in != null) { <line58> in.close(); <line59> } <line60> } catch (Exception e) { <line61> } <line62> try { <line63> if (out != null) { <line64> out.close(); <line65> } <line66> } catch (Exception e) { <line67> } <line68> try { <line69> if (fis != null) { <line70> fis.close(); <line71> } <line72> } catch (Exception e) { <line73> } <line74> try { <line75> if (channel != null) { <line76> channel.disconnect(); <line77> } <line78> } catch (Exception e) { <line79> } <line80> } <line81> } <line82> } <line83> "	<line54>
6997	"public class A { <line0> @Override <line1> protected HttpJsonRequest createPingRequest(Machine devMachine) throws ServerException { <line2> final HttpJsonRequest pingRequest = super.createPingRequest(devMachine); <line3> final String tokenServiceUrl = <line4> UriBuilder.fromUri(apiEndpoint) <line5> .replacePath(""api/machine/token/"" + devMachine.getWorkspaceId()) <line6> .build() <line7> .toString(); <line8> String machineToken = null; <line9> try { <line10> machineToken = <line11> httpJsonRequestFactory <line12> .fromUrl(tokenServiceUrl) <line13> .setMethod(HttpMethod.GET) <line14> .request() <line15> .asDto(MachineTokenDto.class) <line16> .getMachineToken(); <line17> } catch (ApiException | IOException ex) { <line18> } <line19> return machineToken == null ? pingRequest : pingRequest.setAuthorizationHeader(machineToken); <line20> } <line21> } <line22> "	<line18>
6998	"public class A { <line0> protected void doAction(Action action, BackendEntry entry) { <line1> E.checkNotNull(entry, ""entry""); <line2> this.mutation.add(entry, action); <line3> } <line4> } <line5> "	<line1>
6999	"public class A { <line0> public void perform(final Map<Path, String> packages) { <line1> try { <line2> final Path temp = Files.createTempFile(""rpm-primary-append"", Remove.SUFFIX); <line3> try { <line4> final MergedXml.Result res; <line5> final MetadataItem primary = <line6> this.items.stream().filter(item -> item.type == XmlPackage.PRIMARY).findFirst().get(); <line7> try (OutputStream out = new BufferedOutputStream(Files.newOutputStream(temp))) { <line8> res = <line9> new MergedXmlPrimary(primary.input, out) <line10> .merge(packages, this.digest, new XmlEvent.Primary()); <line11> } <line12> final ExecutorService service = Executors.newFixedThreadPool(3); <line13> service.submit(Append.setPrimaryPckg(temp, res, primary)); <line14> service.submit(this.updateOther(packages, res)); <line15> service.submit(this.updateFilelist(packages, res)); <line16> service.shutdown(); <line17> service.awaitTermination(Long.MAX_VALUE, TimeUnit.HOURS); <line18> } catch (final InterruptedException err) { <line19> Thread.currentThread().interrupt(); <line20> } finally { <line21> Files.delete(temp); <line22> } <line23> } catch (final IOException err) { <line24> throw new ArtipieIOException(err); <line25> } <line26> } <line27> } <line28> "	<line20>
7000	public class A { <line0> private boolean cleanup(CacheStatus cacheStatus, boolean gpuCache) { <line1> long needToRemoveBytes; <line2> if (cacheStatus.getCurrentSizeBytes() > cacheStatus.getMaxSizeBytes()) { <line3> needToRemoveBytes = cacheStatus.getCurrentSizeBytes() - cacheStatus.getLowWaterBytes(); <line4> } else { <line5> return false; <line6> } <line7> Map<Object, Set<CacheNode>> toBeRemovedMap = new HashMap<>(); <line8> synchronized (myLRUMap) { <line9> long toBeRemovedBytes = 0; <line10> for (Iterator<Entry<Object, LRUNodeSet>> lruIter = myLRUMap.entrySet().iterator(); <line11> lruIter.hasNext() && needToRemoveBytes > toBeRemovedBytes; ) { <line12> Entry<Object, LRUNodeSet> entry = lruIter.next(); <line13> Object key = entry.getKey(); <line14> Set<CacheNode> entryNodes = entry.getValue().getNodes(); <line15> int checkedCacheSize = 0; <line16> for (CacheNode node : entryNodes) { <line17> if (gpuCache) { <line18> checkedCacheSize += node.getSizeGPU(); <line19> } else { <line20> checkedCacheSize += node.getSizeVM(); <line21> } <line22> } <line23> if (checkedCacheSize > 0) { <line24> toBeRemovedBytes += checkedCacheSize; <line25> toBeRemovedMap.put(key, new HashSet<>(entryNodes)); <line26> } <line27> } <line28> } <line29> if (LOGGER.isTraceEnabled() && !toBeRemovedMap.isEmpty()) { <line30> Map<Class<?>, Set<CacheNode>> classCounts = new HashMap<>(); <line31> for (Entry<Object, Set<CacheNode>> entry : toBeRemovedMap.entrySet()) { <line32> Set<CacheNode> nodes = classCounts.get(entry.getKey().getClass()); <line33> if (nodes == null) { <line34> nodes = new HashSet<>(); <line35> classCounts.put(entry.getKey().getClass(), nodes); <line36> } <line37> nodes.addAll(entry.getValue()); <line38> } <line39> for (Entry<Class<?>, Set<CacheNode>> entry : classCounts.entrySet()) { <line40> } <line41> } <line42> doRemoveFromCache(toBeRemovedMap); <line43> return true; <line44> } <line45> } <line46> 	<line30>, <line40>
7001	public class A { <line0> public boolean parse(ByteBuffer buffer) { <line1> while (true) { <line2> switch (state) { <line3> case HEADER: <line4> { <line5> if (!headerParser.parse(buffer)) return false; <line6> state = State.CONTENT; <line7> break; <line8> } <line9> case CONTENT: <line10> { <line11> ContentParser contentParser = findContentParser(headerParser.getFrameType()); <line12> if (headerParser.getContentLength() == 0) { <line13> contentParser.noContent(); <line14> } else { <line15> ContentParser.Result result = contentParser.parse(buffer); <line16> if (LOG.isDebugEnabled()) <line17> if (result == ContentParser.Result.PENDING) { <line18> return false; <line19> } <line20> if (result == ContentParser.Result.ASYNC) { <line21> return true; <line22> } <line23> } <line24> padding = headerParser.getPaddingLength(); <line25> state = State.PADDING; <line26> break; <line27> } <line28> case PADDING: <line29> { <line30> if (buffer.remaining() >= padding) { <line31> buffer.position(buffer.position() + padding); <line32> reset(); <line33> break; <line34> } else { <line35> padding -= buffer.remaining(); <line36> buffer.position(buffer.limit()); <line37> return false; <line38> } <line39> } <line40> default: <line41> { <line42> throw new IllegalStateException(); <line43> } <line44> } <line45> } <line46> } <line47> } <line48> 	<line17>
7002	public class A { <line0> private void clearConsole() { <line1> ConsoleView console = new ConsoleView(); <line2> if (console.canClearConsole()) { <line3> console.clearConsole(); <line4> } <line5> } <line6> } <line7> 	<line1>
7003	"public class A { <line0> @Override <line1> public void myPrepare() { <line2> try { <line3> PropertiesManager pMgr = WebloggerFactory.getWeblogger().getPropertiesManager(); <line4> setProperties(pMgr.getProperties()); <line5> } catch (RollerException ex) { <line6> } <line7> RuntimeConfigDefs defs = PlanetRuntimeConfig.getRuntimeConfigDefs(); <line8> List<ConfigDef> configDefs = defs.getConfigDefs(); <line9> for (ConfigDef configDef : configDefs) { <line10> if (""global-properties"".equals(configDef.getName())) { <line11> setGlobalConfigDef(configDef); <line12> } <line13> } <line14> } <line15> } <line16> "	<line6>
7004	"public class A { <line0> private void insertDataRecord(final String tableName, final WireRecord wireRecord) <line1> throws SQLException { <line2> requireNonNull(tableName, ""Table name cannot be null""); <line3> requireNonNull(wireRecord, ""Wire Record cannot be null""); <line4> final Map<String, TypedValue<?>> wireRecordProperties = wireRecord.getProperties(); <line5> this.dbHelper.withConnection( <line6> c -> { <line7> try (final PreparedStatement stmt = <line8> prepareStatement(c, tableName, wireRecordProperties, new Date().getTime())) { <line9> stmt.execute(); <line10> c.commit(); <line11> return (Void) null; <line12> } <line13> }); <line14> } <line15> } <line16> "	<line14>
7005	"public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> super.handleCommand(channelUID, command); <line3> String channelID = channelUID.getId(); <line4> String uid = (String) getThing().getConfiguration().getProperties().get(APPLIANCE_ID); <line5> String protocol = (String) getThing().getProperties().get(PROTOCOL_PROPERTY_NAME); <line6> OvenChannelSelector selector = (OvenChannelSelector) getValueSelectorFromChannelID(channelID); <line7> JsonElement result = null; <line8> try { <line9> if (selector != null) { <line10> switch (selector) { <line11> case SWITCH: <line12> { <line13> if (command.equals(OnOffType.ON)) { <line14> result = bridgeHandler.invokeOperation(uid, modelID, ""switchOn"", protocol); <line15> } else if (command.equals(OnOffType.OFF)) { <line16> result = bridgeHandler.invokeOperation(uid, modelID, ""switchOff"", protocol); <line17> } <line18> break; <line19> } <line20> case STOP: <line21> { <line22> if (command.equals(OnOffType.ON)) { <line23> result = bridgeHandler.invokeOperation(uid, modelID, ""stop"", protocol); <line24> } <line25> break; <line26> } <line27> default: <line28> { <line29> if (!(command instanceof RefreshType)) { <line30> } <line31> } <line32> } <line33> } <line34> if (isResultProcessable(result)) { <line35> } <line36> } catch (IllegalArgumentException e) { <line37> } <line38> } <line39> } <line40> "	<line30>, <line35>, <line37>
7006	"public class A { <line0> @Override <line1> public Response toResponse(Throwable exception) { <line2> try { <line3> if (exception instanceof WebApplicationException) { <line4> final Response response = ((WebApplicationException) exception).getResponse(); <line5> if (response != null && response.getStatus() > 0) { <line6> return response; <line7> } <line8> } <line9> return Response.temporaryRedirect(new URI(getRedirectURI())).build(); <line10> } catch (Exception e) { <line11> return Response.status(500) <line12> .entity(""Something bad happened. Please try again later!"") <line13> .type(""text/plain"") <line14> .build(); <line15> } <line16> } <line17> } <line18> "	<line9>, <line11>
7007	public class A { <line0> @Override <line1> public void subscribe(String subject, MessageSubscriber subscriber) { <line2> assert (subject != null); <line3> assert (subscriber != null); <line4> if (_gate.enter()) { <line5> if (s_logger.isTraceEnabled()) { <line6> } <line7> try { <line8> SubscriptionNode current = locate(subject, null, true); <line9> assert (current != null); <line10> current.addSubscriber(subscriber); <line11> } finally { <line12> _gate.leave(); <line13> } <line14> } else { <line15> synchronized (_pendingActions) { <line16> _pendingActions.add(new ActionRecord(ActionType.Subscribe, subject, subscriber)); <line17> } <line18> } <line19> } <line20> } <line21> 	<line6>
7008	"public class A { <line0> @Override <line1> public byte[] serializeHandshakeMessageContent() { <line2> writeLifetimeHint(msg); <line3> if (version.isTLS13()) { <line4> writeTicketAgeAdd(msg); <line5> writeTicketNonceLength(msg); <line6> writeTicketNonce(msg); <line7> writeTicketIdentityLength(msg); <line8> writeTicketIdentity(msg); <line9> writeExtensions(); <line10> } else { <line11> throw new UnsupportedOperationException( <line12> ""NewSessionTicket message is currently not supported for not TLS 1.3""); <line13> } <line14> return getAlreadySerialized(); <line15> } <line16> } <line17> "	<line2>
7009	"public class A { <line0> protected String getUrl(String serviceName) { <line1> String result = """"; <line2> try { <line3> result = getWebServiceProxyHelper().getUrlLocalHomeCommunity(serviceName); <line4> } catch (Exception ex) { <line5> } <line6> return result; <line7> } <line8> } <line9> "	<line5>
7010	"public class A { <line0> public void init(final MessageProducer sender, final MessageProducer controlSender) { <line1> Assert.notNull(sender, ""sender is null.""); <line2> Assert.notNull(controlSender, ""controlSender is null.""); <line3> this.sender = sender; <line4> this.controlSender = controlSender; <line5> this.initialized = true; <line6> } <line7> } <line8> "	<line1>
7011	"public class A { <line0> @Around(""within(@org.springframework.stereotype.Controller *)"") <line1> public Object logging(ProceedingJoinPoint joinPoint) throws Throwable { <line2> final long start = System.currentTimeMillis(); <line3> Throwable capture = null; <line4> try { <line5> return joinPoint.proceed(); <line6> } catch (Throwable th) { <line7> capture = th; <line8> throw th; <line9> } finally { <line10> final long time = System.currentTimeMillis() - start; <line11> if (capture != null) { <line12> warnLog(joinPoint, time, capture); <line13> } else if (time > slow) { <line14> warnLog(joinPoint, time, capture); <line15> } else { <line16> if (logger.isDebugEnabled()) { <line17> final String className = joinPoint.getTarget().getClass().getSimpleName(); <line18> final String methodName = joinPoint.getSignature().getName(); <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	<line19>
7012	"public class A { <line0> private Promise<Void> checkBreakpoint(RDPNativeBreakpoint breakpoint) { <line1> if (!breakpoint.breakpoints.isEmpty()) { <line2> return Promise.VOID; <line3> } <line4> if (breakpointLocationMap.get(breakpoint.getLocation()) == breakpoint) { <line5> breakpointLocationMap.remove(breakpoint.getLocation()); <line6> } <line7> if (breakpoint.destroyPromise == null) { <line8> breakpoint.destroyPromise = <line9> breakpoint.initPromise.thenAsync( <line10> v -> { <line11> breakpointsByChromeId.remove(breakpoint.chromeId); <line12> if (logger.isInfoEnabled()) { <line13> } <line14> RemoveBreakpointCommand params = new RemoveBreakpointCommand(); <line15> params.setBreakpointId(breakpoint.chromeId); <line16> return callMethodAsync(""Debugger.removeBreakpoint"", void.class, params); <line17> }); <line18> breakpoint.debugger = null; <line19> } <line20> return breakpoint.destroyPromise; <line21> } <line22> } <line23> "	<line13>
7013	"public class A { <line0> @Test <line1> @Verifies( <line2> value = ""should return trimmed encounter"", <line3> method = ""trimEncounterToMatchForm(Encounter e, HtmlForm htmlform)"") <line4> public void trimEncounterToMatchForm_shouldReturnEncounterCorrectly() throws Exception { <line5> Form form = new Form(); <line6> HtmlForm htmlform = new HtmlForm(); <line7> htmlform.setForm(form); <line8> form.setEncounterType(new EncounterType()); <line9> htmlform.setDateChanged(new Date()); <line10> htmlform.setXmlData( <line11> new TestUtil() <line12> .loadXmlFromFile( <line13> ""org/openmrs/module/htmlformentry/include/returnSectionsAndConceptsInSectionsTestFormWithGroups.xml"")); <line14> String newXml = HtmlFormEntryExportUtil.getSectionAsFormXml(htmlform, 0); <line15> htmlform.setXmlData(newXml); <line16> Encounter e = new Encounter(); <line17> e.setPatient(Context.getPatientService().getPatient(2)); <line18> Date date = Context.getDateFormat().parse(""01/02/2003""); <line19> e.setDateCreated(new Date()); <line20> e.setEncounterDatetime(date); <line21> e.setEncounterType(Context.getEncounterService().getEncounterType(1)); <line22> e.setLocation(Context.getLocationService().getLocation(2)); <line23> e.addProvider( <line24> Context.getEncounterService().getEncounterRole(1), <line25> Context.getProviderService().getProvider(1)); <line26> TestUtil.addObs(e, 2474, Context.getConceptService().getConcept(656), date); <line27> TestUtil.addObs(e, 3017, Context.getConceptService().getConcept(767), date); <line28> TestUtil.addObs(e, 3032, new Date(), date); <line29> TestUtil.addObs(e, 5497, 1500, date); <line30> TestUtil.addObs(e, 5089, 50, date); <line31> TestUtil.addObs(e, 5090, 100, date); <line32> TestUtil.addObs(e, 80000, ""blah blah"", date); <line33> TestUtil.addObsGroup( <line34> e, 1004, new Date(), 1005, Context.getConceptService().getConcept(1001), new Date()); <line35> TestUtil.addObsGroup( <line36> e, 70000, new Date(), 1000, Context.getConceptService().getConcept(1003), new Date()); <line37> Context.getEncounterService().saveEncounter(e); <line38> e = HtmlFormEntryExportUtil.trimEncounterToMatchForm(e, htmlform); <line39> if (log.isDebugEnabled()) { <line40> for (Obs otmp : e.getAllObs()) { <line41> } <line42> } <line43> Assert.assertEquals(5, e.getAllObs().size()); <line44> } <line45> } <line46> "	<line41>
7014	"public class A { <line0> @Override <line1> public long purge(Integer tenant) throws DatabaseException { <line2> ParametersChecker.checkParameter(ALL_PARAMS_REQUIRED, tenant); <line3> try { <line4> DeleteResult response = <line5> collection.deleteMany(new BasicDBObject(VitamDocument.TENANT_ID, tenant)); <line6> return response.getDeletedCount(); <line7> } catch (MongoException e) { <line8> throw new DatabaseException( <line9> String.format(""Error while delete documents for tenant %s"", tenant), e); <line10> } <line11> } <line12> } <line13> "	<line8>
7015	public class A { <line0> private boolean fillBuffer() { <line1> buffer.clear(); <line2> bufferOffset = 0; <line3> bufferFillSize = 0; <line4> List<Integer> queue = new LinkedList<Integer>(); <line5> queue.addAll(notExpandedCategories); <line6> while (!queue.isEmpty() && buffer.size() < maxBufferSize) { <line7> Category currentCat = wiki.getCategory(queue.get(0)); <line8> queue.remove(0); <line9> if (!expandedCategoryIds.contains(currentCat.getPageId())) { <line10> buffer.add(currentCat); <line11> notExpandedCategories.remove(currentCat.getPageId()); <line12> expandedCategoryIds.add(currentCat.getPageId()); <line13> for (Category child : currentCat.getChildren()) { <line14> queue.add(child.getPageId()); <line15> notExpandedCategories.add(child.getPageId()); <line16> } <line17> } <line18> } <line19> if (buffer.size() > 0) { <line20> bufferFillSize = buffer.size(); <line21> return true; <line22> } else { <line23> return false; <line24> } <line25> } <line26> } <line27> 	<line13>
7016	"public class A { <line0> @Test() <line1> @Timeout(300000) <line2> @Tag(TagNames.LONG_TEST) <line3> @Tag(TagNames.LARGE_RESOURCES) <line4> public void testHash() { <line5> VocabWord w1 = new VocabWord(1.0, ""D1""); <line6> VocabWord w2 = new VocabWord(1.0, ""Bo""); <line7> assertNotEquals(w1.getStorageId(), w2.getStorageId()); <line8> } <line9> } <line10> "	<line7>
7017	"public class A { <line0> @Override <line1> public void stop() { <line2> logApplicationLifecycle(""Stopping""); <line3> ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator( <line4> this, Attributes.SERVICE_STATE_ACTUAL, ""Application stopping""); <line5> sensors().set(SERVICE_UP, false); <line6> setExpectedStateAndRecordLifecycleEvent(Lifecycle.STOPPING); <line7> try { <line8> doStop(); <line9> } catch (Exception e) { <line10> setExpectedStateAndRecordLifecycleEvent(Lifecycle.ON_FIRE); <line11> throw Exceptions.propagate(e); <line12> } <line13> ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator( <line14> this, Attributes.SERVICE_STATE_ACTUAL, ""Application stopped""); <line15> setExpectedStateAndRecordLifecycleEvent(Lifecycle.STOPPED); <line16> if (getParent() == null) { <line17> synchronized (this) { <line18> getEntityManager().unmanage(this); <line19> } <line20> } <line21> logApplicationLifecycle(""Stopped""); <line22> } <line23> } <line24> "	<line11>
7018	public class A { <line0> protected void activate(ComponentContext context, Map<String, Object> config) <line1> throws RepositoryException { <line2> config = Maps.newHashMap(config); <line3> DataStore ds = createDataStore(context, config); <line4> boolean encodeLengthInId = PropertiesUtil.toBoolean(config.get(PROP_ENCODE_LENGTH), true); <line5> int cacheSizeInMB = <line6> PropertiesUtil.toInteger( <line7> config.get(PROP_CACHE_SIZE), DataStoreBlobStore.DEFAULT_CACHE_SIZE); <line8> String homeDir = lookup(context, PROP_HOME); <line9> if (config.containsKey(PATH) && !Strings.isNullOrEmpty((String) config.get(PATH))) { <line10> } else if (homeDir != null) { <line11> } <line12> PropertiesUtil.populate(ds, config, false); <line13> ds.init(homeDir); <line14> BlobStoreStats stats = new BlobStoreStats(getStatisticsProvider()); <line15> this.dataStore = new DataStoreBlobStore(ds, encodeLengthInId, cacheSizeInMB); <line16> this.dataStore.setBlobStatsCollector(stats); <line17> PropertiesUtil.populate(dataStore, config, false); <line18> Dictionary<String, Object> props = new Hashtable<String, Object>(); <line19> props.put(Constants.SERVICE_PID, ds.getClass().getName()); <line20> props.put(DESCRIPTION, getDescription()); <line21> if (context.getProperties().get(PROP_SPLIT_BLOBSTORE) != null) { <line22> props.put(PROP_SPLIT_BLOBSTORE, context.getProperties().get(PROP_SPLIT_BLOBSTORE)); <line23> } <line24> reg = <line25> context <line26> .getBundleContext() <line27> .registerService( <line28> new String[] { <line29> BlobStore.class.getName(), <line30> GarbageCollectableBlobStore.class.getName(), <line31> BlobAccessProvider.class.getName(), <line32> }, <line33> dataStore, <line34> props); <line35> mbeanReg = registerMBeans(context.getBundleContext(), dataStore, stats); <line36> } <line37> } <line38> 	<line10>, <line11>
7019	"public class A { <line0> @GET <line1> @Path(""/reload/{tableName}"") <line2> @Produces({ <line3> ""application/xml"", <line4> ""text/xml"", <line5> ""application/json"", <line6> ""text/yaml"", <line7> ""text/x-yaml"", <line8> ""application/x-yaml"", <line9> ""application/x-protobuf"", <line10> ""application/x-protostuff"" <line11> }) <line12> @GZIP <line13> @Interceptors(RequiredInterceptor.class) <line14> public VoidResponse reloadCache(@Required(""tableName"") @PathParam(""tableName"") String tableName) { <line15> VoidResponse response = new VoidResponse(); <line16> if (null == details.get(tableName)) { <line17> return response; <line18> } <line19> try { <line20> details.get(tableName).getWatcher().incrementCounter(tableName); <line21> } catch (Exception e) { <line22> response.addException(new QueryException(e).getBottomQueryException()); <line23> throw new DatawaveWebApplicationException(e, response); <line24> } <line25> try { <line26> this.sendCacheReloadMessage(tableName); <line27> } catch (Exception e) { <line28> } <line29> handleReload(tableName); <line30> handleReloadTypeMetadata(tableName); <line31> return response; <line32> } <line33> } <line34> "	<line28>
7020	"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/by-code/{code}"") <line3> public Response getCrisisByCode(@PathParam(""code"") String crisisCode) { <line4> CollectionDTO collection = null; <line5> ResponseWrapper response = new ResponseWrapper(); <line6> try { <line7> collection = crisisLocalEJB.getCrisisByCode(crisisCode); <line8> if (collection != null) { <line9> response.setDataObject(collection); <line10> response.setTotal(1); <line11> response.setStatusCode( <line12> TaggerAPIConfigurator.getInstance() <line13> .getProperty(TaggerAPIConfigurationProperty.STATUS_CODE_SUCCESS)); <line14> return Response.ok(response).build(); <line15> } else { <line16> response.setDataObject(null); <line17> response.setTotal(0); <line18> response.setStatusCode( <line19> TaggerAPIConfigurator.getInstance() <line20> .getProperty(TaggerAPIConfigurationProperty.STATUS_CODE_SUCCESS)); <line21> return Response.ok(response).build(); <line22> } <line23> } catch (RuntimeException e) { <line24> response.setDataObject(null); <line25> response.setTotal(0); <line26> response.setStatusCode( <line27> TaggerAPIConfigurator.getInstance() <line28> .getProperty(TaggerAPIConfigurationProperty.STATUS_CODE_FAILED)); <line29> response.setMessage(e.getCause().getCause().getMessage()); <line30> return Response.ok(response).build(); <line31> } <line32> } <line33> } <line34> "	<line8>, <line30>
7021	public class A { <line0> public static void print(Message msg) throws JMSException { <line1> if (msg instanceof ObjectMessage) { <line2> ObjectMessage objMsg = (ObjectMessage) msg; <line3> } else { <line4> MapMessage mapMsg = (MapMessage) msg; <line5> HashMap map = new HashMap(); <line6> Enumeration en = mapMsg.getMapNames(); <line7> while (en.hasMoreElements()) { <line8> String property = (String) en.nextElement(); <line9> Object mapObject = mapMsg.getObject(property); <line10> map.put(property, mapObject); <line11> } <line12> } <line13> } <line14> } <line15> 	<line1>, <line3>, <line12>
7022	public class A { <line0> private Method getMethod(String methodName, Object value, Class<?> clazz) { <line1> try { <line2> if (value == null) { <line3> return clazz.getMethod(methodName, (Class<?>[]) null); <line4> } else { <line5> return clazz.getMethod(methodName, value.getClass()); <line6> } <line7> } catch (SecurityException e) { <line8> return null; <line9> } catch (NoSuchMethodException e) { <line10> return null; <line11> } <line12> } <line13> } <line14> 	<line8>, <line10>
7023	public class A { <line0> Path checkParent(Path path) throws IOException { <line1> Path parent = path.getParent(); <line2> if (directoryCache.getIfPresent(parent) == null && !fs.exists(parent)) { <line3> if (fs.mkdirs(parent)) { <line4> directoryCache.put(parent, parent); <line5> } else { <line6> } <line7> } <line8> return path; <line9> } <line10> } <line11> 	<line6>
7024	public class A { <line0> private void handle(ErrorAction action, Exception cause, String message) throws IOException { <line1> switch (action) { <line2> case REPORT: <line3> break; <line4> case ERROR: <line5> throw new IOException(message, cause); <line6> default: <line7> throw new AssertionError(action); <line8> } <line9> } <line10> } <line11> 	<line3>
7025	"public class A { <line0> @RetryingOperation <line1> @Override <line2> @ValidateParams <line3> public double getNewNavOrder( <line4> @ValidateStringParam(name = ""site"") String site, <line5> @ValidateSecurePathParam(name = ""path"") String path, <line6> @ValidateDoubleParam(name = ""currentMaxNavOrder"") double currentMaxNavOrder) { <line7> String lockId = site + "":"" + path; <line8> double lastNavOrder = 1000D; <line9> try { <line10> Map<String, String> params = new HashMap<String, String>(); <line11> params.put(""site"", site); <line12> params.put(""path"", path); <line13> NavigationOrderSequence navigationOrderSequence = <line14> navigationOrderSequenceMapper.getPageNavigationOrderForSiteAndPath(params); <line15> if (navigationOrderSequence == null) { <line16> navigationOrderSequence = new NavigationOrderSequence(); <line17> navigationOrderSequence.setSite(site); <line18> navigationOrderSequence.setPath(path); <line19> ContentItemTO itemTreeTO = contentService.getContentItemTree(site, path, 1); <line20> if (itemTreeTO == null) { <line21> navigationOrderSequence.setMaxCount(0F); <line22> } else { <line23> if (StringUtils.isEmpty(itemTreeTO.getNodeRef())) { <line24> navigationOrderSequence.setFolderId(UUID.randomUUID().toString()); <line25> } else { <line26> navigationOrderSequence.setFolderId(itemTreeTO.getNodeRef()); <line27> } <line28> if (currentMaxNavOrder < 0) { <line29> navigationOrderSequence.setMaxCount(1000F * itemTreeTO.getNumOfChildren()); <line30> } else { <line31> double newMaxCount = currentMaxNavOrder + getPageNavigationOrderIncrement(); <line32> navigationOrderSequence.setMaxCount(newMaxCount); <line33> } <line34> } <line35> navigationOrderSequenceMapper.insert(navigationOrderSequence); <line36> } else { <line37> double newMaxCount = <line38> navigationOrderSequence.getMaxCount() + getPageNavigationOrderIncrement(); <line39> navigationOrderSequence.setMaxCount(newMaxCount); <line40> navigationOrderSequenceMapper.update(navigationOrderSequence); <line41> } <line42> lastNavOrder = navigationOrderSequence.getMaxCount(); <line43> } catch (Exception e) { <line44> } <line45> return lastNavOrder; <line46> } <line47> } <line48> "	<line44>
7026	public class A { <line0> public static void sqlRS(Connection conn, String sql, Consumer<ResultSet> consumer) { <line1> try (Statement stmt = conn.createStatement(); <line2> ResultSet rs = stmt.executeQuery(sql)) { <line3> consumer.accept(rs); <line4> } catch (SQLException e) { <line5> } <line6> } <line7> } <line8> 	<line5>
7027	public class A { <line0> public void logStart() { <line1> } <line2> } <line3> 	<line1>
7028	public class A { <line0> public void trace(ScriptExecution scriptExecution) { <line1> try { <line2> String runId = scriptExecution.getExecutionControl().getRunId(); <line3> Long processId = scriptExecution.getProcessId(); <line4> ScriptTraceConfiguration.getInstance() <line5> .insert( <line6> new ScriptTrace( <line7> runId, <line8> processId, <line9> scriptExecution <line10> .getParentScriptExecution() <line11> .map(ScriptExecution::getProcessId) <line12> .orElse(0L), <line13> scriptExecution.getScript())); <line14> ScriptVersionTraceConfiguration.getInstance() <line15> .insert( <line16> new ScriptVersionTrace(runId, processId, scriptExecution.getScript().getVersion())); <line17> for (ScriptParameter scriptParameter : scriptExecution.getScript().getParameters()) { <line18> ScriptParameterTraceConfiguration.getInstance() <line19> .insert(new ScriptParameterTrace(runId, processId, scriptParameter)); <line20> } <line21> for (ScriptLabel scriptLabel : scriptExecution.getScript().getLabels()) { <line22> ScriptLabelTraceConfiguration.getInstance() <line23> .insert( <line24> new ScriptLabelTrace( <line25> new ScriptLabelTraceKey(runId, processId, scriptLabel.getMetadataKey()), <line26> scriptLabel.getScriptKey(), <line27> scriptLabel.getName(), <line28> scriptLabel.getValue())); <line29> } <line30> } catch (Exception e) { <line31> StringWriter stackTrace = new StringWriter(); <line32> e.printStackTrace(new PrintWriter(stackTrace)); <line33> } <line34> } <line35> } <line36> 	<line33>
7029	"public class A { <line0> public int insert(String table, String key, HashMap<String, ByteIterator> values) { <line1> try { <line2> HBaseUser u = <line3> new HBaseUser(key, getString(key, ""24""), getString(key, ""gzb""), getString(key, ""mishra"")); <line4> em.persist(u); <line5> j++; <line6> if (j % 5000 == 0) { <line7> em.clear(); <line8> } <line9> return Ok; <line10> } catch (Exception e) { <line11> return Error; <line12> } <line13> } <line14> } <line15> "	<line11>
7030	public class A { <line0> public static InetAddress getInetNetworkMask(final int prefixMaskLength, final boolean isV6) { <line1> if (prefixMaskLength < 0 || !isV6 && prefixMaskLength > 32 || isV6 && prefixMaskLength > 128) { <line2> return null; <line3> } <line4> byte[] v4Address = {0, 0, 0, 0}; <line5> byte[] v6Address = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; <line6> byte[] address = isV6 ? v6Address : v4Address; <line7> int numBytes = prefixMaskLength / 8; <line8> int numBits = prefixMaskLength % 8; <line9> int index = 0; <line10> for (; index < numBytes; index++) { <line11> address[index] = (byte) 0xff; <line12> } <line13> if (numBits > 0) { <line14> int rem = 0; <line15> for (int j = 0; j < numBits; j++) { <line16> rem |= 1 << 7 - j; <line17> } <line18> address[index] = (byte) rem; <line19> } <line20> try { <line21> return InetAddress.getByAddress(address); <line22> } catch (final UnknownHostException e) { <line23> } <line24> return null; <line25> } <line26> } <line27> 	<line23>
7031	public class A { <line0> public static DateTime parseStringWithFormatPattern4NoTZ(String tsString) { <line1> try { <line2> String tsStringTruncated = tsString.substring(0, tsString.length() - 3); <line3> return FORMATTER4.parseDateTime(tsStringTruncated); <line4> } catch (Exception e) { <line5> return parseStringWithFormatPattern5(tsString); <line6> } <line7> } <line8> } <line9> 	<line5>
7032	"public class A { <line0> static void clean(ClassLoader cl) { <line1> MBeanServer mbs = ManagementFactory.getPlatformMBeanServer(); <line2> String domain = """"; <line3> for (ObjectName mbean : mbs.queryNames(null, null)) { <line4> try { <line5> domain = mbean.getDomain(); <line6> if (domain.startsWith(""java."") <line7> || domain.startsWith(""com.sun."") <line8> || domain.startsWith(""JMI"") <line9> || domain.startsWith(""com.enioka."")) { <line10> continue; <line11> } <line12> if (mbs.getClassLoaderFor(mbean) == null || mbs.getClassLoaderFor(mbean).equals(cl)) { <line13> mbs.unregisterMBean(mbean); <line14> } <line15> } catch (Exception e) { <line16> } <line17> } <line18> Introspector.flushCaches(); <line19> } <line20> } <line21> "	<line13>, <line16>
7033	public class A { <line0> private void initObject(final MSXMLScriptable scriptable) { <line1> try { <line2> scriptable.setPrototype(environment_.getPrototype(scriptable.getClass())); <line3> scriptable.setEnvironment(environment_); <line4> } catch (final Exception e) { <line5> throw new ScriptException(null, e); <line6> } <line7> } <line8> } <line9> 	<line5>
7034	"public class A { <line0> @Test <line1> public void forTranslation() throws Exception { <line2> TMTestData tmTestData = new TMTestData(testIdWatcher); <line3> Repository repository = tmTestData.repository; <line4> List<String> bcp47Tags = new ArrayList<>(); <line5> bcp47Tags.add(""fr-FR""); <line6> bcp47Tags.add(""ko-KR""); <line7> bcp47Tags.add(""ja-JP""); <line8> ExportDropConfig exportDropConfig = new ExportDropConfig(); <line9> exportDropConfig.setRepositoryId(repository.getId()); <line10> exportDropConfig.setBcp47Tags(bcp47Tags); <line11> checkNumberOfUntranslatedTextUnit(repository, bcp47Tags, 4); <line12> PollableFuture<Drop> startExportProcess = <line13> dropService.startDropExportProcess(exportDropConfig, PollableTask.INJECT_CURRENT_TASK); <line14> PollableTask pollableTask = startExportProcess.getPollableTask(); <line15> pollableTaskService.waitForPollableTask(pollableTask.getId(), 600000L); <line16> Drop drop = startExportProcess.get(); <line17> localizeDropFiles(drop, 1); <line18> PollableFuture startImportDrop = <line19> dropService.importDrop(drop.getId(), null, PollableTask.INJECT_CURRENT_TASK); <line20> logger.debug(""Wait for import to finish""); <line21> pollableTaskService.waitForPollableTask(startImportDrop.getPollableTask().getId(), 60000L); <line22> logger.debug(""Check everything is now translated""); <line23> checkNumberOfUntranslatedTextUnit(repository, bcp47Tags, 0); <line24> checkImportedFilesContent(drop, 1); <line25> checkTranslationKitStatistics(drop); <line26> localizeDropFiles(drop, 2); <line27> PollableFuture startImportDrop3 = <line28> dropService.importDrop(drop.getId(), null, PollableTask.INJECT_CURRENT_TASK); <line29> pollableTaskService.waitForPollableTask(startImportDrop3.getPollableTask().getId(), 60000L); <line30> checkNumberOfUntranslatedTextUnit(repository, bcp47Tags, 0); <line31> checkImportedFilesContent(drop, 2); <line32> checkTranslationKitStatistics(drop); <line33> } <line34> } <line35> "	<line11>, <line12>, <line15>, <line16>, <line18>, <line26>, <line29>, <line30>
7035	public class A { <line0> protected <T> boolean needsToBeSuspected(Address mbr, T value) { <line1> long val = (long) value; <line2> long diff = TimeUnit.MILLISECONDS.convert(getTimestamp() - val, TimeUnit.NANOSECONDS); <line3> if (diff > timeout) { <line4> return true; <line5> } <line6> return false; <line7> } <line8> } <line9> 	<line4>
7036	public class A { <line0> @Override <line1> protected void doPost(HttpServletRequest req, HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> ChannelService channelService = ChannelServiceFactory.getChannelService(); <line4> ChannelPresence presence = channelService.parsePresence(req); <line5> } <line6> } <line7> 	<line5>
7037	public class A { <line0> private void setComputationModulus(SrpClientKeyExchangeMessage msg) { <line1> msg.getComputations().setModulus(chooser.getSRPModulus()); <line2> } <line3> } <line4> 	<line2>
7038	"public class A { <line0> public static void zipTrackedContent(File out, Set<TrackedContent> sealed) throws IOException { <line1> try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(out))) { <line2> for (TrackedContent f : sealed) { <line3> String name = SEALED.getValue() + ""/"" + f.getKey().getId(); <line4> zip.putNextEntry(new ZipEntry(name)); <line5> copy(toInputStream(f), zip); <line6> } <line7> } <line8> } <line9> } <line10> "	<line1>, <line4>
7039	public class A { <line0> public void uploadFileEvent(String index, File file) { <line1> WebElement element = driver.findElement(By.xpath(index)); <line2> element.sendKeys(file.toPath().toString()); <line3> } <line4> } <line5> 	<line3>
7040	public class A { <line0> @Override <line1> public void update(IDirectPersistencyOpInfo entry) { <line2> try { <line3> _cacheManager <line4> .getBlobStoreStorageHandler() <line5> .replace( <line6> getOpInfoStorageKey(entry.getGenerationId(), entry.getSequenceNumber()), <line7> entry, <line8> null, <line9> BlobStoreObjectType.SYNC, <line10> null); <line11> } catch (BlobStoreException ex) { <line12> throw ex; <line13> } <line14> } <line15> } <line16> 	<line12>
7041	"public class A { <line0> private void processNodeStateEvent(NodeStateEvent event) { <line1> switch (stateRef.get()) { <line2> case BEFORE_INIT: <line3> case DURING_INIT: <line4> throw new AssertionError(""Filter should not be marked ready until LBP init""); <line5> case CLOSING: <line6> return; <line7> case RUNNING: <line8> for (LoadBalancingPolicy policy : policies) { <line9> if (event.newState == NodeState.UP) { <line10> policy.onUp(event.node); <line11> } else if (event.newState == NodeState.DOWN || event.newState == NodeState.FORCED_DOWN) { <line12> policy.onDown(event.node); <line13> } else if (event.newState == NodeState.UNKNOWN) { <line14> policy.onAdd(event.node); <line15> } else if (event.newState == null) { <line16> policy.onRemove(event.node); <line17> } else { <line18> } <line19> } <line20> break; <line21> } <line22> } <line23> } <line24> "	<line18>
7042	public class A { <line0> @Override <line1> public void evaluate() throws Throwable { <line2> try { <line3> base.evaluate(); <line4> } catch (MultiplexingClientDeviceRegistrationAuthenticationException e) { <line5> for (String deviceId : e.getRegistrationExceptions().keySet()) { <line6> } <line7> throw e; <line8> } <line9> } <line10> } <line11> 	<line5>, <line6>
7043	public class A { <line0> @Override <line1> public void onDestroyed(PeerId peer) { <line2> } <line3> } <line4> 	<line2>
7044	"public class A { <line0> protected void clearTestData() throws Exception { <line1> CosmosQueryRequestOptions queryOptions = new CosmosQueryRequestOptions(); <line2> CosmosPagedIterable<JsonNode> response = <line3> container.queryItems(""select * from c order by c._ts"", queryOptions, JsonNode.class); <line4> response.forEach( <line5> data -> { <line6> if (data.get(TEST_COSMOS_PARTITION_KEY_FIELD_NAME) != null) { <line7> PartitionKey pkey = <line8> new PartitionKey(data.get(TEST_COSMOS_PARTITION_KEY_FIELD_NAME).asText()); <line9> container.deleteItem(data.get(""id"").asText(), pkey, new CosmosItemRequestOptions()); <line10> } else { <line11> container.deleteItem( <line12> data.get(""id"").asText(), PartitionKey.NONE, new CosmosItemRequestOptions()); <line13> } <line14> }); <line15> } <line16> } <line17> "	<line1>
7045	public class A { <line0> @Override <line1> public void onMessage(UUID nodeId, Object msg, byte plc) { <line2> if (msg instanceof TxLocksResponse) { <line3> try { <line4> ((TxLocksResponse) msg).finishUnmarshal(clientCtx, clientCtx.deploy().globalLoader()); <line5> res.set(true); <line6> } catch (Exception e) { <line7> } finally { <line8> latch.countDown(); <line9> } <line10> } <line11> } <line12> } <line13> 	<line7>
7046	public class A { <line0> @Override <line1> public void getNumberOfConfigsSuccess(Integer numberOfConfigs, ReplyContext replyContext) { <line2> } <line3> } <line4> 	<line2>
7047	public class A { <line0> @Override <line1> public int getNumberOfUsers() { <line2> if (numberOfUsersString != null) { <line3> try { <line4> return Integer.valueOf(numberOfUsersString); <line5> } catch (Throwable t) { <line6> } <line7> } <line8> return -1; <line9> } <line10> } <line11> 	<line6>
7048	"public class A { <line0> public ReplicaSets getReplicaSets() { <line1> MongoClient client = context.getConnectionContext().clientFor(seedAddresses); <line2> Set<ReplicaSet> replicaSetSpecs = new HashSet<>(); <line3> String shardsCollection = ""shards""; <line4> try { <line5> MongoUtil.onCollectionDocuments( <line6> client, <line7> CONFIG_DATABASE_NAME, <line8> shardsCollection, <line9> doc -> { <line10> String shardName = doc.getString(""_id""); <line11> String hostStr = doc.getString(""host""); <line12> String replicaSetName = MongoUtil.replicaSetUsedIn(hostStr); <line13> replicaSetSpecs.add(new ReplicaSet(hostStr, replicaSetName, shardName)); <line14> }); <line15> } catch (MongoInterruptedException e) { <line16> Thread.currentThread().interrupt(); <line17> } catch (MongoException e) { <line18> } <line19> if (replicaSetSpecs.isEmpty()) { <line20> final ClusterDescription clusterDescription = client.getClusterDescription(); <line21> if (clusterDescription != null) { <line22> final List<ServerDescription> serverDescriptions = <line23> clusterDescription.getServerDescriptions(); <line24> if (serverDescriptions == null || serverDescriptions.size() == 0) { <line25> } else { <line26> String addressStr = <line27> serverDescriptions.stream() <line28> .map(x -> x.getAddress().toString()) <line29> .collect(Collectors.joining("","")); <line30> String replicaSetName = serverDescriptions.get(0).getSetName(); <line31> replicaSetSpecs.add(new ReplicaSet(addressStr, replicaSetName, null)); <line32> } <line33> } else { <line34> String replicaSetName = MongoUtil.replicaSetUsedIn(seedAddresses); <line35> if (replicaSetName != null) { <line36> for (String address : MongoUtil.ADDRESS_DELIMITER_PATTERN.split(seedAddresses)) { <line37> replicaSetSpecs.add(new ReplicaSet(address, replicaSetName, null)); <line38> } <line39> } <line40> } <line41> } <line42> if (replicaSetSpecs.isEmpty()) { <line43> } <line44> return new ReplicaSets(replicaSetSpecs); <line45> } <line46> } <line47> "	<line10>, <line16>, <line18>, <line21>, <line25>, <line34>, <line43>
7049	"public class A { <line0> public boolean updateCheckout(OnDiskCheckout c, ProjectVersion pv) throws CheckoutException { <line1> if (c != null) { <line2> return false; <line3> } <line4> if (!isUpdatable(c)) { <line5> return false; <line6> } <line7> OnDiskCheckoutImpl cimpl = (OnDiskCheckoutImpl) c; <line8> cimpl.lock(); <line9> if (cimpl.getProjectVersion().gt(pv)) { <line10> throw new CheckoutException(""Checkout already updated""); <line11> } else if (cimpl.getProjectVersion().eq(pv)) { <line12> return true; <line13> } <line14> SCMAccessor scm = <line15> (SCMAccessor) <line16> AlitheiaCore.getInstance().getTDSService().getAccessor(pv.getProject().getId()); <line17> try { <line18> scm.updateCheckout( <line19> cimpl.getRepositoryPath(), <line20> projectVersionToRevision(cimpl.getProjectVersion()), <line21> projectVersionToRevision(pv), <line22> cimpl.getRoot()); <line23> cimpl.setRevision(pv); <line24> } catch (InvalidProjectRevisionException e) { <line25> throw new CheckoutException( <line26> ""Project version "" <line27> + pv <line28> + "" does not map to an SCM revision. Error was:"" <line29> + e.getMessage()); <line30> } catch (InvalidRepositoryException e) { <line31> throw new CheckoutException( <line32> ""Error accessing repository "" + scm.toString() + "". Error was:"" + e.getMessage()); <line33> } catch (FileNotFoundException e) { <line34> throw new CheckoutException(""Error accessing checkout root. "" + e.getMessage()); <line35> } finally { <line36> cimpl.unlock(); <line37> } <line38> return true; <line39> } <line40> } <line41> "	<line10>
7050	public class A { <line0> protected void buildMetadataStoreDirectory(String namespace, String address) { <line1> try { <line2> _metadataStoreDirectory = ZkMetadataStoreDirectory.getInstance(namespace, address); <line3> } catch (InvalidRoutingDataException ex) { <line4> } <line5> } <line6> } <line7> 	<line4>
7051	"public class A { <line0> public boolean isValid(RequestContext context, String endpointAddress) throws Exception { <line1> if (endpointAddress == null) { <line2> return true; <line3> } <line4> UrlValidator urlValidator = <line5> new UrlValidator(new String[] {""http"", ""https""}, UrlValidator.ALLOW_LOCAL_URLS); <line6> if (!urlValidator.isValid(endpointAddress)) { <line7> return false; <line8> } <line9> return true; <line10> } <line11> } <line12> "	<line7>
7052	public class A { <line0> @Override <line1> protected void start() { <line2> try { <line3> super.start(); <line4> this.remove(POSTED_TIME_ORDERBY.clone()); <line5> this.append(ACTIVITY_UPDATED_POINT_FIELD.clone()) <line6> .with(POSTED_TIME_ORDERBY.clone()) <line7> .direction(DIRECTION.ASC) <line8> .with(LAST_UPDATED_ORDERBY.clone()) <line9> .direction(DIRECTION.ASC); <line10> } catch (Exception ex) { <line11> } <line12> } <line13> } <line14> 	<line11>
7053	"public class A { <line0> @SuppressWarnings({""java:S2274""}) <line1> void startElection() { <line2> synchronized (localMember.getTerm()) { <line3> long nextTerm = localMember.getTerm().incrementAndGet(); <line4> localMember.setVoteFor(localMember.getThisNode()); <line5> localMember.updateHardState(nextTerm, this.localMember.getVoteFor()); <line6> int quorumNum = localMember.getAllNodes().size() / 2; <line7> AtomicBoolean electionTerminated = new AtomicBoolean(false); <line8> AtomicBoolean electionValid = new AtomicBoolean(false); <line9> AtomicInteger quorum = new AtomicInteger(quorumNum); <line10> AtomicInteger failingVoteCounter = new AtomicInteger(quorumNum + 1); <line11> electionRequest.setTerm(nextTerm); <line12> electionRequest.setElector(localMember.getThisNode()); <line13> if (!electionRequest.isSetLastLogIndex()) { <line14> electionRequest.setLastLogTerm(localMember.getLogManager().getLastLogTerm()); <line15> electionRequest.setLastLogIndex(localMember.getLogManager().getLastLogIndex()); <line16> } <line17> requestVote( <line18> localMember.getAllNodes(), <line19> electionRequest, <line20> nextTerm, <line21> quorum, <line22> electionTerminated, <line23> electionValid, <line24> failingVoteCounter); <line25> electionRequest.unsetLastLogIndex(); <line26> try { <line27> localMember.getTerm().wait(RaftServer.getConnectionTimeoutInMS()); <line28> } catch (InterruptedException e) { <line29> Thread.currentThread().interrupt(); <line30> } <line31> electionTerminated.set(true); <line32> if (electionValid.get()) { <line33> localMember.setCharacter(NodeCharacter.LEADER); <line34> localMember.setLeader(localMember.getThisNode()); <line35> } <line36> } <line37> } <line38> } <line39> "	<line7>, <line27>, <line29>, <line33>
7054	"public class A { <line0> public List findByExample(FilterResMas instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.FilterResMas"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	<line1>, <line8>, <line10>
7055	public class A { <line0> @Override <line1> public boolean doesInvoicePassValidation(final ContractsGrantsInvoiceDocument document) { <line2> try { <line3> final Boolean result = <line4> GlobalVariables.doInNewGlobalVariables( <line5> new UserSession( <line6> getContractsGrantsInvoiceBatchCreationUserPrincipal().getPrincipalName()), <line7> new Callable<Boolean>() { <line8> @Override <line9> public Boolean call() throws Exception { <line10> final AttributedRouteDocumentEvent routeEvent = <line11> new AttributedRouteDocumentEvent(document); <line12> getKualiRuleService().applyRules(routeEvent); <line13> return Boolean.valueOf(!GlobalVariables.getMessageMap().hasErrors()); <line14> } <line15> }); <line16> return result.booleanValue(); <line17> } catch (Exception e) { <line18> return false; <line19> } <line20> } <line21> } <line22> 	<line18>
7056	public class A { <line0> protected void addEvent(final ProvenanceEventRecord event, final StorageSummary location) { <line1> for (final CachedQuery cachedQuery : cachedQueries) { <line2> cachedQuery.update(event, location); <line3> } <line4> final Document document = eventConverter.convert(event, location); <line5> if (document == null) { <line6> } else { <line7> final StoredDocument doc = new StoredDocument(document, location); <line8> boolean added = false; <line9> while (!added && !closed) { <line10> added = documentQueue.offer(doc); <line11> if (!added) { <line12> final long start = System.nanoTime(); <line13> try { <line14> added = documentQueue.offer(doc, 1, TimeUnit.SECONDS); <line15> } catch (final InterruptedException e) { <line16> Thread.currentThread().interrupt(); <line17> return; <line18> } <line19> final long nanos = System.nanoTime() - start; <line20> queuePauseNanos.add(new TimestampedLong(nanos)); <line21> } <line22> if (added) { <line23> final long totalEventCount = eventCount.incrementAndGet(); <line24> if (totalEventCount % 1_000_000 == 0 && logger.isDebugEnabled()) { <line25> incrementAndReportStats(); <line26> } <line27> } <line28> } <line29> } <line30> } <line31> } <line32> 	<line6>, <line17>
7057	public class A { <line0> protected void logIndexRebuildError( <line1> Logger logger, String indexName, int total, int current, Throwable t) { <line2> } <line3> } <line4> 	<line2>
7058	public class A { <line0> public void processMessage(final ProtocolResponseMessage message) { <line1> try { <line2> synchronized (this) { <line3> this.deviceCommunicationInformationService.updateDeviceConnectionInformation(message); <line4> } <line5> } catch (final OptimisticLockException ex) { <line6> } <line7> try { <line8> if (message.isScheduled() && !message.bypassRetry()) { <line9> this.handleScheduledTask(message); <line10> } else { <line11> this.handleProtocolResponseMessage(message); <line12> } <line13> } catch (final FunctionalException e) { <line14> } <line15> } <line16> } <line17> 	<line1>, <line6>, <line9>, <line11>, <line14>
7059	"public class A { <line0> @Test(groups = {""Integration"", ""Broken""}) <line1> public void testSetsLocalBrooklynPropertiesFromContents() throws Exception { <line2> BrooklynNode brooklynNode = <line3> app.createAndManageChild( <line4> newBrooklynNodeSpecForTest() <line5> .configure( <line6> BrooklynNode.BROOKLYN_LOCAL_PROPERTIES_REMOTE_PATH, <line7> pseudoBrooklynPropertiesFile.getAbsolutePath()) <line8> .configure(BrooklynNode.BROOKLYN_LOCAL_PROPERTIES_CONTENTS, ""abc=def"")); <line9> app.start(locs); <line10> assertEquals( <line11> Files.readLines(pseudoBrooklynPropertiesFile, Charsets.UTF_8), ImmutableList.of(""abc=def"")); <line12> } <line13> } <line14> "	<line10>
7060	public class A { <line0> public void closeNote(String user, String noteId) { <line1> List<InterpreterSetting> settings = getInterpreterSettings(noteId); <line2> if (settings == null || settings.size() == 0) { <line3> return; <line4> } <line5> for (InterpreterSetting setting : settings) { <line6> removeInterpretersForNote(setting, user, noteId); <line7> } <line8> } <line9> } <line10> 	<line5>
7061	public class A { <line0> public ExchangeInfoType getExchangeInfoView() { <line1> ExchangeInfoType view = new ExchangeInfoType(); <line2> try { <line3> refreshExchangeCacheIfRequired(); <line4> view.setRefreshInterval(exInfo.getRefreshInterval()); <line5> view.setMaxNumberOfBackups(exInfo.getMaxNumberOfBackups()); <line6> view.setDefaultExchange(exInfo.getDefaultExchange()); <line7> } catch (ExchangeManagerException e) { <line8> } <line9> return view; <line10> } <line11> } <line12> 	<line8>
7062	public class A { <line0> public RuleExecutionContext createPnrApisRequestContext(final List<Message> loadedMessages) { <line1> List<Pnr> pnrList = new ArrayList<>(); <line2> List<ApisMessage> apisMessages = new ArrayList<>(); <line3> if (loadedMessages != null) { <line4> for (Message message : loadedMessages) { <line5> if (message instanceof ApisMessage) { <line6> apisMessages.add((ApisMessage) message); <line7> } else if (message instanceof Pnr) { <line8> pnrList.add((Pnr) message); <line9> } <line10> } <line11> } <line12> RuleEngineRequestBuilder bldr = applicationContext.getBean(RuleEngineRequestBuilder.class); <line13> if (!pnrList.isEmpty()) { <line14> bldr.addPnr(pnrList); <line15> } <line16> if (!apisMessages.isEmpty()) { <line17> bldr.addApisMessage(apisMessages); <line18> } <line19> RuleExecutionContext context = new RuleExecutionContext(); <line20> context.setRuleServiceRequest(bldr.build()); <line21> return context; <line22> } <line23> } <line24> 	<line1>, <line21>
7063	"public class A { <line0> protected void openContext() throws Exception { <line1> if (context == null) { <line2> try { <line3> Hashtable<String, String> env = new Hashtable<>(); <line4> env.put(Context.INITIAL_CONTEXT_FACTORY, getLDAPPropertyValue(INITIAL_CONTEXT_FACTORY)); <line5> env.put(Context.SECURITY_PROTOCOL, getLDAPPropertyValue(CONNECTION_PROTOCOL)); <line6> env.put(Context.PROVIDER_URL, getLDAPPropertyValue(CONNECTION_URL)); <line7> env.put(Context.SECURITY_AUTHENTICATION, getLDAPPropertyValue(AUTHENTICATION)); <line8> if (isLoginPropertySet(CONNECTION_POOL)) { <line9> env.put(""com.sun.jndi.ldap.connect.pool"", getLDAPPropertyValue(CONNECTION_POOL)); <line10> } <line11> if (isLoginPropertySet(CONNECTION_TIMEOUT)) { <line12> env.put(""com.sun.jndi.ldap.connect.timeout"", getLDAPPropertyValue(CONNECTION_TIMEOUT)); <line13> } <line14> if (isLoginPropertySet(READ_TIMEOUT)) { <line15> env.put(""com.sun.jndi.ldap.read.timeout"", getLDAPPropertyValue(READ_TIMEOUT)); <line16> } <line17> String referral = ""ignore""; <line18> if (getLDAPPropertyValue(REFERRAL) != null) { <line19> referral = getLDAPPropertyValue(REFERRAL); <line20> } <line21> env.put(Context.REFERRAL, referral); <line22> if (logger.isDebugEnabled()) { <line23> } <line24> if (""GSSAPI"".equalsIgnoreCase(getLDAPPropertyValue(AUTHENTICATION))) { <line25> final String configScope = <line26> isLoginPropertySet(SASL_LOGIN_CONFIG_SCOPE) <line27> ? getLDAPPropertyValue(SASL_LOGIN_CONFIG_SCOPE) <line28> : ""broker-sasl-gssapi""; <line29> try { <line30> LoginContext loginContext = new LoginContext(configScope); <line31> loginContext.login(); <line32> brokerGssapiIdentity = loginContext.getSubject(); <line33> } catch (LoginException e) { <line34> e.printStackTrace(); <line35> FailedLoginException ex = <line36> new FailedLoginException( <line37> ""Error contacting LDAP using GSSAPI in JAAS loginConfigScope: "" + configScope); <line38> ex.initCause(e); <line39> throw ex; <line40> } <line41> } else { <line42> if (isLoginPropertySet(CONNECTION_USERNAME)) { <line43> env.put(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME)); <line44> } else { <line45> throw new NamingException(""Empty username is not allowed""); <line46> } <line47> if (isLoginPropertySet(CONNECTION_PASSWORD)) { <line48> env.put( <line49> Context.SECURITY_CREDENTIALS, <line50> getPlainPassword(getLDAPPropertyValue(CONNECTION_PASSWORD))); <line51> } else { <line52> throw new NamingException(""Empty password is not allowed""); <line53> } <line54> } <line55> try { <line56> context = <line57> Subject.doAs( <line58> brokerGssapiIdentity, <line59> (PrivilegedExceptionAction<DirContext>) () -> new InitialDirContext(env)); <line60> } catch (PrivilegedActionException e) { <line61> throw e.getException(); <line62> } <line63> } catch (NamingException e) { <line64> closeContext(); <line65> ActiveMQServerLogger.LOGGER.failedToOpenContext(e); <line66> throw e; <line67> } <line68> } <line69> } <line70> } <line71> "	<line23>
7064	public class A { <line0> @Override <line1> public void messageSent(IoSession session, Object message) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>
7065	"public class A { <line0> private TestCaseStepActionControlExecution executeControl( <line1> TestCaseStepActionControlExecution testCaseStepActionControlExecution, <line2> TestCaseExecution tcExecution) { <line3> if (!tcExecution.getManualExecution().equals(""Y"")) { <line4> testCaseStepActionControlExecution = <line5> this.controlService.doControl(testCaseStepActionControlExecution); <line6> testCaseStepActionControlExecution.addFileList( <line7> recorderService.recordExecutionInformationAfterStepActionandControl( <line8> testCaseStepActionControlExecution.getTestCaseStepActionExecution(), <line9> testCaseStepActionControlExecution)); <line10> } else { <line11> testCaseStepActionControlExecution.setControlResultMessage( <line12> new MessageEvent(MessageEventEnum.CONTROL_WAITINGEXECUTION)); <line13> testCaseStepActionControlExecution.setExecutionResultMessage( <line14> new MessageGeneral(MessageGeneralEnum.EXECUTION_WE)); <line15> testCaseStepActionControlExecution.setEnd(new Date().getTime()); <line16> } <line17> this.testCaseStepActionControlExecutionService.updateTestCaseStepActionControlExecution( <line18> testCaseStepActionControlExecution); <line19> updateTCExecutionWebSocketOnly(tcExecution, false); <line20> return testCaseStepActionControlExecution; <line21> } <line22> } <line23> "	<line17>, <line19>
7066	"public class A { <line0> public XmldbURI createCollection(String name) <line1> throws PermissionDeniedException, CollectionExistsException, EXistException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> XmldbURI newCollection = xmldbUri.append(name); <line5> final TransactionManager txnManager = brokerPool.getTransactionManager(); <line6> try (final DBBroker broker = brokerPool.get(Optional.ofNullable(subject)); <line7> final Txn txn = txnManager.beginTransaction(); <line8> final Collection collection = broker.openCollection(newCollection, LockMode.WRITE_LOCK)) { <line9> if (collection != null) { <line10> final String msg = ""Collection already exists""; <line11> txnManager.abort(txn); <line12> throw new CollectionExistsException(msg); <line13> } <line14> try (final Collection created = broker.getOrCreateCollection(txn, newCollection)) { <line15> broker.saveCollection(txn, created); <line16> broker.flush(); <line17> txnManager.commit(txn); <line18> if (LOG.isDebugEnabled()) { <line19> } <line20> } <line21> } catch (EXistException | PermissionDeniedException e) { <line22> LOG.error(e); <line23> throw e; <line24> } catch (Throwable e) { <line25> throw new EXistException(e); <line26> } finally { <line27> if (LOG.isDebugEnabled()) { <line28> } <line29> } <line30> return newCollection; <line31> } <line32> } <line33> "	<line3>, <line11>, <line19>, <line25>, <line28>
7067	public class A { <line0> public final boolean addChildAction(BasicAction act) { <line1> if (tsLogger.logger.isTraceEnabled()) { <line2> } <line3> if (act == null) return false; <line4> boolean result = false; <line5> criticalStart(); <line6> synchronized (this) { <line7> if (actionStatus <= ActionStatus.ABORTING) { <line8> if (_childActions == null) _childActions = new Hashtable<BasicAction, BasicAction>(); <line9> _childActions.put(act, act); <line10> result = true; <line11> } <line12> } <line13> criticalEnd(); <line14> if (tsLogger.logger.isTraceEnabled()) { <line15> } <line16> return result; <line17> } <line18> } <line19> 	<line2>, <line15>
7068	public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> super.handleCommand(channelUID, command); <line3> if (DISH_WARMER_PROGRAM_ACTIVE.equals(channelUID.getId()) && command instanceof StringType) { <line4> try { <line5> triggerProgram(Long.parseLong(command.toString())); <line6> } catch (NumberFormatException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
7069	"public class A { <line0> private BigDecimal readSensorTemperature(String gpioFile) { <line1> try (Stream<String> stream = Files.lines(Paths.get(gpioFile))) { <line2> Optional<String> temperatureLine = <line3> stream.filter(s -> s.contains(OneWireGPIOBindingConstants.FILE_TEMP_MARKER)).findFirst(); <line4> if (temperatureLine.isPresent()) { <line5> String line = temperatureLine.get(); <line6> String tempString = <line7> line.substring( <line8> line.indexOf(OneWireGPIOBindingConstants.FILE_TEMP_MARKER) <line9> + OneWireGPIOBindingConstants.FILE_TEMP_MARKER.length()); <line10> Integer intTemp = Integer.parseInt(tempString); <line11> if (getThing().getStatus() != ThingStatus.ONLINE) { <line12> updateStatus(ThingStatus.ONLINE); <line13> } <line14> return calculateValue(intTemp); <line15> } else { <line16> return null; <line17> } <line18> } catch (IOException | InvalidPathException e) { <line19> updateStatus( <line20> ThingStatus.OFFLINE, <line21> ThingStatusDetail.COMMUNICATION_ERROR, <line22> ""Error reading GPIO bus file.""); <line23> return null; <line24> } <line25> } <line26> } <line27> "	<line16>, <line19>
7070	"public class A { <line0> @Test <line1> public void testBrowseByteMessageFails() throws Exception { <line2> ActiveMQBytesMessage bm = new ActiveMQBytesMessage(); <line3> bm.writeBytes(""123456"".getBytes()); <line4> Object result = OpenTypeSupport.convert(bm); <line5> } <line6> } <line7> "	<line5>
7071	public class A { <line0> private void translationDocumentUpdated(XWikiDocument document) { <line1> if (!document.getOriginalDocument().isNew()) { <line2> unregisterTranslationBundle(document.getOriginalDocument()); <line3> } <line4> if (!document.isNew()) { <line5> try { <line6> registerTranslationBundle(document); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> } <line12> 	<line8>
7072	public class A { <line0> public void updateCallback(Map<String, Object> properties) { <line1> if (properties != null) { <line2> if (!checkMetaTypeClass(properties, METATYPE_MONITORED_ADDRESS, String.class)) { <line3> return; <line4> } <line5> if (properties.containsKey(METATYPE_NETWORK_INTERFACE) <line6> && !checkMetaTypeClass(properties, METATYPE_NETWORK_INTERFACE, String.class)) { <line7> return; <line8> } <line9> if (!checkMetaTypeClass(properties, METATYPE_BYTE_COUNT_ROLLOVER_CONDITION, Integer.class)) { <line10> return; <line11> } <line12> if (!checkMetaTypeClass(properties, METATYPE_ELAPSED_TIME_ROLLOVER_CONDITION, Long.class)) { <line13> return; <line14> } <line15> if (!checkMetaTypeClass(properties, METATYPE_FILENAME_TEMPLATE, String.class)) { <line16> return; <line17> } <line18> if (!checkMetaTypeClass(properties, METATYPE_PARENT_TITLE, String.class)) { <line19> return; <line20> } <line21> if (!checkMetaTypeClass(properties, METATYPE_METACARD_UPDATE_INITIAL_DELAY, Long.class)) { <line22> return; <line23> } <line24> if (!checkMetaTypeClass(properties, METATYPE_TITLE, String.class)) { <line25> return; <line26> } <line27> if (properties.containsKey(METATYPE_DISTANCE_TOLERANCE) <line28> && properties.get(METATYPE_DISTANCE_TOLERANCE) != null <line29> && !checkMetaTypeClass(properties, METATYPE_DISTANCE_TOLERANCE, Double.class)) { <line30> return; <line31> } <line32> setMonitoredAddress((String) properties.get(METATYPE_MONITORED_ADDRESS)); <line33> setNetworkInterface((String) properties.get(METATYPE_NETWORK_INTERFACE)); <line34> setMegabyteCountRolloverCondition( <line35> (Integer) properties.get(METATYPE_BYTE_COUNT_ROLLOVER_CONDITION)); <line36> setElapsedTimeRolloverCondition( <line37> (Long) properties.get(METATYPE_ELAPSED_TIME_ROLLOVER_CONDITION)); <line38> setFilenameTemplate((String) properties.get(METATYPE_FILENAME_TEMPLATE)); <line39> setMetacardUpdateInitialDelay((Long) properties.get(METATYPE_METACARD_UPDATE_INITIAL_DELAY)); <line40> setParentTitle((String) properties.get(METATYPE_PARENT_TITLE)); <line41> setDistanceTolerance((Double) properties.get(METATYPE_DISTANCE_TOLERANCE)); <line42> init(); <line43> } <line44> } <line45> } <line46> 	<line1>
7073	public class A { <line0> public void phaseEnded(ConstructionHeuristicPhaseScope<Solution_> phaseScope) { <line1> super.phaseEnded(phaseScope); <line2> if (skipBestSolutionCloningInSteps) { <line3> bestSolutionRecaller.updateBestSolution(phaseScope.getSolverScope()); <line4> } <line5> entityPlacer.phaseEnded(phaseScope); <line6> decider.phaseEnded(phaseScope); <line7> phaseScope.endingNow(); <line8> } <line9> } <line10> 	<line8>
7074	"public class A { <line0> @Override <line1> public void onEvent(SensorEvent<Object> event) { <line2> AttributeSensor<Boolean> sensor = config().get(START_SENSOR); <line3> if (event.getSensor().getName().equals(sensor.getName())) { <line4> boolean start = Boolean.TRUE.equals(event.getValue()); <line5> if (start && running.compareAndSet(false, true)) { <line6> config().set(RUNNING, true); <line7> highlightConfirmation(""Starting effector invocation schedule""); <line8> start(); <line9> } <line10> } <line11> AttributeSensor<Boolean> sensor2 = config().get(ENABLED_SENSOR); <line12> if (sensor2 != null && event.getSensor().getName().equals(sensor2.getName())) { <line13> boolean enable = Boolean.TRUE.equals(event.getValue()); <line14> if (running.compareAndSet(!enable, enable)) { <line15> config().set(RUNNING, enable); <line16> if (enable) { <line17> highlightConfirmation(""Resuming effector invocation schedule""); <line18> resume(); <line19> } else { <line20> highlightViolation(""Suspending effector invocation""); <line21> suspend(); <line22> } <line23> } <line24> } <line25> } <line26> } <line27> "	<line2>
7075	"public class A { <line0> @SuppressWarnings(""rawtypes"") <line1> @Override <line2> public void bind() { <line3> BaseBind packet = null; <line4> if (config.getType() == SmppBindType.TRANSCEIVER) packet = new BindTransceiver(); <line5> else if (config.getType() == SmppBindType.RECEIVER) packet = new BindReceiver(); <line6> else if (config.getType() == SmppBindType.TRANSMITTER) packet = new BindTransmitter(); <line7> packet.setSystemId(config.getSystemId()); <line8> packet.setPassword(config.getPassword()); <line9> packet.setSystemType(config.getSystemType()); <line10> packet.setInterfaceVersion(config.getInterfaceVersion()); <line11> packet.setAddressRange(config.getAddressRange()); <line12> packet.setSequenceNumber(lastSequenceNumberSent.incrementAndGet()); <line13> ChannelBuffer buffer = null; <line14> try { <line15> buffer = transcoder.encode(packet); <line16> } catch (UnrecoverablePduException e) { <line17> logger.error(""Encode error: "", e); <line18> } catch (RecoverablePduException e) { <line19> } <line20> if (clientState != ClientState.REBINDING) clientState = ClientState.BINDING; <line21> if (logger.isDebugEnabled()) <line22> channel.write(buffer); <line23> } <line24> } <line25> "	<line19>, <line22>
7076	public class A { <line0> private void deregisterService() { <line1> for (ServiceRegistration<?> serviceRegistration : targetServiceRegistrations) { <line2> if (serviceRegistration != null) { <line3> ServiceReference<?> reference = serviceRegistration.getReference(); <line4> context.ungetService(reference); <line5> } <line6> } <line7> } <line8> } <line9> 	<line4>
7077	"public class A { <line0> private void setSession() { <line1> JSch ssh; <line2> boolean success = waitActive(SESSION_CONNECT_TIMEOUT); <line3> if (!success) { <line4> } <line5> try { <line6> Thread.sleep(30000); <line7> ssh = new JSch(); <line8> ssh.addIdentity(value.getSshKeyFile()); <line9> session = ssh.getSession(Utils.DEFAULT_USER, value.getPublicIpAddress()); <line10> session.setConfig(""StrictHostKeyChecking"", ""no""); <line11> session.connect(); <line12> } catch (Exception e) { <line13> session = null; <line14> } <line15> } <line16> } <line17> "	<line4>, <line13>
7078	public class A { <line0> @Override <line1> public void pushTaskLog(final String taskid, final File logFile) throws IOException { <line2> final String taskKey = getTaskLogKey(taskid); <line3> pushTaskFile(logFile, taskKey); <line4> } <line5> } <line6> 	<line3>
7079	public class A { <line0> protected void activate( <line1> final ComponentContext componentContext, final Map<String, Object> properties) { <line2> this.properties = properties; <line3> this.wireSupport = <line4> this.wireHelperService.newWireSupport( <line5> this, (ServiceReference<WireComponent>) componentContext.getServiceReference()); <line6> } <line7> } <line8> 	<line2>, <line6>
7080	"public class A { <line0> @Deprecated <line1> public static ManagementContext startManagement(Application app, ManagementContext mgmt) { <line2> if (isManaged(app)) { <line3> if (app.getManagementContext() == mgmt) { <line4> return mgmt; <line5> } else { <line6> throw new IllegalStateException( <line7> ""Application "" <line8> + app <line9> + "" is already managed by "" <line10> + app.getManagementContext() <line11> + "", so cannot be managed by "" <line12> + mgmt); <line13> } <line14> } <line15> mgmt.getEntityManager().manage(app); <line16> return mgmt; <line17> } <line18> } <line19> "	<line2>
7081	public class A { <line0> @Override <line1> public void terminate( <line2> BatchRunContext batchRunContext, <line3> List<String> all, <line4> long errors, <line5> long unhandled_errors, <line6> long total, <line7> long processed) { <line8> long success = total - errors - unhandled_errors; <line9> if (errors > 0) { <line10> } <line11> if (unhandled_errors > 0) { <line12> } <line13> } <line14> } <line15> 	<line9>, <line10>, <line12>, <line13>
7082	"public class A { <line0> @Override <line1> public void cancelDelegationToken(Token<OzoneTokenIdentifier> token) throws OMException { <line2> OzoneTokenIdentifier id = null; <line3> try { <line4> String canceller = getRemoteUser().getUserName(); <line5> id = delegationTokenMgr.cancelToken(token, canceller); <line6> } catch (OMException oex) { <line7> throw oex; <line8> } catch (IOException ex) { <line9> throw new OMException( <line10> ""Delegation token renewal failed for dt: "" + token, ex, TOKEN_ERROR_OTHER); <line11> } <line12> } <line13> } <line14> "	<line6>, <line9>
7083	public class A { <line0> public String configContentType() { <line1> try { <line2> Widget showlet = super.createNewShowlet(); <line3> showlet <line4> .getConfig() <line5> .setProperty(IContentListWidgetHelper.WIDGET_PARAM_CONTENT_TYPE, this.getContentType()); <line6> this.setShowlet(showlet); <line7> } catch (Throwable t) { <line8> return FAILURE; <line9> } <line10> return SUCCESS; <line11> } <line12> } <line13> 	<line8>
7084	public class A { <line0> @Override <line1> public void onWireReceive(final WireEnvelope envelope) { <line2> withContext( <line3> context -> { <line4> try { <line5> processReceive(context, envelope); <line6> } catch (final Exception e) { <line7> } <line8> }); <line9> } <line10> } <line11> 	<line2>, <line7>
7085	"public class A { <line0> private void decrementNumberOfUsers(int subpartitionIndex) { <line1> if (isReleased()) { <line2> return; <line3> } <line4> final int remainingUnconsumed; <line5> synchronized (releaseLock) { <line6> if (subpartitionIndex != PIPELINED_RESULT_PARTITION_ITSELF) { <line7> if (consumedSubpartitions[subpartitionIndex]) { <line8> return; <line9> } <line10> consumedSubpartitions[subpartitionIndex] = true; <line11> } <line12> remainingUnconsumed = (--numberOfUsers); <line13> } <line14> if (remainingUnconsumed == 0) { <line15> partitionManager.onConsumedPartition(this); <line16> } else if (remainingUnconsumed < 0) { <line17> throw new IllegalStateException( <line18> ""Received consume notification even though all subpartitions are already consumed.""); <line19> } <line20> } <line21> } <line22> "	<line14>
7086	"public class A { <line0> @Test <line1> public void test_01() { <line2> String genome = ""test_NC_045512_01""; <line3> SnpEffCmdBuild buildCmd = buildGetBuildCmd(genome); <line4> SnpEffCmdProtein protCmd = buildCmd.getSnpEffCmdProtein(); <line5> Assert.assertEquals(5, protCmd.getTotalOk()); <line6> Assert.assertEquals(0, protCmd.getTotalErrors()); <line7> Assert.assertEquals(0, protCmd.getTotalWarnings()); <line8> } <line9> } <line10> "	<line2>
7087	"public class A { <line0> @Override <line1> public void process(Channel channel, Command command) { <line2> Preconditions.checkArgument( <line3> CommandType.TASK_EXECUTE_RESPONSE == command.getType(), <line4> String.format(""invalid command type : %s"", command.getType())); <line5> TaskExecuteResponseCommand responseCommand = <line6> JSONUtils.parseObject(command.getBody(), TaskExecuteResponseCommand.class); <line7> taskInstanceCacheManager.cacheTaskInstance(responseCommand); <line8> TaskResponseEvent taskResponseEvent = <line9> TaskResponseEvent.newResult( <line10> ExecutionStatus.of(responseCommand.getStatus()), <line11> responseCommand.getEndTime(), <line12> responseCommand.getProcessId(), <line13> responseCommand.getAppIds(), <line14> responseCommand.getTaskInstanceId(), <line15> responseCommand.getVarPool(), <line16> channel, <line17> responseCommand.getResult()); <line18> taskResponseService.addResponse(taskResponseEvent); <line19> } <line20> } <line21> "	<line7>
7088	"public class A { <line0> private Path distCpDirectory(Path jobDirectory) throws Exception { <line1> FileSystem src = getFileSystem(srcHdfs); <line2> FileSystem dest = getFileSystem(destHdfs); <line3> if (!src.equals(dest)) { <line4> Path srcPath = src.makeQualified(new Path(jobDirectory.toUri().getPath())); <line5> Path destPath = dest.makeQualified(new Path(jobDirectory.toUri().getPath())); <line6> Path logPath = new Path(destPath, ""logs""); <line7> dest.delete(destPath, true); <line8> DistCpOptions options = <line9> new DistCpOptions.Builder(srcPath, destPath) <line10> .withLogPath(logPath) <line11> .withSyncFolder(true) <line12> .preserve(DistCpOptions.FileAttribute.USER) <line13> .preserve(DistCpOptions.FileAttribute.GROUP) <line14> .preserve(DistCpOptions.FileAttribute.PERMISSION) <line15> .build(); <line16> String[] args = (jobtracker == null) ? new String[0] : new String[] {""-jt"", jobtracker}; <line17> int res = ToolRunner.run(conf, new DistCp(conf, options), args); <line18> if (res != 0) { <line19> throw new RuntimeException(""Failed to DistCp: "" + res); <line20> } else { <line21> Map<String, FileStatus> destFiles = new HashMap<>(); <line22> for (FileStatus destFile : dest.listStatus(destPath)) { <line23> destFiles.put(destFile.getPath().getName(), destFile); <line24> } <line25> for (FileStatus srcFile : src.listStatus(srcPath)) { <line26> FileStatus destFile = destFiles.get(srcFile.getPath().getName()); <line27> if (destFile == null || destFile.getLen() != srcFile.getLen()) { <line28> throw new RuntimeException(""Failed to DistCp "" + srcFile.getPath()); <line29> } <line30> } <line31> } <line32> src.delete(jobDirectory, true); <line33> return destPath; <line34> } <line35> return jobDirectory; <line36> } <line37> } <line38> "	<line7>, <line19>, <line28>
7089	"public class A { <line0> @Override <line1> public String parse(String expression, CoreEvent event, ComponentLocation componentLocation) <line2> throws ExpressionRuntimeException { <line3> Builder eventBuilder = CoreEvent.builder(event); <line4> if ((!hasDwExpression(expression) && !hasMelExpression(expression) && melDefault) <line5> || hasMelExpression(expression)) { <line6> return parser.parse( <line7> token -> melParseEvaluation(event, componentLocation, eventBuilder, token), expression); <line8> } else if (isExpression(expression)) { <line9> TypedValue evaluation = evaluate(expression, event, eventBuilder, componentLocation); <line10> try { <line11> return (String) transform(evaluation, evaluation.getDataType(), STRING).getValue(); <line12> } catch (TransformerException e) { <line13> throw new ExpressionRuntimeException( <line14> createStaticMessage( <line15> format(""Failed to transform %s to %s."", evaluation.getDataType(), STRING)), <line16> e); <line17> } <line18> } else { <line19> if (LOGGER.isDebugEnabled()) { <line20> } <line21> return expression; <line22> } <line23> } <line24> } <line25> "	<line6>, <line20>
7090	public class A { <line0> static CSVDataSource getDataSource(Node sourceNode) { <line1> CSVDataSource dataSource = null; <line2> String nodeName = sourceNode.getNodeName(); <line3> if (CSVDataSource.class.getSimpleName().equals(nodeName)) { <line4> try { <line5> dataSource = <line6> XMLUtilities.readXMLObject(sourceNode, CONTEXT_SUPPLIER.get(), CSVDataSource.class); <line7> } catch (JAXBException e) { <line8> } <line9> } <line10> return dataSource; <line11> } <line12> } <line13> 	<line8>
7091	"public class A { <line0> private JsonObject convertStringToJsonObject(String jsonString) { <line1> try { <line2> JsonElement jsonElement = JsonParser.parseString(jsonString); <line3> JsonObject result; <line4> if (jsonElement instanceof JsonObject) { <line5> result = jsonElement.getAsJsonObject(); <line6> } else { <line7> result = new JsonObject(); <line8> throw new IllegalArgumentException(jsonString + ""{} is not valid JSON stirng""); <line9> } <line10> return result; <line11> } catch (IllegalArgumentException e) { <line12> JsonObject result = new JsonObject(); <line13> return result; <line14> } <line15> } <line16> } <line17> "	<line7>
7092	"public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (command instanceof RefreshType) { <line3> updateChannels(); <line4> return; <line5> } <line6> switch (channelUID.getId()) { <line7> case CHANNEL_CONSOLE_ENABLE_DISABLE_BEEPER: <line8> if (command instanceof StringType) { <line9> sendOmnilinkCommand( <line10> CommandMessage.CMD_CONSOLE_ENABLE_DISABLE_BEEPER, <line11> ((StringType) command).equals(StringType.valueOf(""OFF"")) ? 0 : 1, <line12> thingID); <line13> } else { <line14> } <line15> break; <line16> case CHANNEL_CONSOLE_BEEP: <line17> if (command instanceof DecimalType) { <line18> sendOmnilinkCommand( <line19> CommandMessage.CMD_CONSOLE_BEEP, ((DecimalType) command).intValue(), thingID); <line20> } else { <line21> } <line22> break; <line23> default: <line24> } <line25> updateChannels(); <line26> } <line27> } <line28> "	<line2>, <line14>, <line21>, <line24>
7093	"public class A { <line0> public static com.liferay.commerce.product.model.CPOptionValue fetchByExternalReferenceCode( <line1> HttpPrincipal httpPrincipal, String externalReferenceCode, long companyId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CPOptionValueServiceUtil.class, <line7> ""fetchByExternalReferenceCode"", <line8> _fetchByExternalReferenceCodeParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, externalReferenceCode, companyId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.product.model.CPOptionValue) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>
7094	"public class A { <line0> private void stopTest() { <line1> stopTries++; <line2> if (JMeter.isNonGUI()) { <line3> stopTestViaUDP(""StopTestNow""); <line4> } else { <line5> if (stopTries > 10) { <line6> StandardJMeterEngine.stopEngineNow(); <line7> } else if (stopTries > 5) { <line8> StandardJMeterEngine.stopEngine(); <line9> } else { <line10> JMeterContextService.getContext().getEngine().askThreadsToStop(); <line11> } <line12> } <line13> } <line14> } <line15> "	<line3>, <line6>, <line8>
7095	public class A { <line0> @Override <line1> public BufferedImage getImage(final IFeature feature) { <line2> if (feature == null) { <line3> if (this.featureToImageMap.isEmpty()) { <line4> return null; <line5> } <line6> return this.featureToImageMap.values().iterator().next(); <line7> } <line8> return this.featureToImageMap.get(feature); <line9> } <line10> } <line11> 	<line2>
7096	public class A { <line0> @Override <line1> protected final void onStreamError( <line2> ChannelHandlerContext ctx, <line3> boolean outbound, <line4> Throwable cause, <line5> Http2Exception.StreamException streamException) { <line6> int streamId = streamException.streamId(); <line7> Http2Stream connectionStream = connection().stream(streamId); <line8> if (connectionStream == null) { <line9> onHttp2UnknownStreamError(ctx, cause, streamException); <line10> super.onStreamError(ctx, outbound, cause, streamException); <line11> return; <line12> } <line13> Http2FrameStream stream = connectionStream.getProperty(streamKey); <line14> if (stream == null) { <line15> super.onStreamError(ctx, outbound, cause, streamException); <line16> return; <line17> } <line18> if (!outbound) { <line19> onHttp2FrameStreamException( <line20> } <line21> } <line22> } <line23> 	<line15>, <line20>
7097	public class A { <line0> @Override <line1> public void clear(boolean clearSpace) { <line2> this.checkClusterConnected(); <line3> if (this.existsKeyspace()) { <line4> if (!clearSpace) { <line5> this.checkOpened(); <line6> this.clearTables(); <line7> } else { <line8> this.clearKeyspace(); <line9> } <line10> } <line11> } <line12> } <line13> 	<line11>
7098	"public class A { <line0> public static void main(String[] args) throws Exception { <line1> Logging.initialize(); <line2> DistributedQueryRunner queryRunner = <line3> createClickHouseQueryRunner( <line4> new TestingClickHouseServer(), <line5> ImmutableMap.of(""http-server.http.port"", ""8080""), <line6> ImmutableMap.of(), <line7> TpchTable.getTables()); <line8> Logger log = Logger.get(ClickHouseQueryRunner.class); <line9> } <line10> } <line11> "	<line9>
7099	"public class A { <line0> public void exportCsv(final Writer writer) { <line1> final CsvConfig cfg = new CsvConfig(',', '""', '""'); <line2> cfg.setEscapeDisabled(false); <line3> cfg.setQuoteDisabled(false); <line4> @SuppressWarnings(""resource"") <line5> final CsvWriter csvWriter = new CsvWriter(writer, cfg); <line6> try { <line7> final List<String> list = new ArrayList<>(); <line8> list.add(""BadWord""); <line9> csvWriter.writeValues(list); <line10> badWordBhv.selectCursor( <line11> cb -> cb.query().matchAll(), <line12> new EntityRowHandler<BadWord>() { <line13> @Override <line14> public void handle(final BadWord entity) { <line15> final List<String> list = new ArrayList<>(); <line16> addToList(list, entity.getSuggestWord()); <line17> try { <line18> csvWriter.writeValues(list); <line19> } catch (final IOException e) { <line20> } <line21> } <line22>  <line23> private void addToList(final List<String> list, final Object value) { <line24> if (value == null) { <line25> list.add(StringUtil.EMPTY); <line26> } else { <line27> list.add(value.toString()); <line28> } <line29> } <line30> }); <line31> csvWriter.flush(); <line32> } catch (final IOException e) { <line33> } <line34> } <line35> } <line36> "	<line20>, <line33>
7100	public class A { <line0> public static UnconfiguredRendererEndpoint assembleNotConfigurableRendererEPForPeer( <line1> final PolicyConfigurationContext context, <line2> final PeerEndpoint peerEndpoint, <line3> final String info) { <line4> final RendererEndpoint rendererEndpoint = context.getCurrentRendererEP(); <line5> return new UnconfiguredRendererEndpointBuilder(rendererEndpoint) <line6> .setUnconfiguredPeerEndpoint(assemblePeerEndpoint(Stream.of(peerEndpoint), context)) <line7> .setInfo(info) <line8> .build(); <line9> } <line10> } <line11> 	<line5>
7101	"public class A { <line0> @Override <line1> public BaseStruct methodWithStructTypeDefParameter(BaseStruct structTypeDefIn) { <line2> logger.info(""****************************************************""); <line3> return structTypeDefIn; <line4> } <line5> } <line6> "	<line3>
7102	"public class A { <line0> public synchronized void startMaintenance(DatanodeDetails dn, int endInHours) <line1> throws NodeNotFoundException, InvalidNodeStateException { <line2> NodeStatus nodeStatus = getNodeStatus(dn); <line3> NodeOperationalState opState = nodeStatus.getOperationalState(); <line4> long maintenanceEnd = 0; <line5> if (endInHours != 0) { <line6> maintenanceEnd = (System.currentTimeMillis() / 1000L) + (endInHours * 60L * 60L); <line7> } <line8> HddsProtos.NodeState health = nodeStatus.getHealth(); <line9> if (opState == NodeOperationalState.IN_SERVICE) { <line10> if (health != HddsProtos.NodeState.DEAD) { <line11> nodeManager.setNodeOperationalState( <line12> dn, NodeOperationalState.ENTERING_MAINTENANCE, maintenanceEnd); <line13> monitor.startMonitoring(dn); <line14> } else { <line15> nodeManager.setNodeOperationalState(dn, NodeOperationalState.IN_MAINTENANCE); <line16> } <line17> } else if (nodeStatus.isMaintenance()) { <line18> } else { <line19> throw new InvalidNodeStateException( <line20> ""Cannot start maintenance on node "" + dn + "" in state "" + opState); <line21> } <line22> } <line23> } <line24> "	<line14>, <line15>, <line18>, <line19>
7103	public class A { <line0> @Override <line1> void abort() { <line2> offsets.clear(); <line3> entryLogger.removeCurCompactionLog(); <line4> if (compactedLogFile != null && compactedLogFile.exists()) { <line5> if (!compactedLogFile.delete()) { <line6> } <line7> } <line8> } <line9> } <line10> 	<line6>
7104	"public class A { <line0> private void createTarballTargetFolder(String targetFolder) { <line1> String createFolderCommand = String.format(""sudo mkdir -p %s"", targetFolder); <line2> int resultOfCommand = <line3> getMachine().execCommands(""create target folder"", ImmutableList.of(createFolderCommand)); <line4> if (resultOfCommand != 0) { <line5> } <line6> } <line7> } <line8> "	<line5>
7105	"public class A { <line0> private TraceEntry start(boolean completeAsyncTransaction) { <line1> ThreadContextThreadLocal.Holder threadContextHolder = <line2> transactionRegistry.getCurrentThreadContextHolder(); <line3> ThreadContextImpl context = (ThreadContextImpl) threadContextHolder.get(); <line4> if (context != null) { <line5> if (completeAsyncTransaction) { <line6> context.setTransactionAsyncComplete(); <line7> } <line8> return NopTransactionService.TRACE_ENTRY; <line9> } <line10> context = <line11> transactionService.startAuxThreadContextInternal( <line12> transaction, <line13> parentTraceEntry, <line14> parentThreadContextPriorEntry, <line15> servletRequestInfo, <line16> threadContextHolder); <line17> if (context == null) { <line18> return NopTransactionService.TRACE_ENTRY; <line19> } <line20> if (logger.isDebugEnabled() <line21> && !Thread.currentThread().getName().startsWith(""Glowroot-GRPC-"") <line22> && inAuxDebugLogging.get() == null) { <line23> inAuxDebugLogging.set(Boolean.TRUE); <line24> try { <line25> } finally { <line26> inAuxDebugLogging.remove(); <line27> } <line28> } <line29> if (completeAsyncTransaction) { <line30> context.setTransactionAsyncComplete(); <line31> } <line32> TraceEntryImpl rootEntry = context.getRootEntry(); <line33> if (locationStackTrace != null) { <line34> rootEntry.setLocationStackTrace(locationStackTrace); <line35> } <line36> return rootEntry; <line37> } <line38> } <line39> "	<line25>
7106	public class A { <line0> static long getLastTimeStamp(MeasurementMNode node, QueryContext queryContext) { <line1> TimeValuePair last = node.getCachedLast(); <line2> if (last != null) { <line3> return node.getCachedLast().getTimestamp(); <line4> } else { <line5> try { <line6> QueryDataSource dataSource = <line7> QueryResourceManager.getInstance() <line8> .getQueryDataSource(node.getPartialPath(), queryContext, null); <line9> Set<String> measurementSet = new HashSet<>(); <line10> measurementSet.add(node.getPartialPath().getFullPath()); <line11> LastPointReader lastReader = <line12> new LastPointReader( <line13> node.getPartialPath(), <line14> node.getSchema().getType(), <line15> measurementSet, <line16> queryContext, <line17> dataSource, <line18> Long.MAX_VALUE, <line19> null); <line20> last = lastReader.readLastPoint(); <line21> return (last != null ? last.getTimestamp() : Long.MIN_VALUE); <line22> } catch (Exception e) { <line23> return Long.MIN_VALUE; <line24> } <line25> } <line26> } <line27> } <line28> 	<line23>
7107	public class A { <line0> public static List<Map<String, Object>> doScan(String tableName, KuduClient connection) <line1> throws KuduException { <line2> KuduTable table = connection.openTable(tableName); <line3> List<String> projectColumns = new ArrayList<>(1); <line4> for (ColumnSchema columnSchema : table.getSchema().getColumns()) { <line5> projectColumns.add(columnSchema.getName()); <line6> } <line7> KuduScanner scanner = <line8> connection.newScannerBuilder(table).setProjectedColumnNames(projectColumns).build(); <line9> return KuduUtils.scannerToList(table, scanner); <line10> } <line11> } <line12> 	<line2>
7108	"public class A { <line0> private Set<PeerStatus> fetchRemotePeerStatuses() throws IOException { <line1> final Set<PeerDescription> peersToRequestClusterInfoFrom = new HashSet<>(); <line2> final Set<PeerStatus> lastFetched = lastFetchedQueryablePeers; <line3> if (lastFetched != null && !lastFetched.isEmpty()) { <line4> lastFetched.stream() <line5> .map(peer -> peer.getPeerDescription()) <line6> .forEach(desc -> peersToRequestClusterInfoFrom.add(desc)); <line7> } <line8> peersToRequestClusterInfoFrom.add(peerStatusProvider.getBootstrapPeerDescription()); <line9> Exception lastFailure = null; <line10> for (final PeerDescription peerDescription : peersToRequestClusterInfoFrom) { <line11> try { <line12> final Set<PeerStatus> statuses = <line13> peerStatusProvider.fetchRemotePeerStatuses(peerDescription); <line14> lastFetchedQueryablePeers = <line15> statuses.stream().filter(p -> p.isQueryForPeers()).collect(Collectors.toSet()); <line16> return statuses; <line17> } catch (final Exception e) { <line18> lastFailure = e; <line19> } <line20> } <line21> final IOException ioe = <line22> new IOException( <line23> ""Unable to communicate with remote NiFi cluster in order to determine which nodes exist"" <line24> + "" in the remote cluster""); <line25> if (lastFailure != null) { <line26> ioe.addSuppressed(lastFailure); <line27> } <line28> throw ioe; <line29> } <line30> } <line31> "	<line9>, <line18>
7109	"public class A { <line0> @Override <line1> protected void body() throws InterruptedException { <line2> AddressResponse res; <line3> try { <line4> res = new AddressResponse(addrs); <line5> } catch (IgniteCheckedException e) { <line6> return; <line7> } <line8> byte[] reqData = new byte[MSG_ADDR_REQ_DATA.length]; <line9> DatagramPacket pckt = new DatagramPacket(reqData, reqData.length); <line10> while (!isInterrupted()) { <line11> try { <line12> MulticastSocket sock; <line13> synchronized (this) { <line14> if (isInterrupted()) return; <line15> sock = this.sock; <line16> if (sock == null) sock = createSocket(); <line17> } <line18> sock.receive(pckt); <line19> if (!U.bytesEqual(U.IGNITE_HEADER, 0, reqData, 0, U.IGNITE_HEADER.length)) { <line20> continue; <line21> } <line22> try { <line23> sock.send( <line24> new DatagramPacket(res.data(), res.data().length, pckt.getAddress(), pckt.getPort())); <line25> } catch (IOException e) { <line26> if (e.getMessage().contains(""Operation not permitted"")) { <line27> if (log.isDebugEnabled()) <line28> } else throw e; <line29> } <line30> } catch (IOException e) { <line31> if (!isInterrupted()) { <line32> synchronized (this) { <line33> U.close(sock); <line34> sock = null; <line35> } <line36> } <line37> } <line38> } <line39> } <line40> } <line41> "	<line6>, <line20>, <line28>, <line32>
7110	public class A { <line0> private void logRequest(MailRequest mailRequest) { <line1> for (Logger logger : Arrays.asList(trimmedRequestLogger, fullRequestLogger)) { <line2> } <line3> } <line4> } <line5> 	<line2>
7111	"public class A { <line0> private void deleteExperimentRuns(Session session) { <line1> String deleteExperimentRunQueryString = <line2> new StringBuilder(""FROM "") <line3> .append(ExperimentRunEntity.class.getSimpleName()) <line4> .append("" expr WHERE expr."") <line5> .append(ModelDBConstants.DELETED) <line6> .append("" = :deleted "") <line7> .toString(); <line8> Query experimentRunDeleteQuery = session.createQuery(deleteExperimentRunQueryString); <line9> experimentRunDeleteQuery.setParameter(""deleted"", true); <line10> experimentRunDeleteQuery.setMaxResults(this.recordUpdateLimit); <line11> List<ExperimentRunEntity> experimentRunEntities = experimentRunDeleteQuery.list(); <line12> List<String> experimentRunIds = new ArrayList<>(); <line13> if (!experimentRunEntities.isEmpty()) { <line14> for (ExperimentRunEntity experimentRunEntity : experimentRunEntities) { <line15> experimentRunIds.add(experimentRunEntity.getId()); <line16> } <line17> try { <line18> deleteRoleBindingsForExperimentRuns(experimentRunEntities); <line19> } catch (StatusRuntimeException ex) { <line20> } catch (Exception ex) { <line21> } <line22> try { <line23> Transaction transaction = session.beginTransaction(); <line24> if (!experimentRunIds.isEmpty()) { <line25> removeEntityComments( <line26> session, experimentRunIds, ExperimentRunEntity.class.getSimpleName()); <line27> } <line28> transaction.commit(); <line29> for (ExperimentRunEntity experimentRunEntity : experimentRunEntities) { <line30> try { <line31> transaction = session.beginTransaction(); <line32> session.delete(experimentRunEntity); <line33> transaction.commit(); <line34> } catch (OptimisticLockException ex) { <line35> } <line36> } <line37> } catch (OptimisticLockException ex) { <line38> } catch (Exception ex) { <line39> } <line40> } <line41> } <line42> } <line43> "	<line1>, <line20>, <line21>, <line35>, <line38>, <line39>, <line41>
7112	"public class A { <line0> public static FalconNotificationService getService(String serviceName) <line1> throws NotificationServiceException { <line2> SERVICE serviceType = null; <line3> for (SERVICE type : SERVICE.values()) { <line4> if (type.toString().equals(serviceName)) { <line5> serviceType = type; <line6> } <line7> } <line8> if (serviceType == null) { <line9> throw new NotificationServiceException( <line10> ""Unable to find service : "" + serviceName + "" . Not a valid service.""); <line11> } <line12> return getService(serviceType); <line13> } <line14> } <line15> "	<line9>
7113	"public class A { <line0> @Override <line1> public String enrichTagWithCloudProviderBuild( <line2> String provider, String system, String tagS, String user, String pass) { <line3> if (StringUtil.isNullOrEmpty(tagS)) { <line4> return null; <line5> } <line6> AnswerItem answerTag; <line7> answerTag = readByKey(tagS); <line8> Tag tag = (Tag) answerTag.getItem(); <line9> switch (provider) { <line10> case TestCaseExecution.ROBOTPROVIDER_BROWSERSTACK: <line11> if ((tag != null) <line12> && (StringUtil.isNullOrEmpty(tag.getBrowserstackBuildHash()) <line13> || ""BSHash"".equalsIgnoreCase(tag.getBrowserstackBuildHash()))) { <line14> String newBuildHash = <line15> browserstackService.getBrowserStackBuildHash(system, tagS, user, pass); <line16> tag.setBrowserstackBuildHash(newBuildHash); <line17> Answer ans = tagDAO.updateBrowserStackBuild(tagS, tag); <line18> return newBuildHash; <line19> } <line20> break; <line21> case TestCaseExecution.ROBOTPROVIDER_LAMBDATEST: <line22> if ((tag != null) && (StringUtil.isNullOrEmpty(tag.getLambdaTestBuild()))) { <line23> String newBuildHash = lambdatestService.getBuildValue(tagS, user, pass, system); <line24> tag.setLambdaTestBuild(newBuildHash); <line25> Answer ans = tagDAO.updateLambdatestBuild(tagS, tag); <line26> return newBuildHash; <line27> } <line28> break; <line29> } <line30> return null; <line31> } <line32> } <line33> "	<line3>
7114	"public class A { <line0> @Override <line1> public void process() { <line2> try { <line3> int count = 1; <line4> while (count <= maxAssets) { <line5> session.refresh(false); <line6> Node node = <line7> JcrUtils.getOrAddNode(parent, ""Node"" + count, NodeTypeConstants.NT_OAK_UNSTRUCTURED); <line8> node.setProperty(""prop1"", ""val1""); <line9> node.setProperty(""prop2"", ""val2""); <line10> session.save(); <line11> if (LOG.isDebugEnabled()) { <line12> } <line13> count++; <line14> } <line15> } catch (Exception e) { <line16> } <line17> } <line18> } <line19> "	<line12>, <line16>
7115	"public class A { <line0> public static void logAfter( <line1> PLogger logger, <line2> Object target, <line3> String className, <line4> String methodName, <line5> String parameterDescription, <line6> Object[] args, <line7> Object result) { <line8> StringBuilder sb = new StringBuilder(512); <line9> sb.append(""AFTER ""); <line10> logMethod(sb, getTarget(target), className, methodName, parameterDescription, args); <line11> sb.append("" result:""); <line12> sb.append(getTarget(result)); <line13> } <line14> } <line15> "	<line13>
7116	public class A { <line0> protected void runCollectorForTopicDir( <line1> FileSystem fs, String topic, Path topicSourceDir, Path topicDestDir) throws Exception { <line2> ArrayList<Future<?>> tasksToComplete = new ArrayList<Future<?>>(); <line3> List<Properties> jobPropsList = <line4> planner.createSweeperJobProps(topic, topicSourceDir, topicDestDir, fs); <line5> for (Properties jobProps : jobPropsList) { <line6> tasksToComplete.add(runCollector(jobProps, topic)); <line7> } <line8> } <line9> } <line10> 	<line2>, <line8>
7117	"public class A { <line0> @Bean(name = ""protocolMqttOutboundOsgpCoreRequestsJmsTemplate"") <line1> public JmsTemplate jmsTemplate() { <line2> return this.jmsConfigurationFactory.initJmsTemplate(); <line3> } <line4> } <line5> "	<line2>
7118	public class A { <line0> private Pair<String, Long> getPodCidr(long podId, long dcId) { <line1> try { <line2> HashMap<Long, List<Object>> podMap = _podDao.getCurrentPodCidrSubnets(dcId, 0); <line3> List<Object> cidrPair = podMap.get(podId); <line4> String cidrAddress = (String) cidrPair.get(0); <line5> Long cidrSize = (Long) cidrPair.get(1); <line6> return new Pair<String, Long>(cidrAddress, cidrSize); <line7> } catch (PatternSyntaxException e) { <line8> return null; <line9> } catch (IndexOutOfBoundsException e) { <line10> return null; <line11> } <line12> } <line13> } <line14> 	<line8>, <line10>
7119	"public class A { <line0> private void unlockInternal() throws InterruptedException, KeeperException { <line1> File pathToDelete = null; <line2> synchronized (this) { <line3> Preconditions.checkState( <line4> null != mCreatedPath, ""unlock() cannot be called while lock is unlocked.""); <line5> pathToDelete = mCreatedPath; <line6> mCreatedPath = null; <line7> } <line8> mZKClient.delete(pathToDelete, -1); <line9> } <line10> } <line11> "	<line6>
7120	public class A { <line0> public void process(Exchange exchange) throws Exception { <line1> Message out = exchange.getMessage(); <line2> out.copyFrom(exchange.getIn()); <line3> InputStreamCache cache = out.getBody(InputStreamCache.class); <line4> cache.reset(); <line5> } <line6> } <line7> 	<line3>
7121	public class A { <line0> public CloudWithRelaysListResponseDTO getCloudsResponse( <line1> final int page, final int size, final Direction direction, final String sortField) { <line2> final Page<Cloud> entries = getClouds(page, size, direction, sortField); <line3> return DTOConverter.convertCloudToCloudWithRelaysListResponseDTO(entries); <line4> } <line5> } <line6> 	<line2>
7122	"public class A { <line0> @Override <line1> public Session impersonate(Credentials otherCredentials) <line2> throws LoginException, RepositoryException { <line3> sanityCheck(); <line4> if (!(otherCredentials instanceof SimpleCredentials)) { <line5> String msg = ""impersonate failed: incompatible credentials, SimpleCredentials expected""; <line6> throw new RepositoryException(msg); <line7> } <line8> SimpleCredentials creds = (SimpleCredentials) otherCredentials; <line9> creds.setAttribute(SecurityConstants.IMPERSONATOR_ATTRIBUTE, subject); <line10> try { <line11> return getRepository().login(otherCredentials, getWorkspace().getName()); <line12> } catch (NoSuchWorkspaceException nswe) { <line13> String msg = ""impersonate failed""; <line14> throw new RepositoryException(msg, nswe); <line15> } finally { <line16> creds.removeAttribute(SecurityConstants.IMPERSONATOR_ATTRIBUTE); <line17> } <line18> } <line19> } <line20> "	<line6>, <line14>
7123	public class A { <line0> @Override <line1> public void accept(KlvDataElement klvDataElement) { <line2> } <line3> } <line4> 	<line2>
7124	"public class A { <line0> @Bean(name = ""domainCoreInboundWebServiceRequestsMessageProcessorMap"") <line1> public MessageProcessorMap messageProcessorMap() { <line2> return new BaseMessageProcessorMap(""InboundWebServiceRequestsMessageProcessorMap""); <line3> } <line4> } <line5> "	<line2>
7125	public class A { <line0> @Override <line1> public void onJoystickInput(JoystickData input) throws Exception { <line2> if (input.id.contentEquals(axisLeft)) { <line3> moveLeft(input.value); <line4> } else if (input.id.contentEquals(axisRight)) { <line5> moveRight(input.value); <line6> } else { <line7> } <line8> } <line9> } <line10> 	<line7>
7126	"public class A { <line0> public UmaPCT getByCode(String pctCode) { <line1> try { <line2> final Filter filter = Filter.createEqualityFilter(""tknCde"", pctCode); <line3> final List<UmaPCT> entries = <line4> ldapEntryManager.findEntries(branchBaseDn(), UmaPCT.class, filter); <line5> if (entries != null && !entries.isEmpty()) { <line6> return entries.get(0); <line7> } else { <line8> } <line9> } catch (Exception e) { <line10> } <line11> return null; <line12> } <line13> } <line14> "	<line8>, <line10>
7127	public class A { <line0> public void doEvent(Event event) { <line1> if (pos < filters.size()) { <line2> Filter filter = filters.get(pos++); <line3> if (filter != null) { <line4> filter.doEvent(this, event); <line5> return; <line6> } <line7> } <line8> if (terminal != null) { <line9> terminal.doEvent(this, event); <line10> } else { <line11> } <line12> } <line13> } <line14> 	<line7>, <line11>
7128	"public class A { <line0> @PUT <line1> public Response updateEntity( <line2> @Context Providers providers, <line3> @PathParam(""entitySetName"") String entitySetName, <line4> @PathParam(""id"") String id, <line5> @PathParam(""navProp"") String navProp) { <line6> throw new NotImplementedException(""NavProp: updateEntity not supported yet.""); <line7> } <line8> } <line9> "	<line6>
7129	public class A { <line0> private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) { <line1> String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()); <line2> try (Jedis jedis = JedisPooledFactory.getJedisInstance()) { <line3> String xid = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID); <line4> if (StringUtils.isEmpty(xid)) { <line5> return true; <line6> } <line7> Pipeline pipelined = jedis.pipelined(); <line8> pipelined.lrem( <line9> buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid()); <line10> pipelined.del(globalKey); <line11> pipelined.sync(); <line12> return true; <line13> } catch (Exception ex) { <line14> throw new RedisException(ex); <line15> } <line16> } <line17> } <line18> 	<line5>
7130	"public class A { <line0> @Path(""/deleteShouldSucceed"") <line1> @POST <line2> public void deleteShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.DELETE); <line4> template.requestBodyAndHeader(uri, null, OpenstackConstants.ID, DOMAIN_ID); <line5> } <line6> } <line7> "	<line3>
7131	public class A { <line0> @Override <line1> public void close() { <line2> if (_scheduledExecutorService == null || _scheduledExecutorService.isShutdown()) { <line3> return; <line4> } <line5> _scheduledExecutorService.shutdown(); <line6> try { <line7> if (!_scheduledExecutorService.awaitTermination(2L, TimeUnit.SECONDS)) { <line8> List<Runnable> droppedTasks = _scheduledExecutorService.shutdownNow(); <line9> } <line10> } catch (InterruptedException e) { <line11> Thread.currentThread().interrupt(); <line12> } <line13> } <line14> } <line15> 	<line8>, <line9>, <line11>
7132	"public class A { <line0> public static void trace(final Object caller, final String message) { <line1> String id = <line2> (caller == null) <line3> ? Messages.getInstance().getString(""Logger.DEBUG_LOG_UNKNOWN"") <line4> : caller.getClass().getName(); <line5> if (Logger.logLevel <= ILogger.TRACE) { <line6> } <line7> } <line8> } <line9> "	<line6>
7133	"public class A { <line0> public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <line1> throws JsonParseException { <line2> SimpleDateFormat format = new SimpleDateFormat(""EE MMM dd HH:mm:ss z yyyy"", Locale.ENGLISH); <line3> String timeStamp = json.toString().replaceAll(""^\""|\""$"", """"); <line4> Date date = null; <line5> try { <line6> date = format.parse(timeStamp); <line7> } catch (ParseException e) { <line8> } <line9> return date; <line10> } <line11> } <line12> "	<line8>
7134	"public class A { <line0> public void assignField( <line1> ConnectionSource connectionSource, <line2> Object data, <line3> Object val, <line4> boolean parentObject, <line5> ObjectCache objectCache) <line6> throws SQLException { <line7> if (logger.isLevelEnabled(Level.TRACE)) { <line8> } <line9> if (foreignRefField != null && val != null) { <line10> Object foreignRef = extractJavaFieldValue(data); <line11> if (foreignRef != null && foreignRef.equals(val)) { <line12> return; <line13> } <line14> Object cachedVal; <line15> ObjectCache foreignCache = foreignDao.getObjectCache(); <line16> if (foreignCache == null) { <line17> cachedVal = null; <line18> } else { <line19> cachedVal = foreignCache.get(getType(), val); <line20> } <line21> if (cachedVal != null) { <line22> val = cachedVal; <line23> } else if (!parentObject) { <line24> val = createForeignObject(connectionSource, val, objectCache); <line25> } <line26> } <line27> if (fieldSetMethod == null) { <line28> try { <line29> field.set(data, val); <line30> } catch (IllegalArgumentException e) { <line31> if (val == null) { <line32> throw SqlExceptionUtil.create( <line33> ""Could not assign object '"" + val + ""' to field "" + this, e); <line34> } else { <line35> throw SqlExceptionUtil.create( <line36> ""Could not assign object '"" <line37> + val <line38> + ""' of type "" <line39> + val.getClass() <line40> + "" to field "" <line41> + this, <line42> e); <line43> } <line44> } catch (IllegalAccessException e) { <line45> throw SqlExceptionUtil.create( <line46> ""Could not assign object '"" <line47> + val <line48> + ""' of type "" <line49> + val.getClass() <line50> + ""' to field "" <line51> + this, <line52> e); <line53> } <line54> } else { <line55> try { <line56> fieldSetMethod.invoke(data, val); <line57> } catch (Exception e) { <line58> throw SqlExceptionUtil.create( <line59> ""Could not call "" + fieldSetMethod + "" on object with '"" + val + ""' for "" + this, e); <line60> } <line61> } <line62> } <line63> } <line64> "	<line8>
7135	public class A { <line0> private void sendToListener( <line1> ParameterValue pv, ParameterWithId pid, ParameterReplayListener replayListener) { <line2> ParameterValue pv1; <line3> if (pid.getPath() != null) { <line4> try { <line5> pv1 = AggregateUtil.extractMember(pv, pid.getPath()); <line6> if (pv1 == null) { <line7> return; <line8> } <line9> } catch (Exception e) { <line10> return; <line11> } <line12> } else { <line13> pv1 = pv; <line14> } <line15> replayListener.update(new ParameterValueWithId(pv1, pid.getId())); <line16> } <line17> } <line18> 	<line10>
7136	"public class A { <line0> @Override <line1> public void handle(@SuppressWarnings(""rawtypes"") Future future) { <line2> try { <line3> MetricsRecord record = (MetricsRecord) future.get(); <line4> if (null != record) { <line5> if (LOG.isDebugEnabled()) { <line6> for (@SuppressWarnings(""rawtypes"") Metric metric : record.metrics()) { <line7> } <line8> } <line9> repository.put(groom, record); <line10> } <line11> } catch (InterruptedException ie) { <line12> Thread.currentThread().interrupt(); <line13> } catch (ExecutionException ee) { <line14> } <line15> } <line16> } <line17> "	<line7>, <line12>, <line14>
7137	"public class A { <line0> public List<AbstractSequence<? extends AbstractCompound>> getBioSequences( <line1> boolean ignoreCase, String forcedSequenceType) { <line2> if (forcedSequenceType != null <line3> && !(forcedSequenceType.equals(PFAM) || forcedSequenceType.equals(RFAM))) { <line4> throw new IllegalArgumentException(""Illegal Argument "" + forcedSequenceType); <line5> } <line6> List<AbstractSequence<? extends AbstractCompound>> seqs = <line7> new ArrayList<AbstractSequence<? extends AbstractCompound>>(); <line8> for (String sequencename : sequences.keySet()) { <line9> AbstractSequence<? extends AbstractCompound> seq = null; <line10> String sequence = sequences.get(sequencename).toString(); <line11> if (ignoreCase) { <line12> sequence = sequence.toUpperCase(); <line13> } <line14> try { <line15> if (forcedSequenceType == null) <line16> seq = fileAnnotation.isPFam() ? new ProteinSequence(sequence) : new RNASequence(sequence); <line17> else if (forcedSequenceType.equals(PFAM)) seq = new ProteinSequence(sequence); <line18> else seq = new RNASequence(sequence); <line19> } catch (CompoundNotFoundException e) { <line20> continue; <line21> } <line22> String[] seqDetails = splitSeqName(sequencename); <line23> seq.setDescription(seqDetails[0]); <line24> seq.setBioBegin( <line25> (seqDetails[1] == null || seqDetails[1].trim().equals("""") <line26> ? null <line27> : new Integer(seqDetails[1]))); <line28> seq.setBioEnd( <line29> (seqDetails[2] == null || seqDetails[2].trim().equals("""") <line30> ? null <line31> : new Integer(seqDetails[2]))); <line32> seqs.add(seq); <line33> } <line34> return seqs; <line35> } <line36> } <line37> "	<line20>
7138	public class A { <line0> @Override <line1> public void clearUp() { <line2> cleaner.toContinueRunning = false; <line3> try { <line4> th.interrupt(); <line5> } catch (Exception e) { <line6> if (logger.isDebugEnabled()) { <line7> } <line8> } <line9> try { <line10> Iterator availableCacheItr = availableCache.keySet().iterator(); <line11> Iterator activeCacheItr = activeCache.keySet().iterator(); <line12> while (activeCacheItr.hasNext()) { <line13> ((Connection) activeCacheItr.next()).close(); <line14> } <line15> while (availableCacheItr.hasNext()) { <line16> ((Connection) availableCacheItr.next()).close(); <line17> } <line18> } catch (Exception e) { <line19> if (logger.isDebugEnabled()) { <line20> } <line21> } <line22> } <line23> } <line24> 	<line7>, <line20>
7139	public class A { <line0> public <T> T execute(CommandConfig config, Command<T> command) { <line1> CommandContext context = Context.getCommandContext(); <line2> boolean contextReused = false; <line3> if (!config.isContextReusePossible() || context == null || context.getException() != null) { <line4> context = commandContextFactory.createCommandContext(command); <line5> } else { <line6> contextReused = true; <line7> context.setReused(true); <line8> } <line9> try { <line10> Context.setCommandContext(context); <line11> Context.setProcessEngineConfiguration(processEngineConfiguration); <line12> return next.execute(config, command); <line13> } catch (Throwable e) { <line14> context.exception(e); <line15> } finally { <line16> try { <line17> if (!contextReused) { <line18> context.close(); <line19> } <line20> } finally { <line21> Context.removeCommandContext(); <line22> Context.removeProcessEngineConfiguration(); <line23> Context.removeBpmnOverrideContext(); <line24> } <line25> } <line26> return null; <line27> } <line28> } <line29> 	<line6>
7140	public class A { <line0> private void onFailure(final Throwable throwable) { <line1> recorder.reportFailedAuth(serverKey); <line2> session.close(true); <line3> } <line4> } <line5> 	<line1>
7141	public class A { <line0> private boolean isDependencyPresent(String moduleName, String dependencyName) { <line1> if (!modulesNotForDeployment.contains(dependencyName)) { <line2> return true; <line3> } <line4> Module dependency = allModulesInDescriptorWithNames.get(dependencyName); <line5> if (!moduleToDeployHelper.isApplication(dependency)) { <line6> return true; <line7> } <line8> return appExists(dependencyName); <line9> } <line10> } <line11> 	<line6>
7142	"public class A { <line0> @Override <line1> public DistStageAck executeOnWorker() { <line2> if (lifecycle == null) { <line3> return successfulResponse(); <line4> } <line5> boolean stopMe = <line6> stop.contains(workerState.getWorkerIndex()) <line7> || RoleHelper.hasAnyRole(workerState, stopRoles); <line8> boolean startMe = start.contains(workerState.getWorkerIndex()); <line9> if (!(stopMe || startMe)) { <line10> } <line11> while (stopMe || startMe) { <line12> if (startMe) { <line13> if (lifecycle.isRunning()) { <line14> if (!stopMe) { <line15> startMe = false; <line16> return successfulResponse(); <line17> } <line18> } else { <line19> if (startDelay > 0) { <line20> try { <line21> Thread.sleep(startDelay); <line22> } catch (InterruptedException e) { <line23> } <line24> } <line25> try { <line26> LifecycleHelper.start(workerState, false, null, 0, reachable); <line27> } catch (RuntimeException e) { <line28> return errorResponse(""Issues while instantiating/starting cache wrapper"", e); <line29> } <line30> startMe = false; <line31> } <line32> } <line33> if (stopMe) { <line34> if (!lifecycle.isRunning()) { <line35> if (!startMe) { <line36> stopMe = false; <line37> return successfulResponse(); <line38> } <line39> } else { <line40> try { <line41> Thread.sleep(stopDelay); <line42> } catch (InterruptedException e) { <line43> } <line44> try { <line45> LifecycleHelper.stop(workerState, graceful, false); <line46> } catch (RuntimeException e) { <line47> return errorResponse(""Failed to kill the service"", e); <line48> } <line49> stopMe = false; <line50> } <line51> } <line52> } <line53> return successfulResponse(); <line54> } <line55> } <line56> "	<line3>, <line10>, <line15>, <line23>, <line36>, <line43>
7143	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private void filterURL() { <line2> if (filtering) { <line3> throw new IllegalStateException( <line4> ""Calling PortletURL toString or write methods from a PortletURLGenerationListener not"" <line5> + "" allowed""); <line6> } <line7> filtering = true; <line8> try { <line9> PortletURLListenerService service = <line10> responseContext.getContainer().getContainerServices().getPortletURLListenerService(); <line11> PortletApplicationDefinition portletApp = <line12> responseContext.getPortletWindow().getPortletDefinition().getApplication(); <line13> for (PortletURLGenerationListener<RenderURL, ActionURL> listener : <line14> service.getPortletURLGenerationListeners(portletApp)) { <line15> if (this instanceof ActionURL) { <line16> listener.filterActionURL((ActionURL) this); <line17> } else if (this instanceof ResourceURL) { <line18> listener.filterResourceURL((ResourceURL) this); <line19> } else if (this instanceof RenderURL) { <line20> listener.filterRenderURL((RenderURL) this); <line21> } else { <line22> } <line23> } <line24> } finally { <line25> filtering = false; <line26> } <line27> } <line28> } <line29> "	<line22>
7144	public class A { <line0> public static void testTransactionValidation() { <line1> Key key = new Key(); <line2> Network network = config.network(); <line3> TransactionType type = TransactionType.TRANSFER; <line4> byte[] to = Bytes.random(20); <line5> Amount value = Amount.of(1); <line6> Amount fee = config.spec().minTransactionFee(); <line7> long nonce = 1; <line8> long timestamp = TimeUtil.currentTimeMillis(); <line9> byte[] data = {}; <line10> Transaction tx = new Transaction(network, type, to, value, fee, nonce, timestamp, data); <line11> tx.sign(key); <line12> int repeat = 1000; <line13> long t1 = System.nanoTime(); <line14> for (int i = 0; i < repeat; i++) { <line15> tx.validate(network); <line16> } <line17> long t2 = System.nanoTime(); <line18> } <line19> } <line20> 	<line18>
7145	public class A { <line0> public boolean executeExternalUpdateMethod( <line1> CustomScriptConfiguration customScriptConfiguration, <line2> DynamicScopeExternalContext dynamicScopeContext) { <line3> try { <line4> DynamicScopeType dynamicScopeType = <line5> (DynamicScopeType) customScriptConfiguration.getExternalType(); <line6> Map<String, SimpleCustomProperty> configurationAttributes = <line7> customScriptConfiguration.getConfigurationAttributes(); <line8> return dynamicScopeType.update(dynamicScopeContext, configurationAttributes); <line9> } catch (Exception ex) { <line10> saveScriptError(customScriptConfiguration.getCustomScript(), ex); <line11> } <line12> return false; <line13> } <line14> } <line15> 	<line4>, <line10>
7146	public class A { <line0> private ExecutionBlock buildJoinPlan( <line1> GlobalPlanContext context, <line2> JoinNode joinNode, <line3> ExecutionBlock leftBlock, <line4> ExecutionBlock rightBlock) <line5> throws PlanningException { <line6> MasterPlan masterPlan = context.plan; <line7> ExecutionBlock currentBlock; <line8> LogicalNode leftNode = joinNode.getLeftChild(); <line9> LogicalNode rightNode = joinNode.getRightChild(); <line10> boolean leftBroadcasted = false; <line11> boolean rightBroadcasted = false; <line12> if (checkIfCanBeOneOfBroadcastJoin(leftNode) && checkIfCanBeOneOfBroadcastJoin(rightNode)) { <line13> ScanNode leftScan = (ScanNode) leftNode; <line14> ScanNode rightScan = (ScanNode) rightNode; <line15> TableDesc leftDesc = leftScan.getTableDesc(); <line16> TableDesc rightDesc = rightScan.getTableDesc(); <line17> long broadcastThreshold = <line18> conf.getLongVar(TajoConf.ConfVars.DIST_QUERY_BROADCAST_JOIN_THRESHOLD); <line19> if (leftDesc.getStats().getNumBytes() < broadcastThreshold) { <line20> leftBroadcasted = true; <line21> } <line22> if (rightDesc.getStats().getNumBytes() < broadcastThreshold) { <line23> rightBroadcasted = true; <line24> } <line25> if (leftBroadcasted || rightBroadcasted) { <line26> currentBlock = masterPlan.newExecutionBlock(); <line27> currentBlock.setPlan(joinNode); <line28> if (leftBroadcasted) { <line29> currentBlock.addBroadcastTable(leftScan.getCanonicalName()); <line30> } <line31> if (rightBroadcasted) { <line32> currentBlock.addBroadcastTable(rightScan.getCanonicalName()); <line33> } <line34> context.execBlockMap.remove(leftScan.getPID()); <line35> context.execBlockMap.remove(rightScan.getPID()); <line36> return currentBlock; <line37> } <line38> } <line39> currentBlock = masterPlan.newExecutionBlock(); <line40> DataChannel leftChannel = <line41> createDataChannelFromJoin(leftBlock, rightBlock, currentBlock, joinNode, true); <line42> DataChannel rightChannel = <line43> createDataChannelFromJoin(leftBlock, rightBlock, currentBlock, joinNode, false); <line44> ScanNode leftScan = buildInputExecutor(masterPlan.getLogicalPlan(), leftChannel); <line45> ScanNode rightScan = buildInputExecutor(masterPlan.getLogicalPlan(), rightChannel); <line46> joinNode.setLeftChild(leftScan); <line47> joinNode.setRightChild(rightScan); <line48> currentBlock.setPlan(joinNode); <line49> masterPlan.addConnect(leftChannel); <line50> masterPlan.addConnect(rightChannel); <line51> return currentBlock; <line52> } <line53> } <line54> 	<line30>, <line33>
7147	public class A { <line0> private void notifyPreviousReporter(Reporter r, IdTag id) { <line1> if (!(r.equals(this)) && r.getCurrentReport() == id && (r instanceof IdTagListener)) { <line2> ((IdTagListener) r).notify(null); <line3> } else { <line4> } <line5> } <line6> } <line7> 	<line1>, <line2>, <line4>
7148	"public class A { <line0> public void updateSettings() { <line1> reset(); <line2> final Iterator<HierarchicalConfiguration> it = <line3> properties.getReporterConfigurations().iterator(); <line4> while (it.hasNext()) { <line5> final HierarchicalConfiguration reporterConfig = it.next(); <line6> final String reporterType = reporterConfig.getString(""type""); <line7> if (reporterType != null) { <line8> if (reporterType.equals(""jmx"") <line9> || reporterType.equals(JmxReporter.class.getCanonicalName())) { <line10> if (jmxReporter == null) { <line11> jmxReporter = JmxReporter.forRegistry(metricRegistry).build(); <line12> } <line13> } else if (reporterType.equals(""http"")) { <line14> if (httpReporterConfig == null) { <line15> httpReporterConfig = new HttpReporterConfig(reporterConfig); <line16> } <line17> } else if (reporterType.equals(""console"") <line18> || reporterType.equals(ConsoleReporter.class.getCanonicalName())) { <line19> reporters.add(new ConsoleReporterConfig(reporterConfig, metricRegistry)); <line20> } else if (reporterType.equals(""ganglia"") <line21> || reporterType.equals(GangliaReporter.class.getCanonicalName())) { <line22> reporters.add(new GangliaReporterConfig(reporterConfig, metricRegistry)); <line23> } else if (reporterType.equals(""graphite"") <line24> || reporterType.equals(GraphiteReporter.class.getCanonicalName())) { <line25> reporters.add(new GraphiteReporterConfig(reporterConfig, metricRegistry)); <line26> } else { <line27> } <line28> } else { <line29> } <line30> } <line31> this.properties.addOverride(""http-reporter-enabled"", isHttpReporterEnabled()); <line32> this.properties.addOverride(""http-reporter-duration"", getDurationTimeUnitConversion()); <line33> this.properties.addOverride(""http-reporter-convert"", getRateTimeUnitConversion()); <line34> } <line35> } <line36> "	<line27>, <line29>
7149	public class A { <line0> @Override <line1> public UserContext updateUserContext( <line2> UserContext context, AuthenticatedUser authenticatedUser, Credentials credentials) <line3> throws GuacamoleException { <line4> if (authProvider == null) { <line5> return null; <line6> } <line7> return authProvider.updateUserContext(context, authenticatedUser, credentials); <line8> } <line9> } <line10> 	<line5>
7150	public class A { <line0> private void init(final ProtocolInfo protocolInfo) throws SSLException { <line1> final String key = protocolInfo.getKey(); <line2> final JmsConfigurationFactory jmsConfigurationFactory = <line3> new JmsConfigurationFactory( <line4> this.environment, <line5> this.defaultProtocolJmsConfiguration, <line6> protocolInfo.getIncomingResponsesPropertyPrefix()); <line7> final PooledConnectionFactory connectionFactory = <line8> jmsConfigurationFactory.getPooledConnectionFactory(); <line9> this.connectionFactoryRegistry.register(key, connectionFactory); <line10> connectionFactory.start(); <line11> final ProtocolResponseMessageListener messageListener = <line12> new ProtocolResponseMessageListener(this.deviceResponseMessageService); <line13> final DefaultMessageListenerContainer messageListenerContainer = <line14> jmsConfigurationFactory.initMessageListenerContainer(messageListener); <line15> this.messageListenerContainerRegistry.register(key, messageListenerContainer); <line16> messageListenerContainer.afterPropertiesSet(); <line17> messageListenerContainer.start(); <line18> } <line19> } <line20> 	<line2>, <line7>, <line11>
7151	"public class A { <line0> @Override <line1> public CompletionStage<Void> clear() { <line2> assertRunning(); <line3> record(""clear""); <line4> for (int i = 0; i < store.length(); ++i) { <line5> Map<Object, byte[]> map = store.get(i); <line6> if (map != null) { <line7> map.clear(); <line8> } <line9> } <line10> return CompletableFutures.completedNull(); <line11> } <line12> } <line13> "	<line4>
7152	public class A { <line0> public CompletionStage<Void> setKeyspace(CqlIdentifier newKeyspace) { <line1> CqlIdentifier oldKeyspace = this.keyspace; <line2> if (Objects.equals(oldKeyspace, newKeyspace)) { <line3> return CompletableFuture.completedFuture(null); <line4> } <line5> if (config.getBoolean(DefaultDriverOption.REQUEST_WARN_IF_SET_KEYSPACE)) { <line6> } <line7> this.keyspace = newKeyspace; <line8> CompletableFuture<Void> result = new CompletableFuture<>(); <line9> RunOrSchedule.on(adminExecutor, () -> singleThreaded.setKeyspace(newKeyspace, result)); <line10> return result; <line11> } <line12> } <line13> 	<line6>
7153	public class A { <line0> private void sendMessage(final MicrogridsRequestMessage requestMessage) { <line1> this.jmsTemplate.send( <line2> new MessageCreator() { <line3> @Override <line4> public Message createMessage(final Session session) throws JMSException { <line5> final ObjectMessage objectMessage = <line6> session.createObjectMessage(requestMessage.getRequest()); <line7> objectMessage.setJMSCorrelationID(requestMessage.getCorrelationUid()); <line8> objectMessage.setJMSType(requestMessage.getMessageType().name()); <line9> objectMessage.setStringProperty( <line10> Constants.ORGANISATION_IDENTIFICATION, <line11> requestMessage.getOrganisationIdentification()); <line12> objectMessage.setStringProperty( <line13> Constants.DEVICE_IDENTIFICATION, requestMessage.getDeviceIdentification()); <line14> return objectMessage; <line15> } <line16> }); <line17> } <line18> } <line19> 	<line1>
7154	public class A { <line0> public void cleanMetisIndexingDataset( <line1> String topologyName, long taskId, DataSetCleanerParameters dataSetCleanerParameters) <line2> throws DpsException { <line3> Response resp = null; <line4> try { <line5> resp = <line6> client <line7> .target(dpsUrl) <line8> .path(TASK_CLEAN_DATASET_URL) <line9> .resolveTemplate(TOPOLOGY_NAME, topologyName) <line10> .resolveTemplate(TASK_ID, taskId) <line11> .request() <line12> .post(Entity.json(dataSetCleanerParameters)); <line13> if (resp.getStatus() != Response.Status.OK.getStatusCode()) { <line14> throw handleException(resp); <line15> } <line16> } finally { <line17> closeResponse(resp); <line18> } <line19> } <line20> } <line21> 	<line14>
7155	public class A { <line0> @Override <line1> public void seek(Range r, Collection<ByteSequence> columnFamilies, boolean inclusive) <line2> throws IOException { <line3> this.initialSeekRange = new Range(r); <line4> this.topKey = null; <line5> this.topValue = null; <line6> if (log.isTraceEnabled()) { <line7> for (ByteSequence bs : this.seekColumnFamilies) { <line8> } <line9> } <line10> source.seek(r, this.seekColumnFamilies, this.seekColumnFamiliesInclusive); <line11> findTop(); <line12> if (log.isTraceEnabled()) { <line13> } <line14> } <line15> } <line16> 	<line7>, <line8>, <line13>
7156	public class A { <line0> @Override <line1> public void run(SourceContext<WindowedValue<ValueWithRecordId<OutputT>>> ctx) throws Exception { <line2> context = ctx; <line3> ReaderInvocationUtil<OutputT, UnboundedSource.UnboundedReader<OutputT>> readerInvoker = <line4> new ReaderInvocationUtil<>(stepName, serializedOptions.get(), metricContainer); <line5> setNextWatermarkTimer(this.runtimeContext); <line6> if (localReaders.isEmpty()) { <line7> } else if (isConvertedBoundedSource) { <line8> for (int i = 0; i < localReaders.size() && isRunning; i++) { <line9> UnboundedSource.UnboundedReader<OutputT> reader = localReaders.get(i); <line10> synchronized (ctx.getCheckpointLock()) { <line11> boolean dataAvailable = readerInvoker.invokeStart(reader); <line12> if (dataAvailable) { <line13> emitElement(ctx, reader); <line14> } <line15> } <line16> boolean dataAvailable; <line17> do { <line18> synchronized (ctx.getCheckpointLock()) { <line19> dataAvailable = readerInvoker.invokeAdvance(reader); <line20> if (dataAvailable) { <line21> emitElement(ctx, reader); <line22> } <line23> } <line24> } while (dataAvailable && isRunning); <line25> } <line26> } else { <line27> int numReaders = localReaders.size(); <line28> int currentReader = 0; <line29> for (UnboundedSource.UnboundedReader<OutputT> reader : localReaders) { <line30> synchronized (ctx.getCheckpointLock()) { <line31> boolean dataAvailable = readerInvoker.invokeStart(reader); <line32> if (dataAvailable) { <line33> emitElement(ctx, reader); <line34> } <line35> } <line36> } <line37> boolean hadData = false; <line38> while (isRunning && !maxWatermarkReached) { <line39> UnboundedSource.UnboundedReader<OutputT> reader = localReaders.get(currentReader); <line40> synchronized (ctx.getCheckpointLock()) { <line41> if (readerInvoker.invokeAdvance(reader)) { <line42> emitElement(ctx, reader); <line43> hadData = true; <line44> } <line45> } <line46> currentReader = (currentReader + 1) % numReaders; <line47> if (currentReader == 0 && !hadData) { <line48> Thread.sleep(50); <line49> } else if (currentReader == 0) { <line50> hadData = false; <line51> } <line52> } <line53> } <line54> ctx.emitWatermark(new Watermark(Long.MAX_VALUE)); <line55> finalizeSource(); <line56> } <line57> } <line58> 	<line7>
7157	"public class A { <line0> public String getDate(Date date) { <line1> try { <line2> return DateUtil.getDate(date, ""yyyyMMddHHmmss"", LocaleUtil.getDefault()); <line3> } catch (Exception exception) { <line4> if (_log.isWarnEnabled()) { <line5> } <line6> return null; <line7> } <line8> } <line9> } <line10> "	<line5>
7158	public class A { <line0> public void run() { <line1> initPrettyNames(); <line2> this.viz = new Visualization(); <line3> HeatmapData hd = this.setupDataTable(); <line4> int width; <line5> if (SIZE_X - BORDER[0] - BORDER[2] < SIZE_Y - BORDER[1] - BORDER[3]) { <line6> BOXWIDTH = (SIZE_X - BORDER[0] - BORDER[2]) / hd.num_hosts; <line7> } else { <line8> BOXWIDTH = (SIZE_Y - BORDER[1] - BORDER[3]) / hd.num_hosts; <line9> } <line10> width = hd.num_hosts * BOXWIDTH; <line11> this.dataBound.setRect( <line12> BORDER[0] + BOXWIDTH / 2, BORDER[1] + BOXWIDTH / 2, width - BOXWIDTH, width - BOXWIDTH); <line13> this.SIZE_X = BORDER[0] + BORDER[2] + (hd.num_hosts * BOXWIDTH); <line14> this.SIZE_Y = BORDER[1] + BORDER[3] + (hd.num_hosts * BOXWIDTH); <line15> this.setupRenderer(); <line16> VisualTable data_tab_viz = viz.addTable(maingroup, hd.agg_tab); <line17> setupHeatmap(data_tab_viz, hd); <line18> ShapeAction legend_sa1 = null, legend_sa2 = null; <line19> SpecifiedLayout legendlabels_sl1 = null, legendlabels_sl2 = null; <line20> if (plot_legend) { <line21> addHostLabels(hd); <line22> legend_sa1 = new ShapeAction(legendshapegroup); <line23> legendlabels_sl1 = new SpecifiedLayout(legendgroup, VisualItem.X, VisualItem.Y); <line24> ActionList legenddraw = new ActionList(); <line25> legenddraw.add(legend_sa1); <line26> this.viz.putAction(legendshapegroup, legenddraw); <line27> ActionList legendlabelsdraw = new ActionList(); <line28> legendlabelsdraw.add(legendlabels_sl1); <line29> this.viz.putAction(legendgroup, legendlabelsdraw); <line30> } <line31> if (plot_additional_info) { <line32> addAddlInfo(hd); <line33> legend_sa2 = new ShapeAction(addinfoshapegroup); <line34> legendlabels_sl2 = new SpecifiedLayout(addinfogroup, VisualItem.X, VisualItem.Y); <line35> ActionList legenddraw = new ActionList(); <line36> legenddraw.add(legend_sa2); <line37> this.viz.putAction(addinfoshapegroup, legenddraw); <line38> ActionList legendlabelsdraw = new ActionList(); <line39> legendlabelsdraw.add(legendlabels_sl2); <line40> this.viz.putAction(addinfogroup, legendlabelsdraw); <line41> } <line42> } <line43> } <line44> 	<line15>
7159	public class A { <line0> protected final void started() { <line1> if (!state.compareAndSet(State.STARTING, State.ALIVE)) { <line2> return; <line3> } <line4> executor.execute( <line5> () -> { <line6> state.set(State.ALIVE); <line7> caller.alive(); <line8> }); <line9> } <line10> } <line11> 	<line1>, <line2>
7160	public class A { <line0> public static synchronized void reload() { <line1> lastModified = 0; <line2> List<File> settingsFiles = getSettingsFiles(); <line3> List<SimpleXml> simpleXmlList = new ArrayList<SimpleXml>(); <line4> for (File settingsFile : settingsFiles) { <line5> if (settingsFile.isFile()) { <line6> simpleXmlList.add(new SimpleXml(settingsFile)); <line7> } else { <line8> } <line9> if (settingsFile.lastModified() > lastModified) { <line10> lastModified = settingsFile.lastModified(); <line11> } <line12> } <line13> synchronized (fileSettingsXmlList) { <line14> fileSettingsXmlList.clear(); <line15> fileSettingsXmlList.addAll(simpleXmlList); <line16> } <line17> } <line18> } <line19> 	<line8>
7161	public class A { <line0> public static void finishPsiModification() { <line1> if (!PsiInvalidElementAccessException.isTrackingInvalidation()) { <line2> return; <line3> } <line4> Integer depth = ourPsiModificationDepth.get(); <line5> if (depth == null) { <line6> depth = 0; <line7> } else { <line8> depth--; <line9> ourPsiModificationDepth.set(depth); <line10> } <line11> if (depth == 0) { <line12> ourPsiModificationTrace.set(null); <line13> } <line14> } <line15> } <line16> 	<line6>
7162	public class A { <line0> private void saveModel(BSPPeer<Text, VectorWritable, Text, VectorWritable, MapWritable> peer) <line1> throws IOException, SyncException, InterruptedException { <line2> for (Map.Entry<String, VectorWritable> user : usersMatrix.entrySet()) { <line3> peer.write( <line4> new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()), user.getValue()); <line5> } <line6> sendItemFactorizedValues(peer); <line7> peer.sync(); <line8> HashMap<Text, LinkedList<IntWritable>> senderList = <line9> new HashMap<Text, LinkedList<IntWritable>>(); <line10> HashMap<Text, DoubleVector> normalizedValues = new HashMap<Text, DoubleVector>(); <line11> getNormalizedItemFactorizedValues(peer, normalizedValues, senderList); <line12> saveItemFactorizedValues(peer, normalizedValues); <line13> if (itemFeatureMatrix != null) { <line14> for (Map.Entry<String, VectorWritable> feature : inpItemsFeatures.entrySet()) { <line15> peer.write( <line16> new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()), <line17> feature.getValue()); <line18> } <line19> DoubleMatrix res = <line20> normalizeMatrix( <line21> peer, itemFeatureMatrix, OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX, false); <line22> if (res != null) { <line23> Text key = <line24> new Text( <line25> OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM <line26> + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString()); <line27> peer.write(key, convertMatrixToVector(res)); <line28> } <line29> } <line30> if (userFeatureMatrix != null) { <line31> for (Map.Entry<String, VectorWritable> feature : inpUsersFeatures.entrySet()) { <line32> peer.write( <line33> new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()), <line34> feature.getValue()); <line35> } <line36> DoubleMatrix res = <line37> normalizeMatrix( <line38> peer, userFeatureMatrix, OnlineCF.Settings.MSG_USER_FEATURE_MATRIX, false); <line39> if (res != null) { <line40> Text key = <line41> new Text( <line42> OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM <line43> + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString()); <line44> peer.write(key, convertMatrixToVector(res)); <line45> } <line46> } <line47> } <line48> } <line49> 	<line2>
7163	public class A { <line0> public void saveOrUpdate( <line1> final Integer userId, final String key, final Object entry, final boolean checkAccess) { <line2> if (accessChecker.isDemoUser(userId)) { <line3> return; <line4> } <line5> boolean isNew = false; <line6> UserXmlPreferencesDO userPrefs = getUserPreferencesByUserId(userId, key, checkAccess); <line7> final Date date = new Date(); <line8> if (userPrefs == null) { <line9> isNew = true; <line10> userPrefs = new UserXmlPreferencesDO(); <line11> userPrefs.setCreated(date); <line12> userPrefs.setUser(userDao.internalGetById(userId)); <line13> userPrefs.setKey(key); <line14> } <line15> final String xml = serialize(userPrefs, entry); <line16> if (log.isDebugEnabled()) { <line17> } <line18> userPrefs.setLastUpdate(date); <line19> userPrefs.setVersion(); <line20> final UserXmlPreferencesDO userPrefsForDB = userPrefs; <line21> if (isNew) { <line22> if (log.isDebugEnabled()) { <line23> } <line24> emgrFactory.runInTrans( <line25> emgr -> { <line26> emgr.insert(userPrefsForDB); <line27> return null; <line28> }); <line29> } else { <line30> if (log.isDebugEnabled()) { <line31> } <line32> emgrFactory.runInTrans( <line33> emgr -> { <line34> UserXmlPreferencesDO attachedEntity = <line35> emgr.selectByPkAttached(UserXmlPreferencesDO.class, userPrefsForDB.getId()); <line36> attachedEntity.setSerializedSettings(userPrefsForDB.getSerializedSettings()); <line37> attachedEntity.setLastUpdate(userPrefsForDB.getLastUpdate()); <line38> attachedEntity.setVersion(); <line39> emgr.update(attachedEntity); <line40> return null; <line41> }); <line42> } <line43> } <line44> } <line45> 	<line17>, <line23>, <line31>
7164	"public class A { <line0> @Test <line1> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line2> public void testCalculateMethodInvocation() throws Exception { <line3> List requestBody = new ArrayList(); <line4> requestBody.add(1); <line5> requestBody.add(new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY)); <line6> Object responseBody = template.requestBody(""direct:thrift-zlib-calculate"", requestBody); <line7> assertNotNull(responseBody); <line8> assertTrue(responseBody instanceof Integer); <line9> assertEquals(THRIFT_TEST_NUM1 * THRIFT_TEST_NUM2, responseBody); <line10> } <line11> } <line12> "	<line3>
7165	"public class A { <line0> @Override <line1> public void removeContentModel(ContentModel model) throws ApsSystemException { <line2> try { <line3> this.getContentModelDAO().deleteContentModel(model); <line4> this.getCacheWrapper().removeContentModel(model); <line5> this.notifyContentModelChanging(model, ContentModelChangedEvent.REMOVE_OPERATION_CODE); <line6> } catch (Throwable t) { <line7> throw new ApsSystemException(""Error deleting a content model"", t); <line8> } <line9> } <line10> } <line11> "	<line7>
7166	public class A { <line0> @Override <line1> public SocialActivityLimit findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchActivityLimitException { <line3> SocialActivityLimit socialActivityLimit = fetchByPrimaryKey(primaryKey); <line4> if (socialActivityLimit == null) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchActivityLimitException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return socialActivityLimit; <line10> } <line11> } <line12> 	<line6>
7167	public class A { <line0> @Override <line1> public UploadStatistics loadImgthla( <line2> List<FileDescriptor> theFiles, RequestDetails theRequestDetails) { <line3> try (LoadedFileDescriptors descriptors = new LoadedFileDescriptors(theFiles)) { <line4> List<String> mandatoryFilenameFragments = Arrays.asList(IMGTHLA_HLA_NOM_TXT, IMGTHLA_HLA_XML); <line5> descriptors.verifyMandatoryFilesExist(mandatoryFilenameFragments); <line6> return processImgthlaFiles(descriptors, theRequestDetails); <line7> } <line8> } <line9> } <line10> 	<line6>
7168	"public class A { <line0> public void retryWorkflowWithFailedTask() { <line1> JsonParser parser = new JsonParser(); <line2> List<InsightsWorkflowExecutionHistory> readyToRunWorkflowHistory = <line3> workflowProcessing.getFailedTasksForRetry(); <line4> for (InsightsWorkflowExecutionHistory workflowHistory : readyToRunWorkflowHistory) { <line5> if (workflowHistory.getRetryCount() < maxWorkflowsRetries <line6> || workflowHistory <line7> .getWorkflowConfig() <line8> .getWorkflowType() <line9> .equalsIgnoreCase(WorkflowTaskEnum.WorkflowType.SYSTEM.name())) { <line10> InsightsWorkflowTask firstworkflowTask = <line11> workflowProcessing.getWorkflowTaskByTaskId(workflowHistory.getCurrenttask()); <line12> JsonObject mqRetryJsonObject = <line13> parser.parse(workflowHistory.getRequestMessage()).getAsJsonObject(); <line14> mqRetryJsonObject.addProperty(WorkflowUtils.RETRY_JSON_PROPERTY, true); <line15> mqRetryJsonObject.addProperty( <line16> WorkflowUtils.EXECUTION_HISTORY_JOSN_PROPERTY, workflowHistory.getId()); <line17> try { <line18> workflowProcessing.publishMessageInMQ( <line19> firstworkflowTask.getMqChannel(), mqRetryJsonObject); <line20> } catch (WorkflowTaskInitializationException e) { <line21> InsightsStatusProvider.getInstance() <line22> .createInsightStatusNode( <line23> ""In WorkflowRetryExecutor,retryWorkflowWithFailedTask failed due to exception."" <line24> + "" WorkflowId: "" <line25> + workflowHistory.getWorkflowConfig().getWorkflowId(), <line26> PlatformServiceConstants.FAILURE); <line27> } <line28> } else { <line29> workflowProcessing.updateRetryWorkflowExecutionHistory( <line30> workflowHistory.getId(), <line31> workflowHistory.getWorkflowConfig().getWorkflowId(), <line32> WorkflowTaskEnum.WorkflowStatus.ABORTED.toString(), <line33> """"); <line34> } <line35> } <line36> } <line37> } <line38> "	<line2>, <line17>, <line18>, <line21>, <line29>
7169	public class A { <line0> private long getEventDelay(Entity entity, String nominalTime) throws FalconException { <line1> Date instanceDate = EntityUtil.parseDateUTC(nominalTime); <line2> LateProcess lateProcess = EntityUtil.getLateProcess(entity); <line3> if (lateProcess == null) { <line4> return -1; <line5> } <line6> PolicyType latePolicy = lateProcess.getPolicy(); <line7> Date cutOffTime = getCutOffTime(entity, nominalTime); <line8> Date now = new Date(); <line9> Long wait; <line10> if (now.after(cutOffTime)) { <line11> return -1; <line12> } else { <line13> AbstractRerunPolicy rerunPolicy = RerunPolicyFactory.getRetryPolicy(latePolicy); <line14> wait = rerunPolicy.getDelay(lateProcess.getDelay(), instanceDate, cutOffTime); <line15> } <line16> return wait; <line17> } <line18> } <line19> 	<line4>, <line11>
7170	public class A { <line0> final void putBigResource(String resPath, ContentWriter content, long newTS) throws IOException { <line1> RollbackablePushdown pushdown = writePushdown(resPath, content); <line2> try { <line3> putResourceWithRetry(resPath, ContentWriter.create(BytesUtil.EMPTY_BYTE_ARRAY), newTS); <line4> } catch (Throwable ex) { <line5> pushdown.rollback(); <line6> throw ex; <line7> } finally { <line8> pushdown.close(); <line9> } <line10> } <line11> } <line12> 	<line3>
7171	public class A { <line0> public void onComplete(java.lang.String o) { <line1> createGroupResourceProfile_result result = new createGroupResourceProfile_result(); <line2> result.success = o; <line3> try { <line4> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line5> } catch (org.apache.thrift.transport.TTransportException e) { <line6> fb.close(); <line7> } catch (java.lang.Exception e) { <line8> onError(e); <line9> } <line10> } <line11> } <line12> 	<line6>, <line8>
7172	"public class A { <line0> private boolean canCheckout(ProjectVersion pv) throws CheckoutException { <line1> long projectId = pv.getProject().getId(); <line2> if (!tds.projectExists(projectId)) { <line3> throw new CheckoutException(""No such project "" + pv.getProject() + "" to check out.""); <line4> } <line5> if (!tds.accessorExists(projectId)) { <line6> throw new CheckoutException( <line7> ""No accessor available for project: "" + pv.getProject().getName()); <line8> } <line9> ProjectAccessor a = tds.getAccessor(projectId); <line10> if (a == null) { <line11> throw new CheckoutException( <line12> ""Accessor "" <line13> + ""for project "" <line14> + pv.getProject().getName() <line15> + "" not available even though it exists.""); <line16> } <line17> try { <line18> SCMAccessor svn = a.getSCMAccessor(); <line19> if (svn == null) { <line20> throw new CheckoutException( <line21> ""No SCM accessor available for project "" + pv.getProject().getName()); <line22> } <line23> } catch (InvalidAccessorException e) { <line24> throw new CheckoutException( <line25> ""Invalid SCM accessor for project "" + pv.getProject().getName() + "" "" + e.getMessage()); <line26> } <line27> return true; <line28> } <line29> } <line30> "	<line11>, <line20>
7173	public class A { <line0> @Inject <line1> public void configure(Properties properties) { <line2> this.properties = properties; <line3> beOverlord = isOverlord(properties); <line4> if (beOverlord) { <line5> } <line6> } <line7> } <line8> 	<line5>
7174	public class A { <line0> public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException { <line1> if (omegaContext != null) { <line2> invocation.getAttachments().put(GLOBAL_TX_ID_KEY, omegaContext.globalTxId()); <line3> invocation.getAttachments().put(LOCAL_TX_ID_KEY, omegaContext.localTxId()); <line4> invocation.getAttachments().put(GLOBAL_TX_CATEGORY_KEY, omegaContext.category()); <line5> } <line6> if (omegaContext != null && omegaContext.globalTxId() != null) { <line7> } else { <line8> } <line9> if (invoker != null) { <line10> return invoker.invoke(invocation); <line11> } <line12> return null; <line13> } <line14> } <line15> 	<line7>, <line8>
7175	public class A { <line0> protected synchronized void sendRaw(byte[] data, int delay) throws IOException { <line1> try (Socket socket = new Socket(host, port); <line2> DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream())) { <line3> socket.setSoTimeout(DEFAULT_SOCKET_TIMEOUT); <line4> sendRaw(data, outputStream); <line5> if (delay > 0) { <line6> Thread.sleep(delay); <line7> } <line8> } catch (InterruptedException e) { <line9> Thread.currentThread().interrupt(); <line10> } <line11> } <line12> } <line13> 	<line3>
7176	"public class A { <line0> private void repairMetaRename(int index) { <line1> try { <line2> path.concat(META_PREV_FILE_NAME); <line3> if (index > 0) { <line4> path.put('.').put(index); <line5> } <line6> path.$(); <line7> if (ff.exists(path)) { <line8> if (ff.exists(other.concat(META_FILE_NAME).$()) && !ff.remove(other)) { <line9> throw CairoException.instance(ff.errno()) <line10> .put(""Repair failed. Cannot replace "") <line11> .put(other); <line12> } <line13> if (!ff.rename(path, other)) { <line14> throw CairoException.instance(ff.errno()) <line15> .put(""Repair failed. Cannot rename "") <line16> .put(path) <line17> .put("" -> "") <line18> .put(other); <line19> } <line20> } <line21> } finally { <line22> path.trimTo(rootLen); <line23> other.trimTo(rootLen); <line24> } <line25> clearTodoLog(); <line26> } <line27> } <line28> "	<line8>
7177	public class A { <line0> private void closeQuietly(Statement stmt) { <line1> if (stmt != null) { <line2> try { <line3> if (!stmt.isClosed()) { <line4> stmt.close(); <line5> } <line6> } catch (Throwable sqle) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>
7178	public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> SmbResource f = this.file; <line4> this.first.waitForStart(); <line5> try (OutputStream os = f.openOutputStream(false, SmbConstants.FILE_NO_SHARE)) { <line6> } catch (IOException e) { <line7> if (e instanceof SmbException <line8> && ((SmbException) e).getNtStatus() == NtStatus.NT_STATUS_SHARING_VIOLATION) { <line9> this.completed = true; <line10> return; <line11> } <line12> throw e; <line13> } finally { <line14> this.first.shutdown(); <line15> } <line16> } catch (Exception e) { <line17> } <line18> } <line19> } <line20> 	<line6>, <line17>
7179	"public class A { <line0> @Test <line1> public void testProcedureMedia() throws Exception { <line2> tester.testPostGetDelete(jetty, ""/media/"", tester.mediaCreate(), ""identificationNumber""); <line3> tester.testLists(jetty, ""/media/"", tester.mediaCreate(), ""items""); <line4> tester.testUIspec(jetty, ""/media/uispec"", ""media.uispec""); <line5> tester.testUIspec(jetty, ""/media/uischema"", ""media.uischema""); <line6> HttpTester out = tester.GETData(""/media/uispec"", jetty); <line7> assertEquals(200, out.getStatus()); <line8> JSONObject spec = new JSONObject(out.getContent()); <line9> assertEquals( <line10> ""${fields.blobs.0.length}"", <line11> spec.getJSONObject(""recordEditor"").getString("".csc-blobs-length"")); <line12> } <line13> } <line14> "	<line4>, <line6>
7180	public class A { <line0> private void removeUnmanagedDevice() { <line1> UnmanagedDevice unmanagedDevice = <line2> this.unmanagedDeviceClient.getByName(UNMANAGED_DEVICE_NAME).get(0); <line3> String response = this.unmanagedDeviceClient.remove(unmanagedDevice.getResourceId()); <line4> } <line5> } <line6> 	<line4>
7181	public class A { <line0> @Override <line1> public void cleanup() throws IOException { <line2> writeLock(); <line3> try { <line4> if (primaryFile != null) { <line5> boolean file1Deleted = primaryFile.delete(); <line6> if (!file1Deleted) { <line7> } <line8> primaryFile = null; <line9> } <line10> if (secondaryFile != null) { <line11> boolean file2Deleted = secondaryFile.delete(); <line12> if (!file2Deleted) { <line13> } <line14> secondaryFile = null; <line15> } <line16> } finally { <line17> releaseWriteLock(); <line18> } <line19> } <line20> } <line21> 	<line5>, <line7>, <line11>, <line13>
7182	public class A { <line0> private Either<ArtifactDefinition, ResponseFormat> checkIfArtifactAlreadyExist( <line1> ArtifactTemplateInfo artifactTemplateInfo, List<ArtifactDefinition> createdArtifacts) { <line2> ArtifactDefinition res = null; <line3> String artifactFileName = artifactTemplateInfo.getFileName(); <line4> Optional<ArtifactDefinition> op = <line5> createdArtifacts.stream() <line6> .filter(a -> a.getArtifactName().equals(artifactFileName)) <line7> .findAny(); <line8> if (op.isPresent()) { <line9> res = op.get(); <line10> if (!res.getArtifactType().equalsIgnoreCase(artifactTemplateInfo.getType())) { <line11> BeEcompErrorManager.getInstance() <line12> .logInternalDataError( <line13> ARTIFACT_FILE_IS_NOT_IN_EXPECTED_FORMAT_FILE_NAME + artifactFileName, <line14> ARTIFACT_INTERNALS_ARE_INVALID, <line15> ErrorSeverity.ERROR); <line16> return Either.right( <line17> componentsUtils.getResponseFormat( <line18> ActionStatus.ARTIFACT_ALREADY_EXIST_IN_DIFFERENT_TYPE_IN_CSAR, <line19> artifactFileName, <line20> artifactTemplateInfo.getType(), <line21> res.getArtifactType())); <line22> } <line23> } <line24> return Either.left(res); <line25> } <line26> } <line27> 	<line11>
7183	"public class A { <line0> public static void waitForKafkaTopicSpecStability( <line1> String topicName, String podName, String bootstrapServer) { <line2> int[] stableCounter = {0}; <line3> String oldSpec = describeTopicViaKafkaPod(topicName, podName, bootstrapServer); <line4> TestUtils.waitFor( <line5> ""KafkaTopic's spec will be stable"", <line6> Constants.GLOBAL_POLL_INTERVAL, <line7> Constants.GLOBAL_STATUS_TIMEOUT, <line8> () -> { <line9> if (oldSpec.equals(describeTopicViaKafkaPod(topicName, podName, bootstrapServer))) { <line10> stableCounter[0]++; <line11> if (stableCounter[0] == Constants.GLOBAL_STABILITY_OFFSET_COUNT) { <line12> return true; <line13> } <line14> } else { <line15> stableCounter[0] = 0; <line16> return false; <line17> } <line18> return false; <line19> }); <line20> } <line21> } <line22> "	<line12>, <line15>, <line18>
7184	public class A { <line0> public static SenseiRequestBPO.Request convert(SenseiRequest req) { <line1> SenseiRequestBPO.Request.Builder builder = SenseiRequestBPO.Request.newBuilder(); <line2> try { <line3> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line4> ObjectOutputStream oos; <line5> oos = new ObjectOutputStream(baos); <line6> oos.writeObject(req); <line7> oos.close(); <line8> byte[] raw = baos.toByteArray(); <line9> builder.setVal(ByteString.copyFrom(raw)); <line10> return builder.build(); <line11> } catch (IOException e) { <line12> } <line13> return SenseiRequestBPO.Request.getDefaultInstance(); <line14> } <line15> } <line16> 	<line12>
7185	public class A { <line0> private Map<StaticBuffer, EntryList> getHelper(List<StaticBuffer> keys, Filter getFilter) <line1> throws BackendException { <line2> List<Get> requests = new ArrayList<Get>(keys.size()); <line3> { <line4> for (StaticBuffer key : keys) { <line5> Get g = <line6> new Get(key.as(StaticBuffer.ARRAY_FACTORY)) <line7> .addFamily(columnFamilyBytes) <line8> .setFilter(getFilter); <line9> try { <line10> g.setTimeRange(0, Long.MAX_VALUE); <line11> } catch (IOException e) { <line12> throw new PermanentBackendException(e); <line13> } <line14> requests.add(g); <line15> } <line16> } <line17> Map<StaticBuffer, EntryList> resultMap = new HashMap<StaticBuffer, EntryList>(keys.size()); <line18> try { <line19> TableMask table = null; <line20> Result[] results = null; <line21> try { <line22> table = cnx.getTable(tableName); <line23> results = table.get(requests); <line24> } finally { <line25> IOUtils.closeQuietly(table); <line26> } <line27> if (results == null) return KCVSUtil.emptyResults(keys); <line28> assert results.length == keys.size(); <line29> for (int i = 0; i < results.length; i++) { <line30> Result result = results[i]; <line31> NavigableMap<byte[], NavigableMap<byte[], NavigableMap<Long, byte[]>>> f = result.getMap(); <line32> if (f == null) { <line33> resultMap.put(keys.get(i), EntryList.EMPTY_LIST); <line34> continue; <line35> } <line36> NavigableMap<byte[], NavigableMap<Long, byte[]>> r = f.get(columnFamilyBytes); <line37> resultMap.put( <line38> keys.get(i), <line39> (r == null) <line40> ? EntryList.EMPTY_LIST <line41> : StaticArrayEntryList.ofBytes(r.entrySet(), entryGetter)); <line42> } <line43> return resultMap; <line44> } catch (IOException e) { <line45> throw new TemporaryBackendException(e); <line46> } <line47> } <line48> } <line49> 	<line23>, <line24>
7186	"public class A { <line0> @Override <line1> public void deregisterObject(JRVirtualizable o) { <line2> String uid = o.getUID(); <line3> if (log.isDebugEnabled()) { <line4> } <line5> try { <line6> dispose(o); <line7> } catch (Exception e) { <line8> } <line9> synchronized (this) { <line10> JRVirtualizable oldIn = pagedIn.remove(uid); <line11> if (oldIn != null) { <line12> if (oldIn != o) { <line13> pagedIn.put(uid, oldIn); <line14> throw new IllegalStateException(""Wrong object stored with UID \"""" + o.getUID() + ""\""""); <line15> } <line16> Object contextLast = lastObjectMap.get(o.getContext()); <line17> if (contextLast == o) { <line18> lastObjectMap.remove(o.getContext()); <line19> lastObjectSet.remove(o); <line20> } <line21> } else { <line22> Object oldOut = pagedOut.remove(uid); <line23> if (oldOut != null && oldOut != o) { <line24> pagedOut.put(uid, oldOut); <line25> throw new IllegalStateException(""Wrong object stored with UID \"""" + o.getUID() + ""\""""); <line26> } <line27> } <line28> } <line29> if (log.isDebugEnabled()) { <line30> } <line31> } <line32> } <line33> "	<line4>, <line8>, <line30>
7187	"public class A { <line0> public boolean addConstraintMapping(HttpContext httpContext, WebContainer service, Object cm) { <line1> if (cm instanceof ConstraintMapping) { <line2> ConstraintMapping constraintMapping = (ConstraintMapping) cm; <line3> Constraint constraint = constraintMapping.getConstraint(); <line4> String[] roles = constraint.getRoles(); <line5> String name = ""Constraint-"" + new SecureRandom().nextInt(Integer.MAX_VALUE); <line6> int dataConstraint = constraint.getDataConstraint(); <line7> String dataConstraintStr; <line8> switch (dataConstraint) { <line9> case Constraint.DC_UNSET: <line10> dataConstraintStr = null; <line11> break; <line12> case Constraint.DC_NONE: <line13> dataConstraintStr = ""NONE""; <line14> break; <line15> case Constraint.DC_CONFIDENTIAL: <line16> dataConstraintStr = ""CONFIDENTIAL""; <line17> break; <line18> case Constraint.DC_INTEGRAL: <line19> dataConstraintStr = ""INTEGRAL""; <line20> break; <line21> default: <line22> log.warnv(""Unknown data constraint: "" + dataConstraint); <line23> dataConstraintStr = ""CONFIDENTIAL""; <line24> } <line25> List<String> rolesList = Arrays.asList(roles); <line26> service.registerConstraintMapping( <line27> name, <line28> null, <line29> constraintMapping.getPathSpec(), <line30> dataConstraintStr, <line31> constraint.getAuthenticate(), <line32> rolesList, <line33> httpContext); <line34> return true; <line35> } <line36> return false; <line37> } <line38> } <line39> "	<line26>
7188	public class A { <line0> @Override <line1> public void initialize() throws SAException { <line2> if (logger.isInfoEnabled()) { <line3> } <line4> synchronizationStorageAdapter.initialize(); <line5> blobStoreStorageAdapter.initialize(); <line6> } <line7> } <line8> 	<line3>
7189	public class A { <line0> @Override <line1> public ResourceInfo getResourceInfo(RepositoryContext context, String location) { <line2> File file = getFile(context, location); <line3> if (file != null) { <line4> try { <line5> Path filePath = file.toPath().toRealPath(); <line6> if (rootRealPath != null && filePath.startsWith(rootRealPath)) { <line7> Path relativePath = rootRealPath.relativize(filePath); <line8> return StandardResourceInfo.from(relativePath); <line9> } else if (resolveAbsolutePath) { <line10> return StandardResourceInfo.from(filePath); <line11> } <line12> } catch (IOException e) { <line13> } <line14> } <line15> return null; <line16> } <line17> } <line18> 	<line13>
7190	"public class A { <line0> private boolean waitForMinimumRecordCount() { <line1> try { <line2> String query = String.format(""select count(*) as count from `%s`"", bucketName); <line3> QueryResult queryResult = cluster.query(query); <line4> List<JsonObject> results = queryResult.rowsAsObject(); <line5> if (results.isEmpty()) { <line6> return false; <line7> } <line8> int size = results.get(0).getInt(""count""); <line9> if (size < expect) { <line10> return false; <line11> } <line12> return size == expect; <line13> } catch (Exception e) { <line14> } <line15> return false; <line16> } <line17> } <line18> "	<line10>, <line14>
7191	public class A { <line0> @AfterClass <line1> public static void exitTest() throws Exception { <line2> clearAllTable(); <line3> } <line4> } <line5> 	<line2>
7192	public class A { <line0> protected static Option addCodeCoverageOption() { <line1> String coverageCommand = System.getProperty(COVERAGE_COMMAND); <line2> if (coverageCommand != null) { <line3> return CoreOptions.vmOption(coverageCommand); <line4> } <line5> return null; <line6> } <line7> } <line8> 	<line3>
7193	public class A { <line0> private synchronized void applyUpdates() { <line1> for (final String name : pendingUpdates) { <line2> accessoryRegistry.remove(name); <line3> getItemOptional(name).ifPresent(this::createRootAccessories); <line4> } <line5> if (!pendingUpdates.isEmpty()) { <line6> makeNewConfigurationRevision(); <line7> pendingUpdates.clear(); <line8> } <line9> } <line10> } <line11> 	<line1>, <line3>
7194	public class A { <line0> @Test <line1> public void testGetEnvironmentVariable() { <line2> String env = locationManager.getEnvironmentVariable(); <line3> } <line4> } <line5> 	<line3>
7195	public class A { <line0> public static int getFragmentCollectionsCount(long[] groupIds) throws RemoteException { <line1> try { <line2> int returnValue = FragmentCollectionServiceUtil.getFragmentCollectionsCount(groupIds); <line3> return returnValue; <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>
7196	"public class A { <line0> @Test <line1> public void testOneDelayedPredicate() throws Exception { <line2> for (final TestCities city : TestCities.values()) { <line3> String query = <line4> ""((_Delayed_ = true) and ("" <line5> + CityField.CITY.name() <line6> + EQ_OP <line7> + ""'"" <line8> + city.name().toLowerCase() <line9> + ""'))""; <line10> String expectQuery = CityField.CITY.name() + EQ_OP + ""'"" + city.name().toLowerCase() + ""'""; <line11> runTest(query, expectQuery); <line12> } <line13> } <line14> } <line15> "	<line2>
7197	public class A { <line0> @Override <line1> public void onResponseHead(final HttpConnection connection, final HttpResponse response) { <line2> if (headerLog.isDebugEnabled()) { <line3> final String id = LoggingSupport.getId(connection); <line4> for (final Iterator<Header> it = response.headerIterator(); it.hasNext(); ) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line4>, <line5>
7198	"public class A { <line0> public static BinaryVectorizer load(File f) throws IOException { <line1> RandomAccessFile file = new RandomAccessFile(f, ""rw""); <line2> Header header = Header.read(file); <line3> String[] words = new String[header.getWordCount()]; <line4> for (int i = 0; i < header.getWordCount(); i++) { <line5> words[i] = file.readUTF(); <line6> } <line7> byte[] buffer = new byte[header.getVectorLength() * Float.BYTES]; <line8> file.readFully(buffer); <line9> ByteBuffer byteBuffer = ByteBuffer.wrap(buffer); <line10> float[] unk = new float[header.getVectorLength()]; <line11> for (int i = 0; i < unk.length; i++) { <line12> unk[i] = byteBuffer.getFloat(i * Float.BYTES); <line13> } <line14> long offset = file.getFilePointer(); <line15> return new BinaryVectorizer(header, file, words, offset, unk); <line16> } <line17> } <line18> "	<line7>
7199	"public class A { <line0> @Override <line1> public DLFileEntry findByG_F_FN(long groupId, long folderId, String fileName) <line2> throws NoSuchFileEntryException { <line3> DLFileEntry dlFileEntry = fetchByG_F_FN(groupId, folderId, fileName); <line4> if (dlFileEntry == null) { <line5> StringBundler sb = new StringBundler(8); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""groupId=""); <line8> sb.append(groupId); <line9> sb.append("", folderId=""); <line10> sb.append(folderId); <line11> sb.append("", fileName=""); <line12> sb.append(fileName); <line13> sb.append(""}""); <line14> if (_log.isDebugEnabled()) { <line15> } <line16> throw new NoSuchFileEntryException(sb.toString()); <line17> } <line18> return dlFileEntry; <line19> } <line20> } <line21> "	<line15>
7200	public class A { <line0> @Test <line1> public void onlineValidation() throws Exception { <line2> String token = securityTest.createToken().getTokenValue(); <line3> JwtDecoder jwtDecoder = createOnlineJwtDecoder(); <line4> assertThat(jwtDecoder.decode(token)).isNotNull(); <line5> BenchmarkUtil.Result result = BenchmarkUtil.execute(() -> jwtDecoder.decode(token)); <line6> } <line7> } <line8> 	<line6>
7201	"public class A { <line0> @Override <line1> public void run() { <line2> Thread.currentThread().setName(""SierraUsb598""); <line3> } <line4> } <line5> "	<line3>
7202	"public class A { <line0> void readGeneScores(String geneScoreFile) { <line1> geneScore = new HashMap<String, Double>(); <line2> String lines[] = Gpr.readFile(geneScoreFile).split(""\n""); <line3> double minp = Double.POSITIVE_INFINITY, maxp = Double.NEGATIVE_INFINITY; <line4> for (String line : lines) { <line5> String rec[] = line.split(""\\s""); <line6> String geneId = rec[0].trim(); <line7> double score = Gpr.parseDoubleSafe(rec[1]); <line8> if ((score > 0) && (score <= 1.0)) { <line9> geneScore.put(geneId, score); <line10> minp = Math.min(minp, score); <line11> maxp = Math.max(maxp, score); <line12> } <line13> if (verbose) <line14> } <line15> } <line16> "	<line1>, <line12>, <line14>
7203	public class A { <line0> @Override <line1> public void testStarted(Description description) { <line2> startTimeTestCase = System.currentTimeMillis(); <line3> printDescription(description, 1); <line4> } <line5> } <line6> 	<line2>, <line4>
7204	public class A { <line0> public static List<Setting> getSettings() { <line1> try { <line2> return (List<Setting>) <line3> getClient().invokePort(directConfigClazz, DIRECT_SERVICE_NAME_GET_SETTINGS); <line4> } catch (Exception ex) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	<line5>
7205	public class A { <line0> public void add(final TaskContext taskContext) { <line1> if (regCenter.getNumChildren(FailoverNode.ROOT) <line2> > env.getFrameworkConfiguration().getJobStateQueueSize()) { <line3> return; <line4> } <line5> String failoverTaskNodePath = <line6> FailoverNode.getFailoverTaskNodePath(taskContext.getMetaInfo().toString()); <line7> if (!regCenter.isExisted(failoverTaskNodePath) <line8> && !runningService.isTaskRunning(taskContext.getMetaInfo())) { <line9> regCenter.persist(failoverTaskNodePath, taskContext.getId()); <line10> } <line11> } <line12> } <line13> 	<line3>
7206	public class A { <line0> public boolean enqueue(final MessageHolder<?> holder) { <line1> if (queue.offer(holder)) { <line2> conditionalFlush(); <line3> return true; <line4> } <line5> return false; <line6> } <line7> } <line8> 	<line1>, <line2>, <line5>
7207	public class A { <line0> public org.apache.thrift.async.AsyncMethodCallback<Void> getResultHandler( <line1> final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, <line2> final int seqid) { <line3> final org.apache.thrift.AsyncProcessFunction fcall = this; <line4> return new org.apache.thrift.async.AsyncMethodCallback<Void>() { <line5> public void onComplete(Void o) { <line6> setManagerGoalState_result result = new setManagerGoalState_result(); <line7> try { <line8> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line9> } catch (org.apache.thrift.transport.TTransportException e) { <line10> fb.close(); <line11> } catch (java.lang.Exception e) { <line12> onError(e); <line13> } <line14> } <line15>  <line16> public void onError(java.lang.Exception e) { <line17> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line18> org.apache.thrift.TSerializable msg; <line19> setManagerGoalState_result result = new setManagerGoalState_result(); <line20> if (e instanceof org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException) { <line21> result.sec = (org.apache.accumulo.core.clientImpl.thrift.ThriftSecurityException) e; <line22> result.setSecIsSet(true); <line23> msg = result; <line24> } else if (e <line25> instanceof org.apache.accumulo.core.clientImpl.thrift.ThriftNotActiveServiceException) { <line26> result.tnase = <line27> (org.apache.accumulo.core.clientImpl.thrift.ThriftNotActiveServiceException) e; <line28> result.setTnaseIsSet(true); <line29> msg = result; <line30> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line31> fb.close(); <line32> return; <line33> } else if (e instanceof org.apache.thrift.TApplicationException) { <line34> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line35> msg = (org.apache.thrift.TApplicationException) e; <line36> } else { <line37> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line38> msg = <line39> new org.apache.thrift.TApplicationException( <line40> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line41> } <line42> try { <line43> fcall.sendResponse(fb, msg, msgType, seqid); <line44> } catch (java.lang.Exception ex) { <line45> fb.close(); <line46> } <line47> } <line48> }; <line49> } <line50> } <line51> 	<line10>, <line12>, <line31>, <line34>, <line37>, <line45>
7208	public class A { <line0> @Override <line1> public void receive( <line2> List<org.wso2.carbon.databridge.commons.Event> eventList, Credentials credentials) { <line3> if (eventList.size() > 0) { <line4> thriftTestCompletedinServerTwo = true; <line5> } <line6> } <line7> } <line8> 	<line3>, <line5>
7209	public class A { <line0> public static void executeMemberActivatedExtension(Map<String, String> envParameters) { <line1> try { <line2> if (log.isDebugEnabled()) { <line3> } <line4> String script = System.getProperty(CartridgeAgentConstants.MEMBER_ACTIVATED_SCRIPT); <line5> String command = prepareCommand(script); <line6> addPayloadParameters(envParameters); <line7> cleanProcessParameters(envParameters); <line8> String output = CommandUtils.executeCommand(command, envParameters); <line9> if (log.isDebugEnabled()) { <line10> } <line11> } catch (Exception e) { <line12> if (log.isErrorEnabled()) { <line13> } <line14> } <line15> } <line16> } <line17> 	<line3>, <line10>, <line13>
7210	public class A { <line0> private Set<Class<?>> addExtraDependencies(CConfiguration cConf, Set<Class<?>> dependencies) { <line1> if (clusterMode == ClusterMode.ON_PREMISE) { <line2> try { <line3> dependencies.add(HBaseTableUtilFactory.getHBaseTableUtilClass(cConf)); <line4> } catch (Exception e) { <line5> } <line6> if (SecureStoreUtils.isKMSBacked(cConf) && SecureStoreUtils.isKMSCapable()) { <line7> dependencies.add(SecureStoreUtils.getKMSSecureStore()); <line8> } <line9> } <line10> return dependencies; <line11> } <line12> } <line13> 	<line5>
7211	"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public Object call() throws Exception { <line3> if (log.isDebugEnabled()) <line4> IgniteCacheProxy cache = ctx.cache().jcache(cacheName).cacheNoGate(); <line5> cache.context().awaitStarted(); <line6> if (skipStore) cache = (IgniteCacheProxy<?, ?>) cache.withSkipStore(); <line7> if (keepBinary) cache = (IgniteCacheProxy<?, ?>) cache.withKeepBinary(); <line8> if (ignoreDepOwnership) cache.context().deploy().ignoreOwnership(true); <line9> try { <line10> final GridCacheContext cctx = cache.context(); <line11> for (DataStreamerEntry e : col) { <line12> e.getKey().finishUnmarshal(cctx.cacheObjectContext(), cctx.deploy().globalLoader()); <line13> CacheObject val = e.getValue(); <line14> if (val != null) { <line15> checkSecurityPermission(SecurityPermission.CACHE_PUT); <line16> val.finishUnmarshal(cctx.cacheObjectContext(), cctx.deploy().globalLoader()); <line17> } else checkSecurityPermission(SecurityPermission.CACHE_REMOVE); <line18> } <line19> if (unwrapEntries()) { <line20> Collection<Map.Entry> col0 = <line21> F.viewReadOnly( <line22> col, <line23> new C1<DataStreamerEntry, Map.Entry>() { <line24> @Override <line25> public Map.Entry apply(DataStreamerEntry e) { <line26> return e.toEntry(cctx, keepBinary); <line27> } <line28> }); <line29> rcvr.receive(cache, col0); <line30> } else rcvr.receive(cache, col); <line31> return null; <line32> } finally { <line33> if (ignoreDepOwnership) cache.context().deploy().ignoreOwnership(false); <line34> } <line35> } <line36> } <line37> "	<line4>, <line34>
7212	public class A { <line0> private MutationBatch doWrite( <line1> ApplicationScope collectionScope, Id entityId, UUID version, RowOp op) { <line2> final MutationBatch batch = keyspace.prepareMutationBatch(); <line3> final long timestamp = version.timestamp(); <line4> if (logger.isTraceEnabled()) { <line5> } <line6> final Id applicationId = collectionScope.getApplication(); <line7> final ScopedRowKey<K> key = createKey(applicationId, entityId); <line8> op.doOp(batch.withRow(CF_ENTITY_LOG, key)); <line9> return batch; <line10> } <line11> } <line12> 	<line5>
7213	public class A { <line0> private void addToRole(User admin, Team iesiTeam, String roleName) { <line1> Optional<Role> sysAdminRole = <line2> iesiTeam.getRoles().stream() <line3> .filter(role -> role.getName().equalsIgnoreCase(roleName)) <line4> .findFirst(); <line5> if (sysAdminRole.isPresent()) { <line6> admin.getRoleKeys().add(sysAdminRole.get().getMetadataKey()); <line7> } else { <line8> } <line9> } <line10> } <line11> 	<line6>, <line8>
7214	"public class A { <line0> public boolean pkgReset() { <line1> CommandInfo cmdInfo = cset.newCommandInfo(CommandInfo.CMD_RESET); <line2> if (""ask"".equalsIgnoreCase(accept)) { <line3> accept = <line4> readConsole( <line5> ""The reset will erase Marketplace packages history.\n"" <line6> + ""Do you want to continue (yes/no)? [yes] "", <line7> ""yes""); <line8> } <line9> if (!Boolean.parseBoolean(accept)) { <line10> cmdInfo.exitCode = 1; <line11> return false; <line12> } <line13> try { <line14> service.reset(); <line15> List<LocalPackage> localPackages = service.getPackages(); <line16> for (LocalPackage localPackage : localPackages) { <line17> localPackage.getUninstallFile().delete(); <line18> FileUtils.deleteDirectory(localPackage.getData().getEntry(LocalPackage.BACKUP_DIR)); <line19> newPackageInfo(cmdInfo, localPackage); <line20> } <line21> service.getRegistry().delete(); <line22> FileUtils.deleteDirectory(service.getBackupDir()); <line23> } catch (PackageException e) { <line24> log.error(e); <line25> cmdInfo.exitCode = 1; <line26> } catch (IOException e) { <line27> cmdInfo.exitCode = 1; <line28> } <line29> return cmdInfo.exitCode == 0; <line30> } <line31> } <line32> "	<line15>, <line27>
7215	"public class A { <line0> @Override <line1> public Map<String, Double> getScores() { <line2> if (coefficients == null) { <line3> return null; <line4> } else { <line5> Map<String, Double> scores = new HashMap<>(); <line6> try { <line7> scores.put(""rSquared"", olsModel.calculateRSquared()); <line8> scores.put(""totalSumOfSquares"", olsModel.calculateTotalSumOfSquares()); <line9> } catch (SingularMatrixException sme) { <line10> } <line11> return scores; <line12> } <line13> } <line14> } <line15> "	<line10>
7216	"public class A { <line0> @Override <line1> public Optional<Record> lookup(Map<String, Object> coordinates, Map<String, String> context) <line2> throws LookupFailureException { <line3> final String endpoint = determineEndpoint(coordinates, context); <line4> final String mimeType = (String) coordinates.get(MIME_TYPE_KEY); <line5> final String method = <line6> ((String) coordinates.getOrDefault(METHOD_KEY, ""get"")).trim().toLowerCase(); <line7> final String body = (String) coordinates.get(BODY_KEY); <line8> validateVerb(method); <line9> if (StringUtils.isBlank(body)) { <line10> if (method.equals(""post"") || method.equals(""put"")) { <line11> throw new LookupFailureException( <line12> String.format( <line13> ""Used HTTP verb %s without specifying the %s key to provide a payload."", <line14> method, BODY_KEY)); <line15> } <line16> } else { <line17> if (StringUtils.isBlank(mimeType)) { <line18> throw new LookupFailureException( <line19> String.format(""Request body is specified without its %s."", MIME_TYPE_KEY)); <line20> } <line21> } <line22> Request request = buildRequest(mimeType, method, body, endpoint, context); <line23> try { <line24> Response response = executeRequest(request); <line25> if (getLogger().isDebugEnabled()) { <line26> getLogger() <line27> } <line28> final ResponseBody responseBody = response.body(); <line29> if (responseBody == null) { <line30> return Optional.empty(); <line31> } <line32> final Record record; <line33> try (final InputStream is = responseBody.byteStream(); <line34> final InputStream bufferedIn = new BufferedInputStream(is)) { <line35> record = handleResponse(bufferedIn, responseBody.contentLength(), context); <line36> } <line37> return Optional.ofNullable(record); <line38> } catch (Exception e) { <line39> throw new LookupFailureException(e); <line40> } <line41> } <line42> } <line43> "	<line27>, <line39>
7217	public class A { <line0> @Override <line1> protected void initChannel(final SocketChannel ch) throws Exception { <line2> Iec61850Config.this.createChannelPipeline( <line3> ch, Iec61850Config.this.iec61850ChannelHandlerServer()); <line4> } <line5> } <line6> 	<line4>
7218	public class A { <line0> private static Properties filterAndLoadProperties( <line1> List<ConfigProperty> properties, <line2> Scope scope, <line3> BiFunction<PropertyKey, String, String> logMessage) { <line4> Properties props = new Properties(); <line5> for (ConfigProperty property : properties) { <line6> String name = property.getName(); <line7> if (PropertyKey.isValid(name) && property.hasValue()) { <line8> PropertyKey key = PropertyKey.fromString(name); <line9> if (!GrpcUtils.contains(key.getScope(), scope)) { <line10> continue; <line11> } <line12> String value = property.getValue(); <line13> props.put(key, value); <line14> } <line15> } <line16> return props; <line17> } <line18> } <line19> 	<line14>
7219	"public class A { <line0> @Override <line1> @SuppressFBWarnings(""SLF4J_FORMAT_SHOULD_BE_CONST"") <line2> public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext) <line3> throws IOException { <line4> if (responseContext.getStatusInfo().getFamily().equals(Response.Status.Family.SUCCESSFUL) <line5> && !isContentTypeCompatible(responseContext.getMediaType())) { <line6> String snippet = <line7> String.format(""Wrong content type received: [%s]"", responseContext.getMediaType()); <line8> throw new IllegalStateException(snippet); <line9> } <line10> } <line11> } <line12> "	<line6>, <line8>
7220	public class A { <line0> public static List<Integer> loadJava(Class<?> annotItfClass) { <line1> List<Integer> updatedCEs = new LinkedList<>(); <line2> List<CoreElementDefinition> ceds = ITFParser.parseITFMethods(annotItfClass); <line3> for (CoreElementDefinition ced : ceds) { <line4> CoreElement ce = CoreManager.registerNewCoreElement(ced); <line5> Integer methodId = ce.getCoreId(); <line6> updatedCEs.add(methodId); <line7> } <line8> return updatedCEs; <line9> } <line10> } <line11> 	<line1>
7221	"public class A { <line0> @Override <line1> public <T> T get(Class<T> interfaceClass, String key, IPentahoSession session) <line2> throws ObjectFactoryException { <line3> if (key != null) { <line4> readLock.lock(); <line5> try { <line6> for (IPentahoObjectFactory fact : factories) { <line7> if (fact.objectDefined(key)) { <line8> T object = fact.get(interfaceClass, key, session); <line9> return object; <line10> } <line11> } <line12> } finally { <line13> readLock.unlock(); <line14> } <line15> } <line16> T fromType = get(interfaceClass, session, null); <line17> if (fromType != null) { <line18> return fromType; <line19> } <line20> String msg = <line21> Messages.getInstance() <line22> .getString( <line23> ""AbstractSpringPentahoObjectFactory.WARN_FAILED_TO_RETRIEVE_OBJECT"", <line24> interfaceClass.getSimpleName()); <line25> throw new ObjectFactoryException(msg); <line26> } <line27> } <line28> "	<line9>
7222	"public class A { <line0> private Response<BackfillPayload> getBackfill(RequestContext rc, String id) { <line1> final boolean includeStatuses = rc.request().parameter(""status"").orElse(""true"").equals(""true""); <line2> final Optional<Backfill> backfillOpt; <line3> try { <line4> backfillOpt = storage.backfill(id); <line5> } catch (IOException e) { <line6> final String message = String.format(""Couldn't read backfill %s. "", id); <line7> return Response.forStatus( <line8> Status.INTERNAL_SERVER_ERROR.withReasonPhrase(""Error in internal storage"")); <line9> } <line10> if (backfillOpt.isEmpty()) { <line11> return Response.forStatus(Status.NOT_FOUND); <line12> } <line13> final Backfill backfill = backfillOpt.get(); <line14> if (includeStatuses) { <line15> final List<RunStateData> statuses = retrieveBackfillStatuses(backfill); <line16> return Response.forPayload( <line17> BackfillPayload.create(backfill, Optional.of(RunStateDataPayload.create(statuses)))); <line18> } else { <line19> return Response.forPayload(BackfillPayload.create(backfill, Optional.empty())); <line20> } <line21> } <line22> } <line23> "	<line7>
7223	public class A { <line0> private void purgeVersion( <line1> Tx tx, <line2> Long txCounter, <line3> BulkActionContext bac, <line4> NodeGraphFieldContainer lastRemaining, <line5> NodeGraphFieldContainer version, <line6> boolean previousRemoved, <line7> ZonedDateTime maxAge) { <line8> ContentDaoWrapper contentDao = tx.contentDao(); <line9> List<NodeGraphFieldContainer> nextVersions = <line10> Lists.newArrayList(contentDao.getNextVersions(version)); <line11> boolean isNewerThanMaxAge = maxAge != null && !isOlderThanMaxAge(version, maxAge); <line12> boolean isInTimeFrame = maxAge == null || isOlderThanMaxAge(version, maxAge); <line13> if (isInTimeFrame && version.isPurgeable()) { <line14> contentDao.delete(version, bac, false); <line15> previousRemoved = true; <line16> txCounter++; <line17> } else { <line18> if (previousRemoved) { <line19> contentDao.setNextVersion(lastRemaining, version); <line20> txCounter++; <line21> } <line22> if (txCounter % meshOptions.getVersionPurgeMaxBatchSize() == 0 && txCounter != 0) { <line23> tx.getGraph().commit(); <line24> } <line25> lastRemaining = version; <line26> previousRemoved = false; <line27> } <line28> if (isNewerThanMaxAge) { <line29> return; <line30> } else { <line31> for (NodeGraphFieldContainer next : nextVersions) { <line32> purgeVersion(tx, txCounter, bac, lastRemaining, next, previousRemoved, maxAge); <line33> } <line34> } <line35> } <line36> } <line37> 	<line14>, <line19>, <line23>
7224	"public class A { <line0> public synchronized void signalLosePrimacy() { <line1> Preconditions.checkState( <line2> mState.get() == State.PRIMARY, ""unexpected journal state "" + mState.get()); <line3> mState.set(State.SECONDARY); <line4> } <line5> } <line6> "	<line4>
7225	"public class A { <line0> public CouchDBMapping build() { <line1> if (mapping.getDatabaseName() == null) { <line2> throw new IllegalStateException(""A collection is not specified""); <line3> } <line4> return mapping; <line5> } <line6> } <line7> "	<line2>
7226	"public class A { <line0> public static void appendToFile(File file, String... lines) { <line1> ArgumentNotValid.checkNotNull(file, ""File file""); <line2> ArgumentNotValid.checkNotNull(lines, ""String... lines""); <line3> PrintWriter writer = null; <line4> int linesAppended = 0; <line5> try { <line6> boolean appendMode = true; <line7> writer = new PrintWriter(new FileWriter(file, appendMode)); <line8> for (String line : lines) { <line9> writer.println(line); <line10> linesAppended++; <line11> } <line12> } catch (IOException e) { <line13> } finally { <line14> if (writer != null) { <line15> writer.close(); <line16> } <line17> } <line18> } <line19> } <line20> "	<line13>
7227	"public class A { <line0> private void analyzeResult( <line1> org.apache.hadoop.fs.FileSystem fs, TestType testType, long execTime, String resFileName) <line2> throws IOException { <line3> Path reduceFile = getReduceFilePath(testType); <line4> long tasks = 0; <line5> long size = 0; <line6> long time = 0; <line7> float rate = 0; <line8> float sqrate = 0; <line9> DataInputStream in = null; <line10> BufferedReader lines = null; <line11> try { <line12> in = new DataInputStream(fs.open(reduceFile)); <line13> lines = new BufferedReader(new InputStreamReader(in)); <line14> String line; <line15> while ((line = lines.readLine()) != null) { <line16> StringTokenizer tokens = new StringTokenizer(line, "" \t\n\r\f%""); <line17> String attr = tokens.nextToken(); <line18> if (attr.endsWith("":tasks"")) { <line19> tasks = Long.parseLong(tokens.nextToken()); <line20> } else if (attr.endsWith("":size"")) { <line21> size = Long.parseLong(tokens.nextToken()); <line22> } else if (attr.endsWith("":time"")) { <line23> time = Long.parseLong(tokens.nextToken()); <line24> } else if (attr.endsWith("":rate"")) { <line25> rate = Float.parseFloat(tokens.nextToken()); <line26> } else if (attr.endsWith("":sqrate"")) { <line27> sqrate = Float.parseFloat(tokens.nextToken()); <line28> } <line29> } <line30> } finally { <line31> if (in != null) { <line32> in.close(); <line33> } <line34> if (lines != null) { <line35> lines.close(); <line36> } <line37> } <line38> double med = rate / 1000 / tasks; <line39> double stdDev = Math.sqrt(Math.abs(sqrate / 1000 / tasks - med * med)); <line40> String[] resultLines = { <line41> ""----- DFSIOIntegrationTest ----- : "" + testType, <line42> ""           Date & time: "" + new Date(System.currentTimeMillis()), <line43> ""       Number of files: "" + tasks, <line44> ""Total MBytes processed: "" + toMB(size), <line45> ""     Throughput mb/sec: "" + size * 1000.0 / (time * MEGA), <line46> ""Average IO rate mb/sec: "" + med, <line47> "" IO rate std deviation: "" + stdDev, <line48> ""    Test exec time sec: "" + (float) execTime / 1000, <line49> """" <line50> }; <line51> PrintStream res = null; <line52> try { <line53> if (sGenerateReportFile) { <line54> res = new PrintStream(new FileOutputStream(new File(resFileName), true)); <line55> } <line56> for (String resultLine : resultLines) { <line57> if (sGenerateReportFile) { <line58> res.println(resultLine); <line59> } else { <line60> System.out.println(resultLine); <line61> } <line62> } <line63> } finally { <line64> if (res != null) { <line65> res.close(); <line66> } <line67> } <line68> } <line69> } <line70> "	<line57>
7228	public class A { <line0> private ServerSocket get(String hostname, Supplier<Integer> randomPortMaker) { <line1> ServerSocket ss = null; <line2> int port = -1; <line3> while (true) { <line4> port = randomPortMaker.get(); <line5> try { <line6> ss = new ServerSocket(); <line7> ss.bind(new InetSocketAddress(hostname, port)); <line8> break; <line9> } catch (IOException ioe) { <line10> try { <line11> ss.close(); <line12> } catch (IOException ioe2) { <line13> } <line14> } <line15> } <line16> return ss; <line17> } <line18> } <line19> 	<line10>, <line13>
7229	"public class A { <line0> void dispatch(final StaplerRequest request, final StaplerResponse rsp, final String body) { <line1> final String pathInfo = request.getPathInfo(); <line2> final String eventName = pathInfoToEventName(pathInfo); <line3> try { <line4> final JSONObject response = innerDispatch(body, eventName, HOOK_EVENT_FACTORIES_BY_NAME); <line5> rsp.setStatus(SC_OK); <line6> rsp.setContentType(MediaType.APPLICATION_JSON_UTF_8); <line7> final PrintWriter w = rsp.getWriter(); <line8> final String responseJsonString = response.toString(); <line9> w.print(responseJsonString); <line10> w.println(); <line11> } catch (final IllegalArgumentException e) { <line12> LOGGER.log(Level.WARNING, ""IllegalArgumentException"", e); <line13> } catch (final Exception e) { <line14> final String template = ""Error while performing reaction to '%s' event.""; <line15> final String message = String.format(template, eventName); <line16> LOGGER.log(Level.SEVERE, message, e); <line17> } <line18> } <line19> } <line20> "	<line13>, <line17>
7230	public class A { <line0> public void deleteOAuthClientService() { <line1> String bridgeUID = bridgeHandler.getThing().getUID().getAsString(); <line2> oAuthClientService.removeAccessTokenRefreshListener(this); <line3> oAuthFactory.deleteServiceAndAccessToken(bridgeUID); <line4> } <line5> } <line6> 	<line2>
7231	"public class A { <line0> private synchronized void writePidFile(final String pid, final Logger logger) throws IOException { <line1> final File pidFile = getPidFile(logger); <line2> if (pidFile.exists() && !pidFile.delete()) { <line3> } <line4> if (!pidFile.createNewFile()) { <line5> throw new IOException(""Failed to create file "" + pidFile); <line6> } <line7> try { <line8> final Set<PosixFilePermission> perms = new HashSet<>(); <line9> perms.add(PosixFilePermission.OWNER_WRITE); <line10> perms.add(PosixFilePermission.OWNER_READ); <line11> perms.add(PosixFilePermission.GROUP_READ); <line12> perms.add(PosixFilePermission.OTHERS_READ); <line13> Files.setPosixFilePermissions(pidFile.toPath(), perms); <line14> } catch (final Exception e) { <line15> } <line16> try (final FileOutputStream fos = new FileOutputStream(pidFile)) { <line17> fos.write(pid.getBytes(StandardCharsets.UTF_8)); <line18> fos.getFD().sync(); <line19> } <line20> } <line21> } <line22> "	<line3>, <line15>, <line20>
7232	public class A { <line0> private Reducer createReducerInstance(ClassLoader classLoader, String userReducer) { <line1> try { <line2> return (Reducer) classLoader.loadClass(userReducer).newInstance(); <line3> } catch (Exception e) { <line4> throw Throwables.propagate(e); <line5> } <line6> } <line7> } <line8> 	<line4>
7233	"public class A { <line0> @Around(value = ""addMandatoryPointcutScenario(pickle)"") <line1> public void aroundAddMandatoryPointcut(ProceedingJoinPoint pjp, PickleEvent pickle) <line2> throws Throwable { <line3> Runner runner = (Runner) pjp.getThis(); <line4> Class<?> sc = runner.getClass(); <line5> Method tt = sc.getDeclaredMethod(""buildBackendWorlds""); <line6> tt.setAccessible(true); <line7> tt.invoke(runner); <line8> String scenarioName = pickle.pickle.getName(); <line9> List<PickleTag> pickleTagList = pickle.pickle.getTags(); <line10> List<String> tagList = new ArrayList<>(); <line11> for (PickleTag pt : pickleTagList) { <line12> tagList.add(pt.getName()); <line13> } <line14> boolean exec = manageTags(tagList); <line15> if (!exec) { <line16> } else { <line17> pjp.proceed(); <line18> } <line19> } <line20> } <line21> "	<line16>
7234	public class A { <line0> void passivate() { <line1> if (currentThreadCount.get().getAndDecrement() == 1) { <line2> lastActivatedStackTrace.set(null); <line3> fireSessionEvent(passivated, concurrentAccess.decrementAndGet()); <line4> } else { <line5> } <line6> if (!firstURI.isPresent()) { <line7> firstURI = Optional.of(DEFAULT_URI); <line8> } <line9> onCommitTasks.remove(); <line10> servletJob.remove(); <line11> } <line12> } <line13> 	<line5>
7235	public class A { <line0> public static void stop() { <line1> if (!enabled && registry.getRegistries().isEmpty()) { <line2> return; <line3> } <line4> enabled = false; <line5> if (jvmGcMetrics != null) { <line6> jvmGcMetrics.close(); <line7> jvmGcMetrics = null; <line8> } <line9> List<MeterRegistry> list = new ArrayList<>(); <line10> registry <line11> .getRegistries() <line12> .forEach( <line13> r -> { <line14> list.add(r); <line15> r.close(); <line16> }); <line17> list.forEach(r -> registry.remove(r)); <line18> } <line19> } <line20> 	<line4>, <line18>
7236	public class A { <line0> private float[] recommendCreations( <line1> int coreCount, <line2> long creationTime, <line3> long[] aggregatedMinCoreTime, <line4> long[] aggregatedMeanCoreTime, <line5> long[] aggregatedMaxCoreTime, <line6> int[] totalSlots, <line7> int[] realSlots) { <line8> float[] creations = new float[coreCount]; <line9> for (int coreId = 0; coreId < coreCount; coreId++) { <line10> long totalTime = totalSlots[coreId] * creationTime; <line11> long embraceableLoad = totalTime; <line12> long remainingLoad = aggregatedMeanCoreTime[coreId] - embraceableLoad; <line13> if (DEBUG) { <line14> } <line15> if (remainingLoad > 0) { <line16> creations[coreId] = (int) (remainingLoad / creationTime); <line17> if (DEBUG) { <line18> } <line19> } else { <line20> creations[coreId] = 0; <line21> } <line22> } <line23> return creations; <line24> } <line25> } <line26> 	<line14>, <line18>
7237	"public class A { <line0> private Mono<ResourceResponse<DocumentCollection>> readCollectionInternal( <line1> String collectionLink, <line2> RequestOptions options, <line3> DocumentClientRetryPolicy retryPolicyInstance) { <line4> try { <line5> if (StringUtils.isEmpty(collectionLink)) { <line6> throw new IllegalArgumentException(""collectionLink""); <line7> } <line8> String path = Utils.joinPath(collectionLink, null); <line9> Map<String, String> requestHeaders = <line10> this.getRequestHeaders(options, ResourceType.DocumentCollection, OperationType.Read); <line11> RxDocumentServiceRequest request = <line12> RxDocumentServiceRequest.create( <line13> this, <line14> OperationType.Read, <line15> ResourceType.DocumentCollection, <line16> path, <line17> requestHeaders, <line18> options); <line19> if (retryPolicyInstance != null) { <line20> retryPolicyInstance.onBeforeSendRequest(request); <line21> } <line22> return this.read(request, retryPolicyInstance) <line23> .map(response -> toResourceResponse(response, DocumentCollection.class)); <line24> } catch (Exception e) { <line25> } <line26> } <line27> } <line28> "	<line8>, <line25>
7238	"public class A { <line0> @Override <line1> public ICommandOutput execute() throws JobException { <line2> final ExecutorService executor = Executors.newSingleThreadExecutor(); <line3> future = <line4> new FutureTask<Integer>( <line5> new Callable<Integer>() { <line6> public Integer call() throws JobException, IOException { <line7> executor.shutdown(); <line8> return executeCommand(executeCommand); <line9> } <line10> }); <line11> executor.execute(future); <line12> int exitCode = -1; <line13> if (!isAsync) { <line14> try { <line15> exitCode = future.get(); <line16> } catch (CancellationException e) { <line17> exitCode = -2; <line18> } catch (Exception e) { <line19> throw new JobException(""Error when execute job "" + executeCommand, e); <line20> } finally { <line21> if (exitCode == 0) { <line22> output.setStatus(JobStepStatusEnum.FINISHED); <line23> } else if (exitCode == -2) { <line24> output.setStatus(JobStepStatusEnum.DISCARDED); <line25> } else { <line26> output.setStatus(JobStepStatusEnum.ERROR); <line27> } <line28> output.setExitCode(exitCode); <line29> } <line30> } <line31> return output; <line32> } <line33> } <line34> "	<line16>, <line17>
7239	public class A { <line0> void updateTypeVertex(AtlasBaseTypeDef typeDef, AtlasVertex vertex) { <line1> if (!isTypeVertex(vertex)) { <line2> return; <line3> } <line4> updateVertexProperty(vertex, Constants.GUID_PROPERTY_KEY, typeDef.getGuid()); <line5> updateVertexProperty(vertex, Constants.TYPEDESCRIPTION_PROPERTY_KEY, typeDef.getDescription()); <line6> updateVertexProperty(vertex, Constants.TYPEVERSION_PROPERTY_KEY, typeDef.getTypeVersion()); <line7> updateVertexProperty( <line8> vertex, Constants.TYPEOPTIONS_PROPERTY_KEY, AtlasType.toJson(typeDef.getOptions())); <line9> if (StringUtils.isNotEmpty(typeDef.getServiceType())) { <line10> updateVertexProperty( <line11> vertex, Constants.TYPESERVICETYPE_PROPERTY_KEY, typeDef.getServiceType()); <line12> } <line13> markVertexUpdated(vertex); <line14> } <line15> } <line16> 	<line2>
7240	public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> getUsersWithRole_result result = new getUsersWithRole_result(); <line4> if (e <line5> instanceof <line6> org.apache.airavata.service.profile.iam.admin.services.cpi.exception <line7> .IamAdminServicesException) { <line8> result.Idse = <line9> (org.apache.airavata.service.profile.iam.admin.services.cpi.exception <line10> .IamAdminServicesException) <line11> e; <line12> result.setIdseIsSet(true); <line13> msg = result; <line14> } else if (e instanceof org.apache.airavata.model.error.AuthorizationException) { <line15> result.ae = (org.apache.airavata.model.error.AuthorizationException) e; <line16> result.setAeIsSet(true); <line17> msg = result; <line18> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line19> fb.close(); <line20> return; <line21> } else if (e instanceof org.apache.thrift.TApplicationException) { <line22> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line23> msg = (org.apache.thrift.TApplicationException) e; <line24> } else { <line25> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line26> msg = <line27> new org.apache.thrift.TApplicationException( <line28> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line29> } <line30> try { <line31> fcall.sendResponse(fb, msg, msgType, seqid); <line32> } catch (java.lang.Exception ex) { <line33> fb.close(); <line34> } <line35> } <line36> } <line37> 	<line19>, <line22>, <line25>, <line33>
7241	public class A { <line0> protected void startHeartBeat() { <line1> String intervalStr = <line2> session.getFactoryManager().getProperties().get(ClientFactoryManager.HEARTBEAT_INTERVAL); <line3> try { <line4> int interval = intervalStr != null ? Integer.parseInt(intervalStr) : 0; <line5> if (interval > 0) { <line6> session <line7> .getFactoryManager() <line8> .getScheduledExecutorService() <line9> .scheduleAtFixedRate( <line10> new Runnable() { <line11> public void run() { <line12> sendHeartBeat(); <line13> } <line14> }, <line15> interval, <line16> interval, <line17> TimeUnit.MILLISECONDS); <line18> } <line19> } catch (NumberFormatException e) { <line20> } <line21> } <line22> } <line23> 	<line20>
7242	"public class A { <line0> public void onData(IStream stream, DataFrame frame, Callback callback) { <line1> HTTP2Channel.Server channel = (HTTP2Channel.Server) stream.getAttachment(); <line2> if (channel != null) { <line3> Runnable task = channel.onData(frame, callback); <line4> if (task != null) offerTask(task, false); <line5> } else { <line6> callback.failed(new IOException(""channel_not_found"")); <line7> } <line8> } <line9> } <line10> "	<line1>
7243	public class A { <line0> private Map<String, Object> getTemplateVariables(Locale locale) { <line1> Map<String, Object> templateVariables = Maps.newHashMap(); <line2> Map<String, Object> sharedVariables = templateVariablesByLocale.get(null); <line3> if (sharedVariables != null) { <line4> templateVariables.putAll(sharedVariables); <line5> } <line6> Map<String, Object> localeDependentVariables = templateVariablesByLocale.get(locale); <line7> if (localeDependentVariables != null) { <line8> templateVariables.putAll(localeDependentVariables); <line9> } <line10> if (!attachments.isEmpty()) { <line11> if (!templateVariables.containsKey(ATTACHMENT_NAMES_VARIABLE_NAME)) { <line12> Collection<String> labels = Lists.newArrayList(); <line13> for (LabelValue<String, ?> labelValue : attachments) { <line14> labels.add(labelValue.getLabel()); <line15> } <line16> templateVariables.put(ATTACHMENT_NAMES_VARIABLE_NAME, labels); <line17> } else { <line18> } <line19> } <line20> return templateVariables; <line21> } <line22> } <line23> 	<line18>
7244	"public class A { <line0> private synchronized Pattern getPatternForUri() { <line1> if (null == _uri_pattern) { <line2> try { <line3> _uri_pattern = Pattern.compile(""^http://id.nlm.nih.gov/mesh/(\\d{4,4}/)?[DQMCT\\d]+$""); <line4> } catch (PatternSyntaxException e) { <line5> } <line6> } <line7> return _uri_pattern; <line8> } <line9> } <line10> "	<line5>
7245	public class A { <line0> public void send( <line1> final RequestMessage requestMessage, <line2> final String messageType, <line3> final MessageMetadata messageMetadata) { <line4> this.jmsTemplate.send( <line5> (final Session session) -> { <line6> final ObjectMessage objectMessage = session.createObjectMessage(requestMessage); <line7> objectMessage.setJMSCorrelationID(requestMessage.getCorrelationUid()); <line8> objectMessage.setJMSType(messageType); <line9> objectMessage.setStringProperty( <line10> Constants.ORGANISATION_IDENTIFICATION, <line11> requestMessage.getOrganisationIdentification()); <line12> objectMessage.setStringProperty( <line13> Constants.DEVICE_IDENTIFICATION, requestMessage.getDeviceIdentification()); <line14> if (messageMetadata != null) { <line15> objectMessage.setJMSPriority(messageMetadata.getMessagePriority()); <line16> objectMessage.setStringProperty(Constants.DOMAIN, messageMetadata.getDomain()); <line17> objectMessage.setStringProperty( <line18> Constants.DOMAIN_VERSION, messageMetadata.getDomainVersion()); <line19> objectMessage.setStringProperty(Constants.IP_ADDRESS, messageMetadata.getIpAddress()); <line20> objectMessage.setBooleanProperty(Constants.IS_SCHEDULED, messageMetadata.isScheduled()); <line21> objectMessage.setIntProperty(Constants.RETRY_COUNT, messageMetadata.getRetryCount()); <line22> objectMessage.setBooleanProperty( <line23> Constants.BYPASS_RETRY, messageMetadata.isBypassRetry()); <line24> } <line25> return objectMessage; <line26> }); <line27> } <line28> } <line29> 	<line4>
7246	public class A { <line0> @Override <line1> public IXMLSerializer createSerializer(final Class<?> classContext, final URL schemaFile) { <line2> return new XMLSerializer(classContext, schemaFile); <line3> } <line4> } <line5> 	<line2>
7247	"public class A { <line0> public List findDeletedEventCRFsFromAuditEventByEventCRFStatus(int studyEventId) { <line1> this.unsetTypeExpected(); <line2> this.setTypeExpected(1, TypeNames.INT); <line3> this.setTypeExpected(2, TypeNames.STRING); <line4> this.setTypeExpected(3, TypeNames.STRING); <line5> this.setTypeExpected(4, TypeNames.STRING); <line6> this.setTypeExpected(5, TypeNames.TIMESTAMP); <line7> this.setTypeExpected(6, TypeNames.INT); <line8> HashMap variables = new HashMap(); <line9> variables.put(new Integer(1), new Integer(40)); <line10> variables.put(new Integer(2), new Integer(studyEventId)); <line11> String sql = digester.getQuery(""findDeletedEventCRFsFromAuditEventByEventCRFStatus""); <line12> ArrayList alist = this.select(sql, variables); <line13> ArrayList al = new ArrayList(); <line14> Iterator it = alist.iterator(); <line15> while (it.hasNext()) { <line16> DeletedEventCRFBean bean = new DeletedEventCRFBean(); <line17> HashMap map = (HashMap) it.next(); <line18> bean.setStudyEventId(studyEventId); <line19> bean.setCrfName((String) map.get(""crf_name"")); <line20> bean.setCrfVersion((String) map.get(""crf_version_name"")); <line21> bean.setDeletedBy((String) map.get(""user_name"")); <line22> bean.setDeletedDate((Date) map.get(""audit_date"")); <line23> bean.setDeletedEventCrfId((Integer) map.get(""event_crf_id"")); <line24> al.add(bean); <line25> } <line26> return al; <line27> } <line28> } <line29> "	<line15>
7248	public class A { <line0> @Override <line1> public void run() { <line2> synchronized (BlockingRpcConnection.this) { <line3> while (!closed) { <line4> if (callsToWrite.isEmpty()) { <line5> try { <line6> BlockingRpcConnection.this.wait(); <line7> } catch (InterruptedException e) { <line8> } <line9> continue; <line10> } <line11> Call call = callsToWrite.poll(); <line12> if (call.isDone()) { <line13> continue; <line14> } <line15> try (Scope scope = call.span.makeCurrent()) { <line16> writeRequest(call); <line17> } catch (IOException e) { <line18> call.setException(e); <line19> closeConn(e); <line20> } <line21> } <line22> } <line23> } <line24> } <line25> 	<line18>
7249	public class A { <line0> @Override <line1> public void addFeeds(RebindContext rebindContext, EntityMemento memento) { <line2> for (String feedId : memento.getFeeds()) { <line3> AbstractFeed feed = (AbstractFeed) rebindContext.lookup().lookupFeed(feedId); <line4> if (feed != null) { <line5> try { <line6> entity.feeds().add(feed); <line7> } catch (Exception e) { <line8> rebindContext.getExceptionHandler().onAddFeedFailed(entity, feed, e); <line9> } <line10> try { <line11> if (!rebindContext.isReadOnly(feed)) { <line12> feed.start(); <line13> } <line14> } catch (Exception e) { <line15> rebindContext.getExceptionHandler().onRebindFailed(BrooklynObjectType.ENTITY, entity, e); <line16> } <line17> } else { <line18> } <line19> } <line20> } <line21> } <line22> 	<line18>
7250	public class A { <line0> @Test <line1> public void testServerFunctionExecution_NoAck() { <line2> createScenario(); <line3> functionNoAck = new TestFunction(false, TEST_FUNCTION1, true); <line4> functionAck = new TestFunction(true, TEST_FUNCTION1, true); <line5> registerFunctionAtServer(functionNoAck); <line6> registerFunctionAtServer(functionAck); <line7> isByName = new Boolean(true); <line8> toRegister = new Boolean(true); <line9> client.invoke( <line10> () -> <line11> PRClientServerFunctionExecutionNoAckDUnitTest.serverExecution( <line12> isByName, functionNoAck, functionAck, toRegister)); <line13> client.invoke( <line14> () -> <line15> PRClientServerFunctionExecutionNoAckDUnitTest.allServerExecution( <line16> isByName, functionNoAck, toRegister)); <line17> } <line18> } <line19> 	<line9>
7251	"public class A { <line0> public DataTableSpec getNewSpec(final DataTableSpec inSpec) throws InvalidSettingsException { <line1> m_missingColumnNames.clear(); <line2> DataColumnSpec[] colSpecs = new DataColumnSpec[inSpec.getNumColumns()]; <line3> HashMap<String, Integer> duplicateHash = new HashMap<>(); <line4> List<RenameColumnSetting> renameSettings = <line5> m_settings == null <line6> ? new ArrayList<RenameColumnSetting>() <line7> : new ArrayList<>(m_settings.values()); <line8> for (int i = 0; i < colSpecs.length; i++) { <line9> DataColumnSpec current = inSpec.getColumnSpec(i); <line10> String name = current.getName(); <line11> RenameColumnSetting set = findAndRemoveSettings(name, renameSettings); <line12> DataColumnSpec newColSpec; <line13> if (set == null) { <line14> newColSpec = current; <line15> } else { <line16> newColSpec = set.configure(current); <line17> } <line18> String newName = newColSpec.getName(); <line19> CheckUtils.checkSetting( <line20> StringUtils.isNotEmpty(newName), ""Column name at index '%d' is empty."", i); <line21> Integer duplIndex = duplicateHash.put(newName, i); <line22> CheckUtils.checkSetting( <line23> duplIndex == null, <line24> ""Duplicate column name '%s' at index '%d' and '%d'"", <line25> newName, <line26> duplIndex, <line27> i); <line28> colSpecs[i] = newColSpec; <line29> } <line30> if (!renameSettings.isEmpty()) { <line31> for (RenameColumnSetting setting : renameSettings) { <line32> String name = setting.getName(); <line33> if (StringUtils.isNotEmpty(name)) { <line34> m_missingColumnNames.add(name); <line35> } <line36> } <line37> } <line38> return new DataTableSpec(colSpecs); <line39> } <line40> } <line41> "	<line14>
7252	public class A { <line0> @Override <line1> public void close() { <line2> if (log.isDebugEnabled()) { <line3> } <line4> monitor.close(); <line5> } <line6> } <line7> 	<line3>
7253	"public class A { <line0> protected boolean _ping() { <line1> try { <line2> String pingURL = url + ""/ping/"" + getServiceName() + ""/"" + id; <line3> Request req = Request.create(pingURL, METHOD.GET); <line4> req.getHeader().clear(); <line5> req.getHeader().set(""If-None-Match"", lastPingETag); <line6> Response resp = <line7> Sender.create(req, conf.getInt(""loach.client.ping.timeout"", 1000)) <line8> .setConnTimeout(1000) <line9> .send(); <line10> String cnt = resp.getContent(); <line11> if (resp.isOK()) { <line12> lastPingETag = Strings.sBlank(resp.getHeader().get(""ETag""), ""ABC""); <line13> NutMap re = Json.fromJson(NutMap.class, cnt); <line14> if (re != null && re.getBoolean(""ok"", false)) return true; <line15> } else if (resp.getStatus() == 304) { <line16> return true; <line17> } <line18> } catch (Throwable e) { <line19> log.debugf(""bad url? %s %s"", url, e.getMessage()); <line20> } <line21> return false; <line22> } <line23> } <line24> "	<line3>, <line11>
7254	"public class A { <line0> public static boolean endSwitch(String dataHost) { <line1> String path = ZKUtils.getZKBasePath() + ""heartbeat/"" + dataHost + ""/""; <line2> String changingResultPath = path + ""changingStatue""; <line3> Map<String, String> propertyMap = new HashMap<>(); <line4> String myId = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID); <line5> propertyMap.put(myId + ""_changing_statue"", ""switching success""); <line6> propertyMap.put(myId + ""_endTime"", new Date().toString()); <line7> try { <line8> try { <line9> changingStatueLock.acquire(30000, TimeUnit.MILLISECONDS); <line10> ZKUtils.writeProperty(changingResultPath, propertyMap); <line11> } finally { <line12> changingStatueLock.release(); <line13> } <line14> return true; <line15> } catch (Exception e) { <line16> return false; <line17> } <line18> } <line19> } <line20> "	<line16>
7255	public class A { <line0> private void scheduleQueryRevoking(QueryContext queryContext, long maxTotalMemory) { <line1> memoryRevocationExecutor.execute( <line2> () -> { <line3> try { <line4> revokeQueryMemory(queryContext, maxTotalMemory); <line5> } catch (Exception e) { <line6> } <line7> }); <line8> } <line9> } <line10> 	<line6>
7256	"public class A { <line0> @Override <line1> protected String convertFromXmlDocument(Document xml) throws AtlasException { <line2> if (LOG.isTraceEnabled()) { <line3> try { <line4> } catch (Exception e) { <line5> } <line6> } <line7> W3CDOMInfosetInputter input = new W3CDOMInfosetInputter(xml); <line8> ByteArrayOutputStream bos = new ByteArrayOutputStream(); <line9> UnparseResult result = this.daffodil.unparse(input, Channels.newChannel(bos)); <line10> if (result.isError()) { <line11> StringBuffer buf = new StringBuffer(""DFDL document read error""); <line12> result <line13> .getDiagnostics() <line14> .forEach( <line15> d -> { <line16> buf.append(""; "").append(d.getMessage()); <line17> }); <line18> throw new AtlasException(buf.toString()); <line19> } <line20> return new String(bos.toByteArray()); <line21> } <line22> } <line23> "	<line4>
7257	public class A { <line0> public void showStatus(String msg) { <line1> } <line2> } <line3> 	<line1>
7258	public class A { <line0> protected boolean acceptFile(String filePathStr) { <line1> if (partitionCount > 1) { <line2> int i = getPartition(filePathStr); <line3> int mod = i % partitionCount; <line4> if (mod < 0) { <line5> mod += partitionCount; <line6> } <line7> if (mod != partitionIndex) { <line8> return false; <line9> } <line10> } <line11> Pattern regex = this.getRegex(); <line12> if (regex != null) { <line13> String fileName = new File(filePathStr).getName(); <line14> Matcher matcher = regex.matcher(fileName); <line15> if (!matcher.matches()) { <line16> return false; <line17> } <line18> } <line19> return true; <line20> } <line21> } <line22> 	<line7>
7259	"public class A { <line0> private void recoveryDataSplits() throws IOException { <line1> if (appAttemptId.getAttemptId() > 1) { <line2> try { <line3> dataSpliter = appStateStorage.loadDataSplits(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> if (dataSpliter == null) { <line8> try { <line9> dataSpliter = new DataSpliter(appContext); <line10> dataSpliter.generateSplits(); <line11> appStateStorage.writeDataSplits(dataSpliter); <line12> } catch (Exception x) { <line13> throw new IOException(x); <line14> } <line15> } <line16> if (dataSpliter.getSplitNum() == 0) { <line17> throw new IOException(""training data directory is empty""); <line18> } <line19> } <line20> } <line21> "	<line5>, <line13>
7260	public class A { <line0> @Override <line1> public void doStateTransition() { <line2> try { <line3> TransactionBody cryptoCreateTxn = txnCtx.accessor().getTxn(); <line4> AccountID sponsor = cryptoCreateTxn.getTransactionID().getAccountID(); <line5> CryptoCreateTransactionBody op = cryptoCreateTxn.getCryptoCreateAccount(); <line6> long balance = op.getInitialBalance(); <line7> AccountID created = ledger.create(sponsor, balance, asCustomizer(op)); <line8> txnCtx.setCreated(created); <line9> txnCtx.setStatus(SUCCESS); <line10> } catch (InsufficientFundsException ife) { <line11> txnCtx.setStatus(INSUFFICIENT_PAYER_BALANCE); <line12> } catch (Exception e) { <line13> txnCtx.setStatus(FAIL_INVALID); <line14> } <line15> } <line16> } <line17> 	<line13>
7261	public class A { <line0> public void afterPropertiesSet() throws IOException, CacheException { <line1> Configuration config; <line2> if (this.configuration != null) { <line3> config = this.configuration; <line4> } else if (this.configLocation != null) { <line5> config = ConfigurationFactory.parseConfiguration(this.configLocation.getInputStream()); <line6> } else { <line7> config = new Configuration(); <line8> } <line9> if (this.cacheManagerName != null) { <line10> config.setName(this.cacheManagerName); <line11> } <line12> this.cacheManager = new CacheManager(config); <line13> if (!this.cacheManager.isNamed()) { <line14> } <line15> } <line16> } <line17> 	<line1>, <line14>
7262	public class A { <line0> public static State getMiles(QuantityType<Length> qtLength) { <line1> if (qtLength.intValue() == -1) { <line2> return UnDefType.UNDEF; <line3> } <line4> QuantityType<Length> qt = qtLength.toUnit(ImperialUnits.MILE); <line5> if (qt != null) { <line6> return qt; <line7> } else { <line8> return UnDefType.UNDEF; <line9> } <line10> } <line11> } <line12> 	<line8>
7263	public class A { <line0> private static void loadJsonEnv() { <line1> ObjectMapper mapper = new ObjectMapper(); <line2> try { <line3> File jsonFile = new File(Environment.getInstance().getScaleConfig()).getAbsoluteFile(); <line4> jsonEnv = mapper.readTree(jsonFile); <line5> } catch (Exception e) { <line6> jsonEnv = mapper.createObjectNode(); <line7> } <line8> } <line9> } <line10> 	<line6>
7264	"public class A { <line0> private void addDocsServlets(WebAppContext docsContext) { <line1> try { <line2> final File docsDir = getDocsDir(docsLocation); <line3> ServletHolder defaultHolder = new ServletHolder(""default"", DefaultServlet.class); <line4> defaultHolder.setInitParameter(""dirAllowed"", ""false""); <line5> ServletHolder docs = new ServletHolder(""docs"", DefaultServlet.class); <line6> docs.setInitParameter(""resourceBase"", docsDir.getPath()); <line7> docs.setInitParameter(""dirAllowed"", ""false""); <line8> docsContext.addServlet(docs, ""/html/*""); <line9> docsContext.addServlet(defaultHolder, ""/""); <line10> final File webApiDocsDir = new File(webApiContext.getTempDirectory(), ""webapp/docs""); <line11> if (!webApiDocsDir.exists()) { <line12> final boolean made = webApiDocsDir.mkdirs(); <line13> if (!made) { <line14> throw new RuntimeException(webApiDocsDir.getAbsolutePath() + "" could not be created""); <line15> } <line16> } <line17> ServletHolder apiDocs = new ServletHolder(""apiDocs"", DefaultServlet.class); <line18> apiDocs.setInitParameter(""resourceBase"", webApiDocsDir.getPath()); <line19> apiDocs.setInitParameter(""dirAllowed"", ""false""); <line20> docsContext.addServlet(apiDocs, ""/rest-api/*""); <line21> } catch (Exception ex) { <line22> startUpFailure(ex); <line23> } <line24> } <line25> } <line26> "	<line21>, <line22>
7265	"public class A { <line0> public void mockIntpProcessMeta(String metaKey, boolean online) { <line1> HashMap<String, Object> meta = new HashMap<>(); <line2> meta.put(ClusterMeta.SERVER_HOST, ""127.0.0.1""); <line3> meta.put(ClusterMeta.SERVER_PORT, 6000); <line4> meta.put(ClusterMeta.INTP_TSERVER_HOST, ""127.0.0.1""); <line5> meta.put(ClusterMeta.INTP_TSERVER_PORT, tSocket.getServerSocket().getLocalPort()); <line6> meta.put(ClusterMeta.CPU_CAPACITY, ""CPU_CAPACITY""); <line7> meta.put(ClusterMeta.CPU_USED, ""CPU_USED""); <line8> meta.put(ClusterMeta.MEMORY_CAPACITY, ""MEMORY_CAPACITY""); <line9> meta.put(ClusterMeta.MEMORY_USED, ""MEMORY_USED""); <line10> meta.put(ClusterMeta.LATEST_HEARTBEAT, LocalDateTime.now()); <line11> if (online) { <line12> meta.put(ClusterMeta.STATUS, ONLINE_STATUS); <line13> } else { <line14> meta.put(ClusterMeta.STATUS, OFFLINE_STATUS); <line15> } <line16> clusterClient.putClusterMeta(ClusterMetaType.INTP_PROCESS_META, metaKey, meta); <line17> HashMap<String, HashMap<String, Object>> check = <line18> clusterClient.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, metaKey); <line19> assertNotNull(check); <line20> assertNotNull(check.get(metaKey)); <line21> assertEquals(true, check.get(metaKey).size() == 10); <line22> } <line23> } <line24> "	<line19>
7266	public class A { <line0> public static synchronized LumifyBootstrap bootstrap(final Configuration configuration) { <line1> if (lumifyBootstrap == null) { <line2> lumifyBootstrap = new LumifyBootstrap(configuration); <line3> } <line4> return lumifyBootstrap; <line5> } <line6> } <line7> 	<line2>
7267	public class A { <line0> public void cleanup() { <line1> synchronized (HTTPRemoteFileRegistry.class) { <line2> try { <line3> server.stop(); <line4> } catch (Exception e) { <line5> } <line6> try { <line7> Runtime.getRuntime().removeShutdownHook(cleanupHook); <line8> } catch (Exception e) { <line9> } <line10> instance = null; <line11> } <line12> } <line13> } <line14> 	<line5>
7268	public class A { <line0> @Override <line1> protected void changeMode(String mode) throws DaikinCommunicationException { <line2> AirbaseMode newMode; <line3> try { <line4> newMode = AirbaseMode.valueOf(mode); <line5> } catch (IllegalArgumentException ex) { <line6> return; <line7> } <line8> if (airbaseModelInfo != null) { <line9> if ((newMode == AirbaseMode.AUTO && !airbaseModelInfo.features.contains(AirbaseFeature.AUTO)) <line10> || (newMode == AirbaseMode.DRY <line11> && !airbaseModelInfo.features.contains(AirbaseFeature.DRY))) { <line12> return; <line13> } <line14> } <line15> AirbaseControlInfo info = webTargets.getAirbaseControlInfo(); <line16> info.mode = newMode; <line17> webTargets.setAirbaseControlInfo(info); <line18> } <line19> } <line20> 	<line6>, <line12>
7269	"public class A { <line0> private Map<String, Map<String, URL>> sortAndNormalizeScopes(JsonObject obj, URL baseURL) { <line1> final Map<String, Map<String, URL>> normalized = new HashMap<>(); <line2> for (Map.Entry<String, Object> kv : obj) { <line3> if (!(kv.getValue() instanceof JsonObject)) { <line4> throw new RuntimeException( <line5> ""The value for the "" + kv.getKey() + "" scope prefix must be an object.""); <line6> } <line7> final URL scopePrefixURL = tryURLParse(kv.getKey(), baseURL); <line8> if (scopePrefixURL == null) { <line9> continue; <line10> } <line11> final String normalizedScopePrefix = href(scopePrefixURL); <line12> normalized.put( <line13> normalizedScopePrefix, sortAndNormalizeSpecifierMap((JsonObject) kv.getValue(), baseURL)); <line14> } <line15> return new TreeMap<>(normalized); <line16> } <line17> } <line18> "	<line9>
7270	"public class A { <line0> public static void sendEvent(RegressionEnvironment env, String value, String typeName) { <line1> String xml = XML_NOSCHEMAEVENT.replaceAll(""VAL1"", value); <line2> sendXMLEvent(env, xml, typeName); <line3> } <line4> } <line5> "	<line2>
7271	public class A { <line0> private void addHdfsOperationHandler( <line1> final Class<? extends Operation> opClass, final OperationHandler handler) { <line2> try { <line3> addOperationHandler(opClass, handler); <line4> } catch (final NoClassDefFoundError e) { <line5> } <line6> } <line7> } <line8> 	<line5>
7272	"public class A { <line0> @Override <line1> @Nullable <line2> public ValueObject filterValue(ValueObject value) { <line3> if (value == null) { <line4> return null; <line5> } <line6> String html = value.asString().asNative(); <line7> if (html == null) { <line8> return null; <line9> } <line10> @Nonnull Multiset<String> valueCounts = HashMultiset.create(); <line11> try { <line12> Parser parser = Parser.htmlParser().setTrackErrors(0); <line13> @Nonnull Document doc = parser.parseInput(html, """"); <line14> @Nonnull Elements tags = doc.select(tagName); <line15> for (Element tag : tags) { <line16> for (String tagAttr : tagAttrs) { <line17> @Nonnull String attrValue = tag.attr(tagAttr).toLowerCase(); <line18> for (String matchValue : values) { <line19> if (attrValue.contains(matchValue)) { <line20> valueCounts.add(matchValue); <line21> } <line22> } <line23> } <line24> } <line25> } catch (Exception e) { <line26> if (parserErrors++ % logEveryN == 0) { <line27> } <line28> } <line29> return valueCounts.isEmpty() ? null : multisetToValueMap(valueCounts); <line30> } <line31> } <line32> "	<line27>
7273	public class A { <line0> private void start() { <line1> fetchScheduleService.scheduleAtFixedRate( <line2> () -> { <line3> try { <line4> fetchAllApp(); <line5> } catch (Exception e) { <line6> } <line7> }, <line8> 10, <line9> intervalSecond, <line10> TimeUnit.SECONDS); <line11> } <line12> } <line13> 	<line6>
7274	public class A { <line0> @Override <line1> @Subscribe <line2> public void handleRebuildEvent(RebuildIndexEvent event) { <line3> if (event.affects(SearchIndex.MEMBER)) { <line4> rebuildIndex(); <line5> } <line6> } <line7> } <line8> 	<line4>
7275	public class A { <line0> public void setAuthorizationId(final String id) { <line1> checkImmutable(); <line2> authorizationId = id; <line3> } <line4> } <line5> 	<line2>
7276	"public class A { <line0> public void setAsText(String text) throws IllegalArgumentException { <line1> ConceptService cs = Context.getConceptService(); <line2> if (StringUtils.hasText(text)) { <line3> try { <line4> setValue(cs.getConceptNumeric(Integer.valueOf(text))); <line5> } catch (Exception ex) { <line6> ConceptNumeric conceptNumeric = cs.getConceptNumericByUuid(text); <line7> setValue(conceptNumeric); <line8> if (conceptNumeric == null) { <line9> throw new IllegalArgumentException(""Concept not found: "" + ex.getMessage()); <line10> } <line11> } <line12> } else { <line13> setValue(null); <line14> } <line15> } <line16> } <line17> "	<line9>
7277	public class A { <line0> @Override <line1> public Collection<Document> toDocuments(LuceneIndex index, Object value) { <line2> Document doc = new Document(); <line3> PdxInstance pdx = (PdxInstance) value; <line4> for (String field : index.getFieldNames()) { <line5> if (pdx.hasField(field)) { <line6> Object fieldValue = pdx.getField(field); <line7> if (fieldValue == null) { <line8> continue; <line9> } <line10> SerializerUtil.addField(doc, field, fieldValue); <line11> } <line12> } <line13> if (logger.isDebugEnabled()) { <line14> } <line15> return Collections.singleton(doc); <line16> } <line17> } <line18> 	<line14>
7278	public class A { <line0> public void setFromStringArray(String[] BBOX, int recWatch) { <line1> if (BBOX.length == 4) { <line2> coords[0] = Double.parseDouble(BBOX[0]); <line3> coords[1] = Double.parseDouble(BBOX[1]); <line4> coords[2] = Double.parseDouble(BBOX[2]); <line5> coords[3] = Double.parseDouble(BBOX[3]); <line6> } else if (recWatch < 4) { <line7> setFromBBOXString(BBOX[0], recWatch); <line8> } else { <line9> } <line10> } <line11> } <line12> 	<line9>
7279	"public class A { <line0> @Deprecated <line1> @SuppressWarnings(""deprecation"") <line2> private static List<RuntimeConfigurationProducer> findAllProducers( <line3> Location location, ConfigurationContext context) { <line4> ConfigurationType.EP_NAME.getExtensionList(); <line5> final List<RuntimeConfigurationProducer> configurationProducers = <line6> RuntimeConfigurationProducer.RUNTIME_CONFIGURATION_PRODUCER.getExtensionList(); <line7> final ArrayList<RuntimeConfigurationProducer> producers = new ArrayList<>(); <line8> for (final RuntimeConfigurationProducer prototype : configurationProducers) { <line9> final RuntimeConfigurationProducer producer; <line10> try { <line11> producer = prototype.createProducer(location, context); <line12> } catch (AbstractMethodError e) { <line13> continue; <line14> } <line15> if (producer.getConfiguration() != null) { <line16> LOG.assertTrue(producer.getSourceElement() != null, producer); <line17> producers.add(producer); <line18> } <line19> } <line20> return producers; <line21> } <line22> } <line23> "	<line13>
7280	public class A { <line0> public boolean add( <line1> MediaPackage sourceMediaPackage, <line2> AccessControlList acl, <line3> AccessControlList seriesAcl, <line4> Date deletionDate, <line5> Date modificationDate) <line6> throws SolrServerException { <line7> try { <line8> SolrInputDocument episodeDocument = createEpisodeInputDocument(sourceMediaPackage, acl); <line9> SolrInputDocument seriesDocument = <line10> createSeriesInputDocument(sourceMediaPackage.getSeries(), seriesAcl); <line11> if (seriesDocument != null) { <line12> Schema.enrich(episodeDocument, seriesDocument); <line13> } <line14> Schema.setOcModified(episodeDocument, modificationDate); <line15> if (deletionDate != null) { <line16> Schema.setOcDeleted(episodeDocument, deletionDate); <line17> } <line18> solrServer.add(episodeDocument); <line19> solrServer.add(seriesDocument); <line20> solrServer.commit(); <line21> return true; <line22> } catch (Exception e) { <line23> try { <line24> solrServer.rollback(); <line25> } catch (IOException e1) { <line26> throw new SolrServerException(e1); <line27> } <line28> throw new SolrServerException(e); <line29> } <line30> } <line31> } <line32> 	<line23>
7281	public class A { <line0> public void delete(SysExportNotiz persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	<line1>, <line3>, <line4>
7282	"public class A { <line0> @Override <line1> public void onServiceSubscribed(@Nullable String service, boolean succeeded) { <line2> if (!succeeded) { <line3> upnpSubscribed = false; <line4> updateStatus( <line5> ThingStatus.OFFLINE, <line6> ThingStatusDetail.COMMUNICATION_ERROR, <line7> ""Could not subscribe to service "" + service + ""for"" + thing.getLabel()); <line8> } <line9> } <line10> } <line11> "	<line2>
7283	"public class A { <line0> @Before <line1> public void setUp() throws Exception { <line2> resources = new ResourceResolver(getClass()); <line3> String user = ""alice""; <line4> String path = base + ""/crumbIssuer/api/json""; <line5> Crumb crumb = Unirest.get(path).basicAuth(user, user).asObject(Crumb.class).getBody(); <line6> path = base + ""/users/"" + user + ""/favorites/""; <line7> HttpResponse<String> response = <line8> Unirest.delete(path) <line9> .basicAuth(user, user) <line10> .header(crumb.getCrumbRequestField(), crumb.getCrumb()) <line11> .asString(); <line12> } <line13> } <line14> "	<line4>, <line12>
7284	public class A { <line0> public void removeLockedObjectOwner(String owner) { <line1> try { <line2> if (this.owner != null) { <line3> int size = this.owner.length; <line4> for (int i = 0; i < size; i++) { <line5> if (this.owner[i].equals(owner)) { <line6> size -= 1; <line7> String[] newLockedObjectOwner = new String[size]; <line8> for (int j = 0; j < size; j++) { <line9> if (j < i) { <line10> newLockedObjectOwner[j] = this.owner[j]; <line11> } else { <line12> newLockedObjectOwner[j] = this.owner[j + 1]; <line13> } <line14> } <line15> this.owner = newLockedObjectOwner; <line16> } <line17> } <line18> if (this.owner.length == 0) { <line19> this.owner = null; <line20> } <line21> } <line22> } catch (ArrayIndexOutOfBoundsException e) { <line23> } <line24> } <line25> } <line26> 	<line23>
7285	public class A { <line0> public String getUserName() { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> return raProperties.getUserName(); <line4> } <line5> } <line6> 	<line2>
7286	public class A { <line0> public void handleException(Exception e, Logger log, String name) { <line1> } <line2> } <line3> 	<line1>
7287	public class A { <line0> public void removeRealm(ServiceReference<JaasRealm> serviceReference) { <line1> Bundle bundle = FrameworkUtil.getBundle(UsernamePasswordRealm.class); <line2> if (null != bundle) { <line3> JaasRealm realm = bundle.getBundleContext().getService(serviceReference); <line4> realmList.remove(realm); <line5> } <line6> } <line7> } <line8> 	<line4>
7288	public class A { <line0> @Override <line1> public void warn(String msg, Throwable e) { <line2> try { <line3> } catch (Throwable t) { <line4> } <line5> } <line6> } <line7> 	<line3>
7289	public class A { <line0> private Algorithm_SuperClass findAlgorithm(String approachId) { <line1> Algorithm_SuperClass foundAlgorithm = null; <line2> try { <line3> switch (approachId) { <line4> case (Algorithms.Layers_HUSACCT_SelectedModule): <line5> foundAlgorithm = new Layers_HUSACCT_Algorithm_SelectedModule(queryService); <line6> break; <line7> case (Algorithms.Component_HUSACCT_SelectedModule): <line8> foundAlgorithm = new ComponentsAndSubSystems_HUSACCT(queryService); <line9> break; <line10> case (Algorithms.Externals_Recognition): <line11> foundAlgorithm = new ExternalSystemAlgorithm(queryService); <line12> break; <line13> case (Algorithms.CombinedAndIterative_HUSACCT_SelectedModule): <line14> foundAlgorithm = new CombinedAndIterative_Layers_Components_Subsystems(queryService); <line15> break; <line16> case (Algorithms.Layers_HUSACCT_SAEroCon2016): <line17> foundAlgorithm = new Layers_HUSACCT_Algorithm_SAEroCon2016(queryService); <line18> break; <line19> case (Algorithms.Layers_Goldstein_Root_Original): <line20> foundAlgorithm = new Layers_Goldstein_Root_Initial(queryService); <line21> break; <line22> case (Algorithms.Layers_Goldstein_HUSACCT_SelectedModule): <line23> foundAlgorithm = new Layers_Goldstein_HUSACCT_Algorithm_SelectedModule(queryService); <line24> break; <line25> case (Algorithms.Layers_Scanniello_Improved): <line26> foundAlgorithm = new Layers_Scanniello_SelectedModule_Improved(queryService); <line27> break; <line28> case (Algorithms.Layers_Scanniello_Original): <line29> foundAlgorithm = new Layers_Scanniello_Root_Initial(queryService); <line30> break; <line31> case (Algorithms.Gateways_HUSACCT_Root): <line32> foundAlgorithm = new GatewayHUSACCT_Root(queryService); <line33> break; <line34> default: <line35> foundAlgorithm = null; <line36> } <line37> } catch (Exception e) { <line38> } <line39> return foundAlgorithm; <line40> } <line41> } <line42> 	<line38>
7290	public class A { <line0> private void notifyTransactionCommand(final ZigBeeCommand command) { <line1> synchronized (outstandingTransactions) { <line2> for (final ZigBeeTransaction transaction : outstandingTransactions) { <line3> networkManager <line4> .getNotificationService() <line5> .execute( <line6> new Runnable() { <line7> @Override <line8> public void run() { <line9> transaction.commandReceived(command); <line10> } <line11> }); <line12> } <line13> } <line14> } <line15> } <line16> 	<line1>, <line3>
7291	public class A { <line0> CompletableFuture<Collection<Xid>> fetchPreparedTransactions() { <line1> try { <line2> TransactionOperationFactory factory = assertStartedAndReturnFactory(); <line3> return factory.newRecoveryOperation().execute(); <line4> } catch (Exception e) { <line5> if (log.isTraceEnabled()) { <line6> } <line7> return CompletableFuture.completedFuture(Collections.emptyList()); <line8> } <line9> } <line10> } <line11> 	<line6>
7292	public class A { <line0> @Override <line1> public RtuWriteCommand<ProfileDto> getCommand(final String node) { <line2> final RtuWriteCommand<ProfileDto> command = RTU_COMMAND_MAP.get(node); <line3> if (command == null) { <line4> } <line5> return command; <line6> } <line7> } <line8> 	<line4>
7293	"public class A { <line0> @Override <line1> public ProjectRecord createProject( <line2> String name, <line3> String description, <line4> String descriptionHtml, <line5> ProjectType type, <line6> String board, <line7> boolean privateProject, <line8> boolean sharedProject) { <line9> return createProject( <line10> name, description, descriptionHtml, """", type, board, privateProject, sharedProject, null); <line11> } <line12> } <line13> "	<line9>
7294	public class A { <line0> private void notifyHeaders(Request.HeadersListener listener, Request request) { <line1> try { <line2> listener.onHeaders(request); <line3> } catch (Throwable x) { <line4> } <line5> } <line6> } <line7> 	<line4>
7295	public class A { <line0> private FileDescriptor readFileDescriptor(File file, FileIOFactory ioFactory) { <line1> FileDescriptor ds = new FileDescriptor(file); <line2> try (SegmentIO fileIO = ds.toReadOnlyIO(ioFactory); <line3> ByteBufferExpander buf = <line4> new ByteBufferExpander(HEADER_RECORD_SIZE, ByteOrder.nativeOrder())) { <line5> final DataInput in = segmentFileInputFactory.createFileInput(fileIO, buf); <line6> final int type = in.readUnsignedByte(); <line7> if (type == RecordType.STOP_ITERATION_RECORD_TYPE) { <line8> return null; <line9> } <line10> WALPointer ptr = readPosition(in); <line11> return new FileDescriptor(file, ptr.index()); <line12> } catch (IOException e) { <line13> return null; <line14> } <line15> } <line16> } <line17> 	<line8>, <line13>
7296	public class A { <line0> private String findGroupBySID(final DirContext ctx, final String sid) throws NamingException { <line1> final LDAPSearchContext search = ensureContextFactory().getSearch(); <line2> final SearchAttribute sa = <line3> new SearchAttribute( <line4> search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.OBJECT_SID), sid); <line5> final String searchFilter = <line6> buildSearchFilter(search.getSearchGroup().getSearchFilterPrefix(), sa); <line7> final SearchControls searchControls = new SearchControls(); <line8> searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE); <line9> final NamingEnumeration<SearchResult> results = <line10> ctx.search(search.getAbsoluteBase(), searchFilter, searchControls); <line11> if (results.hasMoreElements()) { <line12> SearchResult searchResult = results.nextElement(); <line13> if (results.hasMoreElements()) { <line14> return null; <line15> } else { <line16> return addDomainPostfix( <line17> (String) <line18> searchResult <line19> .getAttributes() <line20> .get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME)) <line21> .get()); <line22> } <line23> } <line24> return null; <line25> } <line26> } <line27> 	<line14>, <line24>
7297	public class A { <line0> @ResponseBody <line1> @ExceptionHandler(Exception.class) <line2> public InhouseCmdbResponse handleException(Exception ex) { <line3> } <line4> } <line5> 	<line3>
7298	public class A { <line0> @Override <line1> public void handleTaskDoneCommandError(Connection c, CommandNIOTaskDone commandNIOTaskDone) { <line2> if (commandNIOTaskDone.canRetry()) { <line3> commandNIOTaskDone.increaseRetries(); <line4> sendNIOTaskDoneCommandSequence(commandNIOTaskDone); <line5> } else { <line6> } <line7> } <line8> } <line9> 	<line6>
7299	"public class A { <line0> private void startServer(String hostName, int port) throws IOException { <line1> try { <line2> this.server = <line3> RPC.getServer( <line4> this, <line5> hostName, <line6> port, <line7> conf.getInt(""hama.default.messenger.handler.threads.num"", 5), <line8> false, <line9> conf); <line10> server.start(); <line11> } catch (BindException e) { <line12> final int nextPort = port + 1; <line13> if (retry++ >= MAX_RETRY) { <line14> throw new RuntimeException(""RPC Server could not be launched!""); <line15> } <line16> startServer(hostName, nextPort); <line17> } <line18> } <line19> } <line20> "	<line11>, <line13>
7300	"public class A { <line0> @Override <line1> public boolean isSimCardReady() throws KuraException { <line2> boolean simReady = false; <line3> String port = null; <line4> if (isGpsEnabled() && getAtPort().equals(getGpsPort()) && !getAtPort().equals(getDataPort())) { <line5> port = getDataPort(); <line6> } else { <line7> port = getAtPort(); <line8> } <line9> synchronized (this.atLock) { <line10> byte[] reply = null; <line11> CommConnection commAtConnection = null; <line12> try { <line13> commAtConnection = openSerialPort(port); <line14> if (!isAtReachable(commAtConnection)) { <line15> throw new KuraException( <line16> KuraErrorCode.NOT_CONNECTED, MODEM_NOT_AVAILABLE + QuectelGeneric.class.getName()); <line17> } <line18> reply = <line19> commAtConnection.sendCommand( <line20> QuectelGenericAtCommands.GET_SIM_STATUS.getCommand().getBytes(), 1000, 100); <line21> if (reply != null) { <line22> String simStatus = getResponseString(reply); <line23> String[] simStatusSplit = simStatus.split("",""); <line24> if (simStatusSplit.length > 1 && Integer.valueOf(simStatusSplit[1]) > 0) { <line25> simReady = true; <line26> } <line27> } <line28> } catch (IOException e) { <line29> throw new KuraException(KuraErrorCode.UNAVAILABLE_DEVICE, e); <line30> } catch (KuraException e) { <line31> throw e; <line32> } finally { <line33> closeSerialPort(commAtConnection); <line34> } <line35> } <line36> return simReady; <line37> } <line38> } <line39> "	<line10>
7301	"public class A { <line0> public String postMultipart( <line1> String path, String fileName, InputStream data, Map<String, String> otherStringParts) <line2> throws IOException { <line3> HttpPost httpPost = new HttpPost(applicationUrl + path); <line4> MultipartEntityBuilder mpBuilder = MultipartEntityBuilder.create(); <line5> mpBuilder.addPart(""file"", new InputStreamBody(data, fileName)); <line6> if (MapUtils.isNotEmpty(otherStringParts)) { <line7> for (Entry<String, String> entry : otherStringParts.entrySet()) { <line8> mpBuilder.addTextBody(entry.getKey(), entry.getValue()); <line9> } <line10> } <line11> httpPost.setEntity(mpBuilder.build()); <line12> CloseableHttpResponse response = httpClient.execute(httpPost); <line13> return ResponseUtil.toString(response); <line14> } <line15> } <line16> "	<line3>
7302	public class A { <line0> private void concurrencyConfigurationCheck(VersionTag tag) { <line1> if (!concurrencyMessageIssued && tag == null && getConcurrencyChecksEnabled()) { <line2> concurrencyMessageIssued = true; <line3> } <line4> } <line5> } <line6> 	<line3>
7303	public class A { <line0> public boolean startGreeter(String address) { <line1> endpoints.put(address, Endpoint.publish(address, implementors.get(address))); <line2> return true; <line3> } <line4> } <line5> 	<line2>
7304	public class A { <line0> @Override <line1> protected void doExecute() throws Exception { <line2> final ScheduledFuture<?> scheduleFuture = <line3> scheduled.schedule( <line4> new AbstractExceptionLogTask() { <line5> @Override <line6> protected void doRun() throws Exception { <line7> try { <line8> command <line9> .execute() <line10> .addListener( <line11> new CommandFutureListener<V>() { <line12> @Override <line13> public void operationComplete(CommandFuture<V> commandFuture) <line14> throws Exception { <line15> if (commandFuture.isSuccess()) { <line16> future().setSuccess(commandFuture.get()); <line17> } else { <line18> future() <line19> .setFailure(ExceptionUtils.getRootCause(commandFuture.cause())); <line20> } <line21> } <line22> }); <line23> } catch (Exception e) { <line24> future().setFailure(ExceptionUtils.getRootCause(e)); <line25> } <line26> } <line27> }, <line28> time, <line29> timeUnit); <line30> future() <line31> .addListener( <line32> new CommandFutureListener<V>() { <line33> @Override <line34> public void operationComplete(CommandFuture<V> commandFuture) throws Exception { <line35> if (commandFuture.isCancelled()) { <line36> command.future().cancel(true); <line37> scheduleFuture.cancel(false); <line38> } <line39> } <line40> }); <line41> } <line42> } <line43> 	<line36>
7305	"public class A { <line0> public static APPlatformController getInstance(String controllerId) <line1> throws ControllerLookupException { <line2> String controllerFullId = APPlatformController.JNDI_PREFIX + controllerId; <line3> try { <line4> InitialContext context = new InitialContext(); <line5> Object lookup = context.lookup(controllerFullId); <line6> APPlatformController adapter; <line7> if (APPlatformController.class.isAssignableFrom(lookup.getClass())) { <line8> adapter = new APPlatformControllerAdapter((APPlatformController) lookup); <line9> } else if (org.oscm.app.v1_0.intf.APPlatformController.class.isAssignableFrom( <line10> lookup.getClass())) { <line11> adapter = <line12> new APPlatformControllerLegacyAdapter( <line13> (org.oscm.app.v1_0.intf.APPlatformController) lookup); <line14> } else { <line15> throw new ControllerLookupException(Messages.getAll(""error_controller_lookup"")); <line16> } <line17> return adapter; <line18> } catch (Exception e) { <line19> throw new ControllerLookupException(Messages.getAll(""error_controller_lookup""), e); <line20> } <line21> } <line22> } <line23> "	<line15>, <line19>
7306	"public class A { <line0> private void _upgradeDB( <line1> ClassLoader classLoader, <line2> String buildNamespace, <line3> long buildNumber, <line4> ServiceComponent previousServiceComponent, <line5> String tablesSQL, <line6> String sequencesSQL, <line7> String indexesSQL) <line8> throws Exception { <line9> DB db = DBManagerUtil.getDB(); <line10> if (previousServiceComponent == null) { <line11> if (_log.isInfoEnabled()) { <line12> } <line13> db.runSQLTemplateString(tablesSQL, false); <line14> db.runSQLTemplateString(sequencesSQL, false); <line15> db.runSQLTemplateString(indexesSQL, false); <line16> } else if (PropsValues.SCHEMA_MODULE_BUILD_AUTO_UPGRADE) { <line17> if (_log.isWarnEnabled()) { <line18> StringBundler sb = new StringBundler(7); <line19> sb.append(""Auto upgrading ""); <line20> sb.append(buildNamespace); <line21> sb.append("" database to build number ""); <line22> sb.append(buildNumber); <line23> sb.append("" is not supported for a production environment. ""); <line24> sb.append(""Write an UpgradeStep to ensure data is upgraded ""); <line25> sb.append(""correctly.""); <line26> } <line27> if (!tablesSQL.equals(previousServiceComponent.getTablesSQL())) { <line28> if (_log.isInfoEnabled()) { <line29> } <line30> db.runSQLTemplateString(tablesSQL, false); <line31> upgradeModels(classLoader, previousServiceComponent, tablesSQL); <line32> } <line33> if (!sequencesSQL.equals(previousServiceComponent.getSequencesSQL())) { <line34> if (_log.isInfoEnabled()) { <line35> } <line36> db.runSQLTemplateString(sequencesSQL, false); <line37> } <line38> if (!indexesSQL.equals(previousServiceComponent.getIndexesSQL()) <line39> || !tablesSQL.equals(previousServiceComponent.getTablesSQL())) { <line40> if (_log.isInfoEnabled()) { <line41> } <line42> db.runSQLTemplateString(indexesSQL, false); <line43> } <line44> } <line45> } <line46> } <line47> "	<line12>, <line26>, <line29>, <line35>, <line41>
7307	"public class A { <line0> private void restoreFullSchema(Connection conn, Long schemaID) <line1> throws SQLException, InvalidSchemaError { <line2> PreparedStatement p = <line3> conn.prepareStatement( <line4> ""SELECT "" <line5> + ""d.id AS dbId,"" <line6> + ""d.name AS dbName,"" <line7> + ""d.charset AS dbCharset,"" <line8> + ""t.name AS tableName,"" <line9> + ""t.charset AS tableCharset,"" <line10> + ""t.pk AS tablePk,"" <line11> + ""t.id AS tableId,"" <line12> + ""c.column_length AS columnLength,"" <line13> + ""c.enum_values AS columnEnumValues,"" <line14> + ""c.name AS columnName,"" <line15> + ""c.charset AS columnCharset,"" <line16> + ""c.coltype AS columnColtype,"" <line17> + ""c.is_signed AS columnIsSigned "" <line18> + ""FROM `databases` d "" <line19> + ""LEFT JOIN tables t ON d.id = t.database_id "" <line20> + ""LEFT JOIN columns c ON c.table_id=t.id "" <line21> + ""WHERE d.schema_id = ? "" <line22> + ""ORDER BY d.id, t.id, c.id""); <line23> p.setLong(1, this.schemaID); <line24> ResultSet rs = p.executeQuery(); <line25> Database currentDatabase = null; <line26> Table currentTable = null; <line27> short columnIndex = 0; <line28> while (rs.next()) { <line29> String dbName = rs.getString(""dbName""); <line30> String dbCharset = rs.getString(""dbCharset""); <line31> String tName = rs.getString(""tableName""); <line32> String tCharset = rs.getString(""tableCharset""); <line33> String tPKs = rs.getString(""tablePk""); <line34> String columnName = rs.getString(""columnName""); <line35> int columnLengthInt = rs.getInt(""columnLength""); <line36> String columnEnumValues = rs.getString(""columnEnumValues""); <line37> String columnCharset = rs.getString(""columnCharset""); <line38> String columnType = rs.getString(""columnColtype""); <line39> int columnIsSigned = rs.getInt(""columnIsSigned""); <line40> if (currentDatabase == null || !currentDatabase.getName().equals(dbName)) { <line41> currentDatabase = new Database(dbName, dbCharset); <line42> this.schema.addDatabase(currentDatabase); <line43> currentTable = null; <line44> } <line45> if (tName == null) { <line46> continue; <line47> } else if (currentTable == null || !currentTable.getName().equals(tName)) { <line48> currentTable = currentDatabase.buildTable(tName, tCharset); <line49> if (tPKs != null) { <line50> List<String> pkList = Arrays.asList(StringUtils.split(tPKs, ',')); <line51> currentTable.setPKList(pkList); <line52> } <line53> columnIndex = 0; <line54> } <line55> if (columnName == null) { <line56> continue; <line57> } <line58> Long columnLength; <line59> if (rs.wasNull()) { <line60> columnLength = null; <line61> } else { <line62> columnLength = Long.valueOf(columnLengthInt); <line63> } <line64> String[] enumValues = null; <line65> if (columnEnumValues != null) { <line66> if (this.schemaVersion >= 4) { <line67> try { <line68> enumValues = mapper.readValue(columnEnumValues, String[].class); <line69> } catch (IOException e) { <line70> throw new SQLException(e); <line71> } <line72> } else { <line73> enumValues = StringUtils.splitByWholeSeparatorPreserveAllTokens(columnEnumValues, "",""); <line74> } <line75> } <line76> ColumnDef c = <line77> ColumnDef.build( <line78> columnName, <line79> columnCharset, <line80> columnType, <line81> columnIndex++, <line82> columnIsSigned == 1, <line83> enumValues, <line84> columnLength); <line85> currentTable.addColumn(c); <line86> } <line87> rs.close(); <line88> } <line89> } <line90> "	<line44>, <line88>
7308	"public class A { <line0> @GET <line1> @Path(""/{cluster}/namespaceIsolationPolicies/brokers/{broker}"") <line2> @ApiOperation( <line3> value = ""Get a broker with namespace-isolation policies attached to it."", <line4> response = BrokerNamespaceIsolationData.class, <line5> notes = ""This operation requires Pulsar superuser privileges."") <line6> @ApiResponses( <line7> value = { <line8> @ApiResponse(code = 403, message = ""Don't have admin permission.""), <line9> @ApiResponse(code = 404, message = ""Namespace-isolation policies/ Broker not found.""), <line10> @ApiResponse(code = 412, message = ""Cluster doesn't exist.""), <line11> @ApiResponse(code = 500, message = ""Internal server error."") <line12> }) <line13> public BrokerNamespaceIsolationData getBrokerWithNamespaceIsolationPolicy( <line14> @ApiParam(value = ""The cluster name"", required = true) @PathParam(""cluster"") String cluster, <line15> @ApiParam( <line16> value = ""The broker name (<broker-hostname>:<web-service-port>)"", <line17> required = true, <line18> example = ""broker1:8080"") <line19> @PathParam(""broker"") <line20> String broker) { <line21> validateSuperUserAccess(); <line22> validateClusterExists(cluster); <line23> final String nsIsolationPoliciesPath = <line24> AdminResource.path(""clusters"", cluster, NAMESPACE_ISOLATION_POLICIES); <line25> Map<String, NamespaceIsolationData> nsPolicies; <line26> try { <line27> Optional<NamespaceIsolationPolicies> nsPoliciesResult = <line28> namespaceIsolationPolicies().getPolicies(nsIsolationPoliciesPath); <line29> if (!nsPoliciesResult.isPresent()) { <line30> throw new RestException( <line31> Status.NOT_FOUND, ""namespace-isolation policies not found for "" + cluster); <line32> } <line33> nsPolicies = nsPoliciesResult.get().getPolicies(); <line34> } catch (Exception e) { <line35> throw new RestException(e); <line36> } <line37> BrokerNamespaceIsolationData brokerIsolationData = new BrokerNamespaceIsolationData(); <line38> brokerIsolationData.brokerName = broker; <line39> if (nsPolicies != null) { <line40> nsPolicies.forEach( <line41> (name, policyData) -> { <line42> NamespaceIsolationPolicyImpl nsPolicyImpl = <line43> new NamespaceIsolationPolicyImpl(policyData); <line44> boolean isPrimary = nsPolicyImpl.isPrimaryBroker(broker); <line45> if (isPrimary || nsPolicyImpl.isSecondaryBroker(broker)) { <line46> if (brokerIsolationData.namespaceRegex == null) { <line47> brokerIsolationData.namespaceRegex = Lists.newArrayList(); <line48> } <line49> brokerIsolationData.namespaceRegex.addAll(policyData.namespaces); <line50> brokerIsolationData.isPrimary = isPrimary; <line51> brokerIsolationData.policyName = name; <line52> } <line53> }); <line54> } <line55> return brokerIsolationData; <line56> } <line57> } <line58> "	<line35>
7309	public class A { <line0> protected void doRollback() { <line1> try { <line2> contentTracker.getWriteLock().acquire(); <line3> assert (contentTracker.getWriteLock().availablePermits() == 0); <line4> if (cascadeTracker.isPresent()) { <line5> cascadeTracker.get().getWriteLock().acquire(); <line6> assert (cascadeTracker.get().getWriteLock().availablePermits() == 0); <line7> } <line8> infoSrv.rollback(); <line9> if (aclTracker.getRollbackCausedBy() != null) { <line10> } <line11> if (metadataTracker.getRollbackCausedBy() != null) { <line12> } <line13> } catch (Exception e) { <line14> } finally { <line15> aclTracker.setRollback(false, null); <line16> aclTracker.invalidateState(); <line17> metadataTracker.setRollback(false, null); <line18> metadataTracker.invalidateState(); <line19> contentTracker.setRollback(false, null); <line20> contentTracker.invalidateState(); <line21> cascadeTracker.ifPresent(c -> c.setRollback(false, null)); <line22> cascadeTracker.ifPresent(c -> invalidateState()); <line23> contentTracker.getWriteLock().release(); <line24> cascadeTracker.ifPresent(c -> c.getWriteLock().release()); <line25> rollbackCount.incrementAndGet(); <line26> } <line27> } <line28> } <line29> 	<line10>, <line12>, <line14>
7310	"public class A { <line0> @Override <line1> public boolean execute(Context context) throws Exception { <line2> boolean result = ERROR; <line3> Monitor monitor = MonitorFactory.start(COMMAND); <line4> try { <line5> JobData jobData = (JobData) context.get(JOB_DATA); <line6> jobData.setOutputFilename(""export_"" + jobData.getType() + ""_"" + jobData.getId() + "".zip""); <line7> context.put(REFERENTIAL, new Referential()); <line8> Metadata metadata = new Metadata(); <line9> metadata.setDate(Calendar.getInstance()); <line10> metadata.setFormat(""text/csv""); <line11> metadata.setTitle(""Export GTFS ""); <line12> try { <line13> metadata.setRelation(new URL(""https://developers.google.com/transit/gtfs/reference"")); <line14> } catch (MalformedURLException e1) { <line15> } <line16> context.put(METADATA, metadata); <line17> Path path = Paths.get(jobData.getPathName(), OUTPUT); <line18> if (!Files.exists(path)) { <line19> Files.createDirectories(path); <line20> } <line21> GtfsExporter gtfsExporter = new GtfsExporter(path.toString()); <line22> context.put(GTFS_EXPORTER, gtfsExporter); <line23> result = SUCCESS; <line24> } catch (Exception e) { <line25> throw e; <line26> } finally { <line27> } <line28> return result; <line29> } <line30> } <line31> "	<line15>, <line25>, <line27>
7311	public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntrySoap[] getFileEntries( <line1> long repositoryId, long folderId) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.portal.kernel.repository.model.FileEntry> returnValue = <line4> DLAppServiceUtil.getFileEntries(repositoryId, folderId); <line5> return com.liferay.portal.kernel.repository.model.FileEntrySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>
7312	"public class A { <line0> private void setupRift() { <line1> Hmd.initialize(); <line2> try { <line3> Thread.sleep(400); <line4> } catch (InterruptedException e) { <line5> throw new IllegalStateException(e); <line6> } <line7> hmd = Hmd.create(); <line8> if (null == hmd) { <line9> throw new IllegalStateException(""Unable to initialize HMD""); <line10> } <line11> hmdDesc = hmd.getDesc(); <line12> hmd.recenterPose(); <line13> } <line14> } <line15> "	<line13>
7313	public class A { <line0> private Mono<Result> createMailbox(MailboxPath path) { <line1> return Mono.fromRunnable( <line2> () -> { <line3> MailboxSession ownerSession = mailboxManager.createSystemSession(path.getUser()); <line4> Optional<MailboxId> mailboxId = <line5> Throwing.supplier(() -> mailboxManager.createMailbox(path, ownerSession)) <line6> .sneakyThrow() <line7> .get(); <line8> recordSuccess(mailboxId); <line9> }) <line10> .then(Mono.just(Result.COMPLETED)) <line11> .onErrorResume( <line12> e -> { <line13> recordFailure(path); <line14> return Mono.just(Result.PARTIAL); <line15> }); <line16> } <line17> } <line18> 	<line13>
7314	"public class A { <line0> public synchronized void run() { <line1> try { <line2> Map<String, List<Number>> stats = getStatsByKey(); <line3> StringBuilder buf = getCSVBuf(stats); <line4> final FileWriter fw = getFileWriter(); <line5> fw.append(buf.append(""\n"").toString()); <line6> fw.flush(); <line7> } catch (Throwable e) { <line8> } <line9> } <line10> } <line11> "	<line8>
7315	public class A { <line0> @Override <line1> public void commit(EKBCommit commit) throws SanityCheckException, EKBException { <line2> runPersistingLogic(commit, true, null, false); <line3> } <line4> } <line5> 	<line2>, <line3>
7316	"public class A { <line0> protected Runner startWithArgs(String[] args, String startedAfterString, RunTypes type) <line1> throws IOException { <line2> outContent = new ByteArrayOutputStream(); <line3> errContent = new ByteArrayOutputStream(); <line4> PipedOutputStream out = new PipedOutputStream(); <line5> PipedInputStream in = new PipedInputStream(out); <line6> PrintStream stdinPrintStream = new PrintStream(out); <line7> System.setOut(new PrintStream(outContent)); <line8> System.setErr(new PrintStream(errContent)); <line9> System.setIn(in); <line10> final int startTimeoutSeconds = 60; <line11> Runner runner = <line12> new Runner( <line13> args, <line14> flinkConfiguration, <line15> CliFrontend.getConfigurationDirectoryFromEnv(), <line16> type, <line17> 0, <line18> stdinPrintStream); <line19> runner.setName(""Frontend (CLI/YARN Client) runner thread (startWithArgs()).""); <line20> runner.start(); <line21> for (int second = 0; second < startTimeoutSeconds; second++) { <line22> sleep(1000); <line23> if (outContent.toString().contains(startedAfterString) <line24> || errContent.toString().contains(startedAfterString)) { <line25> return runner; <line26> } <line27> if (!runner.isAlive()) { <line28> resetStreamsAndSendOutput(); <line29> if (runner.getRunnerError() != null) { <line30> throw new RuntimeException(""Runner failed with exception."", runner.getRunnerError()); <line31> } <line32> Assert.fail(""Runner thread died before the test was finished.""); <line33> } <line34> } <line35> resetStreamsAndSendOutput(); <line36> Assert.fail( <line37> ""During the timeout period of "" <line38> + startTimeoutSeconds <line39> + "" seconds the "" <line40> + ""expected string did not show up""); <line41> return null; <line42> } <line43> } <line44> "	<line2>, <line25>
7317	public class A { <line0> public static InetAddress getInetAddress(final int address) { <line1> InetAddress ip = null; <line2> try { <line3> ip = InetAddress.getByAddress(NetUtils.intToByteArray4(address)); <line4> } catch (final UnknownHostException e) { <line5> } <line6> return ip; <line7> } <line8> } <line9> 	<line5>
7318	"public class A { <line0> @Override <line1> public void initialize() { <line2> HDPowerViewHubConfiguration config = getConfigAs(HDPowerViewHubConfiguration.class); <line3> String host = config.host; <line4> if (host == null || host.isEmpty()) { <line5> updateStatus( <line6> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Host address must be set""); <line7> return; <line8> } <line9> webTargets = new HDPowerViewWebTargets(httpClient, host); <line10> refreshInterval = config.refresh; <line11> hardRefreshInterval = config.hardRefresh; <line12> schedulePoll(); <line13> } <line14> } <line15> "	<line2>
7319	"public class A { <line0> private boolean doStartOsgiAfterBundlesRefreshed() { <line1> if (startedOsgiAfterBundlesRefreshed.getAndSet(true)) { <line2> return false; <line3> } <line4> doStartOsgi(); <line5> Object newStartLevelS = null; <line6> try { <line7> newStartLevelS = getBrooklynProperties().getConfig(BROOKLYN_OSGI_STARTLEVEL_POSTINIT); <line8> if (newStartLevelS == null || Strings.isBlank("""" + newStartLevelS)) { <line9> } else { <line10> FrameworkStartLevel fsl = <line11> FrameworkUtil.getBundle(this.getClass()) <line12> .getBundleContext() <line13> .getBundle(0) <line14> .adapt(FrameworkStartLevel.class); <line15> int newStartLevel = TypeCoercions.coerce(newStartLevelS, Integer.class); <line16> if (fsl.getStartLevel() < newStartLevel) { <line17> fsl.setStartLevel(newStartLevel); <line18> } else { <line19> } <line20> } <line21> } catch (Exception e) { <line22> } <line23> return true; <line24> } <line25> } <line26> "	<line2>, <line9>, <line17>, <line19>, <line22>
7320	"public class A { <line0> public static void runCommand(String command) { <line1> try { <line2> String[] commands = new String[] {""sh"", ""-c"", ""\"""" + command + ""\""""}; <line3> Process p = Runtime.getRuntime().exec(commands); <line4> BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); <line5> BufferedReader err = new BufferedReader(new InputStreamReader(p.getErrorStream())); <line6> String line; <line7> StringBuilder sb = new StringBuilder(); <line8> while ((line = in.readLine()) != null) { <line9> sb.append(line + ""\n""); <line10> } <line11> String stdOutput = sb.toString(); <line12> if (!stdOutput.isEmpty()) { <line13> } <line14> in.close(); <line15> sb = new StringBuilder(); <line16> while ((line = err.readLine()) != null) { <line17> sb.append(line + ""\n""); <line18> } <line19> String errOutput = sb.toString(); <line20> if (!errOutput.isEmpty()) { <line21> } <line22> err.close(); <line23> } catch (IOException e) { <line24> e.printStackTrace(); <line25> } <line26> } <line27> } <line28> "	<line3>, <line13>, <line21>, <line24>
